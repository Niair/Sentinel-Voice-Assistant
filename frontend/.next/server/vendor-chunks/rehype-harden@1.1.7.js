"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-harden@1.1.7";
exports.ids = ["vendor-chunks/rehype-harden@1.1.7"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/rehype-harden@1.1.7/node_modules/rehype-harden/dist/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/rehype-harden@1.1.7/node_modules/rehype-harden/dist/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   harden: () => (/* binding */ harden)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/.pnpm/unist-util-visit@5.0.0/node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/.pnpm/unist-util-visit-parents@6.0.2/node_modules/unist-util-visit-parents/lib/index.js\");\n\nfunction harden({ defaultOrigin = \"\", allowedLinkPrefixes = [], allowedImagePrefixes = [], allowDataImages = false, allowedProtocols = [], blockedImageClass = \"inline-block bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400 px-3 py-1 rounded text-sm\", blockedLinkClass = \"text-gray-500\" }) {\n    // Only require defaultOrigin if we have specific prefixes (not wildcard only)\n    const hasSpecificLinkPrefixes = allowedLinkPrefixes.length && !allowedLinkPrefixes.every((p)=>p === \"*\");\n    const hasSpecificImagePrefixes = allowedImagePrefixes.length && !allowedImagePrefixes.every((p)=>p === \"*\");\n    if (!defaultOrigin && (hasSpecificLinkPrefixes || hasSpecificImagePrefixes)) {\n        throw new Error(\"defaultOrigin is required when allowedLinkPrefixes or allowedImagePrefixes are provided\");\n    }\n    return (tree)=>{\n        const visitor = createVisitor(defaultOrigin, allowedLinkPrefixes, allowedImagePrefixes, allowDataImages, allowedProtocols, blockedImageClass, blockedLinkClass);\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, visitor);\n    };\n}\nfunction parseUrl(url, defaultOrigin) {\n    if (typeof url !== \"string\") return null;\n    try {\n        // Try to parse as absolute URL first\n        return new URL(url);\n    } catch  {\n        // If that fails and we have a defaultOrigin, try with it\n        if (defaultOrigin) {\n            try {\n                return new URL(url, defaultOrigin);\n            } catch  {\n                return null;\n            }\n        }\n        // For relative URLs without defaultOrigin, use a dummy base to parse them\n        // This allows wildcard \"*\" to work with relative URLs\n        if (url.startsWith(\"/\") || url.startsWith(\"./\") || url.startsWith(\"../\")) {\n            try {\n                return new URL(url, \"http://example.com\");\n            } catch  {\n                return null;\n            }\n        }\n        return null;\n    }\n}\nfunction isPathRelativeUrl(url) {\n    if (typeof url !== \"string\") return false;\n    return url.startsWith(\"/\") || url.startsWith(\"./\") || url.startsWith(\"../\");\n}\nconst safeProtocols = new Set([\n    \"https:\",\n    \"http:\",\n    \"irc:\",\n    \"ircs:\",\n    \"mailto:\",\n    \"xmpp:\",\n    \"blob:\"\n]);\n// Protocols that should NEVER be allowed for security reasons\nconst blockedProtocols = new Set([\n    \"javascript:\",\n    \"data:\",\n    \"file:\",\n    \"vbscript:\"\n]);\nfunction transformUrl(url, allowedPrefixes, defaultOrigin, allowDataImages = false, isImage = false, allowedProtocols = []) {\n    if (!url) return null;\n    // Allow hash-only (fragment-only) URLs - they navigate within the current page\n    if (typeof url === \"string\" && url.startsWith(\"#\") && !isImage) {\n        // Hash-only URLs don't need defaultOrigin validation\n        // Just verify it's a valid fragment identifier\n        try {\n            // Use a dummy base to validate the hash format\n            const testUrl = new URL(url, \"http://example.com\");\n            if (testUrl.hash === url) {\n                return url;\n            }\n        } catch  {\n        // Invalid hash format, fall through to normal validation\n        }\n    }\n    // Handle data: URLs for images if allowDataImages is enabled\n    if (typeof url === \"string\" && url.startsWith(\"data:\")) {\n        // Only allow data: URLs for images when explicitly enabled\n        if (isImage && allowDataImages && url.startsWith(\"data:image/\")) {\n            return url;\n        }\n        return null;\n    }\n    // Handle blob: URLs - these are browser-generated URLs for local objects\n    if (typeof url === \"string\" && url.startsWith(\"blob:\")) {\n        // blob: URLs are valid and safe - they reference in-memory objects\n        // They can only reference content already loaded in the browser\n        try {\n            // Validate it's a properly formatted blob URL\n            // blob: URLs should have the format: blob:<origin>/<uuid> or blob:null/<uuid>\n            const blobUrl = new URL(url);\n            if (blobUrl.protocol === \"blob:\" && url.length > 5) {\n                // Ensure there's actual content after \"blob:\"\n                const afterProtocol = url.substring(5);\n                if (afterProtocol && afterProtocol.length > 0 && afterProtocol !== \"invalid\") {\n                    return url;\n                }\n            }\n        } catch  {\n            return null;\n        }\n        // If we get here, the blob URL is malformed\n        return null;\n    }\n    const parsedUrl = parseUrl(url, defaultOrigin);\n    if (!parsedUrl) return null;\n    // Block dangerous protocols - these should NEVER be allowed\n    // Exception: data: is allowed for images if allowDataImages is true (handled above)\n    if (blockedProtocols.has(parsedUrl.protocol)) {\n        return null;\n    }\n    // Check if protocol is allowed\n    const isProtocolAllowed = safeProtocols.has(parsedUrl.protocol) || allowedProtocols.includes(parsedUrl.protocol) || allowedProtocols.includes(\"*\");\n    if (!isProtocolAllowed) return null;\n    // mailto: and other custom protocols can just return as-is\n    if (parsedUrl.protocol === \"mailto:\" || !parsedUrl.protocol.match(/^https?:$/)) {\n        return parsedUrl.href;\n    }\n    // If the input is path relative, we output a path relative URL as well,\n    // however, we always run the same checks on an absolute URL and we\n    // always reconstruct the output from the parsed URL to ensure that\n    // the output is always a valid URL.\n    const inputWasRelative = isPathRelativeUrl(url);\n    if (parsedUrl && allowedPrefixes.some((prefix)=>{\n        const parsedPrefix = parseUrl(prefix, defaultOrigin);\n        if (!parsedPrefix) {\n            return false;\n        }\n        if (parsedPrefix.origin !== parsedUrl.origin) {\n            return false;\n        }\n        return parsedUrl.href.startsWith(parsedPrefix.href);\n    })) {\n        if (inputWasRelative) {\n            return parsedUrl.pathname + parsedUrl.search + parsedUrl.hash;\n        }\n        return parsedUrl.href;\n    }\n    // Check for wildcard - allow all URLs\n    if (allowedPrefixes.includes(\"*\")) {\n        // Wildcard only allows http and https URLs\n        if (parsedUrl.protocol !== \"https:\" && parsedUrl.protocol !== \"http:\") {\n            return null;\n        }\n        if (inputWasRelative) {\n            return parsedUrl.pathname + parsedUrl.search + parsedUrl.hash;\n        }\n        return parsedUrl.href;\n    }\n    return null;\n}\nconst SEEN = Symbol(\"node-seen\");\nconst createVisitor = (defaultOrigin, allowedLinkPrefixes, allowedImagePrefixes, allowDataImages, allowedProtocols, blockedImageClass, blockedLinkClass)=>{\n    const visitor = (node, index, parent)=>{\n        if (node.type !== \"element\" || // @ts-expect-error\n        node[SEEN]) {\n            return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n        }\n        if (node.tagName === \"a\") {\n            const transformedUrl = transformUrl(node.properties.href, allowedLinkPrefixes, defaultOrigin, false, false, allowedProtocols);\n            if (transformedUrl === null) {\n                // @ts-expect-error\n                node[SEEN] = true;\n                // We need to eagerly visit children so that we catch any nested nastiness as well,\n                // prior to modifying the node's parent.\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(node, visitor);\n                if (parent && typeof index === \"number\") {\n                    parent.children[index] = {\n                        type: \"element\",\n                        tagName: \"span\",\n                        properties: {\n                            title: \"Blocked URL: \" + String(node.properties.href),\n                            class: blockedLinkClass\n                        },\n                        children: [\n                            ...node.children,\n                            {\n                                type: \"text\",\n                                value: \" [blocked]\"\n                            }\n                        ]\n                    };\n                }\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.SKIP;\n            } else {\n                node.properties.href = transformedUrl;\n                node.properties.target = \"_blank\";\n                node.properties.rel = \"noopener noreferrer\";\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n            }\n        }\n        if (node.tagName === \"img\") {\n            const transformedUrl = transformUrl(node.properties.src, allowedImagePrefixes, defaultOrigin, allowDataImages, true, allowedProtocols);\n            if (transformedUrl === null) {\n                // @ts-expect-error\n                node[SEEN] = true;\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(node, visitor);\n                if (parent && typeof index === \"number\") {\n                    parent.children[index] = {\n                        type: \"element\",\n                        tagName: \"span\",\n                        properties: {\n                            class: blockedImageClass\n                        },\n                        children: [\n                            {\n                                type: \"text\",\n                                value: \"[Image blocked: \" + String(node.properties.alt || \"No description\") + \"]\"\n                            }\n                        ]\n                    };\n                }\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.SKIP;\n            } else {\n                node.properties.src = transformedUrl;\n                return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n            }\n        }\n        return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.CONTINUE;\n    };\n    return visitor;\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVoeXBlLWhhcmRlbkAxLjEuNy9ub2RlX21vZHVsZXMvcmVoeXBlLWhhcmRlbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RDtBQUNsRCxTQUFTRyxPQUFPLEVBQUVDLGdCQUFnQixFQUFFLEVBQUVDLHNCQUFzQixFQUFFLEVBQUVDLHVCQUF1QixFQUFFLEVBQUVDLGtCQUFrQixLQUFLLEVBQUVDLG1CQUFtQixFQUFFLEVBQUVDLG9CQUFvQixzR0FBc0csRUFBRUMsbUJBQW1CLGVBQWUsRUFBRztJQUMvUyw4RUFBOEU7SUFDOUUsTUFBTUMsMEJBQTBCTixvQkFBb0JPLE1BQU0sSUFBSSxDQUFDUCxvQkFBb0JRLEtBQUssQ0FBQyxDQUFDQyxJQUFNQSxNQUFNO0lBQ3RHLE1BQU1DLDJCQUEyQlQscUJBQXFCTSxNQUFNLElBQ3hELENBQUNOLHFCQUFxQk8sS0FBSyxDQUFDLENBQUNDLElBQU1BLE1BQU07SUFDN0MsSUFBSSxDQUFDVixpQkFBa0JPLENBQUFBLDJCQUEyQkksd0JBQXVCLEdBQUk7UUFDekUsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsT0FBTyxDQUFDQztRQUNKLE1BQU1DLFVBQVVDLGNBQWNmLGVBQWVDLHFCQUFxQkMsc0JBQXNCQyxpQkFBaUJDLGtCQUFrQkMsbUJBQW1CQztRQUM5SVIsdURBQUtBLENBQUNlLE1BQU1DO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTRSxTQUFTQyxHQUFHLEVBQUVqQixhQUFhO0lBQ2hDLElBQUksT0FBT2lCLFFBQVEsVUFDZixPQUFPO0lBQ1gsSUFBSTtRQUNBLHFDQUFxQztRQUNyQyxPQUFPLElBQUlDLElBQUlEO0lBQ25CLEVBQ0EsT0FBTTtRQUNGLHlEQUF5RDtRQUN6RCxJQUFJakIsZUFBZTtZQUNmLElBQUk7Z0JBQ0EsT0FBTyxJQUFJa0IsSUFBSUQsS0FBS2pCO1lBQ3hCLEVBQ0EsT0FBTTtnQkFDRixPQUFPO1lBQ1g7UUFDSjtRQUNBLDBF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QUlvQyxVQUFVLE9BQU9ELFVBQVUsVUFBVTtvQkFDckNDLE9BQU9LLFFBQVEsQ0FBQ04sTUFBTSxHQUFHO3dCQUNyQkUsTUFBTTt3QkFDTkMsU0FBUzt3QkFDVEUsWUFBWTs0QkFDUkksT0FBT3JEO3dCQUNYO3dCQUNBa0QsVUFBVTs0QkFDTjtnQ0FDSUosTUFBTTtnQ0FDTlEsT0FBTyxxQkFDSEYsT0FBT1QsS0FBS00sVUFBVSxDQUFDUyxHQUFHLElBQUksb0JBQzlCOzRCQUNSO3lCQUNIO29CQUNMO2dCQUNKO2dCQUNBLE9BQU9sRSxrREFBSUE7WUFDZixPQUNLO2dCQUNEbUQsS0FBS00sVUFBVSxDQUFDUSxHQUFHLEdBQUdUO2dCQUN0QixPQUFPekQsc0RBQVFBO1lBQ25CO1FBQ0o7UUFDQSxPQUFPQSxzREFBUUE7SUFDbkI7SUFDQSxPQUFPa0I7QUFDWCxHQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlaHlwZS1oYXJkZW5AMS4xLjcvbm9kZV9tb2R1bGVzL3JlaHlwZS1oYXJkZW4vZGlzdC9pbmRleC5qcz8wYTAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENPTlRJTlVFLCBTS0lQLCB2aXNpdCB9IGZyb20gXCJ1bmlzdC11dGlsLXZpc2l0XCI7XG5leHBvcnQgZnVuY3Rpb24gaGFyZGVuKHsgZGVmYXVsdE9yaWdpbiA9IFwiXCIsIGFsbG93ZWRMaW5rUHJlZml4ZXMgPSBbXSwgYWxsb3dlZEltYWdlUHJlZml4ZXMgPSBbXSwgYWxsb3dEYXRhSW1hZ2VzID0gZmFsc2UsIGFsbG93ZWRQcm90b2NvbHMgPSBbXSwgYmxvY2tlZEltYWdlQ2xhc3MgPSBcImlubGluZS1ibG9jayBiZy1ncmF5LTIwMCBkYXJrOmJnLWdyYXktNzAwIHRleHQtZ3JheS02MDAgZGFyazp0ZXh0LWdyYXktNDAwIHB4LTMgcHktMSByb3VuZGVkIHRleHQtc21cIiwgYmxvY2tlZExpbmtDbGFzcyA9IFwidGV4dC1ncmF5LTUwMFwiLCB9KSB7XG4gICAgLy8gT25seSByZXF1aXJlIGRlZmF1bHRPcmlnaW4gaWYgd2UgaGF2ZSBzcGVjaWZpYyBwcmVmaXhlcyAobm90IHdpbGRjYXJkIG9ubHkpXG4gICAgY29uc3QgaGFzU3BlY2lmaWNMaW5rUHJlZml4ZXMgPSBhbGxvd2VkTGlua1ByZWZpeGVzLmxlbmd0aCAmJiAhYWxsb3dlZExpbmtQcmVmaXhlcy5ldmVyeSgocCkgPT4gcCA9PT0gXCIqXCIpO1xuICAgIGNvbnN0IGhhc1NwZWNpZmljSW1hZ2VQcmVmaXhlcyA9IGFsbG93ZWRJbWFnZVByZWZpeGVzLmxlbmd0aCAmJlxuICAgICAgICAhYWxsb3dlZEltYWdlUHJlZml4ZXMuZXZlcnkoKHApID0+IHAgPT09IFwiKlwiKTtcbiAgICBpZiAoIWRlZmF1bHRPcmlnaW4gJiYgKGhhc1NwZWNpZmljTGlua1ByZWZpeGVzIHx8IGhhc1NwZWNpZmljSW1hZ2VQcmVmaXhlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdE9yaWdpbiBpcyByZXF1aXJlZCB3aGVuIGFsbG93ZWRMaW5rUHJlZml4ZXMgb3IgYWxsb3dlZEltYWdlUHJlZml4ZXMgYXJlIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKHRyZWUpID0+IHtcbiAgICAgICAgY29uc3QgdmlzaXRvciA9IGNyZWF0ZVZpc2l0b3IoZGVmYXVsdE9yaWdpbiwgYWxsb3dlZExpbmtQcmVmaXhlcywgYWxsb3dlZEltYWdlUHJlZml4ZXMsIGFsbG93RGF0YUltYWdlcywgYWxsb3dlZFByb3RvY29scywgYmxvY2tlZEltYWdlQ2xhc3MsIGJsb2NrZWRMaW5rQ2xhc3MpO1xuICAgICAgICB2aXNpdCh0cmVlLCB2aXNpdG9yKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VVcmwodXJsLCBkZWZhdWx0T3JpZ2luKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBhYnNvbHV0ZSBVUkwgZmlyc3RcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBJZiB0aGF0IGZhaWxzIGFuZCB3ZSBoYXZlIGEgZGVmYXVsdE9yaWdpbiwgdHJ5IHdpdGggaXRcbiAgICAgICAgaWYgKGRlZmF1bHRPcmlnaW4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsLCBkZWZhdWx0T3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgcmVsYXRpdmUgVVJMcyB3aXRob3V0IGRlZmF1bHRPcmlnaW4sIHVzZSBhIGR1bW15IGJhc2UgdG8gcGFyc2UgdGhlbVxuICAgICAgICAvLyBUaGlzIGFsbG93cyB3aWxkY2FyZCBcIipcIiB0byB3b3JrIHdpdGggcmVsYXRpdmUgVVJMc1xuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCIvXCIpIHx8IHVybC5zdGFydHNXaXRoKFwiLi9cIikgfHwgdXJsLnN0YXJ0c1dpdGgoXCIuLi9cIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsLCBcImh0dHA6Ly9leGFtcGxlLmNvbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1BhdGhSZWxhdGl2ZVVybCh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChcIi9cIikgfHwgdXJsLnN0YXJ0c1dpdGgoXCIuL1wiKSB8fCB1cmwuc3RhcnRzV2l0aChcIi4uL1wiKTtcbn1cbmNvbnN0IHNhZmVQcm90b2NvbHMgPSBuZXcgU2V0KFtcbiAgICBcImh0dHBzOlwiLFxuICAgIFwiaHR0cDpcIixcbiAgICBcImlyYzpcIixcbiAgICBcImlyY3M6XCIsXG4gICAgXCJtYWlsdG86XCIsXG4gICAgXCJ4bXBwOlwiLFxuICAgIFwiYmxvYjpcIixcbl0pO1xuLy8gUHJvdG9jb2xzIHRoYXQgc2hvdWxkIE5FVkVSIGJlIGFsbG93ZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbmNvbnN0IGJsb2NrZWRQcm90b2NvbHMgPSBuZXcgU2V0KFtcbiAgICBcImphdmFzY3JpcHQ6XCIsXG4gICAgXCJkYXRhOlwiLFxuICAgIFwiZmlsZTpcIixcbiAgICBcInZic2NyaXB0OlwiLFxuXSk7XG5mdW5jdGlvbiB0cmFuc2Zvcm1VcmwodXJsLCBhbGxvd2VkUHJlZml4ZXMsIGRlZmF1bHRPcmlnaW4sIGFsbG93RGF0YUltYWdlcyA9IGZhbHNlLCBpc0ltYWdlID0gZmFsc2UsIGFsbG93ZWRQcm90b2NvbHMgPSBbXSkge1xuICAgIGlmICghdXJsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBBbGxvdyBoYXNoLW9ubHkgKGZyYWdtZW50LW9ubHkpIFVSTHMgLSB0aGV5IG5hdmlnYXRlIHdpdGhpbiB0aGUgY3VycmVudCBwYWdlXG4gICAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIgJiYgdXJsLnN0YXJ0c1dpdGgoXCIjXCIpICYmICFpc0ltYWdlKSB7XG4gICAgICAgIC8vIEhhc2gtb25seSBVUkxzIGRvbid0IG5lZWQgZGVmYXVsdE9yaWdpbiB2YWxpZGF0aW9uXG4gICAgICAgIC8vIEp1c3QgdmVyaWZ5IGl0J3MgYSB2YWxpZCBmcmFnbWVudCBpZGVudGlmaWVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgYSBkdW1teSBiYXNlIHRvIHZhbGlkYXRlIHRoZSBoYXNoIGZvcm1hdFxuICAgICAgICAgICAgY29uc3QgdGVzdFVybCA9IG5ldyBVUkwodXJsLCBcImh0dHA6Ly9leGFtcGxlLmNvbVwiKTtcbiAgICAgICAgICAgIGlmICh0ZXN0VXJsLmhhc2ggPT09IHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gSW52YWxpZCBoYXNoIGZvcm1hdCwgZmFsbCB0aHJvdWdoIHRvIG5vcm1hbCB2YWxpZGF0aW9uXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIGRhdGE6IFVSTHMgZm9yIGltYWdlcyBpZiBhbGxvd0RhdGFJbWFnZXMgaXMgZW5hYmxlZFxuICAgIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiICYmIHVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgLy8gT25seSBhbGxvdyBkYXRhOiBVUkxzIGZvciBpbWFnZXMgd2hlbiBleHBsaWNpdGx5IGVuYWJsZWRcbiAgICAgICAgaWYgKGlzSW1hZ2UgJiYgYWxsb3dEYXRhSW1hZ2VzICYmIHVybC5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9cIikpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBibG9iOiBVUkxzIC0gdGhlc2UgYXJlIGJyb3dzZXItZ2VuZXJhdGVkIFVSTHMgZm9yIGxvY2FsIG9iamVjdHNcbiAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIiAmJiB1cmwuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgIC8vIGJsb2I6IFVSTHMgYXJlIHZhbGlkIGFuZCBzYWZlIC0gdGhleSByZWZlcmVuY2UgaW4tbWVtb3J5IG9iamVjdHNcbiAgICAgICAgLy8gVGhleSBjYW4gb25seSByZWZlcmVuY2UgY29udGVudCBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgYnJvd3NlclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgaXQncyBhIHByb3Blcmx5IGZvcm1hdHRlZCBibG9iIFVSTFxuICAgICAgICAgICAgLy8gYmxvYjogVVJMcyBzaG91bGQgaGF2ZSB0aGUgZm9ybWF0OiBibG9iOjxvcmlnaW4+Lzx1dWlkPiBvciBibG9iOm51bGwvPHV1aWQ+XG4gICAgICAgICAgICBjb25zdCBibG9iVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICAgICAgaWYgKGJsb2JVcmwucHJvdG9jb2wgPT09IFwiYmxvYjpcIiAmJiB1cmwubGVuZ3RoID4gNSkge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGFjdHVhbCBjb250ZW50IGFmdGVyIFwiYmxvYjpcIlxuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyUHJvdG9jb2wgPSB1cmwuc3Vic3RyaW5nKDUpO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlclByb3RvY29sICYmIGFmdGVyUHJvdG9jb2wubGVuZ3RoID4gMCAmJiBhZnRlclByb3RvY29sICE9PSBcImludmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIGJsb2IgVVJMIGlzIG1hbGZvcm1lZFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVXJsID0gcGFyc2VVcmwodXJsLCBkZWZhdWx0T3JpZ2luKTtcbiAgICBpZiAoIXBhcnNlZFVybClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gQmxvY2sgZGFuZ2Vyb3VzIHByb3RvY29scyAtIHRoZXNlIHNob3VsZCBORVZFUiBiZSBhbGxvd2VkXG4gICAgLy8gRXhjZXB0aW9uOiBkYXRhOiBpcyBhbGxvd2VkIGZvciBpbWFnZXMgaWYgYWxsb3dEYXRhSW1hZ2VzIGlzIHRydWUgKGhhbmRsZWQgYWJvdmUpXG4gICAgaWYgKGJsb2NrZWRQcm90b2NvbHMuaGFzKHBhcnNlZFVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHByb3RvY29sIGlzIGFsbG93ZWRcbiAgICBjb25zdCBpc1Byb3RvY29sQWxsb3dlZCA9IHNhZmVQcm90b2NvbHMuaGFzKHBhcnNlZFVybC5wcm90b2NvbCkgfHxcbiAgICAgICAgYWxsb3dlZFByb3RvY29scy5pbmNsdWRlcyhwYXJzZWRVcmwucHJvdG9jb2wpIHx8XG4gICAgICAgIGFsbG93ZWRQcm90b2NvbHMuaW5jbHVkZXMoXCIqXCIpO1xuICAgIGlmICghaXNQcm90b2NvbEFsbG93ZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIG1haWx0bzogYW5kIG90aGVyIGN1c3RvbSBwcm90b2NvbHMgY2FuIGp1c3QgcmV0dXJuIGFzLWlzXG4gICAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gXCJtYWlsdG86XCIgfHwgIXBhcnNlZFVybC5wcm90b2NvbC5tYXRjaCgvXmh0dHBzPzokLykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFVybC5ocmVmO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgcGF0aCByZWxhdGl2ZSwgd2Ugb3V0cHV0IGEgcGF0aCByZWxhdGl2ZSBVUkwgYXMgd2VsbCxcbiAgICAvLyBob3dldmVyLCB3ZSBhbHdheXMgcnVuIHRoZSBzYW1lIGNoZWNrcyBvbiBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlXG4gICAgLy8gYWx3YXlzIHJlY29uc3RydWN0IHRoZSBvdXRwdXQgZnJvbSB0aGUgcGFyc2VkIFVSTCB0byBlbnN1cmUgdGhhdFxuICAgIC8vIHRoZSBvdXRwdXQgaXMgYWx3YXlzIGEgdmFsaWQgVVJMLlxuICAgIGNvbnN0IGlucHV0V2FzUmVsYXRpdmUgPSBpc1BhdGhSZWxhdGl2ZVVybCh1cmwpO1xuICAgIGlmIChwYXJzZWRVcmwgJiZcbiAgICAgICAgYWxsb3dlZFByZWZpeGVzLnNvbWUoKHByZWZpeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUHJlZml4ID0gcGFyc2VVcmwocHJlZml4LCBkZWZhdWx0T3JpZ2luKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VkUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZFByZWZpeC5vcmlnaW4gIT09IHBhcnNlZFVybC5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkVXJsLmhyZWYuc3RhcnRzV2l0aChwYXJzZWRQcmVmaXguaHJlZik7XG4gICAgICAgIH0pKSB7XG4gICAgICAgIGlmIChpbnB1dFdhc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaCArIHBhcnNlZFVybC5oYXNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRVcmwuaHJlZjtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHdpbGRjYXJkIC0gYWxsb3cgYWxsIFVSTHNcbiAgICBpZiAoYWxsb3dlZFByZWZpeGVzLmluY2x1ZGVzKFwiKlwiKSkge1xuICAgICAgICAvLyBXaWxkY2FyZCBvbmx5IGFsbG93cyBodHRwIGFuZCBodHRwcyBVUkxzXG4gICAgICAgIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9PSBcImh0dHA6XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFdhc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaCArIHBhcnNlZFVybC5oYXNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRVcmwuaHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBTRUVOID0gU3ltYm9sKFwibm9kZS1zZWVuXCIpO1xuY29uc3QgY3JlYXRlVmlzaXRvciA9IChkZWZhdWx0T3JpZ2luLCBhbGxvd2VkTGlua1ByZWZpeGVzLCBhbGxvd2VkSW1hZ2VQcmVmaXhlcywgYWxsb3dEYXRhSW1hZ2VzLCBhbGxvd2VkUHJvdG9jb2xzLCBibG9ja2VkSW1hZ2VDbGFzcywgYmxvY2tlZExpbmtDbGFzcykgPT4ge1xuICAgIGNvbnN0IHZpc2l0b3IgPSAobm9kZSwgaW5kZXgsIHBhcmVudCkgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcImVsZW1lbnRcIiB8fFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgbm9kZVtTRUVOXSkge1xuICAgICAgICAgICAgcmV0dXJuIENPTlRJTlVFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFVybCA9IHRyYW5zZm9ybVVybChub2RlLnByb3BlcnRpZXMuaHJlZiwgYWxsb3dlZExpbmtQcmVmaXhlcywgZGVmYXVsdE9yaWdpbiwgZmFsc2UsIGZhbHNlLCBhbGxvd2VkUHJvdG9jb2xzKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lZFVybCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBub2RlW1NFRU5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGVhZ2VybHkgdmlzaXQgY2hpbGRyZW4gc28gdGhhdCB3ZSBjYXRjaCBhbnkgbmVzdGVkIG5hc3RpbmVzcyBhcyB3ZWxsLFxuICAgICAgICAgICAgICAgIC8vIHByaW9yIHRvIG1vZGlmeWluZyB0aGUgbm9kZSdzIHBhcmVudC5cbiAgICAgICAgICAgICAgICB2aXNpdChub2RlLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5baW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCbG9ja2VkIFVSTDogXCIgKyBTdHJpbmcobm9kZS5wcm9wZXJ0aWVzLmhyZWYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBibG9ja2VkTGlua0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCIgW2Jsb2NrZWRdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBTS0lQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLmhyZWYgPSB0cmFuc2Zvcm1lZFVybDtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMudGFyZ2V0ID0gXCJfYmxhbmtcIjtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMucmVsID0gXCJub29wZW5lciBub3JlZmVycmVyXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTlRJTlVFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09IFwiaW1nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVXJsID0gdHJhbnNmb3JtVXJsKG5vZGUucHJvcGVydGllcy5zcmMsIGFsbG93ZWRJbWFnZVByZWZpeGVzLCBkZWZhdWx0T3JpZ2luLCBhbGxvd0RhdGFJbWFnZXMsIHRydWUsIGFsbG93ZWRQcm90b2NvbHMpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkVXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIG5vZGVbU0VFTl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZpc2l0KG5vZGUsIHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgdHlwZW9mIGluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBibG9ja2VkSW1hZ2VDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIltJbWFnZSBibG9ja2VkOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcobm9kZS5wcm9wZXJ0aWVzLmFsdCB8fCBcIk5vIGRlc2NyaXB0aW9uXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gU0tJUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5zcmMgPSB0cmFuc2Zvcm1lZFVybDtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OVElOVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENPTlRJTlVFO1xuICAgIH07XG4gICAgcmV0dXJuIHZpc2l0b3I7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkNPTlRJTlVFIiwiU0tJUCIsInZpc2l0IiwiaGFyZGVuIiwiZGVmYXVsdE9yaWdpbiIsImFsbG93ZWRMaW5rUHJlZml4ZXMiLCJhbGxvd2VkSW1hZ2VQcmVmaXhlcyIsImFsbG93RGF0YUltYWdlcyIsImFsbG93ZWRQcm90b2NvbHMiLCJibG9ja2VkSW1hZ2VDbGFzcyIsImJsb2NrZWRMaW5rQ2xhc3MiLCJoYXNTcGVjaWZpY0xpbmtQcmVmaXhlcyIsImxlbmd0aCIsImV2ZXJ5IiwicCIsImhhc1NwZWNpZmljSW1hZ2VQcmVmaXhlcyIsIkVycm9yIiwidHJlZSIsInZpc2l0b3IiLCJjcmVhdGVWaXNpdG9yIiwicGFyc2VVcmwiLCJ1cmwiLCJVUkwiLCJzdGFydHNXaXRoIiwiaXNQYXRoUmVsYXRpdmVVcmwiLCJzYWZlUHJvdG9jb2xzIiwiU2V0IiwiYmxvY2tlZFByb3RvY29scyIsInRyYW5zZm9ybVVybCIsImFsbG93ZWRQcmVmaXhlcyIsImlzSW1hZ2UiLCJ0ZXN0VXJsIiwiaGFzaCIsImJsb2JVcmwiLCJwcm90b2NvbCIsImFmdGVyUHJvdG9jb2wiLCJzdWJzdHJpbmciLCJwYXJzZWRVcmwiLCJoYXMiLCJpc1Byb3RvY29sQWxsb3dlZCIsImluY2x1ZGVzIiwibWF0Y2giLCJocmVmIiwiaW5wdXRXYXNSZWxhdGl2ZSIsInNvbWUiLCJwcmVmaXgiLCJwYXJzZWRQcmVmaXgiLCJvcmlnaW4iLCJwYXRobmFtZSIsInNlYXJjaCIsIlNFRU4iLCJTeW1ib2wiLCJub2RlIiwiaW5kZXgiLCJwYXJlbnQiLCJ0eXBlIiwidGFnTmFtZSIsInRyYW5zZm9ybWVkVXJsIiwicHJvcGVydGllcyIsImNoaWxkcmVuIiwidGl0bGUiLCJTdHJpbmciLCJjbGFzcyIsInZhbHVlIiwidGFyZ2V0IiwicmVsIiwic3JjIiwiYWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/rehype-harden@1.1.7/node_modules/rehype-harden/dist/index.js\n");

/***/ })

};
;