"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/regex-recursion@6.0.2";
exports.ids = ["vendor-chunks/regex-recursion@6.0.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recursion: () => (/* binding */ recursion)\n/* harmony export */ });\n/* harmony import */ var regex_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regex-utilities */ \"(ssr)/./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\");\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCaptureDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst captureDelim = r`${namedCaptureDelim}|(?<unnamed>\\()(?!\\?)`;\nconst token = new RegExp(r`${namedCaptureDelim}|${recursiveToken}|\\(\\?|\\\\?.`, \"gsu\");\nconst overlappingRecursionMsg = \"Cannot use multiple overlapping recursions\";\n/**\n@param {string} pattern\n@param {{\n  flags?: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n  mode?: 'plugin' | 'external';\n}} [data]\n@returns {{\n  pattern: string;\n  captureTransfers: Map<number, Array<number>>;\n  hiddenCaptures: Array<number>;\n}}\n*/ function recursion(pattern, data) {\n    const { hiddenCaptures, mode } = {\n        hiddenCaptures: [],\n        mode: \"plugin\",\n        ...data\n    };\n    // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>\n    let captureTransfers = data?.captureTransfers ?? new Map();\n    // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n    // without the accuracy improvement of using `hasUnescaped` with `Context.DEFAULT`\n    if (!new RegExp(recursiveToken, \"su\").test(pattern)) {\n        return {\n            pattern,\n            captureTransfers,\n            hiddenCaptures\n        };\n    }\n    if (mode === \"plugin\" && (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(pattern, r`\\(\\?\\(DEFINE\\)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n        throw new Error(\"DEFINE groups cannot be used with recursion\");\n    }\n    const addedHiddenCaptures = [];\n    const hasNumberedBackref = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(pattern, r`\\\\[1-9]`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n    const groupContentsStartPos = new Map();\n    const openGroups = [];\n    let hasRecursed = false;\n    let numCharClassesOpen = 0;\n    let numCapturesPassed = 0;\n    let match;\n    token.lastIndex = 0;\n    while(match = token.exec(pattern)){\n        const { 0: m, groups: { captureName, rDepth, gRNameOrNum, gRDepth } } = match;\n        if (m === \"[\") {\n            numCharClassesOpen++;\n        } else if (!numCharClassesOpen) {\n            // `(?R=N)`\n            if (rDepth) {\n                assertMaxInBounds(rDepth);\n                if (hasRecursed) {\n                    throw new Error(overlappingRecursionMsg);\n                }\n                if (hasNumberedBackref) {\n                    // Could add support for numbered backrefs with extra effort, but it's probably not worth\n                    // it. To trigger this error, the regex must include recursion and one of the following:\n                    // - An interpolated regex that contains a numbered backref (since other numbered\n                    //   backrefs are prevented by implicit flag n).\n                    // - A numbered backref, when flag n is explicitly disabled.\n                    // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n                    // add numbered backrefs, but those work fine because external plugins like this one run\n                    // *before* the transformation of built-in syntax extensions\n                    throw new Error(// When used in `external` mode by transpilers other than Regex+, backrefs might have\n                    // gone through conversion from named to numbered, so avoid a misleading error\n                    `${mode === \"external\" ? \"Backrefs\" : \"Numbered backrefs\"} cannot be used with global recursion`);\n                }\n                const left = pattern.slice(0, match.index);\n                const right = pattern.slice(token.lastIndex);\n                if ((0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(right, recursiveToken, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n                    throw new Error(overlappingRecursionMsg);\n                }\n                const reps = +rDepth - 1;\n                pattern = makeRecursive(left, right, reps, false, hiddenCaptures, addedHiddenCaptures, numCapturesPassed);\n                captureTransfers = mapCaptureTransfers(captureTransfers, left, reps, addedHiddenCaptures.length, 0, numCapturesPassed);\n                break;\n            // `\\g<name&R=N>`, `\\g<number&R=N>`\n            } else if (gRNameOrNum) {\n                assertMaxInBounds(gRDepth);\n                let isWithinReffedGroup = false;\n                for (const g of openGroups){\n                    if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n                        isWithinReffedGroup = true;\n                        if (g.hasRecursedWithin) {\n                            throw new Error(overlappingRecursionMsg);\n                        }\n                        break;\n                    }\n                }\n                if (!isWithinReffedGroup) {\n                    throw new Error(r`Recursive \\g cannot be used outside the referenced group \"${mode === \"external\" ? gRNameOrNum : r`\\g<${gRNameOrNum}&R=${gRDepth}>`}\"`);\n                }\n                const startPos = groupContentsStartPos.get(gRNameOrNum);\n                const groupContents = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.getGroupContents)(pattern, startPos);\n                if (hasNumberedBackref && (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(groupContents, r`${namedCaptureDelim}|\\((?!\\?)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n                    throw new Error(// When used in `external` mode by transpilers other than Regex+, backrefs might have\n                    // gone through conversion from named to numbered, so avoid a misleading error\n                    `${mode === \"external\" ? \"Backrefs\" : \"Numbered backrefs\"} cannot be used with recursion of capturing groups`);\n                }\n                const groupContentsLeft = pattern.slice(startPos, match.index);\n                const groupContentsRight = groupContents.slice(groupContentsLeft.length + m.length);\n                const numAddedHiddenCapturesPreExpansion = addedHiddenCaptures.length;\n                const reps = +gRDepth - 1;\n                const expansion = makeRecursive(groupContentsLeft, groupContentsRight, reps, true, hiddenCaptures, addedHiddenCaptures, numCapturesPassed);\n                captureTransfers = mapCaptureTransfers(captureTransfers, groupContentsLeft, reps, addedHiddenCaptures.length - numAddedHiddenCapturesPreExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed);\n                const pre = pattern.slice(0, startPos);\n                const post = pattern.slice(startPos + groupContents.length);\n                // Modify the string we're looping over\n                pattern = `${pre}${expansion}${post}`;\n                // Step forward for the next loop iteration\n                token.lastIndex += expansion.length - m.length - groupContentsLeft.length - groupContentsRight.length;\n                openGroups.forEach((g)=>g.hasRecursedWithin = true);\n                hasRecursed = true;\n            } else if (captureName) {\n                numCapturesPassed++;\n                groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n                groupContentsStartPos.set(captureName, token.lastIndex);\n                openGroups.push({\n                    num: numCapturesPassed,\n                    name: captureName\n                });\n            } else if (m[0] === \"(\") {\n                const isUnnamedCapture = m === \"(\";\n                if (isUnnamedCapture) {\n                    numCapturesPassed++;\n                    groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n                }\n                openGroups.push(isUnnamedCapture ? {\n                    num: numCapturesPassed\n                } : {});\n            } else if (m === \")\") {\n                openGroups.pop();\n            }\n        } else if (m === \"]\") {\n            numCharClassesOpen--;\n        }\n    }\n    hiddenCaptures.push(...addedHiddenCaptures);\n    return {\n        pattern,\n        captureTransfers,\n        hiddenCaptures\n    };\n}\n/**\n@param {string} max\n*/ function assertMaxInBounds(max) {\n    const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n    if (!/^[1-9]\\d*$/.test(max)) {\n        throw new Error(errMsg);\n    }\n    max = +max;\n    if (max < 2 || max > 100) {\n        throw new Error(errMsg);\n    }\n}\n/**\n@param {string} left\n@param {string} right\n@param {number} reps\n@param {boolean} isSubpattern\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/ function makeRecursive(left, right, reps, isSubpattern, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {\n    const namesInRecursed = new Set();\n    // Can skip this work if not needed\n    if (isSubpattern) {\n        (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.forEachUnescaped)(left + right, namedCaptureDelim, ({ groups: { captureName } })=>{\n            namesInRecursed.add(captureName);\n        }, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n    }\n    const rest = [\n        reps,\n        isSubpattern ? namesInRecursed : null,\n        hiddenCaptures,\n        addedHiddenCaptures,\n        numCapturesPassed\n    ];\n    // Depth 2: 'left(?:left(?:)right)right'\n    // Depth 3: 'left(?:left(?:left(?:)right)right)right'\n    // Empty group in the middle separates tokens and absorbs a following quantifier if present\n    return `${left}${repeatWithDepth(`(?:${left}`, \"forward\", ...rest)}(?:)${repeatWithDepth(`${right})`, \"backward\", ...rest)}${right}`;\n}\n/**\n@param {string} pattern\n@param {'forward' | 'backward'} direction\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/ function repeatWithDepth(pattern, direction, reps, namesInRecursed, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {\n    const startNum = 2;\n    const getDepthNum = (i)=>direction === \"forward\" ? i + startNum : reps - i + startNum - 1;\n    let result = \"\";\n    for(let i = 0; i < reps; i++){\n        const depthNum = getDepthNum(i);\n        result += (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.replaceUnescaped)(pattern, r`${captureDelim}|\\\\k<(?<backref>[^>]+)>`, ({ 0: m, groups: { captureName, unnamed, backref } })=>{\n            if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n                // Don't alter backrefs to groups outside the recursed subpattern\n                return m;\n            }\n            const suffix = `_$${depthNum}`;\n            if (unnamed || captureName) {\n                const addedCaptureNum = numCapturesPassed + addedHiddenCaptures.length + 1;\n                addedHiddenCaptures.push(addedCaptureNum);\n                incrementIfAtLeast(hiddenCaptures, addedCaptureNum);\n                return unnamed ? m : `(?<${captureName}${suffix}>`;\n            }\n            return r`\\k<${backref}${suffix}>`;\n        }, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n    }\n    return result;\n}\n/**\nUpdates the array in place by incrementing each value greater than or equal to the threshold.\n@param {Array<number>} arr\n@param {number} threshold\n*/ function incrementIfAtLeast(arr, threshold) {\n    for(let i = 0; i < arr.length; i++){\n        if (arr[i] >= threshold) {\n            arr[i]++;\n        }\n    }\n}\n/**\n@param {Map<number, Array<number>>} captureTransfers\n@param {string} left\n@param {number} reps\n@param {number} numCapturesAddedInExpansion\n@param {number} numAddedHiddenCapturesPreExpansion\n@param {number} numCapturesPassed\n@returns {Map<number, Array<number>>}\n*/ function mapCaptureTransfers(captureTransfers, left, reps, numCapturesAddedInExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed) {\n    if (captureTransfers.size && numCapturesAddedInExpansion) {\n        let numCapturesInLeft = 0;\n        (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.forEachUnescaped)(left, captureDelim, ()=>numCapturesInLeft++, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n        // Is 0 for global recursion\n        const recursionDelimCaptureNum = numCapturesPassed - numCapturesInLeft + numAddedHiddenCapturesPreExpansion;\n        const newCaptureTransfers = new Map();\n        captureTransfers.forEach((from, to)=>{\n            const numCapturesInRight = (numCapturesAddedInExpansion - numCapturesInLeft * reps) / reps;\n            const numCapturesAddedInLeft = numCapturesInLeft * reps;\n            const newTo = to > recursionDelimCaptureNum + numCapturesInLeft ? to + numCapturesAddedInExpansion : to;\n            const newFrom = [];\n            for (const f of from){\n                // Before the recursed subpattern\n                if (f <= recursionDelimCaptureNum) {\n                    newFrom.push(f);\n                // After the recursed subpattern\n                } else if (f > recursionDelimCaptureNum + numCapturesInLeft + numCapturesInRight) {\n                    newFrom.push(f + numCapturesAddedInExpansion);\n                // Within the recursed subpattern, on the left of the recursion token\n                } else if (f <= recursionDelimCaptureNum + numCapturesInLeft) {\n                    for(let i = 0; i <= reps; i++){\n                        newFrom.push(f + numCapturesInLeft * i);\n                    }\n                // Within the recursed subpattern, on the right of the recursion token\n                } else {\n                    for(let i = 0; i <= reps; i++){\n                        newFrom.push(f + numCapturesAddedInLeft + numCapturesInRight * i);\n                    }\n                }\n            }\n            newCaptureTransfers.set(newTo, newFrom);\n        });\n        return newCaptureTransfers;\n    }\n    return captureTransfers;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnZXgtcmVjdXJzaW9uQDYuMC4yL25vZGVfbW9kdWxlcy9yZWdleC1yZWN1cnNpb24vc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRHO0FBRTVHLE1BQU1LLElBQUlDLE9BQU9DLEdBQUc7QUFDcEIsTUFBTUMsVUFBVUgsQ0FBQyxDQUFDLCtDQUErQyxDQUFDO0FBQ2xFLE1BQU1JLGlCQUFpQkosQ0FBQyxDQUFDLDBCQUEwQixFQUFFRyxRQUFRLENBQUM7QUFDOUQsTUFBTUUsb0JBQW9CTCxDQUFDLENBQUMsbUNBQW1DLENBQUM7QUFDaEUsTUFBTU0sZUFBZU4sQ0FBQyxDQUFDLEVBQUVLLGtCQUFrQixxQkFBcUIsQ0FBQztBQUNqRSxNQUFNRSxRQUFRLElBQUlDLE9BQU9SLENBQUMsQ0FBQyxFQUFFSyxrQkFBa0IsQ0FBQyxFQUFFRCxlQUFlLFVBQVUsQ0FBQyxFQUFFO0FBQzlFLE1BQU1LLDBCQUEwQjtBQUVoQzs7Ozs7Ozs7Ozs7OztBQWFBLEdBQ0EsU0FBU0MsVUFBVUMsT0FBTyxFQUFFQyxJQUFJO0lBQzlCLE1BQU0sRUFBQ0MsY0FBYyxFQUFFQyxJQUFJLEVBQUMsR0FBRztRQUM3QkQsZ0JBQWdCLEVBQUU7UUFDbEJDLE1BQU07UUFDTixHQUFHRixJQUFJO0lBQ1Q7SUFDQSxxRUFBcUU7SUFDckUsSUFBSUcsbUJBQW1CSCxNQUFNRyxvQkFBb0IsSUFBSUM7SUFDckQsZ0dBQWdHO0lBQ2hHLGtGQUFrRjtJQUNsRixJQUFJLENBQUUsSUFBSVIsT0FBT0osZ0JBQWdCLE1BQU1hLElBQUksQ0FBQ04sVUFBVztRQUNyRCxPQUFPO1lBQ0xBO1lBQ0FJO1lBQ0FGO1FBQ0Y7SUFDRjtJQUNBLElBQUlDLFNBQVMsWUFBWWhCLDZEQUFZQSxDQUFDYSxTQUFTWCxDQUFDLENBQUMsY0FBYyxDQUFDLEVBQUVMLG9EQUFPQSxDQUFDdUIsT0FBTyxHQUFHO1FBQ2xGLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJ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QzlCLE1BQU1DLHFCQUFxQixDQUFDUCw4QkFBK0JFLG9CQUFvQi9DLElBQUksSUFBS0E7WUFDeEYsTUFBTXFELHlCQUF5Qk4sb0JBQW9CL0M7WUFDbkQsTUFBTXNELFFBQVFILEtBQU1ILDJCQUEyQkQsb0JBQXFCSSxLQUFLTiw4QkFBOEJNO1lBQ3ZHLE1BQU1JLFVBQVUsRUFBRTtZQUNsQixLQUFLLE1BQU1DLEtBQUtOLEtBQU07Z0JBQ3BCLGlDQUFpQztnQkFDakMsSUFBSU0sS0FBS1IsMEJBQTBCO29CQUNqQ08sUUFBUW5DLElBQUksQ0FBQ29DO2dCQUNmLGdDQUFnQztnQkFDaEMsT0FBTyxJQUFJQSxJQUFLUiwyQkFBMkJELG9CQUFvQkssb0JBQXFCO29CQUNsRkcsUUFBUW5DLElBQUksQ0FBQ29DLElBQUlYO2dCQUNuQixxRUFBcUU7Z0JBQ3JFLE9BQU8sSUFBSVcsS0FBTVIsMkJBQTJCRCxtQkFBb0I7b0JBQzlELElBQUssSUFBSWIsSUFBSSxHQUFHQSxLQUFLbEMsTUFBTWtDLElBQUs7d0JBQzlCcUIsUUFBUW5DLElBQUksQ0FBQ29DLElBQUtULG9CQUFvQmI7b0JBQ3hDO2dCQUNGLHNFQUFzRTtnQkFDdEUsT0FBTztvQkFDTCxJQUFLLElBQUlBLElBQUksR0FBR0EsS0FBS2xDLE1BQU1rQyxJQUFLO3dCQUM5QnFCLFFBQVFuQyxJQUFJLENBQUNvQyxJQUFJSCx5QkFBMEJELHFCQUFxQmxCO29CQUNsRTtnQkFDRjtZQUNGO1lBQ0FlLG9CQUFvQjlCLEdBQUcsQ0FBQ21DLE9BQU9DO1FBQ2pDO1FBQ0EsT0FBT047SUFDVDtJQUNBLE9BQU8zRTtBQUNUO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleC1yZWN1cnNpb25ANi4wLjIvbm9kZV9tb2R1bGVzL3JlZ2V4LXJlY3Vyc2lvbi9zcmMvaW5kZXguanM/ZDAyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbnRleHQsIGZvckVhY2hVbmVzY2FwZWQsIGdldEdyb3VwQ29udGVudHMsIGhhc1VuZXNjYXBlZCwgcmVwbGFjZVVuZXNjYXBlZH0gZnJvbSAncmVnZXgtdXRpbGl0aWVzJztcblxuY29uc3QgciA9IFN0cmluZy5yYXc7XG5jb25zdCBnUlRva2VuID0gcmBcXFxcZzwoPzxnUk5hbWVPck51bT5bXj4mXSspJlI9KD88Z1JEZXB0aD5bXj5dKyk+YDtcbmNvbnN0IHJlY3Vyc2l2ZVRva2VuID0gcmBcXChcXD9SPSg/PHJEZXB0aD5bXlxcKV0rKVxcKXwke2dSVG9rZW59YDtcbmNvbnN0IG5hbWVkQ2FwdHVyZURlbGltID0gcmBcXChcXD88KD8hWz0hXSkoPzxjYXB0dXJlTmFtZT5bXj5dKyk+YDtcbmNvbnN0IGNhcHR1cmVEZWxpbSA9IHJgJHtuYW1lZENhcHR1cmVEZWxpbX18KD88dW5uYW1lZD5cXCgpKD8hXFw/KWA7XG5jb25zdCB0b2tlbiA9IG5ldyBSZWdFeHAocmAke25hbWVkQ2FwdHVyZURlbGltfXwke3JlY3Vyc2l2ZVRva2VufXxcXChcXD98XFxcXD8uYCwgJ2dzdScpO1xuY29uc3Qgb3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cgPSAnQ2Fubm90IHVzZSBtdWx0aXBsZSBvdmVybGFwcGluZyByZWN1cnNpb25zJztcblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuQHBhcmFtIHt7XG4gIGZsYWdzPzogc3RyaW5nO1xuICBjYXB0dXJlVHJhbnNmZXJzPzogTWFwPG51bWJlciwgQXJyYXk8bnVtYmVyPj47XG4gIGhpZGRlbkNhcHR1cmVzPzogQXJyYXk8bnVtYmVyPjtcbiAgbW9kZT86ICdwbHVnaW4nIHwgJ2V4dGVybmFsJztcbn19IFtkYXRhXVxuQHJldHVybnMge3tcbiAgcGF0dGVybjogc3RyaW5nO1xuICBjYXB0dXJlVHJhbnNmZXJzOiBNYXA8bnVtYmVyLCBBcnJheTxudW1iZXI+PjtcbiAgaGlkZGVuQ2FwdHVyZXM6IEFycmF5PG51bWJlcj47XG59fVxuKi9cbmZ1bmN0aW9uIHJlY3Vyc2lvbihwYXR0ZXJuLCBkYXRhKSB7XG4gIGNvbnN0IHtoaWRkZW5DYXB0dXJlcywgbW9kZX0gPSB7XG4gICAgaGlkZGVuQ2FwdHVyZXM6IFtdLFxuICAgIG1vZGU6ICdwbHVnaW4nLFxuICAgIC4uLmRhdGEsXG4gIH07XG4gIC8vIENhcHR1cmUgdHJhbnNmZXIgaXMgdXNlZCBieSA8Z2l0aHViLmNvbS9zbGV2aXRoYW4vb25pZ3VydW1hLXRvLWVzPlxuICBsZXQgY2FwdHVyZVRyYW5zZmVycyA9IGRhdGE/LmNhcHR1cmVUcmFuc2ZlcnMgPz8gbmV3IE1hcCgpO1xuICAvLyBLZWVwIHRoZSBpbml0aWFsIGZhaWwtY2hlY2sgKHdoaWNoIGF2b2lkcyB1bm5lZWRlZCBwcm9jZXNzaW5nKSBhcyBmYXN0IGFzIHBvc3NpYmxlIGJ5IHRlc3RpbmdcbiAgLy8gd2l0aG91dCB0aGUgYWNjdXJhY3kgaW1wcm92ZW1lbnQgb2YgdXNpbmcgYGhhc1VuZXNjYXBlZGAgd2l0aCBgQ29udGV4dC5ERUZBVUxUYFxuICBpZiAoIShuZXcgUmVnRXhwKHJlY3Vyc2l2ZVRva2VuLCAnc3UnKS50ZXN0KHBhdHRlcm4pKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuLFxuICAgICAgY2FwdHVyZVRyYW5zZmVycyxcbiAgICAgIGhpZGRlbkNhcHR1cmVzLFxuICAgIH07XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdwbHVnaW4nICYmIGhhc1VuZXNjYXBlZChwYXR0ZXJuLCByYFxcKFxcP1xcKERFRklORVxcKWAsIENvbnRleHQuREVGQVVMVCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RFRklORSBncm91cHMgY2Fubm90IGJlIHVzZWQgd2l0aCByZWN1cnNpb24nKTtcbiAgfVxuXG4gIGNvbnN0IGFkZGVkSGlkZGVuQ2FwdHVyZXMgPSBbXTtcbiAgY29uc3QgaGFzTnVtYmVyZWRCYWNrcmVmID0gaGFzVW5lc2NhcGVkKHBhdHRlcm4sIHJgXFxcXFsxLTldYCwgQ29udGV4dC5ERUZBVUxUKTtcbiAgY29uc3QgZ3JvdXBDb250ZW50c1N0YXJ0UG9zID0gbmV3IE1hcCgpO1xuICBjb25zdCBvcGVuR3JvdXBzID0gW107XG4gIGxldCBoYXNSZWN1cnNlZCA9IGZhbHNlO1xuICBsZXQgbnVtQ2hhckNsYXNzZXNPcGVuID0gMDtcbiAgbGV0IG51bUNhcHR1cmVzUGFzc2VkID0gMDtcbiAgbGV0IG1hdGNoO1xuICB0b2tlbi5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAoKG1hdGNoID0gdG9rZW4uZXhlYyhwYXR0ZXJuKSkpIHtcbiAgICBjb25zdCB7MDogbSwgZ3JvdXBzOiB7Y2FwdHVyZU5hbWUsIHJEZXB0aCwgZ1JOYW1lT3JOdW0sIGdSRGVwdGh9fSA9IG1hdGNoO1xuICAgIGlmIChtID09PSAnWycpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3BlbisrO1xuICAgIH0gZWxzZSBpZiAoIW51bUNoYXJDbGFzc2VzT3Blbikge1xuXG4gICAgICAvLyBgKD9SPU4pYFxuICAgICAgaWYgKHJEZXB0aCkge1xuICAgICAgICBhc3NlcnRNYXhJbkJvdW5kcyhyRGVwdGgpO1xuICAgICAgICBpZiAoaGFzUmVjdXJzZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNOdW1iZXJlZEJhY2tyZWYpIHtcbiAgICAgICAgICAvLyBDb3VsZCBhZGQgc3VwcG9ydCBmb3IgbnVtYmVyZWQgYmFja3JlZnMgd2l0aCBleHRyYSBlZmZvcnQsIGJ1dCBpdCdzIHByb2JhYmx5IG5vdCB3b3J0aFxuICAgICAgICAgIC8vIGl0LiBUbyB0cmlnZ2VyIHRoaXMgZXJyb3IsIHRoZSByZWdleCBtdXN0IGluY2x1ZGUgcmVjdXJzaW9uIGFuZCBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAvLyAtIEFuIGludGVycG9sYXRlZCByZWdleCB0aGF0IGNvbnRhaW5zIGEgbnVtYmVyZWQgYmFja3JlZiAoc2luY2Ugb3RoZXIgbnVtYmVyZWRcbiAgICAgICAgICAvLyAgIGJhY2tyZWZzIGFyZSBwcmV2ZW50ZWQgYnkgaW1wbGljaXQgZmxhZyBuKS5cbiAgICAgICAgICAvLyAtIEEgbnVtYmVyZWQgYmFja3JlZiwgd2hlbiBmbGFnIG4gaXMgZXhwbGljaXRseSBkaXNhYmxlZC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgUmVnZXgrJ3MgZXh0ZW5kZWQgc3ludGF4IChhdG9taWMgZ3JvdXBzIGFuZCBzb21ldGltZXMgc3Vicm91dGluZXMpIGNhbiBhbHNvXG4gICAgICAgICAgLy8gYWRkIG51bWJlcmVkIGJhY2tyZWZzLCBidXQgdGhvc2Ugd29yayBmaW5lIGJlY2F1c2UgZXh0ZXJuYWwgcGx1Z2lucyBsaWtlIHRoaXMgb25lIHJ1blxuICAgICAgICAgIC8vICpiZWZvcmUqIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiBidWlsdC1pbiBzeW50YXggZXh0ZW5zaW9uc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIC8vIFdoZW4gdXNlZCBpbiBgZXh0ZXJuYWxgIG1vZGUgYnkgdHJhbnNwaWxlcnMgb3RoZXIgdGhhbiBSZWdleCssIGJhY2tyZWZzIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgIC8vIGdvbmUgdGhyb3VnaCBjb252ZXJzaW9uIGZyb20gbmFtZWQgdG8gbnVtYmVyZWQsIHNvIGF2b2lkIGEgbWlzbGVhZGluZyBlcnJvclxuICAgICAgICAgICAgYCR7bW9kZSA9PT0gJ2V4dGVybmFsJyA/ICdCYWNrcmVmcycgOiAnTnVtYmVyZWQgYmFja3JlZnMnfSBjYW5ub3QgYmUgdXNlZCB3aXRoIGdsb2JhbCByZWN1cnNpb25gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0ID0gcGF0dGVybi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gcGF0dGVybi5zbGljZSh0b2tlbi5sYXN0SW5kZXgpO1xuICAgICAgICBpZiAoaGFzVW5lc2NhcGVkKHJpZ2h0LCByZWN1cnNpdmVUb2tlbiwgQ29udGV4dC5ERUZBVUxUKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvdmVybGFwcGluZ1JlY3Vyc2lvbk1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwcyA9ICtyRGVwdGggLSAxO1xuICAgICAgICBwYXR0ZXJuID0gbWFrZVJlY3Vyc2l2ZShcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgIHJlcHMsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgaGlkZGVuQ2FwdHVyZXMsXG4gICAgICAgICAgYWRkZWRIaWRkZW5DYXB0dXJlcyxcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZFxuICAgICAgICApO1xuICAgICAgICBjYXB0dXJlVHJhbnNmZXJzID0gbWFwQ2FwdHVyZVRyYW5zZmVycyhcbiAgICAgICAgICBjYXB0dXJlVHJhbnNmZXJzLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmVwcyxcbiAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLmxlbmd0aCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIG51bUNhcHR1cmVzUGFzc2VkXG4gICAgICAgICk7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcGFyc2UgZnVydGhlclxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGBcXGc8bmFtZSZSPU4+YCwgYFxcZzxudW1iZXImUj1OPmBcbiAgICAgIH0gZWxzZSBpZiAoZ1JOYW1lT3JOdW0pIHtcbiAgICAgICAgYXNzZXJ0TWF4SW5Cb3VuZHMoZ1JEZXB0aCk7XG4gICAgICAgIGxldCBpc1dpdGhpblJlZmZlZEdyb3VwID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgZyBvZiBvcGVuR3JvdXBzKSB7XG4gICAgICAgICAgaWYgKGcubmFtZSA9PT0gZ1JOYW1lT3JOdW0gfHwgZy5udW0gPT09ICtnUk5hbWVPck51bSkge1xuICAgICAgICAgICAgaXNXaXRoaW5SZWZmZWRHcm91cCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZy5oYXNSZWN1cnNlZFdpdGhpbikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNXaXRoaW5SZWZmZWRHcm91cCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyYFJlY3Vyc2l2ZSBcXGcgY2Fubm90IGJlIHVzZWQgb3V0c2lkZSB0aGUgcmVmZXJlbmNlZCBncm91cCBcIiR7XG4gICAgICAgICAgICBtb2RlID09PSAnZXh0ZXJuYWwnID8gZ1JOYW1lT3JOdW0gOiByYFxcZzwke2dSTmFtZU9yTnVtfSZSPSR7Z1JEZXB0aH0+YFxuICAgICAgICAgIH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gZ3JvdXBDb250ZW50c1N0YXJ0UG9zLmdldChnUk5hbWVPck51bSk7XG4gICAgICAgIGNvbnN0IGdyb3VwQ29udGVudHMgPSBnZXRHcm91cENvbnRlbnRzKHBhdHRlcm4sIHN0YXJ0UG9zKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGhhc051bWJlcmVkQmFja3JlZiAmJlxuICAgICAgICAgIGhhc1VuZXNjYXBlZChncm91cENvbnRlbnRzLCByYCR7bmFtZWRDYXB0dXJlRGVsaW19fFxcKCg/IVxcPylgLCBDb250ZXh0LkRFRkFVTFQpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIC8vIFdoZW4gdXNlZCBpbiBgZXh0ZXJuYWxgIG1vZGUgYnkgdHJhbnNwaWxlcnMgb3RoZXIgdGhhbiBSZWdleCssIGJhY2tyZWZzIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgIC8vIGdvbmUgdGhyb3VnaCBjb252ZXJzaW9uIGZyb20gbmFtZWQgdG8gbnVtYmVyZWQsIHNvIGF2b2lkIGEgbWlzbGVhZGluZyBlcnJvclxuICAgICAgICAgICAgYCR7bW9kZSA9PT0gJ2V4dGVybmFsJyA/ICdCYWNrcmVmcycgOiAnTnVtYmVyZWQgYmFja3JlZnMnfSBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlY3Vyc2lvbiBvZiBjYXB0dXJpbmcgZ3JvdXBzYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JvdXBDb250ZW50c0xlZnQgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0UG9zLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGNvbnN0IGdyb3VwQ29udGVudHNSaWdodCA9IGdyb3VwQ29udGVudHMuc2xpY2UoZ3JvdXBDb250ZW50c0xlZnQubGVuZ3RoICsgbS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uID0gYWRkZWRIaWRkZW5DYXB0dXJlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlcHMgPSArZ1JEZXB0aCAtIDE7XG4gICAgICAgIGNvbnN0IGV4cGFuc2lvbiA9IG1ha2VSZWN1cnNpdmUoXG4gICAgICAgICAgZ3JvdXBDb250ZW50c0xlZnQsXG4gICAgICAgICAgZ3JvdXBDb250ZW50c1JpZ2h0LFxuICAgICAgICAgIHJlcHMsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBoaWRkZW5DYXB0dXJlcyxcbiAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLFxuICAgICAgICAgIG51bUNhcHR1cmVzUGFzc2VkXG4gICAgICAgICk7XG4gICAgICAgIGNhcHR1cmVUcmFuc2ZlcnMgPSBtYXBDYXB0dXJlVHJhbnNmZXJzKFxuICAgICAgICAgIGNhcHR1cmVUcmFuc2ZlcnMsXG4gICAgICAgICAgZ3JvdXBDb250ZW50c0xlZnQsXG4gICAgICAgICAgcmVwcyxcbiAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLmxlbmd0aCAtIG51bUFkZGVkSGlkZGVuQ2FwdHVyZXNQcmVFeHBhbnNpb24sXG4gICAgICAgICAgbnVtQWRkZWRIaWRkZW5DYXB0dXJlc1ByZUV4cGFuc2lvbixcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwcmUgPSBwYXR0ZXJuLnNsaWNlKDAsIHN0YXJ0UG9zKTtcbiAgICAgICAgY29uc3QgcG9zdCA9IHBhdHRlcm4uc2xpY2Uoc3RhcnRQb3MgKyBncm91cENvbnRlbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIE1vZGlmeSB0aGUgc3RyaW5nIHdlJ3JlIGxvb3Bpbmcgb3ZlclxuICAgICAgICBwYXR0ZXJuID0gYCR7cHJlfSR7ZXhwYW5zaW9ufSR7cG9zdH1gO1xuICAgICAgICAvLyBTdGVwIGZvcndhcmQgZm9yIHRoZSBuZXh0IGxvb3AgaXRlcmF0aW9uXG4gICAgICAgIHRva2VuLmxhc3RJbmRleCArPSBleHBhbnNpb24ubGVuZ3RoIC0gbS5sZW5ndGggLSBncm91cENvbnRlbnRzTGVmdC5sZW5ndGggLSBncm91cENvbnRlbnRzUmlnaHQubGVuZ3RoO1xuICAgICAgICBvcGVuR3JvdXBzLmZvckVhY2goZyA9PiBnLmhhc1JlY3Vyc2VkV2l0aGluID0gdHJ1ZSk7XG4gICAgICAgIGhhc1JlY3Vyc2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZU5hbWUpIHtcbiAgICAgICAgbnVtQ2FwdHVyZXNQYXNzZWQrKztcbiAgICAgICAgZ3JvdXBDb250ZW50c1N0YXJ0UG9zLnNldChTdHJpbmcobnVtQ2FwdHVyZXNQYXNzZWQpLCB0b2tlbi5sYXN0SW5kZXgpO1xuICAgICAgICBncm91cENvbnRlbnRzU3RhcnRQb3Muc2V0KGNhcHR1cmVOYW1lLCB0b2tlbi5sYXN0SW5kZXgpO1xuICAgICAgICBvcGVuR3JvdXBzLnB1c2goe1xuICAgICAgICAgIG51bTogbnVtQ2FwdHVyZXNQYXNzZWQsXG4gICAgICAgICAgbmFtZTogY2FwdHVyZU5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtWzBdID09PSAnKCcpIHtcbiAgICAgICAgY29uc3QgaXNVbm5hbWVkQ2FwdHVyZSA9IG0gPT09ICcoJztcbiAgICAgICAgaWYgKGlzVW5uYW1lZENhcHR1cmUpIHtcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZCsrO1xuICAgICAgICAgIGdyb3VwQ29udGVudHNTdGFydFBvcy5zZXQoU3RyaW5nKG51bUNhcHR1cmVzUGFzc2VkKSwgdG9rZW4ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuR3JvdXBzLnB1c2goaXNVbm5hbWVkQ2FwdHVyZSA/IHtudW06IG51bUNhcHR1cmVzUGFzc2VkfSA6IHt9KTtcbiAgICAgIH0gZWxzZSBpZiAobSA9PT0gJyknKSB7XG4gICAgICAgIG9wZW5Hcm91cHMucG9wKCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG0gPT09ICddJykge1xuICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuLS07XG4gICAgfVxuICB9XG5cbiAgaGlkZGVuQ2FwdHVyZXMucHVzaCguLi5hZGRlZEhpZGRlbkNhcHR1cmVzKTtcblxuICByZXR1cm4ge1xuICAgIHBhdHRlcm4sXG4gICAgY2FwdHVyZVRyYW5zZmVycyxcbiAgICBoaWRkZW5DYXB0dXJlcyxcbiAgfTtcbn1cblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gbWF4XG4qL1xuZnVuY3Rpb24gYXNzZXJ0TWF4SW5Cb3VuZHMobWF4KSB7XG4gIGNvbnN0IGVyck1zZyA9IGBNYXggZGVwdGggbXVzdCBiZSBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMTAwOyB1c2VkICR7bWF4fWA7XG4gIGlmICghL15bMS05XVxcZCokLy50ZXN0KG1heCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgfVxuICBtYXggPSArbWF4O1xuICBpZiAobWF4IDwgMiB8fCBtYXggPiAxMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgfVxufVxuXG4vKipcbkBwYXJhbSB7c3RyaW5nfSBsZWZ0XG5AcGFyYW0ge3N0cmluZ30gcmlnaHRcbkBwYXJhbSB7bnVtYmVyfSByZXBzXG5AcGFyYW0ge2Jvb2xlYW59IGlzU3VicGF0dGVyblxuQHBhcmFtIHtBcnJheTxudW1iZXI+fSBoaWRkZW5DYXB0dXJlc1xuQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhZGRlZEhpZGRlbkNhcHR1cmVzXG5AcGFyYW0ge251bWJlcn0gbnVtQ2FwdHVyZXNQYXNzZWRcbkByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZnVuY3Rpb24gbWFrZVJlY3Vyc2l2ZShcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIHJlcHMsXG4gIGlzU3VicGF0dGVybixcbiAgaGlkZGVuQ2FwdHVyZXMsXG4gIGFkZGVkSGlkZGVuQ2FwdHVyZXMsXG4gIG51bUNhcHR1cmVzUGFzc2VkXG4pIHtcbiAgY29uc3QgbmFtZXNJblJlY3Vyc2VkID0gbmV3IFNldCgpO1xuICAvLyBDYW4gc2tpcCB0aGlzIHdvcmsgaWYgbm90IG5lZWRlZFxuICBpZiAoaXNTdWJwYXR0ZXJuKSB7XG4gICAgZm9yRWFjaFVuZXNjYXBlZChsZWZ0ICsgcmlnaHQsIG5hbWVkQ2FwdHVyZURlbGltLCAoe2dyb3Vwczoge2NhcHR1cmVOYW1lfX0pID0+IHtcbiAgICAgIG5hbWVzSW5SZWN1cnNlZC5hZGQoY2FwdHVyZU5hbWUpO1xuICAgIH0sIENvbnRleHQuREVGQVVMVCk7XG4gIH1cbiAgY29uc3QgcmVzdCA9IFtcbiAgICByZXBzLFxuICAgIGlzU3VicGF0dGVybiA/IG5hbWVzSW5SZWN1cnNlZCA6IG51bGwsXG4gICAgaGlkZGVuQ2FwdHVyZXMsXG4gICAgYWRkZWRIaWRkZW5DYXB0dXJlcyxcbiAgICBudW1DYXB0dXJlc1Bhc3NlZCxcbiAgXTtcbiAgLy8gRGVwdGggMjogJ2xlZnQoPzpsZWZ0KD86KXJpZ2h0KXJpZ2h0J1xuICAvLyBEZXB0aCAzOiAnbGVmdCg/OmxlZnQoPzpsZWZ0KD86KXJpZ2h0KXJpZ2h0KXJpZ2h0J1xuICAvLyBFbXB0eSBncm91cCBpbiB0aGUgbWlkZGxlIHNlcGFyYXRlcyB0b2tlbnMgYW5kIGFic29yYnMgYSBmb2xsb3dpbmcgcXVhbnRpZmllciBpZiBwcmVzZW50XG4gIHJldHVybiBgJHtsZWZ0fSR7XG4gICAgcmVwZWF0V2l0aERlcHRoKGAoPzoke2xlZnR9YCwgJ2ZvcndhcmQnLCAuLi5yZXN0KVxuICB9KD86KSR7XG4gICAgcmVwZWF0V2l0aERlcHRoKGAke3JpZ2h0fSlgLCAnYmFja3dhcmQnLCAuLi5yZXN0KVxuICB9JHtyaWdodH1gO1xufVxuXG4vKipcbkBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG5AcGFyYW0geydmb3J3YXJkJyB8ICdiYWNrd2FyZCd9IGRpcmVjdGlvblxuQHBhcmFtIHtudW1iZXJ9IHJlcHNcbkBwYXJhbSB7U2V0PHN0cmluZz4gfCBudWxsfSBuYW1lc0luUmVjdXJzZWRcbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaGlkZGVuQ2FwdHVyZXNcbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYWRkZWRIaWRkZW5DYXB0dXJlc1xuQHBhcmFtIHtudW1iZXJ9IG51bUNhcHR1cmVzUGFzc2VkXG5AcmV0dXJucyB7c3RyaW5nfVxuKi9cbmZ1bmN0aW9uIHJlcGVhdFdpdGhEZXB0aChcbiAgcGF0dGVybixcbiAgZGlyZWN0aW9uLFxuICByZXBzLFxuICBuYW1lc0luUmVjdXJzZWQsXG4gIGhpZGRlbkNhcHR1cmVzLFxuICBhZGRlZEhpZGRlbkNhcHR1cmVzLFxuICBudW1DYXB0dXJlc1Bhc3NlZFxuKSB7XG4gIGNvbnN0IHN0YXJ0TnVtID0gMjtcbiAgY29uc3QgZ2V0RGVwdGhOdW0gPSBpID0+IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gKGkgKyBzdGFydE51bSkgOiAocmVwcyAtIGkgKyBzdGFydE51bSAtIDEpO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVwczsgaSsrKSB7XG4gICAgY29uc3QgZGVwdGhOdW0gPSBnZXREZXB0aE51bShpKTtcbiAgICByZXN1bHQgKz0gcmVwbGFjZVVuZXNjYXBlZChcbiAgICAgIHBhdHRlcm4sXG4gICAgICByYCR7Y2FwdHVyZURlbGltfXxcXFxcazwoPzxiYWNrcmVmPltePl0rKT5gLFxuICAgICAgKHswOiBtLCBncm91cHM6IHtjYXB0dXJlTmFtZSwgdW5uYW1lZCwgYmFja3JlZn19KSA9PiB7XG4gICAgICAgIGlmIChiYWNrcmVmICYmIG5hbWVzSW5SZWN1cnNlZCAmJiAhbmFtZXNJblJlY3Vyc2VkLmhhcyhiYWNrcmVmKSkge1xuICAgICAgICAgIC8vIERvbid0IGFsdGVyIGJhY2tyZWZzIHRvIGdyb3VwcyBvdXRzaWRlIHRoZSByZWN1cnNlZCBzdWJwYXR0ZXJuXG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gYF8kJHtkZXB0aE51bX1gO1xuICAgICAgICBpZiAodW5uYW1lZCB8fCBjYXB0dXJlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IGFkZGVkQ2FwdHVyZU51bSA9IG51bUNhcHR1cmVzUGFzc2VkICsgYWRkZWRIaWRkZW5DYXB0dXJlcy5sZW5ndGggKyAxO1xuICAgICAgICAgIGFkZGVkSGlkZGVuQ2FwdHVyZXMucHVzaChhZGRlZENhcHR1cmVOdW0pO1xuICAgICAgICAgIGluY3JlbWVudElmQXRMZWFzdChoaWRkZW5DYXB0dXJlcywgYWRkZWRDYXB0dXJlTnVtKTtcbiAgICAgICAgICByZXR1cm4gdW5uYW1lZCA/IG0gOiBgKD88JHtjYXB0dXJlTmFtZX0ke3N1ZmZpeH0+YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmBcXGs8JHtiYWNrcmVmfSR7c3VmZml4fT5gO1xuICAgICAgfSxcbiAgICAgIENvbnRleHQuREVGQVVMVFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGVzIHRoZSBhcnJheSBpbiBwbGFjZSBieSBpbmNyZW1lbnRpbmcgZWFjaCB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRocmVzaG9sZC5cbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyXG5AcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4qL1xuZnVuY3Rpb24gaW5jcmVtZW50SWZBdExlYXN0KGFyciwgdGhyZXNob2xkKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGFycltpXSsrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbkBwYXJhbSB7TWFwPG51bWJlciwgQXJyYXk8bnVtYmVyPj59IGNhcHR1cmVUcmFuc2ZlcnNcbkBwYXJhbSB7c3RyaW5nfSBsZWZ0XG5AcGFyYW0ge251bWJlcn0gcmVwc1xuQHBhcmFtIHtudW1iZXJ9IG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvblxuQHBhcmFtIHtudW1iZXJ9IG51bUFkZGVkSGlkZGVuQ2FwdHVyZXNQcmVFeHBhbnNpb25cbkBwYXJhbSB7bnVtYmVyfSBudW1DYXB0dXJlc1Bhc3NlZFxuQHJldHVybnMge01hcDxudW1iZXIsIEFycmF5PG51bWJlcj4+fVxuKi9cbmZ1bmN0aW9uIG1hcENhcHR1cmVUcmFuc2ZlcnMoY2FwdHVyZVRyYW5zZmVycywgbGVmdCwgcmVwcywgbnVtQ2FwdHVyZXNBZGRlZEluRXhwYW5zaW9uLCBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uLCBudW1DYXB0dXJlc1Bhc3NlZCkge1xuICBpZiAoY2FwdHVyZVRyYW5zZmVycy5zaXplICYmIG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbikge1xuICAgIGxldCBudW1DYXB0dXJlc0luTGVmdCA9IDA7XG4gICAgZm9yRWFjaFVuZXNjYXBlZChsZWZ0LCBjYXB0dXJlRGVsaW0sICgpID0+IG51bUNhcHR1cmVzSW5MZWZ0KyssIENvbnRleHQuREVGQVVMVCk7XG4gICAgLy8gSXMgMCBmb3IgZ2xvYmFsIHJlY3Vyc2lvblxuICAgIGNvbnN0IHJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSA9IG51bUNhcHR1cmVzUGFzc2VkIC0gbnVtQ2FwdHVyZXNJbkxlZnQgKyBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uO1xuICAgIGNvbnN0IG5ld0NhcHR1cmVUcmFuc2ZlcnMgPSBuZXcgTWFwKCk7XG4gICAgY2FwdHVyZVRyYW5zZmVycy5mb3JFYWNoKChmcm9tLCB0bykgPT4ge1xuICAgICAgY29uc3QgbnVtQ2FwdHVyZXNJblJpZ2h0ID0gKG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbiAtIChudW1DYXB0dXJlc0luTGVmdCAqIHJlcHMpKSAvIHJlcHM7XG4gICAgICBjb25zdCBudW1DYXB0dXJlc0FkZGVkSW5MZWZ0ID0gbnVtQ2FwdHVyZXNJbkxlZnQgKiByZXBzO1xuICAgICAgY29uc3QgbmV3VG8gPSB0byA+IChyZWN1cnNpb25EZWxpbUNhcHR1cmVOdW0gKyBudW1DYXB0dXJlc0luTGVmdCkgPyB0byArIG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbiA6IHRvO1xuICAgICAgY29uc3QgbmV3RnJvbSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmIG9mIGZyb20pIHtcbiAgICAgICAgLy8gQmVmb3JlIHRoZSByZWN1cnNlZCBzdWJwYXR0ZXJuXG4gICAgICAgIGlmIChmIDw9IHJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSkge1xuICAgICAgICAgIG5ld0Zyb20ucHVzaChmKTtcbiAgICAgICAgLy8gQWZ0ZXIgdGhlIHJlY3Vyc2VkIHN1YnBhdHRlcm5cbiAgICAgICAgfSBlbHNlIGlmIChmID4gKHJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSArIG51bUNhcHR1cmVzSW5MZWZ0ICsgbnVtQ2FwdHVyZXNJblJpZ2h0KSkge1xuICAgICAgICAgIG5ld0Zyb20ucHVzaChmICsgbnVtQ2FwdHVyZXNBZGRlZEluRXhwYW5zaW9uKTtcbiAgICAgICAgLy8gV2l0aGluIHRoZSByZWN1cnNlZCBzdWJwYXR0ZXJuLCBvbiB0aGUgbGVmdCBvZiB0aGUgcmVjdXJzaW9uIHRva2VuXG4gICAgICAgIH0gZWxzZSBpZiAoZiA8PSAocmVjdXJzaW9uRGVsaW1DYXB0dXJlTnVtICsgbnVtQ2FwdHVyZXNJbkxlZnQpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcmVwczsgaSsrKSB7XG4gICAgICAgICAgICBuZXdGcm9tLnB1c2goZiArIChudW1DYXB0dXJlc0luTGVmdCAqIGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIC8vIFdpdGhpbiB0aGUgcmVjdXJzZWQgc3VicGF0dGVybiwgb24gdGhlIHJpZ2h0IG9mIHRoZSByZWN1cnNpb24gdG9rZW5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByZXBzOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0Zyb20ucHVzaChmICsgbnVtQ2FwdHVyZXNBZGRlZEluTGVmdCArIChudW1DYXB0dXJlc0luUmlnaHQgKiBpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdDYXB0dXJlVHJhbnNmZXJzLnNldChuZXdUbywgbmV3RnJvbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0NhcHR1cmVUcmFuc2ZlcnM7XG4gIH1cbiAgcmV0dXJuIGNhcHR1cmVUcmFuc2ZlcnM7XG59XG5cbmV4cG9ydCB7XG4gIHJlY3Vyc2lvbixcbn07XG4iXSwibmFtZXMiOlsiQ29udGV4dCIsImZvckVhY2hVbmVzY2FwZWQiLCJnZXRHcm91cENvbnRlbnRzIiwiaGFzVW5lc2NhcGVkIiwicmVwbGFjZVVuZXNjYXBlZCIsInIiLCJTdHJpbmciLCJyYXciLCJnUlRva2VuIiwicmVjdXJzaXZlVG9rZW4iLCJuYW1lZENhcHR1cmVEZWxpbSIsImNhcHR1cmVEZWxpbSIsInRva2VuIiwiUmVnRXhwIiwib3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2ciLCJyZWN1cnNpb24iLCJwYXR0ZXJuIiwiZGF0YSIsImhpZGRlbkNhcHR1cmVzIiwibW9kZSIsImNhcHR1cmVUcmFuc2ZlcnMiLCJNYXAiLCJ0ZXN0IiwiREVGQVVMVCIsIkVycm9yIiwiYWRkZWRIaWRkZW5DYXB0dXJlcyIsImhhc051bWJlcmVkQmFja3JlZiIsImdyb3VwQ29udGVudHNTdGFydFBvcyIsIm9wZW5Hcm91cHMiLCJoYXNSZWN1cnNlZCIsIm51bUNoYXJDbGFzc2VzT3BlbiIsIm51bUNhcHR1cmVzUGFzc2VkIiwibWF0Y2giLCJsYXN0SW5kZXgiLCJleGVjIiwibSIsImdyb3VwcyIsImNhcHR1cmVOYW1lIiwickRlcHRoIiwiZ1JOYW1lT3JOdW0iLCJnUkRlcHRoIiwiYXNzZXJ0TWF4SW5Cb3VuZHMiLCJsZWZ0Iiwic2xpY2UiLCJpbmRleCIsInJpZ2h0IiwicmVwcyIsIm1ha2VSZWN1cnNpdmUiLCJtYXBDYXB0dXJlVHJhbnNmZXJzIiwibGVuZ3RoIiwiaXNXaXRoaW5SZWZmZWRHcm91cCIsImciLCJuYW1lIiwibnVtIiwiaGFzUmVjdXJzZWRXaXRoaW4iLCJzdGFydFBvcyIsImdldCIsImdyb3VwQ29udGVudHMiLCJncm91cENvbnRlbnRzTGVmdCIsImdyb3VwQ29udGVudHNSaWdodCIsIm51bUFkZGVkSGlkZGVuQ2FwdHVyZXNQcmVFeHBhbnNpb24iLCJleHBhbnNpb24iLCJwcmUiLCJwb3N0IiwiZm9yRWFjaCIsInNldCIsInB1c2giLCJpc1VubmFtZWRDYXB0dXJlIiwicG9wIiwibWF4IiwiZXJyTXNnIiwiaXNTdWJwYXR0ZXJuIiwibmFtZXNJblJlY3Vyc2VkIiwiU2V0IiwiYWRkIiwicmVzdCIsInJlcGVhdFdpdGhEZXB0aCIsImRpcmVjdGlvbiIsInN0YXJ0TnVtIiwiZ2V0RGVwdGhOdW0iLCJpIiwicmVzdWx0IiwiZGVwdGhOdW0iLCJ1bm5hbWVkIiwiYmFja3JlZiIsImhhcyIsInN1ZmZpeCIsImFkZGVkQ2FwdHVyZU51bSIsImluY3JlbWVudElmQXRMZWFzdCIsImFyciIsInRocmVzaG9sZCIsIm51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbiIsInNpemUiLCJudW1DYXB0dXJlc0luTGVmdCIsInJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSIsIm5ld0NhcHR1cmVUcmFuc2ZlcnMiLCJmcm9tIiwidG8iLCJudW1DYXB0dXJlc0luUmlnaHQiLCJudW1DYXB0dXJlc0FkZGVkSW5MZWZ0IiwibmV3VG8iLCJuZXdGcm9tIiwiZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js\n");

/***/ })

};
;