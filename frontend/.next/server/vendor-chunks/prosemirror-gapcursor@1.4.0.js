"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-gapcursor@1.4.0";
exports.ids = ["vendor-chunks/prosemirror-gapcursor@1.4.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/prosemirror-gapcursor@1.4.0/node_modules/prosemirror-gapcursor/dist/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/prosemirror-gapcursor@1.4.0/node_modules/prosemirror-gapcursor/dist/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* binding */ GapCursor),\n/* harmony export */   gapCursor: () => (/* binding */ gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/.pnpm/prosemirror-keymap@1.2.3/node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/.pnpm/prosemirror-state@1.4.4/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/.pnpm/prosemirror-view@1.41.5/node_modules/prosemirror-view/dist/index.js\");\n\n\n\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/ class GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n    /**\n    Create a gap cursor.\n    */ constructor($pos){\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n    content() {\n        return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty;\n    }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return {\n            type: \"gapcursor\",\n            pos: this.head\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */ getBookmark() {\n        return new GapBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */ static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null) return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */ static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for(;;){\n            if (!mustMove && GapCursor.valid($pos)) return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for(let d = $pos.depth;; d--){\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                } else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur)) return $cur;\n            }\n            // And then down into the next node\n            for(;;){\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur)) return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos){\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n}\nfunction needsGap(type) {\n    return type.isAtom || type.spec.isolating || type.spec.createGapCursor;\n}\nfunction closedBefore($pos) {\n    for(let d = $pos.depth; d >= 0; d--){\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating) return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for(let before = parent.child(index - 1);; before = before.lastChild){\n            if (before.childCount == 0 && !before.inlineContent || needsGap(before.type)) return true;\n            if (before.inlineContent) return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for(let d = $pos.depth; d >= 0; d--){\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating) return true;\n            continue;\n        }\n        for(let after = parent.child(index);; after = after.firstChild){\n            if (after.childCount == 0 && !after.inlineContent || needsGap(after.type)) return true;\n            if (after.inlineContent) return false;\n        }\n    }\n    return true;\n}\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/ function gapCursor() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween (_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: {\n                beforeinput: beforeinput\n            }\n        }\n    });\n}\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n    return function(state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found) return false;\n        if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable) return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos)) return false;\n    let clickPos = view.posAtCoords({\n        left: event.clientX,\n        top: event.clientY\n    });\n    if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor)) return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert) return false;\n    let frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for(let i = insert.length - 1; i >= 0; i--)frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor)) return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [\n        prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, {\n            key: \"gapcursor\"\n        })\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3ItZ2FwY3Vyc29yQDEuNC4wL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFDZ0M7QUFDaEM7QUFDUztBQUU3RDs7O0FBR0EsR0FDQSxNQUFNUyxrQkFBa0JSLHdEQUFTQTtJQUM3Qjs7SUFFQSxHQUNBUyxZQUFZQyxJQUFJLENBQUU7UUFDZCxLQUFLLENBQUNBLE1BQU1BO0lBQ2hCO0lBQ0FDLElBQUlDLEdBQUcsRUFBRUMsT0FBTyxFQUFFO1FBQ2QsSUFBSUgsT0FBT0UsSUFBSUUsT0FBTyxDQUFDRCxRQUFRRixHQUFHLENBQUMsSUFBSSxDQUFDSSxJQUFJO1FBQzVDLE9BQU9QLFVBQVVRLEtBQUssQ0FBQ04sUUFBUSxJQUFJRixVQUFVRSxRQUFRVix3REFBU0EsQ0FBQ2lCLElBQUksQ0FBQ1A7SUFDeEU7SUFDQVEsVUFBVTtRQUFFLE9BQU9kLG9EQUFLQSxDQUFDZSxLQUFLO0lBQUU7SUFDaENDLEdBQUdDLEtBQUssRUFBRTtRQUNOLE9BQU9BLGlCQUFpQmIsYUFBYWEsTUFBTU4sSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSTtJQUNoRTtJQUNBTyxTQUFTO1FBQ0wsT0FBTztZQUFFQyxNQUFNO1lBQWFDLEtBQUssSUFBSSxDQUFDVCxJQUFJO1FBQUM7SUFDL0M7SUFDQTs7SUFFQSxHQUNBLE9BQU9VLFNBQVNiLEdBQUcsRUFBRWMsSUFBSSxFQUFFO1FBQ3ZCLElBQUksT0FBT0EsS0FBS0YsR0FBRyxJQUFJLFVBQ25CLE1BQU0sSUFBSUcsV0FBVztRQUN6QixPQUFPLElBQUluQixVQUFVSSxJQUFJRSxPQUFPLENBQUNZLEtBQUtGLEdBQUc7SUFDN0M7SUFDQTs7SUFFQSxHQUNBSSxjQUFjO1FBQUUsT0FBTyxJQUFJQyxZQUFZLElBQUksQ0FBQ0MsTUFBTTtJQUFHO0lBQ3JEOztJQUVBLEdBQ0EsT0FB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RztJQUNqQixPQUFPbkgsMkRBQWFBLENBQUNvSCxNQUFNLENBQUNwQyxNQUFNMUUsR0FBRyxFQUFFO1FBQUNMLHdEQUFVQSxDQUFDb0gsTUFBTSxDQUFDckMsTUFBTUksU0FBUyxDQUFDM0UsSUFBSSxFQUFFa0MsTUFBTTtZQUFFMkUsS0FBSztRQUFZO0tBQUc7QUFDaEg7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9zZW1pcnJvci1nYXBjdXJzb3JAMS40LjAvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWdhcGN1cnNvci9kaXN0L2luZGV4LmpzP2Y1OTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2V5ZG93bkhhbmRsZXIgfSBmcm9tICdwcm9zZW1pcnJvci1rZXltYXAnO1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBEZWNvcmF0aW9uU2V0LCBEZWNvcmF0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5cbi8qKlxuR2FwIGN1cnNvciBzZWxlY3Rpb25zIGFyZSByZXByZXNlbnRlZCB1c2luZyB0aGlzIGNsYXNzLiBJdHNcbmAkYW5jaG9yYCBhbmQgYCRoZWFkYCBwcm9wZXJ0aWVzIGJvdGggcG9pbnQgYXQgdGhlIGN1cnNvciBwb3NpdGlvbi5cbiovXG5jbGFzcyBHYXBDdXJzb3IgZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGdhcCBjdXJzb3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkcG9zKSB7XG4gICAgICAgIHN1cGVyKCRwb3MsICRwb3MpO1xuICAgIH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7IHJldHVybiBTbGljZS5lbXB0eTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEdhcEN1cnNvciAmJiBvdGhlci5oZWFkID09IHRoaXMuaGVhZDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImdhcGN1cnNvclwiLCBwb3M6IHRoaXMuaGVhZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBHYXBDdXJzb3IuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgR2FwQ3Vyc29yKGRvYy5yZXNvbHZlKGpzb24ucG9zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBuZXcgR2FwQm9va21hcmsodGhpcy5hbmNob3IpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgdmFsaWQoJHBvcykge1xuICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQuaXNUZXh0YmxvY2sgfHwgIWNsb3NlZEJlZm9yZSgkcG9zKSB8fCAhY2xvc2VkQWZ0ZXIoJHBvcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHBhcmVudC50eXBlLnNwZWMuYWxsb3dHYXBDdXJzb3I7XG4gICAgICAgIGlmIChvdmVycmlkZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgICBsZXQgZGVmbHQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJHBvcy5pbmRleCgpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgcmV0dXJuIGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kR2FwQ3Vyc29yRnJvbSgkcG9zLCBkaXIsIG11c3RNb3ZlID0gZmFsc2UpIHtcbiAgICAgICAgc2VhcmNoOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIW11c3RNb3ZlICYmIEdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcztcbiAgICAgICAgICAgIGxldCBwb3MgPSAkcG9zLnBvcywgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvLyBTY2FuIHVwIGZyb20gdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDwgcGFyZW50LmNoaWxkQ291bnQgOiAkcG9zLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcGFyZW50LmNoaWxkKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgOiAkcG9zLmluZGV4KGQpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgICAgICAgbGV0ICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbmQgdGhlbiBkb3duIGludG8gdGhlIG5leHQgbm9kZVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBpbnNpZGUgPSBkaXIgPiAwID8gbmV4dC5maXJzdENoaWxkIDogbmV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuaXNBdG9tICYmICFuZXh0LmlzVGV4dCAmJiAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwb3MgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyArIG5leHQubm9kZVNpemUgKiBkaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IGluc2lkZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5HYXBDdXJzb3IucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcbkdhcEN1cnNvci5maW5kRnJvbSA9IEdhcEN1cnNvci5maW5kR2FwQ3Vyc29yRnJvbTtcblNlbGVjdGlvbi5qc29uSUQoXCJnYXBjdXJzb3JcIiwgR2FwQ3Vyc29yKTtcbmNsYXNzIEdhcEJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2FwQm9va21hcmsobWFwcGluZy5tYXAodGhpcy5wb3MpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmVlZHNHYXAodHlwZSkge1xuICAgIHJldHVybiB0eXBlLmlzQXRvbSB8fCB0eXBlLnNwZWMuaXNvbGF0aW5nIHx8IHR5cGUuc3BlYy5jcmVhdGVHYXBDdXJzb3I7XG59XG5mdW5jdGlvbiBjbG9zZWRCZWZvcmUoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIC8vIEF0IHRoZSBzdGFydCBvZiB0aGlzIHBhcmVudCwgbG9vayBhdCBuZXh0IG9uZVxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGlmIHRoZSBub2RlIGJlZm9yZSAob3IgaXRzIGZpcnN0IGFuY2VzdG9yKSBpcyBjbG9zZWRcbiAgICAgICAgZm9yIChsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7OyBiZWZvcmUgPSBiZWZvcmUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50KSB8fCBuZWVkc0dhcChiZWZvcmUudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBzdGFydCBvZiBkb2N1bWVudFxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBhZnRlciA9IHBhcmVudC5jaGlsZChpbmRleCk7OyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYWZ0ZXIuY2hpbGRDb3VudCA9PSAwICYmICFhZnRlci5pbmxpbmVDb250ZW50KSB8fCBuZWVkc0dhcChhZnRlci50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhZnRlci5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5DcmVhdGUgYSBnYXAgY3Vyc29yIHBsdWdpbi4gV2hlbiBlbmFibGVkLCB0aGlzIHdpbGwgY2FwdHVyZSBjbGlja3Ncbm5lYXIgYW5kIGFycm93LWtleS1tb3Rpb24gcGFzdCBwbGFjZXMgdGhhdCBkb24ndCBoYXZlIGEgbm9ybWFsbHlcbnNlbGVjdGFibGUgcG9zaXRpb24gbmVhcmJ5LCBhbmQgY3JlYXRlIGEgZ2FwIGN1cnNvciBzZWxlY3Rpb24gZm9yXG50aGVtLiBUaGUgY3Vyc29yIGlzIGRyYXduIGFzIGFuIGVsZW1lbnQgd2l0aCBjbGFzc1xuYFByb3NlTWlycm9yLWdhcGN1cnNvcmAuIFlvdSBjYW4gZWl0aGVyIGluY2x1ZGVcbmBzdHlsZS9nYXBjdXJzb3IuY3NzYCBmcm9tIHRoZSBwYWNrYWdlJ3MgZGlyZWN0b3J5IG9yIGFkZCB5b3VyIG93blxuc3R5bGVzIHRvIG1ha2UgaXQgdmlzaWJsZS5cbiovXG5mdW5jdGlvbiBnYXBDdXJzb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGRyYXdHYXBDdXJzb3IsXG4gICAgICAgICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkYW5jaG9yLnBvcyA9PSAkaGVhZC5wb3MgJiYgR2FwQ3Vyc29yLnZhbGlkKCRoZWFkKSA/IG5ldyBHYXBDdXJzb3IoJGhlYWQpIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVDbGljayxcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHsgYmVmb3JlaW5wdXQ6IGJlZm9yZWlucHV0IH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgICBcIkFycm93TGVmdFwiOiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgICBcIkFycm93UmlnaHRcIjogYXJyb3coXCJob3JpelwiLCAxKSxcbiAgICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgICBcIkFycm93RG93blwiOiBhcnJvdyhcInZlcnRcIiwgMSlcbn0pO1xuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gICAgY29uc3QgZGlyU3RyID0gYXhpcyA9PSBcInZlcnRcIiA/IChkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIpIDogKGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0ICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLCBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcbiAgICAgICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpIHx8ICRzdGFydC5kZXB0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCAkZm91bmQgPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb20oJHN0YXJ0LCBkaXIsIG11c3RNb3ZlKTtcbiAgICAgICAgaWYgKCEkZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRmb3VuZCkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKHZpZXcsIHBvcywgZXZlbnQpIHtcbiAgICBpZiAoIXZpZXcgfHwgIXZpZXcuZWRpdGFibGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIUdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjbGlja1BvcyA9IHZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgaWYgKGNsaWNrUG9zICYmIGNsaWNrUG9zLmluc2lkZSA+IC0xICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChjbGlja1Bvcy5pbnNpZGUpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gVGhpcyBpcyBhIGhhY2sgdGhhdCwgd2hlbiBhIGNvbXBvc2l0aW9uIHN0YXJ0cyB3aGlsZSBhIGdhcCBjdXJzb3Jcbi8vIGlzIGFjdGl2ZSwgcXVpY2tseSBjcmVhdGVzIGFuIGlubGluZSBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRpb24gdG9cbi8vIGhhcHBlbiBpbiwgdG8gYXZvaWQgaXQgYmVpbmcgYWJvcnRlZCBieSB0aGUgRE9NIHNlbGVjdGlvbiBiZWluZ1xuLy8gbW92ZWQgaW50byBhIHZhbGlkIHBvc2l0aW9uLlxuZnVuY3Rpb24gYmVmb3JlaW5wdXQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlICE9IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgfHwgISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGluc2VydCA9ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKS5maW5kV3JhcHBpbmcodmlldy5zdGF0ZS5zY2hlbWEubm9kZXMudGV4dCk7XG4gICAgaWYgKCFpbnNlcnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZnJhZyA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSBpbnNlcnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGZyYWcgPSBGcmFnbWVudC5mcm9tKGluc2VydFtpXS5jcmVhdGVBbmRGaWxsKG51bGwsIGZyYWcpKTtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoJGZyb20ucG9zLCAkZnJvbS5wb3MsIG5ldyBTbGljZShmcmFnLCAwLCAwKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSkpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdHYXBDdXJzb3Ioc3RhdGUpIHtcbiAgICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbm9kZS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWdhcGN1cnNvclwiO1xuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwgeyBrZXk6IFwiZ2FwY3Vyc29yXCIgfSldKTtcbn1cblxuZXhwb3J0IHsgR2FwQ3Vyc29yLCBnYXBDdXJzb3IgfTtcbiJdLCJuYW1lcyI6WyJrZXlkb3duSGFuZGxlciIsIlNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJUZXh0U2VsZWN0aW9uIiwiUGx1Z2luIiwiU2xpY2UiLCJGcmFnbWVudCIsIkRlY29yYXRpb25TZXQiLCJEZWNvcmF0aW9uIiwiR2FwQ3Vyc29yIiwiY29uc3RydWN0b3IiLCIkcG9zIiwibWFwIiwiZG9jIiwibWFwcGluZyIsInJlc29sdmUiLCJoZWFkIiwidmFsaWQiLCJuZWFyIiwiY29udGVudCIsImVtcHR5IiwiZXEiLCJvdGhlciIsInRvSlNPTiIsInR5cGUiLCJwb3MiLCJmcm9tSlNPTiIsImpzb24iLCJSYW5nZUVycm9yIiwiZ2V0Qm9va21hcmsiLCJHYXBCb29rbWFyayIsImFuY2hvciIsInBhcmVudCIsImlzVGV4dGJsb2NrIiwiY2xvc2VkQmVmb3JlIiwiY2xvc2VkQWZ0ZXIiLCJvdmVycmlkZSIsInNwZWMiLCJhbGxvd0dhcEN1cnNvciIsImRlZmx0IiwiY29udGVudE1hdGNoQXQiLCJpbmRleCIsImRlZmF1bHRUeXBlIiwiZmluZEdhcEN1cnNvckZyb20iLCJkaXIiLCJtdXN0TW92ZSIsInNlYXJjaCIsIm5leHQiLCJkIiwiZGVwdGgiLCJub2RlIiwiaW5kZXhBZnRlciIsImNoaWxkQ291bnQiLCJjaGlsZCIsIiRjdXIiLCJpbnNpZGUiLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiaXNBdG9tIiwiaXNUZXh0IiwiaXNTZWxlY3RhYmxlIiwibm9kZVNpemUiLCJwcm90b3R5cGUiLCJ2aXNpYmxlIiwiZmluZEZyb20iLCJqc29uSUQiLCJuZWVkc0dhcCIsImlzb2xhdGluZyIsImNyZWF0ZUdhcEN1cnNvciIsImJlZm9yZSIsImlubGluZUNvbnRlbnQiLCJhZnRlciIsImdhcEN1cnNvciIsInByb3BzIiwiZGVjb3JhdGlvbnMiLCJkcmF3R2FwQ3Vyc29yIiwiY3JlYXRlU2VsZWN0aW9uQmV0d2VlbiIsIl92aWV3IiwiJGFuY2hvciIsIiRoZWFkIiwiaGFuZGxlQ2xpY2siLCJoYW5kbGVLZXlEb3duIiwiaGFuZGxlRE9NRXZlbnRzIiwiYmVmb3JlaW5wdXQiLCJhcnJvdyIsImF4aXMiLCJkaXJTdHIiLCJzdGF0ZSIsImRpc3BhdGNoIiwidmlldyIsInNlbCIsInNlbGVjdGlvbiIsIiRzdGFydCIsIiR0byIsIiRmcm9tIiwiZW5kT2ZUZXh0YmxvY2siLCIkZm91bmQiLCJ0ciIsInNldFNlbGVjdGlvbiIsImV2ZW50IiwiZWRpdGFibGUiLCJjbGlja1BvcyIsInBvc0F0Q29vcmRzIiwibGVmdCIsImNsaWVudFgiLCJ0b3AiLCJjbGllbnRZIiwibm9kZUF0IiwiaW5wdXRUeXBlIiwiaW5zZXJ0IiwiZmluZFdyYXBwaW5nIiwic2NoZW1hIiwibm9kZXMiLCJ0ZXh0IiwiZnJhZyIsImkiLCJsZW5ndGgiLCJmcm9tIiwiY3JlYXRlQW5kRmlsbCIsInJlcGxhY2UiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJjcmVhdGUiLCJ3aWRnZXQiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/prosemirror-gapcursor@1.4.0/node_modules/prosemirror-gapcursor/dist/index.js\n");

/***/ })

};
;