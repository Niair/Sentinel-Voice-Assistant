"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oniguruma-to-es@4.3.4";
exports.ids = ["vendor-chunks/oniguruma-to-es@4.3.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/oniguruma-to-es@4.3.4/node_modules/oniguruma-to-es/dist/esm/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/oniguruma-to-es@4.3.4/node_modules/oniguruma-to-es/dist/esm/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmulatedRegExp: () => (/* binding */ EmulatedRegExp),\n/* harmony export */   toRegExp: () => (/* binding */ toRegExp),\n/* harmony export */   toRegExpDetails: () => (/* binding */ toRegExpDetails)\n/* harmony export */ });\n/* harmony import */ var oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! oniguruma-parser/parser */ \"(ssr)/./node_modules/.pnpm/oniguruma-parser@0.12.1/node_modules/oniguruma-parser/dist/parser/parse.js\");\n/* harmony import */ var oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oniguruma-parser/parser */ \"(ssr)/./node_modules/.pnpm/oniguruma-parser@0.12.1/node_modules/oniguruma-parser/dist/parser/node-utils.js\");\n/* harmony import */ var oniguruma_parser_traverser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! oniguruma-parser/traverser */ \"(ssr)/./node_modules/.pnpm/oniguruma-parser@0.12.1/node_modules/oniguruma-parser/dist/traverser/traverse.js\");\n/* harmony import */ var regex_internals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! regex/internals */ \"(ssr)/./node_modules/.pnpm/regex@6.1.0/node_modules/regex/src/internals.js\");\n/* harmony import */ var regex_recursion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! regex-recursion */ \"(ssr)/./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js\");\n// src/utils.js\nvar cp = String.fromCodePoint;\nvar r = String.raw;\nvar envFlags = {\n    flagGroups: (()=>{\n        try {\n            new RegExp(\"(?i:)\");\n        } catch  {\n            return false;\n        }\n        return true;\n    })(),\n    unicodeSets: (()=>{\n        try {\n            new RegExp(\"[[]]\", \"v\");\n        } catch  {\n            return false;\n        }\n        return true;\n    })()\n};\nenvFlags.bugFlagVLiteralHyphenIsRange = envFlags.unicodeSets ? (()=>{\n    try {\n        new RegExp(r`[\\d\\-a]`, \"v\");\n    } catch  {\n        return true;\n    }\n    return false;\n})() : false;\nenvFlags.bugNestedClassIgnoresNegation = envFlags.unicodeSets && new RegExp(\"[[^a]]\", \"v\").test(\"a\");\nfunction getNewCurrentFlags(current, { enable, disable }) {\n    return {\n        dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n        ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase)\n    };\n}\nfunction getOrInsert(map, key, defaultValue) {\n    if (!map.has(key)) {\n        map.set(key, defaultValue);\n    }\n    return map.get(key);\n}\nfunction isMinTarget(target, min) {\n    return EsVersion[target] >= EsVersion[min];\n}\nfunction throwIfNullish(value, msg) {\n    if (value == null) {\n        throw new Error(msg ?? \"Value expected\");\n    }\n    return value;\n}\n// src/options.js\nvar EsVersion = {\n    ES2025: 2025,\n    ES2024: 2024,\n    ES2018: 2018\n};\nvar Target = /** @type {const} */ {\n    auto: \"auto\",\n    ES2025: \"ES2025\",\n    ES2024: \"ES2024\",\n    ES2018: \"ES2018\"\n};\nfunction getOptions(options = {}) {\n    if (({}).toString.call(options) !== \"[object Object]\") {\n        throw new Error(\"Unexpected options\");\n    }\n    if (options.target !== void 0 && !Target[options.target]) {\n        throw new Error(`Unexpected target \"${options.target}\"`);\n    }\n    const opts = {\n        // Sets the level of emulation rigor/strictness.\n        accuracy: \"default\",\n        // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n        // certain patterns not being emulatable.\n        avoidSubclass: false,\n        // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W`, `y{g}` in any order (all\n        // optional). Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n        flags: \"\",\n        // Include JavaScript flag `g` (`global`) in the result.\n        global: false,\n        // Include JavaScript flag `d` (`hasIndices`) in the result.\n        hasIndices: false,\n        // Delay regex construction until first use if the transpiled pattern is at least this length.\n        lazyCompileLength: Infinity,\n        // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n        // your environment. Later targets allow faster processing, simpler generated source, and\n        // support for additional features.\n        target: \"auto\",\n        // Disables minifications that simplify the pattern without changing the meaning.\n        verbose: false,\n        ...options,\n        // Advanced options that override standard behavior, error checking, and flags when enabled.\n        rules: {\n            // Useful with TextMate grammars that merge backreferences across patterns.\n            allowOrphanBackrefs: false,\n            // Use ASCII `\\b` and `\\B`, which increases search performance of generated regexes.\n            asciiWordBoundaries: false,\n            // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n            // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n            // `vscode-oniguruma`.\n            captureGroup: false,\n            // Change the recursion depth limit from Oniguruma's `20` to an integer `2`–`20`.\n            recursionLimit: 20,\n            // `^` as `\\A`; `$` as`\\Z`. Improves search performance of generated regexes without changing\n            // the meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n            singleline: false,\n            ...options.rules\n        }\n    };\n    if (opts.target === \"auto\") {\n        opts.target = envFlags.flagGroups ? \"ES2025\" : envFlags.unicodeSets ? \"ES2024\" : \"ES2018\";\n    }\n    return opts;\n}\n// src/unicode.js\n\nvar asciiSpaceChar = \"[\t-\\r ]\";\nvar CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([\n    cp(304),\n    // İ\n    cp(305)\n]);\nvar defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\nfunction getIgnoreCaseMatchChars(char) {\n    if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n        return [\n            char\n        ];\n    }\n    const set = /* @__PURE__ */ new Set();\n    const lower = char.toLowerCase();\n    const upper = lower.toUpperCase();\n    const title = LowerToTitleCaseMap.get(lower);\n    const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n    const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n    if ([\n        ...upper\n    ].length === 1) {\n        set.add(upper);\n    }\n    altUpper && set.add(altUpper);\n    title && set.add(title);\n    set.add(lower);\n    altLower && set.add(altLower);\n    return [\n        ...set\n    ];\n}\nvar JsUnicodePropertyMap = /* @__PURE__ */ new Map(`C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.split(/\\s/).map((p)=>[\n        (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.slug)(p),\n        p\n    ]));\nvar LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([\n    [\n        \"s\",\n        cp(383)\n    ],\n    // s, ſ\n    [\n        cp(383),\n        \"s\"\n    ]\n]);\nvar LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([\n    [\n        cp(223),\n        cp(7838)\n    ],\n    // ß, ẞ\n    [\n        cp(107),\n        cp(8490)\n    ],\n    // k, K (Kelvin)\n    [\n        cp(229),\n        cp(8491)\n    ],\n    // å, Å (Angstrom)\n    [\n        cp(969),\n        cp(8486)\n    ]\n]);\nvar LowerToTitleCaseMap = new Map([\n    titleEntry(453),\n    titleEntry(456),\n    titleEntry(459),\n    titleEntry(498),\n    ...titleRange(8072, 8079),\n    ...titleRange(8088, 8095),\n    ...titleRange(8104, 8111),\n    titleEntry(8124),\n    titleEntry(8140),\n    titleEntry(8188)\n]);\nvar PosixClassMap = /* @__PURE__ */ new Map([\n    [\n        \"alnum\",\n        r`[\\p{Alpha}\\p{Nd}]`\n    ],\n    [\n        \"alpha\",\n        r`\\p{Alpha}`\n    ],\n    [\n        \"ascii\",\n        r`\\p{ASCII}`\n    ],\n    [\n        \"blank\",\n        r`[\\p{Zs}\\t]`\n    ],\n    [\n        \"cntrl\",\n        r`\\p{Cc}`\n    ],\n    [\n        \"digit\",\n        r`\\p{Nd}`\n    ],\n    [\n        \"graph\",\n        r`[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]`\n    ],\n    [\n        \"lower\",\n        r`\\p{Lower}`\n    ],\n    [\n        \"print\",\n        r`[[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`\n    ],\n    [\n        \"punct\",\n        r`[\\p{P}\\p{S}]`\n    ],\n    // Updated value from Onig 6.9.9; changed from Unicode `\\p{punct}`\n    [\n        \"space\",\n        r`\\p{space}`\n    ],\n    [\n        \"upper\",\n        r`\\p{Upper}`\n    ],\n    [\n        \"word\",\n        r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`\n    ],\n    [\n        \"xdigit\",\n        r`\\p{AHex}`\n    ]\n]);\nfunction range(start, end) {\n    const range2 = [];\n    for(let i = start; i <= end; i++){\n        range2.push(i);\n    }\n    return range2;\n}\nfunction titleEntry(codePoint) {\n    const char = cp(codePoint);\n    return [\n        char.toLowerCase(),\n        char\n    ];\n}\nfunction titleRange(start, end) {\n    return range(start, end).map((codePoint)=>titleEntry(codePoint));\n}\nvar UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([\n    \"Lower\",\n    \"Lowercase\",\n    \"Upper\",\n    \"Uppercase\",\n    \"Ll\",\n    \"Lowercase_Letter\",\n    \"Lt\",\n    \"Titlecase_Letter\",\n    \"Lu\",\n    \"Uppercase_Letter\"\n]);\n// src/transform.js\n\n\nfunction transform(ast, options) {\n    const opts = {\n        // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n        // - `CharacterSet` kind `text_segment` (`\\X`): An exact representation would require heavy\n        //   Unicode data; a best-effort approximation requires knowing the target.\n        // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode\n        //   representations would be hard to change to ASCII versions after the fact in the generator\n        //   based on `target`/`accuracy`, so produce the appropriate structure here.\n        accuracy: \"default\",\n        asciiWordBoundaries: false,\n        avoidSubclass: false,\n        bestEffortTarget: \"ES2025\",\n        ...options\n    };\n    addParentProperties(ast);\n    const firstPassState = {\n        accuracy: opts.accuracy,\n        asciiWordBoundaries: opts.asciiWordBoundaries,\n        avoidSubclass: opts.avoidSubclass,\n        flagDirectivesByAlt: /* @__PURE__ */ new Map(),\n        jsGroupNameMap: /* @__PURE__ */ new Map(),\n        minTargetEs2024: isMinTarget(opts.bestEffortTarget, \"ES2024\"),\n        passedLookbehind: false,\n        strategy: null,\n        // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n        subroutineRefMap: /* @__PURE__ */ new Map(),\n        supportedGNodes: /* @__PURE__ */ new Set(),\n        digitIsAscii: ast.flags.digitIsAscii,\n        spaceIsAscii: ast.flags.spaceIsAscii,\n        wordIsAscii: ast.flags.wordIsAscii\n    };\n    (0,oniguruma_parser_traverser__WEBPACK_IMPORTED_MODULE_1__.traverse)(ast, FirstPassVisitor, firstPassState);\n    const globalFlags = {\n        dotAll: ast.flags.dotAll,\n        ignoreCase: ast.flags.ignoreCase\n    };\n    const secondPassState = {\n        currentFlags: globalFlags,\n        prevFlags: null,\n        globalFlags,\n        groupOriginByCopy: /* @__PURE__ */ new Map(),\n        groupsByName: /* @__PURE__ */ new Map(),\n        multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),\n        openRefs: /* @__PURE__ */ new Map(),\n        reffedNodesByReferencer: /* @__PURE__ */ new Map(),\n        subroutineRefMap: firstPassState.subroutineRefMap\n    };\n    (0,oniguruma_parser_traverser__WEBPACK_IMPORTED_MODULE_1__.traverse)(ast, SecondPassVisitor, secondPassState);\n    const thirdPassState = {\n        groupsByName: secondPassState.groupsByName,\n        highestOrphanBackref: 0,\n        numCapturesToLeft: 0,\n        reffedNodesByReferencer: secondPassState.reffedNodesByReferencer\n    };\n    (0,oniguruma_parser_traverser__WEBPACK_IMPORTED_MODULE_1__.traverse)(ast, ThirdPassVisitor, thirdPassState);\n    ast._originMap = secondPassState.groupOriginByCopy;\n    ast._strategy = firstPassState.strategy;\n    return ast;\n}\nvar FirstPassVisitor = {\n    AbsenceFunction ({ node, parent, replaceWith }) {\n        const { body, kind } = node;\n        if (kind === \"repeater\") {\n            const innerGroup = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)();\n            innerGroup.body[0].body.push(// Insert own alts as `body`\n            (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createLookaroundAssertion)({\n                negate: true,\n                body\n            }), (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createUnicodeProperty)(\"Any\"));\n            const outerGroup = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)();\n            outerGroup.body[0].body.push((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createQuantifier)(\"greedy\", 0, Infinity, innerGroup));\n            replaceWith(setParentDeep(outerGroup, parent), {\n                traverse: true\n            });\n        } else {\n            throw new Error(`Unsupported absence function \"(?~|\"`);\n        }\n    },\n    Alternative: {\n        enter ({ node, parent, key }, { flagDirectivesByAlt }) {\n            const flagDirectives = node.body.filter((el)=>el.kind === \"flags\");\n            for(let i = key + 1; i < parent.body.length; i++){\n                const forwardSiblingAlt = parent.body[i];\n                getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n            }\n        },\n        exit ({ node }, { flagDirectivesByAlt }) {\n            if (flagDirectivesByAlt.get(node)?.length) {\n                const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n                if (flags) {\n                    const flagGroup = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)({\n                        flags\n                    });\n                    flagGroup.body[0].body = node.body;\n                    node.body = [\n                        setParentDeep(flagGroup, node)\n                    ];\n                }\n            }\n        }\n    },\n    Assertion ({ node, parent, key, container, root, remove, replaceWith }, state) {\n        const { kind, negate } = node;\n        const { asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii } = state;\n        if (kind === \"text_segment_boundary\") {\n            throw new Error(`Unsupported text segment boundary \"\\\\${negate ? \"Y\" : \"y\"}\"`);\n        } else if (kind === \"line_end\") {\n            replaceWith(setParentDeep((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createLookaroundAssertion)({\n                body: [\n                    (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createAlternative)({\n                        body: [\n                            (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createAssertion)(\"string_end\")\n                        ]\n                    }),\n                    (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createAlternative)({\n                        body: [\n                            (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createCharacter)(10)\n                        ]\n                    })\n                ]\n            }), parent));\n        } else if (kind === \"line_start\") {\n            replaceWith(setParentDeep(parseFragment(r`(?<=\\A|\\n(?!\\z))`, {\n                skipLookbehindValidation: true\n            }), parent));\n        } else if (kind === \"search_start\") {\n            if (supportedGNodes.has(node)) {\n                root.flags.sticky = true;\n                remove();\n            } else {\n                const prev = container[key - 1];\n                if (prev && isAlwaysNonZeroLength(prev)) {\n                    replaceWith(setParentDeep((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createLookaroundAssertion)({\n                        negate: true\n                    }), parent));\n                } else if (avoidSubclass) {\n                    throw new Error(r`Uses \"\\G\" in a way that requires a subclass`);\n                } else {\n                    replaceWith(setParent((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createAssertion)(\"string_start\"), parent));\n                    state.strategy = \"clip_search\";\n                }\n            }\n        } else if (kind === \"string_end\" || kind === \"string_start\") {} else if (kind === \"string_end_newline\") {\n            replaceWith(setParentDeep(parseFragment(r`(?=\\n?\\z)`), parent));\n        } else if (kind === \"word_boundary\") {\n            if (!wordIsAscii && !asciiWordBoundaries) {\n                const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n                const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n                replaceWith(setParentDeep(parseFragment(negate ? B : b), parent));\n            }\n        } else {\n            throw new Error(`Unexpected assertion kind \"${kind}\"`);\n        }\n    },\n    Backreference ({ node }, { jsGroupNameMap }) {\n        let { ref } = node;\n        if (typeof ref === \"string\" && !isValidJsGroupName(ref)) {\n            ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n            node.ref = ref;\n        }\n    },\n    CapturingGroup ({ node }, { jsGroupNameMap, subroutineRefMap }) {\n        let { name } = node;\n        if (name && !isValidJsGroupName(name)) {\n            name = getAndStoreJsGroupName(name, jsGroupNameMap);\n            node.name = name;\n        }\n        subroutineRefMap.set(node.number, node);\n        if (name) {\n            subroutineRefMap.set(name, node);\n        }\n    },\n    CharacterClassRange ({ node, parent, replaceWith }) {\n        if (parent.kind === \"intersection\") {\n            const cc = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createCharacterClass)({\n                body: [\n                    node\n                ]\n            });\n            replaceWith(setParentDeep(cc, parent), {\n                traverse: true\n            });\n        }\n    },\n    CharacterSet ({ node, parent, replaceWith }, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n        const { kind, negate, value } = node;\n        if (digitIsAscii && (kind === \"digit\" || value === \"digit\")) {\n            replaceWith(setParent((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createCharacterSet)(\"digit\", {\n                negate\n            }), parent));\n            return;\n        }\n        if (spaceIsAscii && (kind === \"space\" || value === \"space\")) {\n            replaceWith(setParentDeep(setNegate(parseFragment(asciiSpaceChar), negate), parent));\n            return;\n        }\n        if (wordIsAscii && (kind === \"word\" || value === \"word\")) {\n            replaceWith(setParent((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createCharacterSet)(\"word\", {\n                negate\n            }), parent));\n            return;\n        }\n        if (kind === \"any\") {\n            replaceWith(setParent((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createUnicodeProperty)(\"Any\"), parent));\n        } else if (kind === \"digit\") {\n            replaceWith(setParent((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createUnicodeProperty)(\"Nd\", {\n                negate\n            }), parent));\n        } else if (kind === \"dot\") {} else if (kind === \"text_segment\") {\n            if (accuracy === \"strict\") {\n                throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n            }\n            const eBase = \"\\\\p{Emoji}(?:\\\\p{EMod}|\\\\uFE0F\\\\u20E3?|[\\\\x{E0020}-\\\\x{E007E}]+\\\\x{E007F})?\";\n            const emoji = r`\\p{RI}{2}|${eBase}(?:\\u200D${eBase})*`;\n            replaceWith(setParentDeep(parseFragment(// Close approximation of an extended grapheme cluster; see <unicode.org/reports/tr29/>\n            r`(?>\\r\\n|${minTargetEs2024 ? r`\\p{RGI_Emoji}` : emoji}|\\P{M}\\p{M}*)`, // Allow JS property `RGI_Emoji` through\n            {\n                skipPropertyNameValidation: true\n            }), parent));\n        } else if (kind === \"hex\") {\n            replaceWith(setParent((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createUnicodeProperty)(\"AHex\", {\n                negate\n            }), parent));\n        } else if (kind === \"newline\") {\n            replaceWith(setParentDeep(parseFragment(negate ? \"[^\\n]\" : \"(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])\"), parent));\n        } else if (kind === \"posix\") {\n            if (!minTargetEs2024 && (value === \"graph\" || value === \"print\")) {\n                if (accuracy === \"strict\") {\n                    throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n                }\n                let ascii = {\n                    graph: \"!-~\",\n                    print: \" -~\"\n                }[value];\n                if (negate) {\n                    ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n                }\n                replaceWith(setParentDeep(parseFragment(`[${ascii}]`), parent));\n            } else {\n                replaceWith(setParentDeep(setNegate(parseFragment(PosixClassMap.get(value)), negate), parent));\n            }\n        } else if (kind === \"property\") {\n            if (!JsUnicodePropertyMap.has((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.slug)(value))) {\n                node.key = \"sc\";\n            }\n        } else if (kind === \"space\") {\n            replaceWith(setParent((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createUnicodeProperty)(\"space\", {\n                negate\n            }), parent));\n        } else if (kind === \"word\") {\n            replaceWith(setParentDeep(setNegate(parseFragment(defaultWordChar), negate), parent));\n        } else {\n            throw new Error(`Unexpected character set kind \"${kind}\"`);\n        }\n    },\n    Directive ({ node, parent, root, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings }) {\n        const { kind, flags } = node;\n        if (kind === \"flags\") {\n            if (!flags.enable && !flags.disable) {\n                remove();\n            } else {\n                const flagGroup = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)({\n                    flags\n                });\n                flagGroup.body[0].body = removeAllNextSiblings();\n                replaceWith(setParentDeep(flagGroup, parent), {\n                    traverse: true\n                });\n            }\n        } else if (kind === \"keep\") {\n            const firstAlt = root.body[0];\n            const hasWrapperGroup = root.body.length === 1 && // Not emulatable if within a `CapturingGroup`\n            (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_2__.hasOnlyChild)(firstAlt, {\n                type: \"Group\"\n            }) && firstAlt.body[0].body.length === 1;\n            const topLevel = hasWrapperGroup ? firstAlt.body[0] : root;\n            if (parent.parent !== topLevel || topLevel.body.length > 1) {\n                throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n            }\n            const lookbehind = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createLookaroundAssertion)({\n                behind: true\n            });\n            lookbehind.body[0].body = removeAllPrevSiblings();\n            replaceWith(setParentDeep(lookbehind, parent));\n        } else {\n            throw new Error(`Unexpected directive kind \"${kind}\"`);\n        }\n    },\n    Flags ({ node, parent }) {\n        if (node.posixIsAscii) {\n            throw new Error('Unsupported flag \"P\"');\n        }\n        if (node.textSegmentMode === \"word\") {\n            throw new Error('Unsupported flag \"y{w}\"');\n        }\n        [\n            \"digitIsAscii\",\n            // Flag D\n            \"extended\",\n            // Flag x\n            \"posixIsAscii\",\n            // Flag P\n            \"spaceIsAscii\",\n            // Flag S\n            \"wordIsAscii\",\n            // Flag W\n            \"textSegmentMode\"\n        ].forEach((f)=>delete node[f]);\n        Object.assign(node, {\n            // JS flag g; no Onig equiv\n            global: false,\n            // JS flag d; no Onig equiv\n            hasIndices: false,\n            // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n            // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n            // results (also allows `^` and `$` to be used in the generator for string start and end)\n            multiline: false,\n            // JS flag y; no Onig equiv, but used for `\\G` emulation\n            sticky: node.sticky ?? false\n        });\n        parent.options = {\n            disable: {\n                // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n                x: true,\n                // Onig has no flag to control \"named capture only\" mode but contextually applies its\n                // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n                n: true\n            },\n            force: {\n                // Always add flag v because we're generating an AST that relies on it (it enables JS\n                // support for Onig features nested classes, intersection, Unicode properties, etc.).\n                // However, the generator might disable flag v based on its `target` option\n                v: true\n            }\n        };\n    },\n    Group ({ node }) {\n        if (!node.flags) {\n            return;\n        }\n        const { enable, disable } = node.flags;\n        enable?.extended && delete enable.extended;\n        disable?.extended && delete disable.extended;\n        enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n        enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n        enable && !Object.keys(enable).length && delete node.flags.enable;\n        disable && !Object.keys(disable).length && delete node.flags.disable;\n        !node.flags.enable && !node.flags.disable && delete node.flags;\n    },\n    LookaroundAssertion ({ node }, state) {\n        const { kind } = node;\n        if (kind === \"lookbehind\") {\n            state.passedLookbehind = true;\n        }\n    },\n    NamedCallout ({ node, parent, replaceWith }) {\n        const { kind } = node;\n        if (kind === \"fail\") {\n            replaceWith(setParentDeep((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createLookaroundAssertion)({\n                negate: true\n            }), parent));\n        } else {\n            throw new Error(`Unsupported named callout \"(*${kind.toUpperCase()}\"`);\n        }\n    },\n    Quantifier ({ node }) {\n        if (node.body.type === \"Quantifier\") {\n            const group = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)();\n            group.body[0].body.push(node.body);\n            node.body = setParentDeep(group, node);\n        }\n    },\n    Regex: {\n        enter ({ node }, { supportedGNodes }) {\n            const leadingGs = [];\n            let hasAltWithLeadG = false;\n            let hasAltWithoutLeadG = false;\n            for (const alt of node.body){\n                if (alt.body.length === 1 && alt.body[0].kind === \"search_start\") {\n                    alt.body.pop();\n                } else {\n                    const leadingG = getLeadingG(alt.body);\n                    if (leadingG) {\n                        hasAltWithLeadG = true;\n                        Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);\n                    } else {\n                        hasAltWithoutLeadG = true;\n                    }\n                }\n            }\n            if (hasAltWithLeadG && !hasAltWithoutLeadG) {\n                leadingGs.forEach((g)=>supportedGNodes.add(g));\n            }\n        },\n        exit (_, { accuracy, passedLookbehind, strategy }) {\n            if (accuracy === \"strict\" && passedLookbehind && strategy) {\n                throw new Error(r`Uses \"\\G\" in a way that requires non-strict accuracy`);\n            }\n        }\n    },\n    Subroutine ({ node }, { jsGroupNameMap }) {\n        let { ref } = node;\n        if (typeof ref === \"string\" && !isValidJsGroupName(ref)) {\n            ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n            node.ref = ref;\n        }\n    }\n};\nvar SecondPassVisitor = {\n    Backreference ({ node }, { multiplexCapturesToLeftByRef, reffedNodesByReferencer }) {\n        const { orphan, ref } = node;\n        if (!orphan) {\n            reffedNodesByReferencer.set(node, [\n                ...multiplexCapturesToLeftByRef.get(ref).map(({ node: node2 })=>node2)\n            ]);\n        }\n    },\n    CapturingGroup: {\n        enter ({ node, parent, replaceWith, skip }, { groupOriginByCopy, groupsByName, multiplexCapturesToLeftByRef, openRefs, reffedNodesByReferencer }) {\n            const origin = groupOriginByCopy.get(node);\n            if (origin && openRefs.has(node.number)) {\n                const recursion2 = setParent(createRecursion(node.number), parent);\n                reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));\n                replaceWith(recursion2);\n                return;\n            }\n            openRefs.set(node.number, node);\n            multiplexCapturesToLeftByRef.set(node.number, []);\n            if (node.name) {\n                getOrInsert(multiplexCapturesToLeftByRef, node.name, []);\n            }\n            const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n            for(let i = 0; i < multiplexNodes.length; i++){\n                const multiplex = multiplexNodes[i];\n                if (// This group is from subroutine expansion, and there's a multiplex value from either the\n                // origin node or a prior subroutine expansion group with the same origin\n                origin === multiplex.node || origin && origin === multiplex.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion\n                // group that refers to this group\n                node === multiplex.origin) {\n                    multiplexNodes.splice(i, 1);\n                    break;\n                }\n            }\n            multiplexCapturesToLeftByRef.get(node.number).push({\n                node,\n                origin\n            });\n            if (node.name) {\n                multiplexCapturesToLeftByRef.get(node.name).push({\n                    node,\n                    origin\n                });\n            }\n            if (node.name) {\n                const groupsWithSameName = getOrInsert(groupsByName, node.name, /* @__PURE__ */ new Map());\n                let hasDuplicateNameToRemove = false;\n                if (origin) {\n                    hasDuplicateNameToRemove = true;\n                } else {\n                    for (const groupInfo of groupsWithSameName.values()){\n                        if (!groupInfo.hasDuplicateNameToRemove) {\n                            hasDuplicateNameToRemove = true;\n                            break;\n                        }\n                    }\n                }\n                groupsByName.get(node.name).set(node, {\n                    node,\n                    hasDuplicateNameToRemove\n                });\n            }\n        },\n        exit ({ node }, { openRefs }) {\n            openRefs.delete(node.number);\n        }\n    },\n    Group: {\n        enter ({ node }, state) {\n            state.prevFlags = state.currentFlags;\n            if (node.flags) {\n                state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n            }\n        },\n        exit (_, state) {\n            state.currentFlags = state.prevFlags;\n        }\n    },\n    Subroutine ({ node, parent, replaceWith }, state) {\n        const { isRecursive, ref } = node;\n        if (isRecursive) {\n            let reffed = parent;\n            while(reffed = reffed.parent){\n                if (reffed.type === \"CapturingGroup\" && (reffed.name === ref || reffed.number === ref)) {\n                    break;\n                }\n            }\n            state.reffedNodesByReferencer.set(node, reffed);\n            return;\n        }\n        const reffedGroupNode = state.subroutineRefMap.get(ref);\n        const isGlobalRecursion = ref === 0;\n        const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n        cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null);\n        let replacement = expandedSubroutine;\n        if (!isGlobalRecursion) {\n            const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (p)=>p.type === \"Group\" && !!p.flags));\n            const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;\n            if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n                replacement = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)({\n                    flags: getFlagModsFromFlags(reffedGroupFlags)\n                });\n                replacement.body[0].body.push(expandedSubroutine);\n            }\n        }\n        replaceWith(setParentDeep(replacement, parent), {\n            traverse: !isGlobalRecursion\n        });\n    }\n};\nvar ThirdPassVisitor = {\n    Backreference ({ node, parent, replaceWith }, state) {\n        if (node.orphan) {\n            state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n            return;\n        }\n        const reffedNodes = state.reffedNodesByReferencer.get(node);\n        const participants = reffedNodes.filter((reffed)=>canParticipateWithNode(reffed, node));\n        if (!participants.length) {\n            replaceWith(setParentDeep((0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createLookaroundAssertion)({\n                negate: true\n            }), parent));\n        } else if (participants.length > 1) {\n            const group = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)({\n                atomic: true,\n                body: participants.reverse().map((reffed)=>(0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createAlternative)({\n                        body: [\n                            (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createBackreference)(reffed.number)\n                        ]\n                    }))\n            });\n            replaceWith(setParentDeep(group, parent));\n        } else {\n            node.ref = participants[0].number;\n        }\n    },\n    CapturingGroup ({ node }, state) {\n        node.number = ++state.numCapturesToLeft;\n        if (node.name) {\n            if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n                delete node.name;\n            }\n        }\n    },\n    Regex: {\n        exit ({ node }, state) {\n            const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n            for(let i = 0; i < numCapsNeeded; i++){\n                const emptyCapture = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createCapturingGroup)();\n                node.body.at(-1).body.push(emptyCapture);\n            }\n        }\n    },\n    Subroutine ({ node }, state) {\n        if (!node.isRecursive || node.ref === 0) {\n            return;\n        }\n        node.ref = state.reffedNodesByReferencer.get(node).number;\n    }\n};\nfunction addParentProperties(root) {\n    (0,oniguruma_parser_traverser__WEBPACK_IMPORTED_MODULE_1__.traverse)(root, {\n        \"*\" ({ node, parent }) {\n            node.parent = parent;\n        }\n    });\n}\nfunction areFlagsEqual(a, b) {\n    return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\nfunction canParticipateWithNode(capture, node) {\n    let rightmostPoint = node;\n    do {\n        if (rightmostPoint.type === \"Regex\") {\n            return false;\n        }\n        if (rightmostPoint.type === \"Alternative\") {\n            continue;\n        }\n        if (rightmostPoint === capture) {\n            return false;\n        }\n        const kidsOfParent = getKids(rightmostPoint.parent);\n        for (const kid of kidsOfParent){\n            if (kid === rightmostPoint) {\n                break;\n            }\n            if (kid === capture || isAncestorOf(kid, capture)) {\n                return true;\n            }\n        }\n    }while (rightmostPoint = rightmostPoint.parent);\n    throw new Error(\"Unexpected path\");\n}\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n    const store = Array.isArray(obj) ? [] : {};\n    for (const [key, value] of Object.entries(obj)){\n        if (key === \"parent\") {\n            store.parent = Array.isArray(up) ? up2 : up;\n        } else if (value && typeof value === \"object\") {\n            store[key] = cloneCapturingGroup(value, originMap, store, up);\n        } else {\n            if (key === \"type\" && value === \"CapturingGroup\") {\n                originMap.set(store, originMap.get(obj) ?? obj);\n            }\n            store[key] = value;\n        }\n    }\n    return store;\n}\nfunction createRecursion(ref) {\n    const node = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createSubroutine)(ref);\n    node.isRecursive = true;\n    return node;\n}\nfunction getAllParents(node, filterFn) {\n    const results = [];\n    while(node = node.parent){\n        if (!filterFn || filterFn(node)) {\n            results.push(node);\n        }\n    }\n    return results;\n}\nfunction getAndStoreJsGroupName(name, map) {\n    if (map.has(name)) {\n        return map.get(name);\n    }\n    const jsName = `$${map.size}_${name.replace(/^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]/ug, \"_\")}`;\n    map.set(name, jsName);\n    return jsName;\n}\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n    const flagProps = [\n        \"dotAll\",\n        \"ignoreCase\"\n    ];\n    const combinedFlags = {\n        enable: {},\n        disable: {}\n    };\n    flagNodes.forEach(({ flags })=>{\n        flagProps.forEach((prop)=>{\n            if (flags.enable?.[prop]) {\n                delete combinedFlags.disable[prop];\n                combinedFlags.enable[prop] = true;\n            }\n            if (flags.disable?.[prop]) {\n                combinedFlags.disable[prop] = true;\n            }\n        });\n    });\n    if (!Object.keys(combinedFlags.enable).length) {\n        delete combinedFlags.enable;\n    }\n    if (!Object.keys(combinedFlags.disable).length) {\n        delete combinedFlags.disable;\n    }\n    if (combinedFlags.enable || combinedFlags.disable) {\n        return combinedFlags;\n    }\n    return null;\n}\nfunction getFlagModsFromFlags({ dotAll, ignoreCase }) {\n    const mods = {};\n    if (dotAll || ignoreCase) {\n        mods.enable = {};\n        dotAll && (mods.enable.dotAll = true);\n        ignoreCase && (mods.enable.ignoreCase = true);\n    }\n    if (!dotAll || !ignoreCase) {\n        mods.disable = {};\n        !dotAll && (mods.disable.dotAll = true);\n        !ignoreCase && (mods.disable.ignoreCase = true);\n    }\n    return mods;\n}\nfunction getKids(node) {\n    if (!node) {\n        throw new Error(\"Node expected\");\n    }\n    const { body } = node;\n    return Array.isArray(body) ? body : body ? [\n        body\n    ] : null;\n}\nfunction getLeadingG(els) {\n    const firstToConsider = els.find((el)=>el.kind === \"search_start\" || isLoneGLookaround(el, {\n            negate: false\n        }) || !isAlwaysZeroLength(el));\n    if (!firstToConsider) {\n        return null;\n    }\n    if (firstToConsider.kind === \"search_start\") {\n        return firstToConsider;\n    }\n    if (firstToConsider.type === \"LookaroundAssertion\") {\n        return firstToConsider.body[0].body[0];\n    }\n    if (firstToConsider.type === \"CapturingGroup\" || firstToConsider.type === \"Group\") {\n        const gNodesForGroup = [];\n        for (const alt of firstToConsider.body){\n            const leadingG = getLeadingG(alt.body);\n            if (!leadingG) {\n                return null;\n            }\n            Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);\n        }\n        return gNodesForGroup;\n    }\n    return null;\n}\nfunction isAncestorOf(node, descendant) {\n    const kids = getKids(node) ?? [];\n    for (const kid of kids){\n        if (kid === descendant || isAncestorOf(kid, descendant)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isAlwaysZeroLength({ type }) {\n    return type === \"Assertion\" || type === \"Directive\" || type === \"LookaroundAssertion\";\n}\nfunction isAlwaysNonZeroLength(node) {\n    const types = [\n        \"Character\",\n        \"CharacterClass\",\n        \"CharacterSet\"\n    ];\n    return types.includes(node.type) || node.type === \"Quantifier\" && node.min && types.includes(node.body.type);\n}\nfunction isLoneGLookaround(node, options) {\n    const opts = {\n        negate: null,\n        ...options\n    };\n    return node.type === \"LookaroundAssertion\" && (opts.negate === null || node.negate === opts.negate) && node.body.length === 1 && (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_2__.hasOnlyChild)(node.body[0], {\n        type: \"Assertion\",\n        kind: \"search_start\"\n    });\n}\nfunction isValidJsGroupName(name) {\n    return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\nfunction parseFragment(pattern, options) {\n    const ast = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(pattern, {\n        ...options,\n        // Providing a custom set of Unicode property names avoids converting some JS Unicode\n        // properties (ex: `\\p{Alpha}`) to Onig POSIX classes\n        unicodePropertyMap: JsUnicodePropertyMap\n    });\n    const alts = ast.body;\n    if (alts.length > 1 || alts[0].body.length > 1) {\n        return (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)({\n            body: alts\n        });\n    }\n    return alts[0].body[0];\n}\nfunction setNegate(node, negate) {\n    node.negate = negate;\n    return node;\n}\nfunction setParent(node, parent) {\n    node.parent = parent;\n    return node;\n}\nfunction setParentDeep(node, parent) {\n    addParentProperties(node);\n    node.parent = parent;\n    return node;\n}\n// src/generate.js\n\n\nfunction generate(ast, options) {\n    const opts = getOptions(options);\n    const minTargetEs2024 = isMinTarget(opts.target, \"ES2024\");\n    const minTargetEs2025 = isMinTarget(opts.target, \"ES2025\");\n    const recursionLimit = opts.rules.recursionLimit;\n    if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n        throw new Error(\"Invalid recursionLimit; use 2-20\");\n    }\n    let hasCaseInsensitiveNode = null;\n    let hasCaseSensitiveNode = null;\n    if (!minTargetEs2025) {\n        const iStack = [\n            ast.flags.ignoreCase\n        ];\n        (0,oniguruma_parser_traverser__WEBPACK_IMPORTED_MODULE_1__.traverse)(ast, FlagModifierVisitor, {\n            getCurrentModI: ()=>iStack.at(-1),\n            popModI () {\n                iStack.pop();\n            },\n            pushModI (isIOn) {\n                iStack.push(isIOn);\n            },\n            setHasCasedChar () {\n                if (iStack.at(-1)) {\n                    hasCaseInsensitiveNode = true;\n                } else {\n                    hasCaseSensitiveNode = true;\n                }\n            }\n        });\n    }\n    const appliedGlobalFlags = {\n        dotAll: ast.flags.dotAll,\n        // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n        //   used (to avoid unnecessary node expansion).\n        // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n        //   forced without the use of ES2025 flag groups)\n        ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)\n    };\n    let lastNode = ast;\n    const state = {\n        accuracy: opts.accuracy,\n        appliedGlobalFlags,\n        captureMap: /* @__PURE__ */ new Map(),\n        currentFlags: {\n            dotAll: ast.flags.dotAll,\n            ignoreCase: ast.flags.ignoreCase\n        },\n        inCharClass: false,\n        lastNode,\n        originMap: ast._originMap,\n        recursionLimit,\n        useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n        useFlagMods: minTargetEs2025,\n        useFlagV: minTargetEs2024,\n        verbose: opts.verbose\n    };\n    function gen(node) {\n        state.lastNode = lastNode;\n        lastNode = node;\n        const fn = throwIfNullish(generator[node.type], `Unexpected node type \"${node.type}\"`);\n        return fn(node, state, gen);\n    }\n    const result = {\n        pattern: ast.body.map(gen).join(\"|\"),\n        // Could reset `lastNode` at this point via `lastNode = ast`, but it isn't needed by flags\n        flags: gen(ast.flags),\n        options: {\n            ...ast.options\n        }\n    };\n    if (!minTargetEs2024) {\n        delete result.options.force.v;\n        result.options.disable.v = true;\n        result.options.unicodeSetsPlugin = null;\n    }\n    result._captureTransfers = /* @__PURE__ */ new Map();\n    result._hiddenCaptures = [];\n    state.captureMap.forEach((value, key)=>{\n        if (value.hidden) {\n            result._hiddenCaptures.push(key);\n        }\n        if (value.transferTo) {\n            getOrInsert(result._captureTransfers, value.transferTo, []).push(key);\n        }\n    });\n    return result;\n}\nvar FlagModifierVisitor = {\n    \"*\": {\n        enter ({ node }, state) {\n            if (isAnyGroup(node)) {\n                const currentModI = state.getCurrentModI();\n                state.pushModI(node.flags ? getNewCurrentFlags({\n                    ignoreCase: currentModI\n                }, node.flags).ignoreCase : currentModI);\n            }\n        },\n        exit ({ node }, state) {\n            if (isAnyGroup(node)) {\n                state.popModI();\n            }\n        }\n    },\n    Backreference (_, state) {\n        state.setHasCasedChar();\n    },\n    Character ({ node }, state) {\n        if (charHasCase(cp(node.value))) {\n            state.setHasCasedChar();\n        }\n    },\n    CharacterClassRange ({ node, skip }, state) {\n        skip();\n        if (getCasesOutsideCharClassRange(node, {\n            firstOnly: true\n        }).length) {\n            state.setHasCasedChar();\n        }\n    },\n    CharacterSet ({ node }, state) {\n        if (node.kind === \"property\" && UnicodePropertiesWithSpecificCase.has(node.value)) {\n            state.setHasCasedChar();\n        }\n    }\n};\nvar generator = {\n    /**\n  @param {AlternativeNode} node\n  */ Alternative ({ body }, _, gen) {\n        return body.map(gen).join(\"\");\n    },\n    /**\n  @param {AssertionNode} node\n  */ Assertion ({ kind, negate }) {\n        if (kind === \"string_end\") {\n            return \"$\";\n        }\n        if (kind === \"string_start\") {\n            return \"^\";\n        }\n        if (kind === \"word_boundary\") {\n            return negate ? r`\\B` : r`\\b`;\n        }\n        throw new Error(`Unexpected assertion kind \"${kind}\"`);\n    },\n    /**\n  @param {BackreferenceNode} node\n  */ Backreference ({ ref }, state) {\n        if (typeof ref !== \"number\") {\n            throw new Error(\"Unexpected named backref in transformed AST\");\n        }\n        if (!state.useFlagMods && state.accuracy === \"strict\" && state.currentFlags.ignoreCase && !state.captureMap.get(ref).ignoreCase) {\n            throw new Error(\"Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy\");\n        }\n        return \"\\\\\" + ref;\n    },\n    /**\n  @param {CapturingGroupNode} node\n  */ CapturingGroup (node, state, gen) {\n        const { body, name, number } = node;\n        const data = {\n            ignoreCase: state.currentFlags.ignoreCase\n        };\n        const origin = state.originMap.get(node);\n        if (origin) {\n            data.hidden = true;\n            if (number > origin.number) {\n                data.transferTo = origin.number;\n            }\n        }\n        state.captureMap.set(number, data);\n        return `(${name ? `?<${name}>` : \"\"}${body.map(gen).join(\"|\")})`;\n    },\n    /**\n  @param {CharacterNode} node\n  */ Character ({ value }, state) {\n        const char = cp(value);\n        const escaped = getCharEscape(value, {\n            escDigit: state.lastNode.type === \"Backreference\",\n            inCharClass: state.inCharClass,\n            useFlagV: state.useFlagV\n        });\n        if (escaped !== char) {\n            return escaped;\n        }\n        if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n            const cases = getIgnoreCaseMatchChars(char);\n            return state.inCharClass ? cases.join(\"\") : cases.length > 1 ? `[${cases.join(\"\")}]` : cases[0];\n        }\n        return char;\n    },\n    /**\n  @param {CharacterClassNode} node\n  */ CharacterClass (node, state, gen) {\n        const { kind, negate, parent } = node;\n        let { body } = node;\n        if (kind === \"intersection\" && !state.useFlagV) {\n            throw new Error(\"Use of character class intersection requires min target ES2024\");\n        }\n        if (envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV && body.some(isLiteralHyphen)) {\n            body = [\n                (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createCharacter)(45),\n                ...body.filter((kid)=>!isLiteralHyphen(kid))\n            ];\n        }\n        const genClass = ()=>`[${negate ? \"^\" : \"\"}${body.map(gen).join(kind === \"intersection\" ? \"&&\" : \"\")}]`;\n        if (!state.inCharClass) {\n            if (// Already established `kind !== 'intersection'` if `!state.useFlagV`; don't check again\n            (!state.useFlagV || envFlags.bugNestedClassIgnoresNegation) && !negate) {\n                const negatedChildClasses = body.filter((kid)=>kid.type === \"CharacterClass\" && kid.kind === \"union\" && kid.negate);\n                if (negatedChildClasses.length) {\n                    const group = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createGroup)();\n                    const groupFirstAlt = group.body[0];\n                    group.parent = parent;\n                    groupFirstAlt.parent = group;\n                    body = body.filter((kid)=>!negatedChildClasses.includes(kid));\n                    node.body = body;\n                    if (body.length) {\n                        node.parent = groupFirstAlt;\n                        groupFirstAlt.body.push(node);\n                    } else {\n                        group.body.pop();\n                    }\n                    negatedChildClasses.forEach((cc)=>{\n                        const newAlt = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.createAlternative)({\n                            body: [\n                                cc\n                            ]\n                        });\n                        cc.parent = newAlt;\n                        newAlt.parent = group;\n                        group.body.push(newAlt);\n                    });\n                    return gen(group);\n                }\n            }\n            state.inCharClass = true;\n            const result = genClass();\n            state.inCharClass = false;\n            return result;\n        }\n        const firstEl = body[0];\n        if (// Already established that the parent is a char class via `inCharClass`; don't check again\n        kind === \"union\" && !negate && firstEl && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n        ((!state.useFlagV || !state.verbose) && parent.kind === \"union\" && !(envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV) || !state.verbose && parent.kind === \"intersection\" && // JS doesn't allow intersection with union or ranges\n        body.length === 1 && firstEl.type !== \"CharacterClassRange\")) {\n            return body.map(gen).join(\"\");\n        }\n        if (!state.useFlagV && parent.type === \"CharacterClass\") {\n            throw new Error(\"Uses nested character class in a way that requires min target ES2024\");\n        }\n        return genClass();\n    },\n    /**\n  @param {CharacterClassRangeNode} node\n  */ CharacterClassRange (node, state) {\n        const min = node.min.value;\n        const max = node.max.value;\n        const escOpts = {\n            escDigit: false,\n            inCharClass: true,\n            useFlagV: state.useFlagV\n        };\n        const minStr = getCharEscape(min, escOpts);\n        const maxStr = getCharEscape(max, escOpts);\n        const extraChars = /* @__PURE__ */ new Set();\n        if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n            const charsOutsideRange = getCasesOutsideCharClassRange(node);\n            const ranges = getCodePointRangesFromChars(charsOutsideRange);\n            ranges.forEach((value)=>{\n                extraChars.add(Array.isArray(value) ? `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` : getCharEscape(value, escOpts));\n            });\n        }\n        return `${minStr}-${maxStr}${[\n            ...extraChars\n        ].join(\"\")}`;\n    },\n    /**\n  @param {CharacterSetNode} node\n  */ CharacterSet ({ kind, negate, value, key }, state) {\n        if (kind === \"dot\") {\n            return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? \".\" : \"[^]\" : // Onig's only line break char is line feed, unlike JS\n            r`[^\\n]`;\n        }\n        if (kind === \"digit\") {\n            return negate ? r`\\D` : r`\\d`;\n        }\n        if (kind === \"property\") {\n            if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) {\n                throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n            }\n            return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : \"\"}${value}}`;\n        }\n        if (kind === \"word\") {\n            return negate ? r`\\W` : r`\\w`;\n        }\n        throw new Error(`Unexpected character set kind \"${kind}\"`);\n    },\n    /**\n  @param {FlagsNode} node\n  */ Flags (node, state) {\n        return(// The transformer should never turn on the properties for flags d, g, m since Onig doesn't\n        // have equivs. Flag m is never used since Onig uses different line break chars than JS\n        // (node.hasIndices ? 'd' : '') +\n        // (node.global ? 'g' : '') +\n        // (node.multiline ? 'm' : '') +\n        (state.appliedGlobalFlags.ignoreCase ? \"i\" : \"\") + (node.dotAll ? \"s\" : \"\") + (node.sticky ? \"y\" : \"\"));\n    },\n    /**\n  @param {GroupNode} node\n  */ Group ({ atomic: atomic2, body, flags, parent }, state, gen) {\n        const currentFlags = state.currentFlags;\n        if (flags) {\n            state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n        }\n        const contents = body.map(gen).join(\"|\");\n        const result = !state.verbose && body.length === 1 && // Single alt\n        parent.type !== \"Quantifier\" && !atomic2 && (!state.useFlagMods || !flags) ? contents : `(?${getGroupPrefix(atomic2, flags, state.useFlagMods)}${contents})`;\n        state.currentFlags = currentFlags;\n        return result;\n    },\n    /**\n  @param {LookaroundAssertionNode} node\n  */ LookaroundAssertion ({ body, kind, negate }, _, gen) {\n        const prefix = `${kind === \"lookahead\" ? \"\" : \"<\"}${negate ? \"!\" : \"=\"}`;\n        return `(?${prefix}${body.map(gen).join(\"|\")})`;\n    },\n    /**\n  @param {QuantifierNode} node\n  */ Quantifier (node, _, gen) {\n        return gen(node.body) + getQuantifierStr(node);\n    },\n    /**\n  @param {SubroutineNode & {isRecursive: true}} node\n  */ Subroutine ({ isRecursive, ref }, state) {\n        if (!isRecursive) {\n            throw new Error(\"Unexpected non-recursive subroutine in transformed AST\");\n        }\n        const limit = state.recursionLimit;\n        return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n    }\n};\nvar BaseEscapeChars = /* @__PURE__ */ new Set([\n    \"$\",\n    \"(\",\n    \")\",\n    \"*\",\n    \"+\",\n    \".\",\n    \"?\",\n    \"[\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    \"{\",\n    \"|\",\n    \"}\"\n]);\nvar CharClassEscapeChars = /* @__PURE__ */ new Set([\n    \"-\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n    // linters and regex syntax processors that expect unescaped `[` to create a nested class\n    \"[\"\n]);\nvar CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([\n    \"(\",\n    \")\",\n    \"-\",\n    \"/\",\n    \"[\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    \"{\",\n    \"|\",\n    \"}\",\n    // Double punctuators; also includes already-listed `-` and `^`\n    \"!\",\n    \"#\",\n    \"$\",\n    \"%\",\n    \"&\",\n    \"*\",\n    \"+\",\n    \",\",\n    \".\",\n    \":\",\n    \";\",\n    \"<\",\n    \"=\",\n    \">\",\n    \"?\",\n    \"@\",\n    \"`\",\n    \"~\"\n]);\nvar CharCodeEscapeMap = /* @__PURE__ */ new Map([\n    [\n        9,\n        r`\\t`\n    ],\n    // horizontal tab\n    [\n        10,\n        r`\\n`\n    ],\n    // line feed\n    [\n        11,\n        r`\\v`\n    ],\n    // vertical tab\n    [\n        12,\n        r`\\f`\n    ],\n    // form feed\n    [\n        13,\n        r`\\r`\n    ],\n    // carriage return\n    [\n        8232,\n        r`\\u2028`\n    ],\n    // line separator\n    [\n        8233,\n        r`\\u2029`\n    ],\n    // paragraph separator\n    [\n        65279,\n        r`\\uFEFF`\n    ]\n]);\nvar casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n    return casedRe.test(char);\n}\nfunction getCasesOutsideCharClassRange(node, options) {\n    const firstOnly = !!options?.firstOnly;\n    const min = node.min.value;\n    const max = node.max.value;\n    const found = [];\n    if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) {\n        return found;\n    }\n    for(let i = min; i <= max; i++){\n        const char = cp(i);\n        if (!charHasCase(char)) {\n            continue;\n        }\n        const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar)=>{\n            const num = caseOfChar.codePointAt(0);\n            return num < min || num > max;\n        });\n        if (charsOutsideRange.length) {\n            found.push(...charsOutsideRange);\n            if (firstOnly) {\n                break;\n            }\n        }\n    }\n    return found;\n}\nfunction getCharEscape(codePoint, { escDigit, inCharClass, useFlagV }) {\n    if (CharCodeEscapeMap.has(codePoint)) {\n        return CharCodeEscapeMap.get(codePoint);\n    }\n    if (// Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || codePoint > 126 && codePoint < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    escDigit && isDigitCharCode(codePoint)) {\n        return codePoint > 255 ? `\\\\u{${codePoint.toString(16).toUpperCase()}}` : `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, \"0\")}`;\n    }\n    const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;\n    const char = cp(codePoint);\n    return (escapeChars.has(char) ? \"\\\\\" : \"\") + char;\n}\nfunction getCodePointRangesFromChars(chars) {\n    const codePoints = chars.map((char)=>char.codePointAt(0)).sort((a, b)=>a - b);\n    const values = [];\n    let start = null;\n    for(let i = 0; i < codePoints.length; i++){\n        if (codePoints[i + 1] === codePoints[i] + 1) {\n            start ??= codePoints[i];\n        } else if (start === null) {\n            values.push(codePoints[i]);\n        } else {\n            values.push([\n                start,\n                codePoints[i]\n            ]);\n            start = null;\n        }\n    }\n    return values;\n}\nfunction getGroupPrefix(atomic2, flagMods, useFlagMods) {\n    if (atomic2) {\n        return \">\";\n    }\n    let mods = \"\";\n    if (flagMods && useFlagMods) {\n        const { enable, disable } = flagMods;\n        mods = (enable?.ignoreCase ? \"i\" : \"\") + (enable?.dotAll ? \"s\" : \"\") + (disable ? \"-\" : \"\") + (disable?.ignoreCase ? \"i\" : \"\") + (disable?.dotAll ? \"s\" : \"\");\n    }\n    return `${mods}:`;\n}\nfunction getQuantifierStr({ kind, max, min }) {\n    let base;\n    if (!min && max === 1) {\n        base = \"?\";\n    } else if (!min && max === Infinity) {\n        base = \"*\";\n    } else if (min === 1 && max === Infinity) {\n        base = \"+\";\n    } else if (min === max) {\n        base = `{${min}}`;\n    } else {\n        base = `{${min},${max === Infinity ? \"\" : max}}`;\n    }\n    return base + ({\n        greedy: \"\",\n        lazy: \"?\",\n        possessive: \"+\"\n    })[kind];\n}\nfunction isAnyGroup({ type }) {\n    return type === \"CapturingGroup\" || type === \"Group\" || type === \"LookaroundAssertion\";\n}\nfunction isDigitCharCode(value) {\n    return value > 47 && value < 58;\n}\nfunction isLiteralHyphen({ type, value }) {\n    return type === \"Character\" && value === 45;\n}\n// src/subclass.js\nvar EmulatedRegExp = class _EmulatedRegExp extends RegExp {\n    /**\n  @type {Map<number, {\n    hidden?: true;\n    transferTo?: number;\n  }>}\n  */ #captureMap;\n    /**\n  @type {RegExp | EmulatedRegExp | null}\n  */ #compiled;\n    /**\n  @type {string}\n  */ #pattern;\n    /**\n  @type {Map<number, string>?}\n  */ #nameMap;\n    /**\n  @type {string?}\n  */ #strategy;\n    // Override the getter with one that works with lazy-compiled regexes\n    get source() {\n        return this.#pattern || \"(?:)\";\n    }\n    /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */ /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */ constructor(pattern, flags, options){\n        const lazyCompile = !!options?.lazyCompile;\n        if (pattern instanceof RegExp) {\n            if (options) {\n                throw new Error(\"Cannot provide options when copying a regexp\");\n            }\n            const re = pattern;\n            super(re, flags);\n            this.#captureMap = /* @__PURE__ */ new Map();\n            this.#compiled = null;\n            this.#nameMap = null;\n            this.#strategy = null;\n            /**\n  Can be used to serialize the instance.\n  @type {EmulatedRegExpOptions}\n  */ this.rawOptions = {};\n            this.#pattern = re.source;\n            if (re instanceof _EmulatedRegExp) {\n                this.#captureMap = re.#captureMap;\n                this.#nameMap = re.#nameMap;\n                this.#strategy = re.#strategy;\n                this.rawOptions = re.rawOptions;\n            }\n        } else {\n            const opts = {\n                hiddenCaptures: [],\n                strategy: null,\n                transfers: [],\n                ...options\n            };\n            super(lazyCompile ? \"\" : pattern, flags);\n            this.#captureMap = new Map();\n            this.#compiled = null;\n            this.#nameMap = null;\n            this.#strategy = null;\n            this.rawOptions = {};\n            this.#pattern = pattern;\n            this.#captureMap = createCaptureMap(opts.hiddenCaptures, opts.transfers);\n            this.#strategy = opts.strategy;\n            this.rawOptions = options ?? {};\n        }\n        if (!lazyCompile) {\n            this.#compiled = this;\n        }\n    }\n    /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray?}\n  */ exec(str) {\n        if (!this.#compiled) {\n            const { lazyCompile, ...rest } = this.rawOptions;\n            this.#compiled = new _EmulatedRegExp(this.#pattern, this.flags, rest);\n        }\n        const useLastIndex = this.global || this.sticky;\n        const pos = this.lastIndex;\n        if (this.#strategy === \"clip_search\" && useLastIndex && pos) {\n            this.lastIndex = 0;\n            const match = this.#execCore(str.slice(pos));\n            if (match) {\n                adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);\n                this.lastIndex += pos;\n            }\n            return match;\n        }\n        return this.#execCore(str);\n    }\n    /**\n  Adds support for hidden and transfer captures.\n  @param {string} str\n  @returns\n  */ #execCore(str) {\n        this.#compiled.lastIndex = this.lastIndex;\n        const match = super.exec.call(this.#compiled, str);\n        this.lastIndex = this.#compiled.lastIndex;\n        if (!match || !this.#captureMap.size) {\n            return match;\n        }\n        const matchCopy = [\n            ...match\n        ];\n        match.length = 1;\n        let indicesCopy;\n        if (this.hasIndices) {\n            indicesCopy = [\n                ...match.indices\n            ];\n            match.indices.length = 1;\n        }\n        const mappedNums = [\n            0\n        ];\n        for(let i = 1; i < matchCopy.length; i++){\n            const { hidden, transferTo } = this.#captureMap.get(i) ?? {};\n            if (hidden) {\n                mappedNums.push(null);\n            } else {\n                mappedNums.push(match.length);\n                match.push(matchCopy[i]);\n                if (this.hasIndices) {\n                    match.indices.push(indicesCopy[i]);\n                }\n            }\n            if (transferTo && matchCopy[i] !== void 0) {\n                const to = mappedNums[transferTo];\n                if (!to) {\n                    throw new Error(`Invalid capture transfer to \"${to}\"`);\n                }\n                match[to] = matchCopy[i];\n                if (this.hasIndices) {\n                    match.indices[to] = indicesCopy[i];\n                }\n                if (match.groups) {\n                    if (!this.#nameMap) {\n                        this.#nameMap = createNameMap(this.source);\n                    }\n                    const name = this.#nameMap.get(transferTo);\n                    if (name) {\n                        match.groups[name] = matchCopy[i];\n                        if (this.hasIndices) {\n                            match.indices.groups[name] = indicesCopy[i];\n                        }\n                    }\n                }\n            }\n        }\n        return match;\n    }\n};\nfunction adjustMatchDetailsForOffset(match, offset, input, hasIndices) {\n    match.index += offset;\n    match.input = input;\n    if (hasIndices) {\n        const indices = match.indices;\n        for(let i = 0; i < indices.length; i++){\n            const arr = indices[i];\n            if (arr) {\n                indices[i] = [\n                    arr[0] + offset,\n                    arr[1] + offset\n                ];\n            }\n        }\n        const groupIndices = indices.groups;\n        if (groupIndices) {\n            Object.keys(groupIndices).forEach((key)=>{\n                const arr = groupIndices[key];\n                if (arr) {\n                    groupIndices[key] = [\n                        arr[0] + offset,\n                        arr[1] + offset\n                    ];\n                }\n            });\n        }\n    }\n}\nfunction createCaptureMap(hiddenCaptures, transfers) {\n    const captureMap = /* @__PURE__ */ new Map();\n    for (const num of hiddenCaptures){\n        captureMap.set(num, {\n            hidden: true\n        });\n    }\n    for (const [to, from] of transfers){\n        for (const num of from){\n            getOrInsert(captureMap, num, {}).transferTo = to;\n        }\n    }\n    return captureMap;\n}\nfunction createNameMap(pattern) {\n    const re = /(?<capture>\\((?:\\?<(?![=!])(?<name>[^>]+)>|(?!\\?)))|\\\\?./gsu;\n    const map = /* @__PURE__ */ new Map();\n    let numCharClassesOpen = 0;\n    let numCaptures = 0;\n    let match;\n    while(match = re.exec(pattern)){\n        const { 0: m, groups: { capture, name } } = match;\n        if (m === \"[\") {\n            numCharClassesOpen++;\n        } else if (!numCharClassesOpen) {\n            if (capture) {\n                numCaptures++;\n                if (name) {\n                    map.set(numCaptures, name);\n                }\n            }\n        } else if (m === \"]\") {\n            numCharClassesOpen--;\n        }\n    }\n    return map;\n}\n// src/index.js\n\n\n\nfunction toRegExp(pattern, options) {\n    const d = toRegExpDetails(pattern, options);\n    if (d.options) {\n        return new EmulatedRegExp(d.pattern, d.flags, d.options);\n    }\n    return new RegExp(d.pattern, d.flags);\n}\nfunction toRegExpDetails(pattern, options) {\n    const opts = getOptions(options);\n    const onigurumaAst = (0,oniguruma_parser_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(pattern, {\n        flags: opts.flags,\n        normalizeUnknownPropertyNames: true,\n        rules: {\n            captureGroup: opts.rules.captureGroup,\n            singleline: opts.rules.singleline\n        },\n        skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n        unicodePropertyMap: JsUnicodePropertyMap\n    });\n    const regexPlusAst = transform(onigurumaAst, {\n        accuracy: opts.accuracy,\n        asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n        avoidSubclass: opts.avoidSubclass,\n        bestEffortTarget: opts.target\n    });\n    const generated = generate(regexPlusAst, opts);\n    const recursionResult = (0,regex_recursion__WEBPACK_IMPORTED_MODULE_4__.recursion)(generated.pattern, {\n        captureTransfers: generated._captureTransfers,\n        hiddenCaptures: generated._hiddenCaptures,\n        mode: \"external\"\n    });\n    const possessiveResult = (0,regex_internals__WEBPACK_IMPORTED_MODULE_3__.possessive)(recursionResult.pattern);\n    const atomicResult = (0,regex_internals__WEBPACK_IMPORTED_MODULE_3__.atomic)(possessiveResult.pattern, {\n        captureTransfers: recursionResult.captureTransfers,\n        hiddenCaptures: recursionResult.hiddenCaptures\n    });\n    const details = {\n        pattern: atomicResult.pattern,\n        flags: `${opts.hasIndices ? \"d\" : \"\"}${opts.global ? \"g\" : \"\"}${generated.flags}${generated.options.disable.v ? \"u\" : \"v\"}`\n    };\n    if (opts.avoidSubclass) {\n        if (opts.lazyCompileLength !== Infinity) {\n            throw new Error(\"Lazy compilation requires subclass\");\n        }\n    } else {\n        const hiddenCaptures = atomicResult.hiddenCaptures.sort((a, b)=>a - b);\n        const transfers = Array.from(atomicResult.captureTransfers);\n        const strategy = regexPlusAst._strategy;\n        const lazyCompile = details.pattern.length >= opts.lazyCompileLength;\n        if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) {\n            details.options = {\n                ...hiddenCaptures.length && {\n                    hiddenCaptures\n                },\n                ...transfers.length && {\n                    transfers\n                },\n                ...strategy && {\n                    strategy\n                },\n                ...lazyCompile && {\n                    lazyCompile\n                }\n            };\n        }\n    }\n    return details;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vb25pZ3VydW1hLXRvLWVzQDQuMy40L25vZGVfbW9kdWxlcy9vbmlndXJ1bWEtdG8tZXMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsSUFBSUEsS0FBS0MsT0FBT0MsYUFBYTtBQUM3QixJQUFJQyxJQUFJRixPQUFPRyxHQUFHO0FBQ2xCLElBQUlDLFdBQVc7SUFDYkMsWUFBWSxDQUFDO1FBQ1gsSUFBSTtZQUNGLElBQUlDLE9BQU87UUFDYixFQUFFLE9BQU07WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQUMsYUFBYSxDQUFDO1FBQ1osSUFBSTtZQUNGLElBQUlELE9BQU8sUUFBUTtRQUNyQixFQUFFLE9BQU07WUFDTixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUNBRixTQUFTSSw0QkFBNEIsR0FBR0osU0FBU0csV0FBVyxHQUFHLENBQUM7SUFDOUQsSUFBSTtRQUNGLElBQUlELE9BQU9KLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUN6QixFQUFFLE9BQU07UUFDTixPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1QsT0FBTztBQUNQRSxTQUFTSyw2QkFBNkIsR0FBR0wsU0FBU0csV0FBVyxJQUFJLElBQUlELE9BQU8sVUFBVSxLQUFLSSxJQUFJLENBQUM7QUFDaEcsU0FBU0MsbUJBQW1CQyxPQUFPLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUU7SUFDdEQsT0FBTztRQUNMQyxRQUFRLENBQUNELFNBQVNDLFVBQVUsQ0FBQyxDQUFFRixDQUFBQSxRQUFRRSxVQUFVSCxRQUFRRyxNQUFNO1FBQy9EQyxZQUFZLENBQUNGLFNBQVNFLGNBQWMsQ0FBQyxDQUFFSCxDQUFBQSxRQUFRRyxjQUFjSixRQUFRSSxVQUFVO0lBQ2pGO0FBQ0Y7QUFDQSxTQUFTQyxZQUFZQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsWUFBWTtJQUN6QyxJ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QjlQLE9BQU8sQ0FBQyxFQUFFSCxLQUFLSyxVQUFVLEdBQUcsTUFBTSxHQUFHLEVBQUVMLEtBQUtJLE1BQU0sR0FBRyxNQUFNLEdBQUcsRUFBRW9ZLFVBQVVyWSxLQUFLLENBQUMsRUFBRXFZLFVBQVUzWSxPQUFPLENBQUN4QixPQUFPLENBQUNrTSxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUM7SUFDN0g7SUFDQSxJQUFJdkssS0FBS0UsYUFBYSxFQUFFO1FBQ3RCLElBQUlGLEtBQUtNLGlCQUFpQixLQUFLQyxVQUFVO1lBQ3ZDLE1BQU0sSUFBSWpCLE1BQU07UUFDbEI7SUFDRixPQUFPO1FBQ0wsTUFBTTRXLGlCQUFpQjJDLGFBQWEzQyxjQUFjLENBQUNmLElBQUksQ0FBQyxDQUFDbkgsR0FBR2pHLElBQU1pRyxJQUFJakc7UUFDdEUsTUFBTW9PLFlBQVk1SyxNQUFNb00sSUFBSSxDQUFDa0IsYUFBYUgsZ0JBQWdCO1FBQzFELE1BQU1oVSxXQUFXNlQsYUFBYXZTLFNBQVM7UUFDdkMsTUFBTStQLGNBQWMrQyxRQUFRN0ksT0FBTyxDQUFDak8sTUFBTSxJQUFJaEMsS0FBS00saUJBQWlCO1FBQ3BFLElBQUk0VixlQUFlbFUsTUFBTSxJQUFJbVUsVUFBVW5VLE1BQU0sSUFBSTBDLFlBQVlxUixhQUFhO1lBQ3hFK0MsUUFBUWpaLE9BQU8sR0FBRztnQkFDaEIsR0FBR3FXLGVBQWVsVSxNQUFNLElBQUk7b0JBQUVrVTtnQkFBZSxDQUFDO2dCQUM5QyxHQUFHQyxVQUFVblUsTUFBTSxJQUFJO29CQUFFbVU7Z0JBQVUsQ0FBQztnQkFDcEMsR0FBR3pSLFlBQVk7b0JBQUVBO2dCQUFTLENBQUM7Z0JBQzNCLEdBQUdxUixlQUFlO29CQUFFQTtnQkFBWSxDQUFDO1lBQ25DO1FBQ0Y7SUFDRjtJQUNBLE9BQU8rQztBQUNUO0FBS0UsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9vbmlndXJ1bWEtdG8tZXNANC4zLjQvbm9kZV9tb2R1bGVzL29uaWd1cnVtYS10by1lcy9kaXN0L2VzbS9pbmRleC5qcz9lN2ZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy5qc1xudmFyIGNwID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG52YXIgciA9IFN0cmluZy5yYXc7XG52YXIgZW52RmxhZ3MgPSB7XG4gIGZsYWdHcm91cHM6ICgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBSZWdFeHAoXCIoP2k6KVwiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pKCksXG4gIHVuaWNvZGVTZXRzOiAoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgUmVnRXhwKFwiW1tdXVwiLCBcInZcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KSgpXG59O1xuZW52RmxhZ3MuYnVnRmxhZ1ZMaXRlcmFsSHlwaGVuSXNSYW5nZSA9IGVudkZsYWdzLnVuaWNvZGVTZXRzID8gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBuZXcgUmVnRXhwKHJgW1xcZFxcLWFdYCwgXCJ2XCIpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSgpIDogZmFsc2U7XG5lbnZGbGFncy5idWdOZXN0ZWRDbGFzc0lnbm9yZXNOZWdhdGlvbiA9IGVudkZsYWdzLnVuaWNvZGVTZXRzICYmIG5ldyBSZWdFeHAoXCJbW15hXV1cIiwgXCJ2XCIpLnRlc3QoXCJhXCIpO1xuZnVuY3Rpb24gZ2V0TmV3Q3VycmVudEZsYWdzKGN1cnJlbnQsIHsgZW5hYmxlLCBkaXNhYmxlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBkb3RBbGw6ICFkaXNhYmxlPy5kb3RBbGwgJiYgISEoZW5hYmxlPy5kb3RBbGwgfHwgY3VycmVudC5kb3RBbGwpLFxuICAgIGlnbm9yZUNhc2U6ICFkaXNhYmxlPy5pZ25vcmVDYXNlICYmICEhKGVuYWJsZT8uaWdub3JlQ2FzZSB8fCBjdXJyZW50Lmlnbm9yZUNhc2UpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckluc2VydChtYXAsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgbWFwLnNldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG1hcC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTWluVGFyZ2V0KHRhcmdldCwgbWluKSB7XG4gIHJldHVybiBFc1ZlcnNpb25bdGFyZ2V0XSA+PSBFc1ZlcnNpb25bbWluXTtcbn1cbmZ1bmN0aW9uIHRocm93SWZOdWxsaXNoKHZhbHVlLCBtc2cpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnID8/IFwiVmFsdWUgZXhwZWN0ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvb3B0aW9ucy5qc1xudmFyIEVzVmVyc2lvbiA9IHtcbiAgRVMyMDI1OiAyMDI1LFxuICBFUzIwMjQ6IDIwMjQsXG4gIEVTMjAxODogMjAxOFxufTtcbnZhciBUYXJnZXQgPSAoXG4gIC8qKiBAdHlwZSB7Y29uc3R9ICovXG4gIHtcbiAgICBhdXRvOiBcImF1dG9cIixcbiAgICBFUzIwMjU6IFwiRVMyMDI1XCIsXG4gICAgRVMyMDI0OiBcIkVTMjAyNFwiLFxuICAgIEVTMjAxODogXCJFUzIwMThcIlxuICB9XG4pO1xuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgaWYgKHt9LnRvU3RyaW5nLmNhbGwob3B0aW9ucykgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG9wdGlvbnNcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGFyZ2V0ICE9PSB2b2lkIDAgJiYgIVRhcmdldFtvcHRpb25zLnRhcmdldF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdGFyZ2V0IFwiJHtvcHRpb25zLnRhcmdldH1cImApO1xuICB9XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgLy8gU2V0cyB0aGUgbGV2ZWwgb2YgZW11bGF0aW9uIHJpZ29yL3N0cmljdG5lc3MuXG4gICAgYWNjdXJhY3k6IFwiZGVmYXVsdFwiLFxuICAgIC8vIERpc2FibGVzIGFkdmFuY2VkIGVtdWxhdGlvbiB0aGF0IHJlbGllcyBvbiByZXR1cm5pbmcgYSBgUmVnRXhwYCBzdWJjbGFzcywgcmVzdWx0aW5nIGluXG4gICAgLy8gY2VydGFpbiBwYXR0ZXJucyBub3QgYmVpbmcgZW11bGF0YWJsZS5cbiAgICBhdm9pZFN1YmNsYXNzOiBmYWxzZSxcbiAgICAvLyBPbmlndXJ1bWEgZmxhZ3M7IGEgc3RyaW5nIHdpdGggYGlgLCBgbWAsIGB4YCwgYERgLCBgU2AsIGBXYCwgYHl7Z31gIGluIGFueSBvcmRlciAoYWxsXG4gICAgLy8gb3B0aW9uYWwpLiBPbmlndXJ1bWEncyBgbWAgaXMgZXF1aXZhbGVudCB0byBKYXZhU2NyaXB0J3MgYHNgIChgZG90QWxsYCkuXG4gICAgZmxhZ3M6IFwiXCIsXG4gICAgLy8gSW5jbHVkZSBKYXZhU2NyaXB0IGZsYWcgYGdgIChgZ2xvYmFsYCkgaW4gdGhlIHJlc3VsdC5cbiAgICBnbG9iYWw6IGZhbHNlLFxuICAgIC8vIEluY2x1ZGUgSmF2YVNjcmlwdCBmbGFnIGBkYCAoYGhhc0luZGljZXNgKSBpbiB0aGUgcmVzdWx0LlxuICAgIGhhc0luZGljZXM6IGZhbHNlLFxuICAgIC8vIERlbGF5IHJlZ2V4IGNvbnN0cnVjdGlvbiB1bnRpbCBmaXJzdCB1c2UgaWYgdGhlIHRyYW5zcGlsZWQgcGF0dGVybiBpcyBhdCBsZWFzdCB0aGlzIGxlbmd0aC5cbiAgICBsYXp5Q29tcGlsZUxlbmd0aDogSW5maW5pdHksXG4gICAgLy8gSmF2YVNjcmlwdCB2ZXJzaW9uIHVzZWQgZm9yIGdlbmVyYXRlZCByZWdleGVzLiBVc2luZyBgYXV0b2AgZGV0ZWN0cyB0aGUgYmVzdCB2YWx1ZSBiYXNlZCBvblxuICAgIC8vIHlvdXIgZW52aXJvbm1lbnQuIExhdGVyIHRhcmdldHMgYWxsb3cgZmFzdGVyIHByb2Nlc3NpbmcsIHNpbXBsZXIgZ2VuZXJhdGVkIHNvdXJjZSwgYW5kXG4gICAgLy8gc3VwcG9ydCBmb3IgYWRkaXRpb25hbCBmZWF0dXJlcy5cbiAgICB0YXJnZXQ6IFwiYXV0b1wiLFxuICAgIC8vIERpc2FibGVzIG1pbmlmaWNhdGlvbnMgdGhhdCBzaW1wbGlmeSB0aGUgcGF0dGVybiB3aXRob3V0IGNoYW5naW5nIHRoZSBtZWFuaW5nLlxuICAgIHZlcmJvc2U6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgLy8gQWR2YW5jZWQgb3B0aW9ucyB0aGF0IG92ZXJyaWRlIHN0YW5kYXJkIGJlaGF2aW9yLCBlcnJvciBjaGVja2luZywgYW5kIGZsYWdzIHdoZW4gZW5hYmxlZC5cbiAgICBydWxlczoge1xuICAgICAgLy8gVXNlZnVsIHdpdGggVGV4dE1hdGUgZ3JhbW1hcnMgdGhhdCBtZXJnZSBiYWNrcmVmZXJlbmNlcyBhY3Jvc3MgcGF0dGVybnMuXG4gICAgICBhbGxvd09ycGhhbkJhY2tyZWZzOiBmYWxzZSxcbiAgICAgIC8vIFVzZSBBU0NJSSBgXFxiYCBhbmQgYFxcQmAsIHdoaWNoIGluY3JlYXNlcyBzZWFyY2ggcGVyZm9ybWFuY2Ugb2YgZ2VuZXJhdGVkIHJlZ2V4ZXMuXG4gICAgICBhc2NpaVdvcmRCb3VuZGFyaWVzOiBmYWxzZSxcbiAgICAgIC8vIEFsbG93IHVubmFtZWQgY2FwdHVyZXMgYW5kIG51bWJlcmVkIGNhbGxzIChiYWNrcmVmZXJlbmNlcyBhbmQgc3Vicm91dGluZXMpIHdoZW4gdXNpbmdcbiAgICAgIC8vIG5hbWVkIGNhcHR1cmUuIFRoaXMgaXMgT25pZ3VydW1hIG9wdGlvbiBgT05JR19PUFRJT05fQ0FQVFVSRV9HUk9VUGA7IG9uIGJ5IGRlZmF1bHQgaW5cbiAgICAgIC8vIGB2c2NvZGUtb25pZ3VydW1hYC5cbiAgICAgIGNhcHR1cmVHcm91cDogZmFsc2UsXG4gICAgICAvLyBDaGFuZ2UgdGhlIHJlY3Vyc2lvbiBkZXB0aCBsaW1pdCBmcm9tIE9uaWd1cnVtYSdzIGAyMGAgdG8gYW4gaW50ZWdlciBgMmDigJNgMjBgLlxuICAgICAgcmVjdXJzaW9uTGltaXQ6IDIwLFxuICAgICAgLy8gYF5gIGFzIGBcXEFgOyBgJGAgYXNgXFxaYC4gSW1wcm92ZXMgc2VhcmNoIHBlcmZvcm1hbmNlIG9mIGdlbmVyYXRlZCByZWdleGVzIHdpdGhvdXQgY2hhbmdpbmdcbiAgICAgIC8vIHRoZSBtZWFuaW5nIGlmIHNlYXJjaGluZyBsaW5lIGJ5IGxpbmUuIFRoaXMgaXMgT25pZ3VydW1hIG9wdGlvbiBgT05JR19PUFRJT05fU0lOR0xFTElORWAuXG4gICAgICBzaW5nbGVsaW5lOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnMucnVsZXNcbiAgICB9XG4gIH07XG4gIGlmIChvcHRzLnRhcmdldCA9PT0gXCJhdXRvXCIpIHtcbiAgICBvcHRzLnRhcmdldCA9IGVudkZsYWdzLmZsYWdHcm91cHMgPyBcIkVTMjAyNVwiIDogZW52RmxhZ3MudW5pY29kZVNldHMgPyBcIkVTMjAyNFwiIDogXCJFUzIwMThcIjtcbiAgfVxuICByZXR1cm4gb3B0cztcbn1cblxuLy8gc3JjL3VuaWNvZGUuanNcbmltcG9ydCB7IHNsdWcgfSBmcm9tIFwib25pZ3VydW1hLXBhcnNlci9wYXJzZXJcIjtcbnZhciBhc2NpaVNwYWNlQ2hhciA9IFwiW1x0LVxcciBdXCI7XG52YXIgQ2hhcnNXaXRob3V0SWdub3JlQ2FzZUV4cGFuc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgY3AoMzA0KSxcbiAgLy8gxLBcbiAgY3AoMzA1KVxuICAvLyDEsVxuXSk7XG52YXIgZGVmYXVsdFdvcmRDaGFyID0gcmBbXFxwe0x9XFxwe019XFxwe059XFxwe1BjfV1gO1xuZnVuY3Rpb24gZ2V0SWdub3JlQ2FzZU1hdGNoQ2hhcnMoY2hhcikge1xuICBpZiAoQ2hhcnNXaXRob3V0SWdub3JlQ2FzZUV4cGFuc2lvbi5oYXMoY2hhcikpIHtcbiAgICByZXR1cm4gW2NoYXJdO1xuICB9XG4gIGNvbnN0IHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGxvd2VyID0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCB1cHBlciA9IGxvd2VyLnRvVXBwZXJDYXNlKCk7XG4gIGNvbnN0IHRpdGxlID0gTG93ZXJUb1RpdGxlQ2FzZU1hcC5nZXQobG93ZXIpO1xuICBjb25zdCBhbHRMb3dlciA9IExvd2VyVG9BbHRlcm5hdGl2ZUxvd2VyQ2FzZU1hcC5nZXQobG93ZXIpO1xuICBjb25zdCBhbHRVcHBlciA9IExvd2VyVG9BbHRlcm5hdGl2ZVVwcGVyQ2FzZU1hcC5nZXQobG93ZXIpO1xuICBpZiAoWy4uLnVwcGVyXS5sZW5ndGggPT09IDEpIHtcbiAgICBzZXQuYWRkKHVwcGVyKTtcbiAgfVxuICBhbHRVcHBlciAmJiBzZXQuYWRkKGFsdFVwcGVyKTtcbiAgdGl0bGUgJiYgc2V0LmFkZCh0aXRsZSk7XG4gIHNldC5hZGQobG93ZXIpO1xuICBhbHRMb3dlciAmJiBzZXQuYWRkKGFsdExvd2VyKTtcbiAgcmV0dXJuIFsuLi5zZXRdO1xufVxudmFyIEpzVW5pY29kZVByb3BlcnR5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoXG4gIGBDIE90aGVyXG5DYyBDb250cm9sIGNudHJsXG5DZiBGb3JtYXRcbkNuIFVuYXNzaWduZWRcbkNvIFByaXZhdGVfVXNlXG5DcyBTdXJyb2dhdGVcbkwgTGV0dGVyXG5MQyBDYXNlZF9MZXR0ZXJcbkxsIExvd2VyY2FzZV9MZXR0ZXJcbkxtIE1vZGlmaWVyX0xldHRlclxuTG8gT3RoZXJfTGV0dGVyXG5MdCBUaXRsZWNhc2VfTGV0dGVyXG5MdSBVcHBlcmNhc2VfTGV0dGVyXG5NIE1hcmsgQ29tYmluaW5nX01hcmtcbk1jIFNwYWNpbmdfTWFya1xuTWUgRW5jbG9zaW5nX01hcmtcbk1uIE5vbnNwYWNpbmdfTWFya1xuTiBOdW1iZXJcbk5kIERlY2ltYWxfTnVtYmVyIGRpZ2l0XG5ObCBMZXR0ZXJfTnVtYmVyXG5ObyBPdGhlcl9OdW1iZXJcblAgUHVuY3R1YXRpb24gcHVuY3RcblBjIENvbm5lY3Rvcl9QdW5jdHVhdGlvblxuUGQgRGFzaF9QdW5jdHVhdGlvblxuUGUgQ2xvc2VfUHVuY3R1YXRpb25cblBmIEZpbmFsX1B1bmN0dWF0aW9uXG5QaSBJbml0aWFsX1B1bmN0dWF0aW9uXG5QbyBPdGhlcl9QdW5jdHVhdGlvblxuUHMgT3Blbl9QdW5jdHVhdGlvblxuUyBTeW1ib2xcblNjIEN1cnJlbmN5X1N5bWJvbFxuU2sgTW9kaWZpZXJfU3ltYm9sXG5TbSBNYXRoX1N5bWJvbFxuU28gT3RoZXJfU3ltYm9sXG5aIFNlcGFyYXRvclxuWmwgTGluZV9TZXBhcmF0b3JcblpwIFBhcmFncmFwaF9TZXBhcmF0b3JcblpzIFNwYWNlX1NlcGFyYXRvclxuQVNDSUlcbkFTQ0lJX0hleF9EaWdpdCBBSGV4XG5BbHBoYWJldGljIEFscGhhXG5BbnlcbkFzc2lnbmVkXG5CaWRpX0NvbnRyb2wgQmlkaV9DXG5CaWRpX01pcnJvcmVkIEJpZGlfTVxuQ2FzZV9JZ25vcmFibGUgQ0lcbkNhc2VkXG5DaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGXG5DaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNXG5DaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0xcbkNoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0ZcbkNoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVFxuQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVXG5EYXNoXG5EZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJXG5EZXByZWNhdGVkIERlcFxuRGlhY3JpdGljIERpYVxuRW1vamlcbkVtb2ppX0NvbXBvbmVudCBFQ29tcFxuRW1vamlfTW9kaWZpZXIgRU1vZFxuRW1vamlfTW9kaWZpZXJfQmFzZSBFQmFzZVxuRW1vamlfUHJlc2VudGF0aW9uIEVQcmVzXG5FeHRlbmRlZF9QaWN0b2dyYXBoaWMgRXh0UGljdFxuRXh0ZW5kZXIgRXh0XG5HcmFwaGVtZV9CYXNlIEdyX0Jhc2VcbkdyYXBoZW1lX0V4dGVuZCBHcl9FeHRcbkhleF9EaWdpdCBIZXhcbklEU19CaW5hcnlfT3BlcmF0b3IgSURTQlxuSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVFxuSURfQ29udGludWUgSURDXG5JRF9TdGFydCBJRFNcbklkZW9ncmFwaGljIElkZW9cbkpvaW5fQ29udHJvbCBKb2luX0NcbkxvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRVxuTG93ZXJjYXNlIExvd2VyXG5NYXRoXG5Ob25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhclxuUGF0dGVybl9TeW50YXggUGF0X1N5blxuUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1NcblF1b3RhdGlvbl9NYXJrIFFNYXJrXG5SYWRpY2FsXG5SZWdpb25hbF9JbmRpY2F0b3IgUklcblNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtXG5Tb2Z0X0RvdHRlZCBTRFxuVGVybWluYWxfUHVuY3R1YXRpb24gVGVybVxuVW5pZmllZF9JZGVvZ3JhcGggVUlkZW9cblVwcGVyY2FzZSBVcHBlclxuVmFyaWF0aW9uX1NlbGVjdG9yIFZTXG5XaGl0ZV9TcGFjZSBzcGFjZVxuWElEX0NvbnRpbnVlIFhJRENcblhJRF9TdGFydCBYSURTYC5zcGxpdCgvXFxzLykubWFwKChwKSA9PiBbc2x1ZyhwKSwgcF0pXG4pO1xudmFyIExvd2VyVG9BbHRlcm5hdGl2ZUxvd2VyQ2FzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wic1wiLCBjcCgzODMpXSxcbiAgLy8gcywgxb9cbiAgW2NwKDM4MyksIFwic1wiXVxuICAvLyDFvywgc1xuXSk7XG52YXIgTG93ZXJUb0FsdGVybmF0aXZlVXBwZXJDYXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbY3AoMjIzKSwgY3AoNzgzOCldLFxuICAvLyDDnywg4bqeXG4gIFtjcCgxMDcpLCBjcCg4NDkwKV0sXG4gIC8vIGssIOKEqiAoS2VsdmluKVxuICBbY3AoMjI5KSwgY3AoODQ5MSldLFxuICAvLyDDpSwg4oSrIChBbmdzdHJvbSlcbiAgW2NwKDk2OSksIGNwKDg0ODYpXVxuICAvLyDPiSwg4oSmIChPaG0pXG5dKTtcbnZhciBMb3dlclRvVGl0bGVDYXNlTWFwID0gbmV3IE1hcChbXG4gIHRpdGxlRW50cnkoNDUzKSxcbiAgdGl0bGVFbnRyeSg0NTYpLFxuICB0aXRsZUVudHJ5KDQ1OSksXG4gIHRpdGxlRW50cnkoNDk4KSxcbiAgLi4udGl0bGVSYW5nZSg4MDcyLCA4MDc5KSxcbiAgLi4udGl0bGVSYW5nZSg4MDg4LCA4MDk1KSxcbiAgLi4udGl0bGVSYW5nZSg4MTA0LCA4MTExKSxcbiAgdGl0bGVFbnRyeSg4MTI0KSxcbiAgdGl0bGVFbnRyeSg4MTQwKSxcbiAgdGl0bGVFbnRyeSg4MTg4KVxuXSk7XG52YXIgUG9zaXhDbGFzc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiYWxudW1cIiwgcmBbXFxwe0FscGhhfVxccHtOZH1dYF0sXG4gIFtcImFscGhhXCIsIHJgXFxwe0FscGhhfWBdLFxuICBbXCJhc2NpaVwiLCByYFxccHtBU0NJSX1gXSxcbiAgW1wiYmxhbmtcIiwgcmBbXFxwe1pzfVxcdF1gXSxcbiAgW1wiY250cmxcIiwgcmBcXHB7Q2N9YF0sXG4gIFtcImRpZ2l0XCIsIHJgXFxwe05kfWBdLFxuICBbXCJncmFwaFwiLCByYFtcXFB7c3BhY2V9JiZcXFB7Q2N9JiZcXFB7Q259JiZcXFB7Q3N9XWBdLFxuICBbXCJsb3dlclwiLCByYFxccHtMb3dlcn1gXSxcbiAgW1wicHJpbnRcIiwgcmBbW1xcUHtzcGFjZX0mJlxcUHtDY30mJlxcUHtDbn0mJlxcUHtDc31dXFxwe1pzfV1gXSxcbiAgW1wicHVuY3RcIiwgcmBbXFxwe1B9XFxwe1N9XWBdLFxuICAvLyBVcGRhdGVkIHZhbHVlIGZyb20gT25pZyA2LjkuOTsgY2hhbmdlZCBmcm9tIFVuaWNvZGUgYFxccHtwdW5jdH1gXG4gIFtcInNwYWNlXCIsIHJgXFxwe3NwYWNlfWBdLFxuICBbXCJ1cHBlclwiLCByYFxccHtVcHBlcn1gXSxcbiAgW1wid29yZFwiLCByYFtcXHB7QWxwaGF9XFxwe019XFxwe05kfVxccHtQY31dYF0sXG4gIFtcInhkaWdpdFwiLCByYFxccHtBSGV4fWBdXG5dKTtcbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgcmFuZ2UyID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIHJhbmdlMi5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByYW5nZTI7XG59XG5mdW5jdGlvbiB0aXRsZUVudHJ5KGNvZGVQb2ludCkge1xuICBjb25zdCBjaGFyID0gY3AoY29kZVBvaW50KTtcbiAgcmV0dXJuIFtjaGFyLnRvTG93ZXJDYXNlKCksIGNoYXJdO1xufVxuZnVuY3Rpb24gdGl0bGVSYW5nZShzdGFydCwgZW5kKSB7XG4gIHJldHVybiByYW5nZShzdGFydCwgZW5kKS5tYXAoKGNvZGVQb2ludCkgPT4gdGl0bGVFbnRyeShjb2RlUG9pbnQpKTtcbn1cbnZhciBVbmljb2RlUHJvcGVydGllc1dpdGhTcGVjaWZpY0Nhc2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiTG93ZXJcIixcbiAgXCJMb3dlcmNhc2VcIixcbiAgXCJVcHBlclwiLFxuICBcIlVwcGVyY2FzZVwiLFxuICBcIkxsXCIsXG4gIFwiTG93ZXJjYXNlX0xldHRlclwiLFxuICBcIkx0XCIsXG4gIFwiVGl0bGVjYXNlX0xldHRlclwiLFxuICBcIkx1XCIsXG4gIFwiVXBwZXJjYXNlX0xldHRlclwiXG4gIC8vIFRoZSBgQ2hhbmdlc19XaGVuXypgIHByb3BlcnRpZXMgKGFuZCB0aGVpciBhbGlhc2VzKSBjb3VsZCBiZSBpbmNsdWRlZCwgYnV0IHRoZXkncmUgdmVyeSByYXJlLlxuICAvLyBTb21lIG90aGVyIHByb3BlcnRpZXMgaW5jbHVkZSBhIGhhbmRmdWwgb2YgY2hhcnMgd2l0aCBzcGVjaWZpYyBjYXNlcyBvbmx5LCBidXQgdGhlc2UgY2hhcnMgYXJlXG4gIC8vIGdlbmVyYWxseSBleHRyZW1lIGVkZ2UgY2FzZXMgYW5kIHVzaW5nIHN1Y2ggcHJvcGVydGllcyBjYXNlIGluc2Vuc2l0aXZlbHkgZ2VuZXJhbGx5IHByb2R1Y2VzXG4gIC8vIHVuZGVzaXJlZCBiZWhhdmlvciBhbnl3YXlcbl0pO1xuXG4vLyBzcmMvdHJhbnNmb3JtLmpzXG5pbXBvcnQgeyBjcmVhdGVBbHRlcm5hdGl2ZSwgY3JlYXRlQXNzZXJ0aW9uLCBjcmVhdGVCYWNrcmVmZXJlbmNlLCBjcmVhdGVDYXB0dXJpbmdHcm91cCwgY3JlYXRlQ2hhcmFjdGVyLCBjcmVhdGVDaGFyYWN0ZXJDbGFzcywgY3JlYXRlQ2hhcmFjdGVyU2V0LCBjcmVhdGVHcm91cCwgY3JlYXRlTG9va2Fyb3VuZEFzc2VydGlvbiwgY3JlYXRlUXVhbnRpZmllciwgY3JlYXRlU3Vicm91dGluZSwgY3JlYXRlVW5pY29kZVByb3BlcnR5LCBoYXNPbmx5Q2hpbGQsIHBhcnNlLCBzbHVnIGFzIHNsdWcyIH0gZnJvbSBcIm9uaWd1cnVtYS1wYXJzZXIvcGFyc2VyXCI7XG5pbXBvcnQgeyB0cmF2ZXJzZSB9IGZyb20gXCJvbmlndXJ1bWEtcGFyc2VyL3RyYXZlcnNlclwiO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGFzdCwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIC8vIEEgY291cGxlIGVkZ2UgY2FzZXMgZXhpc3Qgd2hlcmUgb3B0aW9ucyBgYWNjdXJhY3lgIGFuZCBgYmVzdEVmZm9ydFRhcmdldGAgYXJlIHVzZWQ6XG4gICAgLy8gLSBgQ2hhcmFjdGVyU2V0YCBraW5kIGB0ZXh0X3NlZ21lbnRgIChgXFxYYCk6IEFuIGV4YWN0IHJlcHJlc2VudGF0aW9uIHdvdWxkIHJlcXVpcmUgaGVhdnlcbiAgICAvLyAgIFVuaWNvZGUgZGF0YTsgYSBiZXN0LWVmZm9ydCBhcHByb3hpbWF0aW9uIHJlcXVpcmVzIGtub3dpbmcgdGhlIHRhcmdldC5cbiAgICAvLyAtIGBDaGFyYWN0ZXJTZXRgIGtpbmQgYHBvc2l4YCB3aXRoIHZhbHVlcyBgZ3JhcGhgIGFuZCBgcHJpbnRgOiBUaGVpciBjb21wbGV4IFVuaWNvZGVcbiAgICAvLyAgIHJlcHJlc2VudGF0aW9ucyB3b3VsZCBiZSBoYXJkIHRvIGNoYW5nZSB0byBBU0NJSSB2ZXJzaW9ucyBhZnRlciB0aGUgZmFjdCBpbiB0aGUgZ2VuZXJhdG9yXG4gICAgLy8gICBiYXNlZCBvbiBgdGFyZ2V0YC9gYWNjdXJhY3lgLCBzbyBwcm9kdWNlIHRoZSBhcHByb3ByaWF0ZSBzdHJ1Y3R1cmUgaGVyZS5cbiAgICBhY2N1cmFjeTogXCJkZWZhdWx0XCIsXG4gICAgYXNjaWlXb3JkQm91bmRhcmllczogZmFsc2UsXG4gICAgYXZvaWRTdWJjbGFzczogZmFsc2UsXG4gICAgYmVzdEVmZm9ydFRhcmdldDogXCJFUzIwMjVcIixcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGFkZFBhcmVudFByb3BlcnRpZXMoYXN0KTtcbiAgY29uc3QgZmlyc3RQYXNzU3RhdGUgPSB7XG4gICAgYWNjdXJhY3k6IG9wdHMuYWNjdXJhY3ksXG4gICAgYXNjaWlXb3JkQm91bmRhcmllczogb3B0cy5hc2NpaVdvcmRCb3VuZGFyaWVzLFxuICAgIGF2b2lkU3ViY2xhc3M6IG9wdHMuYXZvaWRTdWJjbGFzcyxcbiAgICBmbGFnRGlyZWN0aXZlc0J5QWx0OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIGpzR3JvdXBOYW1lTWFwOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIG1pblRhcmdldEVzMjAyNDogaXNNaW5UYXJnZXQob3B0cy5iZXN0RWZmb3J0VGFyZ2V0LCBcIkVTMjAyNFwiKSxcbiAgICBwYXNzZWRMb29rYmVoaW5kOiBmYWxzZSxcbiAgICBzdHJhdGVneTogbnVsbCxcbiAgICAvLyBTdWJyb3V0aW5lcyBjYW4gYXBwZWFyIGJlZm9yZSB0aGUgZ3JvdXBzIHRoZXkgcmVmLCBzbyBjb2xsZWN0IHJlZmZlZCBub2RlcyBmb3IgYSBzZWNvbmQgcGFzcyBcbiAgICBzdWJyb3V0aW5lUmVmTWFwOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHN1cHBvcnRlZEdOb2RlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICBkaWdpdElzQXNjaWk6IGFzdC5mbGFncy5kaWdpdElzQXNjaWksXG4gICAgc3BhY2VJc0FzY2lpOiBhc3QuZmxhZ3Muc3BhY2VJc0FzY2lpLFxuICAgIHdvcmRJc0FzY2lpOiBhc3QuZmxhZ3Mud29yZElzQXNjaWlcbiAgfTtcbiAgdHJhdmVyc2UoYXN0LCBGaXJzdFBhc3NWaXNpdG9yLCBmaXJzdFBhc3NTdGF0ZSk7XG4gIGNvbnN0IGdsb2JhbEZsYWdzID0ge1xuICAgIGRvdEFsbDogYXN0LmZsYWdzLmRvdEFsbCxcbiAgICBpZ25vcmVDYXNlOiBhc3QuZmxhZ3MuaWdub3JlQ2FzZVxuICB9O1xuICBjb25zdCBzZWNvbmRQYXNzU3RhdGUgPSB7XG4gICAgY3VycmVudEZsYWdzOiBnbG9iYWxGbGFncyxcbiAgICBwcmV2RmxhZ3M6IG51bGwsXG4gICAgZ2xvYmFsRmxhZ3MsXG4gICAgZ3JvdXBPcmlnaW5CeUNvcHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgZ3JvdXBzQnlOYW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWY6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgb3BlblJlZnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXI6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgc3Vicm91dGluZVJlZk1hcDogZmlyc3RQYXNzU3RhdGUuc3Vicm91dGluZVJlZk1hcFxuICB9O1xuICB0cmF2ZXJzZShhc3QsIFNlY29uZFBhc3NWaXNpdG9yLCBzZWNvbmRQYXNzU3RhdGUpO1xuICBjb25zdCB0aGlyZFBhc3NTdGF0ZSA9IHtcbiAgICBncm91cHNCeU5hbWU6IHNlY29uZFBhc3NTdGF0ZS5ncm91cHNCeU5hbWUsXG4gICAgaGlnaGVzdE9ycGhhbkJhY2tyZWY6IDAsXG4gICAgbnVtQ2FwdHVyZXNUb0xlZnQ6IDAsXG4gICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXI6IHNlY29uZFBhc3NTdGF0ZS5yZWZmZWROb2Rlc0J5UmVmZXJlbmNlclxuICB9O1xuICB0cmF2ZXJzZShhc3QsIFRoaXJkUGFzc1Zpc2l0b3IsIHRoaXJkUGFzc1N0YXRlKTtcbiAgYXN0Ll9vcmlnaW5NYXAgPSBzZWNvbmRQYXNzU3RhdGUuZ3JvdXBPcmlnaW5CeUNvcHk7XG4gIGFzdC5fc3RyYXRlZ3kgPSBmaXJzdFBhc3NTdGF0ZS5zdHJhdGVneTtcbiAgcmV0dXJuIGFzdDtcbn1cbnZhciBGaXJzdFBhc3NWaXNpdG9yID0ge1xuICBBYnNlbmNlRnVuY3Rpb24oeyBub2RlLCBwYXJlbnQsIHJlcGxhY2VXaXRoIH0pIHtcbiAgICBjb25zdCB7IGJvZHksIGtpbmQgfSA9IG5vZGU7XG4gICAgaWYgKGtpbmQgPT09IFwicmVwZWF0ZXJcIikge1xuICAgICAgY29uc3QgaW5uZXJHcm91cCA9IGNyZWF0ZUdyb3VwKCk7XG4gICAgICBpbm5lckdyb3VwLmJvZHlbMF0uYm9keS5wdXNoKFxuICAgICAgICAvLyBJbnNlcnQgb3duIGFsdHMgYXMgYGJvZHlgXG4gICAgICAgIGNyZWF0ZUxvb2thcm91bmRBc3NlcnRpb24oeyBuZWdhdGU6IHRydWUsIGJvZHkgfSksXG4gICAgICAgIGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eShcIkFueVwiKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG91dGVyR3JvdXAgPSBjcmVhdGVHcm91cCgpO1xuICAgICAgb3V0ZXJHcm91cC5ib2R5WzBdLmJvZHkucHVzaChcbiAgICAgICAgY3JlYXRlUXVhbnRpZmllcihcImdyZWVkeVwiLCAwLCBJbmZpbml0eSwgaW5uZXJHcm91cClcbiAgICAgICk7XG4gICAgICByZXBsYWNlV2l0aChzZXRQYXJlbnREZWVwKG91dGVyR3JvdXAsIHBhcmVudCksIHsgdHJhdmVyc2U6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWJzZW5jZSBmdW5jdGlvbiBcIig/fnxcImApO1xuICAgIH1cbiAgfSxcbiAgQWx0ZXJuYXRpdmU6IHtcbiAgICBlbnRlcih7IG5vZGUsIHBhcmVudCwga2V5IH0sIHsgZmxhZ0RpcmVjdGl2ZXNCeUFsdCB9KSB7XG4gICAgICBjb25zdCBmbGFnRGlyZWN0aXZlcyA9IG5vZGUuYm9keS5maWx0ZXIoKGVsKSA9PiBlbC5raW5kID09PSBcImZsYWdzXCIpO1xuICAgICAgZm9yIChsZXQgaSA9IGtleSArIDE7IGkgPCBwYXJlbnQuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmb3J3YXJkU2libGluZ0FsdCA9IHBhcmVudC5ib2R5W2ldO1xuICAgICAgICBnZXRPckluc2VydChmbGFnRGlyZWN0aXZlc0J5QWx0LCBmb3J3YXJkU2libGluZ0FsdCwgW10pLnB1c2goLi4uZmxhZ0RpcmVjdGl2ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdCh7IG5vZGUgfSwgeyBmbGFnRGlyZWN0aXZlc0J5QWx0IH0pIHtcbiAgICAgIGlmIChmbGFnRGlyZWN0aXZlc0J5QWx0LmdldChub2RlKT8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gZ2V0Q29tYmluZWRGbGFnTW9kc0Zyb21GbGFnTm9kZXMoZmxhZ0RpcmVjdGl2ZXNCeUFsdC5nZXQobm9kZSkpO1xuICAgICAgICBpZiAoZmxhZ3MpIHtcbiAgICAgICAgICBjb25zdCBmbGFnR3JvdXAgPSBjcmVhdGVHcm91cCh7IGZsYWdzIH0pO1xuICAgICAgICAgIGZsYWdHcm91cC5ib2R5WzBdLmJvZHkgPSBub2RlLmJvZHk7XG4gICAgICAgICAgbm9kZS5ib2R5ID0gW3NldFBhcmVudERlZXAoZmxhZ0dyb3VwLCBub2RlKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIEFzc2VydGlvbih7IG5vZGUsIHBhcmVudCwga2V5LCBjb250YWluZXIsIHJvb3QsIHJlbW92ZSwgcmVwbGFjZVdpdGggfSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IGtpbmQsIG5lZ2F0ZSB9ID0gbm9kZTtcbiAgICBjb25zdCB7IGFzY2lpV29yZEJvdW5kYXJpZXMsIGF2b2lkU3ViY2xhc3MsIHN1cHBvcnRlZEdOb2Rlcywgd29yZElzQXNjaWkgfSA9IHN0YXRlO1xuICAgIGlmIChraW5kID09PSBcInRleHRfc2VnbWVudF9ib3VuZGFyeVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRleHQgc2VnbWVudCBib3VuZGFyeSBcIlxcXFwke25lZ2F0ZSA/IFwiWVwiIDogXCJ5XCJ9XCJgKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwibGluZV9lbmRcIikge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50RGVlcChjcmVhdGVMb29rYXJvdW5kQXNzZXJ0aW9uKHsgYm9keTogW1xuICAgICAgICBjcmVhdGVBbHRlcm5hdGl2ZSh7IGJvZHk6IFtjcmVhdGVBc3NlcnRpb24oXCJzdHJpbmdfZW5kXCIpXSB9KSxcbiAgICAgICAgY3JlYXRlQWx0ZXJuYXRpdmUoeyBib2R5OiBbY3JlYXRlQ2hhcmFjdGVyKDEwKV0gfSlcbiAgICAgICAgLy8gYFxcbmBcbiAgICAgIF0gfSksIHBhcmVudCkpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJsaW5lX3N0YXJ0XCIpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAocGFyc2VGcmFnbWVudChyYCg/PD1cXEF8XFxuKD8hXFx6KSlgLCB7IHNraXBMb29rYmVoaW5kVmFsaWRhdGlvbjogdHJ1ZSB9KSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInNlYXJjaF9zdGFydFwiKSB7XG4gICAgICBpZiAoc3VwcG9ydGVkR05vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICByb290LmZsYWdzLnN0aWNreSA9IHRydWU7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGNvbnRhaW5lcltrZXkgLSAxXTtcbiAgICAgICAgaWYgKHByZXYgJiYgaXNBbHdheXNOb25aZXJvTGVuZ3RoKHByZXYpKSB7XG4gICAgICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50RGVlcChjcmVhdGVMb29rYXJvdW5kQXNzZXJ0aW9uKHsgbmVnYXRlOiB0cnVlIH0pLCBwYXJlbnQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdm9pZFN1YmNsYXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgVXNlcyBcIlxcR1wiIGluIGEgd2F5IHRoYXQgcmVxdWlyZXMgYSBzdWJjbGFzc2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudChjcmVhdGVBc3NlcnRpb24oXCJzdHJpbmdfc3RhcnRcIiksIHBhcmVudCkpO1xuICAgICAgICAgIHN0YXRlLnN0cmF0ZWd5ID0gXCJjbGlwX3NlYXJjaFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInN0cmluZ19lbmRcIiB8fCBraW5kID09PSBcInN0cmluZ19zdGFydFwiKSB7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInN0cmluZ19lbmRfbmV3bGluZVwiKSB7XG4gICAgICByZXBsYWNlV2l0aChzZXRQYXJlbnREZWVwKHBhcnNlRnJhZ21lbnQocmAoPz1cXG4/XFx6KWApLCBwYXJlbnQpKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwid29yZF9ib3VuZGFyeVwiKSB7XG4gICAgICBpZiAoIXdvcmRJc0FzY2lpICYmICFhc2NpaVdvcmRCb3VuZGFyaWVzKSB7XG4gICAgICAgIGNvbnN0IGIgPSBgKD86KD88PSR7ZGVmYXVsdFdvcmRDaGFyfSkoPyEke2RlZmF1bHRXb3JkQ2hhcn0pfCg/PCEke2RlZmF1bHRXb3JkQ2hhcn0pKD89JHtkZWZhdWx0V29yZENoYXJ9KSlgO1xuICAgICAgICBjb25zdCBCID0gYCg/Oig/PD0ke2RlZmF1bHRXb3JkQ2hhcn0pKD89JHtkZWZhdWx0V29yZENoYXJ9KXwoPzwhJHtkZWZhdWx0V29yZENoYXJ9KSg/ISR7ZGVmYXVsdFdvcmRDaGFyfSkpYDtcbiAgICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50RGVlcChwYXJzZUZyYWdtZW50KG5lZ2F0ZSA/IEIgOiBiKSwgcGFyZW50KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBhc3NlcnRpb24ga2luZCBcIiR7a2luZH1cImApO1xuICAgIH1cbiAgfSxcbiAgQmFja3JlZmVyZW5jZSh7IG5vZGUgfSwgeyBqc0dyb3VwTmFtZU1hcCB9KSB7XG4gICAgbGV0IHsgcmVmIH0gPSBub2RlO1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcInN0cmluZ1wiICYmICFpc1ZhbGlkSnNHcm91cE5hbWUocmVmKSkge1xuICAgICAgcmVmID0gZ2V0QW5kU3RvcmVKc0dyb3VwTmFtZShyZWYsIGpzR3JvdXBOYW1lTWFwKTtcbiAgICAgIG5vZGUucmVmID0gcmVmO1xuICAgIH1cbiAgfSxcbiAgQ2FwdHVyaW5nR3JvdXAoeyBub2RlIH0sIHsganNHcm91cE5hbWVNYXAsIHN1YnJvdXRpbmVSZWZNYXAgfSkge1xuICAgIGxldCB7IG5hbWUgfSA9IG5vZGU7XG4gICAgaWYgKG5hbWUgJiYgIWlzVmFsaWRKc0dyb3VwTmFtZShuYW1lKSkge1xuICAgICAgbmFtZSA9IGdldEFuZFN0b3JlSnNHcm91cE5hbWUobmFtZSwganNHcm91cE5hbWVNYXApO1xuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgc3Vicm91dGluZVJlZk1hcC5zZXQobm9kZS5udW1iZXIsIG5vZGUpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICBzdWJyb3V0aW5lUmVmTWFwLnNldChuYW1lLCBub2RlKTtcbiAgICB9XG4gIH0sXG4gIENoYXJhY3RlckNsYXNzUmFuZ2UoeyBub2RlLCBwYXJlbnQsIHJlcGxhY2VXaXRoIH0pIHtcbiAgICBpZiAocGFyZW50LmtpbmQgPT09IFwiaW50ZXJzZWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGNjID0gY3JlYXRlQ2hhcmFjdGVyQ2xhc3MoeyBib2R5OiBbbm9kZV0gfSk7XG4gICAgICByZXBsYWNlV2l0aChzZXRQYXJlbnREZWVwKGNjLCBwYXJlbnQpLCB7IHRyYXZlcnNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSxcbiAgQ2hhcmFjdGVyU2V0KHsgbm9kZSwgcGFyZW50LCByZXBsYWNlV2l0aCB9LCB7IGFjY3VyYWN5LCBtaW5UYXJnZXRFczIwMjQsIGRpZ2l0SXNBc2NpaSwgc3BhY2VJc0FzY2lpLCB3b3JkSXNBc2NpaSB9KSB7XG4gICAgY29uc3QgeyBraW5kLCBuZWdhdGUsIHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChkaWdpdElzQXNjaWkgJiYgKGtpbmQgPT09IFwiZGlnaXRcIiB8fCB2YWx1ZSA9PT0gXCJkaWdpdFwiKSkge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50KGNyZWF0ZUNoYXJhY3RlclNldChcImRpZ2l0XCIsIHsgbmVnYXRlIH0pLCBwYXJlbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNwYWNlSXNBc2NpaSAmJiAoa2luZCA9PT0gXCJzcGFjZVwiIHx8IHZhbHVlID09PSBcInNwYWNlXCIpKSB7XG4gICAgICByZXBsYWNlV2l0aChzZXRQYXJlbnREZWVwKHNldE5lZ2F0ZShwYXJzZUZyYWdtZW50KGFzY2lpU3BhY2VDaGFyKSwgbmVnYXRlKSwgcGFyZW50KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3b3JkSXNBc2NpaSAmJiAoa2luZCA9PT0gXCJ3b3JkXCIgfHwgdmFsdWUgPT09IFwid29yZFwiKSkge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50KGNyZWF0ZUNoYXJhY3RlclNldChcIndvcmRcIiwgeyBuZWdhdGUgfSksIHBhcmVudCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gXCJhbnlcIikge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50KGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eShcIkFueVwiKSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImRpZ2l0XCIpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudChjcmVhdGVVbmljb2RlUHJvcGVydHkoXCJOZFwiLCB7IG5lZ2F0ZSB9KSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImRvdFwiKSB7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInRleHRfc2VnbWVudFwiKSB7XG4gICAgICBpZiAoYWNjdXJhY3kgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgVXNlIG9mIFwiXFxYXCIgcmVxdWlyZXMgbm9uLXN0cmljdCBhY2N1cmFjeWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZUJhc2UgPSBcIlxcXFxwe0Vtb2ppfSg/OlxcXFxwe0VNb2R9fFxcXFx1RkUwRlxcXFx1MjBFMz98W1xcXFx4e0UwMDIwfS1cXFxceHtFMDA3RX1dK1xcXFx4e0UwMDdGfSk/XCI7XG4gICAgICBjb25zdCBlbW9qaSA9IHJgXFxwe1JJfXsyfXwke2VCYXNlfSg/OlxcdTIwMEQke2VCYXNlfSkqYDtcbiAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAocGFyc2VGcmFnbWVudChcbiAgICAgICAgLy8gQ2xvc2UgYXBwcm94aW1hdGlvbiBvZiBhbiBleHRlbmRlZCBncmFwaGVtZSBjbHVzdGVyOyBzZWUgPHVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8+XG4gICAgICAgIHJgKD8+XFxyXFxufCR7bWluVGFyZ2V0RXMyMDI0ID8gcmBcXHB7UkdJX0Vtb2ppfWAgOiBlbW9qaX18XFxQe019XFxwe019KilgLFxuICAgICAgICAvLyBBbGxvdyBKUyBwcm9wZXJ0eSBgUkdJX0Vtb2ppYCB0aHJvdWdoXG4gICAgICAgIHsgc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb246IHRydWUgfVxuICAgICAgKSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImhleFwiKSB7XG4gICAgICByZXBsYWNlV2l0aChzZXRQYXJlbnQoY3JlYXRlVW5pY29kZVByb3BlcnR5KFwiQUhleFwiLCB7IG5lZ2F0ZSB9KSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcIm5ld2xpbmVcIikge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50RGVlcChwYXJzZUZyYWdtZW50KG5lZ2F0ZSA/IFwiW15cXG5dXCIgOiBcIig/Plxcclxcbj98W1xcblxcdlxcZlxceDg1XFx1MjAyOFxcdTIwMjldKVwiKSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInBvc2l4XCIpIHtcbiAgICAgIGlmICghbWluVGFyZ2V0RXMyMDI0ICYmICh2YWx1ZSA9PT0gXCJncmFwaFwiIHx8IHZhbHVlID09PSBcInByaW50XCIpKSB7XG4gICAgICAgIGlmIChhY2N1cmFjeSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUE9TSVggY2xhc3MgXCIke3ZhbHVlfVwiIHJlcXVpcmVzIG1pbiB0YXJnZXQgRVMyMDI0IG9yIG5vbi1zdHJpY3QgYWNjdXJhY3lgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXNjaWkgPSB7XG4gICAgICAgICAgZ3JhcGg6IFwiIS1+XCIsXG4gICAgICAgICAgcHJpbnQ6IFwiIC1+XCJcbiAgICAgICAgfVt2YWx1ZV07XG4gICAgICAgIGlmIChuZWdhdGUpIHtcbiAgICAgICAgICBhc2NpaSA9IGBcXDAtJHtjcChhc2NpaS5jb2RlUG9pbnRBdCgwKSAtIDEpfSR7Y3AoYXNjaWkuY29kZVBvaW50QXQoMikgKyAxKX0tXFx1ezEwRkZGRn1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAocGFyc2VGcmFnbWVudChgWyR7YXNjaWl9XWApLCBwYXJlbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAoc2V0TmVnYXRlKHBhcnNlRnJhZ21lbnQoUG9zaXhDbGFzc01hcC5nZXQodmFsdWUpKSwgbmVnYXRlKSwgcGFyZW50KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInByb3BlcnR5XCIpIHtcbiAgICAgIGlmICghSnNVbmljb2RlUHJvcGVydHlNYXAuaGFzKHNsdWcyKHZhbHVlKSkpIHtcbiAgICAgICAgbm9kZS5rZXkgPSBcInNjXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcInNwYWNlXCIpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudChjcmVhdGVVbmljb2RlUHJvcGVydHkoXCJzcGFjZVwiLCB7IG5lZ2F0ZSB9KSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcIndvcmRcIikge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50RGVlcChzZXROZWdhdGUocGFyc2VGcmFnbWVudChkZWZhdWx0V29yZENoYXIpLCBuZWdhdGUpLCBwYXJlbnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBzZXQga2luZCBcIiR7a2luZH1cImApO1xuICAgIH1cbiAgfSxcbiAgRGlyZWN0aXZlKHsgbm9kZSwgcGFyZW50LCByb290LCByZW1vdmUsIHJlcGxhY2VXaXRoLCByZW1vdmVBbGxQcmV2U2libGluZ3MsIHJlbW92ZUFsbE5leHRTaWJsaW5ncyB9KSB7XG4gICAgY29uc3QgeyBraW5kLCBmbGFncyB9ID0gbm9kZTtcbiAgICBpZiAoa2luZCA9PT0gXCJmbGFnc1wiKSB7XG4gICAgICBpZiAoIWZsYWdzLmVuYWJsZSAmJiAhZmxhZ3MuZGlzYWJsZSkge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZsYWdHcm91cCA9IGNyZWF0ZUdyb3VwKHsgZmxhZ3MgfSk7XG4gICAgICAgIGZsYWdHcm91cC5ib2R5WzBdLmJvZHkgPSByZW1vdmVBbGxOZXh0U2libGluZ3MoKTtcbiAgICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50RGVlcChmbGFnR3JvdXAsIHBhcmVudCksIHsgdHJhdmVyc2U6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImtlZXBcIikge1xuICAgICAgY29uc3QgZmlyc3RBbHQgPSByb290LmJvZHlbMF07XG4gICAgICBjb25zdCBoYXNXcmFwcGVyR3JvdXAgPSByb290LmJvZHkubGVuZ3RoID09PSAxICYmIC8vIE5vdCBlbXVsYXRhYmxlIGlmIHdpdGhpbiBhIGBDYXB0dXJpbmdHcm91cGBcbiAgICAgIGhhc09ubHlDaGlsZChmaXJzdEFsdCwgeyB0eXBlOiBcIkdyb3VwXCIgfSkgJiYgZmlyc3RBbHQuYm9keVswXS5ib2R5Lmxlbmd0aCA9PT0gMTtcbiAgICAgIGNvbnN0IHRvcExldmVsID0gaGFzV3JhcHBlckdyb3VwID8gZmlyc3RBbHQuYm9keVswXSA6IHJvb3Q7XG4gICAgICBpZiAocGFyZW50LnBhcmVudCAhPT0gdG9wTGV2ZWwgfHwgdG9wTGV2ZWwuYm9keS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyYFVzZXMgXCJcXEtcIiBpbiBhIHdheSB0aGF0J3MgdW5zdXBwb3J0ZWRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvb2tiZWhpbmQgPSBjcmVhdGVMb29rYXJvdW5kQXNzZXJ0aW9uKHsgYmVoaW5kOiB0cnVlIH0pO1xuICAgICAgbG9va2JlaGluZC5ib2R5WzBdLmJvZHkgPSByZW1vdmVBbGxQcmV2U2libGluZ3MoKTtcbiAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAobG9va2JlaGluZCwgcGFyZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkaXJlY3RpdmUga2luZCBcIiR7a2luZH1cImApO1xuICAgIH1cbiAgfSxcbiAgRmxhZ3MoeyBub2RlLCBwYXJlbnQgfSkge1xuICAgIGlmIChub2RlLnBvc2l4SXNBc2NpaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmbGFnIFwiUFwiJyk7XG4gICAgfVxuICAgIGlmIChub2RlLnRleHRTZWdtZW50TW9kZSA9PT0gXCJ3b3JkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmxhZyBcInl7d31cIicpO1xuICAgIH1cbiAgICBbXG4gICAgICBcImRpZ2l0SXNBc2NpaVwiLFxuICAgICAgLy8gRmxhZyBEXG4gICAgICBcImV4dGVuZGVkXCIsXG4gICAgICAvLyBGbGFnIHhcbiAgICAgIFwicG9zaXhJc0FzY2lpXCIsXG4gICAgICAvLyBGbGFnIFBcbiAgICAgIFwic3BhY2VJc0FzY2lpXCIsXG4gICAgICAvLyBGbGFnIFNcbiAgICAgIFwid29yZElzQXNjaWlcIixcbiAgICAgIC8vIEZsYWcgV1xuICAgICAgXCJ0ZXh0U2VnbWVudE1vZGVcIlxuICAgICAgLy8gRmxhZyB5e2d9IG9yIHl7d31cbiAgICBdLmZvckVhY2goKGYpID0+IGRlbGV0ZSBub2RlW2ZdKTtcbiAgICBPYmplY3QuYXNzaWduKG5vZGUsIHtcbiAgICAgIC8vIEpTIGZsYWcgZzsgbm8gT25pZyBlcXVpdlxuICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgIC8vIEpTIGZsYWcgZDsgbm8gT25pZyBlcXVpdlxuICAgICAgaGFzSW5kaWNlczogZmFsc2UsXG4gICAgICAvLyBKUyBmbGFnIG07IG5vIE9uaWcgZXF1aXYgYnV0IGl0cyBiZWhhdmlvciBpcyBhbHdheXMgb24gaW4gT25pZy4gT25pZydzIG9ubHkgbGluZSBicmVha1xuICAgICAgLy8gY2hhciBpcyBsaW5lIGZlZWQsIHVubGlrZSBKUywgc28gdGhpcyBmbGFnIGlzbid0IHVzZWQgc2luY2UgaXQgd291bGQgcHJvZHVjZSBpbmFjY3VyYXRlXG4gICAgICAvLyByZXN1bHRzIChhbHNvIGFsbG93cyBgXmAgYW5kIGAkYCB0byBiZSB1c2VkIGluIHRoZSBnZW5lcmF0b3IgZm9yIHN0cmluZyBzdGFydCBhbmQgZW5kKVxuICAgICAgbXVsdGlsaW5lOiBmYWxzZSxcbiAgICAgIC8vIEpTIGZsYWcgeTsgbm8gT25pZyBlcXVpdiwgYnV0IHVzZWQgZm9yIGBcXEdgIGVtdWxhdGlvblxuICAgICAgc3RpY2t5OiBub2RlLnN0aWNreSA/PyBmYWxzZVxuICAgICAgLy8gTm90ZTogUmVnZXgrIGRvZXNuJ3QgYWxsb3cgZXhwbGljaXRseSBhZGRpbmcgZmxhZ3MgaXQgaGFuZGxlcyBpbXBsaWNpdGx5LCBzbyBsZWF2ZSBvdXRcbiAgICAgIC8vIHByb3BlcnRpZXMgYHVuaWNvZGVgIChKUyBmbGFnIHUpIGFuZCBgdW5pY29kZVNldHNgIChKUyBmbGFnIHYpLiBLZWVwIHRoZSBleGlzdGluZyB2YWx1ZXNcbiAgICAgIC8vIGZvciBgaWdub3JlQ2FzZWAgKGZsYWcgaSkgYW5kIGBkb3RBbGxgIChKUyBmbGFnIHMsIGJ1dCBPbmlnIGZsYWcgbSlcbiAgICB9KTtcbiAgICBwYXJlbnQub3B0aW9ucyA9IHtcbiAgICAgIGRpc2FibGU6IHtcbiAgICAgICAgLy8gT25pZyB1c2VzIGRpZmZlcmVudCBydWxlcyBmb3IgZmxhZyB4IHRoYW4gUmVnZXgrLCBzbyBkaXNhYmxlIHRoZSBpbXBsaWNpdCBmbGFnXG4gICAgICAgIHg6IHRydWUsXG4gICAgICAgIC8vIE9uaWcgaGFzIG5vIGZsYWcgdG8gY29udHJvbCBcIm5hbWVkIGNhcHR1cmUgb25seVwiIG1vZGUgYnV0IGNvbnRleHR1YWxseSBhcHBsaWVzIGl0c1xuICAgICAgICAvLyBiZWhhdmlvciB3aGVuIG5hbWVkIGNhcHR1cmluZyBpcyB1c2VkLCBzbyBkaXNhYmxlIFJlZ2V4KydzIGltcGxpY2l0IGZsYWcgZm9yIGl0XG4gICAgICAgIG46IHRydWVcbiAgICAgIH0sXG4gICAgICBmb3JjZToge1xuICAgICAgICAvLyBBbHdheXMgYWRkIGZsYWcgdiBiZWNhdXNlIHdlJ3JlIGdlbmVyYXRpbmcgYW4gQVNUIHRoYXQgcmVsaWVzIG9uIGl0IChpdCBlbmFibGVzIEpTXG4gICAgICAgIC8vIHN1cHBvcnQgZm9yIE9uaWcgZmVhdHVyZXMgbmVzdGVkIGNsYXNzZXMsIGludGVyc2VjdGlvbiwgVW5pY29kZSBwcm9wZXJ0aWVzLCBldGMuKS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGdlbmVyYXRvciBtaWdodCBkaXNhYmxlIGZsYWcgdiBiYXNlZCBvbiBpdHMgYHRhcmdldGAgb3B0aW9uXG4gICAgICAgIHY6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBHcm91cCh7IG5vZGUgfSkge1xuICAgIGlmICghbm9kZS5mbGFncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGVuYWJsZSwgZGlzYWJsZSB9ID0gbm9kZS5mbGFncztcbiAgICBlbmFibGU/LmV4dGVuZGVkICYmIGRlbGV0ZSBlbmFibGUuZXh0ZW5kZWQ7XG4gICAgZGlzYWJsZT8uZXh0ZW5kZWQgJiYgZGVsZXRlIGRpc2FibGUuZXh0ZW5kZWQ7XG4gICAgZW5hYmxlPy5kb3RBbGwgJiYgZGlzYWJsZT8uZG90QWxsICYmIGRlbGV0ZSBlbmFibGUuZG90QWxsO1xuICAgIGVuYWJsZT8uaWdub3JlQ2FzZSAmJiBkaXNhYmxlPy5pZ25vcmVDYXNlICYmIGRlbGV0ZSBlbmFibGUuaWdub3JlQ2FzZTtcbiAgICBlbmFibGUgJiYgIU9iamVjdC5rZXlzKGVuYWJsZSkubGVuZ3RoICYmIGRlbGV0ZSBub2RlLmZsYWdzLmVuYWJsZTtcbiAgICBkaXNhYmxlICYmICFPYmplY3Qua2V5cyhkaXNhYmxlKS5sZW5ndGggJiYgZGVsZXRlIG5vZGUuZmxhZ3MuZGlzYWJsZTtcbiAgICAhbm9kZS5mbGFncy5lbmFibGUgJiYgIW5vZGUuZmxhZ3MuZGlzYWJsZSAmJiBkZWxldGUgbm9kZS5mbGFncztcbiAgfSxcbiAgTG9va2Fyb3VuZEFzc2VydGlvbih7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IGtpbmQgfSA9IG5vZGU7XG4gICAgaWYgKGtpbmQgPT09IFwibG9va2JlaGluZFwiKSB7XG4gICAgICBzdGF0ZS5wYXNzZWRMb29rYmVoaW5kID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIE5hbWVkQ2FsbG91dCh7IG5vZGUsIHBhcmVudCwgcmVwbGFjZVdpdGggfSkge1xuICAgIGNvbnN0IHsga2luZCB9ID0gbm9kZTtcbiAgICBpZiAoa2luZCA9PT0gXCJmYWlsXCIpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAoY3JlYXRlTG9va2Fyb3VuZEFzc2VydGlvbih7IG5lZ2F0ZTogdHJ1ZSB9KSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbmFtZWQgY2FsbG91dCBcIigqJHtraW5kLnRvVXBwZXJDYXNlKCl9XCJgKTtcbiAgICB9XG4gIH0sXG4gIFF1YW50aWZpZXIoeyBub2RlIH0pIHtcbiAgICBpZiAobm9kZS5ib2R5LnR5cGUgPT09IFwiUXVhbnRpZmllclwiKSB7XG4gICAgICBjb25zdCBncm91cCA9IGNyZWF0ZUdyb3VwKCk7XG4gICAgICBncm91cC5ib2R5WzBdLmJvZHkucHVzaChub2RlLmJvZHkpO1xuICAgICAgbm9kZS5ib2R5ID0gc2V0UGFyZW50RGVlcChncm91cCwgbm9kZSk7XG4gICAgfVxuICB9LFxuICBSZWdleDoge1xuICAgIGVudGVyKHsgbm9kZSB9LCB7IHN1cHBvcnRlZEdOb2RlcyB9KSB7XG4gICAgICBjb25zdCBsZWFkaW5nR3MgPSBbXTtcbiAgICAgIGxldCBoYXNBbHRXaXRoTGVhZEcgPSBmYWxzZTtcbiAgICAgIGxldCBoYXNBbHRXaXRob3V0TGVhZEcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgYWx0IG9mIG5vZGUuYm9keSkge1xuICAgICAgICBpZiAoYWx0LmJvZHkubGVuZ3RoID09PSAxICYmIGFsdC5ib2R5WzBdLmtpbmQgPT09IFwic2VhcmNoX3N0YXJ0XCIpIHtcbiAgICAgICAgICBhbHQuYm9keS5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsZWFkaW5nRyA9IGdldExlYWRpbmdHKGFsdC5ib2R5KTtcbiAgICAgICAgICBpZiAobGVhZGluZ0cpIHtcbiAgICAgICAgICAgIGhhc0FsdFdpdGhMZWFkRyA9IHRydWU7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGxlYWRpbmdHKSA/IGxlYWRpbmdHcy5wdXNoKC4uLmxlYWRpbmdHKSA6IGxlYWRpbmdHcy5wdXNoKGxlYWRpbmdHKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzQWx0V2l0aG91dExlYWRHID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNBbHRXaXRoTGVhZEcgJiYgIWhhc0FsdFdpdGhvdXRMZWFkRykge1xuICAgICAgICBsZWFkaW5nR3MuZm9yRWFjaCgoZykgPT4gc3VwcG9ydGVkR05vZGVzLmFkZChnKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0KF8sIHsgYWNjdXJhY3ksIHBhc3NlZExvb2tiZWhpbmQsIHN0cmF0ZWd5IH0pIHtcbiAgICAgIGlmIChhY2N1cmFjeSA9PT0gXCJzdHJpY3RcIiAmJiBwYXNzZWRMb29rYmVoaW5kICYmIHN0cmF0ZWd5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyYFVzZXMgXCJcXEdcIiBpbiBhIHdheSB0aGF0IHJlcXVpcmVzIG5vbi1zdHJpY3QgYWNjdXJhY3lgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFN1YnJvdXRpbmUoeyBub2RlIH0sIHsganNHcm91cE5hbWVNYXAgfSkge1xuICAgIGxldCB7IHJlZiB9ID0gbm9kZTtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJzdHJpbmdcIiAmJiAhaXNWYWxpZEpzR3JvdXBOYW1lKHJlZikpIHtcbiAgICAgIHJlZiA9IGdldEFuZFN0b3JlSnNHcm91cE5hbWUocmVmLCBqc0dyb3VwTmFtZU1hcCk7XG4gICAgICBub2RlLnJlZiA9IHJlZjtcbiAgICB9XG4gIH1cbn07XG52YXIgU2Vjb25kUGFzc1Zpc2l0b3IgPSB7XG4gIEJhY2tyZWZlcmVuY2UoeyBub2RlIH0sIHsgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZiwgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIgfSkge1xuICAgIGNvbnN0IHsgb3JwaGFuLCByZWYgfSA9IG5vZGU7XG4gICAgaWYgKCFvcnBoYW4pIHtcbiAgICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLnNldChub2RlLCBbLi4ubXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZi5nZXQocmVmKS5tYXAoKHsgbm9kZTogbm9kZTIgfSkgPT4gbm9kZTIpXSk7XG4gICAgfVxuICB9LFxuICBDYXB0dXJpbmdHcm91cDoge1xuICAgIGVudGVyKHtcbiAgICAgIG5vZGUsXG4gICAgICBwYXJlbnQsXG4gICAgICByZXBsYWNlV2l0aCxcbiAgICAgIHNraXBcbiAgICB9LCB7XG4gICAgICBncm91cE9yaWdpbkJ5Q29weSxcbiAgICAgIGdyb3Vwc0J5TmFtZSxcbiAgICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYsXG4gICAgICBvcGVuUmVmcyxcbiAgICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyXG4gICAgfSkge1xuICAgICAgY29uc3Qgb3JpZ2luID0gZ3JvdXBPcmlnaW5CeUNvcHkuZ2V0KG5vZGUpO1xuICAgICAgaWYgKG9yaWdpbiAmJiBvcGVuUmVmcy5oYXMobm9kZS5udW1iZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlY3Vyc2lvbjIgPSBzZXRQYXJlbnQoY3JlYXRlUmVjdXJzaW9uKG5vZGUubnVtYmVyKSwgcGFyZW50KTtcbiAgICAgICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIuc2V0KHJlY3Vyc2lvbjIsIG9wZW5SZWZzLmdldChub2RlLm51bWJlcikpO1xuICAgICAgICByZXBsYWNlV2l0aChyZWN1cnNpb24yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3BlblJlZnMuc2V0KG5vZGUubnVtYmVyLCBub2RlKTtcbiAgICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYuc2V0KG5vZGUubnVtYmVyLCBbXSk7XG4gICAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICAgIGdldE9ySW5zZXJ0KG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYsIG5vZGUubmFtZSwgW10pO1xuICAgICAgfVxuICAgICAgY29uc3QgbXVsdGlwbGV4Tm9kZXMgPSBtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLmdldChub2RlLm5hbWUgPz8gbm9kZS5udW1iZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdWx0aXBsZXhOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtdWx0aXBsZXggPSBtdWx0aXBsZXhOb2Rlc1tpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIFRoaXMgZ3JvdXAgaXMgZnJvbSBzdWJyb3V0aW5lIGV4cGFuc2lvbiwgYW5kIHRoZXJlJ3MgYSBtdWx0aXBsZXggdmFsdWUgZnJvbSBlaXRoZXIgdGhlXG4gICAgICAgICAgLy8gb3JpZ2luIG5vZGUgb3IgYSBwcmlvciBzdWJyb3V0aW5lIGV4cGFuc2lvbiBncm91cCB3aXRoIHRoZSBzYW1lIG9yaWdpblxuICAgICAgICAgIG9yaWdpbiA9PT0gbXVsdGlwbGV4Lm5vZGUgfHwgb3JpZ2luICYmIG9yaWdpbiA9PT0gbXVsdGlwbGV4Lm9yaWdpbiB8fCAvLyBUaGlzIGdyb3VwIGlzIG5vdCBmcm9tIHN1YnJvdXRpbmUgZXhwYW5zaW9uLCBhbmQgaXQgY29tZXMgYWZ0ZXIgYSBzdWJyb3V0aW5lIGV4cGFuc2lvblxuICAgICAgICAgIC8vIGdyb3VwIHRoYXQgcmVmZXJzIHRvIHRoaXMgZ3JvdXBcbiAgICAgICAgICBub2RlID09PSBtdWx0aXBsZXgub3JpZ2luXG4gICAgICAgICkge1xuICAgICAgICAgIG11bHRpcGxleE5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZi5nZXQobm9kZS5udW1iZXIpLnB1c2goeyBub2RlLCBvcmlnaW4gfSk7XG4gICAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYuZ2V0KG5vZGUubmFtZSkucHVzaCh7IG5vZGUsIG9yaWdpbiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzV2l0aFNhbWVOYW1lID0gZ2V0T3JJbnNlcnQoZ3JvdXBzQnlOYW1lLCBub2RlLm5hbWUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgICBsZXQgaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICBoYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgZ3JvdXBJbmZvIG9mIGdyb3Vwc1dpdGhTYW1lTmFtZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFncm91cEluZm8uaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBncm91cHNCeU5hbWUuZ2V0KG5vZGUubmFtZSkuc2V0KG5vZGUsIHsgbm9kZSwgaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdCh7IG5vZGUgfSwgeyBvcGVuUmVmcyB9KSB7XG4gICAgICBvcGVuUmVmcy5kZWxldGUobm9kZS5udW1iZXIpO1xuICAgIH1cbiAgfSxcbiAgR3JvdXA6IHtcbiAgICBlbnRlcih7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICAgIHN0YXRlLnByZXZGbGFncyA9IHN0YXRlLmN1cnJlbnRGbGFncztcbiAgICAgIGlmIChub2RlLmZsYWdzKSB7XG4gICAgICAgIHN0YXRlLmN1cnJlbnRGbGFncyA9IGdldE5ld0N1cnJlbnRGbGFncyhzdGF0ZS5jdXJyZW50RmxhZ3MsIG5vZGUuZmxhZ3MpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdChfLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuY3VycmVudEZsYWdzID0gc3RhdGUucHJldkZsYWdzO1xuICAgIH1cbiAgfSxcbiAgU3Vicm91dGluZSh7IG5vZGUsIHBhcmVudCwgcmVwbGFjZVdpdGggfSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IGlzUmVjdXJzaXZlLCByZWYgfSA9IG5vZGU7XG4gICAgaWYgKGlzUmVjdXJzaXZlKSB7XG4gICAgICBsZXQgcmVmZmVkID0gcGFyZW50O1xuICAgICAgd2hpbGUgKHJlZmZlZCA9IHJlZmZlZC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKHJlZmZlZC50eXBlID09PSBcIkNhcHR1cmluZ0dyb3VwXCIgJiYgKHJlZmZlZC5uYW1lID09PSByZWYgfHwgcmVmZmVkLm51bWJlciA9PT0gcmVmKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5yZWZmZWROb2Rlc0J5UmVmZXJlbmNlci5zZXQobm9kZSwgcmVmZmVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVmZmVkR3JvdXBOb2RlID0gc3RhdGUuc3Vicm91dGluZVJlZk1hcC5nZXQocmVmKTtcbiAgICBjb25zdCBpc0dsb2JhbFJlY3Vyc2lvbiA9IHJlZiA9PT0gMDtcbiAgICBjb25zdCBleHBhbmRlZFN1YnJvdXRpbmUgPSBpc0dsb2JhbFJlY3Vyc2lvbiA/IGNyZWF0ZVJlY3Vyc2lvbigwKSA6IChcbiAgICAgIC8vIFRoZSByZWZmZWQgZ3JvdXAgbWlnaHQgaXRzZWxmIGNvbnRhaW4gc3Vicm91dGluZXMsIHdoaWNoIGFyZSBleHBhbmRlZCBkdXJpbmcgc3ViLXRyYXZlcnNhbFxuICAgICAgY2xvbmVDYXB0dXJpbmdHcm91cChyZWZmZWRHcm91cE5vZGUsIHN0YXRlLmdyb3VwT3JpZ2luQnlDb3B5LCBudWxsKVxuICAgICk7XG4gICAgbGV0IHJlcGxhY2VtZW50ID0gZXhwYW5kZWRTdWJyb3V0aW5lO1xuICAgIGlmICghaXNHbG9iYWxSZWN1cnNpb24pIHtcbiAgICAgIGNvbnN0IHJlZmZlZEdyb3VwRmxhZ01vZHMgPSBnZXRDb21iaW5lZEZsYWdNb2RzRnJvbUZsYWdOb2RlcyhnZXRBbGxQYXJlbnRzKFxuICAgICAgICByZWZmZWRHcm91cE5vZGUsXG4gICAgICAgIChwKSA9PiBwLnR5cGUgPT09IFwiR3JvdXBcIiAmJiAhIXAuZmxhZ3NcbiAgICAgICkpO1xuICAgICAgY29uc3QgcmVmZmVkR3JvdXBGbGFncyA9IHJlZmZlZEdyb3VwRmxhZ01vZHMgPyBnZXROZXdDdXJyZW50RmxhZ3Moc3RhdGUuZ2xvYmFsRmxhZ3MsIHJlZmZlZEdyb3VwRmxhZ01vZHMpIDogc3RhdGUuZ2xvYmFsRmxhZ3M7XG4gICAgICBpZiAoIWFyZUZsYWdzRXF1YWwocmVmZmVkR3JvdXBGbGFncywgc3RhdGUuY3VycmVudEZsYWdzKSkge1xuICAgICAgICByZXBsYWNlbWVudCA9IGNyZWF0ZUdyb3VwKHtcbiAgICAgICAgICBmbGFnczogZ2V0RmxhZ01vZHNGcm9tRmxhZ3MocmVmZmVkR3JvdXBGbGFncylcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxhY2VtZW50LmJvZHlbMF0uYm9keS5wdXNoKGV4cGFuZGVkU3Vicm91dGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAocmVwbGFjZW1lbnQsIHBhcmVudCksIHsgdHJhdmVyc2U6ICFpc0dsb2JhbFJlY3Vyc2lvbiB9KTtcbiAgfVxufTtcbnZhciBUaGlyZFBhc3NWaXNpdG9yID0ge1xuICBCYWNrcmVmZXJlbmNlKHsgbm9kZSwgcGFyZW50LCByZXBsYWNlV2l0aCB9LCBzdGF0ZSkge1xuICAgIGlmIChub2RlLm9ycGhhbikge1xuICAgICAgc3RhdGUuaGlnaGVzdE9ycGhhbkJhY2tyZWYgPSBNYXRoLm1heChzdGF0ZS5oaWdoZXN0T3JwaGFuQmFja3JlZiwgbm9kZS5yZWYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWZmZWROb2RlcyA9IHN0YXRlLnJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLmdldChub2RlKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSByZWZmZWROb2Rlcy5maWx0ZXIoKHJlZmZlZCkgPT4gY2FuUGFydGljaXBhdGVXaXRoTm9kZShyZWZmZWQsIG5vZGUpKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50cy5sZW5ndGgpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHNldFBhcmVudERlZXAoY3JlYXRlTG9va2Fyb3VuZEFzc2VydGlvbih7IG5lZ2F0ZTogdHJ1ZSB9KSwgcGFyZW50KSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0aWNpcGFudHMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgZ3JvdXAgPSBjcmVhdGVHcm91cCh7XG4gICAgICAgIGF0b21pYzogdHJ1ZSxcbiAgICAgICAgYm9keTogcGFydGljaXBhbnRzLnJldmVyc2UoKS5tYXAoKHJlZmZlZCkgPT4gY3JlYXRlQWx0ZXJuYXRpdmUoe1xuICAgICAgICAgIGJvZHk6IFtjcmVhdGVCYWNrcmVmZXJlbmNlKHJlZmZlZC5udW1iZXIpXVxuICAgICAgICB9KSlcbiAgICAgIH0pO1xuICAgICAgcmVwbGFjZVdpdGgoc2V0UGFyZW50RGVlcChncm91cCwgcGFyZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVmID0gcGFydGljaXBhbnRzWzBdLm51bWJlcjtcbiAgICB9XG4gIH0sXG4gIENhcHR1cmluZ0dyb3VwKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIG5vZGUubnVtYmVyID0gKytzdGF0ZS5udW1DYXB0dXJlc1RvTGVmdDtcbiAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICBpZiAoc3RhdGUuZ3JvdXBzQnlOYW1lLmdldChub2RlLm5hbWUpLmdldChub2RlKS5oYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUpIHtcbiAgICAgICAgZGVsZXRlIG5vZGUubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFJlZ2V4OiB7XG4gICAgZXhpdCh7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICAgIGNvbnN0IG51bUNhcHNOZWVkZWQgPSBNYXRoLm1heChzdGF0ZS5oaWdoZXN0T3JwaGFuQmFja3JlZiAtIHN0YXRlLm51bUNhcHR1cmVzVG9MZWZ0LCAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2Fwc05lZWRlZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVtcHR5Q2FwdHVyZSA9IGNyZWF0ZUNhcHR1cmluZ0dyb3VwKCk7XG4gICAgICAgIG5vZGUuYm9keS5hdCgtMSkuYm9keS5wdXNoKGVtcHR5Q2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBTdWJyb3V0aW5lKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIGlmICghbm9kZS5pc1JlY3Vyc2l2ZSB8fCBub2RlLnJlZiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnJlZiA9IHN0YXRlLnJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLmdldChub2RlKS5udW1iZXI7XG4gIH1cbn07XG5mdW5jdGlvbiBhZGRQYXJlbnRQcm9wZXJ0aWVzKHJvb3QpIHtcbiAgdHJhdmVyc2Uocm9vdCwge1xuICAgIFwiKlwiKHsgbm9kZSwgcGFyZW50IH0pIHtcbiAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhcmVGbGFnc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEuZG90QWxsID09PSBiLmRvdEFsbCAmJiBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZTtcbn1cbmZ1bmN0aW9uIGNhblBhcnRpY2lwYXRlV2l0aE5vZGUoY2FwdHVyZSwgbm9kZSkge1xuICBsZXQgcmlnaHRtb3N0UG9pbnQgPSBub2RlO1xuICBkbyB7XG4gICAgaWYgKHJpZ2h0bW9zdFBvaW50LnR5cGUgPT09IFwiUmVnZXhcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmlnaHRtb3N0UG9pbnQudHlwZSA9PT0gXCJBbHRlcm5hdGl2ZVwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0bW9zdFBvaW50ID09PSBjYXB0dXJlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGtpZHNPZlBhcmVudCA9IGdldEtpZHMocmlnaHRtb3N0UG9pbnQucGFyZW50KTtcbiAgICBmb3IgKGNvbnN0IGtpZCBvZiBraWRzT2ZQYXJlbnQpIHtcbiAgICAgIGlmIChraWQgPT09IHJpZ2h0bW9zdFBvaW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGtpZCA9PT0gY2FwdHVyZSB8fCBpc0FuY2VzdG9yT2Yoa2lkLCBjYXB0dXJlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKHJpZ2h0bW9zdFBvaW50ID0gcmlnaHRtb3N0UG9pbnQucGFyZW50KTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBwYXRoXCIpO1xufVxuZnVuY3Rpb24gY2xvbmVDYXB0dXJpbmdHcm91cChvYmosIG9yaWdpbk1hcCwgdXAsIHVwMikge1xuICBjb25zdCBzdG9yZSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBpZiAoa2V5ID09PSBcInBhcmVudFwiKSB7XG4gICAgICBzdG9yZS5wYXJlbnQgPSBBcnJheS5pc0FycmF5KHVwKSA/IHVwMiA6IHVwO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBzdG9yZVtrZXldID0gY2xvbmVDYXB0dXJpbmdHcm91cCh2YWx1ZSwgb3JpZ2luTWFwLCBzdG9yZSwgdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5ID09PSBcInR5cGVcIiAmJiB2YWx1ZSA9PT0gXCJDYXB0dXJpbmdHcm91cFwiKSB7XG4gICAgICAgIG9yaWdpbk1hcC5zZXQoc3RvcmUsIG9yaWdpbk1hcC5nZXQob2JqKSA/PyBvYmopO1xuICAgICAgfVxuICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWN1cnNpb24ocmVmKSB7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVTdWJyb3V0aW5lKHJlZik7XG4gIG5vZGUuaXNSZWN1cnNpdmUgPSB0cnVlO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGdldEFsbFBhcmVudHMobm9kZSwgZmlsdGVyRm4pIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgaWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbihub2RlKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIGdldEFuZFN0b3JlSnNHcm91cE5hbWUobmFtZSwgbWFwKSB7XG4gIGlmIChtYXAuaGFzKG5hbWUpKSB7XG4gICAgcmV0dXJuIG1hcC5nZXQobmFtZSk7XG4gIH1cbiAgY29uc3QganNOYW1lID0gYCQke21hcC5zaXplfV8ke25hbWUucmVwbGFjZSgvXlteJF9cXHB7SURTfV18W14kXFx1MjAwQ1xcdTIwMERcXHB7SURDfV0vdWcsIFwiX1wiKX1gO1xuICBtYXAuc2V0KG5hbWUsIGpzTmFtZSk7XG4gIHJldHVybiBqc05hbWU7XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZEZsYWdNb2RzRnJvbUZsYWdOb2RlcyhmbGFnTm9kZXMpIHtcbiAgY29uc3QgZmxhZ1Byb3BzID0gW1wiZG90QWxsXCIsIFwiaWdub3JlQ2FzZVwiXTtcbiAgY29uc3QgY29tYmluZWRGbGFncyA9IHsgZW5hYmxlOiB7fSwgZGlzYWJsZToge30gfTtcbiAgZmxhZ05vZGVzLmZvckVhY2goKHsgZmxhZ3MgfSkgPT4ge1xuICAgIGZsYWdQcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAoZmxhZ3MuZW5hYmxlPy5bcHJvcF0pIHtcbiAgICAgICAgZGVsZXRlIGNvbWJpbmVkRmxhZ3MuZGlzYWJsZVtwcm9wXTtcbiAgICAgICAgY29tYmluZWRGbGFncy5lbmFibGVbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWdzLmRpc2FibGU/Lltwcm9wXSkge1xuICAgICAgICBjb21iaW5lZEZsYWdzLmRpc2FibGVbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgaWYgKCFPYmplY3Qua2V5cyhjb21iaW5lZEZsYWdzLmVuYWJsZSkubGVuZ3RoKSB7XG4gICAgZGVsZXRlIGNvbWJpbmVkRmxhZ3MuZW5hYmxlO1xuICB9XG4gIGlmICghT2JqZWN0LmtleXMoY29tYmluZWRGbGFncy5kaXNhYmxlKS5sZW5ndGgpIHtcbiAgICBkZWxldGUgY29tYmluZWRGbGFncy5kaXNhYmxlO1xuICB9XG4gIGlmIChjb21iaW5lZEZsYWdzLmVuYWJsZSB8fCBjb21iaW5lZEZsYWdzLmRpc2FibGUpIHtcbiAgICByZXR1cm4gY29tYmluZWRGbGFncztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEZsYWdNb2RzRnJvbUZsYWdzKHsgZG90QWxsLCBpZ25vcmVDYXNlIH0pIHtcbiAgY29uc3QgbW9kcyA9IHt9O1xuICBpZiAoZG90QWxsIHx8IGlnbm9yZUNhc2UpIHtcbiAgICBtb2RzLmVuYWJsZSA9IHt9O1xuICAgIGRvdEFsbCAmJiAobW9kcy5lbmFibGUuZG90QWxsID0gdHJ1ZSk7XG4gICAgaWdub3JlQ2FzZSAmJiAobW9kcy5lbmFibGUuaWdub3JlQ2FzZSA9IHRydWUpO1xuICB9XG4gIGlmICghZG90QWxsIHx8ICFpZ25vcmVDYXNlKSB7XG4gICAgbW9kcy5kaXNhYmxlID0ge307XG4gICAgIWRvdEFsbCAmJiAobW9kcy5kaXNhYmxlLmRvdEFsbCA9IHRydWUpO1xuICAgICFpZ25vcmVDYXNlICYmIChtb2RzLmRpc2FibGUuaWdub3JlQ2FzZSA9IHRydWUpO1xuICB9XG4gIHJldHVybiBtb2RzO1xufVxuZnVuY3Rpb24gZ2V0S2lkcyhub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGUgZXhwZWN0ZWRcIik7XG4gIH1cbiAgY29uc3QgeyBib2R5IH0gPSBub2RlO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShib2R5KSA/IGJvZHkgOiBib2R5ID8gW2JvZHldIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldExlYWRpbmdHKGVscykge1xuICBjb25zdCBmaXJzdFRvQ29uc2lkZXIgPSBlbHMuZmluZCgoZWwpID0+IGVsLmtpbmQgPT09IFwic2VhcmNoX3N0YXJ0XCIgfHwgaXNMb25lR0xvb2thcm91bmQoZWwsIHsgbmVnYXRlOiBmYWxzZSB9KSB8fCAhaXNBbHdheXNaZXJvTGVuZ3RoKGVsKSk7XG4gIGlmICghZmlyc3RUb0NvbnNpZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGZpcnN0VG9Db25zaWRlci5raW5kID09PSBcInNlYXJjaF9zdGFydFwiKSB7XG4gICAgcmV0dXJuIGZpcnN0VG9Db25zaWRlcjtcbiAgfVxuICBpZiAoZmlyc3RUb0NvbnNpZGVyLnR5cGUgPT09IFwiTG9va2Fyb3VuZEFzc2VydGlvblwiKSB7XG4gICAgcmV0dXJuIGZpcnN0VG9Db25zaWRlci5ib2R5WzBdLmJvZHlbMF07XG4gIH1cbiAgaWYgKGZpcnN0VG9Db25zaWRlci50eXBlID09PSBcIkNhcHR1cmluZ0dyb3VwXCIgfHwgZmlyc3RUb0NvbnNpZGVyLnR5cGUgPT09IFwiR3JvdXBcIikge1xuICAgIGNvbnN0IGdOb2Rlc0Zvckdyb3VwID0gW107XG4gICAgZm9yIChjb25zdCBhbHQgb2YgZmlyc3RUb0NvbnNpZGVyLmJvZHkpIHtcbiAgICAgIGNvbnN0IGxlYWRpbmdHID0gZ2V0TGVhZGluZ0coYWx0LmJvZHkpO1xuICAgICAgaWYgKCFsZWFkaW5nRykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIEFycmF5LmlzQXJyYXkobGVhZGluZ0cpID8gZ05vZGVzRm9yR3JvdXAucHVzaCguLi5sZWFkaW5nRykgOiBnTm9kZXNGb3JHcm91cC5wdXNoKGxlYWRpbmdHKTtcbiAgICB9XG4gICAgcmV0dXJuIGdOb2Rlc0Zvckdyb3VwO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNBbmNlc3Rvck9mKG5vZGUsIGRlc2NlbmRhbnQpIHtcbiAgY29uc3Qga2lkcyA9IGdldEtpZHMobm9kZSkgPz8gW107XG4gIGZvciAoY29uc3Qga2lkIG9mIGtpZHMpIHtcbiAgICBpZiAoa2lkID09PSBkZXNjZW5kYW50IHx8IGlzQW5jZXN0b3JPZihraWQsIGRlc2NlbmRhbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNBbHdheXNaZXJvTGVuZ3RoKHsgdHlwZSB9KSB7XG4gIHJldHVybiB0eXBlID09PSBcIkFzc2VydGlvblwiIHx8IHR5cGUgPT09IFwiRGlyZWN0aXZlXCIgfHwgdHlwZSA9PT0gXCJMb29rYXJvdW5kQXNzZXJ0aW9uXCI7XG59XG5mdW5jdGlvbiBpc0Fsd2F5c05vblplcm9MZW5ndGgobm9kZSkge1xuICBjb25zdCB0eXBlcyA9IFtcbiAgICBcIkNoYXJhY3RlclwiLFxuICAgIFwiQ2hhcmFjdGVyQ2xhc3NcIixcbiAgICBcIkNoYXJhY3RlclNldFwiXG4gIF07XG4gIHJldHVybiB0eXBlcy5pbmNsdWRlcyhub2RlLnR5cGUpIHx8IG5vZGUudHlwZSA9PT0gXCJRdWFudGlmaWVyXCIgJiYgbm9kZS5taW4gJiYgdHlwZXMuaW5jbHVkZXMobm9kZS5ib2R5LnR5cGUpO1xufVxuZnVuY3Rpb24gaXNMb25lR0xvb2thcm91bmQobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG5lZ2F0ZTogbnVsbCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiTG9va2Fyb3VuZEFzc2VydGlvblwiICYmIChvcHRzLm5lZ2F0ZSA9PT0gbnVsbCB8fCBub2RlLm5lZ2F0ZSA9PT0gb3B0cy5uZWdhdGUpICYmIG5vZGUuYm9keS5sZW5ndGggPT09IDEgJiYgaGFzT25seUNoaWxkKG5vZGUuYm9keVswXSwge1xuICAgIHR5cGU6IFwiQXNzZXJ0aW9uXCIsXG4gICAga2luZDogXCJzZWFyY2hfc3RhcnRcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKc0dyb3VwTmFtZShuYW1lKSB7XG4gIHJldHVybiAvXlskX1xccHtJRFN9XVskXFx1MjAwQ1xcdTIwMERcXHB7SURDfV0qJC91LnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBwYXJzZUZyYWdtZW50KHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgYXN0ID0gcGFyc2UocGF0dGVybiwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgLy8gUHJvdmlkaW5nIGEgY3VzdG9tIHNldCBvZiBVbmljb2RlIHByb3BlcnR5IG5hbWVzIGF2b2lkcyBjb252ZXJ0aW5nIHNvbWUgSlMgVW5pY29kZVxuICAgIC8vIHByb3BlcnRpZXMgKGV4OiBgXFxwe0FscGhhfWApIHRvIE9uaWcgUE9TSVggY2xhc3Nlc1xuICAgIHVuaWNvZGVQcm9wZXJ0eU1hcDogSnNVbmljb2RlUHJvcGVydHlNYXBcbiAgfSk7XG4gIGNvbnN0IGFsdHMgPSBhc3QuYm9keTtcbiAgaWYgKGFsdHMubGVuZ3RoID4gMSB8fCBhbHRzWzBdLmJvZHkubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBjcmVhdGVHcm91cCh7IGJvZHk6IGFsdHMgfSk7XG4gIH1cbiAgcmV0dXJuIGFsdHNbMF0uYm9keVswXTtcbn1cbmZ1bmN0aW9uIHNldE5lZ2F0ZShub2RlLCBuZWdhdGUpIHtcbiAgbm9kZS5uZWdhdGUgPSBuZWdhdGU7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc2V0UGFyZW50KG5vZGUsIHBhcmVudCkge1xuICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXRQYXJlbnREZWVwKG5vZGUsIHBhcmVudCkge1xuICBhZGRQYXJlbnRQcm9wZXJ0aWVzKG5vZGUpO1xuICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS5qc1xuaW1wb3J0IHsgY3JlYXRlQWx0ZXJuYXRpdmUgYXMgY3JlYXRlQWx0ZXJuYXRpdmUyLCBjcmVhdGVDaGFyYWN0ZXIgYXMgY3JlYXRlQ2hhcmFjdGVyMiwgY3JlYXRlR3JvdXAgYXMgY3JlYXRlR3JvdXAyIH0gZnJvbSBcIm9uaWd1cnVtYS1wYXJzZXIvcGFyc2VyXCI7XG5pbXBvcnQgeyB0cmF2ZXJzZSBhcyB0cmF2ZXJzZTIgfSBmcm9tIFwib25pZ3VydW1hLXBhcnNlci90cmF2ZXJzZXJcIjtcbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgbWluVGFyZ2V0RXMyMDI0ID0gaXNNaW5UYXJnZXQob3B0cy50YXJnZXQsIFwiRVMyMDI0XCIpO1xuICBjb25zdCBtaW5UYXJnZXRFczIwMjUgPSBpc01pblRhcmdldChvcHRzLnRhcmdldCwgXCJFUzIwMjVcIik7XG4gIGNvbnN0IHJlY3Vyc2lvbkxpbWl0ID0gb3B0cy5ydWxlcy5yZWN1cnNpb25MaW1pdDtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJlY3Vyc2lvbkxpbWl0KSB8fCByZWN1cnNpb25MaW1pdCA8IDIgfHwgcmVjdXJzaW9uTGltaXQgPiAyMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVjdXJzaW9uTGltaXQ7IHVzZSAyLTIwXCIpO1xuICB9XG4gIGxldCBoYXNDYXNlSW5zZW5zaXRpdmVOb2RlID0gbnVsbDtcbiAgbGV0IGhhc0Nhc2VTZW5zaXRpdmVOb2RlID0gbnVsbDtcbiAgaWYgKCFtaW5UYXJnZXRFczIwMjUpIHtcbiAgICBjb25zdCBpU3RhY2sgPSBbYXN0LmZsYWdzLmlnbm9yZUNhc2VdO1xuICAgIHRyYXZlcnNlMihhc3QsIEZsYWdNb2RpZmllclZpc2l0b3IsIHtcbiAgICAgIGdldEN1cnJlbnRNb2RJOiAoKSA9PiBpU3RhY2suYXQoLTEpLFxuICAgICAgcG9wTW9kSSgpIHtcbiAgICAgICAgaVN0YWNrLnBvcCgpO1xuICAgICAgfSxcbiAgICAgIHB1c2hNb2RJKGlzSU9uKSB7XG4gICAgICAgIGlTdGFjay5wdXNoKGlzSU9uKTtcbiAgICAgIH0sXG4gICAgICBzZXRIYXNDYXNlZENoYXIoKSB7XG4gICAgICAgIGlmIChpU3RhY2suYXQoLTEpKSB7XG4gICAgICAgICAgaGFzQ2FzZUluc2Vuc2l0aXZlTm9kZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzQ2FzZVNlbnNpdGl2ZU5vZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYXBwbGllZEdsb2JhbEZsYWdzID0ge1xuICAgIGRvdEFsbDogYXN0LmZsYWdzLmRvdEFsbCxcbiAgICAvLyAtIFR1cm4gZ2xvYmFsIGZsYWcgaSBvbiBpZiBhIGNhc2UgaW5zZW5zaXRpdmUgbm9kZSB3YXMgdXNlZCBhbmQgbm8gY2FzZSBzZW5zaXRpdmUgbm9kZXMgd2VyZVxuICAgIC8vICAgdXNlZCAodG8gYXZvaWQgdW5uZWNlc3Nhcnkgbm9kZSBleHBhbnNpb24pLlxuICAgIC8vIC0gVHVybiBnbG9iYWwgZmxhZyBpIG9mZiBpZiBhIGNhc2Ugc2Vuc2l0aXZlIG5vZGUgd2FzIHVzZWQgKHNpbmNlIGNhc2Ugc2Vuc2l0aXZpdHkgY2FuJ3QgYmVcbiAgICAvLyAgIGZvcmNlZCB3aXRob3V0IHRoZSB1c2Ugb2YgRVMyMDI1IGZsYWcgZ3JvdXBzKVxuICAgIGlnbm9yZUNhc2U6ICEhKChhc3QuZmxhZ3MuaWdub3JlQ2FzZSB8fCBoYXNDYXNlSW5zZW5zaXRpdmVOb2RlKSAmJiAhaGFzQ2FzZVNlbnNpdGl2ZU5vZGUpXG4gIH07XG4gIGxldCBsYXN0Tm9kZSA9IGFzdDtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgYWNjdXJhY3k6IG9wdHMuYWNjdXJhY3ksXG4gICAgYXBwbGllZEdsb2JhbEZsYWdzLFxuICAgIGNhcHR1cmVNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgY3VycmVudEZsYWdzOiB7XG4gICAgICBkb3RBbGw6IGFzdC5mbGFncy5kb3RBbGwsXG4gICAgICBpZ25vcmVDYXNlOiBhc3QuZmxhZ3MuaWdub3JlQ2FzZVxuICAgIH0sXG4gICAgaW5DaGFyQ2xhc3M6IGZhbHNlLFxuICAgIGxhc3ROb2RlLFxuICAgIG9yaWdpbk1hcDogYXN0Ll9vcmlnaW5NYXAsXG4gICAgcmVjdXJzaW9uTGltaXQsXG4gICAgdXNlQXBwbGllZElnbm9yZUNhc2U6ICEhKCFtaW5UYXJnZXRFczIwMjUgJiYgaGFzQ2FzZUluc2Vuc2l0aXZlTm9kZSAmJiBoYXNDYXNlU2Vuc2l0aXZlTm9kZSksXG4gICAgdXNlRmxhZ01vZHM6IG1pblRhcmdldEVzMjAyNSxcbiAgICB1c2VGbGFnVjogbWluVGFyZ2V0RXMyMDI0LFxuICAgIHZlcmJvc2U6IG9wdHMudmVyYm9zZVxuICB9O1xuICBmdW5jdGlvbiBnZW4obm9kZSkge1xuICAgIHN0YXRlLmxhc3ROb2RlID0gbGFzdE5vZGU7XG4gICAgbGFzdE5vZGUgPSBub2RlO1xuICAgIGNvbnN0IGZuID0gdGhyb3dJZk51bGxpc2goZ2VuZXJhdG9yW25vZGUudHlwZV0sIGBVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIiR7bm9kZS50eXBlfVwiYCk7XG4gICAgcmV0dXJuIGZuKG5vZGUsIHN0YXRlLCBnZW4pO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBwYXR0ZXJuOiBhc3QuYm9keS5tYXAoZ2VuKS5qb2luKFwifFwiKSxcbiAgICAvLyBDb3VsZCByZXNldCBgbGFzdE5vZGVgIGF0IHRoaXMgcG9pbnQgdmlhIGBsYXN0Tm9kZSA9IGFzdGAsIGJ1dCBpdCBpc24ndCBuZWVkZWQgYnkgZmxhZ3NcbiAgICBmbGFnczogZ2VuKGFzdC5mbGFncyksXG4gICAgb3B0aW9uczogeyAuLi5hc3Qub3B0aW9ucyB9XG4gIH07XG4gIGlmICghbWluVGFyZ2V0RXMyMDI0KSB7XG4gICAgZGVsZXRlIHJlc3VsdC5vcHRpb25zLmZvcmNlLnY7XG4gICAgcmVzdWx0Lm9wdGlvbnMuZGlzYWJsZS52ID0gdHJ1ZTtcbiAgICByZXN1bHQub3B0aW9ucy51bmljb2RlU2V0c1BsdWdpbiA9IG51bGw7XG4gIH1cbiAgcmVzdWx0Ll9jYXB0dXJlVHJhbnNmZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmVzdWx0Ll9oaWRkZW5DYXB0dXJlcyA9IFtdO1xuICBzdGF0ZS5jYXB0dXJlTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuaGlkZGVuKSB7XG4gICAgICByZXN1bHQuX2hpZGRlbkNhcHR1cmVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnRyYW5zZmVyVG8pIHtcbiAgICAgIGdldE9ySW5zZXJ0KHJlc3VsdC5fY2FwdHVyZVRyYW5zZmVycywgdmFsdWUudHJhbnNmZXJUbywgW10pLnB1c2goa2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEZsYWdNb2RpZmllclZpc2l0b3IgPSB7XG4gIFwiKlwiOiB7XG4gICAgZW50ZXIoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgICBpZiAoaXNBbnlHcm91cChub2RlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50TW9kSSA9IHN0YXRlLmdldEN1cnJlbnRNb2RJKCk7XG4gICAgICAgIHN0YXRlLnB1c2hNb2RJKFxuICAgICAgICAgIG5vZGUuZmxhZ3MgPyBnZXROZXdDdXJyZW50RmxhZ3MoeyBpZ25vcmVDYXNlOiBjdXJyZW50TW9kSSB9LCBub2RlLmZsYWdzKS5pZ25vcmVDYXNlIDogY3VycmVudE1vZElcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgICBpZiAoaXNBbnlHcm91cChub2RlKSkge1xuICAgICAgICBzdGF0ZS5wb3BNb2RJKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBCYWNrcmVmZXJlbmNlKF8sIHN0YXRlKSB7XG4gICAgc3RhdGUuc2V0SGFzQ2FzZWRDaGFyKCk7XG4gIH0sXG4gIENoYXJhY3Rlcih7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICBpZiAoY2hhckhhc0Nhc2UoY3Aobm9kZS52YWx1ZSkpKSB7XG4gICAgICBzdGF0ZS5zZXRIYXNDYXNlZENoYXIoKTtcbiAgICB9XG4gIH0sXG4gIENoYXJhY3RlckNsYXNzUmFuZ2UoeyBub2RlLCBza2lwIH0sIHN0YXRlKSB7XG4gICAgc2tpcCgpO1xuICAgIGlmIChnZXRDYXNlc091dHNpZGVDaGFyQ2xhc3NSYW5nZShub2RlLCB7IGZpcnN0T25seTogdHJ1ZSB9KS5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLnNldEhhc0Nhc2VkQ2hhcigpO1xuICAgIH1cbiAgfSxcbiAgQ2hhcmFjdGVyU2V0KHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIGlmIChub2RlLmtpbmQgPT09IFwicHJvcGVydHlcIiAmJiBVbmljb2RlUHJvcGVydGllc1dpdGhTcGVjaWZpY0Nhc2UuaGFzKG5vZGUudmFsdWUpKSB7XG4gICAgICBzdGF0ZS5zZXRIYXNDYXNlZENoYXIoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgZ2VuZXJhdG9yID0ge1xuICAvKipcbiAgQHBhcmFtIHtBbHRlcm5hdGl2ZU5vZGV9IG5vZGVcbiAgKi9cbiAgQWx0ZXJuYXRpdmUoeyBib2R5IH0sIF8sIGdlbikge1xuICAgIHJldHVybiBib2R5Lm1hcChnZW4pLmpvaW4oXCJcIik7XG4gIH0sXG4gIC8qKlxuICBAcGFyYW0ge0Fzc2VydGlvbk5vZGV9IG5vZGVcbiAgKi9cbiAgQXNzZXJ0aW9uKHsga2luZCwgbmVnYXRlIH0pIHtcbiAgICBpZiAoa2luZCA9PT0gXCJzdHJpbmdfZW5kXCIpIHtcbiAgICAgIHJldHVybiBcIiRcIjtcbiAgICB9XG4gICAgaWYgKGtpbmQgPT09IFwic3RyaW5nX3N0YXJ0XCIpIHtcbiAgICAgIHJldHVybiBcIl5cIjtcbiAgICB9XG4gICAgaWYgKGtpbmQgPT09IFwid29yZF9ib3VuZGFyeVwiKSB7XG4gICAgICByZXR1cm4gbmVnYXRlID8gcmBcXEJgIDogcmBcXGJgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgYXNzZXJ0aW9uIGtpbmQgXCIke2tpbmR9XCJgKTtcbiAgfSxcbiAgLyoqXG4gIEBwYXJhbSB7QmFja3JlZmVyZW5jZU5vZGV9IG5vZGVcbiAgKi9cbiAgQmFja3JlZmVyZW5jZSh7IHJlZiB9LCBzdGF0ZSkge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5hbWVkIGJhY2tyZWYgaW4gdHJhbnNmb3JtZWQgQVNUXCIpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLnVzZUZsYWdNb2RzICYmIHN0YXRlLmFjY3VyYWN5ID09PSBcInN0cmljdFwiICYmIHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlICYmICFzdGF0ZS5jYXB0dXJlTWFwLmdldChyZWYpLmlnbm9yZUNhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBvZiBjYXNlLWluc2Vuc2l0aXZlIGJhY2tyZWYgdG8gY2FzZS1zZW5zaXRpdmUgZ3JvdXAgcmVxdWlyZXMgdGFyZ2V0IEVTMjAyNSBvciBub24tc3RyaWN0IGFjY3VyYWN5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXFxcXCIgKyByZWY7XG4gIH0sXG4gIC8qKlxuICBAcGFyYW0ge0NhcHR1cmluZ0dyb3VwTm9kZX0gbm9kZVxuICAqL1xuICBDYXB0dXJpbmdHcm91cChub2RlLCBzdGF0ZSwgZ2VuKSB7XG4gICAgY29uc3QgeyBib2R5LCBuYW1lLCBudW1iZXIgfSA9IG5vZGU7XG4gICAgY29uc3QgZGF0YSA9IHsgaWdub3JlQ2FzZTogc3RhdGUuY3VycmVudEZsYWdzLmlnbm9yZUNhc2UgfTtcbiAgICBjb25zdCBvcmlnaW4gPSBzdGF0ZS5vcmlnaW5NYXAuZ2V0KG5vZGUpO1xuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgIGRhdGEuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGlmIChudW1iZXIgPiBvcmlnaW4ubnVtYmVyKSB7XG4gICAgICAgIGRhdGEudHJhbnNmZXJUbyA9IG9yaWdpbi5udW1iZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmNhcHR1cmVNYXAuc2V0KG51bWJlciwgZGF0YSk7XG4gICAgcmV0dXJuIGAoJHtuYW1lID8gYD88JHtuYW1lfT5gIDogXCJcIn0ke2JvZHkubWFwKGdlbikuam9pbihcInxcIil9KWA7XG4gIH0sXG4gIC8qKlxuICBAcGFyYW0ge0NoYXJhY3Rlck5vZGV9IG5vZGVcbiAgKi9cbiAgQ2hhcmFjdGVyKHsgdmFsdWUgfSwgc3RhdGUpIHtcbiAgICBjb25zdCBjaGFyID0gY3AodmFsdWUpO1xuICAgIGNvbnN0IGVzY2FwZWQgPSBnZXRDaGFyRXNjYXBlKHZhbHVlLCB7XG4gICAgICBlc2NEaWdpdDogc3RhdGUubGFzdE5vZGUudHlwZSA9PT0gXCJCYWNrcmVmZXJlbmNlXCIsXG4gICAgICBpbkNoYXJDbGFzczogc3RhdGUuaW5DaGFyQ2xhc3MsXG4gICAgICB1c2VGbGFnVjogc3RhdGUudXNlRmxhZ1ZcbiAgICB9KTtcbiAgICBpZiAoZXNjYXBlZCAhPT0gY2hhcikge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS51c2VBcHBsaWVkSWdub3JlQ2FzZSAmJiBzdGF0ZS5jdXJyZW50RmxhZ3MuaWdub3JlQ2FzZSAmJiBjaGFySGFzQ2FzZShjaGFyKSkge1xuICAgICAgY29uc3QgY2FzZXMgPSBnZXRJZ25vcmVDYXNlTWF0Y2hDaGFycyhjaGFyKTtcbiAgICAgIHJldHVybiBzdGF0ZS5pbkNoYXJDbGFzcyA/IGNhc2VzLmpvaW4oXCJcIikgOiBjYXNlcy5sZW5ndGggPiAxID8gYFske2Nhc2VzLmpvaW4oXCJcIil9XWAgOiBjYXNlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXI7XG4gIH0sXG4gIC8qKlxuICBAcGFyYW0ge0NoYXJhY3RlckNsYXNzTm9kZX0gbm9kZVxuICAqL1xuICBDaGFyYWN0ZXJDbGFzcyhub2RlLCBzdGF0ZSwgZ2VuKSB7XG4gICAgY29uc3QgeyBraW5kLCBuZWdhdGUsIHBhcmVudCB9ID0gbm9kZTtcbiAgICBsZXQgeyBib2R5IH0gPSBub2RlO1xuICAgIGlmIChraW5kID09PSBcImludGVyc2VjdGlvblwiICYmICFzdGF0ZS51c2VGbGFnVikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIG9mIGNoYXJhY3RlciBjbGFzcyBpbnRlcnNlY3Rpb24gcmVxdWlyZXMgbWluIHRhcmdldCBFUzIwMjRcIik7XG4gICAgfVxuICAgIGlmIChlbnZGbGFncy5idWdGbGFnVkxpdGVyYWxIeXBoZW5Jc1JhbmdlICYmIHN0YXRlLnVzZUZsYWdWICYmIGJvZHkuc29tZShpc0xpdGVyYWxIeXBoZW4pKSB7XG4gICAgICBib2R5ID0gW2NyZWF0ZUNoYXJhY3RlcjIoNDUpLCAuLi5ib2R5LmZpbHRlcigoa2lkKSA9PiAhaXNMaXRlcmFsSHlwaGVuKGtpZCkpXTtcbiAgICB9XG4gICAgY29uc3QgZ2VuQ2xhc3MgPSAoKSA9PiBgWyR7bmVnYXRlID8gXCJeXCIgOiBcIlwifSR7Ym9keS5tYXAoZ2VuKS5qb2luKGtpbmQgPT09IFwiaW50ZXJzZWN0aW9uXCIgPyBcIiYmXCIgOiBcIlwiKX1dYDtcbiAgICBpZiAoIXN0YXRlLmluQ2hhckNsYXNzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIEFscmVhZHkgZXN0YWJsaXNoZWQgYGtpbmQgIT09ICdpbnRlcnNlY3Rpb24nYCBpZiBgIXN0YXRlLnVzZUZsYWdWYDsgZG9uJ3QgY2hlY2sgYWdhaW5cbiAgICAgICAgKCFzdGF0ZS51c2VGbGFnViB8fCBlbnZGbGFncy5idWdOZXN0ZWRDbGFzc0lnbm9yZXNOZWdhdGlvbikgJiYgIW5lZ2F0ZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG5lZ2F0ZWRDaGlsZENsYXNzZXMgPSBib2R5LmZpbHRlcihcbiAgICAgICAgICAoa2lkKSA9PiBraWQudHlwZSA9PT0gXCJDaGFyYWN0ZXJDbGFzc1wiICYmIGtpZC5raW5kID09PSBcInVuaW9uXCIgJiYga2lkLm5lZ2F0ZVxuICAgICAgICApO1xuICAgICAgICBpZiAobmVnYXRlZENoaWxkQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBncm91cCA9IGNyZWF0ZUdyb3VwMigpO1xuICAgICAgICAgIGNvbnN0IGdyb3VwRmlyc3RBbHQgPSBncm91cC5ib2R5WzBdO1xuICAgICAgICAgIGdyb3VwLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICBncm91cEZpcnN0QWx0LnBhcmVudCA9IGdyb3VwO1xuICAgICAgICAgIGJvZHkgPSBib2R5LmZpbHRlcigoa2lkKSA9PiAhbmVnYXRlZENoaWxkQ2xhc3Nlcy5pbmNsdWRlcyhraWQpKTtcbiAgICAgICAgICBub2RlLmJvZHkgPSBib2R5O1xuICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBncm91cEZpcnN0QWx0O1xuICAgICAgICAgICAgZ3JvdXBGaXJzdEFsdC5ib2R5LnB1c2gobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwLmJvZHkucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZ2F0ZWRDaGlsZENsYXNzZXMuZm9yRWFjaCgoY2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FsdCA9IGNyZWF0ZUFsdGVybmF0aXZlMih7IGJvZHk6IFtjY10gfSk7XG4gICAgICAgICAgICBjYy5wYXJlbnQgPSBuZXdBbHQ7XG4gICAgICAgICAgICBuZXdBbHQucGFyZW50ID0gZ3JvdXA7XG4gICAgICAgICAgICBncm91cC5ib2R5LnB1c2gobmV3QWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZ2VuKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuaW5DaGFyQ2xhc3MgPSB0cnVlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2VuQ2xhc3MoKTtcbiAgICAgIHN0YXRlLmluQ2hhckNsYXNzID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEVsID0gYm9keVswXTtcbiAgICBpZiAoXG4gICAgICAvLyBBbHJlYWR5IGVzdGFibGlzaGVkIHRoYXQgdGhlIHBhcmVudCBpcyBhIGNoYXIgY2xhc3MgdmlhIGBpbkNoYXJDbGFzc2A7IGRvbid0IGNoZWNrIGFnYWluXG4gICAgICBraW5kID09PSBcInVuaW9uXCIgJiYgIW5lZ2F0ZSAmJiBmaXJzdEVsICYmIC8vIEFsbG93cyBtYW55IG5lc3RlZCBjbGFzc2VzIHRvIHdvcmsgd2l0aCBgdGFyZ2V0YCBFUzIwMTggd2hpY2ggZG9lc24ndCBzdXBwb3J0IG5lc3RpbmdcbiAgICAgICgoIXN0YXRlLnVzZUZsYWdWIHx8ICFzdGF0ZS52ZXJib3NlKSAmJiBwYXJlbnQua2luZCA9PT0gXCJ1bmlvblwiICYmICEoZW52RmxhZ3MuYnVnRmxhZ1ZMaXRlcmFsSHlwaGVuSXNSYW5nZSAmJiBzdGF0ZS51c2VGbGFnVikgfHwgIXN0YXRlLnZlcmJvc2UgJiYgcGFyZW50LmtpbmQgPT09IFwiaW50ZXJzZWN0aW9uXCIgJiYgLy8gSlMgZG9lc24ndCBhbGxvdyBpbnRlcnNlY3Rpb24gd2l0aCB1bmlvbiBvciByYW5nZXNcbiAgICAgIGJvZHkubGVuZ3RoID09PSAxICYmIGZpcnN0RWwudHlwZSAhPT0gXCJDaGFyYWN0ZXJDbGFzc1JhbmdlXCIpXG4gICAgKSB7XG4gICAgICByZXR1cm4gYm9keS5tYXAoZ2VuKS5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLnVzZUZsYWdWICYmIHBhcmVudC50eXBlID09PSBcIkNoYXJhY3RlckNsYXNzXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXMgbmVzdGVkIGNoYXJhY3RlciBjbGFzcyBpbiBhIHdheSB0aGF0IHJlcXVpcmVzIG1pbiB0YXJnZXQgRVMyMDI0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuQ2xhc3MoKTtcbiAgfSxcbiAgLyoqXG4gIEBwYXJhbSB7Q2hhcmFjdGVyQ2xhc3NSYW5nZU5vZGV9IG5vZGVcbiAgKi9cbiAgQ2hhcmFjdGVyQ2xhc3NSYW5nZShub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG1pbiA9IG5vZGUubWluLnZhbHVlO1xuICAgIGNvbnN0IG1heCA9IG5vZGUubWF4LnZhbHVlO1xuICAgIGNvbnN0IGVzY09wdHMgPSB7XG4gICAgICBlc2NEaWdpdDogZmFsc2UsXG4gICAgICBpbkNoYXJDbGFzczogdHJ1ZSxcbiAgICAgIHVzZUZsYWdWOiBzdGF0ZS51c2VGbGFnVlxuICAgIH07XG4gICAgY29uc3QgbWluU3RyID0gZ2V0Q2hhckVzY2FwZShtaW4sIGVzY09wdHMpO1xuICAgIGNvbnN0IG1heFN0ciA9IGdldENoYXJFc2NhcGUobWF4LCBlc2NPcHRzKTtcbiAgICBjb25zdCBleHRyYUNoYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBpZiAoc3RhdGUudXNlQXBwbGllZElnbm9yZUNhc2UgJiYgc3RhdGUuY3VycmVudEZsYWdzLmlnbm9yZUNhc2UpIHtcbiAgICAgIGNvbnN0IGNoYXJzT3V0c2lkZVJhbmdlID0gZ2V0Q2FzZXNPdXRzaWRlQ2hhckNsYXNzUmFuZ2Uobm9kZSk7XG4gICAgICBjb25zdCByYW5nZXMgPSBnZXRDb2RlUG9pbnRSYW5nZXNGcm9tQ2hhcnMoY2hhcnNPdXRzaWRlUmFuZ2UpO1xuICAgICAgcmFuZ2VzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIGV4dHJhQ2hhcnMuYWRkKFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYCR7Z2V0Q2hhckVzY2FwZSh2YWx1ZVswXSwgZXNjT3B0cyl9LSR7Z2V0Q2hhckVzY2FwZSh2YWx1ZVsxXSwgZXNjT3B0cyl9YCA6IGdldENoYXJFc2NhcGUodmFsdWUsIGVzY09wdHMpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGAke21pblN0cn0tJHttYXhTdHJ9JHtbLi4uZXh0cmFDaGFyc10uam9pbihcIlwiKX1gO1xuICB9LFxuICAvKipcbiAgQHBhcmFtIHtDaGFyYWN0ZXJTZXROb2RlfSBub2RlXG4gICovXG4gIENoYXJhY3RlclNldCh7IGtpbmQsIG5lZ2F0ZSwgdmFsdWUsIGtleSB9LCBzdGF0ZSkge1xuICAgIGlmIChraW5kID09PSBcImRvdFwiKSB7XG4gICAgICByZXR1cm4gc3RhdGUuY3VycmVudEZsYWdzLmRvdEFsbCA/IHN0YXRlLmFwcGxpZWRHbG9iYWxGbGFncy5kb3RBbGwgfHwgc3RhdGUudXNlRmxhZ01vZHMgPyBcIi5cIiA6IFwiW15dXCIgOiAoXG4gICAgICAgIC8vIE9uaWcncyBvbmx5IGxpbmUgYnJlYWsgY2hhciBpcyBsaW5lIGZlZWQsIHVubGlrZSBKU1xuICAgICAgICByYFteXFxuXWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChraW5kID09PSBcImRpZ2l0XCIpIHtcbiAgICAgIHJldHVybiBuZWdhdGUgPyByYFxcRGAgOiByYFxcZGA7XG4gICAgfVxuICAgIGlmIChraW5kID09PSBcInByb3BlcnR5XCIpIHtcbiAgICAgIGlmIChzdGF0ZS51c2VBcHBsaWVkSWdub3JlQ2FzZSAmJiBzdGF0ZS5jdXJyZW50RmxhZ3MuaWdub3JlQ2FzZSAmJiBVbmljb2RlUHJvcGVydGllc1dpdGhTcGVjaWZpY0Nhc2UuaGFzKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWNvZGUgcHJvcGVydHkgXCIke3ZhbHVlfVwiIGNhbid0IGJlIGNhc2UtaW5zZW5zaXRpdmUgd2hlbiBvdGhlciBjaGFycyBoYXZlIHNwZWNpZmljIGNhc2VgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHtuZWdhdGUgPyByYFxcUGAgOiByYFxccGB9eyR7a2V5ID8gYCR7a2V5fT1gIDogXCJcIn0ke3ZhbHVlfX1gO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gXCJ3b3JkXCIpIHtcbiAgICAgIHJldHVybiBuZWdhdGUgPyByYFxcV2AgOiByYFxcd2A7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgc2V0IGtpbmQgXCIke2tpbmR9XCJgKTtcbiAgfSxcbiAgLyoqXG4gIEBwYXJhbSB7RmxhZ3NOb2RlfSBub2RlXG4gICovXG4gIEZsYWdzKG5vZGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIFRoZSB0cmFuc2Zvcm1lciBzaG91bGQgbmV2ZXIgdHVybiBvbiB0aGUgcHJvcGVydGllcyBmb3IgZmxhZ3MgZCwgZywgbSBzaW5jZSBPbmlnIGRvZXNuJ3RcbiAgICAgIC8vIGhhdmUgZXF1aXZzLiBGbGFnIG0gaXMgbmV2ZXIgdXNlZCBzaW5jZSBPbmlnIHVzZXMgZGlmZmVyZW50IGxpbmUgYnJlYWsgY2hhcnMgdGhhbiBKU1xuICAgICAgLy8gKG5vZGUuaGFzSW5kaWNlcyA/ICdkJyA6ICcnKSArXG4gICAgICAvLyAobm9kZS5nbG9iYWwgPyAnZycgOiAnJykgK1xuICAgICAgLy8gKG5vZGUubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgIChzdGF0ZS5hcHBsaWVkR2xvYmFsRmxhZ3MuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAobm9kZS5kb3RBbGwgPyBcInNcIiA6IFwiXCIpICsgKG5vZGUuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKVxuICAgICk7XG4gIH0sXG4gIC8qKlxuICBAcGFyYW0ge0dyb3VwTm9kZX0gbm9kZVxuICAqL1xuICBHcm91cCh7IGF0b21pYzogYXRvbWljMiwgYm9keSwgZmxhZ3MsIHBhcmVudCB9LCBzdGF0ZSwgZ2VuKSB7XG4gICAgY29uc3QgY3VycmVudEZsYWdzID0gc3RhdGUuY3VycmVudEZsYWdzO1xuICAgIGlmIChmbGFncykge1xuICAgICAgc3RhdGUuY3VycmVudEZsYWdzID0gZ2V0TmV3Q3VycmVudEZsYWdzKGN1cnJlbnRGbGFncywgZmxhZ3MpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50cyA9IGJvZHkubWFwKGdlbikuam9pbihcInxcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gIXN0YXRlLnZlcmJvc2UgJiYgYm9keS5sZW5ndGggPT09IDEgJiYgLy8gU2luZ2xlIGFsdFxuICAgIHBhcmVudC50eXBlICE9PSBcIlF1YW50aWZpZXJcIiAmJiAhYXRvbWljMiAmJiAoIXN0YXRlLnVzZUZsYWdNb2RzIHx8ICFmbGFncykgPyBjb250ZW50cyA6IGAoPyR7Z2V0R3JvdXBQcmVmaXgoYXRvbWljMiwgZmxhZ3MsIHN0YXRlLnVzZUZsYWdNb2RzKX0ke2NvbnRlbnRzfSlgO1xuICAgIHN0YXRlLmN1cnJlbnRGbGFncyA9IGN1cnJlbnRGbGFncztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAvKipcbiAgQHBhcmFtIHtMb29rYXJvdW5kQXNzZXJ0aW9uTm9kZX0gbm9kZVxuICAqL1xuICBMb29rYXJvdW5kQXNzZXJ0aW9uKHsgYm9keSwga2luZCwgbmVnYXRlIH0sIF8sIGdlbikge1xuICAgIGNvbnN0IHByZWZpeCA9IGAke2tpbmQgPT09IFwibG9va2FoZWFkXCIgPyBcIlwiIDogXCI8XCJ9JHtuZWdhdGUgPyBcIiFcIiA6IFwiPVwifWA7XG4gICAgcmV0dXJuIGAoPyR7cHJlZml4fSR7Ym9keS5tYXAoZ2VuKS5qb2luKFwifFwiKX0pYDtcbiAgfSxcbiAgLyoqXG4gIEBwYXJhbSB7UXVhbnRpZmllck5vZGV9IG5vZGVcbiAgKi9cbiAgUXVhbnRpZmllcihub2RlLCBfLCBnZW4pIHtcbiAgICByZXR1cm4gZ2VuKG5vZGUuYm9keSkgKyBnZXRRdWFudGlmaWVyU3RyKG5vZGUpO1xuICB9LFxuICAvKipcbiAgQHBhcmFtIHtTdWJyb3V0aW5lTm9kZSAmIHtpc1JlY3Vyc2l2ZTogdHJ1ZX19IG5vZGVcbiAgKi9cbiAgU3Vicm91dGluZSh7IGlzUmVjdXJzaXZlLCByZWYgfSwgc3RhdGUpIHtcbiAgICBpZiAoIWlzUmVjdXJzaXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vbi1yZWN1cnNpdmUgc3Vicm91dGluZSBpbiB0cmFuc2Zvcm1lZCBBU1RcIik7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gc3RhdGUucmVjdXJzaW9uTGltaXQ7XG4gICAgcmV0dXJuIHJlZiA9PT0gMCA/IGAoP1I9JHtsaW1pdH0pYCA6IHJgXFxnPCR7cmVmfSZSPSR7bGltaXR9PmA7XG4gIH1cbn07XG52YXIgQmFzZUVzY2FwZUNoYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIiRcIixcbiAgXCIoXCIsXG4gIFwiKVwiLFxuICBcIipcIixcbiAgXCIrXCIsXG4gIFwiLlwiLFxuICBcIj9cIixcbiAgXCJbXCIsXG4gIFwiXFxcXFwiLFxuICBcIl1cIixcbiAgXCJeXCIsXG4gIFwie1wiLFxuICBcInxcIixcbiAgXCJ9XCJcbl0pO1xudmFyIENoYXJDbGFzc0VzY2FwZUNoYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIi1cIixcbiAgXCJcXFxcXCIsXG4gIFwiXVwiLFxuICBcIl5cIixcbiAgLy8gTGl0ZXJhbCBgW2AgZG9lc24ndCByZXF1aXJlIGVzY2FwaW5nIHdpdGggZmxhZyB1LCBidXQgdGhpcyBjYW4gaGVscCB3b3JrIGFyb3VuZCByZWdleCBzb3VyY2VcbiAgLy8gbGludGVycyBhbmQgcmVnZXggc3ludGF4IHByb2Nlc3NvcnMgdGhhdCBleHBlY3QgdW5lc2NhcGVkIGBbYCB0byBjcmVhdGUgYSBuZXN0ZWQgY2xhc3NcbiAgXCJbXCJcbl0pO1xudmFyIENoYXJDbGFzc0VzY2FwZUNoYXJzRmxhZ1YgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiKFwiLFxuICBcIilcIixcbiAgXCItXCIsXG4gIFwiL1wiLFxuICBcIltcIixcbiAgXCJcXFxcXCIsXG4gIFwiXVwiLFxuICBcIl5cIixcbiAgXCJ7XCIsXG4gIFwifFwiLFxuICBcIn1cIixcbiAgLy8gRG91YmxlIHB1bmN0dWF0b3JzOyBhbHNvIGluY2x1ZGVzIGFscmVhZHktbGlzdGVkIGAtYCBhbmQgYF5gXG4gIFwiIVwiLFxuICBcIiNcIixcbiAgXCIkXCIsXG4gIFwiJVwiLFxuICBcIiZcIixcbiAgXCIqXCIsXG4gIFwiK1wiLFxuICBcIixcIixcbiAgXCIuXCIsXG4gIFwiOlwiLFxuICBcIjtcIixcbiAgXCI8XCIsXG4gIFwiPVwiLFxuICBcIj5cIixcbiAgXCI/XCIsXG4gIFwiQFwiLFxuICBcImBcIixcbiAgXCJ+XCJcbl0pO1xudmFyIENoYXJDb2RlRXNjYXBlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbOSwgcmBcXHRgXSxcbiAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgWzEwLCByYFxcbmBdLFxuICAvLyBsaW5lIGZlZWRcbiAgWzExLCByYFxcdmBdLFxuICAvLyB2ZXJ0aWNhbCB0YWJcbiAgWzEyLCByYFxcZmBdLFxuICAvLyBmb3JtIGZlZWRcbiAgWzEzLCByYFxccmBdLFxuICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgWzgyMzIsIHJgXFx1MjAyOGBdLFxuICAvLyBsaW5lIHNlcGFyYXRvclxuICBbODIzMywgcmBcXHUyMDI5YF0sXG4gIC8vIHBhcmFncmFwaCBzZXBhcmF0b3JcbiAgWzY1Mjc5LCByYFxcdUZFRkZgXVxuICAvLyBaV05CU1AvQk9NXG5dKTtcbnZhciBjYXNlZFJlID0gL15cXHB7Q2FzZWR9JC91O1xuZnVuY3Rpb24gY2hhckhhc0Nhc2UoY2hhcikge1xuICByZXR1cm4gY2FzZWRSZS50ZXN0KGNoYXIpO1xufVxuZnVuY3Rpb24gZ2V0Q2FzZXNPdXRzaWRlQ2hhckNsYXNzUmFuZ2Uobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBmaXJzdE9ubHkgPSAhIW9wdGlvbnM/LmZpcnN0T25seTtcbiAgY29uc3QgbWluID0gbm9kZS5taW4udmFsdWU7XG4gIGNvbnN0IG1heCA9IG5vZGUubWF4LnZhbHVlO1xuICBjb25zdCBmb3VuZCA9IFtdO1xuICBpZiAobWluIDwgNjUgJiYgKG1heCA9PT0gNjU1MzUgfHwgbWF4ID49IDEzMTA3MSkgfHwgbWluID09PSA2NTUzNiAmJiBtYXggPj0gMTMxMDcxKSB7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGZvciAobGV0IGkgPSBtaW47IGkgPD0gbWF4OyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gY3AoaSk7XG4gICAgaWYgKCFjaGFySGFzQ2FzZShjaGFyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzT3V0c2lkZVJhbmdlID0gZ2V0SWdub3JlQ2FzZU1hdGNoQ2hhcnMoY2hhcikuZmlsdGVyKChjYXNlT2ZDaGFyKSA9PiB7XG4gICAgICBjb25zdCBudW0gPSBjYXNlT2ZDaGFyLmNvZGVQb2ludEF0KDApO1xuICAgICAgcmV0dXJuIG51bSA8IG1pbiB8fCBudW0gPiBtYXg7XG4gICAgfSk7XG4gICAgaWYgKGNoYXJzT3V0c2lkZVJhbmdlLmxlbmd0aCkge1xuICAgICAgZm91bmQucHVzaCguLi5jaGFyc091dHNpZGVSYW5nZSk7XG4gICAgICBpZiAoZmlyc3RPbmx5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBnZXRDaGFyRXNjYXBlKGNvZGVQb2ludCwgeyBlc2NEaWdpdCwgaW5DaGFyQ2xhc3MsIHVzZUZsYWdWIH0pIHtcbiAgaWYgKENoYXJDb2RlRXNjYXBlTWFwLmhhcyhjb2RlUG9pbnQpKSB7XG4gICAgcmV0dXJuIENoYXJDb2RlRXNjYXBlTWFwLmdldChjb2RlUG9pbnQpO1xuICB9XG4gIGlmIChcbiAgICAvLyBDb250cm9sIGNoYXJzLCBldGMuOyBjb25kaXRpb24gbW9kZWxlZCBvbiB0aGUgQ2hyb21lIGRldmVsb3BlciBjb25zb2xlJ3MgZGlzcGxheSBmb3Igc3RyaW5nc1xuICAgIGNvZGVQb2ludCA8IDMyIHx8IGNvZGVQb2ludCA+IDEyNiAmJiBjb2RlUG9pbnQgPCAxNjAgfHwgLy8gVW5pY29kZSBwbGFuZXMgNC0xNjsgdW5hc3NpZ25lZCwgc3BlY2lhbCBwdXJwb3NlLCBhbmQgcHJpdmF0ZSB1c2UgYXJlYVxuICAgIGNvZGVQb2ludCA+IDI2MjE0MyB8fCAvLyBBdm9pZCBjb3JydXB0aW5nIGEgcHJlY2VkaW5nIGJhY2tyZWYgYnkgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGl0IHdpdGggYSBsaXRlcmFsIGRpZ2l0XG4gICAgZXNjRGlnaXQgJiYgaXNEaWdpdENoYXJDb2RlKGNvZGVQb2ludClcbiAgKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludCA+IDI1NSA/IGBcXFxcdXske2NvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX19YCA6IGBcXFxceCR7Y29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsIFwiMFwiKX1gO1xuICB9XG4gIGNvbnN0IGVzY2FwZUNoYXJzID0gaW5DaGFyQ2xhc3MgPyB1c2VGbGFnViA/IENoYXJDbGFzc0VzY2FwZUNoYXJzRmxhZ1YgOiBDaGFyQ2xhc3NFc2NhcGVDaGFycyA6IEJhc2VFc2NhcGVDaGFycztcbiAgY29uc3QgY2hhciA9IGNwKGNvZGVQb2ludCk7XG4gIHJldHVybiAoZXNjYXBlQ2hhcnMuaGFzKGNoYXIpID8gXCJcXFxcXCIgOiBcIlwiKSArIGNoYXI7XG59XG5mdW5jdGlvbiBnZXRDb2RlUG9pbnRSYW5nZXNGcm9tQ2hhcnMoY2hhcnMpIHtcbiAgY29uc3QgY29kZVBvaW50cyA9IGNoYXJzLm1hcCgoY2hhcikgPT4gY2hhci5jb2RlUG9pbnRBdCgwKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvZGVQb2ludHNbaSArIDFdID09PSBjb2RlUG9pbnRzW2ldICsgMSkge1xuICAgICAgc3RhcnQgPz89IGNvZGVQb2ludHNbaV07XG4gICAgfSBlbHNlIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgdmFsdWVzLnB1c2goY29kZVBvaW50c1tpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcy5wdXNoKFtzdGFydCwgY29kZVBvaW50c1tpXV0pO1xuICAgICAgc3RhcnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0R3JvdXBQcmVmaXgoYXRvbWljMiwgZmxhZ01vZHMsIHVzZUZsYWdNb2RzKSB7XG4gIGlmIChhdG9taWMyKSB7XG4gICAgcmV0dXJuIFwiPlwiO1xuICB9XG4gIGxldCBtb2RzID0gXCJcIjtcbiAgaWYgKGZsYWdNb2RzICYmIHVzZUZsYWdNb2RzKSB7XG4gICAgY29uc3QgeyBlbmFibGUsIGRpc2FibGUgfSA9IGZsYWdNb2RzO1xuICAgIG1vZHMgPSAoZW5hYmxlPy5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChlbmFibGU/LmRvdEFsbCA/IFwic1wiIDogXCJcIikgKyAoZGlzYWJsZSA/IFwiLVwiIDogXCJcIikgKyAoZGlzYWJsZT8uaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoZGlzYWJsZT8uZG90QWxsID8gXCJzXCIgOiBcIlwiKTtcbiAgfVxuICByZXR1cm4gYCR7bW9kc306YDtcbn1cbmZ1bmN0aW9uIGdldFF1YW50aWZpZXJTdHIoeyBraW5kLCBtYXgsIG1pbiB9KSB7XG4gIGxldCBiYXNlO1xuICBpZiAoIW1pbiAmJiBtYXggPT09IDEpIHtcbiAgICBiYXNlID0gXCI/XCI7XG4gIH0gZWxzZSBpZiAoIW1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgYmFzZSA9IFwiKlwiO1xuICB9IGVsc2UgaWYgKG1pbiA9PT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgYmFzZSA9IFwiK1wiO1xuICB9IGVsc2UgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgYmFzZSA9IGB7JHttaW59fWA7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IGB7JHttaW59LCR7bWF4ID09PSBJbmZpbml0eSA/IFwiXCIgOiBtYXh9fWA7XG4gIH1cbiAgcmV0dXJuIGJhc2UgKyB7XG4gICAgZ3JlZWR5OiBcIlwiLFxuICAgIGxhenk6IFwiP1wiLFxuICAgIHBvc3Nlc3NpdmU6IFwiK1wiXG4gIH1ba2luZF07XG59XG5mdW5jdGlvbiBpc0FueUdyb3VwKHsgdHlwZSB9KSB7XG4gIHJldHVybiB0eXBlID09PSBcIkNhcHR1cmluZ0dyb3VwXCIgfHwgdHlwZSA9PT0gXCJHcm91cFwiIHx8IHR5cGUgPT09IFwiTG9va2Fyb3VuZEFzc2VydGlvblwiO1xufVxuZnVuY3Rpb24gaXNEaWdpdENoYXJDb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA+IDQ3ICYmIHZhbHVlIDwgNTg7XG59XG5mdW5jdGlvbiBpc0xpdGVyYWxIeXBoZW4oeyB0eXBlLCB2YWx1ZSB9KSB7XG4gIHJldHVybiB0eXBlID09PSBcIkNoYXJhY3RlclwiICYmIHZhbHVlID09PSA0NTtcbn1cblxuLy8gc3JjL3N1YmNsYXNzLmpzXG52YXIgRW11bGF0ZWRSZWdFeHAgPSBjbGFzcyBfRW11bGF0ZWRSZWdFeHAgZXh0ZW5kcyBSZWdFeHAge1xuICAvKipcbiAgQHR5cGUge01hcDxudW1iZXIsIHtcbiAgICBoaWRkZW4/OiB0cnVlO1xuICAgIHRyYW5zZmVyVG8/OiBudW1iZXI7XG4gIH0+fVxuICAqL1xuICAjY2FwdHVyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICBAdHlwZSB7UmVnRXhwIHwgRW11bGF0ZWRSZWdFeHAgfCBudWxsfVxuICAqL1xuICAjY29tcGlsZWQgPSBudWxsO1xuICAvKipcbiAgQHR5cGUge3N0cmluZ31cbiAgKi9cbiAgI3BhdHRlcm47XG4gIC8qKlxuICBAdHlwZSB7TWFwPG51bWJlciwgc3RyaW5nPj99XG4gICovXG4gICNuYW1lTWFwID0gbnVsbDtcbiAgLyoqXG4gIEB0eXBlIHtzdHJpbmc/fVxuICAqL1xuICAjc3RyYXRlZ3kgPSBudWxsO1xuICAvKipcbiAgQ2FuIGJlIHVzZWQgdG8gc2VyaWFsaXplIHRoZSBpbnN0YW5jZS5cbiAgQHR5cGUge0VtdWxhdGVkUmVnRXhwT3B0aW9uc31cbiAgKi9cbiAgcmF3T3B0aW9ucyA9IHt9O1xuICAvLyBPdmVycmlkZSB0aGUgZ2V0dGVyIHdpdGggb25lIHRoYXQgd29ya3Mgd2l0aCBsYXp5LWNvbXBpbGVkIHJlZ2V4ZXNcbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcGF0dGVybiB8fCBcIig/OilcIjtcbiAgfVxuICAvKipcbiAgQG92ZXJsb2FkXG4gIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gIEBwYXJhbSB7RW11bGF0ZWRSZWdFeHBPcHRpb25zfSBbb3B0aW9uc11cbiAgKi9cbiAgLyoqXG4gIEBvdmVybG9hZFxuICBAcGFyYW0ge0VtdWxhdGVkUmVnRXhwfSBwYXR0ZXJuXG4gIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICovXG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4sIGZsYWdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGF6eUNvbXBpbGUgPSAhIW9wdGlvbnM/LmxhenlDb21waWxlO1xuICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHJvdmlkZSBvcHRpb25zIHdoZW4gY29weWluZyBhIHJlZ2V4cFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlID0gcGF0dGVybjtcbiAgICAgIHN1cGVyKHJlLCBmbGFncyk7XG4gICAgICB0aGlzLiNwYXR0ZXJuID0gcmUuc291cmNlO1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgX0VtdWxhdGVkUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuI2NhcHR1cmVNYXAgPSByZS4jY2FwdHVyZU1hcDtcbiAgICAgICAgdGhpcy4jbmFtZU1hcCA9IHJlLiNuYW1lTWFwO1xuICAgICAgICB0aGlzLiNzdHJhdGVneSA9IHJlLiNzdHJhdGVneTtcbiAgICAgICAgdGhpcy5yYXdPcHRpb25zID0gcmUucmF3T3B0aW9ucztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgaGlkZGVuQ2FwdHVyZXM6IFtdLFxuICAgICAgICBzdHJhdGVneTogbnVsbCxcbiAgICAgICAgdHJhbnNmZXJzOiBbXSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHN1cGVyKGxhenlDb21waWxlID8gXCJcIiA6IHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIHRoaXMuI3BhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgdGhpcy4jY2FwdHVyZU1hcCA9IGNyZWF0ZUNhcHR1cmVNYXAob3B0cy5oaWRkZW5DYXB0dXJlcywgb3B0cy50cmFuc2ZlcnMpO1xuICAgICAgdGhpcy4jc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5O1xuICAgICAgdGhpcy5yYXdPcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcbiAgICB9XG4gICAgaWYgKCFsYXp5Q29tcGlsZSkge1xuICAgICAgdGhpcy4jY29tcGlsZWQgPSB0aGlzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgQ2FsbGVkIGludGVybmFsbHkgYnkgYWxsIFN0cmluZy9SZWdFeHAgbWV0aG9kcyB0aGF0IHVzZSByZWdleGVzLlxuICBAb3ZlcnJpZGVcbiAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICBAcmV0dXJucyB7UmVnRXhwRXhlY0FycmF5P31cbiAgKi9cbiAgZXhlYyhzdHIpIHtcbiAgICBpZiAoIXRoaXMuI2NvbXBpbGVkKSB7XG4gICAgICBjb25zdCB7IGxhenlDb21waWxlLCAuLi5yZXN0IH0gPSB0aGlzLnJhd09wdGlvbnM7XG4gICAgICB0aGlzLiNjb21waWxlZCA9IG5ldyBfRW11bGF0ZWRSZWdFeHAodGhpcy4jcGF0dGVybiwgdGhpcy5mbGFncywgcmVzdCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZUxhc3RJbmRleCA9IHRoaXMuZ2xvYmFsIHx8IHRoaXMuc3RpY2t5O1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubGFzdEluZGV4O1xuICAgIGlmICh0aGlzLiNzdHJhdGVneSA9PT0gXCJjbGlwX3NlYXJjaFwiICYmIHVzZUxhc3RJbmRleCAmJiBwb3MpIHtcbiAgICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy4jZXhlY0NvcmUoc3RyLnNsaWNlKHBvcykpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGFkanVzdE1hdGNoRGV0YWlsc0Zvck9mZnNldChtYXRjaCwgcG9zLCBzdHIsIHRoaXMuaGFzSW5kaWNlcyk7XG4gICAgICAgIHRoaXMubGFzdEluZGV4ICs9IHBvcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2V4ZWNDb3JlKHN0cik7XG4gIH1cbiAgLyoqXG4gIEFkZHMgc3VwcG9ydCBmb3IgaGlkZGVuIGFuZCB0cmFuc2ZlciBjYXB0dXJlcy5cbiAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICBAcmV0dXJuc1xuICAqL1xuICAjZXhlY0NvcmUoc3RyKSB7XG4gICAgdGhpcy4jY29tcGlsZWQubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgY29uc3QgbWF0Y2ggPSBzdXBlci5leGVjLmNhbGwodGhpcy4jY29tcGlsZWQsIHN0cik7XG4gICAgdGhpcy5sYXN0SW5kZXggPSB0aGlzLiNjb21waWxlZC5sYXN0SW5kZXg7XG4gICAgaWYgKCFtYXRjaCB8fCAhdGhpcy4jY2FwdHVyZU1hcC5zaXplKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoQ29weSA9IFsuLi5tYXRjaF07XG4gICAgbWF0Y2gubGVuZ3RoID0gMTtcbiAgICBsZXQgaW5kaWNlc0NvcHk7XG4gICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgaW5kaWNlc0NvcHkgPSBbLi4ubWF0Y2guaW5kaWNlc107XG4gICAgICBtYXRjaC5pbmRpY2VzLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGNvbnN0IG1hcHBlZE51bXMgPSBbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaENvcHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgaGlkZGVuLCB0cmFuc2ZlclRvIH0gPSB0aGlzLiNjYXB0dXJlTWFwLmdldChpKSA/PyB7fTtcbiAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgbWFwcGVkTnVtcy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkTnVtcy5wdXNoKG1hdGNoLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLnB1c2gobWF0Y2hDb3B5W2ldKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgICAgIG1hdGNoLmluZGljZXMucHVzaChpbmRpY2VzQ29weVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2ZlclRvICYmIG1hdGNoQ29weVtpXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHRvID0gbWFwcGVkTnVtc1t0cmFuc2ZlclRvXTtcbiAgICAgICAgaWYgKCF0bykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjYXB0dXJlIHRyYW5zZmVyIHRvIFwiJHt0b31cImApO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoW3RvXSA9IG1hdGNoQ29weVtpXTtcbiAgICAgICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgICAgIG1hdGNoLmluZGljZXNbdG9dID0gaW5kaWNlc0NvcHlbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmdyb3Vwcykge1xuICAgICAgICAgIGlmICghdGhpcy4jbmFtZU1hcCkge1xuICAgICAgICAgICAgdGhpcy4jbmFtZU1hcCA9IGNyZWF0ZU5hbWVNYXAodGhpcy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy4jbmFtZU1hcC5nZXQodHJhbnNmZXJUbyk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIG1hdGNoLmdyb3Vwc1tuYW1lXSA9IG1hdGNoQ29weVtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0luZGljZXMpIHtcbiAgICAgICAgICAgICAgbWF0Y2guaW5kaWNlcy5ncm91cHNbbmFtZV0gPSBpbmRpY2VzQ29weVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xuICB9XG59O1xuZnVuY3Rpb24gYWRqdXN0TWF0Y2hEZXRhaWxzRm9yT2Zmc2V0KG1hdGNoLCBvZmZzZXQsIGlucHV0LCBoYXNJbmRpY2VzKSB7XG4gIG1hdGNoLmluZGV4ICs9IG9mZnNldDtcbiAgbWF0Y2guaW5wdXQgPSBpbnB1dDtcbiAgaWYgKGhhc0luZGljZXMpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gbWF0Y2guaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyciA9IGluZGljZXNbaV07XG4gICAgICBpZiAoYXJyKSB7XG4gICAgICAgIGluZGljZXNbaV0gPSBbYXJyWzBdICsgb2Zmc2V0LCBhcnJbMV0gKyBvZmZzZXRdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBncm91cEluZGljZXMgPSBpbmRpY2VzLmdyb3VwcztcbiAgICBpZiAoZ3JvdXBJbmRpY2VzKSB7XG4gICAgICBPYmplY3Qua2V5cyhncm91cEluZGljZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBhcnIgPSBncm91cEluZGljZXNba2V5XTtcbiAgICAgICAgaWYgKGFycikge1xuICAgICAgICAgIGdyb3VwSW5kaWNlc1trZXldID0gW2FyclswXSArIG9mZnNldCwgYXJyWzFdICsgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlTWFwKGhpZGRlbkNhcHR1cmVzLCB0cmFuc2ZlcnMpIHtcbiAgY29uc3QgY2FwdHVyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgbnVtIG9mIGhpZGRlbkNhcHR1cmVzKSB7XG4gICAgY2FwdHVyZU1hcC5zZXQobnVtLCB7XG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IFt0bywgZnJvbV0gb2YgdHJhbnNmZXJzKSB7XG4gICAgZm9yIChjb25zdCBudW0gb2YgZnJvbSkge1xuICAgICAgZ2V0T3JJbnNlcnQoY2FwdHVyZU1hcCwgbnVtLCB7fSkudHJhbnNmZXJUbyA9IHRvO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FwdHVyZU1hcDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5hbWVNYXAocGF0dGVybikge1xuICBjb25zdCByZSA9IC8oPzxjYXB0dXJlPlxcKCg/OlxcPzwoPyFbPSFdKSg/PG5hbWU+W14+XSspPnwoPyFcXD8pKSl8XFxcXD8uL2dzdTtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDA7XG4gIGxldCBudW1DYXB0dXJlcyA9IDA7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGNvbnN0IHsgMDogbSwgZ3JvdXBzOiB7IGNhcHR1cmUsIG5hbWUgfSB9ID0gbWF0Y2g7XG4gICAgaWYgKG0gPT09IFwiW1wiKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICB9IGVsc2UgaWYgKCFudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgIG51bUNhcHR1cmVzKys7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgbWFwLnNldChudW1DYXB0dXJlcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG0gPT09IFwiXVwiKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4tLTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuLy8gc3JjL2luZGV4LmpzXG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZTIgfSBmcm9tIFwib25pZ3VydW1hLXBhcnNlci9wYXJzZXJcIjtcbmltcG9ydCB7IGF0b21pYywgcG9zc2Vzc2l2ZSB9IGZyb20gXCJyZWdleC9pbnRlcm5hbHNcIjtcbmltcG9ydCB7IHJlY3Vyc2lvbiB9IGZyb20gXCJyZWdleC1yZWN1cnNpb25cIjtcbmZ1bmN0aW9uIHRvUmVnRXhwKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgZCA9IHRvUmVnRXhwRGV0YWlscyhwYXR0ZXJuLCBvcHRpb25zKTtcbiAgaWYgKGQub3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRW11bGF0ZWRSZWdFeHAoZC5wYXR0ZXJuLCBkLmZsYWdzLCBkLm9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKGQucGF0dGVybiwgZC5mbGFncyk7XG59XG5mdW5jdGlvbiB0b1JlZ0V4cERldGFpbHMocGF0dGVybiwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3Qgb25pZ3VydW1hQXN0ID0gcGFyc2UyKHBhdHRlcm4sIHtcbiAgICBmbGFnczogb3B0cy5mbGFncyxcbiAgICBub3JtYWxpemVVbmtub3duUHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgICBydWxlczoge1xuICAgICAgY2FwdHVyZUdyb3VwOiBvcHRzLnJ1bGVzLmNhcHR1cmVHcm91cCxcbiAgICAgIHNpbmdsZWxpbmU6IG9wdHMucnVsZXMuc2luZ2xlbGluZVxuICAgIH0sXG4gICAgc2tpcEJhY2tyZWZWYWxpZGF0aW9uOiBvcHRzLnJ1bGVzLmFsbG93T3JwaGFuQmFja3JlZnMsXG4gICAgdW5pY29kZVByb3BlcnR5TWFwOiBKc1VuaWNvZGVQcm9wZXJ0eU1hcFxuICB9KTtcbiAgY29uc3QgcmVnZXhQbHVzQXN0ID0gdHJhbnNmb3JtKG9uaWd1cnVtYUFzdCwge1xuICAgIGFjY3VyYWN5OiBvcHRzLmFjY3VyYWN5LFxuICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IG9wdHMucnVsZXMuYXNjaWlXb3JkQm91bmRhcmllcyxcbiAgICBhdm9pZFN1YmNsYXNzOiBvcHRzLmF2b2lkU3ViY2xhc3MsXG4gICAgYmVzdEVmZm9ydFRhcmdldDogb3B0cy50YXJnZXRcbiAgfSk7XG4gIGNvbnN0IGdlbmVyYXRlZCA9IGdlbmVyYXRlKHJlZ2V4UGx1c0FzdCwgb3B0cyk7XG4gIGNvbnN0IHJlY3Vyc2lvblJlc3VsdCA9IHJlY3Vyc2lvbihnZW5lcmF0ZWQucGF0dGVybiwge1xuICAgIGNhcHR1cmVUcmFuc2ZlcnM6IGdlbmVyYXRlZC5fY2FwdHVyZVRyYW5zZmVycyxcbiAgICBoaWRkZW5DYXB0dXJlczogZ2VuZXJhdGVkLl9oaWRkZW5DYXB0dXJlcyxcbiAgICBtb2RlOiBcImV4dGVybmFsXCJcbiAgfSk7XG4gIGNvbnN0IHBvc3Nlc3NpdmVSZXN1bHQgPSBwb3NzZXNzaXZlKHJlY3Vyc2lvblJlc3VsdC5wYXR0ZXJuKTtcbiAgY29uc3QgYXRvbWljUmVzdWx0ID0gYXRvbWljKHBvc3Nlc3NpdmVSZXN1bHQucGF0dGVybiwge1xuICAgIGNhcHR1cmVUcmFuc2ZlcnM6IHJlY3Vyc2lvblJlc3VsdC5jYXB0dXJlVHJhbnNmZXJzLFxuICAgIGhpZGRlbkNhcHR1cmVzOiByZWN1cnNpb25SZXN1bHQuaGlkZGVuQ2FwdHVyZXNcbiAgfSk7XG4gIGNvbnN0IGRldGFpbHMgPSB7XG4gICAgcGF0dGVybjogYXRvbWljUmVzdWx0LnBhdHRlcm4sXG4gICAgZmxhZ3M6IGAke29wdHMuaGFzSW5kaWNlcyA/IFwiZFwiIDogXCJcIn0ke29wdHMuZ2xvYmFsID8gXCJnXCIgOiBcIlwifSR7Z2VuZXJhdGVkLmZsYWdzfSR7Z2VuZXJhdGVkLm9wdGlvbnMuZGlzYWJsZS52ID8gXCJ1XCIgOiBcInZcIn1gXG4gIH07XG4gIGlmIChvcHRzLmF2b2lkU3ViY2xhc3MpIHtcbiAgICBpZiAob3B0cy5sYXp5Q29tcGlsZUxlbmd0aCAhPT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhenkgY29tcGlsYXRpb24gcmVxdWlyZXMgc3ViY2xhc3NcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhpZGRlbkNhcHR1cmVzID0gYXRvbWljUmVzdWx0LmhpZGRlbkNhcHR1cmVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBjb25zdCB0cmFuc2ZlcnMgPSBBcnJheS5mcm9tKGF0b21pY1Jlc3VsdC5jYXB0dXJlVHJhbnNmZXJzKTtcbiAgICBjb25zdCBzdHJhdGVneSA9IHJlZ2V4UGx1c0FzdC5fc3RyYXRlZ3k7XG4gICAgY29uc3QgbGF6eUNvbXBpbGUgPSBkZXRhaWxzLnBhdHRlcm4ubGVuZ3RoID49IG9wdHMubGF6eUNvbXBpbGVMZW5ndGg7XG4gICAgaWYgKGhpZGRlbkNhcHR1cmVzLmxlbmd0aCB8fCB0cmFuc2ZlcnMubGVuZ3RoIHx8IHN0cmF0ZWd5IHx8IGxhenlDb21waWxlKSB7XG4gICAgICBkZXRhaWxzLm9wdGlvbnMgPSB7XG4gICAgICAgIC4uLmhpZGRlbkNhcHR1cmVzLmxlbmd0aCAmJiB7IGhpZGRlbkNhcHR1cmVzIH0sXG4gICAgICAgIC4uLnRyYW5zZmVycy5sZW5ndGggJiYgeyB0cmFuc2ZlcnMgfSxcbiAgICAgICAgLi4uc3RyYXRlZ3kgJiYgeyBzdHJhdGVneSB9LFxuICAgICAgICAuLi5sYXp5Q29tcGlsZSAmJiB7IGxhenlDb21waWxlIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXRhaWxzO1xufVxuZXhwb3J0IHtcbiAgRW11bGF0ZWRSZWdFeHAsXG4gIHRvUmVnRXhwLFxuICB0b1JlZ0V4cERldGFpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcCIsIlN0cmluZyIsImZyb21Db2RlUG9pbnQiLCJyIiwicmF3IiwiZW52RmxhZ3MiLCJmbGFnR3JvdXBzIiwiUmVnRXhwIiwidW5pY29kZVNldHMiLCJidWdGbGFnVkxpdGVyYWxIeXBoZW5Jc1JhbmdlIiwiYnVnTmVzdGVkQ2xhc3NJZ25vcmVzTmVnYXRpb24iLCJ0ZXN0IiwiZ2V0TmV3Q3VycmVudEZsYWdzIiwiY3VycmVudCIsImVuYWJsZSIsImRpc2FibGUiLCJkb3RBbGwiLCJpZ25vcmVDYXNlIiwiZ2V0T3JJbnNlcnQiLCJtYXAiLCJrZXkiLCJkZWZhdWx0VmFsdWUiLCJoYXMiLCJzZXQiLCJnZXQiLCJpc01pblRhcmdldCIsInRhcmdldCIsIm1pbiIsIkVzVmVyc2lvbiIsInRocm93SWZOdWxsaXNoIiwidmFsdWUiLCJtc2ciLCJFcnJvciIsIkVTMjAyNSIsIkVTMjAyNCIsIkVTMjAxOCIsIlRhcmdldCIsImF1dG8iLCJnZXRPcHRpb25zIiwib3B0aW9ucyIsInRvU3RyaW5nIiwiY2FsbCIsIm9wdHMiLCJhY2N1cmFjeSIsImF2b2lkU3ViY2xhc3MiLCJmbGFncyIsImdsb2JhbCIsImhhc0luZGljZXMiLCJsYXp5Q29tcGlsZUxlbmd0aCIsIkluZmluaXR5IiwidmVyYm9zZSIsInJ1bGVzIiwiYWxsb3dPcnBoYW5CYWNrcmVmcyIsImFzY2lpV29yZEJvdW5kYXJpZXMiLCJjYXB0dXJlR3JvdXAiLCJyZWN1cnNpb25MaW1pdCIsInNpbmdsZWxpbmUiLCJzbHVnIiwiYXNjaWlTcGFjZUNoYXIiLCJDaGFyc1dpdGhvdXRJZ25vcmVDYXNlRXhwYW5zaW9uIiwiU2V0IiwiZGVmYXVsdFdvcmRDaGFyIiwiZ2V0SWdub3JlQ2FzZU1hdGNoQ2hhcnMiLCJjaGFyIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJ0aXRsZSIsIkxvd2VyVG9UaXRsZUNhc2VNYXAiLCJhbHRMb3dlciIsIkxvd2VyVG9BbHRlcm5hdGl2ZUxvd2VyQ2FzZU1hcCIsImFsdFVwcGVyIiwiTG93ZXJUb0FsdGVybmF0aXZlVXBwZXJDYXNlTWFwIiwibGVuZ3RoIiwiYWRkIiwiSnNVbmljb2RlUHJvcGVydHlNYXAiLCJNYXAiLCJzcGxpdCIsInAiLCJ0aXRsZUVudHJ5IiwidGl0bGVSYW5nZSIsIlBvc2l4Q2xhc3NNYXAiLCJyYW5nZSIsInN0YXJ0IiwiZW5kIiwicmFuZ2UyIiwiaSIsInB1c2giLCJjb2RlUG9pbnQiLCJVbmljb2RlUHJvcGVydGllc1dpdGhTcGVjaWZpY0Nhc2UiLCJjcmVhdGVBbHRlcm5hdGl2ZSIsImNyZWF0ZUFzc2VydGlvbiIsImNyZWF0ZUJhY2tyZWZlcmVuY2UiLCJjcmVhdGVDYXB0dXJpbmdHcm91cCIsImNyZWF0ZUNoYXJhY3RlciIsImNyZWF0ZUNoYXJhY3RlckNsYXNzIiwiY3JlYXRlQ2hhcmFjdGVyU2V0IiwiY3JlYXRlR3JvdXAiLCJjcmVhdGVMb29rYXJvdW5kQXNzZXJ0aW9uIiwiY3JlYXRlUXVhbnRpZmllciIsImNyZWF0ZVN1YnJvdXRpbmUiLCJjcmVhdGVVbmljb2RlUHJvcGVydHkiLCJoYXNPbmx5Q2hpbGQiLCJwYXJzZSIsInNsdWcyIiwidHJhdmVyc2UiLCJ0cmFuc2Zvcm0iLCJhc3QiLCJiZXN0RWZmb3J0VGFyZ2V0IiwiYWRkUGFyZW50UHJvcGVydGllcyIsImZpcnN0UGFzc1N0YXRlIiwiZmxhZ0RpcmVjdGl2ZXNCeUFsdCIsImpzR3JvdXBOYW1lTWFwIiwibWluVGFyZ2V0RXMyMDI0IiwicGFzc2VkTG9va2JlaGluZCIsInN0cmF0ZWd5Iiwic3Vicm91dGluZVJlZk1hcCIsInN1cHBvcnRlZEdOb2RlcyIsImRpZ2l0SXNBc2NpaSIsInNwYWNlSXNBc2NpaSIsIndvcmRJc0FzY2lpIiwiRmlyc3RQYXNzVmlzaXRvciIsImdsb2JhbEZsYWdzIiwic2Vjb25kUGFzc1N0YXRlIiwiY3VycmVudEZsYWdzIiwicHJldkZsYWdzIiwiZ3JvdXBPcmlnaW5CeUNvcHkiLCJncm91cHNCeU5hbWUiLCJtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmIiwib3BlblJlZnMiLCJyZWZmZWROb2Rlc0J5UmVmZXJlbmNlciIsIlNlY29uZFBhc3NWaXNpdG9yIiwidGhpcmRQYXNzU3RhdGUiLCJoaWdoZXN0T3JwaGFuQmFja3JlZiIsIm51bUNhcHR1cmVzVG9MZWZ0IiwiVGhpcmRQYXNzVmlzaXRvciIsIl9vcmlnaW5NYXAiLCJfc3RyYXRlZ3kiLCJBYnNlbmNlRnVuY3Rpb24iLCJub2RlIiwicGFyZW50IiwicmVwbGFjZVdpdGgiLCJib2R5Iiwia2luZCIsImlubmVyR3JvdXAiLCJuZWdhdGUiLCJvdXRlckdyb3VwIiwic2V0UGFyZW50RGVlcCIsIkFsdGVybmF0aXZlIiwiZW50ZXIiLCJmbGFnRGlyZWN0aXZlcyIsImZpbHRlciIsImVsIiwiZm9yd2FyZFNpYmxpbmdBbHQiLCJleGl0IiwiZ2V0Q29tYmluZWRGbGFnTW9kc0Zyb21GbGFnTm9kZXMiLCJmbGFnR3JvdXAiLCJBc3NlcnRpb24iLCJjb250YWluZXIiLCJyb290IiwicmVtb3ZlIiwic3RhdGUiLCJwYXJzZUZyYWdtZW50Iiwic2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uIiwic3RpY2t5IiwicHJldiIsImlzQWx3YXlzTm9uWmVyb0xlbmd0aCIsInNldFBhcmVudCIsImIiLCJCIiwiQmFja3JlZmVyZW5jZSIsInJlZiIsImlzVmFsaWRKc0dyb3VwTmFtZSIsImdldEFuZFN0b3JlSnNHcm91cE5hbWUiLCJDYXB0dXJpbmdHcm91cCIsIm5hbWUiLCJudW1iZXIiLCJDaGFyYWN0ZXJDbGFzc1JhbmdlIiwiY2MiLCJDaGFyYWN0ZXJTZXQiLCJzZXROZWdhdGUiLCJlQmFzZSIsImVtb2ppIiwic2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb24iLCJhc2NpaSIsImdyYXBoIiwicHJpbnQiLCJjb2RlUG9pbnRBdCIsIkRpcmVjdGl2ZSIsInJlbW92ZUFsbFByZXZTaWJsaW5ncyIsInJlbW92ZUFsbE5leHRTaWJsaW5ncyIsImZpcnN0QWx0IiwiaGFzV3JhcHBlckdyb3VwIiwidHlwZSIsInRvcExldmVsIiwibG9va2JlaGluZCIsImJlaGluZCIsIkZsYWdzIiwicG9zaXhJc0FzY2lpIiwidGV4dFNlZ21lbnRNb2RlIiwiZm9yRWFjaCIsImYiLCJPYmplY3QiLCJhc3NpZ24iLCJtdWx0aWxpbmUiLCJ4IiwibiIsImZvcmNlIiwidiIsIkdyb3VwIiwiZXh0ZW5kZWQiLCJrZXlzIiwiTG9va2Fyb3VuZEFzc2VydGlvbiIsIk5hbWVkQ2FsbG91dCIsIlF1YW50aWZpZXIiLCJncm91cCIsIlJlZ2V4IiwibGVhZGluZ0dzIiwiaGFzQWx0V2l0aExlYWRHIiwiaGFzQWx0V2l0aG91dExlYWRHIiwiYWx0IiwicG9wIiwibGVhZGluZ0ciLCJnZXRMZWFkaW5nRyIsIkFycmF5IiwiaXNBcnJheSIsImciLCJfIiwiU3Vicm91dGluZSIsIm9ycGhhbiIsIm5vZGUyIiwic2tpcCIsIm9yaWdpbiIsInJlY3Vyc2lvbjIiLCJjcmVhdGVSZWN1cnNpb24iLCJtdWx0aXBsZXhOb2RlcyIsIm11bHRpcGxleCIsInNwbGljZSIsImdyb3Vwc1dpdGhTYW1lTmFtZSIsImhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSIsImdyb3VwSW5mbyIsInZhbHVlcyIsImRlbGV0ZSIsImlzUmVjdXJzaXZlIiwicmVmZmVkIiwicmVmZmVkR3JvdXBOb2RlIiwiaXNHbG9iYWxSZWN1cnNpb24iLCJleHBhbmRlZFN1YnJvdXRpbmUiLCJjbG9uZUNhcHR1cmluZ0dyb3VwIiwicmVwbGFjZW1lbnQiLCJyZWZmZWRHcm91cEZsYWdNb2RzIiwiZ2V0QWxsUGFyZW50cyIsInJlZmZlZEdyb3VwRmxhZ3MiLCJhcmVGbGFnc0VxdWFsIiwiZ2V0RmxhZ01vZHNGcm9tRmxhZ3MiLCJNYXRoIiwibWF4IiwicmVmZmVkTm9kZXMiLCJwYXJ0aWNpcGFudHMiLCJjYW5QYXJ0aWNpcGF0ZVdpdGhOb2RlIiwiYXRvbWljIiwicmV2ZXJzZSIsIm51bUNhcHNOZWVkZWQiLCJlbXB0eUNhcHR1cmUiLCJhdCIsImEiLCJjYXB0dXJlIiwicmlnaHRtb3N0UG9pbnQiLCJraWRzT2ZQYXJlbnQiLCJnZXRLaWRzIiwia2lkIiwiaXNBbmNlc3Rvck9mIiwib2JqIiwib3JpZ2luTWFwIiwidXAiLCJ1cDIiLCJzdG9yZSIsImVudHJpZXMiLCJmaWx0ZXJGbiIsInJlc3VsdHMiLCJqc05hbWUiLCJzaXplIiwicmVwbGFjZSIsImZsYWdOb2RlcyIsImZsYWdQcm9wcyIsImNvbWJpbmVkRmxhZ3MiLCJwcm9wIiwibW9kcyIsImVscyIsImZpcnN0VG9Db25zaWRlciIsImZpbmQiLCJpc0xvbmVHTG9va2Fyb3VuZCIsImlzQWx3YXlzWmVyb0xlbmd0aCIsImdOb2Rlc0Zvckdyb3VwIiwiZGVzY2VuZGFudCIsImtpZHMiLCJ0eXBlcyIsImluY2x1ZGVzIiwicGF0dGVybiIsInVuaWNvZGVQcm9wZXJ0eU1hcCIsImFsdHMiLCJjcmVhdGVBbHRlcm5hdGl2ZTIiLCJjcmVhdGVDaGFyYWN0ZXIyIiwiY3JlYXRlR3JvdXAyIiwidHJhdmVyc2UyIiwiZ2VuZXJhdGUiLCJtaW5UYXJnZXRFczIwMjUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJoYXNDYXNlSW5zZW5zaXRpdmVOb2RlIiwiaGFzQ2FzZVNlbnNpdGl2ZU5vZGUiLCJpU3RhY2siLCJGbGFnTW9kaWZpZXJWaXNpdG9yIiwiZ2V0Q3VycmVudE1vZEkiLCJwb3BNb2RJIiwicHVzaE1vZEkiLCJpc0lPbiIsInNldEhhc0Nhc2VkQ2hhciIsImFwcGxpZWRHbG9iYWxGbGFncyIsImxhc3ROb2RlIiwiY2FwdHVyZU1hcCIsImluQ2hhckNsYXNzIiwidXNlQXBwbGllZElnbm9yZUNhc2UiLCJ1c2VGbGFnTW9kcyIsInVzZUZsYWdWIiwiZ2VuIiwiZm4iLCJnZW5lcmF0b3IiLCJyZXN1bHQiLCJqb2luIiwidW5pY29kZVNldHNQbHVnaW4iLCJfY2FwdHVyZVRyYW5zZmVycyIsIl9oaWRkZW5DYXB0dXJlcyIsImhpZGRlbiIsInRyYW5zZmVyVG8iLCJpc0FueUdyb3VwIiwiY3VycmVudE1vZEkiLCJDaGFyYWN0ZXIiLCJjaGFySGFzQ2FzZSIsImdldENhc2VzT3V0c2lkZUNoYXJDbGFzc1JhbmdlIiwiZmlyc3RPbmx5IiwiZGF0YSIsImVzY2FwZWQiLCJnZXRDaGFyRXNjYXBlIiwiZXNjRGlnaXQiLCJjYXNlcyIsIkNoYXJhY3RlckNsYXNzIiwic29tZSIsImlzTGl0ZXJhbEh5cGhlbiIsImdlbkNsYXNzIiwibmVnYXRlZENoaWxkQ2xhc3NlcyIsImdyb3VwRmlyc3RBbHQiLCJuZXdBbHQiLCJmaXJzdEVsIiwiZXNjT3B0cyIsIm1pblN0ciIsIm1heFN0ciIsImV4dHJhQ2hhcnMiLCJjaGFyc091dHNpZGVSYW5nZSIsInJhbmdlcyIsImdldENvZGVQb2ludFJhbmdlc0Zyb21DaGFycyIsImF0b21pYzIiLCJjb250ZW50cyIsImdldEdyb3VwUHJlZml4IiwicHJlZml4IiwiZ2V0UXVhbnRpZmllclN0ciIsImxpbWl0IiwiQmFzZUVzY2FwZUNoYXJzIiwiQ2hhckNsYXNzRXNjYXBlQ2hhcnMiLCJDaGFyQ2xhc3NFc2NhcGVDaGFyc0ZsYWdWIiwiQ2hhckNvZGVFc2NhcGVNYXAiLCJjYXNlZFJlIiwiZm91bmQiLCJjYXNlT2ZDaGFyIiwibnVtIiwiaXNEaWdpdENoYXJDb2RlIiwicGFkU3RhcnQiLCJlc2NhcGVDaGFycyIsImNoYXJzIiwiY29kZVBvaW50cyIsInNvcnQiLCJmbGFnTW9kcyIsImJhc2UiLCJncmVlZHkiLCJsYXp5IiwicG9zc2Vzc2l2ZSIsIkVtdWxhdGVkUmVnRXhwIiwiX0VtdWxhdGVkUmVnRXhwIiwiY29tcGlsZWQiLCJuYW1lTWFwIiwic291cmNlIiwiY29uc3RydWN0b3IiLCJsYXp5Q29tcGlsZSIsInJlIiwicmF3T3B0aW9ucyIsImhpZGRlbkNhcHR1cmVzIiwidHJhbnNmZXJzIiwiY3JlYXRlQ2FwdHVyZU1hcCIsImV4ZWMiLCJzdHIiLCJyZXN0IiwidXNlTGFzdEluZGV4IiwicG9zIiwibGFzdEluZGV4IiwibWF0Y2giLCJleGVjQ29yZSIsInNsaWNlIiwiYWRqdXN0TWF0Y2hEZXRhaWxzRm9yT2Zmc2V0IiwibWF0Y2hDb3B5IiwiaW5kaWNlc0NvcHkiLCJpbmRpY2VzIiwibWFwcGVkTnVtcyIsInRvIiwiZ3JvdXBzIiwiY3JlYXRlTmFtZU1hcCIsIm9mZnNldCIsImlucHV0IiwiaW5kZXgiLCJhcnIiLCJncm91cEluZGljZXMiLCJmcm9tIiwibnVtQ2hhckNsYXNzZXNPcGVuIiwibnVtQ2FwdHVyZXMiLCJtIiwicGFyc2UyIiwicmVjdXJzaW9uIiwidG9SZWdFeHAiLCJkIiwidG9SZWdFeHBEZXRhaWxzIiwib25pZ3VydW1hQXN0Iiwibm9ybWFsaXplVW5rbm93blByb3BlcnR5TmFtZXMiLCJza2lwQmFja3JlZlZhbGlkYXRpb24iLCJyZWdleFBsdXNBc3QiLCJnZW5lcmF0ZWQiLCJyZWN1cnNpb25SZXN1bHQiLCJjYXB0dXJlVHJhbnNmZXJzIiwibW9kZSIsInBvc3Nlc3NpdmVSZXN1bHQiLCJhdG9taWNSZXN1bHQiLCJkZXRhaWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/oniguruma-to-es@4.3.4/node_modules/oniguruma-to-es/dist/esm/index.js\n");

/***/ })

};
;