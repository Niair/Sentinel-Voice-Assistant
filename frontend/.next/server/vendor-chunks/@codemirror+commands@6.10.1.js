"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+commands@6.10.1";
exports.ids = ["vendor-chunks/@codemirror+commands@6.10.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@codemirror+commands@6.10.1/node_modules/@codemirror/commands/dist/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@codemirror+commands@6.10.1/node_modules/@codemirror/commands/dist/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCursorAbove: () => (/* binding */ addCursorAbove),\n/* harmony export */   addCursorBelow: () => (/* binding */ addCursorBelow),\n/* harmony export */   blockComment: () => (/* binding */ blockComment),\n/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),\n/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),\n/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),\n/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),\n/* harmony export */   cursorCharBackwardLogical: () => (/* binding */ cursorCharBackwardLogical),\n/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),\n/* harmony export */   cursorCharForwardLogical: () => (/* binding */ cursorCharForwardLogical),\n/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),\n/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),\n/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),\n/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),\n/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),\n/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),\n/* harmony export */   cursorGroupForwardWin: () => (/* binding */ cursorGroupForwardWin),\n/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),\n/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),\n/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),\n/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),\n/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),\n/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),\n/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),\n/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),\n/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),\n/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),\n/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),\n/* harmony export */   deleteCharBackwardStrict: () => (/* binding */ deleteCharBackwardStrict),\n/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),\n/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),\n/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),\n/* harmony export */   deleteGroupForwardWin: () => (/* binding */ deleteGroupForwardWin),\n/* harmony export */   deleteLine: () => (/* binding */ deleteLine),\n/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),\n/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),\n/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),\n/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),\n/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   historyField: () => (/* binding */ historyField),\n/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),\n/* harmony export */   indentLess: () => (/* binding */ indentLess),\n/* harmony export */   indentMore: () => (/* binding */ indentMore),\n/* harmony export */   indentSelection: () => (/* binding */ indentSelection),\n/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),\n/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),\n/* harmony export */   insertNewline: () => (/* binding */ insertNewline),\n/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   insertNewlineKeepIndent: () => (/* binding */ insertNewlineKeepIndent),\n/* harmony export */   insertTab: () => (/* binding */ insertTab),\n/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),\n/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),\n/* harmony export */   lineComment: () => (/* binding */ lineComment),\n/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),\n/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),\n/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoSelection: () => (/* binding */ redoSelection),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),\n/* harmony export */   selectCharBackwardLogical: () => (/* binding */ selectCharBackwardLogical),\n/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),\n/* harmony export */   selectCharForwardLogical: () => (/* binding */ selectCharForwardLogical),\n/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),\n/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),\n/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),\n/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),\n/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),\n/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),\n/* harmony export */   selectGroupForwardWin: () => (/* binding */ selectGroupForwardWin),\n/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),\n/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),\n/* harmony export */   selectLine: () => (/* binding */ selectLine),\n/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),\n/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),\n/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),\n/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),\n/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),\n/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),\n/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),\n/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),\n/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),\n/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),\n/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),\n/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),\n/* harmony export */   splitLine: () => (/* binding */ splitLine),\n/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),\n/* harmony export */   temporarilySetTabFocusMode: () => (/* binding */ temporarilySetTabFocusMode),\n/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),\n/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   toggleComment: () => (/* binding */ toggleComment),\n/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),\n/* harmony export */   toggleTabFocusMode: () => (/* binding */ toggleTabFocusMode),\n/* harmony export */   transposeChars: () => (/* binding */ transposeChars),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoSelection: () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/.pnpm/@codemirror+state@6.5.4/node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/.pnpm/@codemirror+view@6.39.11/node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/.pnpm/@codemirror+language@6.12.1/node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/ const toggleComment = (target)=>{\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let tr = f(option, state);\n        if (!tr) return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleLineComment = /*@__PURE__*/ command(changeLineComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using line comments.\n*/ const lineComment = /*@__PURE__*/ command(changeLineComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using line comments.\n*/ const lineUncomment = /*@__PURE__*/ command(changeLineComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleBlockComment = /*@__PURE__*/ command(changeBlockComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using block comments.\n*/ const blockComment = /*@__PURE__*/ command(changeBlockComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using block comments.\n*/ const blockUncomment = /*@__PURE__*/ command(changeBlockComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/ const toggleBlockCommentByLine = /*@__PURE__*/ command((o, s)=>changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */ );\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos, 1);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/ function findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return {\n            open: {\n                pos: from - spaceBefore,\n                margin: spaceBefore && 1\n            },\n            close: {\n                pos: to + spaceAfter,\n                margin: spaceAfter && 1\n            }\n        };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    } else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n        return {\n            open: {\n                pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n            },\n            close: {\n                pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n            }\n        };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges){\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        if (toLine.from > fromLine.from && toLine.from == r.to) toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;\n        else ranges.push({\n            from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n            to: toLine.to\n        });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map((r)=>getConfig(state, r.from).block);\n    if (!tokens.every((c)=>c)) return null;\n    let comments = ranges.map((r, i)=>findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */  && !comments.every((c)=>c)) {\n        return {\n            changes: state.changes(ranges.map((range, i)=>{\n                if (comments[i]) return [];\n                return [\n                    {\n                        from: range.from,\n                        insert: tokens[i].open + \" \"\n                    },\n                    {\n                        from: range.to,\n                        insert: \" \" + tokens[i].close\n                    }\n                ];\n            }))\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && comments.some((c)=>c)) {\n        let changes = [];\n        for(let i = 0, comment; i < comments.length; i++)if (comment = comments[i]) {\n            let token = tokens[i], { open, close } = comment;\n            changes.push({\n                from: open.pos - token.open.length,\n                to: open.pos + open.margin\n            }, {\n                from: close.pos - close.margin,\n                to: close.pos + token.close.length\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges){\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token) continue;\n        for(let pos = from; pos <= to;){\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent) minIndent = indent;\n                lines.push({\n                    line,\n                    comment,\n                    token,\n                    indent,\n                    empty,\n                    single: false\n                });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9) {\n            for(let i = startI; i < lines.length; i++)if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n        }\n        if (lines.length == startI + 1) lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */  && lines.some((l)=>l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)if (single || !empty) changes.push({\n            from: line.from + indent,\n            insert: token + \" \"\n        });\n        let changeSet = state.changes(changes);\n        return {\n            changes: changeSet,\n            selection: state.selection.map(changeSet, 1)\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && lines.some((l)=>l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)if (comment >= 0) {\n            let from = line.from + comment, to = from + token.length;\n            if (line.text[to - line.from] == \" \") to++;\n            changes.push({\n                from,\n                to\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\nconst fromHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/ const isolateHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/ const invertedEffects = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent)=>isAdjacent\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b)=>(tr, adj)=>a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return HistoryState.empty;\n    },\n    update (state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */  ? state.undone : state.done;\n            if (item) other = updateBranch(other, other.length, config.minDepth, item);\n            else other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */  ? fromHist.rest : other, from == 0 /* BranchName.Done */  ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n        if (event) state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n        return state;\n    },\n    toJSON (value) {\n        return {\n            done: value.done.map((e)=>e.toJSON()),\n            undone: value.undone.map((e)=>e.toJSON())\n        };\n    },\n    fromJSON (json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/ function history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n            beforeinput (e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command) return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/ const historyField = historyField_;\nfunction cmd(side, selection) {\n    return function({ state, dispatch }) {\n        if (!selection && state.readOnly) return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState) return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr) return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/ const undo = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/ const redo = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , false);\n/**\nUndo a change or selection change.\n*/ const undoSelection = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , true);\n/**\nRedo a change or selection change.\n*/ const redoSelection = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , true);\nfunction depth(side) {\n    return function(state) {\n        let histState = state.field(historyField_, false);\n        if (!histState) return 0;\n        let branch = side == 0 /* BranchName.Done */  ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/ const undoDepth = /*@__PURE__*/ depth(0 /* BranchName.Done */ );\n/**\nThe amount of redoable change events available in a given state.\n*/ const redoDepth = /*@__PURE__*/ depth(1 /* BranchName.Undone */ );\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(// The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, // The effects associated with this event\n    effects, // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, // The selection before this event\n    startSelection, // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter){\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map((s)=>s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)){\n            let result = invert(tr);\n            if (result.length) effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty) return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t)=>ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t)=>{\n        for(let i = 0; i < ranges.length;){\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to) isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i)=>r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [\n            HistEvent.selection([\n                selection\n            ])\n        ];\n    } else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length) return branch;\n    let length = branch.length, selections = none;\n    while(length){\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) {\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        } else {\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [\n        HistEvent.selection(selections)\n    ] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s)=>s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes) return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined){\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n        userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        } else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */  ? this.done : this.undone;\n        if (branch.length == 0) return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({\n                    side,\n                    rest: popSelection(branch),\n                    selection\n                }),\n                userEvent: side == 0 /* BranchName.Done */  ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        } else if (!event.changes) {\n            return null;\n        } else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({\n                    side,\n                    rest,\n                    selection\n                }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */  ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/ new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/ const historyKeymap = [\n    {\n        key: \"Mod-z\",\n        run: undo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-y\",\n        mac: \"Mod-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        linux: \"Ctrl-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-u\",\n        run: undoSelection,\n        preventDefault: true\n    },\n    {\n        key: \"Alt-u\",\n        mac: \"Mod-Shift-u\",\n        run: redoSelection,\n        preventDefault: true\n    }\n];\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({\n        selection,\n        scrollIntoView: true,\n        userEvent: \"select\"\n    });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection, true)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/ const cursorCharLeft = (view)=>cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/ const cursorCharRight = (view)=>cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/ const cursorCharForward = (view)=>cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/ const cursorCharBackward = (view)=>cursorByChar(view, false);\nfunction byCharLogical(state, range, forward) {\n    let pos = range.head, line = state.doc.lineAt(pos);\n    if (pos == (forward ? line.to : line.from)) pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);\n    else pos = line.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos, forward ? -1 : 1);\n}\nfunction moveByCharLogical(target, forward) {\n    return moveSel(target, (range)=>range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character forward, in logical\n(non-text-direction-aware) string index order.\n*/ const cursorCharForwardLogical = (target)=>moveByCharLogical(target, true);\n/**\nMove the selection one character backward, in logical string index\norder.\n*/ const cursorCharBackwardLogical = (target)=>moveByCharLogical(target, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/ const cursorGroupLeft = (view)=>cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/ const cursorGroupRight = (view)=>cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/ const cursorGroupForward = (view)=>cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/ const cursorGroupBackward = (view)=>cursorByGroup(view, false);\nfunction toGroupStart(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start), initial = cat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space;\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (nextCat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) return initial && nextCat == cat;\n        initial = false;\n        return true;\n    };\n}\n/**\nMove the cursor one group forward in the default Windows style,\nwhere it moves to the start of the next group.\n*/ const cursorGroupForwardWin = (view)=>{\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)) : rangeEnd(range, true));\n};\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/ new Intl.Segmenter(undefined, {\n    granularity: \"word\"\n}) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next)=>{\n        if (done) return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n        if (cat != nextCat) return false;\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper) return false;\n                sawLower = true;\n            } else if (sawLower) {\n                if (forward) return false;\n                done = true;\n            } else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, (start)=>{\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, (range)=>range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/ const cursorSubwordForward = (view)=>cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/ const cursorSubwordBackward = (view)=>cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp)) return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for(let at = start.head;;){\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next) break;\n        if (interestingNode(state, next, bracketProp)) pos = next;\n        else at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;\n    else newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/ const cursorSyntaxLeft = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/ const cursorSyntaxRight = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, (range)=>{\n        if (!range.empty) return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/ const cursorLineUp = (view)=>cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/ const cursorLineDown = (view)=>cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)){\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    } else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return {\n        marginTop,\n        marginBottom,\n        selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5)\n    };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, (range)=>{\n        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection)) return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n            y: \"start\",\n            yMargin: startPos.top - scrollTop\n        });\n    }\n    view.dispatch(setSel(state, selection), {\n        effects: effect\n    });\n    return true;\n}\n/**\nMove the selection one page up.\n*/ const cursorPageUp = (view)=>cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/ const cursorPageDown = (view)=>cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/ const cursorLineBoundaryForward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/ const cursorLineBoundaryBackward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/ const cursorLineBoundaryLeft = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/ const cursorLineBoundaryRight = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/ const cursorLineStart = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/ const cursorLineEnd = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, (range)=>{\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n        if (!matching || !matching.end) return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/ const cursorMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/ const selectMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, true);\nfunction extendSel(target, how) {\n    let selection = updateSel(target.state.selection, (range)=>{\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(target.state.selection)) return false;\n    target.dispatch(setSel(target.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, (range)=>view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/ const selectCharLeft = (view)=>selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/ const selectCharRight = (view)=>selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/ const selectCharForward = (view)=>selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/ const selectCharBackward = (view)=>selectByChar(view, false);\n/**\nMove the selection head one character forward by logical\n(non-direction aware) string index order.\n*/ const selectCharForwardLogical = (target)=>extendSel(target, (range)=>byCharLogical(target.state, range, true));\n/**\nMove the selection head one character backward by logical string\nindex order.\n*/ const selectCharBackwardLogical = (target)=>extendSel(target, (range)=>byCharLogical(target.state, range, false));\nfunction selectByGroup(view, forward) {\n    return extendSel(view, (range)=>view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/ const selectGroupLeft = (view)=>selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/ const selectGroupRight = (view)=>selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/ const selectGroupForward = (view)=>selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/ const selectGroupBackward = (view)=>selectByGroup(view, false);\n/**\nMove the selection head one group forward in the default Windows\nstyle, skipping to the start of the next group.\n*/ const selectGroupForwardWin = (view)=>{\n    return extendSel(view, (range)=>view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)));\n};\nfunction selectBySubword(view, forward) {\n    return extendSel(view, (range)=>moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/ const selectSubwordForward = (view)=>selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/ const selectSubwordBackward = (view)=>selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/ const selectSyntaxLeft = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/ const selectSyntaxRight = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/ const selectLineUp = (view)=>selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/ const selectLineDown = (view)=>selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/ const selectPageUp = (view)=>selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/ const selectPageDown = (view)=>selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/ const selectLineBoundaryForward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/ const selectLineBoundaryBackward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/ const selectLineBoundaryLeft = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/ const selectLineBoundaryRight = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/ const selectLineStart = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/ const selectLineEnd = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/ const cursorDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: 0\n    }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/ const cursorDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.doc.length\n    }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/ const selectDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: 0\n    }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/ const selectDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: state.doc.length\n    }));\n    return true;\n};\n/**\nSelect the entire document.\n*/ const selectAll = ({ state, dispatch })=>{\n    dispatch(state.update({\n        selection: {\n            anchor: 0,\n            head: state.doc.length\n        },\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/ const selectLine = ({ state, dispatch })=>{\n    let ranges = selectedLineBlocks(state).map(({ from, to })=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/ const selectParentSyntax = ({ state, dispatch })=>{\n    let selection = updateSel(state.selection, (range)=>{\n        let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state), stack = tree.resolveStack(range.from, 1);\n        if (range.empty) {\n            let stackBefore = tree.resolveStack(range.from, -1);\n            if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;\n        }\n        for(let cur = stack; cur; cur = cur.next){\n            let { node } = cur;\n            if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    if (selection.eq(state.selection)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction addCursorVertically(view, forward) {\n    let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();\n    for (let range of state.selection.ranges){\n        let line = state.doc.lineAt(range.head);\n        if (forward ? line.to < view.state.doc.length : line.from > 0) for(let cur = range;;){\n            let next = view.moveVertically(cur, forward);\n            if (next.head < line.from || next.head > line.to) {\n                if (!ranges.some((r)=>r.head == next.head)) ranges.push(next);\n                break;\n            } else if (next.head == cur.head) {\n                break;\n            } else {\n                cur = next;\n            }\n        }\n    }\n    if (ranges.length == sel.ranges.length) return false;\n    view.dispatch(setSel(state, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, ranges.length - 1)));\n    return true;\n}\n/**\nExpand the selection by adding a cursor above the heads of\ncurrently selected ranges.\n*/ const addCursorAbove = (view)=>addCursorVertically(view, false);\n/**\nExpand the selection by adding a cursor below the heads of\ncurrently selected ranges.\n*/ const addCursorBelow = (view)=>addCursorVertically(view, true);\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/ const simplifySelection = ({ state, dispatch })=>{\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        cur.main\n    ]);\n    else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)\n    ]);\n    if (!selection) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly) return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange((range)=>{\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            } else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        } else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? {\n            range\n        } : {\n            changes: {\n                from,\n                to\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1)\n        };\n    });\n    if (changes.changes.empty) return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map((f)=>f(target)))ranges.between(pos, pos, (from, to)=>{\n        if (from < pos && to > pos) pos = forward ? to : from;\n    });\n    return pos;\n}\nconst deleteByChar = (target, forward, byIndentUnit)=>deleteBy(target, (range)=>{\n        let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n        if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n            if (before[before.length - 1] == \"\t\") return pos - 1;\n            let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n            for(let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)pos--;\n            targetPos = pos;\n        } else {\n            targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n            if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n            else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false) + line.from;\n        }\n        return targetPos;\n    });\n/**\nDelete the selection, or, for cursor selections, the character or\nindentation unit before the cursor.\n*/ const deleteCharBackward = (view)=>deleteByChar(view, false, true);\n/**\nDelete the selection or the character before the cursor. Does not\nimplement any extended behavior like deleting whole indentation\nunits in one go.\n*/ const deleteCharBackwardStrict = (view)=>deleteByChar(view, false, false);\n/**\nDelete the selection or the character after the cursor.\n*/ const deleteCharForward = (view)=>deleteByChar(view, true, false);\nconst deleteByGroup = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n        let categorize = state.charCategorizer(pos);\n        for(let cat = null;;){\n            if (pos == (forward ? line.to : line.from)) {\n                if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n                break;\n            }\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n            let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n            let nextCat = categorize(nextChar);\n            if (cat != null && nextCat != cat) break;\n            if (nextChar != \" \" || pos != range.head) cat = nextCat;\n            pos = next;\n        }\n        return pos;\n    });\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/ const deleteGroupBackward = (target)=>deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/ const deleteGroupForward = (target)=>deleteByGroup(target, true);\n/**\nVariant of [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\nthat uses the Windows convention of also deleting the whitespace\nafter a word.\n*/ const deleteGroupForwardWin = (view)=>deleteBy(view, (range)=>view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)).head);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/ const deleteToLineEnd = (view)=>deleteBy(view, (range)=>{\n        let lineEnd = view.lineBlockAt(range.head).to;\n        return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/ const deleteToLineStart = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.lineBlockAt(range.head).from;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/ const deleteLineBoundaryBackward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, false).head;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/ const deleteLineBoundaryForward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, true).head;\n        return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/ const deleteTrailingWhitespace = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = [];\n    for(let pos = 0, prev = \"\", iter = state.doc.iter();;){\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1) changes.push({\n                from: pos - (prev.length - trailing),\n                to: pos\n            });\n            if (iter.done) break;\n            prev = \"\";\n        } else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        userEvent: \"delete\"\n    }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/ const splitLine = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\n                    \"\",\n                    \"\"\n                ])\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n        };\n    });\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/ const transposeChars = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n            range\n        };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return {\n            changes: {\n                from,\n                to,\n                insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n        };\n    });\n    if (changes.changes.empty) return false;\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"move.character\"\n    }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges){\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        } else {\n            blocks.push({\n                from: startLine.from,\n                to: endLine.to,\n                ranges: [\n                    range\n                ]\n            });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward ? block.to == state.doc.length : block.from == 0) continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({\n                from: block.to,\n                to: nextLine.to\n            }, {\n                from: block.from,\n                insert: nextLine.text + state.lineBreak\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        } else {\n            changes.push({\n                from: nextLine.from,\n                to: block.from\n            }, {\n                from: block.to,\n                insert: state.lineBreak + nextLine.text\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/ const moveLineUp = ({ state, dispatch })=>moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/ const moveLineDown = ({ state, dispatch })=>moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward) changes.push({\n            from: block.from,\n            insert: state.doc.slice(block.from, block.to) + state.lineBreak\n        });\n        else changes.push({\n            from: block.to,\n            insert: state.lineBreak + state.doc.slice(block.from, block.to)\n        });\n    }\n    let changeSet = state.changes(changes);\n    dispatch(state.update({\n        changes: changeSet,\n        selection: state.selection.map(changeSet, forward ? 1 : -1),\n        scrollIntoView: true,\n        userEvent: \"input.copyline\"\n    }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/ const copyLineUp = ({ state, dispatch })=>copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/ const copyLineDown = ({ state, dispatch })=>copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/ const deleteLine = (view)=>{\n    if (view.state.readOnly) return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to })=>{\n        if (from > 0) from--;\n        else if (to < state.doc.length) to++;\n        return {\n            from,\n            to\n        };\n    }));\n    let selection = updateSel(state.selection, (range)=>{\n        let dist = undefined;\n        if (view.lineWrapping) {\n            let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (pos) dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;\n        }\n        return view.moveVertically(range, true, dist);\n    }).map(changes);\n    view.dispatch({\n        changes,\n        selection,\n        scrollIntoView: true,\n        userEvent: \"delete.line\"\n    });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/ const insertNewline = ({ state, dispatch })=>{\n    dispatch(state.update(state.replaceSelection(state.lineBreak), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nReplace the selection with a newline and the same amount of\nindentation as the line above.\n*/ const insertNewlineKeepIndent = ({ state, dispatch })=>{\n    dispatch(state.update(state.changeByRange((range)=>{\n        let indent = /^\\s*/.exec(state.doc.lineAt(range.from).text)[0];\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: state.lineBreak + indent\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + indent.length + 1)\n        };\n    }), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n        from: pos,\n        to: pos\n    };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n        from: before.to,\n        to: after.from\n    };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/ const insertNewlineAndIndent = /*@__PURE__*/ newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/ const insertBlankLine = /*@__PURE__*/ newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let changes = state.changeByRange((range)=>{\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n                simulateBreak: from,\n                simulateDoubleBreak: !!explode\n            });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null) indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while(to < line.to && /\\s/.test(line.text[to - line.from]))to++;\n            if (explode) ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n            let insert = [\n                \"\",\n                (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)\n            ];\n            if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return {\n                changes: {\n                    from,\n                    to,\n                    insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n            };\n        });\n        dispatch(state.update(changes, {\n            scrollIntoView: true,\n            userEvent: \"input\"\n        }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange((range)=>{\n        let changes = [];\n        for(let pos = range.from; pos <= range.to;){\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return {\n            changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n        };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/ const indentSelection = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        overrideIndentation: (start)=>{\n            let found = updated[start];\n            return found == null ? -1 : found;\n        }\n    });\n    let changes = changeBySelectedLine(state, (line, changes, range)=>{\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null) return;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    });\n    if (!changes.changes.empty) dispatch(state.update(changes, {\n        userEvent: \"indent\"\n    }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/ const indentMore = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        changes.push({\n            from: line.from,\n            insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n        });\n    }), {\n        userEvent: \"input.indent\"\n    }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/ const indentLess = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space) return;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while(keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))keep++;\n        changes.push({\n            from: line.from + keep,\n            to: line.from + space.length,\n            insert: insert.slice(keep)\n        });\n    }), {\n        userEvent: \"delete.dedent\"\n    }));\n    return true;\n};\n/**\nEnables or disables\n[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this\nprevents the editor's key bindings from capturing Tab or\nShift-Tab, making it possible for the user to move focus out of\nthe editor with the keyboard.\n*/ const toggleTabFocusMode = (view)=>{\n    view.setTabFocusMode();\n    return true;\n};\n/**\nTemporarily enables [tab-focus\nmode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until\nanother key is pressed.\n*/ const temporarilySetTabFocusMode = (view)=>{\n    view.setTabFocusMode(2000);\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/ const insertTab = ({ state, dispatch })=>{\n    if (state.selection.ranges.some((r)=>!r.empty)) return indentMore({\n        state,\n        dispatch\n    });\n    dispatch(state.update(state.replaceSelection(\"\t\"), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/ const emacsStyleKeymap = [\n    {\n        key: \"Ctrl-b\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Ctrl-f\",\n        run: cursorCharRight,\n        shift: selectCharRight\n    },\n    {\n        key: \"Ctrl-p\",\n        run: cursorLineUp,\n        shift: selectLineUp\n    },\n    {\n        key: \"Ctrl-n\",\n        run: cursorLineDown,\n        shift: selectLineDown\n    },\n    {\n        key: \"Ctrl-a\",\n        run: cursorLineStart,\n        shift: selectLineStart\n    },\n    {\n        key: \"Ctrl-e\",\n        run: cursorLineEnd,\n        shift: selectLineEnd\n    },\n    {\n        key: \"Ctrl-d\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Ctrl-h\",\n        run: deleteCharBackward\n    },\n    {\n        key: \"Ctrl-k\",\n        run: deleteToLineEnd\n    },\n    {\n        key: \"Ctrl-Alt-h\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Ctrl-o\",\n        run: splitLine\n    },\n    {\n        key: \"Ctrl-t\",\n        run: transposeChars\n    },\n    {\n        key: \"Ctrl-v\",\n        run: cursorPageDown\n    }\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/ const standardKeymap = /*@__PURE__*/ [\n    {\n        key: \"ArrowLeft\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowLeft\",\n        mac: \"Alt-ArrowLeft\",\n        run: cursorGroupLeft,\n        shift: selectGroupLeft,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowLeft\",\n        run: cursorLineBoundaryLeft,\n        shift: selectLineBoundaryLeft,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowRight\",\n        run: cursorCharRight,\n        shift: selectCharRight,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowRight\",\n        mac: \"Alt-ArrowRight\",\n        run: cursorGroupRight,\n        shift: selectGroupRight,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowRight\",\n        run: cursorLineBoundaryRight,\n        shift: selectLineBoundaryRight,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowUp\",\n        run: cursorLineUp,\n        shift: selectLineUp,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowUp\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        mac: \"Ctrl-ArrowUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"ArrowDown\",\n        run: cursorLineDown,\n        shift: selectLineDown,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowDown\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        mac: \"Ctrl-ArrowDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"PageUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"PageDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"Home\",\n        run: cursorLineBoundaryBackward,\n        shift: selectLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Home\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        key: \"End\",\n        run: cursorLineBoundaryForward,\n        shift: selectLineBoundaryForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-End\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        key: \"Enter\",\n        run: insertNewlineAndIndent,\n        shift: insertNewlineAndIndent\n    },\n    {\n        key: \"Mod-a\",\n        run: selectAll\n    },\n    {\n        key: \"Backspace\",\n        run: deleteCharBackward,\n        shift: deleteCharBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Delete\",\n        run: deleteCharForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Backspace\",\n        mac: \"Alt-Backspace\",\n        run: deleteGroupBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Delete\",\n        mac: \"Alt-Delete\",\n        run: deleteGroupForward,\n        preventDefault: true\n    },\n    {\n        mac: \"Mod-Backspace\",\n        run: deleteLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        mac: \"Mod-Delete\",\n        run: deleteLineBoundaryForward,\n        preventDefault: true\n    }\n].concat(/*@__PURE__*/ emacsStyleKeymap.map((b)=>({\n        mac: b.key,\n        run: b.run,\n        shift: b.shift\n    })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Ctrl-Alt-ArrowUp (Cmd-Alt-ArrowUp on macOS): [`addCursorAbove`](https://codemirror.net/6/docs/ref/#commands.addCursorAbove).\n- Ctrl-Alt-ArrowDown (Cmd-Alt-ArrowDown on macOS): [`addCursorBelow`](https://codemirror.net/6/docs/ref/#commands.addCursorBelow).\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).\n*/ const defaultKeymap = /*@__PURE__*/ [\n    {\n        key: \"Alt-ArrowLeft\",\n        mac: \"Ctrl-ArrowLeft\",\n        run: cursorSyntaxLeft,\n        shift: selectSyntaxLeft\n    },\n    {\n        key: \"Alt-ArrowRight\",\n        mac: \"Ctrl-ArrowRight\",\n        run: cursorSyntaxRight,\n        shift: selectSyntaxRight\n    },\n    {\n        key: \"Alt-ArrowUp\",\n        run: moveLineUp\n    },\n    {\n        key: \"Shift-Alt-ArrowUp\",\n        run: copyLineUp\n    },\n    {\n        key: \"Alt-ArrowDown\",\n        run: moveLineDown\n    },\n    {\n        key: \"Shift-Alt-ArrowDown\",\n        run: copyLineDown\n    },\n    {\n        key: \"Mod-Alt-ArrowUp\",\n        run: addCursorAbove\n    },\n    {\n        key: \"Mod-Alt-ArrowDown\",\n        run: addCursorBelow\n    },\n    {\n        key: \"Escape\",\n        run: simplifySelection\n    },\n    {\n        key: \"Mod-Enter\",\n        run: insertBlankLine\n    },\n    {\n        key: \"Alt-l\",\n        mac: \"Ctrl-l\",\n        run: selectLine\n    },\n    {\n        key: \"Mod-i\",\n        run: selectParentSyntax,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-[\",\n        run: indentLess\n    },\n    {\n        key: \"Mod-]\",\n        run: indentMore\n    },\n    {\n        key: \"Mod-Alt-\\\\\",\n        run: indentSelection\n    },\n    {\n        key: \"Shift-Mod-k\",\n        run: deleteLine\n    },\n    {\n        key: \"Shift-Mod-\\\\\",\n        run: cursorMatchingBracket\n    },\n    {\n        key: \"Mod-/\",\n        run: toggleComment\n    },\n    {\n        key: \"Alt-A\",\n        run: toggleBlockComment\n    },\n    {\n        key: \"Ctrl-m\",\n        mac: \"Shift-Alt-m\",\n        run: toggleTabFocusMode\n    }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/ const indentWithTab = {\n    key: \"Tab\",\n    run: indentMore,\n    shift: indentLess\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3IrY29tbWFuZHNANi4xMC4xL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzTTtBQUM3STtBQUNnRjtBQUNoRztBQUV6Qzs7O0FBR0EsR0FDQSxNQUFNdUIsZ0JBQWdCQyxDQUFBQTtJQUNsQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHRCxRQUFRRSxPQUFPRCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ0gsTUFBTUksU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksR0FBR0MsU0FBU0MsVUFBVVQsT0FBT0MsS0FBSyxFQUFFQyxLQUFLSyxJQUFJO0lBQ3RILE9BQU9DLE9BQU9OLElBQUksR0FBR1Esa0JBQWtCVixVQUFVUSxPQUFPRyxLQUFLLEdBQUdDLHlCQUF5QlosVUFBVTtBQUN2RztBQUNBLFNBQVNhLFFBQVFDLENBQUMsRUFBRUMsTUFBTTtJQUN0QixPQUFPLENBQUMsRUFBRWQsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDdkIsSUFBSWYsTUFBTWdCLFFBQVEsRUFDZCxPQUFPO1FBQ1gsSUFBSUMsS0FBS0osRUFBRUMsUUFBUWQ7UUFDbkIsSUFBSSxDQUFDaUIsSUFDRCxPQUFPO1FBQ1hGLFNBQVNmLE1BQU1rQixNQUFNLENBQUNEO1FBQ3RCLE9BQU87SUFDWDtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNUixvQkFBb0IsV0FBVyxHQUFFRyxRQUFRTyxtQkFBbUIsRUFBRSx3QkFBd0I7QUFDNUY7O0FBRUEsR0FDQSxNQUFNQyxjQUFjLFdBQVcsR0FBRVIsUUFBUU8sbUJBQW1CLEVBQUUseUJBQXlC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QUN0QztRQUFFL08sS0FBSztRQUFnQkMsS0FBS3dJO0lBQXNCO0lBQ2xEO1FBQUV6SSxLQUFLO1FBQVNDLEtBQUszTTtJQUFjO0lBQ25DO1FBQUUwTSxLQUFLO1FBQVNDLEtBQUtuTDtJQUFtQjtJQUN4QztRQUFFa0wsS0FBSztRQUFVRSxLQUFLO1FBQWVELEtBQUs4UTtJQUFtQjtDQUNoRSxDQUFDblQsTUFBTSxDQUFDeVQ7QUFDVDs7Ozs7QUFLQSxHQUNBLE1BQU1FLGdCQUFnQjtJQUFFdlIsS0FBSztJQUFPQyxLQUFLMlE7SUFBWVEsT0FBT1A7QUFBVztBQUU4OEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29kZW1pcnJvcitjb21tYW5kc0A2LjEwLjEvbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2NvbW1hbmRzL2Rpc3QvaW5kZXguanM/OGZjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgVHJhbnNhY3Rpb24sIENoYW5nZVNldCwgQ2hhbmdlRGVzYywgRWRpdG9yU2VsZWN0aW9uLCBTdGF0ZUVmZmVjdCwgVGV4dCwgZmluZENsdXN0ZXJCcmVhaywgY291bnRDb2x1bW4sIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgSW5kZW50Q29udGV4dCwgZ2V0SW5kZW50YXRpb24sIGluZGVudFN0cmluZywgbWF0Y2hCcmFja2V0cywgc3ludGF4VHJlZSwgZ2V0SW5kZW50VW5pdCwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIHVzZSBsaW5lIGNvbW1lbnRzXG5pZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQ29tbWVudCA9IHRhcmdldCA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSksIGNvbmZpZyA9IGdldENvbmZpZyh0YXJnZXQuc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIGNvbmZpZy5saW5lID8gdG9nZ2xlTGluZUNvbW1lbnQodGFyZ2V0KSA6IGNvbmZpZy5ibG9jayA/IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSh0YXJnZXQpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gY29tbWFuZChmLCBvcHRpb24pIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBmKG9wdGlvbiwgc3RhdGUpO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUodHIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG5UaGUgbGluZSBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cblRoZSBibG9jayBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGxpbmVzIGFyb3VuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmdcbmJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKChvLCBzKSA9PiBjaGFuZ2VCbG9ja0NvbW1lbnQobywgcywgc2VsZWN0ZWRMaW5lUmFuZ2VzKHMpKSwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG5mdW5jdGlvbiBnZXRDb25maWcoc3RhdGUsIHBvcykge1xuICAgIGxldCBkYXRhID0gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjb21tZW50VG9rZW5zXCIsIHBvcywgMSk7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID8gZGF0YVswXSA6IHt9O1xufVxuY29uc3QgU2VhcmNoTWFyZ2luID0gNTA7XG4vKipcbkRldGVybWluZXMgaWYgdGhlIGdpdmVuIHJhbmdlIGlzIGJsb2NrLWNvbW1lbnRlZCBpbiB0aGUgZ2l2ZW5cbnN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHsgb3BlbiwgY2xvc2UgfSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20gLSBTZWFyY2hNYXJnaW4sIGZyb20pO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyBTZWFyY2hNYXJnaW4pO1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IC9cXHMqJC8uZXhlYyh0ZXh0QmVmb3JlKVswXS5sZW5ndGgsIHNwYWNlQWZ0ZXIgPSAvXlxccyovLmV4ZWModGV4dEFmdGVyKVswXS5sZW5ndGg7XG4gICAgbGV0IGJlZm9yZU9mZiA9IHRleHRCZWZvcmUubGVuZ3RoIC0gc3BhY2VCZWZvcmU7XG4gICAgaWYgKHRleHRCZWZvcmUuc2xpY2UoYmVmb3JlT2ZmIC0gb3Blbi5sZW5ndGgsIGJlZm9yZU9mZikgPT0gb3BlbiAmJlxuICAgICAgICB0ZXh0QWZ0ZXIuc2xpY2Uoc3BhY2VBZnRlciwgc3BhY2VBZnRlciArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gLSBzcGFjZUJlZm9yZSwgbWFyZ2luOiBzcGFjZUJlZm9yZSAmJiAxIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvICsgc3BhY2VBZnRlciwgbWFyZ2luOiBzcGFjZUFmdGVyICYmIDEgfSB9O1xuICAgIH1cbiAgICBsZXQgc3RhcnRUZXh0LCBlbmRUZXh0O1xuICAgIGlmICh0byAtIGZyb20gPD0gMiAqIFNlYXJjaE1hcmdpbikge1xuICAgICAgICBzdGFydFRleHQgPSBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIFNlYXJjaE1hcmdpbik7XG4gICAgICAgIGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyh0byAtIFNlYXJjaE1hcmdpbiwgdG8pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRTcGFjZSA9IC9eXFxzKi8uZXhlYyhzdGFydFRleHQpWzBdLmxlbmd0aCwgZW5kU3BhY2UgPSAvXFxzKiQvLmV4ZWMoZW5kVGV4dClbMF0ubGVuZ3RoO1xuICAgIGxldCBlbmRPZmYgPSBlbmRUZXh0Lmxlbmd0aCAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoO1xuICAgIGlmIChzdGFydFRleHQuc2xpY2Uoc3RhcnRTcGFjZSwgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSA9PSBvcGVuICYmXG4gICAgICAgIGVuZFRleHQuc2xpY2UoZW5kT2ZmLCBlbmRPZmYgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tICsgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChzdGFydFRleHQuY2hhckF0KHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkpID8gMSA6IDAgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3QoZW5kVGV4dC5jaGFyQXQoZW5kT2ZmIC0gMSkpID8gMSA6IDAgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGVkTGluZVJhbmdlcyhzdGF0ZSkge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyLmZyb20pO1xuICAgICAgICBsZXQgdG9MaW5lID0gci50byA8PSBmcm9tTGluZS50byA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvKTtcbiAgICAgICAgaWYgKHRvTGluZS5mcm9tID4gZnJvbUxpbmUuZnJvbSAmJiB0b0xpbmUuZnJvbSA9PSByLnRvKVxuICAgICAgICAgICAgdG9MaW5lID0gci50byA9PSBmcm9tTGluZS50byArIDEgPyBmcm9tTGluZSA6IHN0YXRlLmRvYy5saW5lQXQoci50byAtIDEpO1xuICAgICAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XS50byA+IGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICByYW5nZXNbbGFzdF0udG8gPSB0b0xpbmUudG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogZnJvbUxpbmUuZnJvbSArIC9eXFxzKi8uZXhlYyhmcm9tTGluZS50ZXh0KVswXS5sZW5ndGgsIHRvOiB0b0xpbmUudG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBibG9jayBjb21tZW50cyBpblxuLy8gbGFuZ3VhZ2VzIHRoYXQgc3VwcG9ydCB0aGVtLlxuZnVuY3Rpb24gY2hhbmdlQmxvY2tDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgdG9rZW5zID0gcmFuZ2VzLm1hcChyID0+IGdldENvbmZpZyhzdGF0ZSwgci5mcm9tKS5ibG9jayk7XG4gICAgaWYgKCF0b2tlbnMuZXZlcnkoYyA9PiBjKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNvbW1lbnRzID0gcmFuZ2VzLm1hcCgociwgaSkgPT4gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgdG9rZW5zW2ldLCByLmZyb20sIHIudG8pKTtcbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgIWNvbW1lbnRzLmV2ZXJ5KGMgPT4gYykpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogc3RhdGUuY2hhbmdlcyhyYW5nZXMubWFwKChyYW5nZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiByYW5nZS5mcm9tLCBpbnNlcnQ6IHRva2Vuc1tpXS5vcGVuICsgXCIgXCIgfSwgeyBmcm9tOiByYW5nZS50bywgaW5zZXJ0OiBcIiBcIiArIHRva2Vuc1tpXS5jbG9zZSB9XTtcbiAgICAgICAgICAgIH0pKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgY29tbWVudHMuc29tZShjID0+IGMpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb21tZW50OyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWVudCA9IGNvbW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldLCB7IG9wZW4sIGNsb3NlIH0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG9wZW4ucG9zIC0gdG9rZW4ub3Blbi5sZW5ndGgsIHRvOiBvcGVuLnBvcyArIG9wZW4ubWFyZ2luIH0sIHsgZnJvbTogY2xvc2UucG9zIC0gY2xvc2UubWFyZ2luLCB0bzogY2xvc2UucG9zICsgdG9rZW4uY2xvc2UubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgbGluZSBjb21tZW50cy5cbmZ1bmN0aW9uIGNoYW5nZUxpbmVDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsZXQgcHJldkxpbmUgPSAtMTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydEkgPSBsaW5lcy5sZW5ndGgsIG1pbkluZGVudCA9IDFlOTtcbiAgICAgICAgbGV0IHRva2VuID0gZ2V0Q29uZmlnKHN0YXRlLCBmcm9tKS5saW5lO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IHByZXZMaW5lICYmIChmcm9tID09IHRvIHx8IHRvID4gbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHByZXZMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGVtcHR5ID0gaW5kZW50ID09IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBjb21tZW50ID0gbGluZS50ZXh0LnNsaWNlKGluZGVudCwgaW5kZW50ICsgdG9rZW4ubGVuZ3RoKSA9PSB0b2tlbiA/IGluZGVudCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPCBsaW5lLnRleHQubGVuZ3RoICYmIGluZGVudCA8IG1pbkluZGVudClcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyBsaW5lLCBjb21tZW50LCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5JbmRlbnQgPCAxZTkpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldLmluZGVudCA8IGxpbmVzW2ldLmxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldLmluZGVudCA9IG1pbkluZGVudDtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSBzdGFydEkgKyAxKVxuICAgICAgICAgICAgbGluZXNbc3RhcnRJXS5zaW5nbGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA8IDAgJiYgKCFsLmVtcHR5IHx8IGwuc2luZ2xlKSkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoc2luZ2xlIHx8ICFlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBpbmRlbnQsIGluc2VydDogdG9rZW4gKyBcIiBcIiB9KTtcbiAgICAgICAgbGV0IGNoYW5nZVNldCA9IHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IGNoYW5nZVNldCwgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24ubWFwKGNoYW5nZVNldCwgMSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPj0gMCkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCBjb21tZW50LCB0b2tlbiB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbGluZS5mcm9tICsgY29tbWVudCwgdG8gPSBmcm9tICsgdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBmcm9tSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxuYmVpbmcgY29tYmluZWQgd2l0aCBvdGhlciB0cmFuc2FjdGlvbnMgaW4gdGhlIHVuZG8gaGlzdG9yeS4gR2l2ZW5cbmBcImJlZm9yZVwiYCwgaXQnbGwgcHJldmVudCBtZXJnaW5nIHdpdGggcHJldmlvdXMgdHJhbnNhY3Rpb25zLiBXaXRoXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXG5vbmUuIFdpdGggYFwiZnVsbFwiYCwgdGhlIHRyYW5zYWN0aW9uIGlzIGlzb2xhdGVkIG9uIGJvdGggc2lkZXMuXG4qL1xuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVGhpcyBmYWNldCBwcm92aWRlcyBhIHdheSB0byByZWdpc3RlciBmdW5jdGlvbnMgdGhhdCwgZ2l2ZW4gYVxudHJhbnNhY3Rpb24sIHByb3ZpZGUgYSBzZXQgb2YgZWZmZWN0cyB0aGF0IHRoZSBoaXN0b3J5IHNob3VsZFxuc3RvcmUgd2hlbiBpbnZlcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5pbnRlZ3JhdGUgc29tZSBraW5kcyBvZiBlZmZlY3RzIGluIHRoZSBoaXN0b3J5LCBzbyB0aGF0IHRoZXkgY2FuXG5iZSB1bmRvbmUgKGFuZCByZWRvbmUgYWdhaW4pLlxuKi9cbmNvbnN0IGludmVydGVkRWZmZWN0cyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGhpc3RvcnlDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoX3QsIGlzQWRqYWNlbnQpID0+IGlzQWRqYWNlbnQsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiBNYXRoLm1heCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IE1hdGgubWluLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChhLCBiKSA9PiAodHIsIGFkaikgPT4gYSh0ciwgYWRqKSB8fCBiKHRyLCBhZGopXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgaGlzdG9yeUZpZWxkXyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gSGlzdG9yeVN0YXRlLmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoaGlzdG9yeUNvbmZpZyk7XG4gICAgICAgIGxldCBmcm9tSGlzdCA9IHRyLmFubm90YXRpb24oZnJvbUhpc3RvcnkpO1xuICAgICAgICBpZiAoZnJvbUhpc3QpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0ciwgZnJvbUhpc3Quc2VsZWN0aW9uKSwgZnJvbSA9IGZyb21IaXN0LnNpZGU7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gc3RhdGUudW5kb25lIDogc3RhdGUuZG9uZTtcbiAgICAgICAgICAgIGlmIChpdGVtKVxuICAgICAgICAgICAgICAgIG90aGVyID0gdXBkYXRlQnJhbmNoKG90aGVyLCBvdGhlci5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgaXRlbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3RoZXIgPSBhZGRTZWxlY3Rpb24ob3RoZXIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBmcm9tSGlzdC5yZXN0IDogb3RoZXIsIGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBvdGhlciA6IGZyb21IaXN0LnJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc29sYXRlID0gdHIuYW5ub3RhdGlvbihpc29sYXRlSGlzdG9yeSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJiZWZvcmVcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiAhdHIuY2hhbmdlcy5lbXB0eSA/IHN0YXRlLmFkZE1hcHBpbmcodHIuY2hhbmdlcy5kZXNjKSA6IHN0YXRlO1xuICAgICAgICBsZXQgZXZlbnQgPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnRpbWUpLCB1c2VyRXZlbnQgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKTtcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRTZWxlY3Rpb24odHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICB0b0pTT04odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSwgdW5kb25lOiB2YWx1ZS51bmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSkgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoanNvbi5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pLCBqc29uLnVuZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSk7XG4gICAgfVxufSk7XG4vKipcbkNyZWF0ZSBhIGhpc3RvcnkgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXG4gICAgICAgIGhpc3RvcnlDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICAgICAgICAgIGJlZm9yZWlucHV0KGUsIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgXTtcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHVzZWQgdG8gc3RvcmUgdGhlIGhpc3RvcnkgZGF0YS4gU2hvdWxkIHByb2JhYmx5XG5vbmx5IGJlIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xuW3NlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIG9yXG5bZGVzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHN0YXRlIG9iamVjdHMgaW4gYSB3YXlcbnRoYXQgcHJlc2VydmVzIGhpc3RvcnkuXG4qL1xuY29uc3QgaGlzdG9yeUZpZWxkID0gaGlzdG9yeUZpZWxkXztcbmZ1bmN0aW9uIGNtZChzaWRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHsgc3RhdGUsIGRpc3BhdGNoIH0pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBoaXN0b3J5U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdG9yeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBoaXN0b3J5U3RhdGUucG9wKHNpZGUsIHN0YXRlLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblVuZG8gYSBzaW5nbGUgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXBcbndhcyBhdmFpbGFibGUuXG4qL1xuY29uc3QgdW5kbyA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuUmVkbyBhIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwIHdhc1xuYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHJlZG8gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuVW5kbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHVuZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCB0cnVlKTtcbi8qKlxuUmVkbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHJlZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIHRydWUpO1xuZnVuY3Rpb24gZGVwdGgoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgbGV0IGhpc3RTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBoaXN0U3RhdGUuZG9uZSA6IGhpc3RTdGF0ZS51bmRvbmU7XG4gICAgICAgIHJldHVybiBicmFuY2gubGVuZ3RoIC0gKGJyYW5jaC5sZW5ndGggJiYgIWJyYW5jaFswXS5jaGFuZ2VzID8gMSA6IDApO1xuICAgIH07XG59XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCB1bmRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8pO1xuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgcmVkb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8pO1xuLy8gSGlzdG9yeSBldmVudHMgc3RvcmUgZ3JvdXBzIG9mIGNoYW5nZXMgb3IgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmVcbi8vIHVuZG9uZS9yZWRvbmUgdG9nZXRoZXIuXG5jbGFzcyBIaXN0RXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBjaGFuZ2VzIGluIHRoaXMgZXZlbnQuIE5vcm1hbCBldmVudHMgaG9sZCBhdCBsZWFzdCBvbmVcbiAgICAvLyBjaGFuZ2Ugb3IgZWZmZWN0LiBCdXQgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBzdG9yZSBzZWxlY3Rpb25cbiAgICAvLyBldmVudHMgYmVmb3JlIHRoZSBmaXJzdCBjaGFuZ2UsIGluIHdoaWNoIGNhc2UgYSBzcGVjaWFsIHR5cGUgb2ZcbiAgICAvLyBpbnN0YW5jZSBpcyBjcmVhdGVkIHdoaWNoIGRvZXNuJ3QgaG9sZCBhbnkgY2hhbmdlcywgd2l0aFxuICAgIC8vIGNoYW5nZXMgPT0gc3RhcnRTZWxlY3Rpb24gPT0gdW5kZWZpbmVkXG4gICAgY2hhbmdlcywgXG4gICAgLy8gVGhlIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICBlZmZlY3RzLCBcbiAgICAvLyBBY2N1bXVsYXRlZCBtYXBwaW5nIChmcm9tIGFkZFRvSGlzdG9yeT09ZmFsc2UpIHRoYXQgc2hvdWxkIGJlXG4gICAgLy8gYXBwbGllZCB0byBldmVudHMgYmVsb3cgdGhpcyBvbmUuXG4gICAgbWFwcGVkLCBcbiAgICAvLyBUaGUgc2VsZWN0aW9uIGJlZm9yZSB0aGlzIGV2ZW50XG4gICAgc3RhcnRTZWxlY3Rpb24sIFxuICAgIC8vIFN0b3JlcyBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciB0aGlzIGV2ZW50LCB0byBiZSB1c2VkIGZvclxuICAgIC8vIHNlbGVjdGlvbiB1bmRvL3JlZG8uXG4gICAgc2VsZWN0aW9uc0FmdGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMubWFwcGVkID0gbWFwcGVkO1xuICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0aW9uID0gc3RhcnRTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uc0FmdGVyID0gc2VsZWN0aW9uc0FmdGVyO1xuICAgIH1cbiAgICBzZXRTZWxBZnRlcihhZnRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0aGlzLmNoYW5nZXMsIHRoaXMuZWZmZWN0cywgdGhpcy5tYXBwZWQsIHRoaXMuc3RhcnRTZWxlY3Rpb24sIGFmdGVyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IChfYSA9IHRoaXMuY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpLFxuICAgICAgICAgICAgbWFwcGVkOiAoX2IgPSB0aGlzLm1hcHBlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSlNPTigpLFxuICAgICAgICAgICAgc3RhcnRTZWxlY3Rpb246IChfYyA9IHRoaXMuc3RhcnRTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0pTT04oKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbnNBZnRlcjogdGhpcy5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy50b0pTT04oKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQoanNvbi5jaGFuZ2VzICYmIENoYW5nZVNldC5mcm9tSlNPTihqc29uLmNoYW5nZXMpLCBbXSwganNvbi5tYXBwZWQgJiYgQ2hhbmdlRGVzYy5mcm9tSlNPTihqc29uLm1hcHBlZCksIGpzb24uc3RhcnRTZWxlY3Rpb24gJiYgRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc3RhcnRTZWxlY3Rpb24pLCBqc29uLnNlbGVjdGlvbnNBZnRlci5tYXAoRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKSk7XG4gICAgfVxuICAgIC8vIFRoaXMgZG9lcyBub3QgY2hlY2sgYGFkZFRvSGlzdG9yeWAgYW5kIHN1Y2gsIGl0IGFzc3VtZXMgdGhlXG4gICAgLy8gdHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGFuIGl0ZW0uIFJldHVybnMgbnVsbCB3aGVuXG4gICAgLy8gdGhlcmUgYXJlIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0ciwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gbm9uZTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0IG9mIHRyLnN0YXJ0U3RhdGUuZmFjZXQoaW52ZXJ0ZWRFZmZlY3RzKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGludmVydCh0cik7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBlZmZlY3RzID0gZWZmZWN0cy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoICYmIHRyLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodHIuY2hhbmdlcy5pbnZlcnQodHIuc3RhcnRTdGF0ZS5kb2MpLCBlZmZlY3RzLCB1bmRlZmluZWQsIHNlbGVjdGlvbiB8fCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgbm9uZSk7XG4gICAgfVxuICAgIHN0YXRpYyBzZWxlY3Rpb24oc2VsZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh1bmRlZmluZWQsIG5vbmUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzZWxlY3Rpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVCcmFuY2goYnJhbmNoLCB0bywgbWF4TGVuLCBuZXdFdmVudCkge1xuICAgIGxldCBzdGFydCA9IHRvICsgMSA+IG1heExlbiArIDIwID8gdG8gLSBtYXhMZW4gLSAxIDogMDtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKHN0YXJ0LCB0byk7XG4gICAgbmV3QnJhbmNoLnB1c2gobmV3RXZlbnQpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG5mdW5jdGlvbiBpc0FkamFjZW50KGEsIGIpIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIGlzQWRqYWNlbnQgPSBmYWxzZTtcbiAgICBhLml0ZXJDaGFuZ2VkUmFuZ2VzKChmLCB0KSA9PiByYW5nZXMucHVzaChmLCB0KSk7XG4gICAgYi5pdGVyQ2hhbmdlZFJhbmdlcygoX2YsIF90LCBmLCB0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2krK10sIHRvID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICBpZiAodCA+PSBmcm9tICYmIGYgPD0gdG8pXG4gICAgICAgICAgICAgICAgaXNBZGphY2VudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNBZGphY2VudDtcbn1cbmZ1bmN0aW9uIGVxU2VsZWN0aW9uU2hhcGUoYSwgYikge1xuICAgIHJldHVybiBhLnJhbmdlcy5sZW5ndGggPT0gYi5yYW5nZXMubGVuZ3RoICYmXG4gICAgICAgIGEucmFuZ2VzLmZpbHRlcigociwgaSkgPT4gci5lbXB0eSAhPSBiLnJhbmdlc1tpXS5lbXB0eSkubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gY29uYyhhLCBiKSB7XG4gICAgcmV0dXJuICFhLmxlbmd0aCA/IGIgOiAhYi5sZW5ndGggPyBhIDogYS5jb25jYXQoYik7XG59XG5jb25zdCBub25lID0gW107XG5jb25zdCBNYXhTZWxlY3Rpb25zUGVyRXZlbnQgPSAyMDA7XG5mdW5jdGlvbiBhZGRTZWxlY3Rpb24oYnJhbmNoLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtIaXN0RXZlbnQuc2VsZWN0aW9uKFtzZWxlY3Rpb25dKV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGFzdEV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHNlbHMgPSBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLnNsaWNlKE1hdGgubWF4KDAsIGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gTWF4U2VsZWN0aW9uc1BlckV2ZW50KSk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCAmJiBzZWxzW3NlbHMubGVuZ3RoIC0gMV0uZXEoc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgIHNlbHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdXBkYXRlQnJhbmNoKGJyYW5jaCwgYnJhbmNoLmxlbmd0aCAtIDEsIDFlOSwgbGFzdEV2ZW50LnNldFNlbEFmdGVyKHNlbHMpKTtcbiAgICB9XG59XG4vLyBBc3N1bWVzIHRoZSB0b3AgaXRlbSBoYXMgb25lIG9yIG1vcmUgc2VsZWN0aW9uQWZ0ZXIgdmFsdWVzXG5mdW5jdGlvbiBwb3BTZWxlY3Rpb24oYnJhbmNoKSB7XG4gICAgbGV0IGxhc3QgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2UoKTtcbiAgICBuZXdCcmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdID0gbGFzdC5zZXRTZWxBZnRlcihsYXN0LnNlbGVjdGlvbnNBZnRlci5zbGljZSgwLCBsYXN0LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbi8vIEFkZCBhIG1hcHBpbmcgdG8gdGhlIHRvcCBldmVudCBpbiB0aGUgZ2l2ZW4gYnJhbmNoLiBJZiB0aGlzIG1hcHNcbi8vIGF3YXkgYWxsIHRoZSBjaGFuZ2VzIGFuZCBlZmZlY3RzIGluIHRoYXQgaXRlbSwgZHJvcCBpdCBhbmRcbi8vIHByb3BhZ2F0ZSB0aGUgbWFwcGluZyB0byB0aGUgbmV4dCBpdGVtLlxuZnVuY3Rpb24gYWRkTWFwcGluZ1RvQnJhbmNoKGJyYW5jaCwgbWFwcGluZykge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICBsZXQgbGVuZ3RoID0gYnJhbmNoLmxlbmd0aCwgc2VsZWN0aW9ucyA9IG5vbmU7XG4gICAgd2hpbGUgKGxlbmd0aCkge1xuICAgICAgICBsZXQgZXZlbnQgPSBtYXBFdmVudChicmFuY2hbbGVuZ3RoIC0gMV0sIG1hcHBpbmcsIHNlbGVjdGlvbnMpO1xuICAgICAgICBpZiAoZXZlbnQuY2hhbmdlcyAmJiAhZXZlbnQuY2hhbmdlcy5lbXB0eSB8fCBldmVudC5lZmZlY3RzLmxlbmd0aCkgeyAvLyBFdmVudCBzdXJ2aXZlZCBtYXBwaW5nXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYnJhbmNoLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHRbbGVuZ3RoIC0gMV0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIERyb3AgdGhpcyBldmVudCwgc2luY2UgdGhlcmUncyBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgbGVmdFxuICAgICAgICAgICAgbWFwcGluZyA9IGV2ZW50Lm1hcHBlZDtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IGV2ZW50LnNlbGVjdGlvbnNBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9ucy5sZW5ndGggPyBbSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKV0gOiBub25lO1xufVxuZnVuY3Rpb24gbWFwRXZlbnQoZXZlbnQsIG1hcHBpbmcsIGV4dHJhU2VsZWN0aW9ucykge1xuICAgIGxldCBzZWxlY3Rpb25zID0gY29uYyhldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoID8gZXZlbnQuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKSA6IG5vbmUsIGV4dHJhU2VsZWN0aW9ucyk7XG4gICAgLy8gQ2hhbmdlLWxlc3MgZXZlbnRzIGRvbid0IHN0b3JlIG1hcHBpbmdzICh0aGV5IGFyZSBhbHdheXMgdGhlIGxhc3QgZXZlbnQgaW4gYSBicmFuY2gpXG4gICAgaWYgKCFldmVudC5jaGFuZ2VzKVxuICAgICAgICByZXR1cm4gSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKTtcbiAgICBsZXQgbWFwcGVkQ2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMubWFwKG1hcHBpbmcpLCBiZWZvcmUgPSBtYXBwaW5nLm1hcERlc2MoZXZlbnQuY2hhbmdlcywgdHJ1ZSk7XG4gICAgbGV0IGZ1bGxNYXBwaW5nID0gZXZlbnQubWFwcGVkID8gZXZlbnQubWFwcGVkLmNvbXBvc2VEZXNjKGJlZm9yZSkgOiBiZWZvcmU7XG4gICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQobWFwcGVkQ2hhbmdlcywgU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhldmVudC5lZmZlY3RzLCBtYXBwaW5nKSwgZnVsbE1hcHBpbmcsIGV2ZW50LnN0YXJ0U2VsZWN0aW9uLm1hcChiZWZvcmUpLCBzZWxlY3Rpb25zKTtcbn1cbmNvbnN0IGpvaW5hYmxlVXNlckV2ZW50ID0gL14oaW5wdXRcXC50eXBlfGRlbGV0ZSkoJHxcXC4pLztcbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2VGltZSA9IDAsIHByZXZVc2VyRXZlbnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2VXNlckV2ZW50ID0gcHJldlVzZXJFdmVudDtcbiAgICB9XG4gICAgaXNvbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldlRpbWUgPyBuZXcgSGlzdG9yeVN0YXRlKHRoaXMuZG9uZSwgdGhpcy51bmRvbmUpIDogdGhpcztcbiAgICB9XG4gICAgYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKSB7XG4gICAgICAgIGxldCBkb25lID0gdGhpcy5kb25lLCBsYXN0RXZlbnQgPSBkb25lW2RvbmUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0RXZlbnQgJiYgbGFzdEV2ZW50LmNoYW5nZXMgJiYgIWxhc3RFdmVudC5jaGFuZ2VzLmVtcHR5ICYmIGV2ZW50LmNoYW5nZXMgJiZcbiAgICAgICAgICAgICghdXNlckV2ZW50IHx8IGpvaW5hYmxlVXNlckV2ZW50LnRlc3QodXNlckV2ZW50KSkgJiZcbiAgICAgICAgICAgICgoIWxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBjb25maWcubmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5qb2luVG9FdmVudCh0ciwgaXNBZGphY2VudChsYXN0RXZlbnQuY2hhbmdlcywgZXZlbnQuY2hhbmdlcykpKSB8fFxuICAgICAgICAgICAgICAgIC8vIEZvciBjb21wb3NlIChidXQgbm90IGNvbXBvc2Uuc3RhcnQpIGV2ZW50cywgYWx3YXlzIGpvaW4gd2l0aCBwcmV2aW91cyBldmVudFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudCA9PSBcImlucHV0LnR5cGUuY29tcG9zZVwiKSkge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCAtIDEsIGNvbmZpZy5taW5EZXB0aCwgbmV3IEhpc3RFdmVudChldmVudC5jaGFuZ2VzLmNvbXBvc2UobGFzdEV2ZW50LmNoYW5nZXMpLCBjb25jKFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmNoYW5nZXMpLCBsYXN0RXZlbnQuZWZmZWN0cyksIGxhc3RFdmVudC5tYXBwZWQsIGxhc3RFdmVudC5zdGFydFNlbGVjdGlvbiwgbm9uZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZG9uZSwgbm9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkU2VsZWN0aW9uKHNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBuZXdHcm91cERlbGF5KSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb25lLmxlbmd0aCA/IHRoaXMuZG9uZVt0aGlzLmRvbmUubGVuZ3RoIC0gMV0uc2VsZWN0aW9uc0FmdGVyIDogbm9uZTtcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBuZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICB1c2VyRXZlbnQgPT0gdGhpcy5wcmV2VXNlckV2ZW50ICYmIHVzZXJFdmVudCAmJiAvXnNlbGVjdCgkfFxcLikvLnRlc3QodXNlckV2ZW50KSAmJlxuICAgICAgICAgICAgZXFTZWxlY3Rpb25TaGFwZShsYXN0W2xhc3QubGVuZ3RoIC0gMV0sIHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkU2VsZWN0aW9uKHRoaXMuZG9uZSwgc2VsZWN0aW9uKSwgdGhpcy51bmRvbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRNYXBwaW5nVG9CcmFuY2godGhpcy5kb25lLCBtYXBwaW5nKSwgYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMudW5kb25lLCBtYXBwaW5nKSwgdGhpcy5wcmV2VGltZSwgdGhpcy5wcmV2VXNlckV2ZW50KTtcbiAgICB9XG4gICAgcG9wKHNpZGUsIHN0YXRlLCBvbmx5U2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gdGhpcy5kb25lIDogdGhpcy51bmRvbmU7XG4gICAgICAgIGlmIChicmFuY2gubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyWzBdIHx8IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG9ubHlTZWxlY3Rpb24gJiYgZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3Q6IHBvcFNlbGVjdGlvbihicmFuY2gpLCBzZWxlY3Rpb24gfSksXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJzZWxlY3QudW5kb1wiIDogXCJzZWxlY3QucmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZXZlbnQuY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdCA9IGJyYW5jaC5sZW5ndGggPT0gMSA/IG5vbmUgOiBicmFuY2guc2xpY2UoMCwgYnJhbmNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN0ID0gYWRkTWFwcGluZ1RvQnJhbmNoKHJlc3QsIGV2ZW50Lm1hcHBlZCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBldmVudC5jaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc3RhcnRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogZXZlbnQuZWZmZWN0cyxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0LCBzZWxlY3Rpb24gfSksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInVuZG9cIiA6IFwicmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkhpc3RvcnlTdGF0ZS5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgSGlzdG9yeVN0YXRlKG5vbmUsIG5vbmUpO1xuLyoqXG5EZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIHVuZG8gaGlzdG9yeS5cblxuLSBNb2QtejogW2B1bmRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvKS5cbi0gTW9kLXkgKE1vZC1TaGlmdC16IG9uIG1hY09TKSArIEN0cmwtU2hpZnQteiBvbiBMaW51eDogW2ByZWRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvKS5cbi0gTW9kLXU6IFtgdW5kb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kb1NlbGVjdGlvbikuXG4tIEFsdC11IChNb2QtU2hpZnQtdSBvbiBtYWNPUyk6IFtgcmVkb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkb1NlbGVjdGlvbikuXG4qL1xuY29uc3QgaGlzdG9yeUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtelwiLCBydW46IHVuZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXlcIiwgbWFjOiBcIk1vZC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGxpbnV4OiBcIkN0cmwtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXVcIiwgcnVuOiB1bmRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFsdC11XCIsIG1hYzogXCJNb2QtU2hpZnQtdVwiLCBydW46IHJlZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH1cbl07XG5cbmZ1bmN0aW9uIHVwZGF0ZVNlbChzZWwsIGJ5KSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5tYXAoYnkpLCBzZWwubWFpbkluZGV4KTtcbn1cbmZ1bmN0aW9uIHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KTtcbn1cbmZ1bmN0aW9uIG1vdmVTZWwoeyBzdGF0ZSwgZGlzcGF0Y2ggfSwgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIGhvdyk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24sIHRydWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG5mdW5jdGlvbiBsdHJBdEN1cnNvcih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbkF0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkgPT0gRGlyZWN0aW9uLkxUUjtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgKHdoaWNoIGlzIGJhY2t3YXJkIGluXG5sZWZ0LXRvLXJpZ2h0IHRleHQsIGZvcndhcmQgaW4gcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiovXG5jb25zdCBjdXJzb3JDaGFyTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JDaGFyUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gYnlDaGFyTG9naWNhbChzdGF0ZSwgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIHBvcyA9IGZvcndhcmQgPyBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgOiBNYXRoLm1heCgwLCBsaW5lLmZyb20gLSAxKTtcbiAgICBlbHNlXG4gICAgICAgIHBvcyA9IGxpbmUuZnJvbSArIGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG5mdW5jdGlvbiBtb3ZlQnlDaGFyTG9naWNhbCh0YXJnZXQsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh0YXJnZXQsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQsIGluIGxvZ2ljYWxcbihub24tdGV4dC1kaXJlY3Rpb24tYXdhcmUpIHN0cmluZyBpbmRleCBvcmRlci5cbiovXG5jb25zdCBjdXJzb3JDaGFyRm9yd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gbW92ZUJ5Q2hhckxvZ2ljYWwodGFyZ2V0LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQsIGluIGxvZ2ljYWwgc3RyaW5nIGluZGV4XG5vcmRlci5cbiovXG5jb25zdCBjdXJzb3JDaGFyQmFja3dhcmRMb2dpY2FsID0gdGFyZ2V0ID0+IG1vdmVCeUNoYXJMb2dpY2FsKHRhcmdldCwgZmFsc2UpO1xuZnVuY3Rpb24gY3Vyc29yQnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbGVmdCBhY3Jvc3Mgb25lIGdyb3VwIG9mIHdvcmQgb3Jcbm5vbi13b3JkIChidXQgYWxzbyBub24tc3BhY2UpIGNoYXJhY3RlcnMuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gdG9Hcm91cFN0YXJ0KHZpZXcsIHBvcywgc3RhcnQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUoc3RhcnQpLCBpbml0aWFsID0gY2F0ICE9IENoYXJDYXRlZ29yeS5TcGFjZTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAobmV4dENhdCAhPSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbCAmJiBuZXh0Q2F0ID09IGNhdDtcbiAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb25lIGdyb3VwIGZvcndhcmQgaW4gdGhlIGRlZmF1bHQgV2luZG93cyBzdHlsZSxcbndoZXJlIGl0IG1vdmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBncm91cC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEZvcndhcmRXaW4gPSB2aWV3ID0+IHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eVxuICAgICAgICA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgdHJ1ZSwgc3RhcnQgPT4gdG9Hcm91cFN0YXJ0KHZpZXcsIHJhbmdlLmhlYWQsIHN0YXJ0KSlcbiAgICAgICAgOiByYW5nZUVuZChyYW5nZSwgdHJ1ZSkpO1xufTtcbmNvbnN0IHNlZ21lbnRlciA9IHR5cGVvZiBJbnRsICE9IFwidW5kZWZpbmVkXCIgJiYgSW50bC5TZWdtZW50ZXIgP1xuICAgIC8qQF9fUFVSRV9fKi9uZXcgKEludGwuU2VnbWVudGVyKSh1bmRlZmluZWQsIHsgZ3JhbnVsYXJpdHk6IFwid29yZFwiIH0pIDogbnVsbDtcbmZ1bmN0aW9uIG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmZyb20pO1xuICAgIGxldCBjYXQgPSBDaGFyQ2F0ZWdvcnkuU3BhY2UsIHBvcyA9IHJhbmdlLmZyb20sIHN0ZXBzID0gMDtcbiAgICBsZXQgZG9uZSA9IGZhbHNlLCBzYXdVcHBlciA9IGZhbHNlLCBzYXdMb3dlciA9IGZhbHNlO1xuICAgIGxldCBzdGVwID0gKG5leHQpID0+IHtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvcyArPSBmb3J3YXJkID8gbmV4dC5sZW5ndGggOiAtbmV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KSwgYWhlYWQ7XG4gICAgICAgIGlmIChuZXh0Q2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIG5leHQuY2hhckNvZGVBdCgwKSA8IDEyOCAmJiAvW1xcV19dLy50ZXN0KG5leHQpKVxuICAgICAgICAgICAgbmV4dENhdCA9IC0xOyAvLyBUcmVhdCB3b3JkIHB1bmN0dWF0aW9uIHNwZWNpYWxseVxuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIGlmIChjYXQgIT0gbmV4dENhdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKG5leHQudG9Mb3dlckNhc2UoKSA9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3J3YXJkICYmIHNhd1VwcGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2F3TG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2F3TG93ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1VwcGVyICYmIGZvcndhcmQgJiYgY2F0ZWdvcml6ZShhaGVhZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgYWhlYWQudG9Mb3dlckNhc2UoKSA9PSBhaGVhZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGVwcysrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGxldCBlbmQgPSB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQsIHN0YXJ0ID0+IHtcbiAgICAgICAgc3RlcChzdGFydCk7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0pO1xuICAgIGlmIChzZWdtZW50ZXIgJiYgY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIGVuZC5mcm9tID09IHJhbmdlLmZyb20gKyBzdGVwcyAqIChmb3J3YXJkID8gMSA6IC0xKSkge1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHJhbmdlLmhlYWQsIGVuZC5oZWFkKSwgdG8gPSBNYXRoLm1heChyYW5nZS5oZWFkLCBlbmQuaGVhZCk7XG4gICAgICAgIGxldCBza2lwcGVkID0gdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDEgJiYgL1tcXHU0RTAwLVxcdWZmZmZdLy50ZXN0KHNraXBwZWQpKSB7XG4gICAgICAgICAgICBsZXQgc2VnbWVudHMgPSBBcnJheS5mcm9tKHNlZ21lbnRlci5zZWdtZW50KHNraXBwZWQpKTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBzZWdtZW50c1sxXS5pbmRleCwgLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGVuZC5oZWFkICsgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihzdGFydC5oZWFkKTtcbiAgICBsZXQgYnJhY2tldFByb3AgPSBmb3J3YXJkID8gTm9kZVByb3AuY2xvc2VkQnkgOiBOb2RlUHJvcC5vcGVuZWRCeTtcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xuICAgIC8vIG5vZGUgYWhlYWQuXG4gICAgZm9yIChsZXQgYXQgPSBzdGFydC5oZWFkOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gbWF0Y2guZW5kLnRvIDogbWF0Y2guZW5kLmZyb207XG4gICAgZWxzZVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gcGFnZUluZm8odmlldykge1xuICAgIGxldCBzZWxmU2Nyb2xsID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IDwgdmlldy5zY3JvbGxET00uc2Nyb2xsSGVpZ2h0IC0gMjtcbiAgICBsZXQgbWFyZ2luVG9wID0gMCwgbWFyZ2luQm90dG9tID0gMCwgaGVpZ2h0O1xuICAgIGlmIChzZWxmU2Nyb2xsKSB7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgICAgIGxldCBtYXJnaW5zID0gc291cmNlKHZpZXcpO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3ApXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gTWF0aC5tYXgobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLnRvcCwgbWFyZ2luVG9wKTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tKVxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy5ib3R0b20sIG1hcmdpbkJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gKHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIHNlbGZTY3JvbGwsXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgodmlldy5kZWZhdWx0TGluZUhlaWdodCwgaGVpZ2h0IC0gNSkgfTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBhZ2UgPSBwYWdlSW5mbyh2aWV3KTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlLmhlaWdodClcbiAgICAgICAgICAgIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3Q7XG4gICAgaWYgKHBhZ2Uuc2VsZlNjcm9sbCkge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgc2Nyb2xsUmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsUmVjdC50b3AgKyBwYWdlLm1hcmdpblRvcCwgc2Nyb2xsQm90dG9tID0gc2Nyb2xsUmVjdC5ib3R0b20gLSBwYWdlLm1hcmdpbkJvdHRvbTtcbiAgICAgICAgaWYgKHN0YXJ0UG9zICYmIHN0YXJ0UG9zLnRvcCA+IHNjcm9sbFRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxCb3R0b20pXG4gICAgICAgICAgICBlZmZlY3QgPSBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxUb3AgfSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8sIC0xKSk7XG5mdW5jdGlvbiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgMSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmcgfHwgIW1hdGNoaW5nLmVuZClcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsZXQgaGVhZCA9IG1hdGNoaW5nLnN0YXJ0LmZyb20gPT0gcmFuZ2UuaGVhZCA/IG1hdGNoaW5nLmVuZC50byA6IG1hdGNoaW5nLmVuZC5mcm9tO1xuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodGFyZ2V0LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHRhcmdldC5zdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGhlYWQgPSBob3cocmFuZ2UpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4sIGhlYWQuYmlkaUxldmVsIHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcSh0YXJnZXQuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaChzZXRTZWwodGFyZ2V0LnN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCwgd2hpbGUgbGVhdmluZ1xudGhlIGFuY2hvciBpbiBwbGFjZS5cbiovXG5jb25zdCBzZWxlY3RDaGFyTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQgYnkgbG9naWNhbFxuKG5vbi1kaXJlY3Rpb24gYXdhcmUpIHN0cmluZyBpbmRleCBvcmRlci5cbiovXG5jb25zdCBzZWxlY3RDaGFyRm9yd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gZXh0ZW5kU2VsKHRhcmdldCwgcmFuZ2UgPT4gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQgYnkgbG9naWNhbCBzdHJpbmdcbmluZGV4IG9yZGVyLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJCYWNrd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gZXh0ZW5kU2VsKHRhcmdldCwgcmFuZ2UgPT4gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCBmYWxzZSkpO1xuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBbZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSB0b1xudGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgZm9yd2FyZCBpbiB0aGUgZGVmYXVsdCBXaW5kb3dzXG5zdHlsZSwgc2tpcHBpbmcgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZFdpbiA9IHZpZXcgPT4ge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCB0cnVlLCBzdGFydCA9PiB0b0dyb3VwU3RhcnQodmlldywgcmFuZ2UuaGVhZCwgc3RhcnQpKSk7XG59O1xuZnVuY3Rpb24gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBzZWxlY3RCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBzZWxlY3RMaW5lVXAgPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0TGluZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSW5mbyh2aWV3KS5oZWlnaHQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgdXAuXG4qL1xuY29uc3Qgc2VsZWN0UGFnZVVwID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VEb3duID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgcHJldmlvdXMgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVTdGFydCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUVuZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cbiovXG5jb25zdCBzZWxlY3RMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgbmV4dCBzeW50YWN0aWMgY29uc3RydWN0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXG5bcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2UpIHlvdSB1c2UgYnVpbGRzIHVwIGEgZnVsbFxuc3ludGF4IHRyZWUuXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50U3ludGF4ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBzdGFjayA9IHRyZWUucmVzb2x2ZVN0YWNrKHJhbmdlLmZyb20sIDEpO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBzdGFja0JlZm9yZSA9IHRyZWUucmVzb2x2ZVN0YWNrKHJhbmdlLmZyb20sIC0xKTtcbiAgICAgICAgICAgIGlmIChzdGFja0JlZm9yZS5ub2RlLmZyb20gPj0gc3RhY2subm9kZS5mcm9tICYmIHN0YWNrQmVmb3JlLm5vZGUudG8gPD0gc3RhY2subm9kZS50bylcbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrQmVmb3JlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YWNrOyBjdXI7IGN1ciA9IGN1ci5uZXh0KSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlIH0gPSBjdXI7XG4gICAgICAgICAgICBpZiAoKChub2RlLmZyb20gPCByYW5nZS5mcm9tICYmIG5vZGUudG8gPj0gcmFuZ2UudG8pIHx8XG4gICAgICAgICAgICAgICAgKG5vZGUudG8gPiByYW5nZS50byAmJiBub2RlLmZyb20gPD0gcmFuZ2UuZnJvbSkpICYmXG4gICAgICAgICAgICAgICAgY3VyLm5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShub2RlLnRvLCBub2RlLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGFkZEN1cnNvclZlcnRpY2FsbHkodmlldywgZm9yd2FyZCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc2xpY2UoKTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBsaW5lLnRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogbGluZS5mcm9tID4gMClcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHJhbmdlOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHZpZXcubW92ZVZlcnRpY2FsbHkoY3VyLCBmb3J3YXJkKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5oZWFkIDwgbGluZS5mcm9tIHx8IG5leHQuaGVhZCA+IGxpbmUudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYW5nZXMuc29tZShyID0+IHIuaGVhZCA9PSBuZXh0LmhlYWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0LmhlYWQgPT0gY3VyLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHNldFNlbChzdGF0ZSwgRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHJhbmdlcy5sZW5ndGggLSAxKSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5FeHBhbmQgdGhlIHNlbGVjdGlvbiBieSBhZGRpbmcgYSBjdXJzb3IgYWJvdmUgdGhlIGhlYWRzIG9mXG5jdXJyZW50bHkgc2VsZWN0ZWQgcmFuZ2VzLlxuKi9cbmNvbnN0IGFkZEN1cnNvckFib3ZlID0gdmlldyA9PiBhZGRDdXJzb3JWZXJ0aWNhbGx5KHZpZXcsIGZhbHNlKTtcbi8qKlxuRXhwYW5kIHRoZSBzZWxlY3Rpb24gYnkgYWRkaW5nIGEgY3Vyc29yIGJlbG93IHRoZSBoZWFkcyBvZlxuY3VycmVudGx5IHNlbGVjdGVkIHJhbmdlcy5cbiovXG5jb25zdCBhZGRDdXJzb3JCZWxvdyA9IHZpZXcgPT4gYWRkQ3Vyc29yVmVydGljYWxseSh2aWV3LCB0cnVlKTtcbi8qKlxuU2ltcGxpZnkgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaGVuIG11bHRpcGxlIHJhbmdlcyBhcmUgc2VsZWN0ZWQsXG5yZWR1Y2UgaXQgdG8gaXRzIG1haW4gcmFuZ2UuIE90aGVyd2lzZSwgaWYgdGhlIHNlbGVjdGlvbiBpc1xubm9uLWVtcHR5LCBjb252ZXJ0IGl0IHRvIGEgY3Vyc29yIHNlbGVjdGlvbi5cbiovXG5jb25zdCBzaW1wbGlmeVNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGN1ciA9IHN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoY3VyLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtjdXIubWFpbl0pO1xuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXIubWFpbi5oZWFkKV0pO1xuICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWxldGVCeSh0YXJnZXQsIGJ5KSB7XG4gICAgaWYgKHRhcmdldC5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBldmVudCA9IFwiZGVsZXRlLnNlbGVjdGlvblwiLCB7IHN0YXRlIH0gPSB0YXJnZXQ7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICAgICAgICBpZiAoZnJvbSA9PSB0bykge1xuICAgICAgICAgICAgbGV0IHRvd2FyZHMgPSBieShyYW5nZSk7XG4gICAgICAgICAgICBpZiAodG93YXJkcyA8IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmJhY2t3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3dhcmRzID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuZm9yd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gTWF0aC5taW4oZnJvbSwgdG93YXJkcyk7XG4gICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCB0b3dhcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBza2lwQXRvbWljKHRhcmdldCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICAgICAgdG8gPSBza2lwQXRvbWljKHRhcmdldCwgdG8sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tID09IHRvID8geyByYW5nZSB9IDogeyBjaGFuZ2VzOiB7IGZyb20sIHRvIH0sIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20sIGZyb20gPCByYW5nZS5oZWFkID8gLTEgOiAxKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogZXZlbnQsXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCwgYnlJbmRlbnRVbml0KSA9PiBkZWxldGVCeSh0YXJnZXQsIHJhbmdlID0+IHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiZWZvcmUsIHRhcmdldFBvcztcbiAgICBpZiAoYnlJbmRlbnRVbml0ICYmICFmb3J3YXJkICYmIHBvcyA+IGxpbmUuZnJvbSAmJiBwb3MgPCBsaW5lLmZyb20gKyAyMDAgJiZcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xuICAgICAgICBpZiAoYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXSA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBvcyAtIDE7XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihiZWZvcmUsIHN0YXRlLnRhYlNpemUpLCBkcm9wID0gY29sICUgZ2V0SW5kZW50VW5pdChzdGF0ZSkgfHwgZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcCAmJiBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDEgLSBpXSA9PSBcIiBcIjsgaSsrKVxuICAgICAgICAgICAgcG9zLS07XG4gICAgICAgIHRhcmdldFBvcyA9IHBvcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQsIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBpZiAodGFyZ2V0UG9zID09IHBvcyAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKCFmb3J3YXJkICYmIC9bXFx1ZmUwMC1cXHVmZTBmXS8udGVzdChsaW5lLnRleHQuc2xpY2UodGFyZ2V0UG9zIC0gbGluZS5mcm9tLCBwb3MgLSBsaW5lLmZyb20pKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0YXJnZXRQb3MgLSBsaW5lLmZyb20sIGZhbHNlLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRQb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjaGFyYWN0ZXIgb3JcbmluZGVudGF0aW9uIHVuaXQgYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UsIHRydWUpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciB0aGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgY3Vyc29yLiBEb2VzIG5vdFxuaW1wbGVtZW50IGFueSBleHRlbmRlZCBiZWhhdmlvciBsaWtlIGRlbGV0aW5nIHdob2xlIGluZGVudGF0aW9uXG51bml0cyBpbiBvbmUgZ28uXG4qL1xuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkU3RyaWN0ID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgdHJ1ZSwgZmFsc2UpO1xuY29uc3QgZGVsZXRlQnlHcm91cCA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgcmFuZ2UgPT4ge1xuICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBmb3IgKGxldCBjYXQgPSBudWxsOzspIHtcbiAgICAgICAgaWYgKHBvcyA9PSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICBpZiAocG9zID09IHJhbmdlLmhlYWQgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCBuZXh0Q2hhciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihwb3MsIG5leHQpIC0gbGluZS5mcm9tLCBNYXRoLm1heChwb3MsIG5leHQpIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHRDaGFyKTtcbiAgICAgICAgaWYgKGNhdCAhPSBudWxsICYmIG5leHRDYXQgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPSBcIiBcIiB8fCBwb3MgIT0gcmFuZ2UuaGVhZClcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcblZhcmlhbnQgb2YgW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbnRoYXQgdXNlcyB0aGUgV2luZG93cyBjb252ZW50aW9uIG9mIGFsc28gZGVsZXRpbmcgdGhlIHdoaXRlc3BhY2VcbmFmdGVyIGEgd29yZC5cbiovXG5jb25zdCBkZWxldGVHcm91cEZvcndhcmRXaW4gPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgdHJ1ZSwgc3RhcnQgPT4gdG9Hcm91cFN0YXJ0KHZpZXcsIHJhbmdlLmhlYWQsIHN0YXJ0KSkuaGVhZCk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZUVuZCA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG87XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPCBsaW5lRW5kID8gbGluZUVuZCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcmFuZ2UuaGVhZCArIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYmVmb3JlIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZVN0YXJ0ID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHJhbmdlLmhlYWQgLSAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUgb3IgdGhlIG5leHQgbGluZSB3cmFwIGJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmYWxzZSkuaGVhZDtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHJhbmdlLmhlYWQgLSAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgZW5kIG9mIHRoZSBsaW5lIG9yIHRoZSBuZXh0IGxpbmUgd3JhcCBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIHRydWUpLmhlYWQ7XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPCBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHJhbmdlLmhlYWQgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgYWxsIHdoaXRlc3BhY2UgZGlyZWN0bHkgYmVmb3JlIGEgbGluZSBlbmQgZnJvbSB0aGVcbmRvY3VtZW50LlxuKi9cbmNvbnN0IGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBwcmV2ID0gXCJcIiwgaXRlciA9IHN0YXRlLmRvYy5pdGVyKCk7Oykge1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXIubGluZUJyZWFrIHx8IGl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nID0gcHJldi5zZWFyY2goL1xccyskLyk7XG4gICAgICAgICAgICBpZiAodHJhaWxpbmcgPiAtMSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBwb3MgLSAocHJldi5sZW5ndGggLSB0cmFpbGluZyksIHRvOiBwb3MgfSk7XG4gICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHJldiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2ID0gaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gaXRlci52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCB1c2VyRXZlbnQ6IFwiZGVsZXRlXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSBlYWNoIHNlbGVjdGlvbiByYW5nZSB3aXRoIGEgbGluZSBicmVhaywgbGVhdmluZyB0aGUgY3Vyc29yXG5vbiB0aGUgbGluZSBiZWZvcmUgdGhlIGJyZWFrLlxuKi9cbmNvbnN0IHNwbGl0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogVGV4dC5vZihbXCJcIiwgXCJcIl0pIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tKSB9O1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5GbGlwIHRoZSBjaGFyYWN0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnNvcihzKS5cbiovXG5jb25zdCB0cmFuc3Bvc2VDaGFycyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCByYW5nZS5mcm9tID09IDAgfHwgcmFuZ2UuZnJvbSA9PSBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gcG9zID09IGxpbmUuZnJvbSA/IHBvcyAtIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCB0byA9IHBvcyA9PSBsaW5lLnRvID8gcG9zICsgMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIHRydWUpICsgbGluZS5mcm9tO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShwb3MsIHRvKS5hcHBlbmQoc3RhdGUuZG9jLnNsaWNlKGZyb20sIHBvcykpIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bykgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJtb3ZlLmNoYXJhY3RlclwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpIHtcbiAgICBsZXQgYmxvY2tzID0gW10sIHVwdG8gPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLCBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byk7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgcmFuZ2UudG8gPT0gZW5kTGluZS5mcm9tKVxuICAgICAgICAgICAgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8gLSAxKTtcbiAgICAgICAgaWYgKHVwdG8gPj0gc3RhcnRMaW5lLm51bWJlcikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcHJldi50byA9IGVuZExpbmUudG87XG4gICAgICAgICAgICBwcmV2LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHsgZnJvbTogc3RhcnRMaW5lLmZyb20sIHRvOiBlbmRMaW5lLnRvLCByYW5nZXM6IFtyYW5nZV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXB0byA9IGVuZExpbmUubnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcztcbn1cbmZ1bmN0aW9uIG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZS5kb2MubGVuZ3RoIDogYmxvY2suZnJvbSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBuZXh0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZm9yd2FyZCA/IGJsb2NrLnRvICsgMSA6IGJsb2NrLmZyb20gLSAxKTtcbiAgICAgICAgbGV0IHNpemUgPSBuZXh0TGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIHRvOiBuZXh0TGluZS50byB9LCB7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogbmV4dExpbmUudGV4dCArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmFuY2hvciArIHNpemUpLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmhlYWQgKyBzaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dExpbmUuZnJvbSwgdG86IGJsb2NrLmZyb20gfSwgeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBuZXh0TGluZS50ZXh0IH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuYW5jaG9yIC0gc2l6ZSwgci5oZWFkIC0gc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc3RhdGUuc2VsZWN0aW9uLm1haW5JbmRleCksXG4gICAgICAgIHVzZXJFdmVudDogXCJtb3ZlLmxpbmVcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgdXAgb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgZG93biBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSB9KTtcbiAgICB9XG4gICAgbGV0IGNoYW5nZVNldCA9IHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgY2hhbmdlczogY2hhbmdlU2V0LFxuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5tYXAoY2hhbmdlU2V0LCBmb3J3YXJkID8gMSA6IC0xKSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5jb3B5bGluZVwiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSB0b3AgY29weS5cbiovXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSBib3R0b20gY29weS5cbiovXG5jb25zdCBjb3B5TGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9KSk7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGRpc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKSwgcG9zID0gdmlldy5jb29yZHNBdFBvcyhyYW5nZS5oZWFkLCByYW5nZS5hc3NvYyB8fCAxKTtcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgZGlzdCA9IChibG9jay5ib3R0b20gKyB2aWV3LmRvY3VtZW50VG9wKSAtIHBvcy5ib3R0b20gKyB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgdHJ1ZSwgZGlzdCk7XG4gICAgfSkubWFwKGNoYW5nZXMpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzLCBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmxpbmVcIiB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZS5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihzdGF0ZS5saW5lQnJlYWspLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIHRoZSBzYW1lIGFtb3VudCBvZlxuaW5kZW50YXRpb24gYXMgdGhlIGxpbmUgYWJvdmUuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUtlZXBJbmRlbnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLnRleHQpWzBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgaW5kZW50IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgaW5kZW50Lmxlbmd0aCArIDEpXG4gICAgICAgIH07XG4gICAgfSksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyk7XG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XG4gICAgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBiZWZvcmUudG8gPD0gcG9zICYmIGFmdGVyLmZyb20gPj0gcG9zICYmXG4gICAgICAgIChjbG9zZWRCeSA9IGJlZm9yZS50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSAmJiBjbG9zZWRCeS5pbmRleE9mKGFmdGVyLm5hbWUpID4gLTEgJiZcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tICYmXG4gICAgICAgICEvXFxTLy50ZXN0KHN0YXRlLnNsaWNlRG9jKGJlZm9yZS50bywgYWZ0ZXIuZnJvbSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBiZWZvcmUudG8sIHRvOiBhZnRlci5mcm9tIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgaW5kZW50IHRoZSBuZXdseSBjcmVhdGVkXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xud2lsbCBhbHNvIGRlbGV0ZSB0aGF0IHdoaXRlc3BhY2UuIFdoZW4gdGhlIGN1cnNvciBpcyBiZXR3ZWVuXG5tYXRjaGluZyBicmFja2V0cywgYW4gYWRkaXRpb25hbCBuZXdsaW5lIHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXJcbnRoZSBjdXJzb3IuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgYmxhbmssIGluZGVudGVkIGxpbmUgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS5cbiovXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGF0RW9mKVxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcbiAgICAgICAgICAgIGxldCBjeCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gY291bnRDb2x1bW4oL15cXHMqLy5leGVjKHN0YXRlLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0sIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0pKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gZXhwbG9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcbiAgICAgICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IFtcIlwiLCBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goaW5kZW50U3RyaW5nKHN0YXRlLCBjeC5saW5lSW5kZW50KGxpbmUuZnJvbSwgLTEpKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YoaW5zZXJ0KSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmZyb207IHBvcyA8PSByYW5nZS50bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBmKGxpbmUsIGNoYW5nZXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBhdExpbmUgPSBsaW5lLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChpbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihzcGFjZSwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBnZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkVuYWJsZXMgb3IgZGlzYWJsZXNcblt0YWItZm9jdXMgbW9kZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2V0VGFiRm9jdXNNb2RlKS4gV2hpbGUgb24sIHRoaXNcbnByZXZlbnRzIHRoZSBlZGl0b3IncyBrZXkgYmluZGluZ3MgZnJvbSBjYXB0dXJpbmcgVGFiIG9yXG5TaGlmdC1UYWIsIG1ha2luZyBpdCBwb3NzaWJsZSBmb3IgdGhlIHVzZXIgdG8gbW92ZSBmb2N1cyBvdXQgb2ZcbnRoZSBlZGl0b3Igd2l0aCB0aGUga2V5Ym9hcmQuXG4qL1xuY29uc3QgdG9nZ2xlVGFiRm9jdXNNb2RlID0gdmlldyA9PiB7XG4gICAgdmlldy5zZXRUYWJGb2N1c01vZGUoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblRlbXBvcmFyaWx5IGVuYWJsZXMgW3RhYi1mb2N1c1xubW9kZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuc2V0VGFiRm9jdXNNb2RlKSBmb3IgdHdvIHNlY29uZHMgb3IgdW50aWxcbmFub3RoZXIga2V5IGlzIHByZXNzZWQuXG4qL1xuY29uc3QgdGVtcG9yYXJpbHlTZXRUYWJGb2N1c01vZGUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LnNldFRhYkZvY3VzTW9kZSgyMDAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXIgYW5kIFNoaWZ0LUVudGVyOiBbYGluc2VydE5ld2xpbmVBbmRJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydE5ld2xpbmVBbmRJbmRlbnQpXG4gLSBDdHJsLWEgKENtZC1hIG9uIG1hY09TKTogW2BzZWxlY3RBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEFsbClcbiAtIEJhY2tzcGFjZTogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIERlbGV0ZTogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLUJhY2tzcGFjZSAoQWx0LUJhY2tzcGFjZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtRGVsZXRlIChBbHQtRGVsZXRlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwRm9yd2FyZClcbiAtIENtZC1CYWNrc3BhY2UgKG1hY09TKTogW2BkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQpLlxuIC0gQ21kLURlbGV0ZSAobWFjT1MpOiBbYGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd0xlZnRcIiwgbWFjOiBcIkFsdC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JHcm91cExlZnQsIHNoaWZ0OiBzZWxlY3RHcm91cExlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93UmlnaHRcIiwgbWFjOiBcIkFsdC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yR3JvdXBSaWdodCwgc2hpZnQ6IHNlbGVjdEdyb3VwUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUhvbWVcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBrZXk6IFwiRW5kXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgc2hpZnQ6IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgfSxcbiAgICB7IGtleTogXCJNb2QtYVwiLCBydW46IHNlbGVjdEFsbCB9LFxuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCwgc2hpZnQ6IGRlbGV0ZUNoYXJCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtRGVsZXRlXCIsIG1hYzogXCJBbHQtRGVsZXRlXCIsIHJ1bjogZGVsZXRlR3JvdXBGb3J3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIk1vZC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXS5jb25jYXQoLypAX19QVVJFX18qL2VtYWNzU3R5bGVLZXltYXAubWFwKGIgPT4gKHsgbWFjOiBiLmtleSwgcnVuOiBiLnJ1biwgc2hpZnQ6IGIuc2hpZnQgfSkpKTtcbi8qKlxuVGhlIGRlZmF1bHQga2V5bWFwLiBJbmNsdWRlcyBhbGwgYmluZGluZ3MgZnJvbVxuW2BzdGFuZGFyZEtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3RhbmRhcmRLZXltYXApIHBsdXMgdGhlIGZvbGxvd2luZzpcblxuLSBBbHQtQXJyb3dMZWZ0IChDdHJsLUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4TGVmdCkgKFtgc2VsZWN0U3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4TGVmdCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93UmlnaHQgKEN0cmwtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheFJpZ2h0KSAoW2BzZWxlY3RTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4UmlnaHQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1VwOiBbYG1vdmVMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lVXApXG4tIEFsdC1BcnJvd0Rvd246IFtgbW92ZUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZURvd24pXG4tIFNoaWZ0LUFsdC1BcnJvd1VwOiBbYGNvcHlMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lVXApXG4tIFNoaWZ0LUFsdC1BcnJvd0Rvd246IFtgY29weUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZURvd24pXG4tIEN0cmwtQWx0LUFycm93VXAgKENtZC1BbHQtQXJyb3dVcCBvbiBtYWNPUyk6IFtgYWRkQ3Vyc29yQWJvdmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmFkZEN1cnNvckFib3ZlKS5cbi0gQ3RybC1BbHQtQXJyb3dEb3duIChDbWQtQWx0LUFycm93RG93biBvbiBtYWNPUyk6IFtgYWRkQ3Vyc29yQmVsb3dgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmFkZEN1cnNvckJlbG93KS5cbi0gRXNjYXBlOiBbYHNpbXBsaWZ5U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zaW1wbGlmeVNlbGVjdGlvbilcbi0gQ3RybC1FbnRlciAoQ21kLUVudGVyIG9uIG1hY09TKTogW2BpbnNlcnRCbGFua0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydEJsYW5rTGluZSlcbi0gQWx0LWwgKEN0cmwtbCBvbiBtYWNPUyk6IFtgc2VsZWN0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZSlcbi0gQ3RybC1pIChDbWQtaSBvbiBtYWNPUyk6IFtgc2VsZWN0UGFyZW50U3ludGF4YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYXJlbnRTeW50YXgpXG4tIEN0cmwtWyAoQ21kLVsgb24gbWFjT1MpOiBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpXG4tIEN0cmwtXSAoQ21kLV0gb24gbWFjT1MpOiBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpXG4tIEN0cmwtQWx0LVxcXFwgKENtZC1BbHQtXFxcXCBvbiBtYWNPUyk6IFtgaW5kZW50U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRTZWxlY3Rpb24pXG4tIFNoaWZ0LUN0cmwtayAoU2hpZnQtQ21kLWsgb24gbWFjT1MpOiBbYGRlbGV0ZUxpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmUpXG4tIFNoaWZ0LUN0cmwtXFxcXCAoU2hpZnQtQ21kLVxcXFwgb24gbWFjT1MpOiBbYGN1cnNvck1hdGNoaW5nQnJhY2tldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTWF0Y2hpbmdCcmFja2V0KVxuLSBDdHJsLS8gKENtZC0vIG9uIG1hY09TKTogW2B0b2dnbGVDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVDb21tZW50KS5cbi0gU2hpZnQtQWx0LWE6IFtgdG9nZ2xlQmxvY2tDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVCbG9ja0NvbW1lbnQpLlxuLSBDdHJsLW0gKEFsdC1TaGlmdC1tIG9uIG1hY09TKTogW2B0b2dnbGVUYWJGb2N1c01vZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZVRhYkZvY3VzTW9kZSkuXG4qL1xuY29uc3QgZGVmYXVsdEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQWx0LUFycm93TGVmdFwiLCBtYWM6IFwiQ3RybC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JTeW50YXhMZWZ0LCBzaGlmdDogc2VsZWN0U3ludGF4TGVmdCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJDdHJsLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JTeW50YXhSaWdodCwgc2hpZnQ6IHNlbGVjdFN5bnRheFJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93VXBcIiwgcnVuOiBtb3ZlTGluZVVwIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93VXBcIiwgcnVuOiBjb3B5TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93RG93blwiLCBydW46IG1vdmVMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd0Rvd25cIiwgcnVuOiBjb3B5TGluZURvd24gfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LUFycm93VXBcIiwgcnVuOiBhZGRDdXJzb3JBYm92ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogYWRkQ3Vyc29yQmVsb3cgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBzaW1wbGlmeVNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIk1vZC1FbnRlclwiLCBydW46IGluc2VydEJsYW5rTGluZSB9LFxuICAgIHsga2V5OiBcIkFsdC1sXCIsIG1hYzogXCJDdHJsLWxcIiwgcnVuOiBzZWxlY3RMaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWlcIiwgcnVuOiBzZWxlY3RQYXJlbnRTeW50YXgsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLVtcIiwgcnVuOiBpbmRlbnRMZXNzIH0sXG4gICAgeyBrZXk6IFwiTW9kLV1cIiwgcnVuOiBpbmRlbnRNb3JlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1cXFxcXCIsIHJ1bjogaW5kZW50U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLWtcIiwgcnVuOiBkZWxldGVMaW5lIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLVxcXFxcIiwgcnVuOiBjdXJzb3JNYXRjaGluZ0JyYWNrZXQgfSxcbiAgICB7IGtleTogXCJNb2QtL1wiLCBydW46IHRvZ2dsZUNvbW1lbnQgfSxcbiAgICB7IGtleTogXCJBbHQtQVwiLCBydW46IHRvZ2dsZUJsb2NrQ29tbWVudCB9LFxuICAgIHsga2V5OiBcIkN0cmwtbVwiLCBtYWM6IFwiU2hpZnQtQWx0LW1cIiwgcnVuOiB0b2dnbGVUYWJGb2N1c01vZGUgfSxcbl0uY29uY2F0KHN0YW5kYXJkS2V5bWFwKTtcbi8qKlxuQSBiaW5kaW5nIHRoYXQgYmluZHMgVGFiIHRvIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgYW5kXG5TaGlmdC1UYWIgdG8gW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKS5cblBsZWFzZSBzZWUgdGhlIFtUYWIgZXhhbXBsZV0oLi4vLi4vZXhhbXBsZXMvdGFiLykgYmVmb3JlIHVzaW5nXG50aGlzLlxuKi9cbmNvbnN0IGluZGVudFdpdGhUYWIgPSB7IGtleTogXCJUYWJcIiwgcnVuOiBpbmRlbnRNb3JlLCBzaGlmdDogaW5kZW50TGVzcyB9O1xuXG5leHBvcnQgeyBhZGRDdXJzb3JBYm92ZSwgYWRkQ3Vyc29yQmVsb3csIGJsb2NrQ29tbWVudCwgYmxvY2tVbmNvbW1lbnQsIGNvcHlMaW5lRG93biwgY29weUxpbmVVcCwgY3Vyc29yQ2hhckJhY2t3YXJkLCBjdXJzb3JDaGFyQmFja3dhcmRMb2dpY2FsLCBjdXJzb3JDaGFyRm9yd2FyZCwgY3Vyc29yQ2hhckZvcndhcmRMb2dpY2FsLCBjdXJzb3JDaGFyTGVmdCwgY3Vyc29yQ2hhclJpZ2h0LCBjdXJzb3JEb2NFbmQsIGN1cnNvckRvY1N0YXJ0LCBjdXJzb3JHcm91cEJhY2t3YXJkLCBjdXJzb3JHcm91cEZvcndhcmQsIGN1cnNvckdyb3VwRm9yd2FyZFdpbiwgY3Vyc29yR3JvdXBMZWZ0LCBjdXJzb3JHcm91cFJpZ2h0LCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyQmFja3dhcmRTdHJpY3QsIGRlbGV0ZUNoYXJGb3J3YXJkLCBkZWxldGVHcm91cEJhY2t3YXJkLCBkZWxldGVHcm91cEZvcndhcmQsIGRlbGV0ZUdyb3VwRm9yd2FyZFdpbiwgZGVsZXRlTGluZSwgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQsIGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQsIGRlbGV0ZVRvTGluZUVuZCwgZGVsZXRlVG9MaW5lU3RhcnQsIGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSwgZW1hY3NTdHlsZUtleW1hcCwgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbmRlbnRMZXNzLCBpbmRlbnRNb3JlLCBpbmRlbnRTZWxlY3Rpb24sIGluZGVudFdpdGhUYWIsIGluc2VydEJsYW5rTGluZSwgaW5zZXJ0TmV3bGluZSwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgaW5zZXJ0TmV3bGluZUtlZXBJbmRlbnQsIGluc2VydFRhYiwgaW52ZXJ0ZWRFZmZlY3RzLCBpc29sYXRlSGlzdG9yeSwgbGluZUNvbW1lbnQsIGxpbmVVbmNvbW1lbnQsIG1vdmVMaW5lRG93biwgbW92ZUxpbmVVcCwgcmVkbywgcmVkb0RlcHRoLCByZWRvU2VsZWN0aW9uLCBzZWxlY3RBbGwsIHNlbGVjdENoYXJCYWNrd2FyZCwgc2VsZWN0Q2hhckJhY2t3YXJkTG9naWNhbCwgc2VsZWN0Q2hhckZvcndhcmQsIHNlbGVjdENoYXJGb3J3YXJkTG9naWNhbCwgc2VsZWN0Q2hhckxlZnQsIHNlbGVjdENoYXJSaWdodCwgc2VsZWN0RG9jRW5kLCBzZWxlY3REb2NTdGFydCwgc2VsZWN0R3JvdXBCYWNrd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkLCBzZWxlY3RHcm91cEZvcndhcmRXaW4sIHNlbGVjdEdyb3VwTGVmdCwgc2VsZWN0R3JvdXBSaWdodCwgc2VsZWN0TGluZSwgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHNlbGVjdExpbmVCb3VuZGFyeUxlZnQsIHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBzZWxlY3RMaW5lRG93biwgc2VsZWN0TGluZUVuZCwgc2VsZWN0TGluZVN0YXJ0LCBzZWxlY3RMaW5lVXAsIHNlbGVjdE1hdGNoaW5nQnJhY2tldCwgc2VsZWN0UGFnZURvd24sIHNlbGVjdFBhZ2VVcCwgc2VsZWN0UGFyZW50U3ludGF4LCBzZWxlY3RTdWJ3b3JkQmFja3dhcmQsIHNlbGVjdFN1YndvcmRGb3J3YXJkLCBzZWxlY3RTeW50YXhMZWZ0LCBzZWxlY3RTeW50YXhSaWdodCwgc2ltcGxpZnlTZWxlY3Rpb24sIHNwbGl0TGluZSwgc3RhbmRhcmRLZXltYXAsIHRlbXBvcmFyaWx5U2V0VGFiRm9jdXNNb2RlLCB0b2dnbGVCbG9ja0NvbW1lbnQsIHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSwgdG9nZ2xlQ29tbWVudCwgdG9nZ2xlTGluZUNvbW1lbnQsIHRvZ2dsZVRhYkZvY3VzTW9kZSwgdHJhbnNwb3NlQ2hhcnMsIHVuZG8sIHVuZG9EZXB0aCwgdW5kb1NlbGVjdGlvbiB9O1xuIl0sIm5hbWVzIjpbIkFubm90YXRpb24iLCJGYWNldCIsImNvbWJpbmVDb25maWciLCJTdGF0ZUZpZWxkIiwiVHJhbnNhY3Rpb24iLCJDaGFuZ2VTZXQiLCJDaGFuZ2VEZXNjIiwiRWRpdG9yU2VsZWN0aW9uIiwiU3RhdGVFZmZlY3QiLCJUZXh0IiwiZmluZENsdXN0ZXJCcmVhayIsImNvdW50Q29sdW1uIiwiQ2hhckNhdGVnb3J5IiwiRWRpdG9yVmlldyIsIkRpcmVjdGlvbiIsIkluZGVudENvbnRleHQiLCJnZXRJbmRlbnRhdGlvbiIsImluZGVudFN0cmluZyIsIm1hdGNoQnJhY2tldHMiLCJzeW50YXhUcmVlIiwiZ2V0SW5kZW50VW5pdCIsImluZGVudFVuaXQiLCJOb2RlUHJvcCIsInRvZ2dsZUNvbW1lbnQiLCJ0YXJnZXQiLCJzdGF0ZSIsImxpbmUiLCJkb2MiLCJsaW5lQXQiLCJzZWxlY3Rpb24iLCJtYWluIiwiZnJvbSIsImNvbmZpZyIsImdldENvbmZpZyIsInRvZ2dsZUxpbmVDb21tZW50IiwiYmxvY2siLCJ0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUiLCJjb21tYW5kIiwiZiIsIm9wdGlvbiIsImRpc3BhdGNoIiwicmVhZE9ubHkiLCJ0ciIsInVwZGF0ZSIsImNoYW5nZUxpbmVDb21tZW50IiwibGluZUNvbW1lbnQiLCJsaW5lVW5jb21tZW50IiwidG9nZ2xlQmxvY2tDb21tZW50IiwiY2hhbmdlQmxvY2tDb21tZW50IiwiYmxvY2tDb21tZW50IiwiYmxvY2tVbmNvbW1lbnQiLCJvIiwicyIsInNlbGVjdGVkTGluZVJhbmdlcyIsInBvcyIsImRhdGEiLCJsYW5ndWFnZURhdGFBdCIsImxlbmd0aCIsIlNlYXJjaE1hcmdpbiIsImZpbmRCbG9ja0NvbW1lbnQiLCJvcGVuIiwiY2xvc2UiLCJ0byIsInRleHRCZWZvcmUiLCJzbGljZURvYyIsInRleHRBZnRlciIsInNwYWNlQmVmb3JlIiwiZXhlYyIsInNwYWNlQWZ0ZXIiLCJiZWZvcmVPZmYiLCJzbGljZSIsIm1hcmdpbiIsInN0YXJ0VGV4dCIsImVuZFRleHQiLCJzdGFydFNwYWNlIiwiZW5kU3BhY2UiLCJlbmRPZmYiLCJ0ZXN0IiwiY2hhckF0IiwicmFuZ2VzIiwiciIsImZyb21MaW5lIiwidG9MaW5lIiwibGFzdCIsInB1c2giLCJ0ZXh0IiwidG9rZW5zIiwibWFwIiwiZXZlcnkiLCJjIiwiY29tbWVudHMiLCJpIiwiY2hhbmdlcyIsInJhbmdlIiwiaW5zZXJ0Iiwic29tZSIsImNvbW1lbnQiLCJ0b2tlbiIsImxpbmVzIiwicHJldkxpbmUiLCJzdGFydEkiLCJtaW5JbmRlbnQiLCJpbmRlbnQiLCJlbXB0eSIsInNpbmdsZSIsImwiLCJjaGFuZ2VTZXQiLCJmcm9tSGlzdG9yeSIsImRlZmluZSIsImlzb2xhdGVIaXN0b3J5IiwiaW52ZXJ0ZWRFZmZlY3RzIiwiaGlzdG9yeUNvbmZpZyIsImNvbWJpbmUiLCJjb25maWdzIiwibWluRGVwdGgiLCJuZXdHcm91cERlbGF5Iiwiam9pblRvRXZlbnQiLCJfdCIsImlzQWRqYWNlbnQiLCJNYXRoIiwibWF4IiwibWluIiwiYSIsImIiLCJhZGoiLCJoaXN0b3J5RmllbGRfIiwiY3JlYXRlIiwiSGlzdG9yeVN0YXRlIiwiZmFjZXQiLCJmcm9tSGlzdCIsImFubm90YXRpb24iLCJpdGVtIiwiSGlzdEV2ZW50IiwiZnJvbVRyYW5zYWN0aW9uIiwic2lkZSIsIm90aGVyIiwidW5kb25lIiwiZG9uZSIsInVwZGF0ZUJyYW5jaCIsImFkZFNlbGVjdGlvbiIsInN0YXJ0U3RhdGUiLCJyZXN0IiwiaXNvbGF0ZSIsImFkZFRvSGlzdG9yeSIsImFkZE1hcHBpbmciLCJkZXNjIiwiZXZlbnQiLCJ0aW1lIiwidXNlckV2ZW50IiwiYWRkQ2hhbmdlcyIsInRvSlNPTiIsInZhbHVlIiwiZSIsImZyb21KU09OIiwianNvbiIsImhpc3RvcnkiLCJvZiIsImRvbUV2ZW50SGFuZGxlcnMiLCJiZWZvcmVpbnB1dCIsInZpZXciLCJpbnB1dFR5cGUiLCJ1bmRvIiwicmVkbyIsInByZXZlbnREZWZhdWx0IiwiaGlzdG9yeUZpZWxkIiwiY21kIiwiaGlzdG9yeVN0YXRlIiwiZmllbGQiLCJwb3AiLCJ1bmRvU2VsZWN0aW9uIiwicmVkb1NlbGVjdGlvbiIsImRlcHRoIiwiaGlzdFN0YXRlIiwiYnJhbmNoIiwidW5kb0RlcHRoIiwicmVkb0RlcHRoIiwiY29uc3RydWN0b3IiLCJlZmZlY3RzIiwibWFwcGVkIiwic3RhcnRTZWxlY3Rpb24iLCJzZWxlY3Rpb25zQWZ0ZXIiLCJzZXRTZWxBZnRlciIsImFmdGVyIiwiX2EiLCJfYiIsIl9jIiwibm9uZSIsImludmVydCIsInJlc3VsdCIsImNvbmNhdCIsInVuZGVmaW5lZCIsInNlbGVjdGlvbnMiLCJtYXhMZW4iLCJuZXdFdmVudCIsInN0YXJ0IiwibmV3QnJhbmNoIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJ0IiwiX2YiLCJlcVNlbGVjdGlvblNoYXBlIiwiZmlsdGVyIiwiY29uYyIsIk1heFNlbGVjdGlvbnNQZXJFdmVudCIsImxhc3RFdmVudCIsInNlbHMiLCJlcSIsInBvcFNlbGVjdGlvbiIsImFkZE1hcHBpbmdUb0JyYW5jaCIsIm1hcHBpbmciLCJtYXBFdmVudCIsImV4dHJhU2VsZWN0aW9ucyIsIm1hcHBlZENoYW5nZXMiLCJiZWZvcmUiLCJtYXBEZXNjIiwiZnVsbE1hcHBpbmciLCJjb21wb3NlRGVzYyIsIm1hcEVmZmVjdHMiLCJqb2luYWJsZVVzZXJFdmVudCIsInByZXZUaW1lIiwicHJldlVzZXJFdmVudCIsImNvbXBvc2UiLCJvbmx5U2VsZWN0aW9uIiwiYW5ub3RhdGlvbnMiLCJzY3JvbGxJbnRvVmlldyIsImhpc3RvcnlLZXltYXAiLCJrZXkiLCJydW4iLCJtYWMiLCJsaW51eCIsInVwZGF0ZVNlbCIsInNlbCIsImJ5IiwibWFpbkluZGV4Iiwic2V0U2VsIiwibW92ZVNlbCIsImhvdyIsInJhbmdlRW5kIiwiZm9yd2FyZCIsImN1cnNvciIsImN1cnNvckJ5Q2hhciIsIm1vdmVCeUNoYXIiLCJsdHJBdEN1cnNvciIsInRleHREaXJlY3Rpb25BdCIsImhlYWQiLCJMVFIiLCJjdXJzb3JDaGFyTGVmdCIsImN1cnNvckNoYXJSaWdodCIsImN1cnNvckNoYXJGb3J3YXJkIiwiY3Vyc29yQ2hhckJhY2t3YXJkIiwiYnlDaGFyTG9naWNhbCIsIm1vdmVCeUNoYXJMb2dpY2FsIiwiY3Vyc29yQ2hhckZvcndhcmRMb2dpY2FsIiwiY3Vyc29yQ2hhckJhY2t3YXJkTG9naWNhbCIsImN1cnNvckJ5R3JvdXAiLCJtb3ZlQnlHcm91cCIsImN1cnNvckdyb3VwTGVmdCIsImN1cnNvckdyb3VwUmlnaHQiLCJjdXJzb3JHcm91cEZvcndhcmQiLCJjdXJzb3JHcm91cEJhY2t3YXJkIiwidG9Hcm91cFN0YXJ0IiwiY2F0ZWdvcml6ZSIsImNoYXJDYXRlZ29yaXplciIsImNhdCIsImluaXRpYWwiLCJTcGFjZSIsIm5leHQiLCJuZXh0Q2F0IiwiY3Vyc29yR3JvdXBGb3J3YXJkV2luIiwic2VnbWVudGVyIiwiSW50bCIsIlNlZ21lbnRlciIsImdyYW51bGFyaXR5IiwibW92ZUJ5U3Vid29yZCIsInN0ZXBzIiwic2F3VXBwZXIiLCJzYXdMb3dlciIsInN0ZXAiLCJhaGVhZCIsIldvcmQiLCJjaGFyQ29kZUF0IiwidG9Mb3dlckNhc2UiLCJlbmQiLCJza2lwcGVkIiwic2VnbWVudHMiLCJBcnJheSIsInNlZ21lbnQiLCJpbmRleCIsImN1cnNvckJ5U3Vid29yZCIsImN1cnNvclN1YndvcmRGb3J3YXJkIiwiY3Vyc29yU3Vid29yZEJhY2t3YXJkIiwiaW50ZXJlc3RpbmdOb2RlIiwibm9kZSIsImJyYWNrZXRQcm9wIiwidHlwZSIsInByb3AiLCJsZW4iLCJmaXJzdENoaWxkIiwibW92ZUJ5U3ludGF4IiwicmVzb2x2ZUlubmVyIiwiY2xvc2VkQnkiLCJvcGVuZWRCeSIsImF0IiwiY2hpbGRBZnRlciIsImNoaWxkQmVmb3JlIiwiYnJhY2tldCIsIm1hdGNoIiwibmV3UG9zIiwibWF0Y2hlZCIsImN1cnNvclN5bnRheExlZnQiLCJjdXJzb3JTeW50YXhSaWdodCIsImN1cnNvckJ5TGluZSIsIm1vdmVkIiwibW92ZVZlcnRpY2FsbHkiLCJtb3ZlVG9MaW5lQm91bmRhcnkiLCJjdXJzb3JMaW5lVXAiLCJjdXJzb3JMaW5lRG93biIsInBhZ2VJbmZvIiwic2VsZlNjcm9sbCIsInNjcm9sbERPTSIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsImhlaWdodCIsInNvdXJjZSIsInNjcm9sbE1hcmdpbnMiLCJtYXJnaW5zIiwidG9wIiwiYm90dG9tIiwiZG9tIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJkZWZhdWx0TGluZUhlaWdodCIsImN1cnNvckJ5UGFnZSIsInBhZ2UiLCJlZmZlY3QiLCJzdGFydFBvcyIsImNvb3Jkc0F0UG9zIiwic2Nyb2xsUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbFRvcCIsInNjcm9sbEJvdHRvbSIsInkiLCJ5TWFyZ2luIiwiY3Vyc29yUGFnZVVwIiwiY3Vyc29yUGFnZURvd24iLCJtb3ZlQnlMaW5lQm91bmRhcnkiLCJsaW5lQmxvY2tBdCIsInNwYWNlIiwiY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCIsImN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkIiwiY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCIsImN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0IiwiY3Vyc29yTGluZVN0YXJ0IiwiY3Vyc29yTGluZUVuZCIsInRvTWF0Y2hpbmdCcmFja2V0IiwiZXh0ZW5kIiwiZm91bmQiLCJtYXRjaGluZyIsImFuY2hvciIsImN1cnNvck1hdGNoaW5nQnJhY2tldCIsInNlbGVjdE1hdGNoaW5nQnJhY2tldCIsImV4dGVuZFNlbCIsImdvYWxDb2x1bW4iLCJiaWRpTGV2ZWwiLCJzZWxlY3RCeUNoYXIiLCJzZWxlY3RDaGFyTGVmdCIsInNlbGVjdENoYXJSaWdodCIsInNlbGVjdENoYXJGb3J3YXJkIiwic2VsZWN0Q2hhckJhY2t3YXJkIiwic2VsZWN0Q2hhckZvcndhcmRMb2dpY2FsIiwic2VsZWN0Q2hhckJhY2t3YXJkTG9naWNhbCIsInNlbGVjdEJ5R3JvdXAiLCJzZWxlY3RHcm91cExlZnQiLCJzZWxlY3RHcm91cFJpZ2h0Iiwic2VsZWN0R3JvdXBGb3J3YXJkIiwic2VsZWN0R3JvdXBCYWNrd2FyZCIsInNlbGVjdEdyb3VwRm9yd2FyZFdpbiIsInNlbGVjdEJ5U3Vid29yZCIsInNlbGVjdFN1YndvcmRGb3J3YXJkIiwic2VsZWN0U3Vid29yZEJhY2t3YXJkIiwic2VsZWN0U3ludGF4TGVmdCIsInNlbGVjdFN5bnRheFJpZ2h0Iiwic2VsZWN0QnlMaW5lIiwic2VsZWN0TGluZVVwIiwic2VsZWN0TGluZURvd24iLCJzZWxlY3RCeVBhZ2UiLCJzZWxlY3RQYWdlVXAiLCJzZWxlY3RQYWdlRG93biIsInNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQiLCJzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCIsInNlbGVjdExpbmVCb3VuZGFyeUxlZnQiLCJzZWxlY3RMaW5lQm91bmRhcnlSaWdodCIsInNlbGVjdExpbmVTdGFydCIsInNlbGVjdExpbmVFbmQiLCJjdXJzb3JEb2NTdGFydCIsImN1cnNvckRvY0VuZCIsInNlbGVjdERvY1N0YXJ0Iiwic2VsZWN0RG9jRW5kIiwic2VsZWN0QWxsIiwic2VsZWN0TGluZSIsInNlbGVjdGVkTGluZUJsb2NrcyIsInNlbGVjdFBhcmVudFN5bnRheCIsInRyZWUiLCJzdGFjayIsInJlc29sdmVTdGFjayIsInN0YWNrQmVmb3JlIiwiY3VyIiwiYWRkQ3Vyc29yVmVydGljYWxseSIsImFkZEN1cnNvckFib3ZlIiwiYWRkQ3Vyc29yQmVsb3ciLCJzaW1wbGlmeVNlbGVjdGlvbiIsImRlbGV0ZUJ5IiwiY2hhbmdlQnlSYW5nZSIsInRvd2FyZHMiLCJza2lwQXRvbWljIiwiYW5ub3VuY2UiLCJwaHJhc2UiLCJhdG9taWNSYW5nZXMiLCJiZXR3ZWVuIiwiZGVsZXRlQnlDaGFyIiwiYnlJbmRlbnRVbml0IiwidGFyZ2V0UG9zIiwiY29sIiwidGFiU2l6ZSIsImRyb3AiLCJudW1iZXIiLCJkZWxldGVDaGFyQmFja3dhcmQiLCJkZWxldGVDaGFyQmFja3dhcmRTdHJpY3QiLCJkZWxldGVDaGFyRm9yd2FyZCIsImRlbGV0ZUJ5R3JvdXAiLCJuZXh0Q2hhciIsImRlbGV0ZUdyb3VwQmFja3dhcmQiLCJkZWxldGVHcm91cEZvcndhcmQiLCJkZWxldGVHcm91cEZvcndhcmRXaW4iLCJkZWxldGVUb0xpbmVFbmQiLCJsaW5lRW5kIiwiZGVsZXRlVG9MaW5lU3RhcnQiLCJsaW5lU3RhcnQiLCJkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCIsImRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQiLCJkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UiLCJwcmV2IiwiaXRlciIsImxpbmVCcmVhayIsInRyYWlsaW5nIiwic2VhcmNoIiwic3BsaXRMaW5lIiwidHJhbnNwb3NlQ2hhcnMiLCJhcHBlbmQiLCJibG9ja3MiLCJ1cHRvIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsIm1vdmVMaW5lIiwibmV4dExpbmUiLCJzaXplIiwibW92ZUxpbmVVcCIsIm1vdmVMaW5lRG93biIsImNvcHlMaW5lIiwiY29weUxpbmVVcCIsImNvcHlMaW5lRG93biIsImRlbGV0ZUxpbmUiLCJkaXN0IiwibGluZVdyYXBwaW5nIiwiYXNzb2MiLCJkb2N1bWVudFRvcCIsImluc2VydE5ld2xpbmUiLCJyZXBsYWNlU2VsZWN0aW9uIiwiaW5zZXJ0TmV3bGluZUtlZXBJbmRlbnQiLCJpc0JldHdlZW5CcmFja2V0cyIsImNvbnRleHQiLCJpbmRleE9mIiwibmFtZSIsImluc2VydE5ld2xpbmVBbmRJbmRlbnQiLCJuZXdsaW5lQW5kSW5kZW50IiwiaW5zZXJ0QmxhbmtMaW5lIiwiYXRFb2YiLCJleHBsb2RlIiwiY3giLCJzaW11bGF0ZUJyZWFrIiwic2ltdWxhdGVEb3VibGVCcmVhayIsImxpbmVJbmRlbnQiLCJjaGFuZ2VCeVNlbGVjdGVkTGluZSIsImF0TGluZSIsIm1hcFBvcyIsImluZGVudFNlbGVjdGlvbiIsInVwZGF0ZWQiLCJPYmplY3QiLCJvdmVycmlkZUluZGVudGF0aW9uIiwibm9ybSIsImluZGVudE1vcmUiLCJpbmRlbnRMZXNzIiwia2VlcCIsInRvZ2dsZVRhYkZvY3VzTW9kZSIsInNldFRhYkZvY3VzTW9kZSIsInRlbXBvcmFyaWx5U2V0VGFiRm9jdXNNb2RlIiwiaW5zZXJ0VGFiIiwiZW1hY3NTdHlsZUtleW1hcCIsInNoaWZ0Iiwic3RhbmRhcmRLZXltYXAiLCJkZWZhdWx0S2V5bWFwIiwiaW5kZW50V2l0aFRhYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@codemirror+commands@6.10.1/node_modules/@codemirror/commands/dist/index.js\n");

/***/ })

};
;