"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-inputrules@1.5.1";
exports.ids = ["vendor-chunks/prosemirror-inputrules@1.5.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/prosemirror-inputrules@1.5.1/node_modules/prosemirror-inputrules/dist/index.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/prosemirror-inputrules@1.5.1/node_modules/prosemirror-inputrules/dist/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   closeDoubleQuote: () => (/* binding */ closeDoubleQuote),\n/* harmony export */   closeSingleQuote: () => (/* binding */ closeSingleQuote),\n/* harmony export */   ellipsis: () => (/* binding */ ellipsis),\n/* harmony export */   emDash: () => (/* binding */ emDash),\n/* harmony export */   inputRules: () => (/* binding */ inputRules),\n/* harmony export */   openDoubleQuote: () => (/* binding */ openDoubleQuote),\n/* harmony export */   openSingleQuote: () => (/* binding */ openSingleQuote),\n/* harmony export */   smartQuotes: () => (/* binding */ smartQuotes),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   undoInputRule: () => (/* binding */ undoInputRule),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/.pnpm/prosemirror-state@1.4.4/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/.pnpm/prosemirror-transform@1.10.5/node_modules/prosemirror-transform/dist/index.js\");\n\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/ class InputRule {\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule's effect, or null to indicate the input was not handled.\n    */ constructor(/**\n    @internal\n    */ match, handler, options = {}){\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n        this.undoable = options.undoable !== false;\n        this.inCode = options.inCode || false;\n        this.inCodeMark = options.inCodeMark !== false;\n    }\n}\nfunction stringHandler(string) {\n    return function(state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/ function inputRules({ rules }) {\n    let plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        state: {\n            init () {\n                return null;\n            },\n            apply (tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored) return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput (view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view)=>{\n                    setTimeout(()=>{\n                        let { $cursor } = view.state.selection;\n                        if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing) return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"￼\") + text;\n    for(let i = 0; i < rules.length; i++){\n        let rule = rules[i];\n        if (!rule.inCodeMark && $from.marks().some((m)=>m.type.spec.code)) continue;\n        if ($from.parent.type.spec.code) {\n            if (!rule.inCode) continue;\n        } else if (rule.inCode === \"only\") {\n            continue;\n        }\n        let match = rule.match.exec(textBefore);\n        if (!match || match[0].length < text.length) continue;\n        let startPos = from - (match[0].length - text.length);\n        if (!rule.inCodeMark) {\n            let hasMark = false;\n            state.doc.nodesBetween(startPos, $from.pos, (node)=>{\n                if (node.isInline && node.marks.some((m)=>m.type.spec.code)) hasMark = true;\n            });\n            if (hasMark) continue;\n        }\n        let tr = rule.handler(state, match, startPos, to);\n        if (!tr) continue;\n        if (rule.undoable) tr.setMeta(plugin, {\n            transform: tr,\n            from,\n            to,\n            text\n        });\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/ const undoInputRule = (state, dispatch)=>{\n    let plugins = state.plugins;\n    for(let i = 0; i < plugins.length; i++){\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for(let j = toUndo.steps.length - 1; j >= 0; j--)tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                } else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n/**\nConverts double dashes to an emdash.\n*/ const emDash = new InputRule(/--$/, \"—\", {\n    inCodeMark: false\n});\n/**\nConverts three dots to an ellipsis character.\n*/ const ellipsis = new InputRule(/\\.\\.\\.$/, \"…\", {\n    inCodeMark: false\n});\n/**\n“Smart” opening double quotes.\n*/ const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\", {\n    inCodeMark: false\n});\n/**\n“Smart” closing double quotes.\n*/ const closeDoubleQuote = new InputRule(/\"$/, \"”\", {\n    inCodeMark: false\n});\n/**\n“Smart” opening single quotes.\n*/ const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\", {\n    inCodeMark: false\n});\n/**\n“Smart” closing single quotes.\n*/ const closeSingleQuote = new InputRule(/'$/, \"’\", {\n    inCodeMark: false\n});\n/**\nSmart-quote related input rules.\n*/ const smartQuotes = [\n    openDoubleQuote,\n    closeDoubleQuote,\n    openSingleQuote,\n    closeSingleQuote\n];\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/ function wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end)=>{\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping) return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/ function textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end)=>{\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;\n        return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3ItaW5wdXRydWxlc0AxLjUuMS9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaW5wdXRydWxlcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ21CO0FBRTlEOzs7OztBQUtBLEdBQ0EsTUFBTUc7SUFDRjs7Ozs7Ozs7Ozs7Ozs7O0lBZUEsR0FDQUMsWUFDQTs7SUFFQSxHQUNBQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUMxQixJQUFJLENBQUNGLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRyxPQUFPQSxXQUFXLFdBQVdFLGNBQWNGLFdBQVdBO1FBQ3JFLElBQUksQ0FBQ0csUUFBUSxHQUFHRixRQUFRRSxRQUFRLEtBQUs7UUFDckMsSUFBSSxDQUFDQyxNQUFNLEdBQUdILFFBQVFHLE1BQU0sSUFBSTtRQUNoQyxJQUFJLENBQUNDLFVBQVUsR0FBR0osUUFBUUksVUFBVSxLQUFLO0lBQzdDO0FBQ0o7QUFDQSxTQUFTSCxjQUFjSSxNQUFNO0lBQ3pCLE9BQU8sU0FBVUMsS0FBSyxFQUFFUixLQUFLLEVBQUVTLEtBQUssRUFBRUMsR0FBRztRQUNyQyxJQUFJQyxTQUFTSjtRQUNiLElBQUlQLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDVixJQUFJWSxTQUFTWixLQUFLLENBQUMsRUFBRSxDQUFDYSxXQUFXLENBQUNiLEtBQUssQ0FBQyxFQUFFO1lBQzFDVyxVQUFVWCxLQUFLLENBQUMsRUFBRSxDQUFDYyxLQUFLLENBQUNGLFNBQVNaLEtBQUssQ0FBQyxFQUFFLENBQUNlLE1BQU07WUFDakROLFNBQVNHO1lBQ1QsSUFBSUksU0FBU1AsUUFBUUM7WUFDckIsSUFBSU0sU0FBUyxHQUFHO2dCQUNaTCxTQUFTWCxLQUFLLENBQUMsRUFBRSxDQUFDYyxLQUFL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RyxPQUFPQSxPQUFPbUYsVUFBVUc7SUFDOUM7QUFDSjtBQUVnTSIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLWlucHV0cnVsZXNAMS41LjEvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWlucHV0cnVsZXMvZGlzdC9pbmRleC5qcz9kMWVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGZpbmRXcmFwcGluZywgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8qKlxuSW5wdXQgcnVsZXMgYXJlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZGVzY3JpYmluZyBhIHBpZWNlIG9mIHRleHRcbnRoYXQsIHdoZW4gdHlwZWQsIGNhdXNlcyBzb21ldGhpbmcgdG8gaGFwcGVuLiBUaGlzIG1pZ2h0IGJlXG5jaGFuZ2luZyB0d28gZGFzaGVzIGludG8gYW4gZW1kYXNoLCB3cmFwcGluZyBhIHBhcmFncmFwaCBzdGFydGluZ1xud2l0aCBgXCI+IFwiYCBpbnRvIGEgYmxvY2txdW90ZSwgb3Igc29tZXRoaW5nIGVudGlyZWx5IGRpZmZlcmVudC5cbiovXG5jbGFzcyBJbnB1dFJ1bGUge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnB1dCBydWxlLiBUaGUgcnVsZSBhcHBsaWVzIHdoZW4gdGhlIHVzZXIgdHlwZWRcbiAgICBzb21ldGhpbmcgYW5kIHRoZSB0ZXh0IGRpcmVjdGx5IGluIGZyb250IG9mIHRoZSBjdXJzb3IgbWF0Y2hlc1xuICAgIGBtYXRjaGAsIHdoaWNoIHNob3VsZCBlbmQgd2l0aCBgJGAuXG4gICAgXG4gICAgVGhlIGBoYW5kbGVyYCBjYW4gYmUgYSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgdGhlIG1hdGNoZWQgdGV4dCwgb3JcbiAgICB0aGUgZmlyc3QgbWF0Y2hlZCBncm91cCBpbiB0aGUgcmVnZXhwLCBpcyByZXBsYWNlZCBieSB0aGF0XG4gICAgc3RyaW5nLlxuICAgIFxuICAgIE9yIGEgaXQgY2FuIGJlIGEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG1hdGNoXG4gICAgYXJyYXkgcHJvZHVjZWQgYnlcbiAgICBbYFJlZ0V4cC5leGVjYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL2V4ZWMpLFxuICAgIGFzIHdlbGwgYXMgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIG1hdGNoZWQgcmFuZ2UsIGFuZCB3aGljaCBjYW5cbiAgICByZXR1cm4gYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCBkZXNjcmliZXMgdGhlXG4gICAgcnVsZSdzIGVmZmVjdCwgb3IgbnVsbCB0byBpbmRpY2F0ZSB0aGUgaW5wdXQgd2FzIG5vdCBoYW5kbGVkLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaCwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSB0eXBlb2YgaGFuZGxlciA9PSBcInN0cmluZ1wiID8gc3RyaW5nSGFuZGxlcihoYW5kbGVyKSA6IGhhbmRsZXI7XG4gICAgICAgIHRoaXMudW5kb2FibGUgPSBvcHRpb25zLnVuZG9hYmxlICE9PSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbkNvZGUgPSBvcHRpb25zLmluQ29kZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pbkNvZGVNYXJrID0gb3B0aW9ucy5pbkNvZGVNYXJrICE9PSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdIYW5kbGVyKHN0cmluZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIG1hdGNoLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCBpbnNlcnQgPSBzdHJpbmc7XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICB9O1xufVxuY29uc3QgTUFYX01BVENIID0gNTAwO1xuLyoqXG5DcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZSdzXG5hY3Rpb24uXG4qL1xuZnVuY3Rpb24gaW5wdXRSdWxlcyh7IHJ1bGVzIH0pIHtcbiAgICBsZXQgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBwcmV2KSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0b3JlZCA9IHRyLmdldE1ldGEodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIuc2VsZWN0aW9uU2V0IHx8IHRyLmRvY0NoYW5nZWQgPyBudWxsIDogcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW4odmlldywgZnJvbSwgdG8sIHRleHQsIHJ1bGVzLCBwbHVnaW4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uZW5kOiAodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRjdXJzb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuKHZpZXcsICRjdXJzb3IucG9zLCAkY3Vyc29yLnBvcywgXCJcIiwgcnVsZXMsIHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNJbnB1dFJ1bGVzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbjtcbn1cbmZ1bmN0aW9uIHJ1bih2aWV3LCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbikge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUsICRmcm9tID0gc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHRleHRCZWZvcmUgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oTWF0aC5tYXgoMCwgJGZyb20ucGFyZW50T2Zmc2V0IC0gTUFYX01BVENIKSwgJGZyb20ucGFyZW50T2Zmc2V0LCBudWxsLCBcIlxcdWZmZmNcIikgKyB0ZXh0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgICAgaWYgKCFydWxlLmluQ29kZU1hcmsgJiYgJGZyb20ubWFya3MoKS5zb21lKG0gPT4gbS50eXBlLnNwZWMuY29kZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZSkge1xuICAgICAgICAgICAgaWYgKCFydWxlLmluQ29kZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLmluQ29kZSA9PT0gXCJvbmx5XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaCA9IHJ1bGUubWF0Y2guZXhlYyh0ZXh0QmVmb3JlKTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFswXS5sZW5ndGggPCB0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBmcm9tIC0gKG1hdGNoWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFydWxlLmluQ29kZU1hcmspIHtcbiAgICAgICAgICAgIGxldCBoYXNNYXJrID0gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0UG9zLCAkZnJvbS5wb3MsIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIG5vZGUubWFya3Muc29tZShtID0+IG0udHlwZS5zcGVjLmNvZGUpKVxuICAgICAgICAgICAgICAgICAgICBoYXNNYXJrID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc01hcmspXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyID0gcnVsZS5oYW5kbGVyKHN0YXRlLCBtYXRjaCwgc3RhcnRQb3MsIHRvKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocnVsZS51bmRvYWJsZSlcbiAgICAgICAgICAgIHRyLnNldE1ldGEocGx1Z2luLCB7IHRyYW5zZm9ybTogdHIsIGZyb20sIHRvLCB0ZXh0IH0pO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuVGhpcyBpcyBhIGNvbW1hbmQgdGhhdCB3aWxsIHVuZG8gYW4gaW5wdXQgcnVsZSwgaWYgYXBwbHlpbmcgc3VjaCBhXG5ydWxlIHdhcyB0aGUgbGFzdCB0aGluZyB0aGF0IHRoZSB1c2VyIGRpZC5cbiovXG5jb25zdCB1bmRvSW5wdXRSdWxlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbnNbaV0sIHVuZG9hYmxlO1xuICAgICAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ciwgdG9VbmRvID0gdW5kb2FibGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpO1xuICAgICAgICAgICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG5Db252ZXJ0cyBkb3VibGUgZGFzaGVzIHRvIGFuIGVtZGFzaC5cbiovXG5jb25zdCBlbURhc2ggPSBuZXcgSW5wdXRSdWxlKC8tLSQvLCBcIuKAlFwiLCB7IGluQ29kZU1hcms6IGZhbHNlIH0pO1xuLyoqXG5Db252ZXJ0cyB0aHJlZSBkb3RzIHRvIGFuIGVsbGlwc2lzIGNoYXJhY3Rlci5cbiovXG5jb25zdCBlbGxpcHNpcyA9IG5ldyBJbnB1dFJ1bGUoL1xcLlxcLlxcLiQvLCBcIuKAplwiLCB7IGluQ29kZU1hcms6IGZhbHNlIH0pO1xuLyoqXG7igJxTbWFydOKAnSBvcGVuaW5nIGRvdWJsZSBxdW90ZXMuXG4qL1xuY29uc3Qgb3BlbkRvdWJsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvKD86XnxbXFxzXFx7XFxbXFwoXFw8J1wiXFx1MjAxOFxcdTIwMUNdKShcIikkLywgXCLigJxcIiwgeyBpbkNvZGVNYXJrOiBmYWxzZSB9KTtcbi8qKlxu4oCcU21hcnTigJ0gY2xvc2luZyBkb3VibGUgcXVvdGVzLlxuKi9cbmNvbnN0IGNsb3NlRG91YmxlUXVvdGUgPSBuZXcgSW5wdXRSdWxlKC9cIiQvLCBcIuKAnVwiLCB7IGluQ29kZU1hcms6IGZhbHNlIH0pO1xuLyoqXG7igJxTbWFydOKAnSBvcGVuaW5nIHNpbmdsZSBxdW90ZXMuXG4qL1xuY29uc3Qgb3BlblNpbmdsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvKD86XnxbXFxzXFx7XFxbXFwoXFw8J1wiXFx1MjAxOFxcdTIwMUNdKSgnKSQvLCBcIuKAmFwiLCB7IGluQ29kZU1hcms6IGZhbHNlIH0pO1xuLyoqXG7igJxTbWFydOKAnSBjbG9zaW5nIHNpbmdsZSBxdW90ZXMuXG4qL1xuY29uc3QgY2xvc2VTaW5nbGVRdW90ZSA9IG5ldyBJbnB1dFJ1bGUoLyckLywgXCLigJlcIiwgeyBpbkNvZGVNYXJrOiBmYWxzZSB9KTtcbi8qKlxuU21hcnQtcXVvdGUgcmVsYXRlZCBpbnB1dCBydWxlcy5cbiovXG5jb25zdCBzbWFydFF1b3RlcyA9IFtvcGVuRG91YmxlUXVvdGUsIGNsb3NlRG91YmxlUXVvdGUsIG9wZW5TaW5nbGVRdW90ZSwgY2xvc2VTaW5nbGVRdW90ZV07XG5cbi8qKlxuQnVpbGQgYW4gaW5wdXQgcnVsZSBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyBhIHRleHRibG9jayB3aGVuIGFcbmdpdmVuIHN0cmluZyBpcyB0eXBlZC4gVGhlIGByZWdleHBgIGFyZ3VtZW50IGlzXG5kaXJlY3RseSBwYXNzZWQgdGhyb3VnaCB0byB0aGUgYElucHV0UnVsZWAgY29uc3RydWN0b3IuIFlvdSdsbFxucHJvYmFibHkgd2FudCB0aGUgcmVnZXhwIHRvIHN0YXJ0IHdpdGggYF5gLCBzbyB0aGF0IHRoZSBwYXR0ZXJuIGNhblxub25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG5cbmBub2RlVHlwZWAgaXMgdGhlIHR5cGUgb2Ygbm9kZSB0byB3cmFwIGluLiBJZiBpdCBuZWVkcyBhdHRyaWJ1dGVzLFxueW91IGNhbiBlaXRoZXIgcGFzcyB0aGVtIGRpcmVjdGx5LCBvciBwYXNzIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG5jb21wdXRlIHRoZW0gZnJvbSB0aGUgcmVndWxhciBleHByZXNzaW9uIG1hdGNoLlxuXG5CeSBkZWZhdWx0LCBpZiB0aGVyZSdzIGEgbm9kZSB3aXRoIHRoZSBzYW1lIHR5cGUgYWJvdmUgdGhlIG5ld2x5XG53cmFwcGVkIG5vZGUsIHRoZSBydWxlIHdpbGwgdHJ5IHRvIFtqb2luXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybS5qb2luKSB0aG9zZVxudHdvIG5vZGVzLiBZb3UgY2FuIHBhc3MgYSBqb2luIHByZWRpY2F0ZSwgd2hpY2ggdGFrZXMgYSByZWd1bGFyXG5leHByZXNzaW9uIG1hdGNoIGFuZCB0aGUgbm9kZSBiZWZvcmUgdGhlIHdyYXBwZWQgbm9kZSwgYW5kIGNhblxucmV0dXJuIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgam9pbiBzaG91bGQgaGFwcGVuLlxuKi9cbmZ1bmN0aW9uIHdyYXBwaW5nSW5wdXRSdWxlKHJlZ2V4cCwgbm9kZVR5cGUsIGdldEF0dHJzID0gbnVsbCwgam9pblByZWRpY2F0ZSkge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHJlZ2V4cCwgKHN0YXRlLCBtYXRjaCwgc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICBsZXQgYXR0cnMgPSBnZXRBdHRycyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZ2V0QXR0cnMobWF0Y2gpIDogZ2V0QXR0cnM7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmRlbGV0ZShzdGFydCwgZW5kKTtcbiAgICAgICAgbGV0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0KSwgcmFuZ2UgPSAkc3RhcnQuYmxvY2tSYW5nZSgpLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgaWYgKCF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0ci53cmFwKHJhbmdlLCB3cmFwcGluZyk7XG4gICAgICAgIGxldCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShzdGFydCAtIDEpLm5vZGVCZWZvcmU7XG4gICAgICAgIGlmIChiZWZvcmUgJiYgYmVmb3JlLnR5cGUgPT0gbm9kZVR5cGUgJiYgY2FuSm9pbih0ci5kb2MsIHN0YXJ0IC0gMSkgJiZcbiAgICAgICAgICAgICgham9pblByZWRpY2F0ZSB8fCBqb2luUHJlZGljYXRlKG1hdGNoLCBiZWZvcmUpKSlcbiAgICAgICAgICAgIHRyLmpvaW4oc3RhcnQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH0pO1xufVxuLyoqXG5CdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgY2hhbmdlcyB0aGUgdHlwZSBvZiBhIHRleHRibG9jayB3aGVuIHRoZVxubWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuIFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gc3RhcnQgeW91clxucmVnZXhwIHdpdGggYF5gIHRvIHRoYXQgaXQgaXMgb25seSBtYXRjaGVkIGF0IHRoZSBzdGFydCBvZiBhXG50ZXh0YmxvY2suIFRoZSBvcHRpb25hbCBgZ2V0QXR0cnNgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBjb21wdXRlXG50aGUgbmV3IG5vZGUncyBhdHRyaWJ1dGVzLCBhbmQgd29ya3MgdGhlIHNhbWUgYXMgaW4gdGhlXG5gd3JhcHBpbmdJbnB1dFJ1bGVgIGZ1bmN0aW9uLlxuKi9cbmZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUocmVnZXhwLCBub2RlVHlwZSwgZ2V0QXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUocmVnZXhwLCAoc3RhdGUsIG1hdGNoLCBzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGxldCAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShzdGFydCk7XG4gICAgICAgIGxldCBhdHRycyA9IGdldEF0dHJzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBnZXRBdHRycyhtYXRjaCkgOiBnZXRBdHRycztcbiAgICAgICAgaWYgKCEkc3RhcnQubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJHN0YXJ0LmluZGV4KC0xKSwgJHN0YXJ0LmluZGV4QWZ0ZXIoLTEpLCBub2RlVHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRyXG4gICAgICAgICAgICAuZGVsZXRlKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgICAuc2V0QmxvY2tUeXBlKHN0YXJ0LCBzdGFydCwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgSW5wdXRSdWxlLCBjbG9zZURvdWJsZVF1b3RlLCBjbG9zZVNpbmdsZVF1b3RlLCBlbGxpcHNpcywgZW1EYXNoLCBpbnB1dFJ1bGVzLCBvcGVuRG91YmxlUXVvdGUsIG9wZW5TaW5nbGVRdW90ZSwgc21hcnRRdW90ZXMsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUsIHVuZG9JbnB1dFJ1bGUsIHdyYXBwaW5nSW5wdXRSdWxlIH07XG4iXSwibmFtZXMiOlsiUGx1Z2luIiwiZmluZFdyYXBwaW5nIiwiY2FuSm9pbiIsIklucHV0UnVsZSIsImNvbnN0cnVjdG9yIiwibWF0Y2giLCJoYW5kbGVyIiwib3B0aW9ucyIsInN0cmluZ0hhbmRsZXIiLCJ1bmRvYWJsZSIsImluQ29kZSIsImluQ29kZU1hcmsiLCJzdHJpbmciLCJzdGF0ZSIsInN0YXJ0IiwiZW5kIiwiaW5zZXJ0Iiwib2Zmc2V0IiwibGFzdEluZGV4T2YiLCJzbGljZSIsImxlbmd0aCIsImN1dE9mZiIsInRyIiwiaW5zZXJ0VGV4dCIsIk1BWF9NQVRDSCIsImlucHV0UnVsZXMiLCJydWxlcyIsInBsdWdpbiIsImluaXQiLCJhcHBseSIsInByZXYiLCJzdG9yZWQiLCJnZXRNZXRhIiwic2VsZWN0aW9uU2V0IiwiZG9jQ2hhbmdlZCIsInByb3BzIiwiaGFuZGxlVGV4dElucHV0IiwidmlldyIsImZyb20iLCJ0byIsInRleHQiLCJydW4iLCJoYW5kbGVET01FdmVudHMiLCJjb21wb3NpdGlvbmVuZCIsInNldFRpbWVvdXQiLCIkY3Vyc29yIiwic2VsZWN0aW9uIiwicG9zIiwiaXNJbnB1dFJ1bGVzIiwiY29tcG9zaW5nIiwiJGZyb20iLCJkb2MiLCJyZXNvbHZlIiwidGV4dEJlZm9yZSIsInBhcmVudCIsInRleHRCZXR3ZWVuIiwiTWF0aCIsIm1heCIsInBhcmVudE9mZnNldCIsImkiLCJydWxlIiwibWFya3MiLCJzb21lIiwibSIsInR5cGUiLCJzcGVjIiwiY29kZSIsImV4ZWMiLCJzdGFydFBvcyIsImhhc01hcmsiLCJub2Rlc0JldHdlZW4iLCJub2RlIiwiaXNJbmxpbmUiLCJzZXRNZXRhIiwidHJhbnNmb3JtIiwiZGlzcGF0Y2giLCJ1bmRvSW5wdXRSdWxlIiwicGx1Z2lucyIsImdldFN0YXRlIiwidG9VbmRvIiwiaiIsInN0ZXBzIiwic3RlcCIsImludmVydCIsImRvY3MiLCJyZXBsYWNlV2l0aCIsInNjaGVtYSIsImRlbGV0ZSIsImVtRGFzaCIsImVsbGlwc2lzIiwib3BlbkRvdWJsZVF1b3RlIiwiY2xvc2VEb3VibGVRdW90ZSIsIm9wZW5TaW5nbGVRdW90ZSIsImNsb3NlU2luZ2xlUXVvdGUiLCJzbWFydFF1b3RlcyIsIndyYXBwaW5nSW5wdXRSdWxlIiwicmVnZXhwIiwibm9kZVR5cGUiLCJnZXRBdHRycyIsImpvaW5QcmVkaWNhdGUiLCJhdHRycyIsIkZ1bmN0aW9uIiwiJHN0YXJ0IiwicmFuZ2UiLCJibG9ja1JhbmdlIiwid3JhcHBpbmciLCJ3cmFwIiwiYmVmb3JlIiwibm9kZUJlZm9yZSIsImpvaW4iLCJ0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIiwiY2FuUmVwbGFjZVdpdGgiLCJpbmRleCIsImluZGV4QWZ0ZXIiLCJzZXRCbG9ja1R5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/prosemirror-inputrules@1.5.1/node_modules/prosemirror-inputrules/dist/index.js\n");

/***/ })

};
;