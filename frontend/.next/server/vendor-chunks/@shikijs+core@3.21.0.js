"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shikijs+core@3.21.0";
exports.ids = ["vendor-chunks/@shikijs+core@3.21.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@shikijs+core@3.21.0/node_modules/@shikijs/core/dist/index.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+core@3.21.0/node_modules/@shikijs/core/dist/index.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShikiError: () => (/* reexport safe */ _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError),\n/* harmony export */   addClassToHast: () => (/* binding */ addClassToHast),\n/* harmony export */   applyColorReplacements: () => (/* binding */ applyColorReplacements),\n/* harmony export */   codeToHast: () => (/* binding */ codeToHast),\n/* harmony export */   codeToHtml: () => (/* binding */ codeToHtml),\n/* harmony export */   codeToTokens: () => (/* binding */ codeToTokens),\n/* harmony export */   codeToTokensBase: () => (/* binding */ codeToTokensBase),\n/* harmony export */   codeToTokensWithThemes: () => (/* binding */ codeToTokensWithThemes),\n/* harmony export */   createBundledHighlighter: () => (/* binding */ createBundledHighlighter),\n/* harmony export */   createCssVariablesTheme: () => (/* binding */ createCssVariablesTheme),\n/* harmony export */   createHighlighterCore: () => (/* binding */ createHighlighterCore),\n/* harmony export */   createHighlighterCoreSync: () => (/* binding */ createHighlighterCoreSync),\n/* harmony export */   createPositionConverter: () => (/* binding */ createPositionConverter),\n/* harmony export */   createShikiInternal: () => (/* binding */ createShikiInternal),\n/* harmony export */   createShikiInternalSync: () => (/* binding */ createShikiInternalSync),\n/* harmony export */   createSingletonShorthands: () => (/* binding */ createSingletonShorthands),\n/* harmony export */   createdBundledHighlighter: () => (/* binding */ createdBundledHighlighter),\n/* harmony export */   enableDeprecationWarnings: () => (/* binding */ enableDeprecationWarnings),\n/* harmony export */   flatTokenVariants: () => (/* binding */ flatTokenVariants),\n/* harmony export */   getSingletonHighlighterCore: () => (/* binding */ getSingletonHighlighterCore),\n/* harmony export */   getTokenStyleObject: () => (/* binding */ getTokenStyleObject),\n/* harmony export */   guessEmbeddedLanguages: () => (/* binding */ guessEmbeddedLanguages),\n/* harmony export */   hastToHtml: () => (/* binding */ hastToHtml),\n/* harmony export */   isNoneTheme: () => (/* binding */ isNoneTheme),\n/* harmony export */   isPlainLang: () => (/* binding */ isPlainLang),\n/* harmony export */   isSpecialLang: () => (/* binding */ isSpecialLang),\n/* harmony export */   isSpecialTheme: () => (/* binding */ isSpecialTheme),\n/* harmony export */   makeSingletonHighlighter: () => (/* binding */ makeSingletonHighlighter),\n/* harmony export */   makeSingletonHighlighterCore: () => (/* binding */ makeSingletonHighlighterCore),\n/* harmony export */   normalizeGetter: () => (/* binding */ normalizeGetter),\n/* harmony export */   normalizeTheme: () => (/* binding */ normalizeTheme),\n/* harmony export */   resolveColorReplacements: () => (/* binding */ resolveColorReplacements),\n/* harmony export */   splitLines: () => (/* binding */ splitLines),\n/* harmony export */   splitToken: () => (/* binding */ splitToken),\n/* harmony export */   splitTokens: () => (/* binding */ splitTokens),\n/* harmony export */   stringifyTokenStyle: () => (/* binding */ stringifyTokenStyle),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   tokenizeAnsiWithTheme: () => (/* binding */ tokenizeAnsiWithTheme),\n/* harmony export */   tokenizeWithTheme: () => (/* binding */ tokenizeWithTheme),\n/* harmony export */   tokensToHast: () => (/* binding */ tokensToHast),\n/* harmony export */   transformerDecorations: () => (/* binding */ transformerDecorations),\n/* harmony export */   warnDeprecated: () => (/* binding */ warnDeprecated)\n/* harmony export */ });\n/* harmony import */ var _shikijs_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shikijs/types */ \"(ssr)/./node_modules/.pnpm/@shikijs+types@3.21.0/node_modules/@shikijs/types/dist/index.mjs\");\n/* harmony import */ var _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shikijs/vscode-textmate */ \"(ssr)/./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js\");\n/* harmony import */ var hast_util_to_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-html */ \"(ssr)/./node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/index.js\");\n\n\n\n\nfunction resolveColorReplacements(theme, options) {\n    const replacements = typeof theme === \"string\" ? {} : {\n        ...theme.colorReplacements\n    };\n    const themeName = typeof theme === \"string\" ? theme : theme.name;\n    for (const [key, value] of Object.entries(options?.colorReplacements || {})){\n        if (typeof value === \"string\") replacements[key] = value;\n        else if (key === themeName) Object.assign(replacements, value);\n    }\n    return replacements;\n}\nfunction applyColorReplacements(color, replacements) {\n    if (!color) return color;\n    return replacements?.[color?.toLowerCase()] || color;\n}\nfunction toArray(x) {\n    return Array.isArray(x) ? x : [\n        x\n    ];\n}\nasync function normalizeGetter(p) {\n    return Promise.resolve(typeof p === \"function\" ? p() : p).then((r)=>r.default || r);\n}\nfunction isPlainLang(lang) {\n    return !lang || [\n        \"plaintext\",\n        \"txt\",\n        \"text\",\n        \"plain\"\n    ].includes(lang);\n}\nfunction isSpecialLang(lang) {\n    return lang === \"ansi\" || isPlainLang(lang);\n}\nfunction isNoneTheme(theme) {\n    return theme === \"none\";\n}\nfunction isSpecialTheme(theme) {\n    return isNoneTheme(theme);\n}\nfunction addClassToHast(node, className) {\n    if (!className) return node;\n    node.properties ||= {};\n    node.properties.class ||= [];\n    if (typeof node.properties.class === \"string\") node.properties.class = node.properties.class.split(/\\s+/g);\n    if (!Array.isArray(node.properties.class)) node.properties.class = [];\n    const targets = Array.isArray(className) ? className : className.split(/\\s+/g);\n    for (const c of targets){\n        if (c && !node.properties.class.includes(c)) node.properties.class.push(c);\n    }\n    return node;\n}\nfunction splitLines(code, preserveEnding = false) {\n    if (code.length === 0) {\n        return [\n            [\n                \"\",\n                0\n            ]\n        ];\n    }\n    const parts = code.split(/(\\r?\\n)/g);\n    let index = 0;\n    const lines = [];\n    for(let i = 0; i < parts.length; i += 2){\n        const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n        lines.push([\n            line,\n            index\n        ]);\n        index += parts[i].length;\n        index += parts[i + 1]?.length || 0;\n    }\n    return lines;\n}\nfunction createPositionConverter(code) {\n    const lines = splitLines(code, true).map(([line])=>line);\n    function indexToPos(index) {\n        if (index === code.length) {\n            return {\n                line: lines.length - 1,\n                character: lines[lines.length - 1].length\n            };\n        }\n        let character = index;\n        let line = 0;\n        for (const lineText of lines){\n            if (character < lineText.length) break;\n            character -= lineText.length;\n            line++;\n        }\n        return {\n            line,\n            character\n        };\n    }\n    function posToIndex(line, character) {\n        let index = 0;\n        for(let i = 0; i < line; i++)index += lines[i].length;\n        index += character;\n        return index;\n    }\n    return {\n        lines,\n        indexToPos,\n        posToIndex\n    };\n}\nfunction guessEmbeddedLanguages(code, _lang, highlighter) {\n    const langs = /* @__PURE__ */ new Set();\n    for (const match of code.matchAll(/:?lang=[\"']([^\"']+)[\"']/g)){\n        const lang = match[1].toLowerCase().trim();\n        if (lang) langs.add(lang);\n    }\n    for (const match of code.matchAll(/(?:```|~~~)([\\w-]+)/g)){\n        const lang = match[1].toLowerCase().trim();\n        if (lang) langs.add(lang);\n    }\n    for (const match of code.matchAll(/\\\\begin\\{([\\w-]+)\\}/g)){\n        const lang = match[1].toLowerCase().trim();\n        if (lang) langs.add(lang);\n    }\n    for (const match of code.matchAll(/<script\\s+(?:type|lang)=[\"']([^\"']+)[\"']/gi)){\n        const fullType = match[1].toLowerCase().trim();\n        const lang = fullType.includes(\"/\") ? fullType.split(\"/\").pop() : fullType;\n        if (lang) langs.add(lang);\n    }\n    if (!highlighter) return Array.from(langs);\n    const bundle = highlighter.getBundledLanguages();\n    return Array.from(langs).filter((l)=>l && bundle[l]);\n}\nconst DEFAULT_COLOR_LIGHT_DARK = \"light-dark()\";\nconst COLOR_KEYS = [\n    \"color\",\n    \"background-color\"\n];\nfunction splitToken(token, offsets) {\n    let lastOffset = 0;\n    const tokens = [];\n    for (const offset of offsets){\n        if (offset > lastOffset) {\n            tokens.push({\n                ...token,\n                content: token.content.slice(lastOffset, offset),\n                offset: token.offset + lastOffset\n            });\n        }\n        lastOffset = offset;\n    }\n    if (lastOffset < token.content.length) {\n        tokens.push({\n            ...token,\n            content: token.content.slice(lastOffset),\n            offset: token.offset + lastOffset\n        });\n    }\n    return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n    const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b)=>a - b);\n    if (!sorted.length) return tokens;\n    return tokens.map((line)=>{\n        return line.flatMap((token)=>{\n            const breakpointsInToken = sorted.filter((i)=>token.offset < i && i < token.offset + token.content.length).map((i)=>i - token.offset).sort((a, b)=>a - b);\n            if (!breakpointsInToken.length) return token;\n            return splitToken(token, breakpointsInToken);\n        });\n    });\n}\nfunction flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor, colorsRendering = \"css-vars\") {\n    const token = {\n        content: merged.content,\n        explanation: merged.explanation,\n        offset: merged.offset\n    };\n    const styles = variantsOrder.map((t)=>getTokenStyleObject(merged.variants[t]));\n    const styleKeys = new Set(styles.flatMap((t)=>Object.keys(t)));\n    const mergedStyles = {};\n    const varKey = (idx, key)=>{\n        const keyName = key === \"color\" ? \"\" : key === \"background-color\" ? \"-bg\" : `-${key}`;\n        return cssVariablePrefix + variantsOrder[idx] + (key === \"color\" ? \"\" : keyName);\n    };\n    styles.forEach((cur, idx)=>{\n        for (const key of styleKeys){\n            const value = cur[key] || \"inherit\";\n            if (idx === 0 && defaultColor && COLOR_KEYS.includes(key)) {\n                if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && styles.length > 1) {\n                    const lightIndex = variantsOrder.findIndex((t)=>t === \"light\");\n                    const darkIndex = variantsOrder.findIndex((t)=>t === \"dark\");\n                    if (lightIndex === -1 || darkIndex === -1) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError('When using `defaultColor: \"light-dark()\"`, you must provide both `light` and `dark` themes');\n                    const lightValue = styles[lightIndex][key] || \"inherit\";\n                    const darkValue = styles[darkIndex][key] || \"inherit\";\n                    mergedStyles[key] = `light-dark(${lightValue}, ${darkValue})`;\n                    if (colorsRendering === \"css-vars\") mergedStyles[varKey(idx, key)] = value;\n                } else {\n                    mergedStyles[key] = value;\n                }\n            } else {\n                if (colorsRendering === \"css-vars\") mergedStyles[varKey(idx, key)] = value;\n            }\n        }\n    });\n    token.htmlStyle = mergedStyles;\n    return token;\n}\nfunction getTokenStyleObject(token) {\n    const styles = {};\n    if (token.color) styles.color = token.color;\n    if (token.bgColor) styles[\"background-color\"] = token.bgColor;\n    if (token.fontStyle) {\n        if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Italic) styles[\"font-style\"] = \"italic\";\n        if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Bold) styles[\"font-weight\"] = \"bold\";\n        const decorations = [];\n        if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline) decorations.push(\"underline\");\n        if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough) decorations.push(\"line-through\");\n        if (decorations.length) styles[\"text-decoration\"] = decorations.join(\" \");\n    }\n    return styles;\n}\nfunction stringifyTokenStyle(token) {\n    if (typeof token === \"string\") return token;\n    return Object.entries(token).map(([key, value])=>`${key}:${value}`).join(\";\");\n}\nconst _grammarStateMap = /* @__PURE__ */ new WeakMap();\nfunction setLastGrammarStateToMap(keys, state) {\n    _grammarStateMap.set(keys, state);\n}\nfunction getLastGrammarStateFromMap(keys) {\n    return _grammarStateMap.get(keys);\n}\nclass GrammarState {\n    get themes() {\n        return Object.keys(this._stacks);\n    }\n    get theme() {\n        return this.themes[0];\n    }\n    get _stack() {\n        return this._stacks[this.theme];\n    }\n    /**\n   * Static method to create a initial grammar state.\n   */ static initial(lang, themes) {\n        return new GrammarState(Object.fromEntries(toArray(themes).map((theme)=>[\n                theme,\n                _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.INITIAL\n            ])), lang);\n    }\n    constructor(...args){\n        /**\n   * Theme to Stack mapping\n   */ this._stacks = {};\n        if (args.length === 2) {\n            const [stacksMap, lang] = args;\n            this.lang = lang;\n            this._stacks = stacksMap;\n        } else {\n            const [stack, lang, theme] = args;\n            this.lang = lang;\n            this._stacks = {\n                [theme]: stack\n            };\n        }\n    }\n    /**\n   * Get the internal stack object.\n   * @internal\n   */ getInternalStack(theme = this.theme) {\n        return this._stacks[theme];\n    }\n    getScopes(theme = this.theme) {\n        return getScopes(this._stacks[theme]);\n    }\n    toJSON() {\n        return {\n            lang: this.lang,\n            theme: this.theme,\n            themes: this.themes,\n            scopes: this.getScopes()\n        };\n    }\n}\nfunction getScopes(stack) {\n    const scopes = [];\n    const visited = /* @__PURE__ */ new Set();\n    function pushScope(stack2) {\n        if (visited.has(stack2)) return;\n        visited.add(stack2);\n        const name = stack2?.nameScopesList?.scopeName;\n        if (name) scopes.push(name);\n        if (stack2.parent) pushScope(stack2.parent);\n    }\n    pushScope(stack);\n    return scopes;\n}\nfunction getGrammarStack(state, theme) {\n    if (!(state instanceof GrammarState)) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid grammar state\");\n    return state.getInternalStack(theme);\n}\nfunction transformerDecorations() {\n    const map = /* @__PURE__ */ new WeakMap();\n    function getContext(shiki) {\n        if (!map.has(shiki.meta)) {\n            let normalizePosition = function(p) {\n                if (typeof p === \"number\") {\n                    if (p < 0 || p > shiki.source.length) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);\n                    return {\n                        ...converter.indexToPos(p),\n                        offset: p\n                    };\n                } else {\n                    const line = converter.lines[p.line];\n                    if (line === void 0) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);\n                    let character = p.character;\n                    if (character < 0) character = line.length + character;\n                    if (character < 0 || character > line.length) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);\n                    return {\n                        ...p,\n                        character,\n                        offset: converter.posToIndex(p.line, character)\n                    };\n                }\n            };\n            const converter = createPositionConverter(shiki.source);\n            const decorations = (shiki.options.decorations || []).map((d)=>({\n                    ...d,\n                    start: normalizePosition(d.start),\n                    end: normalizePosition(d.end)\n                }));\n            verifyIntersections(decorations);\n            map.set(shiki.meta, {\n                decorations,\n                converter,\n                source: shiki.source\n            });\n        }\n        return map.get(shiki.meta);\n    }\n    return {\n        name: \"shiki:decorations\",\n        tokens (tokens) {\n            if (!this.options.decorations?.length) return;\n            const ctx = getContext(this);\n            const breakpoints = ctx.decorations.flatMap((d)=>[\n                    d.start.offset,\n                    d.end.offset\n                ]);\n            const splitted = splitTokens(tokens, breakpoints);\n            return splitted;\n        },\n        code (codeEl) {\n            if (!this.options.decorations?.length) return;\n            const ctx = getContext(this);\n            const lines = Array.from(codeEl.children).filter((i)=>i.type === \"element\" && i.tagName === \"span\");\n            if (lines.length !== ctx.converter.lines.length) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);\n            function applyLineSection(line, start, end, decoration) {\n                const lineEl = lines[line];\n                let text = \"\";\n                let startIndex = -1;\n                let endIndex = -1;\n                if (start === 0) startIndex = 0;\n                if (end === 0) endIndex = 0;\n                if (end === Number.POSITIVE_INFINITY) endIndex = lineEl.children.length;\n                if (startIndex === -1 || endIndex === -1) {\n                    for(let i = 0; i < lineEl.children.length; i++){\n                        text += stringify(lineEl.children[i]);\n                        if (startIndex === -1 && text.length === start) startIndex = i + 1;\n                        if (endIndex === -1 && text.length === end) endIndex = i + 1;\n                    }\n                }\n                if (startIndex === -1) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);\n                if (endIndex === -1) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);\n                const children = lineEl.children.slice(startIndex, endIndex);\n                if (!decoration.alwaysWrap && children.length === lineEl.children.length) {\n                    applyDecoration(lineEl, decoration, \"line\");\n                } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === \"element\") {\n                    applyDecoration(children[0], decoration, \"token\");\n                } else {\n                    const wrapper = {\n                        type: \"element\",\n                        tagName: \"span\",\n                        properties: {},\n                        children\n                    };\n                    applyDecoration(wrapper, decoration, \"wrapper\");\n                    lineEl.children.splice(startIndex, children.length, wrapper);\n                }\n            }\n            function applyLine(line, decoration) {\n                lines[line] = applyDecoration(lines[line], decoration, \"line\");\n            }\n            function applyDecoration(el, decoration, type) {\n                const properties = decoration.properties || {};\n                const transform = decoration.transform || ((i)=>i);\n                el.tagName = decoration.tagName || \"span\";\n                el.properties = {\n                    ...el.properties,\n                    ...properties,\n                    class: el.properties.class\n                };\n                if (decoration.properties?.class) addClassToHast(el, decoration.properties.class);\n                el = transform(el, type) || el;\n                return el;\n            }\n            const lineApplies = [];\n            const sorted = ctx.decorations.sort((a, b)=>b.start.offset - a.start.offset || a.end.offset - b.end.offset);\n            for (const decoration of sorted){\n                const { start, end } = decoration;\n                if (start.line === end.line) {\n                    applyLineSection(start.line, start.character, end.character, decoration);\n                } else if (start.line < end.line) {\n                    applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);\n                    for(let i = start.line + 1; i < end.line; i++)lineApplies.unshift(()=>applyLine(i, decoration));\n                    applyLineSection(end.line, 0, end.character, decoration);\n                }\n            }\n            lineApplies.forEach((i)=>i());\n        }\n    };\n}\nfunction verifyIntersections(items) {\n    for(let i = 0; i < items.length; i++){\n        const foo = items[i];\n        if (foo.start.offset > foo.end.offset) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);\n        for(let j = i + 1; j < items.length; j++){\n            const bar = items[j];\n            const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;\n            const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;\n            const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;\n            const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;\n            if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {\n                if (isFooHasBarStart && isFooHasBarEnd) continue;\n                if (isBarHasFooStart && isBarHasFooEnd) continue;\n                if (isBarHasFooStart && foo.start.offset === foo.end.offset) continue;\n                if (isFooHasBarEnd && bar.start.offset === bar.end.offset) continue;\n                throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);\n            }\n        }\n    }\n}\nfunction stringify(el) {\n    if (el.type === \"text\") return el.value;\n    if (el.type === \"element\") return el.children.map(stringify).join(\"\");\n    return \"\";\n}\nconst builtInTransformers = [\n    /* @__PURE__ */ transformerDecorations()\n];\nfunction getTransformers(options) {\n    const transformers = sortTransformersByEnforcement(options.transformers || []);\n    return [\n        ...transformers.pre,\n        ...transformers.normal,\n        ...transformers.post,\n        ...builtInTransformers\n    ];\n}\nfunction sortTransformersByEnforcement(transformers) {\n    const pre = [];\n    const post = [];\n    const normal = [];\n    for (const transformer of transformers){\n        switch(transformer.enforce){\n            case \"pre\":\n                pre.push(transformer);\n                break;\n            case \"post\":\n                post.push(transformer);\n                break;\n            default:\n                normal.push(transformer);\n        }\n    }\n    return {\n        pre,\n        post,\n        normal\n    };\n}\n// src/colors.ts\nvar namedColors = [\n    \"black\",\n    \"red\",\n    \"green\",\n    \"yellow\",\n    \"blue\",\n    \"magenta\",\n    \"cyan\",\n    \"white\",\n    \"brightBlack\",\n    \"brightRed\",\n    \"brightGreen\",\n    \"brightYellow\",\n    \"brightBlue\",\n    \"brightMagenta\",\n    \"brightCyan\",\n    \"brightWhite\"\n];\n// src/decorations.ts\nvar decorations = {\n    1: \"bold\",\n    2: \"dim\",\n    3: \"italic\",\n    4: \"underline\",\n    7: \"reverse\",\n    8: \"hidden\",\n    9: \"strikethrough\"\n};\n// src/parser.ts\nfunction findSequence(value, position) {\n    const nextEscape = value.indexOf(\"\\x1b\", position);\n    if (nextEscape !== -1) {\n        if (value[nextEscape + 1] === \"[\") {\n            const nextClose = value.indexOf(\"m\", nextEscape);\n            if (nextClose !== -1) {\n                return {\n                    sequence: value.substring(nextEscape + 2, nextClose).split(\";\"),\n                    startPosition: nextEscape,\n                    position: nextClose + 1\n                };\n            }\n        }\n    }\n    return {\n        position: value.length\n    };\n}\nfunction parseColor(sequence) {\n    const colorMode = sequence.shift();\n    if (colorMode === \"2\") {\n        const rgb = sequence.splice(0, 3).map((x)=>Number.parseInt(x));\n        if (rgb.length !== 3 || rgb.some((x)=>Number.isNaN(x))) return;\n        return {\n            type: \"rgb\",\n            rgb\n        };\n    } else if (colorMode === \"5\") {\n        const index = sequence.shift();\n        if (index) {\n            return {\n                type: \"table\",\n                index: Number(index)\n            };\n        }\n    }\n}\nfunction parseSequence(sequence) {\n    const commands = [];\n    while(sequence.length > 0){\n        const code = sequence.shift();\n        if (!code) continue;\n        const codeInt = Number.parseInt(code);\n        if (Number.isNaN(codeInt)) continue;\n        if (codeInt === 0) {\n            commands.push({\n                type: \"resetAll\"\n            });\n        } else if (codeInt <= 9) {\n            const decoration = decorations[codeInt];\n            if (decoration) {\n                commands.push({\n                    type: \"setDecoration\",\n                    value: decorations[codeInt]\n                });\n            }\n        } else if (codeInt <= 29) {\n            const decoration = decorations[codeInt - 20];\n            if (decoration) {\n                commands.push({\n                    type: \"resetDecoration\",\n                    value: decoration\n                });\n                if (decoration === \"dim\") {\n                    commands.push({\n                        type: \"resetDecoration\",\n                        value: \"bold\"\n                    });\n                }\n            }\n        } else if (codeInt <= 37) {\n            commands.push({\n                type: \"setForegroundColor\",\n                value: {\n                    type: \"named\",\n                    name: namedColors[codeInt - 30]\n                }\n            });\n        } else if (codeInt === 38) {\n            const color = parseColor(sequence);\n            if (color) {\n                commands.push({\n                    type: \"setForegroundColor\",\n                    value: color\n                });\n            }\n        } else if (codeInt === 39) {\n            commands.push({\n                type: \"resetForegroundColor\"\n            });\n        } else if (codeInt <= 47) {\n            commands.push({\n                type: \"setBackgroundColor\",\n                value: {\n                    type: \"named\",\n                    name: namedColors[codeInt - 40]\n                }\n            });\n        } else if (codeInt === 48) {\n            const color = parseColor(sequence);\n            if (color) {\n                commands.push({\n                    type: \"setBackgroundColor\",\n                    value: color\n                });\n            }\n        } else if (codeInt === 49) {\n            commands.push({\n                type: \"resetBackgroundColor\"\n            });\n        } else if (codeInt === 53) {\n            commands.push({\n                type: \"setDecoration\",\n                value: \"overline\"\n            });\n        } else if (codeInt === 55) {\n            commands.push({\n                type: \"resetDecoration\",\n                value: \"overline\"\n            });\n        } else if (codeInt >= 90 && codeInt <= 97) {\n            commands.push({\n                type: \"setForegroundColor\",\n                value: {\n                    type: \"named\",\n                    name: namedColors[codeInt - 90 + 8]\n                }\n            });\n        } else if (codeInt >= 100 && codeInt <= 107) {\n            commands.push({\n                type: \"setBackgroundColor\",\n                value: {\n                    type: \"named\",\n                    name: namedColors[codeInt - 100 + 8]\n                }\n            });\n        }\n    }\n    return commands;\n}\nfunction createAnsiSequenceParser() {\n    let foreground = null;\n    let background = null;\n    let decorations2 = /* @__PURE__ */ new Set();\n    return {\n        parse (value) {\n            const tokens = [];\n            let position = 0;\n            do {\n                const findResult = findSequence(value, position);\n                const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);\n                if (text.length > 0) {\n                    tokens.push({\n                        value: text,\n                        foreground,\n                        background,\n                        decorations: new Set(decorations2)\n                    });\n                }\n                if (findResult.sequence) {\n                    const commands = parseSequence(findResult.sequence);\n                    for (const styleToken of commands){\n                        if (styleToken.type === \"resetAll\") {\n                            foreground = null;\n                            background = null;\n                            decorations2.clear();\n                        } else if (styleToken.type === \"resetForegroundColor\") {\n                            foreground = null;\n                        } else if (styleToken.type === \"resetBackgroundColor\") {\n                            background = null;\n                        } else if (styleToken.type === \"resetDecoration\") {\n                            decorations2.delete(styleToken.value);\n                        }\n                    }\n                    for (const styleToken of commands){\n                        if (styleToken.type === \"setForegroundColor\") {\n                            foreground = styleToken.value;\n                        } else if (styleToken.type === \"setBackgroundColor\") {\n                            background = styleToken.value;\n                        } else if (styleToken.type === \"setDecoration\") {\n                            decorations2.add(styleToken.value);\n                        }\n                    }\n                }\n                position = findResult.position;\n            }while (position < value.length);\n            return tokens;\n        }\n    };\n}\n// src/palette.ts\nvar defaultNamedColorsMap = {\n    black: \"#000000\",\n    red: \"#bb0000\",\n    green: \"#00bb00\",\n    yellow: \"#bbbb00\",\n    blue: \"#0000bb\",\n    magenta: \"#ff00ff\",\n    cyan: \"#00bbbb\",\n    white: \"#eeeeee\",\n    brightBlack: \"#555555\",\n    brightRed: \"#ff5555\",\n    brightGreen: \"#00ff00\",\n    brightYellow: \"#ffff55\",\n    brightBlue: \"#5555ff\",\n    brightMagenta: \"#ff55ff\",\n    brightCyan: \"#55ffff\",\n    brightWhite: \"#ffffff\"\n};\nfunction createColorPalette(namedColorsMap = defaultNamedColorsMap) {\n    function namedColor(name) {\n        return namedColorsMap[name];\n    }\n    function rgbColor(rgb) {\n        return `#${rgb.map((x)=>Math.max(0, Math.min(x, 255)).toString(16).padStart(2, \"0\")).join(\"\")}`;\n    }\n    let colorTable;\n    function getColorTable() {\n        if (colorTable) {\n            return colorTable;\n        }\n        colorTable = [];\n        for(let i = 0; i < namedColors.length; i++){\n            colorTable.push(namedColor(namedColors[i]));\n        }\n        let levels = [\n            0,\n            95,\n            135,\n            175,\n            215,\n            255\n        ];\n        for(let r = 0; r < 6; r++){\n            for(let g = 0; g < 6; g++){\n                for(let b = 0; b < 6; b++){\n                    colorTable.push(rgbColor([\n                        levels[r],\n                        levels[g],\n                        levels[b]\n                    ]));\n                }\n            }\n        }\n        let level = 8;\n        for(let i = 0; i < 24; i++, level += 10){\n            colorTable.push(rgbColor([\n                level,\n                level,\n                level\n            ]));\n        }\n        return colorTable;\n    }\n    function tableColor(index) {\n        return getColorTable()[index];\n    }\n    function value(color) {\n        switch(color.type){\n            case \"named\":\n                return namedColor(color.name);\n            case \"rgb\":\n                return rgbColor(color.rgb);\n            case \"table\":\n                return tableColor(color.index);\n        }\n    }\n    return {\n        value\n    };\n}\nconst defaultAnsiColors = {\n    black: \"#000000\",\n    red: \"#cd3131\",\n    green: \"#0DBC79\",\n    yellow: \"#E5E510\",\n    blue: \"#2472C8\",\n    magenta: \"#BC3FBC\",\n    cyan: \"#11A8CD\",\n    white: \"#E5E5E5\",\n    brightBlack: \"#666666\",\n    brightRed: \"#F14C4C\",\n    brightGreen: \"#23D18B\",\n    brightYellow: \"#F5F543\",\n    brightBlue: \"#3B8EEA\",\n    brightMagenta: \"#D670D6\",\n    brightCyan: \"#29B8DB\",\n    brightWhite: \"#FFFFFF\"\n};\nfunction tokenizeAnsiWithTheme(theme, fileContents, options) {\n    const colorReplacements = resolveColorReplacements(theme, options);\n    const lines = splitLines(fileContents);\n    const ansiPalette = Object.fromEntries(namedColors.map((name)=>{\n        const key = `terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`;\n        const themeColor = theme.colors?.[key];\n        return [\n            name,\n            themeColor || defaultAnsiColors[name]\n        ];\n    }));\n    const colorPalette = createColorPalette(ansiPalette);\n    const parser = createAnsiSequenceParser();\n    return lines.map((line)=>parser.parse(line[0]).map((token)=>{\n            let color;\n            let bgColor;\n            if (token.decorations.has(\"reverse\")) {\n                color = token.background ? colorPalette.value(token.background) : theme.bg;\n                bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n            } else {\n                color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n                bgColor = token.background ? colorPalette.value(token.background) : void 0;\n            }\n            color = applyColorReplacements(color, colorReplacements);\n            bgColor = applyColorReplacements(bgColor, colorReplacements);\n            if (token.decorations.has(\"dim\")) color = dimColor(color);\n            let fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.None;\n            if (token.decorations.has(\"bold\")) fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Bold;\n            if (token.decorations.has(\"italic\")) fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Italic;\n            if (token.decorations.has(\"underline\")) fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline;\n            if (token.decorations.has(\"strikethrough\")) fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough;\n            return {\n                content: token.value,\n                offset: line[1],\n                // TODO: more accurate offset? might need to fork ansi-sequence-parser\n                color,\n                bgColor,\n                fontStyle\n            };\n        }));\n}\nfunction dimColor(color) {\n    const hexMatch = color.match(/#([0-9a-f]{3,8})/i);\n    if (hexMatch) {\n        const hex = hexMatch[1];\n        if (hex.length === 8) {\n            const alpha = Math.round(Number.parseInt(hex.slice(6, 8), 16) / 2).toString(16).padStart(2, \"0\");\n            return `#${hex.slice(0, 6)}${alpha}`;\n        } else if (hex.length === 6) {\n            return `#${hex}80`;\n        } else if (hex.length === 4) {\n            const r = hex[0];\n            const g = hex[1];\n            const b = hex[2];\n            const a = hex[3];\n            const alpha = Math.round(Number.parseInt(`${a}${a}`, 16) / 2).toString(16).padStart(2, \"0\");\n            return `#${r}${r}${g}${g}${b}${b}${alpha}`;\n        } else if (hex.length === 3) {\n            const r = hex[0];\n            const g = hex[1];\n            const b = hex[2];\n            return `#${r}${r}${g}${g}${b}${b}80`;\n        }\n    }\n    const cssVarMatch = color.match(/var\\((--[\\w-]+-ansi-[\\w-]+)\\)/);\n    if (cssVarMatch) return `var(${cssVarMatch[1]}-dim)`;\n    return color;\n}\nfunction codeToTokensBase(internal, code, options = {}) {\n    const { theme: themeName = internal.getLoadedThemes()[0] } = options;\n    const lang = internal.resolveLangAlias(options.lang || \"text\");\n    if (isPlainLang(lang) || isNoneTheme(themeName)) return splitLines(code).map((line)=>[\n            {\n                content: line[0],\n                offset: line[1]\n            }\n        ]);\n    const { theme, colorMap } = internal.setTheme(themeName);\n    if (lang === \"ansi\") return tokenizeAnsiWithTheme(theme, code, options);\n    const _grammar = internal.getLanguage(options.lang || \"text\");\n    if (options.grammarState) {\n        if (options.grammarState.lang !== _grammar.name) {\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state language \"${options.grammarState.lang}\" does not match highlight language \"${_grammar.name}\"`);\n        }\n        if (!options.grammarState.themes.includes(theme.name)) {\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state themes \"${options.grammarState.themes}\" do not contain highlight theme \"${theme.name}\"`);\n        }\n    }\n    return tokenizeWithTheme(code, _grammar, theme, colorMap, options);\n}\nfunction getLastGrammarState(...args) {\n    if (args.length === 2) {\n        return getLastGrammarStateFromMap(args[1]);\n    }\n    const [internal, code, options = {}] = args;\n    const { lang = \"text\", theme: themeName = internal.getLoadedThemes()[0] } = options;\n    if (isPlainLang(lang) || isNoneTheme(themeName)) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Plain language does not have grammar state\");\n    if (lang === \"ansi\") throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"ANSI language does not have grammar state\");\n    const { theme, colorMap } = internal.setTheme(themeName);\n    const _grammar = internal.getLanguage(lang);\n    return new GrammarState(_tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack, _grammar.name, theme.name);\n}\nfunction tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n    const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);\n    const grammarState = new GrammarState(result.stateStack, grammar.name, theme.name);\n    setLastGrammarStateToMap(result.tokens, grammarState);\n    return result.tokens;\n}\nfunction _tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n    const colorReplacements = resolveColorReplacements(theme, options);\n    const { tokenizeMaxLineLength = 0, tokenizeTimeLimit = 500 } = options;\n    const lines = splitLines(code);\n    let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(options.grammarContextCode, grammar, theme, colorMap, {\n        ...options,\n        grammarState: void 0,\n        grammarContextCode: void 0\n    }).stateStack : _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.INITIAL;\n    let actual = [];\n    const final = [];\n    for(let i = 0, len = lines.length; i < len; i++){\n        const [line, lineOffset] = lines[i];\n        if (line === \"\") {\n            actual = [];\n            final.push([]);\n            continue;\n        }\n        if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {\n            actual = [];\n            final.push([\n                {\n                    content: line,\n                    offset: lineOffset,\n                    color: \"\",\n                    fontStyle: 0\n                }\n            ]);\n            continue;\n        }\n        let resultWithScopes;\n        let tokensWithScopes;\n        let tokensWithScopesIndex;\n        if (options.includeExplanation) {\n            resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);\n            tokensWithScopes = resultWithScopes.tokens;\n            tokensWithScopesIndex = 0;\n        }\n        const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);\n        const tokensLength = result.tokens.length / 2;\n        for(let j = 0; j < tokensLength; j++){\n            const startIndex = result.tokens[2 * j];\n            const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n            if (startIndex === nextStartIndex) continue;\n            const metadata = result.tokens[2 * j + 1];\n            const color = applyColorReplacements(colorMap[_shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.EncodedTokenMetadata.getForeground(metadata)], colorReplacements);\n            const fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.EncodedTokenMetadata.getFontStyle(metadata);\n            const token = {\n                content: line.substring(startIndex, nextStartIndex),\n                offset: lineOffset + startIndex,\n                color,\n                fontStyle\n            };\n            if (options.includeExplanation) {\n                const themeSettingsSelectors = [];\n                if (options.includeExplanation !== \"scopeName\") {\n                    for (const setting of theme.settings){\n                        let selectors;\n                        switch(typeof setting.scope){\n                            case \"string\":\n                                selectors = setting.scope.split(/,/).map((scope)=>scope.trim());\n                                break;\n                            case \"object\":\n                                selectors = setting.scope;\n                                break;\n                            default:\n                                continue;\n                        }\n                        themeSettingsSelectors.push({\n                            settings: setting,\n                            selectors: selectors.map((selector)=>selector.split(/ /))\n                        });\n                    }\n                }\n                token.explanation = [];\n                let offset = 0;\n                while(startIndex + offset < nextStartIndex){\n                    const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];\n                    const tokenWithScopesText = line.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);\n                    offset += tokenWithScopesText.length;\n                    token.explanation.push({\n                        content: tokenWithScopesText,\n                        scopes: options.includeExplanation === \"scopeName\" ? explainThemeScopesNameOnly(tokenWithScopes.scopes) : explainThemeScopesFull(themeSettingsSelectors, tokenWithScopes.scopes)\n                    });\n                    tokensWithScopesIndex += 1;\n                }\n            }\n            actual.push(token);\n        }\n        final.push(actual);\n        actual = [];\n        stateStack = result.ruleStack;\n    }\n    return {\n        tokens: final,\n        stateStack\n    };\n}\nfunction explainThemeScopesNameOnly(scopes) {\n    return scopes.map((scope)=>({\n            scopeName: scope\n        }));\n}\nfunction explainThemeScopesFull(themeSelectors, scopes) {\n    const result = [];\n    for(let i = 0, len = scopes.length; i < len; i++){\n        const scope = scopes[i];\n        result[i] = {\n            scopeName: scope,\n            themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))\n        };\n    }\n    return result;\n}\nfunction matchesOne(selector, scope) {\n    return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === \".\";\n}\nfunction matches(selectors, scope, parentScopes) {\n    if (!matchesOne(selectors[selectors.length - 1], scope)) return false;\n    let selectorParentIndex = selectors.length - 2;\n    let parentIndex = parentScopes.length - 1;\n    while(selectorParentIndex >= 0 && parentIndex >= 0){\n        if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex])) selectorParentIndex -= 1;\n        parentIndex -= 1;\n    }\n    if (selectorParentIndex === -1) return true;\n    return false;\n}\nfunction explainThemeScope(themeSettingsSelectors, scope, parentScopes) {\n    const result = [];\n    for (const { selectors, settings } of themeSettingsSelectors){\n        for (const selectorPieces of selectors){\n            if (matches(selectorPieces, scope, parentScopes)) {\n                result.push(settings);\n                break;\n            }\n        }\n    }\n    return result;\n}\nfunction codeToTokensWithThemes(internal, code, options) {\n    const themes = Object.entries(options.themes).filter((i)=>i[1]).map((i)=>({\n            color: i[0],\n            theme: i[1]\n        }));\n    const themedTokens = themes.map((t)=>{\n        const tokens2 = codeToTokensBase(internal, code, {\n            ...options,\n            theme: t.theme\n        });\n        const state = getLastGrammarStateFromMap(tokens2);\n        const theme = typeof t.theme === \"string\" ? t.theme : t.theme.name;\n        return {\n            tokens: tokens2,\n            state,\n            theme\n        };\n    });\n    const tokens = syncThemesTokenization(...themedTokens.map((i)=>i.tokens));\n    const mergedTokens = tokens[0].map((line, lineIdx)=>line.map((_token, tokenIdx)=>{\n            const mergedToken = {\n                content: _token.content,\n                variants: {},\n                offset: _token.offset\n            };\n            if (\"includeExplanation\" in options && options.includeExplanation) {\n                mergedToken.explanation = _token.explanation;\n            }\n            tokens.forEach((t, themeIdx)=>{\n                const { content: _, explanation: __, offset: ___, ...styles } = t[lineIdx][tokenIdx];\n                mergedToken.variants[themes[themeIdx].color] = styles;\n            });\n            return mergedToken;\n        }));\n    const mergedGrammarState = themedTokens[0].state ? new GrammarState(Object.fromEntries(themedTokens.map((s)=>[\n            s.theme,\n            s.state?.getInternalStack(s.theme)\n        ])), themedTokens[0].state.lang) : void 0;\n    if (mergedGrammarState) setLastGrammarStateToMap(mergedTokens, mergedGrammarState);\n    return mergedTokens;\n}\nfunction syncThemesTokenization(...themes) {\n    const outThemes = themes.map(()=>[]);\n    const count = themes.length;\n    for(let i = 0; i < themes[0].length; i++){\n        const lines = themes.map((t)=>t[i]);\n        const outLines = outThemes.map(()=>[]);\n        outThemes.forEach((t, i2)=>t.push(outLines[i2]));\n        const indexes = lines.map(()=>0);\n        const current = lines.map((l)=>l[0]);\n        while(current.every((t)=>t)){\n            const minLength = Math.min(...current.map((t)=>t.content.length));\n            for(let n = 0; n < count; n++){\n                const token = current[n];\n                if (token.content.length === minLength) {\n                    outLines[n].push(token);\n                    indexes[n] += 1;\n                    current[n] = lines[n][indexes[n]];\n                } else {\n                    outLines[n].push({\n                        ...token,\n                        content: token.content.slice(0, minLength)\n                    });\n                    current[n] = {\n                        ...token,\n                        content: token.content.slice(minLength),\n                        offset: token.offset + minLength\n                    };\n                }\n            }\n        }\n    }\n    return outThemes;\n}\nfunction codeToTokens(internal, code, options) {\n    let bg;\n    let fg;\n    let tokens;\n    let themeName;\n    let rootStyle;\n    let grammarState;\n    if (\"themes\" in options) {\n        const { defaultColor = \"light\", cssVariablePrefix = \"--shiki-\", colorsRendering = \"css-vars\" } = options;\n        const themes = Object.entries(options.themes).filter((i)=>i[1]).map((i)=>({\n                color: i[0],\n                theme: i[1]\n            })).sort((a, b)=>a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);\n        if (themes.length === 0) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"`themes` option must not be empty\");\n        const themeTokens = codeToTokensWithThemes(internal, code, options);\n        grammarState = getLastGrammarStateFromMap(themeTokens);\n        if (defaultColor && DEFAULT_COLOR_LIGHT_DARK !== defaultColor && !themes.find((t)=>t.color === defaultColor)) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`\\`themes\\` option must contain the defaultColor key \\`${defaultColor}\\``);\n        const themeRegs = themes.map((t)=>internal.getTheme(t.theme));\n        const themesOrder = themes.map((t)=>t.color);\n        tokens = themeTokens.map((line)=>line.map((token)=>flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor, colorsRendering)));\n        if (grammarState) setLastGrammarStateToMap(tokens, grammarState);\n        const themeColorReplacements = themes.map((t)=>resolveColorReplacements(t.theme, options));\n        fg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, \"fg\", colorsRendering);\n        bg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, \"bg\", colorsRendering);\n        themeName = `shiki-themes ${themeRegs.map((t)=>t.name).join(\" \")}`;\n        rootStyle = defaultColor ? void 0 : [\n            fg,\n            bg\n        ].join(\";\");\n    } else if (\"theme\" in options) {\n        const colorReplacements = resolveColorReplacements(options.theme, options);\n        tokens = codeToTokensBase(internal, code, options);\n        const _theme = internal.getTheme(options.theme);\n        bg = applyColorReplacements(_theme.bg, colorReplacements);\n        fg = applyColorReplacements(_theme.fg, colorReplacements);\n        themeName = _theme.name;\n        grammarState = getLastGrammarStateFromMap(tokens);\n    } else {\n        throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid options, either `theme` or `themes` must be provided\");\n    }\n    return {\n        tokens,\n        fg,\n        bg,\n        themeName,\n        rootStyle,\n        grammarState\n    };\n}\nfunction mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, property, colorsRendering) {\n    return themes.map((t, idx)=>{\n        const value = applyColorReplacements(themeRegs[idx][property], themeColorReplacements[idx]) || \"inherit\";\n        const cssVar = `${cssVariablePrefix + t.color}${property === \"bg\" ? \"-bg\" : \"\"}:${value}`;\n        if (idx === 0 && defaultColor) {\n            if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && themes.length > 1) {\n                const lightIndex = themes.findIndex((t2)=>t2.color === \"light\");\n                const darkIndex = themes.findIndex((t2)=>t2.color === \"dark\");\n                if (lightIndex === -1 || darkIndex === -1) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError('When using `defaultColor: \"light-dark()\"`, you must provide both `light` and `dark` themes');\n                const lightValue = applyColorReplacements(themeRegs[lightIndex][property], themeColorReplacements[lightIndex]) || \"inherit\";\n                const darkValue = applyColorReplacements(themeRegs[darkIndex][property], themeColorReplacements[darkIndex]) || \"inherit\";\n                return `light-dark(${lightValue}, ${darkValue});${cssVar}`;\n            }\n            return value;\n        }\n        if (colorsRendering === \"css-vars\") {\n            return cssVar;\n        }\n        return null;\n    }).filter((i)=>!!i).join(\";\");\n}\nfunction codeToHast(internal, code, options, transformerContext = {\n    meta: {},\n    options,\n    codeToHast: (_code, _options)=>codeToHast(internal, _code, _options),\n    codeToTokens: (_code, _options)=>codeToTokens(internal, _code, _options)\n}) {\n    let input = code;\n    for (const transformer of getTransformers(options))input = transformer.preprocess?.call(transformerContext, input, options) || input;\n    let { tokens, fg, bg, themeName, rootStyle, grammarState } = codeToTokens(internal, input, options);\n    const { mergeWhitespaces = true, mergeSameStyleTokens = false } = options;\n    if (mergeWhitespaces === true) tokens = mergeWhitespaceTokens(tokens);\n    else if (mergeWhitespaces === \"never\") tokens = splitWhitespaceTokens(tokens);\n    if (mergeSameStyleTokens) {\n        tokens = mergeAdjacentStyledTokens(tokens);\n    }\n    const contextSource = {\n        ...transformerContext,\n        get source () {\n            return input;\n        }\n    };\n    for (const transformer of getTransformers(options))tokens = transformer.tokens?.call(contextSource, tokens) || tokens;\n    return tokensToHast(tokens, {\n        ...options,\n        fg,\n        bg,\n        themeName,\n        rootStyle: options.rootStyle === false ? false : options.rootStyle ?? rootStyle\n    }, contextSource, grammarState);\n}\nfunction tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {\n    const transformers = getTransformers(options);\n    const lines = [];\n    const root = {\n        type: \"root\",\n        children: []\n    };\n    const { structure = \"classic\", tabindex = \"0\" } = options;\n    const properties = {\n        class: `shiki ${options.themeName || \"\"}`\n    };\n    if (options.rootStyle !== false) {\n        if (options.rootStyle != null) properties.style = options.rootStyle;\n        else properties.style = `background-color:${options.bg};color:${options.fg}`;\n    }\n    if (tabindex !== false && tabindex != null) properties.tabindex = tabindex.toString();\n    for (const [key, value] of Object.entries(options.meta || {})){\n        if (!key.startsWith(\"_\")) properties[key] = value;\n    }\n    let preNode = {\n        type: \"element\",\n        tagName: \"pre\",\n        properties,\n        children: [],\n        data: options.data\n    };\n    let codeNode = {\n        type: \"element\",\n        tagName: \"code\",\n        properties: {},\n        children: lines\n    };\n    const lineNodes = [];\n    const context = {\n        ...transformerContext,\n        structure,\n        addClassToHast,\n        get source () {\n            return transformerContext.source;\n        },\n        get tokens () {\n            return tokens;\n        },\n        get options () {\n            return options;\n        },\n        get root () {\n            return root;\n        },\n        get pre () {\n            return preNode;\n        },\n        get code () {\n            return codeNode;\n        },\n        get lines () {\n            return lineNodes;\n        }\n    };\n    tokens.forEach((line, idx)=>{\n        if (idx) {\n            if (structure === \"inline\") root.children.push({\n                type: \"element\",\n                tagName: \"br\",\n                properties: {},\n                children: []\n            });\n            else if (structure === \"classic\") lines.push({\n                type: \"text\",\n                value: \"\\n\"\n            });\n        }\n        let lineNode = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n                class: \"line\"\n            },\n            children: []\n        };\n        let col = 0;\n        for (const token of line){\n            let tokenNode = {\n                type: \"element\",\n                tagName: \"span\",\n                properties: {\n                    ...token.htmlAttrs\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: token.content\n                    }\n                ]\n            };\n            const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n            if (style) tokenNode.properties.style = style;\n            for (const transformer of transformers)tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;\n            if (structure === \"inline\") root.children.push(tokenNode);\n            else if (structure === \"classic\") lineNode.children.push(tokenNode);\n            col += token.content.length;\n        }\n        if (structure === \"classic\") {\n            for (const transformer of transformers)lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;\n            lineNodes.push(lineNode);\n            lines.push(lineNode);\n        } else if (structure === \"inline\") {\n            lineNodes.push(lineNode);\n        }\n    });\n    if (structure === \"classic\") {\n        for (const transformer of transformers)codeNode = transformer?.code?.call(context, codeNode) || codeNode;\n        preNode.children.push(codeNode);\n        for (const transformer of transformers)preNode = transformer?.pre?.call(context, preNode) || preNode;\n        root.children.push(preNode);\n    } else if (structure === \"inline\") {\n        const syntheticLines = [];\n        let currentLine = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {\n                class: \"line\"\n            },\n            children: []\n        };\n        for (const child of root.children){\n            if (child.type === \"element\" && child.tagName === \"br\") {\n                syntheticLines.push(currentLine);\n                currentLine = {\n                    type: \"element\",\n                    tagName: \"span\",\n                    properties: {\n                        class: \"line\"\n                    },\n                    children: []\n                };\n            } else if (child.type === \"element\" || child.type === \"text\") {\n                currentLine.children.push(child);\n            }\n        }\n        syntheticLines.push(currentLine);\n        const syntheticCode = {\n            type: \"element\",\n            tagName: \"code\",\n            properties: {},\n            children: syntheticLines\n        };\n        let transformedCode = syntheticCode;\n        for (const transformer of transformers)transformedCode = transformer?.code?.call(context, transformedCode) || transformedCode;\n        root.children = [];\n        for(let i = 0; i < transformedCode.children.length; i++){\n            if (i > 0) root.children.push({\n                type: \"element\",\n                tagName: \"br\",\n                properties: {},\n                children: []\n            });\n            const line = transformedCode.children[i];\n            if (line.type === \"element\") root.children.push(...line.children);\n        }\n    }\n    let result = root;\n    for (const transformer of transformers)result = transformer?.root?.call(context, result) || result;\n    if (grammarState) setLastGrammarStateToMap(result, grammarState);\n    return result;\n}\nfunction mergeWhitespaceTokens(tokens) {\n    return tokens.map((line)=>{\n        const newLine = [];\n        let carryOnContent = \"\";\n        let firstOffset;\n        line.forEach((token, idx)=>{\n            const isDecorated = token.fontStyle && (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline || token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough);\n            const couldMerge = !isDecorated;\n            if (couldMerge && token.content.match(/^\\s+$/) && line[idx + 1]) {\n                if (firstOffset === void 0) firstOffset = token.offset;\n                carryOnContent += token.content;\n            } else {\n                if (carryOnContent) {\n                    if (couldMerge) {\n                        newLine.push({\n                            ...token,\n                            offset: firstOffset,\n                            content: carryOnContent + token.content\n                        });\n                    } else {\n                        newLine.push({\n                            content: carryOnContent,\n                            offset: firstOffset\n                        }, token);\n                    }\n                    firstOffset = void 0;\n                    carryOnContent = \"\";\n                } else {\n                    newLine.push(token);\n                }\n            }\n        });\n        return newLine;\n    });\n}\nfunction splitWhitespaceTokens(tokens) {\n    return tokens.map((line)=>{\n        return line.flatMap((token)=>{\n            if (token.content.match(/^\\s+$/)) return token;\n            const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n            if (!match) return token;\n            const [, leading, content, trailing] = match;\n            if (!leading && !trailing) return token;\n            const expanded = [\n                {\n                    ...token,\n                    offset: token.offset + leading.length,\n                    content\n                }\n            ];\n            if (leading) {\n                expanded.unshift({\n                    content: leading,\n                    offset: token.offset\n                });\n            }\n            if (trailing) {\n                expanded.push({\n                    content: trailing,\n                    offset: token.offset + leading.length + content.length\n                });\n            }\n            return expanded;\n        });\n    });\n}\nfunction mergeAdjacentStyledTokens(tokens) {\n    return tokens.map((line)=>{\n        const newLine = [];\n        for (const token of line){\n            if (newLine.length === 0) {\n                newLine.push({\n                    ...token\n                });\n                continue;\n            }\n            const prevToken = newLine[newLine.length - 1];\n            const prevStyle = stringifyTokenStyle(prevToken.htmlStyle || getTokenStyleObject(prevToken));\n            const currentStyle = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n            const isPrevDecorated = prevToken.fontStyle && (prevToken.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline || prevToken.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough);\n            const isDecorated = token.fontStyle && (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Underline || token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Strikethrough);\n            if (!isPrevDecorated && !isDecorated && prevStyle === currentStyle) {\n                prevToken.content += token.content;\n            } else {\n                newLine.push({\n                    ...token\n                });\n            }\n        }\n        return newLine;\n    });\n}\nconst hastToHtml = hast_util_to_html__WEBPACK_IMPORTED_MODULE_2__.toHtml;\nfunction codeToHtml(internal, code, options) {\n    const context = {\n        meta: {},\n        options,\n        codeToHast: (_code, _options)=>codeToHast(internal, _code, _options),\n        codeToTokens: (_code, _options)=>codeToTokens(internal, _code, _options)\n    };\n    let result = hastToHtml(codeToHast(internal, code, options, context));\n    for (const transformer of getTransformers(options))result = transformer.postprocess?.call(context, result, options) || result;\n    return result;\n}\nconst VSCODE_FALLBACK_EDITOR_FG = {\n    light: \"#333333\",\n    dark: \"#bbbbbb\"\n};\nconst VSCODE_FALLBACK_EDITOR_BG = {\n    light: \"#fffffe\",\n    dark: \"#1e1e1e\"\n};\nconst RESOLVED_KEY = \"__shiki_resolved\";\nfunction normalizeTheme(rawTheme) {\n    if (rawTheme?.[RESOLVED_KEY]) return rawTheme;\n    const theme = {\n        ...rawTheme\n    };\n    if (theme.tokenColors && !theme.settings) {\n        theme.settings = theme.tokenColors;\n        delete theme.tokenColors;\n    }\n    theme.type ||= \"dark\";\n    theme.colorReplacements = {\n        ...theme.colorReplacements\n    };\n    theme.settings ||= [];\n    let { bg, fg } = theme;\n    if (!bg || !fg) {\n        const globalSetting = theme.settings ? theme.settings.find((s)=>!s.name && !s.scope) : void 0;\n        if (globalSetting?.settings?.foreground) fg = globalSetting.settings.foreground;\n        if (globalSetting?.settings?.background) bg = globalSetting.settings.background;\n        if (!fg && theme?.colors?.[\"editor.foreground\"]) fg = theme.colors[\"editor.foreground\"];\n        if (!bg && theme?.colors?.[\"editor.background\"]) bg = theme.colors[\"editor.background\"];\n        if (!fg) fg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;\n        if (!bg) bg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;\n        theme.fg = fg;\n        theme.bg = bg;\n    }\n    if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {\n        theme.settings.unshift({\n            settings: {\n                foreground: theme.fg,\n                background: theme.bg\n            }\n        });\n    }\n    let replacementCount = 0;\n    const replacementMap = /* @__PURE__ */ new Map();\n    function getReplacementColor(value) {\n        if (replacementMap.has(value)) return replacementMap.get(value);\n        replacementCount += 1;\n        const hex = `#${replacementCount.toString(16).padStart(8, \"0\").toLowerCase()}`;\n        if (theme.colorReplacements?.[`#${hex}`]) return getReplacementColor(value);\n        replacementMap.set(value, hex);\n        return hex;\n    }\n    theme.settings = theme.settings.map((setting)=>{\n        const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith(\"#\");\n        const replaceBg = setting.settings?.background && !setting.settings.background.startsWith(\"#\");\n        if (!replaceFg && !replaceBg) return setting;\n        const clone = {\n            ...setting,\n            settings: {\n                ...setting.settings\n            }\n        };\n        if (replaceFg) {\n            const replacement = getReplacementColor(setting.settings.foreground);\n            theme.colorReplacements[replacement] = setting.settings.foreground;\n            clone.settings.foreground = replacement;\n        }\n        if (replaceBg) {\n            const replacement = getReplacementColor(setting.settings.background);\n            theme.colorReplacements[replacement] = setting.settings.background;\n            clone.settings.background = replacement;\n        }\n        return clone;\n    });\n    for (const key of Object.keys(theme.colors || {})){\n        if (key === \"editor.foreground\" || key === \"editor.background\" || key.startsWith(\"terminal.ansi\")) {\n            if (!theme.colors[key]?.startsWith(\"#\")) {\n                const replacement = getReplacementColor(theme.colors[key]);\n                theme.colorReplacements[replacement] = theme.colors[key];\n                theme.colors[key] = replacement;\n            }\n        }\n    }\n    Object.defineProperty(theme, RESOLVED_KEY, {\n        enumerable: false,\n        writable: false,\n        value: true\n    });\n    return theme;\n}\nasync function resolveLangs(langs) {\n    return Array.from(new Set((await Promise.all(langs.filter((l)=>!isSpecialLang(l)).map(async (lang)=>await normalizeGetter(lang).then((r)=>Array.isArray(r) ? r : [\n                r\n            ])))).flat()));\n}\nasync function resolveThemes(themes) {\n    const resolved = await Promise.all(themes.map(async (theme)=>isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))));\n    return resolved.filter((i)=>!!i);\n}\nlet _emitDeprecation = 3;\nlet _emitError = false;\nfunction enableDeprecationWarnings(emitDeprecation = true, emitError = false) {\n    _emitDeprecation = emitDeprecation;\n    _emitError = emitError;\n}\nfunction warnDeprecated(message, version = 3) {\n    if (!_emitDeprecation) return;\n    if (typeof _emitDeprecation === \"number\" && version > _emitDeprecation) return;\n    if (_emitError) {\n        throw new Error(`[SHIKI DEPRECATE]: ${message}`);\n    } else {\n        console.trace(`[SHIKI DEPRECATE]: ${message}`);\n    }\n}\nclass ShikiError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"ShikiError\";\n    }\n}\nfunction resolveLangAlias(name, alias) {\n    if (!alias) return name;\n    if (alias[name]) {\n        const resolved = /* @__PURE__ */ new Set([\n            name\n        ]);\n        while(alias[name]){\n            name = alias[name];\n            if (resolved.has(name)) throw new ShikiError(`Circular alias \\`${Array.from(resolved).join(\" -> \")} -> ${name}\\``);\n            resolved.add(name);\n        }\n    }\n    return name;\n}\nclass Registry extends _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.Registry {\n    constructor(_resolver, _themes, _langs, _alias = {}){\n        super(_resolver);\n        this._resolvedThemes = /* @__PURE__ */ new Map();\n        this._resolvedGrammars = /* @__PURE__ */ new Map();\n        this._langMap = /* @__PURE__ */ new Map();\n        this._langGraph = /* @__PURE__ */ new Map();\n        this._textmateThemeCache = /* @__PURE__ */ new WeakMap();\n        this._loadedThemesCache = null;\n        this._loadedLanguagesCache = null;\n        this._resolver = _resolver;\n        this._themes = _themes;\n        this._langs = _langs;\n        this._alias = _alias;\n        this._themes.map((t)=>this.loadTheme(t));\n        this.loadLanguages(this._langs);\n    }\n    getTheme(theme) {\n        if (typeof theme === \"string\") return this._resolvedThemes.get(theme);\n        else return this.loadTheme(theme);\n    }\n    loadTheme(theme) {\n        const _theme = normalizeTheme(theme);\n        if (_theme.name) {\n            this._resolvedThemes.set(_theme.name, _theme);\n            this._loadedThemesCache = null;\n        }\n        return _theme;\n    }\n    getLoadedThemes() {\n        if (!this._loadedThemesCache) this._loadedThemesCache = [\n            ...this._resolvedThemes.keys()\n        ];\n        return this._loadedThemesCache;\n    }\n    // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`\n    // is expensive. Themes can switch often especially for dual-theme support.\n    //\n    // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,\n    // we omit here so it's easier to cache the themes.\n    setTheme(theme) {\n        let textmateTheme = this._textmateThemeCache.get(theme);\n        if (!textmateTheme) {\n            textmateTheme = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_1__.Theme.createFromRawTheme(theme);\n            this._textmateThemeCache.set(theme, textmateTheme);\n        }\n        this._syncRegistry.setTheme(textmateTheme);\n    }\n    getGrammar(name) {\n        name = resolveLangAlias(name, this._alias);\n        return this._resolvedGrammars.get(name);\n    }\n    loadLanguage(lang) {\n        if (this.getGrammar(lang.name)) return;\n        const embeddedLazilyBy = new Set([\n            ...this._langMap.values()\n        ].filter((i)=>i.embeddedLangsLazy?.includes(lang.name)));\n        this._resolver.addLanguage(lang);\n        const grammarConfig = {\n            balancedBracketSelectors: lang.balancedBracketSelectors || [\n                \"*\"\n            ],\n            unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []\n        };\n        this._syncRegistry._rawGrammars.set(lang.scopeName, lang);\n        const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);\n        g.name = lang.name;\n        this._resolvedGrammars.set(lang.name, g);\n        if (lang.aliases) {\n            lang.aliases.forEach((alias)=>{\n                this._alias[alias] = lang.name;\n            });\n        }\n        this._loadedLanguagesCache = null;\n        if (embeddedLazilyBy.size) {\n            for (const e of embeddedLazilyBy){\n                this._resolvedGrammars.delete(e.name);\n                this._loadedLanguagesCache = null;\n                this._syncRegistry?._injectionGrammars?.delete(e.scopeName);\n                this._syncRegistry?._grammars?.delete(e.scopeName);\n                this.loadLanguage(this._langMap.get(e.name));\n            }\n        }\n    }\n    dispose() {\n        super.dispose();\n        this._resolvedThemes.clear();\n        this._resolvedGrammars.clear();\n        this._langMap.clear();\n        this._langGraph.clear();\n        this._loadedThemesCache = null;\n    }\n    loadLanguages(langs) {\n        for (const lang of langs)this.resolveEmbeddedLanguages(lang);\n        const langsGraphArray = Array.from(this._langGraph.entries());\n        const missingLangs = langsGraphArray.filter(([_, lang])=>!lang);\n        if (missingLangs.length) {\n            const dependents = langsGraphArray.filter(([_, lang])=>{\n                if (!lang) return false;\n                const embedded = lang.embeddedLanguages || lang.embeddedLangs;\n                return embedded?.some((l)=>missingLangs.map(([name])=>name).includes(l));\n            }).filter((lang)=>!missingLangs.includes(lang));\n            throw new ShikiError(`Missing languages ${missingLangs.map(([name])=>`\\`${name}\\``).join(\", \")}, required by ${dependents.map(([name])=>`\\`${name}\\``).join(\", \")}`);\n        }\n        for (const [_, lang] of langsGraphArray)this._resolver.addLanguage(lang);\n        for (const [_, lang] of langsGraphArray)this.loadLanguage(lang);\n    }\n    getLoadedLanguages() {\n        if (!this._loadedLanguagesCache) {\n            this._loadedLanguagesCache = [\n                .../* @__PURE__ */ new Set([\n                    ...this._resolvedGrammars.keys(),\n                    ...Object.keys(this._alias)\n                ])\n            ];\n        }\n        return this._loadedLanguagesCache;\n    }\n    resolveEmbeddedLanguages(lang) {\n        this._langMap.set(lang.name, lang);\n        this._langGraph.set(lang.name, lang);\n        const embedded = lang.embeddedLanguages ?? lang.embeddedLangs;\n        if (embedded) {\n            for (const embeddedLang of embedded)this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));\n        }\n    }\n}\nclass Resolver {\n    constructor(engine, langs){\n        this._langs = /* @__PURE__ */ new Map();\n        this._scopeToLang = /* @__PURE__ */ new Map();\n        this._injections = /* @__PURE__ */ new Map();\n        this._onigLib = {\n            createOnigScanner: (patterns)=>engine.createScanner(patterns),\n            createOnigString: (s)=>engine.createString(s)\n        };\n        langs.forEach((i)=>this.addLanguage(i));\n    }\n    get onigLib() {\n        return this._onigLib;\n    }\n    getLangRegistration(langIdOrAlias) {\n        return this._langs.get(langIdOrAlias);\n    }\n    loadGrammar(scopeName) {\n        return this._scopeToLang.get(scopeName);\n    }\n    addLanguage(l) {\n        this._langs.set(l.name, l);\n        if (l.aliases) {\n            l.aliases.forEach((a)=>{\n                this._langs.set(a, l);\n            });\n        }\n        this._scopeToLang.set(l.scopeName, l);\n        if (l.injectTo) {\n            l.injectTo.forEach((i)=>{\n                if (!this._injections.get(i)) this._injections.set(i, []);\n                this._injections.get(i).push(l.scopeName);\n            });\n        }\n    }\n    getInjections(scopeName) {\n        const scopeParts = scopeName.split(\".\");\n        let injections = [];\n        for(let i = 1; i <= scopeParts.length; i++){\n            const subScopeName = scopeParts.slice(0, i).join(\".\");\n            injections = [\n                ...injections,\n                ...this._injections.get(subScopeName) || []\n            ];\n        }\n        return injections;\n    }\n}\nlet instancesCount = 0;\nfunction createShikiInternalSync(options) {\n    instancesCount += 1;\n    if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0) console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \\`highlighter.dispose()\\` to release unused instances.`);\n    let isDisposed = false;\n    if (!options.engine) throw new ShikiError(\"`engine` option is required for synchronous mode\");\n    const langs = (options.langs || []).flat(1);\n    const themes = (options.themes || []).flat(1).map(normalizeTheme);\n    const resolver = new Resolver(options.engine, langs);\n    const _registry = new Registry(resolver, themes, langs, options.langAlias);\n    let _lastTheme;\n    function resolveLangAlias$1(name) {\n        return resolveLangAlias(name, options.langAlias);\n    }\n    function getLanguage(name) {\n        ensureNotDisposed();\n        const _lang = _registry.getGrammar(typeof name === \"string\" ? name : name.name);\n        if (!_lang) throw new ShikiError(`Language \\`${name}\\` not found, you may need to load it first`);\n        return _lang;\n    }\n    function getTheme(name) {\n        if (name === \"none\") return {\n            bg: \"\",\n            fg: \"\",\n            name: \"none\",\n            settings: [],\n            type: \"dark\"\n        };\n        ensureNotDisposed();\n        const _theme = _registry.getTheme(name);\n        if (!_theme) throw new ShikiError(`Theme \\`${name}\\` not found, you may need to load it first`);\n        return _theme;\n    }\n    function setTheme(name) {\n        ensureNotDisposed();\n        const theme = getTheme(name);\n        if (_lastTheme !== name) {\n            _registry.setTheme(theme);\n            _lastTheme = name;\n        }\n        const colorMap = _registry.getColorMap();\n        return {\n            theme,\n            colorMap\n        };\n    }\n    function getLoadedThemes() {\n        ensureNotDisposed();\n        return _registry.getLoadedThemes();\n    }\n    function getLoadedLanguages() {\n        ensureNotDisposed();\n        return _registry.getLoadedLanguages();\n    }\n    function loadLanguageSync(...langs2) {\n        ensureNotDisposed();\n        _registry.loadLanguages(langs2.flat(1));\n    }\n    async function loadLanguage(...langs2) {\n        return loadLanguageSync(await resolveLangs(langs2));\n    }\n    function loadThemeSync(...themes2) {\n        ensureNotDisposed();\n        for (const theme of themes2.flat(1)){\n            _registry.loadTheme(theme);\n        }\n    }\n    async function loadTheme(...themes2) {\n        ensureNotDisposed();\n        return loadThemeSync(await resolveThemes(themes2));\n    }\n    function ensureNotDisposed() {\n        if (isDisposed) throw new ShikiError(\"Shiki instance has been disposed\");\n    }\n    function dispose() {\n        if (isDisposed) return;\n        isDisposed = true;\n        _registry.dispose();\n        instancesCount -= 1;\n    }\n    return {\n        setTheme,\n        getTheme,\n        getLanguage,\n        getLoadedThemes,\n        getLoadedLanguages,\n        resolveLangAlias: resolveLangAlias$1,\n        loadLanguage,\n        loadLanguageSync,\n        loadTheme,\n        loadThemeSync,\n        dispose,\n        [Symbol.dispose]: dispose\n    };\n}\nasync function createShikiInternal(options) {\n    if (!options.engine) {\n        warnDeprecated(\"`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.\");\n    }\n    const [themes, langs, engine] = await Promise.all([\n        resolveThemes(options.themes || []),\n        resolveLangs(options.langs || []),\n        options.engine\n    ]);\n    return createShikiInternalSync({\n        ...options,\n        themes,\n        langs,\n        engine\n    });\n}\nasync function createHighlighterCore(options) {\n    const internal = await createShikiInternal(options);\n    return {\n        getLastGrammarState: (...args)=>getLastGrammarState(internal, ...args),\n        codeToTokensBase: (code, options2)=>codeToTokensBase(internal, code, options2),\n        codeToTokensWithThemes: (code, options2)=>codeToTokensWithThemes(internal, code, options2),\n        codeToTokens: (code, options2)=>codeToTokens(internal, code, options2),\n        codeToHast: (code, options2)=>codeToHast(internal, code, options2),\n        codeToHtml: (code, options2)=>codeToHtml(internal, code, options2),\n        getBundledLanguages: ()=>({}),\n        getBundledThemes: ()=>({}),\n        ...internal,\n        getInternalContext: ()=>internal\n    };\n}\nfunction createHighlighterCoreSync(options) {\n    const internal = createShikiInternalSync(options);\n    return {\n        getLastGrammarState: (...args)=>getLastGrammarState(internal, ...args),\n        codeToTokensBase: (code, options2)=>codeToTokensBase(internal, code, options2),\n        codeToTokensWithThemes: (code, options2)=>codeToTokensWithThemes(internal, code, options2),\n        codeToTokens: (code, options2)=>codeToTokens(internal, code, options2),\n        codeToHast: (code, options2)=>codeToHast(internal, code, options2),\n        codeToHtml: (code, options2)=>codeToHtml(internal, code, options2),\n        getBundledLanguages: ()=>({}),\n        getBundledThemes: ()=>({}),\n        ...internal,\n        getInternalContext: ()=>internal\n    };\n}\nfunction makeSingletonHighlighterCore(createHighlighter) {\n    let _shiki;\n    async function getSingletonHighlighterCore2(options) {\n        if (!_shiki) {\n            _shiki = createHighlighter({\n                ...options,\n                themes: options.themes || [],\n                langs: options.langs || []\n            });\n            return _shiki;\n        } else {\n            const s = await _shiki;\n            await Promise.all([\n                s.loadTheme(...options.themes || []),\n                s.loadLanguage(...options.langs || [])\n            ]);\n            return s;\n        }\n    }\n    return getSingletonHighlighterCore2;\n}\nconst getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);\nfunction createBundledHighlighter(options) {\n    const bundledLanguages = options.langs;\n    const bundledThemes = options.themes;\n    const engine = options.engine;\n    async function createHighlighter(options2) {\n        function resolveLang(lang) {\n            if (typeof lang === \"string\") {\n                lang = options2.langAlias?.[lang] || lang;\n                if (isSpecialLang(lang)) return [];\n                const bundle = bundledLanguages[lang];\n                if (!bundle) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Language \\`${lang}\\` is not included in this bundle. You may want to load it from external source.`);\n                return bundle;\n            }\n            return lang;\n        }\n        function resolveTheme(theme) {\n            if (isSpecialTheme(theme)) return \"none\";\n            if (typeof theme === \"string\") {\n                const bundle = bundledThemes[theme];\n                if (!bundle) throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Theme \\`${theme}\\` is not included in this bundle. You may want to load it from external source.`);\n                return bundle;\n            }\n            return theme;\n        }\n        const _themes = (options2.themes ?? []).map((i)=>resolveTheme(i));\n        const langs = (options2.langs ?? []).map((i)=>resolveLang(i));\n        const core = await createHighlighterCore({\n            engine: options2.engine ?? engine(),\n            ...options2,\n            themes: _themes,\n            langs\n        });\n        return {\n            ...core,\n            loadLanguage (...langs2) {\n                return core.loadLanguage(...langs2.map(resolveLang));\n            },\n            loadTheme (...themes) {\n                return core.loadTheme(...themes.map(resolveTheme));\n            },\n            getBundledLanguages () {\n                return bundledLanguages;\n            },\n            getBundledThemes () {\n                return bundledThemes;\n            }\n        };\n    }\n    return createHighlighter;\n}\nfunction makeSingletonHighlighter(createHighlighter) {\n    let _shiki;\n    async function getSingletonHighlighter(options = {}) {\n        if (!_shiki) {\n            _shiki = createHighlighter({\n                ...options,\n                themes: [],\n                langs: []\n            });\n            const s = await _shiki;\n            await Promise.all([\n                s.loadTheme(...options.themes || []),\n                s.loadLanguage(...options.langs || [])\n            ]);\n            return s;\n        } else {\n            const s = await _shiki;\n            await Promise.all([\n                s.loadTheme(...options.themes || []),\n                s.loadLanguage(...options.langs || [])\n            ]);\n            return s;\n        }\n    }\n    return getSingletonHighlighter;\n}\nfunction createSingletonShorthands(createHighlighter, config) {\n    const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);\n    async function get(code, options) {\n        const shiki = await getSingletonHighlighter({\n            langs: [\n                options.lang\n            ],\n            themes: \"theme\" in options ? [\n                options.theme\n            ] : Object.values(options.themes)\n        });\n        const langs = await config?.guessEmbeddedLanguages?.(code, options.lang, shiki);\n        if (langs) {\n            await shiki.loadLanguage(...langs);\n        }\n        return shiki;\n    }\n    return {\n        getSingletonHighlighter (options) {\n            return getSingletonHighlighter(options);\n        },\n        async codeToHtml (code, options) {\n            const shiki = await get(code, options);\n            return shiki.codeToHtml(code, options);\n        },\n        async codeToHast (code, options) {\n            const shiki = await get(code, options);\n            return shiki.codeToHast(code, options);\n        },\n        async codeToTokens (code, options) {\n            const shiki = await get(code, options);\n            return shiki.codeToTokens(code, options);\n        },\n        async codeToTokensBase (code, options) {\n            const shiki = await get(code, options);\n            return shiki.codeToTokensBase(code, options);\n        },\n        async codeToTokensWithThemes (code, options) {\n            const shiki = await get(code, options);\n            return shiki.codeToTokensWithThemes(code, options);\n        },\n        async getLastGrammarState (code, options) {\n            const shiki = await getSingletonHighlighter({\n                langs: [\n                    options.lang\n                ],\n                themes: [\n                    options.theme\n                ]\n            });\n            return shiki.getLastGrammarState(code, options);\n        }\n    };\n}\nconst createdBundledHighlighter = createBundledHighlighter;\nfunction createCssVariablesTheme(options = {}) {\n    const { name = \"css-variables\", variablePrefix = \"--shiki-\", fontStyle = true } = options;\n    const variable = (name2)=>{\n        if (options.variableDefaults?.[name2]) return `var(${variablePrefix}${name2}, ${options.variableDefaults[name2]})`;\n        return `var(${variablePrefix}${name2})`;\n    };\n    const theme = {\n        name,\n        type: \"dark\",\n        colors: {\n            \"editor.foreground\": variable(\"foreground\"),\n            \"editor.background\": variable(\"background\"),\n            \"terminal.ansiBlack\": variable(\"ansi-black\"),\n            \"terminal.ansiRed\": variable(\"ansi-red\"),\n            \"terminal.ansiGreen\": variable(\"ansi-green\"),\n            \"terminal.ansiYellow\": variable(\"ansi-yellow\"),\n            \"terminal.ansiBlue\": variable(\"ansi-blue\"),\n            \"terminal.ansiMagenta\": variable(\"ansi-magenta\"),\n            \"terminal.ansiCyan\": variable(\"ansi-cyan\"),\n            \"terminal.ansiWhite\": variable(\"ansi-white\"),\n            \"terminal.ansiBrightBlack\": variable(\"ansi-bright-black\"),\n            \"terminal.ansiBrightRed\": variable(\"ansi-bright-red\"),\n            \"terminal.ansiBrightGreen\": variable(\"ansi-bright-green\"),\n            \"terminal.ansiBrightYellow\": variable(\"ansi-bright-yellow\"),\n            \"terminal.ansiBrightBlue\": variable(\"ansi-bright-blue\"),\n            \"terminal.ansiBrightMagenta\": variable(\"ansi-bright-magenta\"),\n            \"terminal.ansiBrightCyan\": variable(\"ansi-bright-cyan\"),\n            \"terminal.ansiBrightWhite\": variable(\"ansi-bright-white\")\n        },\n        tokenColors: [\n            {\n                scope: [\n                    \"keyword.operator.accessor\",\n                    \"meta.group.braces.round.function.arguments\",\n                    \"meta.template.expression\",\n                    \"markup.fenced_code meta.embedded.block\"\n                ],\n                settings: {\n                    foreground: variable(\"foreground\")\n                }\n            },\n            {\n                scope: \"emphasis\",\n                settings: {\n                    fontStyle: \"italic\"\n                }\n            },\n            {\n                scope: [\n                    \"strong\",\n                    \"markup.heading.markdown\",\n                    \"markup.bold.markdown\"\n                ],\n                settings: {\n                    fontStyle: \"bold\"\n                }\n            },\n            {\n                scope: [\n                    \"markup.italic.markdown\"\n                ],\n                settings: {\n                    fontStyle: \"italic\"\n                }\n            },\n            {\n                scope: \"meta.link.inline.markdown\",\n                settings: {\n                    fontStyle: \"underline\",\n                    foreground: variable(\"token-link\")\n                }\n            },\n            {\n                scope: [\n                    \"string\",\n                    \"markup.fenced_code\",\n                    \"markup.inline\"\n                ],\n                settings: {\n                    foreground: variable(\"token-string\")\n                }\n            },\n            {\n                scope: [\n                    \"comment\",\n                    \"string.quoted.docstring.multi\"\n                ],\n                settings: {\n                    foreground: variable(\"token-comment\")\n                }\n            },\n            {\n                scope: [\n                    \"constant.numeric\",\n                    \"constant.language\",\n                    \"constant.other.placeholder\",\n                    \"constant.character.format.placeholder\",\n                    \"variable.language.this\",\n                    \"variable.other.object\",\n                    \"variable.other.class\",\n                    \"variable.other.constant\",\n                    \"meta.property-name\",\n                    \"meta.property-value\",\n                    \"support\"\n                ],\n                settings: {\n                    foreground: variable(\"token-constant\")\n                }\n            },\n            {\n                scope: [\n                    \"keyword\",\n                    \"storage.modifier\",\n                    \"storage.type\",\n                    \"storage.control.clojure\",\n                    \"entity.name.function.clojure\",\n                    \"entity.name.tag.yaml\",\n                    \"support.function.node\",\n                    \"support.type.property-name.json\",\n                    \"punctuation.separator.key-value\",\n                    \"punctuation.definition.template-expression\"\n                ],\n                settings: {\n                    foreground: variable(\"token-keyword\")\n                }\n            },\n            {\n                scope: \"variable.parameter.function\",\n                settings: {\n                    foreground: variable(\"token-parameter\")\n                }\n            },\n            {\n                scope: [\n                    \"support.function\",\n                    \"entity.name.type\",\n                    \"entity.other.inherited-class\",\n                    \"meta.function-call\",\n                    \"meta.instance.constructor\",\n                    \"entity.other.attribute-name\",\n                    \"entity.name.function\",\n                    \"constant.keyword.clojure\"\n                ],\n                settings: {\n                    foreground: variable(\"token-function\")\n                }\n            },\n            {\n                scope: [\n                    \"entity.name.tag\",\n                    \"string.quoted\",\n                    \"string.regexp\",\n                    \"string.interpolated\",\n                    \"string.template\",\n                    \"string.unquoted.plain.out.yaml\",\n                    \"keyword.other.template\"\n                ],\n                settings: {\n                    foreground: variable(\"token-string-expression\")\n                }\n            },\n            {\n                scope: [\n                    \"punctuation.definition.arguments\",\n                    \"punctuation.definition.dict\",\n                    \"punctuation.separator\",\n                    \"meta.function-call.arguments\"\n                ],\n                settings: {\n                    foreground: variable(\"token-punctuation\")\n                }\n            },\n            {\n                // [Custom] Markdown links\n                scope: [\n                    \"markup.underline.link\",\n                    \"punctuation.definition.metadata.markdown\"\n                ],\n                settings: {\n                    foreground: variable(\"token-link\")\n                }\n            },\n            {\n                // [Custom] Markdown list\n                scope: [\n                    \"beginning.punctuation.definition.list.markdown\"\n                ],\n                settings: {\n                    foreground: variable(\"token-string\")\n                }\n            },\n            {\n                // [Custom] Markdown punctuation definition brackets\n                scope: [\n                    \"punctuation.definition.string.begin.markdown\",\n                    \"punctuation.definition.string.end.markdown\",\n                    \"string.other.link.title.markdown\",\n                    \"string.other.link.description.markdown\"\n                ],\n                settings: {\n                    foreground: variable(\"token-keyword\")\n                }\n            },\n            {\n                // [Custom] Diff\n                scope: [\n                    \"markup.inserted\",\n                    \"meta.diff.header.to-file\",\n                    \"punctuation.definition.inserted\"\n                ],\n                settings: {\n                    foreground: variable(\"token-inserted\")\n                }\n            },\n            {\n                scope: [\n                    \"markup.deleted\",\n                    \"meta.diff.header.from-file\",\n                    \"punctuation.definition.deleted\"\n                ],\n                settings: {\n                    foreground: variable(\"token-deleted\")\n                }\n            },\n            {\n                scope: [\n                    \"markup.changed\",\n                    \"punctuation.definition.changed\"\n                ],\n                settings: {\n                    foreground: variable(\"token-changed\")\n                }\n            }\n        ]\n    };\n    if (!fontStyle) {\n        theme.tokenColors = theme.tokenColors?.map((tokenColor)=>{\n            if (tokenColor.settings?.fontStyle) delete tokenColor.settings.fontStyle;\n            return tokenColor;\n        });\n    }\n    return theme;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrY29yZUAzLjIxLjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2NvcmUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTREO0FBQzdCO0FBQ29GO0FBQ3hFO0FBRTNDLFNBQVNTLHlCQUF5QkMsS0FBSyxFQUFFQyxPQUFPO0lBQzlDLE1BQU1DLGVBQWUsT0FBT0YsVUFBVSxXQUFXLENBQUMsSUFBSTtRQUFFLEdBQUdBLE1BQU1HLGlCQUFpQjtJQUFDO0lBQ25GLE1BQU1DLFlBQVksT0FBT0osVUFBVSxXQUFXQSxRQUFRQSxNQUFNSyxJQUFJO0lBQ2hFLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1IsU0FBU0UscUJBQXFCLENBQUMsR0FBSTtRQUMzRSxJQUFJLE9BQU9JLFVBQVUsVUFDbkJMLFlBQVksQ0FBQ0ksSUFBSSxHQUFHQzthQUNqQixJQUFJRCxRQUFRRixXQUNmSSxPQUFPRSxNQUFNLENBQUNSLGNBQWNLO0lBQ2hDO0lBQ0EsT0FBT0w7QUFDVDtBQUNBLFNBQVNTLHVCQUF1QkMsS0FBSyxFQUFFVixZQUFZO0lBQ2pELElBQUksQ0FBQ1UsT0FDSCxPQUFPQTtJQUNULE9BQU9WLGNBQWMsQ0FBQ1UsT0FBT0MsY0FBYyxJQUFJRDtBQUNqRDtBQUVBLFNBQVNFLFFBQVFDLENBQUM7SUFDaEIsT0FBT0MsTUFBTUMsT0FBTyxDQUFDRixLQUFLQSxJQUFJO1FBQUNBO0tBQUU7QUFDbkM7QUFDQSxlQUFlRyxnQkFBZ0JDLENBQUM7SUFDOUIsT0FBT0MsUUFBUUMsT0FBTyxDQUFDLE9BQU9GLE1BQU0sYUFBYUEsTUFBTUEsR0FBR0csSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVDLE9BQU8sSUFBSUQ7QUFDckY7QUFDQSxTQUFTRSxZQUFZQyxJQUFJO0lBQ3ZCLE9BQU8s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QUFTO2dCQUN2QjtZQUNGO1lBQ0E7Z0JBQ0UsMEJBQTBCO2dCQUMxQmpQLE9BQU87b0JBQ0w7b0JBQ0E7aUJBQ0Q7Z0JBQ0RGLFVBQVU7b0JBQ1I3RixZQUFZZ1YsU0FBUztnQkFDdkI7WUFDRjtZQUNBO2dCQUNFLHlCQUF5QjtnQkFDekJqUCxPQUFPO29CQUFDO2lCQUFpRDtnQkFDekRGLFVBQVU7b0JBQ1I3RixZQUFZZ1YsU0FBUztnQkFDdkI7WUFDRjtZQUNBO2dCQUNFLG9EQUFvRDtnQkFDcERqUCxPQUFPO29CQUNMO29CQUNBO29CQUNBO29CQUNBO2lCQUNEO2dCQUNERixVQUFVO29CQUNSN0YsWUFBWWdWLFNBQVM7Z0JBQ3ZCO1lBQ0Y7WUFDQTtnQkFDRSxnQkFBZ0I7Z0JBQ2hCalAsT0FBTztvQkFDTDtvQkFDQTtvQkFDQTtpQkFDRDtnQkFDREYsVUFBVTtvQkFDUjdGLFlBQVlnVixTQUFTO2dCQUN2QjtZQUNGO1lBQ0E7Z0JBQ0VqUCxPQUFPO29CQUNMO29CQUNBO29CQUNBO2lCQUNEO2dCQUNERixVQUFVO29CQUNSN0YsWUFBWWdWLFNBQVM7Z0JBQ3ZCO1lBQ0Y7WUFDQTtnQkFDRWpQLE9BQU87b0JBQ0w7b0JBQ0E7aUJBQ0Q7Z0JBQ0RGLFVBQVU7b0JBQ1I3RixZQUFZZ1YsU0FBUztnQkFDdkI7WUFDRjtTQUNEO0lBQ0g7SUFDQSxJQUFJLENBQUM5YixXQUFXO1FBQ2RuSCxNQUFNNmEsV0FBVyxHQUFHN2EsTUFBTTZhLFdBQVcsRUFBRTNYLElBQUksQ0FBQ2tnQjtZQUMxQyxJQUFJQSxXQUFXdFAsUUFBUSxFQUFFM00sV0FDdkIsT0FBT2ljLFdBQVd0UCxRQUFRLENBQUMzTSxTQUFTO1lBQ3RDLE9BQU9pYztRQUNUO0lBQ0Y7SUFDQSxPQUFPcGpCO0FBQ1Q7QUFFdXpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VudGluZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrY29yZUAzLjIxLjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2NvcmUvZGlzdC9pbmRleC5tanM/OTY5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaGlraUVycm9yIGFzIFNoaWtpRXJyb3IkMSB9IGZyb20gJ0BzaGlraWpzL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJ0BzaGlraWpzL3R5cGVzJztcbmltcG9ydCB7IEZvbnRTdHlsZSwgSU5JVElBTCwgRW5jb2RlZFRva2VuTWV0YWRhdGEsIFJlZ2lzdHJ5IGFzIFJlZ2lzdHJ5JDEsIFRoZW1lIH0gZnJvbSAnQHNoaWtpanMvdnNjb2RlLXRleHRtYXRlJztcbmltcG9ydCB7IHRvSHRtbCB9IGZyb20gJ2hhc3QtdXRpbC10by1odG1sJztcblxuZnVuY3Rpb24gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcGxhY2VtZW50cyA9IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHt9IDogeyAuLi50aGVtZS5jb2xvclJlcGxhY2VtZW50cyB9O1xuICBjb25zdCB0aGVtZU5hbWUgPSB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IHRoZW1lLm5hbWU7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnM/LmNvbG9yUmVwbGFjZW1lbnRzIHx8IHt9KSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXBsYWNlbWVudHNba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgaWYgKGtleSA9PT0gdGhlbWVOYW1lKVxuICAgICAgT2JqZWN0LmFzc2lnbihyZXBsYWNlbWVudHMsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVwbGFjZW1lbnRzO1xufVxuZnVuY3Rpb24gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhjb2xvciwgcmVwbGFjZW1lbnRzKSB7XG4gIGlmICghY29sb3IpXG4gICAgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gcmVwbGFjZW1lbnRzPy5bY29sb3I/LnRvTG93ZXJDYXNlKCldIHx8IGNvbG9yO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdO1xufVxuYXN5bmMgZnVuY3Rpb24gbm9ybWFsaXplR2V0dGVyKHApIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcCgpIDogcCkudGhlbigocikgPT4gci5kZWZhdWx0IHx8IHIpO1xufVxuZnVuY3Rpb24gaXNQbGFpbkxhbmcobGFuZykge1xuICByZXR1cm4gIWxhbmcgfHwgW1wicGxhaW50ZXh0XCIsIFwidHh0XCIsIFwidGV4dFwiLCBcInBsYWluXCJdLmluY2x1ZGVzKGxhbmcpO1xufVxuZnVuY3Rpb24gaXNTcGVjaWFsTGFuZyhsYW5nKSB7XG4gIHJldHVybiBsYW5nID09PSBcImFuc2lcIiB8fCBpc1BsYWluTGFuZyhsYW5nKTtcbn1cbmZ1bmN0aW9uIGlzTm9uZVRoZW1lKHRoZW1lKSB7XG4gIHJldHVybiB0aGVtZSA9PT0gXCJub25lXCI7XG59XG5mdW5jdGlvbiBpc1NwZWNpYWxUaGVtZSh0aGVtZSkge1xuICByZXR1cm4gaXNOb25lVGhlbWUodGhlbWUpO1xufVxuXG5mdW5jdGlvbiBhZGRDbGFzc1RvSGFzdChub2RlLCBjbGFzc05hbWUpIHtcbiAgaWYgKCFjbGFzc05hbWUpXG4gICAgcmV0dXJuIG5vZGU7XG4gIG5vZGUucHJvcGVydGllcyB8fD0ge307XG4gIG5vZGUucHJvcGVydGllcy5jbGFzcyB8fD0gW107XG4gIGlmICh0eXBlb2Ygbm9kZS5wcm9wZXJ0aWVzLmNsYXNzID09PSBcInN0cmluZ1wiKVxuICAgIG5vZGUucHJvcGVydGllcy5jbGFzcyA9IG5vZGUucHJvcGVydGllcy5jbGFzcy5zcGxpdCgvXFxzKy9nKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUucHJvcGVydGllcy5jbGFzcykpXG4gICAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzID0gW107XG4gIGNvbnN0IHRhcmdldHMgPSBBcnJheS5pc0FycmF5KGNsYXNzTmFtZSkgPyBjbGFzc05hbWUgOiBjbGFzc05hbWUuc3BsaXQoL1xccysvZyk7XG4gIGZvciAoY29uc3QgYyBvZiB0YXJnZXRzKSB7XG4gICAgaWYgKGMgJiYgIW5vZGUucHJvcGVydGllcy5jbGFzcy5pbmNsdWRlcyhjKSlcbiAgICAgIG5vZGUucHJvcGVydGllcy5jbGFzcy5wdXNoKGMpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzcGxpdExpbmVzKGNvZGUsIHByZXNlcnZlRW5kaW5nID0gZmFsc2UpIHtcbiAgaWYgKGNvZGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtbXCJcIiwgMF1dO1xuICB9XG4gIGNvbnN0IHBhcnRzID0gY29kZS5zcGxpdCgvKFxccj9cXG4pL2cpO1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgbGluZSA9IHByZXNlcnZlRW5kaW5nID8gcGFydHNbaV0gKyAocGFydHNbaSArIDFdIHx8IFwiXCIpIDogcGFydHNbaV07XG4gICAgbGluZXMucHVzaChbbGluZSwgaW5kZXhdKTtcbiAgICBpbmRleCArPSBwYXJ0c1tpXS5sZW5ndGg7XG4gICAgaW5kZXggKz0gcGFydHNbaSArIDFdPy5sZW5ndGggfHwgMDtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkNvbnZlcnRlcihjb2RlKSB7XG4gIGNvbnN0IGxpbmVzID0gc3BsaXRMaW5lcyhjb2RlLCB0cnVlKS5tYXAoKFtsaW5lXSkgPT4gbGluZSk7XG4gIGZ1bmN0aW9uIGluZGV4VG9Qb3MoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IGNvZGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBsaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICBjaGFyYWN0ZXI6IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoYXJhY3RlciA9IGluZGV4O1xuICAgIGxldCBsaW5lID0gMDtcbiAgICBmb3IgKGNvbnN0IGxpbmVUZXh0IG9mIGxpbmVzKSB7XG4gICAgICBpZiAoY2hhcmFjdGVyIDwgbGluZVRleHQubGVuZ3RoKVxuICAgICAgICBicmVhaztcbiAgICAgIGNoYXJhY3RlciAtPSBsaW5lVGV4dC5sZW5ndGg7XG4gICAgICBsaW5lKys7XG4gICAgfVxuICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3RlciB9O1xuICB9XG4gIGZ1bmN0aW9uIHBvc1RvSW5kZXgobGluZSwgY2hhcmFjdGVyKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKylcbiAgICAgIGluZGV4ICs9IGxpbmVzW2ldLmxlbmd0aDtcbiAgICBpbmRleCArPSBjaGFyYWN0ZXI7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIHJldHVybiB7XG4gICAgbGluZXMsXG4gICAgaW5kZXhUb1BvcyxcbiAgICBwb3NUb0luZGV4XG4gIH07XG59XG5mdW5jdGlvbiBndWVzc0VtYmVkZGVkTGFuZ3VhZ2VzKGNvZGUsIF9sYW5nLCBoaWdobGlnaHRlcikge1xuICBjb25zdCBsYW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgY29kZS5tYXRjaEFsbCgvOj9sYW5nPVtcIiddKFteXCInXSspW1wiJ10vZykpIHtcbiAgICBjb25zdCBsYW5nID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgaWYgKGxhbmcpXG4gICAgICBsYW5ncy5hZGQobGFuZyk7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaCBvZiBjb2RlLm1hdGNoQWxsKC8oPzpgYGB8fn5+KShbXFx3LV0rKS9nKSkge1xuICAgIGNvbnN0IGxhbmcgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBpZiAobGFuZylcbiAgICAgIGxhbmdzLmFkZChsYW5nKTtcbiAgfVxuICBmb3IgKGNvbnN0IG1hdGNoIG9mIGNvZGUubWF0Y2hBbGwoL1xcXFxiZWdpblxceyhbXFx3LV0rKVxcfS9nKSkge1xuICAgIGNvbnN0IGxhbmcgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBpZiAobGFuZylcbiAgICAgIGxhbmdzLmFkZChsYW5nKTtcbiAgfVxuICBmb3IgKGNvbnN0IG1hdGNoIG9mIGNvZGUubWF0Y2hBbGwoLzxzY3JpcHRcXHMrKD86dHlwZXxsYW5nKT1bXCInXShbXlwiJ10rKVtcIiddL2dpKSkge1xuICAgIGNvbnN0IGZ1bGxUeXBlID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgY29uc3QgbGFuZyA9IGZ1bGxUeXBlLmluY2x1ZGVzKFwiL1wiKSA/IGZ1bGxUeXBlLnNwbGl0KFwiL1wiKS5wb3AoKSA6IGZ1bGxUeXBlO1xuICAgIGlmIChsYW5nKVxuICAgICAgbGFuZ3MuYWRkKGxhbmcpO1xuICB9XG4gIGlmICghaGlnaGxpZ2h0ZXIpXG4gICAgcmV0dXJuIEFycmF5LmZyb20obGFuZ3MpO1xuICBjb25zdCBidW5kbGUgPSBoaWdobGlnaHRlci5nZXRCdW5kbGVkTGFuZ3VhZ2VzKCk7XG4gIHJldHVybiBBcnJheS5mcm9tKGxhbmdzKS5maWx0ZXIoKGwpID0+IGwgJiYgYnVuZGxlW2xdKTtcbn1cblxuY29uc3QgREVGQVVMVF9DT0xPUl9MSUdIVF9EQVJLID0gXCJsaWdodC1kYXJrKClcIjtcbmNvbnN0IENPTE9SX0tFWVMgPSBbXCJjb2xvclwiLCBcImJhY2tncm91bmQtY29sb3JcIl07XG5cbmZ1bmN0aW9uIHNwbGl0VG9rZW4odG9rZW4sIG9mZnNldHMpIHtcbiAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgZm9yIChjb25zdCBvZmZzZXQgb2Ygb2Zmc2V0cykge1xuICAgIGlmIChvZmZzZXQgPiBsYXN0T2Zmc2V0KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIC4uLnRva2VuLFxuICAgICAgICBjb250ZW50OiB0b2tlbi5jb250ZW50LnNsaWNlKGxhc3RPZmZzZXQsIG9mZnNldCksXG4gICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gIH1cbiAgaWYgKGxhc3RPZmZzZXQgPCB0b2tlbi5jb250ZW50Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIC4uLnRva2VuLFxuICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZShsYXN0T2Zmc2V0KSxcbiAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBzcGxpdFRva2Vucyh0b2tlbnMsIGJyZWFrcG9pbnRzKSB7XG4gIGNvbnN0IHNvcnRlZCA9IEFycmF5LmZyb20oYnJlYWtwb2ludHMgaW5zdGFuY2VvZiBTZXQgPyBicmVha3BvaW50cyA6IG5ldyBTZXQoYnJlYWtwb2ludHMpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGlmICghc29ydGVkLmxlbmd0aClcbiAgICByZXR1cm4gdG9rZW5zO1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmZsYXRNYXAoKHRva2VuKSA9PiB7XG4gICAgICBjb25zdCBicmVha3BvaW50c0luVG9rZW4gPSBzb3J0ZWQuZmlsdGVyKChpKSA9PiB0b2tlbi5vZmZzZXQgPCBpICYmIGkgPCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5jb250ZW50Lmxlbmd0aCkubWFwKChpKSA9PiBpIC0gdG9rZW4ub2Zmc2V0KS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICBpZiAoIWJyZWFrcG9pbnRzSW5Ub2tlbi5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIHJldHVybiBzcGxpdFRva2VuKHRva2VuLCBicmVha3BvaW50c0luVG9rZW4pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZsYXRUb2tlblZhcmlhbnRzKG1lcmdlZCwgdmFyaWFudHNPcmRlciwgY3NzVmFyaWFibGVQcmVmaXgsIGRlZmF1bHRDb2xvciwgY29sb3JzUmVuZGVyaW5nID0gXCJjc3MtdmFyc1wiKSB7XG4gIGNvbnN0IHRva2VuID0ge1xuICAgIGNvbnRlbnQ6IG1lcmdlZC5jb250ZW50LFxuICAgIGV4cGxhbmF0aW9uOiBtZXJnZWQuZXhwbGFuYXRpb24sXG4gICAgb2Zmc2V0OiBtZXJnZWQub2Zmc2V0XG4gIH07XG4gIGNvbnN0IHN0eWxlcyA9IHZhcmlhbnRzT3JkZXIubWFwKCh0KSA9PiBnZXRUb2tlblN0eWxlT2JqZWN0KG1lcmdlZC52YXJpYW50c1t0XSkpO1xuICBjb25zdCBzdHlsZUtleXMgPSBuZXcgU2V0KHN0eWxlcy5mbGF0TWFwKCh0KSA9PiBPYmplY3Qua2V5cyh0KSkpO1xuICBjb25zdCBtZXJnZWRTdHlsZXMgPSB7fTtcbiAgY29uc3QgdmFyS2V5ID0gKGlkeCwga2V5KSA9PiB7XG4gICAgY29uc3Qga2V5TmFtZSA9IGtleSA9PT0gXCJjb2xvclwiID8gXCJcIiA6IGtleSA9PT0gXCJiYWNrZ3JvdW5kLWNvbG9yXCIgPyBcIi1iZ1wiIDogYC0ke2tleX1gO1xuICAgIHJldHVybiBjc3NWYXJpYWJsZVByZWZpeCArIHZhcmlhbnRzT3JkZXJbaWR4XSArIChrZXkgPT09IFwiY29sb3JcIiA/IFwiXCIgOiBrZXlOYW1lKTtcbiAgfTtcbiAgc3R5bGVzLmZvckVhY2goKGN1ciwgaWR4KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc3R5bGVLZXlzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cltrZXldIHx8IFwiaW5oZXJpdFwiO1xuICAgICAgaWYgKGlkeCA9PT0gMCAmJiBkZWZhdWx0Q29sb3IgJiYgQ09MT1JfS0VZUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q29sb3IgPT09IERFRkFVTFRfQ09MT1JfTElHSFRfREFSSyAmJiBzdHlsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IGxpZ2h0SW5kZXggPSB2YXJpYW50c09yZGVyLmZpbmRJbmRleCgodCkgPT4gdCA9PT0gXCJsaWdodFwiKTtcbiAgICAgICAgICBjb25zdCBkYXJrSW5kZXggPSB2YXJpYW50c09yZGVyLmZpbmRJbmRleCgodCkgPT4gdCA9PT0gXCJkYXJrXCIpO1xuICAgICAgICAgIGlmIChsaWdodEluZGV4ID09PSAtMSB8fCBkYXJrSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMSgnV2hlbiB1c2luZyBgZGVmYXVsdENvbG9yOiBcImxpZ2h0LWRhcmsoKVwiYCwgeW91IG11c3QgcHJvdmlkZSBib3RoIGBsaWdodGAgYW5kIGBkYXJrYCB0aGVtZXMnKTtcbiAgICAgICAgICBjb25zdCBsaWdodFZhbHVlID0gc3R5bGVzW2xpZ2h0SW5kZXhdW2tleV0gfHwgXCJpbmhlcml0XCI7XG4gICAgICAgICAgY29uc3QgZGFya1ZhbHVlID0gc3R5bGVzW2RhcmtJbmRleF1ba2V5XSB8fCBcImluaGVyaXRcIjtcbiAgICAgICAgICBtZXJnZWRTdHlsZXNba2V5XSA9IGBsaWdodC1kYXJrKCR7bGlnaHRWYWx1ZX0sICR7ZGFya1ZhbHVlfSlgO1xuICAgICAgICAgIGlmIChjb2xvcnNSZW5kZXJpbmcgPT09IFwiY3NzLXZhcnNcIilcbiAgICAgICAgICAgIG1lcmdlZFN0eWxlc1t2YXJLZXkoaWR4LCBrZXkpXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlZFN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb2xvcnNSZW5kZXJpbmcgPT09IFwiY3NzLXZhcnNcIilcbiAgICAgICAgICBtZXJnZWRTdHlsZXNbdmFyS2V5KGlkeCwga2V5KV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0b2tlbi5odG1sU3R5bGUgPSBtZXJnZWRTdHlsZXM7XG4gIHJldHVybiB0b2tlbjtcbn1cbmZ1bmN0aW9uIGdldFRva2VuU3R5bGVPYmplY3QodG9rZW4pIHtcbiAgY29uc3Qgc3R5bGVzID0ge307XG4gIGlmICh0b2tlbi5jb2xvcilcbiAgICBzdHlsZXMuY29sb3IgPSB0b2tlbi5jb2xvcjtcbiAgaWYgKHRva2VuLmJnQ29sb3IpXG4gICAgc3R5bGVzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IHRva2VuLmJnQ29sb3I7XG4gIGlmICh0b2tlbi5mb250U3R5bGUpIHtcbiAgICBpZiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLkl0YWxpYylcbiAgICAgIHN0eWxlc1tcImZvbnQtc3R5bGVcIl0gPSBcIml0YWxpY1wiO1xuICAgIGlmICh0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuQm9sZClcbiAgICAgIHN0eWxlc1tcImZvbnQtd2VpZ2h0XCJdID0gXCJib2xkXCI7XG4gICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBpZiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLlVuZGVybGluZSlcbiAgICAgIGRlY29yYXRpb25zLnB1c2goXCJ1bmRlcmxpbmVcIik7XG4gICAgaWYgKHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoKVxuICAgICAgZGVjb3JhdGlvbnMucHVzaChcImxpbmUtdGhyb3VnaFwiKTtcbiAgICBpZiAoZGVjb3JhdGlvbnMubGVuZ3RoKVxuICAgICAgc3R5bGVzW1widGV4dC1kZWNvcmF0aW9uXCJdID0gZGVjb3JhdGlvbnMuam9pbihcIiBcIik7XG4gIH1cbiAgcmV0dXJuIHN0eWxlcztcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VuU3R5bGUodG9rZW4pIHtcbiAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gdG9rZW47XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh0b2tlbikubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06JHt2YWx1ZX1gKS5qb2luKFwiO1wiKTtcbn1cblxuY29uc3QgX2dyYW1tYXJTdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKGtleXMsIHN0YXRlKSB7XG4gIF9ncmFtbWFyU3RhdGVNYXAuc2V0KGtleXMsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKGtleXMpIHtcbiAgcmV0dXJuIF9ncmFtbWFyU3RhdGVNYXAuZ2V0KGtleXMpO1xufVxuY2xhc3MgR3JhbW1hclN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZW1lIHRvIFN0YWNrIG1hcHBpbmdcbiAgICovXG4gIF9zdGFja3MgPSB7fTtcbiAgbGFuZztcbiAgZ2V0IHRoZW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3RhY2tzKTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbWVzWzBdO1xuICB9XG4gIGdldCBfc3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrc1t0aGlzLnRoZW1lXTtcbiAgfVxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB0byBjcmVhdGUgYSBpbml0aWFsIGdyYW1tYXIgc3RhdGUuXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbChsYW5nLCB0aGVtZXMpIHtcbiAgICByZXR1cm4gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyh0b0FycmF5KHRoZW1lcykubWFwKCh0aGVtZSkgPT4gW3RoZW1lLCBJTklUSUFMXSkpLFxuICAgICAgbGFuZ1xuICAgICk7XG4gIH1cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgW3N0YWNrc01hcCwgbGFuZ10gPSBhcmdzO1xuICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgIHRoaXMuX3N0YWNrcyA9IHN0YWNrc01hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3N0YWNrLCBsYW5nLCB0aGVtZV0gPSBhcmdzO1xuICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgIHRoaXMuX3N0YWNrcyA9IHsgW3RoZW1lXTogc3RhY2sgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJuYWwgc3RhY2sgb2JqZWN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEludGVybmFsU3RhY2sodGhlbWUgPSB0aGlzLnRoZW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrc1t0aGVtZV07XG4gIH1cbiAgZ2V0U2NvcGVzKHRoZW1lID0gdGhpcy50aGVtZSkge1xuICAgIHJldHVybiBnZXRTY29wZXModGhpcy5fc3RhY2tzW3RoZW1lXSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5nOiB0aGlzLmxhbmcsXG4gICAgICB0aGVtZTogdGhpcy50aGVtZSxcbiAgICAgIHRoZW1lczogdGhpcy50aGVtZXMsXG4gICAgICBzY29wZXM6IHRoaXMuZ2V0U2NvcGVzKClcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRTY29wZXMoc3RhY2spIHtcbiAgY29uc3Qgc2NvcGVzID0gW107XG4gIGNvbnN0IHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBwdXNoU2NvcGUoc3RhY2syKSB7XG4gICAgaWYgKHZpc2l0ZWQuaGFzKHN0YWNrMikpXG4gICAgICByZXR1cm47XG4gICAgdmlzaXRlZC5hZGQoc3RhY2syKTtcbiAgICBjb25zdCBuYW1lID0gc3RhY2syPy5uYW1lU2NvcGVzTGlzdD8uc2NvcGVOYW1lO1xuICAgIGlmIChuYW1lKVxuICAgICAgc2NvcGVzLnB1c2gobmFtZSk7XG4gICAgaWYgKHN0YWNrMi5wYXJlbnQpXG4gICAgICBwdXNoU2NvcGUoc3RhY2syLnBhcmVudCk7XG4gIH1cbiAgcHVzaFNjb3BlKHN0YWNrKTtcbiAgcmV0dXJuIHNjb3Blcztcbn1cbmZ1bmN0aW9uIGdldEdyYW1tYXJTdGFjayhzdGF0ZSwgdGhlbWUpIHtcbiAgaWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBHcmFtbWFyU3RhdGUpKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJJbnZhbGlkIGdyYW1tYXIgc3RhdGVcIik7XG4gIHJldHVybiBzdGF0ZS5nZXRJbnRlcm5hbFN0YWNrKHRoZW1lKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXJEZWNvcmF0aW9ucygpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIGdldENvbnRleHQoc2hpa2kpIHtcbiAgICBpZiAoIW1hcC5oYXMoc2hpa2kubWV0YSkpIHtcbiAgICAgIGxldCBub3JtYWxpemVQb3NpdGlvbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHAgPCAwIHx8IHAgPiBzaGlraS5zb3VyY2UubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIG9mZnNldDogJHtwfS4gQ29kZSBsZW5ndGg6ICR7c2hpa2kuc291cmNlLmxlbmd0aH1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29udmVydGVyLmluZGV4VG9Qb3MocCksXG4gICAgICAgICAgICBvZmZzZXQ6IHBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxpbmUgPSBjb252ZXJ0ZXIubGluZXNbcC5saW5lXTtcbiAgICAgICAgICBpZiAobGluZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIHBvc2l0aW9uICR7SlNPTi5zdHJpbmdpZnkocCl9LiBMaW5lcyBsZW5ndGg6ICR7Y29udmVydGVyLmxpbmVzLmxlbmd0aH1gKTtcbiAgICAgICAgICBsZXQgY2hhcmFjdGVyID0gcC5jaGFyYWN0ZXI7XG4gICAgICAgICAgaWYgKGNoYXJhY3RlciA8IDApXG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBsaW5lLmxlbmd0aCArIGNoYXJhY3RlcjtcbiAgICAgICAgICBpZiAoY2hhcmFjdGVyIDwgMCB8fCBjaGFyYWN0ZXIgPiBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEludmFsaWQgZGVjb3JhdGlvbiBwb3NpdGlvbiAke0pTT04uc3RyaW5naWZ5KHApfS4gTGluZSAke3AubGluZX0gbGVuZ3RoOiAke2xpbmUubGVuZ3RofWApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgY2hhcmFjdGVyLFxuICAgICAgICAgICAgb2Zmc2V0OiBjb252ZXJ0ZXIucG9zVG9JbmRleChwLmxpbmUsIGNoYXJhY3RlcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udmVydGVyID0gY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIoc2hpa2kuc291cmNlKTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb25zID0gKHNoaWtpLm9wdGlvbnMuZGVjb3JhdGlvbnMgfHwgW10pLm1hcCgoZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgc3RhcnQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuc3RhcnQpLFxuICAgICAgICBlbmQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuZW5kKVxuICAgICAgfSkpO1xuICAgICAgdmVyaWZ5SW50ZXJzZWN0aW9ucyhkZWNvcmF0aW9ucyk7XG4gICAgICBtYXAuc2V0KHNoaWtpLm1ldGEsIHtcbiAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgIGNvbnZlcnRlcixcbiAgICAgICAgc291cmNlOiBzaGlraS5zb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwLmdldChzaGlraS5tZXRhKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IFwic2hpa2k6ZGVjb3JhdGlvbnNcIixcbiAgICB0b2tlbnModG9rZW5zKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWNvcmF0aW9ucz8ubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjdHggPSBnZXRDb250ZXh0KHRoaXMpO1xuICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSBjdHguZGVjb3JhdGlvbnMuZmxhdE1hcCgoZCkgPT4gW2Quc3RhcnQub2Zmc2V0LCBkLmVuZC5vZmZzZXRdKTtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gc3BsaXRUb2tlbnModG9rZW5zLCBicmVha3BvaW50cyk7XG4gICAgICByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgfSxcbiAgICBjb2RlKGNvZGVFbCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVjb3JhdGlvbnM/Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dCh0aGlzKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuZnJvbShjb2RlRWwuY2hpbGRyZW4pLmZpbHRlcigoaSkgPT4gaS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBpLnRhZ05hbWUgPT09IFwic3BhblwiKTtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggIT09IGN0eC5jb252ZXJ0ZXIubGluZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBOdW1iZXIgb2YgbGluZXMgaW4gY29kZSBlbGVtZW50ICgke2xpbmVzLmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHNvdXJjZSAoJHtjdHguY29udmVydGVyLmxpbmVzLmxlbmd0aH0pLiBGYWlsZWQgdG8gYXBwbHkgZGVjb3JhdGlvbnMuYCk7XG4gICAgICBmdW5jdGlvbiBhcHBseUxpbmVTZWN0aW9uKGxpbmUsIHN0YXJ0LCBlbmQsIGRlY29yYXRpb24pIHtcbiAgICAgICAgY29uc3QgbGluZUVsID0gbGluZXNbbGluZV07XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGVuZEluZGV4ID0gLTE7XG4gICAgICAgIGlmIChzdGFydCA9PT0gMClcbiAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgaWYgKGVuZCA9PT0gMClcbiAgICAgICAgICBlbmRJbmRleCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICBlbmRJbmRleCA9IGxpbmVFbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSB8fCBlbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVFbC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBzdHJpbmdpZnkobGluZUVsLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSAmJiB0ZXh0Lmxlbmd0aCA9PT0gc3RhcnQpXG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEgJiYgdGV4dC5sZW5ndGggPT09IGVuZClcbiAgICAgICAgICAgICAgZW5kSW5kZXggPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEZhaWxlZCB0byBmaW5kIHN0YXJ0IGluZGV4IGZvciBkZWNvcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkoZGVjb3JhdGlvbi5zdGFydCl9YCk7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgRmFpbGVkIHRvIGZpbmQgZW5kIGluZGV4IGZvciBkZWNvcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkoZGVjb3JhdGlvbi5lbmQpfWApO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGxpbmVFbC5jaGlsZHJlbi5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gbGluZUVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihsaW5lRWwsIGRlY29yYXRpb24sIFwibGluZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50eXBlID09PSBcImVsZW1lbnRcIikge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihjaGlsZHJlblswXSwgZGVjb3JhdGlvbiwgXCJ0b2tlblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0ge1xuICAgICAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbih3cmFwcGVyLCBkZWNvcmF0aW9uLCBcIndyYXBwZXJcIik7XG4gICAgICAgICAgbGluZUVsLmNoaWxkcmVuLnNwbGljZShzdGFydEluZGV4LCBjaGlsZHJlbi5sZW5ndGgsIHdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcHBseUxpbmUobGluZSwgZGVjb3JhdGlvbikge1xuICAgICAgICBsaW5lc1tsaW5lXSA9IGFwcGx5RGVjb3JhdGlvbihsaW5lc1tsaW5lXSwgZGVjb3JhdGlvbiwgXCJsaW5lXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXBwbHlEZWNvcmF0aW9uKGVsLCBkZWNvcmF0aW9uLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkZWNvcmF0aW9uLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGRlY29yYXRpb24udHJhbnNmb3JtIHx8ICgoaSkgPT4gaSk7XG4gICAgICAgIGVsLnRhZ05hbWUgPSBkZWNvcmF0aW9uLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIGVsLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgLi4uZWwucHJvcGVydGllcyxcbiAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGNsYXNzOiBlbC5wcm9wZXJ0aWVzLmNsYXNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWNvcmF0aW9uLnByb3BlcnRpZXM/LmNsYXNzKVxuICAgICAgICAgIGFkZENsYXNzVG9IYXN0KGVsLCBkZWNvcmF0aW9uLnByb3BlcnRpZXMuY2xhc3MpO1xuICAgICAgICBlbCA9IHRyYW5zZm9ybShlbCwgdHlwZSkgfHwgZWw7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVBcHBsaWVzID0gW107XG4gICAgICBjb25zdCBzb3J0ZWQgPSBjdHguZGVjb3JhdGlvbnMuc29ydCgoYSwgYikgPT4gYi5zdGFydC5vZmZzZXQgLSBhLnN0YXJ0Lm9mZnNldCB8fCBhLmVuZC5vZmZzZXQgLSBiLmVuZC5vZmZzZXQpO1xuICAgICAgZm9yIChjb25zdCBkZWNvcmF0aW9uIG9mIHNvcnRlZCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGRlY29yYXRpb247XG4gICAgICAgIGlmIChzdGFydC5saW5lID09PSBlbmQubGluZSkge1xuICAgICAgICAgIGFwcGx5TGluZVNlY3Rpb24oc3RhcnQubGluZSwgc3RhcnQuY2hhcmFjdGVyLCBlbmQuY2hhcmFjdGVyLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydC5saW5lIDwgZW5kLmxpbmUpIHtcbiAgICAgICAgICBhcHBseUxpbmVTZWN0aW9uKHN0YXJ0LmxpbmUsIHN0YXJ0LmNoYXJhY3RlciwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQubGluZSArIDE7IGkgPCBlbmQubGluZTsgaSsrKVxuICAgICAgICAgICAgbGluZUFwcGxpZXMudW5zaGlmdCgoKSA9PiBhcHBseUxpbmUoaSwgZGVjb3JhdGlvbikpO1xuICAgICAgICAgIGFwcGx5TGluZVNlY3Rpb24oZW5kLmxpbmUsIDAsIGVuZC5jaGFyYWN0ZXIsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lQXBwbGllcy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUludGVyc2VjdGlvbnMoaXRlbXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZvbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChmb28uc3RhcnQub2Zmc2V0ID4gZm9vLmVuZC5vZmZzZXQpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBJbnZhbGlkIGRlY29yYXRpb24gcmFuZ2U6ICR7SlNPTi5zdHJpbmdpZnkoZm9vLnN0YXJ0KX0gLSAke0pTT04uc3RyaW5naWZ5KGZvby5lbmQpfWApO1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBiYXIgPSBpdGVtc1tqXTtcbiAgICAgIGNvbnN0IGlzRm9vSGFzQmFyU3RhcnQgPSBmb28uc3RhcnQub2Zmc2V0IDw9IGJhci5zdGFydC5vZmZzZXQgJiYgYmFyLnN0YXJ0Lm9mZnNldCA8IGZvby5lbmQub2Zmc2V0O1xuICAgICAgY29uc3QgaXNGb29IYXNCYXJFbmQgPSBmb28uc3RhcnQub2Zmc2V0IDwgYmFyLmVuZC5vZmZzZXQgJiYgYmFyLmVuZC5vZmZzZXQgPD0gZm9vLmVuZC5vZmZzZXQ7XG4gICAgICBjb25zdCBpc0Jhckhhc0Zvb1N0YXJ0ID0gYmFyLnN0YXJ0Lm9mZnNldCA8PSBmb28uc3RhcnQub2Zmc2V0ICYmIGZvby5zdGFydC5vZmZzZXQgPCBiYXIuZW5kLm9mZnNldDtcbiAgICAgIGNvbnN0IGlzQmFySGFzRm9vRW5kID0gYmFyLnN0YXJ0Lm9mZnNldCA8IGZvby5lbmQub2Zmc2V0ICYmIGZvby5lbmQub2Zmc2V0IDw9IGJhci5lbmQub2Zmc2V0O1xuICAgICAgaWYgKGlzRm9vSGFzQmFyU3RhcnQgfHwgaXNGb29IYXNCYXJFbmQgfHwgaXNCYXJIYXNGb29TdGFydCB8fCBpc0Jhckhhc0Zvb0VuZCkge1xuICAgICAgICBpZiAoaXNGb29IYXNCYXJTdGFydCAmJiBpc0Zvb0hhc0JhckVuZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGlzQmFySGFzRm9vU3RhcnQgJiYgaXNCYXJIYXNGb29FbmQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpc0Jhckhhc0Zvb1N0YXJ0ICYmIGZvby5zdGFydC5vZmZzZXQgPT09IGZvby5lbmQub2Zmc2V0KVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaXNGb29IYXNCYXJFbmQgJiYgYmFyLnN0YXJ0Lm9mZnNldCA9PT0gYmFyLmVuZC5vZmZzZXQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYERlY29yYXRpb25zICR7SlNPTi5zdHJpbmdpZnkoZm9vLnN0YXJ0KX0gYW5kICR7SlNPTi5zdHJpbmdpZnkoYmFyLnN0YXJ0KX0gaW50ZXJzZWN0LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGVsKSB7XG4gIGlmIChlbC50eXBlID09PSBcInRleHRcIilcbiAgICByZXR1cm4gZWwudmFsdWU7XG4gIGlmIChlbC50eXBlID09PSBcImVsZW1lbnRcIilcbiAgICByZXR1cm4gZWwuY2hpbGRyZW4ubWFwKHN0cmluZ2lmeSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIFwiXCI7XG59XG5cbmNvbnN0IGJ1aWx0SW5UcmFuc2Zvcm1lcnMgPSBbXG4gIC8qIEBfX1BVUkVfXyAqLyB0cmFuc2Zvcm1lckRlY29yYXRpb25zKClcbl07XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBzb3J0VHJhbnNmb3JtZXJzQnlFbmZvcmNlbWVudChvcHRpb25zLnRyYW5zZm9ybWVycyB8fCBbXSk7XG4gIHJldHVybiBbXG4gICAgLi4udHJhbnNmb3JtZXJzLnByZSxcbiAgICAuLi50cmFuc2Zvcm1lcnMubm9ybWFsLFxuICAgIC4uLnRyYW5zZm9ybWVycy5wb3N0LFxuICAgIC4uLmJ1aWx0SW5UcmFuc2Zvcm1lcnNcbiAgXTtcbn1cbmZ1bmN0aW9uIHNvcnRUcmFuc2Zvcm1lcnNCeUVuZm9yY2VtZW50KHRyYW5zZm9ybWVycykge1xuICBjb25zdCBwcmUgPSBbXTtcbiAgY29uc3QgcG9zdCA9IFtdO1xuICBjb25zdCBub3JtYWwgPSBbXTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICBzd2l0Y2ggKHRyYW5zZm9ybWVyLmVuZm9yY2UpIHtcbiAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgcHJlLnB1c2godHJhbnNmb3JtZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb3N0XCI6XG4gICAgICAgIHBvc3QucHVzaCh0cmFuc2Zvcm1lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9ybWFsLnB1c2godHJhbnNmb3JtZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcmUsIHBvc3QsIG5vcm1hbCB9O1xufVxuXG4vLyBzcmMvY29sb3JzLnRzXG52YXIgbmFtZWRDb2xvcnMgPSBbXG4gIFwiYmxhY2tcIixcbiAgXCJyZWRcIixcbiAgXCJncmVlblwiLFxuICBcInllbGxvd1wiLFxuICBcImJsdWVcIixcbiAgXCJtYWdlbnRhXCIsXG4gIFwiY3lhblwiLFxuICBcIndoaXRlXCIsXG4gIFwiYnJpZ2h0QmxhY2tcIixcbiAgXCJicmlnaHRSZWRcIixcbiAgXCJicmlnaHRHcmVlblwiLFxuICBcImJyaWdodFllbGxvd1wiLFxuICBcImJyaWdodEJsdWVcIixcbiAgXCJicmlnaHRNYWdlbnRhXCIsXG4gIFwiYnJpZ2h0Q3lhblwiLFxuICBcImJyaWdodFdoaXRlXCJcbl07XG5cbi8vIHNyYy9kZWNvcmF0aW9ucy50c1xudmFyIGRlY29yYXRpb25zID0ge1xuICAxOiBcImJvbGRcIixcbiAgMjogXCJkaW1cIixcbiAgMzogXCJpdGFsaWNcIixcbiAgNDogXCJ1bmRlcmxpbmVcIixcbiAgNzogXCJyZXZlcnNlXCIsXG4gIDg6IFwiaGlkZGVuXCIsXG4gIDk6IFwic3RyaWtldGhyb3VnaFwiXG59O1xuXG4vLyBzcmMvcGFyc2VyLnRzXG5mdW5jdGlvbiBmaW5kU2VxdWVuY2UodmFsdWUsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IG5leHRFc2NhcGUgPSB2YWx1ZS5pbmRleE9mKFwiXFx4MUJcIiwgcG9zaXRpb24pO1xuICBpZiAobmV4dEVzY2FwZSAhPT0gLTEpIHtcbiAgICBpZiAodmFsdWVbbmV4dEVzY2FwZSArIDFdID09PSBcIltcIikge1xuICAgICAgY29uc3QgbmV4dENsb3NlID0gdmFsdWUuaW5kZXhPZihcIm1cIiwgbmV4dEVzY2FwZSk7XG4gICAgICBpZiAobmV4dENsb3NlICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNlcXVlbmNlOiB2YWx1ZS5zdWJzdHJpbmcobmV4dEVzY2FwZSArIDIsIG5leHRDbG9zZSkuc3BsaXQoXCI7XCIpLFxuICAgICAgICAgIHN0YXJ0UG9zaXRpb246IG5leHRFc2NhcGUsXG4gICAgICAgICAgcG9zaXRpb246IG5leHRDbG9zZSArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjogdmFsdWUubGVuZ3RoXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUNvbG9yKHNlcXVlbmNlKSB7XG4gIGNvbnN0IGNvbG9yTW9kZSA9IHNlcXVlbmNlLnNoaWZ0KCk7XG4gIGlmIChjb2xvck1vZGUgPT09IFwiMlwiKSB7XG4gICAgY29uc3QgcmdiID0gc2VxdWVuY2Uuc3BsaWNlKDAsIDMpLm1hcCgoeCkgPT4gTnVtYmVyLnBhcnNlSW50KHgpKTtcbiAgICBpZiAocmdiLmxlbmd0aCAhPT0gMyB8fCByZ2Iuc29tZSgoeCkgPT4gTnVtYmVyLmlzTmFOKHgpKSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyZ2JcIixcbiAgICAgIHJnYlxuICAgIH07XG4gIH0gZWxzZSBpZiAoY29sb3JNb2RlID09PSBcIjVcIikge1xuICAgIGNvbnN0IGluZGV4ID0gc2VxdWVuY2Uuc2hpZnQoKTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGFibGVcIiwgaW5kZXg6IE51bWJlcihpbmRleCkgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU2VxdWVuY2Uoc2VxdWVuY2UpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgd2hpbGUgKHNlcXVlbmNlLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb2RlID0gc2VxdWVuY2Uuc2hpZnQoKTtcbiAgICBpZiAoIWNvZGUpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBjb2RlSW50ID0gTnVtYmVyLnBhcnNlSW50KGNvZGUpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oY29kZUludCkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoY29kZUludCA9PT0gMCkge1xuICAgICAgY29tbWFuZHMucHVzaCh7IHR5cGU6IFwicmVzZXRBbGxcIiB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPD0gOSkge1xuICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IGRlY29yYXRpb25zW2NvZGVJbnRdO1xuICAgICAgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJzZXREZWNvcmF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGRlY29yYXRpb25zW2NvZGVJbnRdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZUludCA8PSAyOSkge1xuICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IGRlY29yYXRpb25zW2NvZGVJbnQgLSAyMF07XG4gICAgICBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInJlc2V0RGVjb3JhdGlvblwiLFxuICAgICAgICAgIHZhbHVlOiBkZWNvcmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVjb3JhdGlvbiA9PT0gXCJkaW1cIikge1xuICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJyZXNldERlY29yYXRpb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBcImJvbGRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDM3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gMzBdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gMzgpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gcGFyc2VDb2xvcihzZXF1ZW5jZSk7XG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICB2YWx1ZTogY29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSAzOSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVzZXRGb3JlZ3JvdW5kQ29sb3JcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDQ3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gNDBdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gNDgpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gcGFyc2VDb2xvcihzZXF1ZW5jZSk7XG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICB2YWx1ZTogY29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSA0OSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVzZXRCYWNrZ3JvdW5kQ29sb3JcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSA1Mykge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2V0RGVjb3JhdGlvblwiLFxuICAgICAgICB2YWx1ZTogXCJvdmVybGluZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPT09IDU1KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJyZXNldERlY29yYXRpb25cIixcbiAgICAgICAgdmFsdWU6IFwib3ZlcmxpbmVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID49IDkwICYmIGNvZGVJbnQgPD0gOTcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEZvcmVncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSA5MCArIDhdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA+PSAxMDAgJiYgY29kZUludCA8PSAxMDcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSAxMDAgKyA4XSB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5zaVNlcXVlbmNlUGFyc2VyKCkge1xuICBsZXQgZm9yZWdyb3VuZCA9IG51bGw7XG4gIGxldCBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgbGV0IGRlY29yYXRpb25zMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiB7XG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgZmluZFJlc3VsdCA9IGZpbmRTZXF1ZW5jZSh2YWx1ZSwgcG9zaXRpb24pO1xuICAgICAgICBjb25zdCB0ZXh0ID0gZmluZFJlc3VsdC5zZXF1ZW5jZSA/IHZhbHVlLnN1YnN0cmluZyhwb3NpdGlvbiwgZmluZFJlc3VsdC5zdGFydFBvc2l0aW9uKSA6IHZhbHVlLnN1YnN0cmluZyhwb3NpdGlvbik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgIGZvcmVncm91bmQsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IG5ldyBTZXQoZGVjb3JhdGlvbnMyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5kUmVzdWx0LnNlcXVlbmNlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWFuZHMgPSBwYXJzZVNlcXVlbmNlKGZpbmRSZXN1bHQuc2VxdWVuY2UpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGVUb2tlbiBvZiBjb21tYW5kcykge1xuICAgICAgICAgICAgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldEFsbFwiKSB7XG4gICAgICAgICAgICAgIGZvcmVncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMyLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldEZvcmVncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGZvcmVncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwicmVzZXRCYWNrZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInJlc2V0RGVjb3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zMi5kZWxldGUoc3R5bGVUb2tlbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGVUb2tlbiBvZiBjb21tYW5kcykge1xuICAgICAgICAgICAgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBmb3JlZ3JvdW5kID0gc3R5bGVUb2tlbi52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInNldEJhY2tncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQgPSBzdHlsZVRva2VuLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwic2V0RGVjb3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zMi5hZGQoc3R5bGVUb2tlbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uID0gZmluZFJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIH0gd2hpbGUgKHBvc2l0aW9uIDwgdmFsdWUubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvcGFsZXR0ZS50c1xudmFyIGRlZmF1bHROYW1lZENvbG9yc01hcCA9IHtcbiAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICByZWQ6IFwiI2JiMDAwMFwiLFxuICBncmVlbjogXCIjMDBiYjAwXCIsXG4gIHllbGxvdzogXCIjYmJiYjAwXCIsXG4gIGJsdWU6IFwiIzAwMDBiYlwiLFxuICBtYWdlbnRhOiBcIiNmZjAwZmZcIixcbiAgY3lhbjogXCIjMDBiYmJiXCIsXG4gIHdoaXRlOiBcIiNlZWVlZWVcIixcbiAgYnJpZ2h0QmxhY2s6IFwiIzU1NTU1NVwiLFxuICBicmlnaHRSZWQ6IFwiI2ZmNTU1NVwiLFxuICBicmlnaHRHcmVlbjogXCIjMDBmZjAwXCIsXG4gIGJyaWdodFllbGxvdzogXCIjZmZmZjU1XCIsXG4gIGJyaWdodEJsdWU6IFwiIzU1NTVmZlwiLFxuICBicmlnaHRNYWdlbnRhOiBcIiNmZjU1ZmZcIixcbiAgYnJpZ2h0Q3lhbjogXCIjNTVmZmZmXCIsXG4gIGJyaWdodFdoaXRlOiBcIiNmZmZmZmZcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yUGFsZXR0ZShuYW1lZENvbG9yc01hcCA9IGRlZmF1bHROYW1lZENvbG9yc01hcCkge1xuICBmdW5jdGlvbiBuYW1lZENvbG9yKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZWRDb2xvcnNNYXBbbmFtZV07XG4gIH1cbiAgZnVuY3Rpb24gcmdiQ29sb3IocmdiKSB7XG4gICAgcmV0dXJuIGAjJHtyZ2IubWFwKCh4KSA9PiBNYXRoLm1heCgwLCBNYXRoLm1pbih4LCAyNTUpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgbGV0IGNvbG9yVGFibGU7XG4gIGZ1bmN0aW9uIGdldENvbG9yVGFibGUoKSB7XG4gICAgaWYgKGNvbG9yVGFibGUpIHtcbiAgICAgIHJldHVybiBjb2xvclRhYmxlO1xuICAgIH1cbiAgICBjb2xvclRhYmxlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lZENvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29sb3JUYWJsZS5wdXNoKG5hbWVkQ29sb3IobmFtZWRDb2xvcnNbaV0pKTtcbiAgICB9XG4gICAgbGV0IGxldmVscyA9IFswLCA5NSwgMTM1LCAxNzUsIDIxNSwgMjU1XTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IDY7IHIrKykge1xuICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCA2OyBnKyspIHtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCA2OyBiKyspIHtcbiAgICAgICAgICBjb2xvclRhYmxlLnB1c2gocmdiQ29sb3IoW2xldmVsc1tyXSwgbGV2ZWxzW2ddLCBsZXZlbHNbYl1dKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxldmVsID0gODtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyssIGxldmVsICs9IDEwKSB7XG4gICAgICBjb2xvclRhYmxlLnB1c2gocmdiQ29sb3IoW2xldmVsLCBsZXZlbCwgbGV2ZWxdKSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvclRhYmxlO1xuICB9XG4gIGZ1bmN0aW9uIHRhYmxlQ29sb3IoaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0Q29sb3JUYWJsZSgpW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiB2YWx1ZShjb2xvcikge1xuICAgIHN3aXRjaCAoY29sb3IudHlwZSkge1xuICAgICAgY2FzZSBcIm5hbWVkXCI6XG4gICAgICAgIHJldHVybiBuYW1lZENvbG9yKGNvbG9yLm5hbWUpO1xuICAgICAgY2FzZSBcInJnYlwiOlxuICAgICAgICByZXR1cm4gcmdiQ29sb3IoY29sb3IucmdiKTtcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICByZXR1cm4gdGFibGVDb2xvcihjb2xvci5pbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmFsdWVcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdEFuc2lDb2xvcnMgPSB7XG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgcmVkOiBcIiNjZDMxMzFcIixcbiAgZ3JlZW46IFwiIzBEQkM3OVwiLFxuICB5ZWxsb3c6IFwiI0U1RTUxMFwiLFxuICBibHVlOiBcIiMyNDcyQzhcIixcbiAgbWFnZW50YTogXCIjQkMzRkJDXCIsXG4gIGN5YW46IFwiIzExQThDRFwiLFxuICB3aGl0ZTogXCIjRTVFNUU1XCIsXG4gIGJyaWdodEJsYWNrOiBcIiM2NjY2NjZcIixcbiAgYnJpZ2h0UmVkOiBcIiNGMTRDNENcIixcbiAgYnJpZ2h0R3JlZW46IFwiIzIzRDE4QlwiLFxuICBicmlnaHRZZWxsb3c6IFwiI0Y1RjU0M1wiLFxuICBicmlnaHRCbHVlOiBcIiMzQjhFRUFcIixcbiAgYnJpZ2h0TWFnZW50YTogXCIjRDY3MEQ2XCIsXG4gIGJyaWdodEN5YW46IFwiIzI5QjhEQlwiLFxuICBicmlnaHRXaGl0ZTogXCIjRkZGRkZGXCJcbn07XG5mdW5jdGlvbiB0b2tlbml6ZUFuc2lXaXRoVGhlbWUodGhlbWUsIGZpbGVDb250ZW50cywgb3B0aW9ucykge1xuICBjb25zdCBjb2xvclJlcGxhY2VtZW50cyA9IHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyh0aGVtZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGxpbmVzID0gc3BsaXRMaW5lcyhmaWxlQ29udGVudHMpO1xuICBjb25zdCBhbnNpUGFsZXR0ZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBuYW1lZENvbG9ycy5tYXAoKG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGB0ZXJtaW5hbC5hbnNpJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCl9JHtuYW1lLnN1YnN0cmluZygxKX1gO1xuICAgICAgY29uc3QgdGhlbWVDb2xvciA9IHRoZW1lLmNvbG9ycz8uW2tleV07XG4gICAgICByZXR1cm4gW25hbWUsIHRoZW1lQ29sb3IgfHwgZGVmYXVsdEFuc2lDb2xvcnNbbmFtZV1dO1xuICAgIH0pXG4gICk7XG4gIGNvbnN0IGNvbG9yUGFsZXR0ZSA9IGNyZWF0ZUNvbG9yUGFsZXR0ZShhbnNpUGFsZXR0ZSk7XG4gIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUFuc2lTZXF1ZW5jZVBhcnNlcigpO1xuICByZXR1cm4gbGluZXMubWFwKFxuICAgIChsaW5lKSA9PiBwYXJzZXIucGFyc2UobGluZVswXSkubWFwKCh0b2tlbikgPT4ge1xuICAgICAgbGV0IGNvbG9yO1xuICAgICAgbGV0IGJnQ29sb3I7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwicmV2ZXJzZVwiKSkge1xuICAgICAgICBjb2xvciA9IHRva2VuLmJhY2tncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uYmFja2dyb3VuZCkgOiB0aGVtZS5iZztcbiAgICAgICAgYmdDb2xvciA9IHRva2VuLmZvcmVncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uZm9yZWdyb3VuZCkgOiB0aGVtZS5mZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yID0gdG9rZW4uZm9yZWdyb3VuZCA/IGNvbG9yUGFsZXR0ZS52YWx1ZSh0b2tlbi5mb3JlZ3JvdW5kKSA6IHRoZW1lLmZnO1xuICAgICAgICBiZ0NvbG9yID0gdG9rZW4uYmFja2dyb3VuZCA/IGNvbG9yUGFsZXR0ZS52YWx1ZSh0b2tlbi5iYWNrZ3JvdW5kKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbG9yID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhjb2xvciwgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgICAgYmdDb2xvciA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoYmdDb2xvciwgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcImRpbVwiKSlcbiAgICAgICAgY29sb3IgPSBkaW1Db2xvcihjb2xvcik7XG4gICAgICBsZXQgZm9udFN0eWxlID0gRm9udFN0eWxlLk5vbmU7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwiYm9sZFwiKSlcbiAgICAgICAgZm9udFN0eWxlIHw9IEZvbnRTdHlsZS5Cb2xkO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcIml0YWxpY1wiKSlcbiAgICAgICAgZm9udFN0eWxlIHw9IEZvbnRTdHlsZS5JdGFsaWM7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwidW5kZXJsaW5lXCIpKVxuICAgICAgICBmb250U3R5bGUgfD0gRm9udFN0eWxlLlVuZGVybGluZTtcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJzdHJpa2V0aHJvdWdoXCIpKVxuICAgICAgICBmb250U3R5bGUgfD0gRm9udFN0eWxlLlN0cmlrZXRocm91Z2g7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB0b2tlbi52YWx1ZSxcbiAgICAgICAgb2Zmc2V0OiBsaW5lWzFdLFxuICAgICAgICAvLyBUT0RPOiBtb3JlIGFjY3VyYXRlIG9mZnNldD8gbWlnaHQgbmVlZCB0byBmb3JrIGFuc2ktc2VxdWVuY2UtcGFyc2VyXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBiZ0NvbG9yLFxuICAgICAgICBmb250U3R5bGVcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGRpbUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IGhleE1hdGNoID0gY29sb3IubWF0Y2goLyMoWzAtOWEtZl17Myw4fSkvaSk7XG4gIGlmIChoZXhNYXRjaCkge1xuICAgIGNvbnN0IGhleCA9IGhleE1hdGNoWzFdO1xuICAgIGlmIChoZXgubGVuZ3RoID09PSA4KSB7XG4gICAgICBjb25zdCBhbHBoYSA9IE1hdGgucm91bmQoTnVtYmVyLnBhcnNlSW50KGhleC5zbGljZSg2LCA4KSwgMTYpIC8gMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICAgIHJldHVybiBgIyR7aGV4LnNsaWNlKDAsIDYpfSR7YWxwaGF9YDtcbiAgICB9IGVsc2UgaWYgKGhleC5sZW5ndGggPT09IDYpIHtcbiAgICAgIHJldHVybiBgIyR7aGV4fTgwYDtcbiAgICB9IGVsc2UgaWYgKGhleC5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNvbnN0IHIgPSBoZXhbMF07XG4gICAgICBjb25zdCBnID0gaGV4WzFdO1xuICAgICAgY29uc3QgYiA9IGhleFsyXTtcbiAgICAgIGNvbnN0IGEgPSBoZXhbM107XG4gICAgICBjb25zdCBhbHBoYSA9IE1hdGgucm91bmQoTnVtYmVyLnBhcnNlSW50KGAke2F9JHthfWAsIDE2KSAvIDIpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgICByZXR1cm4gYCMke3J9JHtyfSR7Z30ke2d9JHtifSR7Yn0ke2FscGhhfWA7XG4gICAgfSBlbHNlIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb25zdCByID0gaGV4WzBdO1xuICAgICAgY29uc3QgZyA9IGhleFsxXTtcbiAgICAgIGNvbnN0IGIgPSBoZXhbMl07XG4gICAgICByZXR1cm4gYCMke3J9JHtyfSR7Z30ke2d9JHtifSR7Yn04MGA7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNzc1Zhck1hdGNoID0gY29sb3IubWF0Y2goL3ZhclxcKCgtLVtcXHctXSstYW5zaS1bXFx3LV0rKVxcKS8pO1xuICBpZiAoY3NzVmFyTWF0Y2gpXG4gICAgcmV0dXJuIGB2YXIoJHtjc3NWYXJNYXRjaFsxXX0tZGltKWA7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0aGVtZTogdGhlbWVOYW1lID0gaW50ZXJuYWwuZ2V0TG9hZGVkVGhlbWVzKClbMF1cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGxhbmcgPSBpbnRlcm5hbC5yZXNvbHZlTGFuZ0FsaWFzKG9wdGlvbnMubGFuZyB8fCBcInRleHRcIik7XG4gIGlmIChpc1BsYWluTGFuZyhsYW5nKSB8fCBpc05vbmVUaGVtZSh0aGVtZU5hbWUpKVxuICAgIHJldHVybiBzcGxpdExpbmVzKGNvZGUpLm1hcCgobGluZSkgPT4gW3sgY29udGVudDogbGluZVswXSwgb2Zmc2V0OiBsaW5lWzFdIH1dKTtcbiAgY29uc3QgeyB0aGVtZSwgY29sb3JNYXAgfSA9IGludGVybmFsLnNldFRoZW1lKHRoZW1lTmFtZSk7XG4gIGlmIChsYW5nID09PSBcImFuc2lcIilcbiAgICByZXR1cm4gdG9rZW5pemVBbnNpV2l0aFRoZW1lKHRoZW1lLCBjb2RlLCBvcHRpb25zKTtcbiAgY29uc3QgX2dyYW1tYXIgPSBpbnRlcm5hbC5nZXRMYW5ndWFnZShvcHRpb25zLmxhbmcgfHwgXCJ0ZXh0XCIpO1xuICBpZiAob3B0aW9ucy5ncmFtbWFyU3RhdGUpIHtcbiAgICBpZiAob3B0aW9ucy5ncmFtbWFyU3RhdGUubGFuZyAhPT0gX2dyYW1tYXIubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgR3JhbW1hciBzdGF0ZSBsYW5ndWFnZSBcIiR7b3B0aW9ucy5ncmFtbWFyU3RhdGUubGFuZ31cIiBkb2VzIG5vdCBtYXRjaCBoaWdobGlnaHQgbGFuZ3VhZ2UgXCIke19ncmFtbWFyLm5hbWV9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmdyYW1tYXJTdGF0ZS50aGVtZXMuaW5jbHVkZXModGhlbWUubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEdyYW1tYXIgc3RhdGUgdGhlbWVzIFwiJHtvcHRpb25zLmdyYW1tYXJTdGF0ZS50aGVtZXN9XCIgZG8gbm90IGNvbnRhaW4gaGlnaGxpZ2h0IHRoZW1lIFwiJHt0aGVtZS5uYW1lfVwiYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBfZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldExhc3RHcmFtbWFyU3RhdGUoLi4uYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAoYXJnc1sxXSk7XG4gIH1cbiAgY29uc3QgW2ludGVybmFsLCBjb2RlLCBvcHRpb25zID0ge31dID0gYXJncztcbiAgY29uc3Qge1xuICAgIGxhbmcgPSBcInRleHRcIixcbiAgICB0aGVtZTogdGhlbWVOYW1lID0gaW50ZXJuYWwuZ2V0TG9hZGVkVGhlbWVzKClbMF1cbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChpc1BsYWluTGFuZyhsYW5nKSB8fCBpc05vbmVUaGVtZSh0aGVtZU5hbWUpKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJQbGFpbiBsYW5ndWFnZSBkb2VzIG5vdCBoYXZlIGdyYW1tYXIgc3RhdGVcIik7XG4gIGlmIChsYW5nID09PSBcImFuc2lcIilcbiAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKFwiQU5TSSBsYW5ndWFnZSBkb2VzIG5vdCBoYXZlIGdyYW1tYXIgc3RhdGVcIik7XG4gIGNvbnN0IHsgdGhlbWUsIGNvbG9yTWFwIH0gPSBpbnRlcm5hbC5zZXRUaGVtZSh0aGVtZU5hbWUpO1xuICBjb25zdCBfZ3JhbW1hciA9IGludGVybmFsLmdldExhbmd1YWdlKGxhbmcpO1xuICByZXR1cm4gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICBfdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgX2dyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucykuc3RhdGVTdGFjayxcbiAgICBfZ3JhbW1hci5uYW1lLFxuICAgIHRoZW1lLm5hbWVcbiAgKTtcbn1cbmZ1bmN0aW9uIHRva2VuaXplV2l0aFRoZW1lKGNvZGUsIGdyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBfdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKTtcbiAgY29uc3QgZ3JhbW1hclN0YXRlID0gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICByZXN1bHQuc3RhdGVTdGFjayxcbiAgICBncmFtbWFyLm5hbWUsXG4gICAgdGhlbWUubmFtZVxuICApO1xuICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAocmVzdWx0LnRva2VucywgZ3JhbW1hclN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdC50b2tlbnM7XG59XG5mdW5jdGlvbiBfdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbG9yUmVwbGFjZW1lbnRzID0gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lLCBvcHRpb25zKTtcbiAgY29uc3Qge1xuICAgIHRva2VuaXplTWF4TGluZUxlbmd0aCA9IDAsXG4gICAgdG9rZW5pemVUaW1lTGltaXQgPSA1MDBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGxpbmVzID0gc3BsaXRMaW5lcyhjb2RlKTtcbiAgbGV0IHN0YXRlU3RhY2sgPSBvcHRpb25zLmdyYW1tYXJTdGF0ZSA/IGdldEdyYW1tYXJTdGFjayhvcHRpb25zLmdyYW1tYXJTdGF0ZSwgdGhlbWUubmFtZSkgPz8gSU5JVElBTCA6IG9wdGlvbnMuZ3JhbW1hckNvbnRleHRDb2RlICE9IG51bGwgPyBfdG9rZW5pemVXaXRoVGhlbWUoXG4gICAgb3B0aW9ucy5ncmFtbWFyQ29udGV4dENvZGUsXG4gICAgZ3JhbW1hcixcbiAgICB0aGVtZSxcbiAgICBjb2xvck1hcCxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZ3JhbW1hclN0YXRlOiB2b2lkIDAsXG4gICAgICBncmFtbWFyQ29udGV4dENvZGU6IHZvaWQgMFxuICAgIH1cbiAgKS5zdGF0ZVN0YWNrIDogSU5JVElBTDtcbiAgbGV0IGFjdHVhbCA9IFtdO1xuICBjb25zdCBmaW5hbCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBbbGluZSwgbGluZU9mZnNldF0gPSBsaW5lc1tpXTtcbiAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgYWN0dWFsID0gW107XG4gICAgICBmaW5hbC5wdXNoKFtdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG9rZW5pemVNYXhMaW5lTGVuZ3RoID4gMCAmJiBsaW5lLmxlbmd0aCA+PSB0b2tlbml6ZU1heExpbmVMZW5ndGgpIHtcbiAgICAgIGFjdHVhbCA9IFtdO1xuICAgICAgZmluYWwucHVzaChbe1xuICAgICAgICBjb250ZW50OiBsaW5lLFxuICAgICAgICBvZmZzZXQ6IGxpbmVPZmZzZXQsXG4gICAgICAgIGNvbG9yOiBcIlwiLFxuICAgICAgICBmb250U3R5bGU6IDBcbiAgICAgIH1dKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0V2l0aFNjb3BlcztcbiAgICBsZXQgdG9rZW5zV2l0aFNjb3BlcztcbiAgICBsZXQgdG9rZW5zV2l0aFNjb3Blc0luZGV4O1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbikge1xuICAgICAgcmVzdWx0V2l0aFNjb3BlcyA9IGdyYW1tYXIudG9rZW5pemVMaW5lKGxpbmUsIHN0YXRlU3RhY2ssIHRva2VuaXplVGltZUxpbWl0KTtcbiAgICAgIHRva2Vuc1dpdGhTY29wZXMgPSByZXN1bHRXaXRoU2NvcGVzLnRva2VucztcbiAgICAgIHRva2Vuc1dpdGhTY29wZXNJbmRleCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGdyYW1tYXIudG9rZW5pemVMaW5lMihsaW5lLCBzdGF0ZVN0YWNrLCB0b2tlbml6ZVRpbWVMaW1pdCk7XG4gICAgY29uc3QgdG9rZW5zTGVuZ3RoID0gcmVzdWx0LnRva2Vucy5sZW5ndGggLyAyO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW5zTGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSByZXN1bHQudG9rZW5zWzIgKiBqXTtcbiAgICAgIGNvbnN0IG5leHRTdGFydEluZGV4ID0gaiArIDEgPCB0b2tlbnNMZW5ndGggPyByZXN1bHQudG9rZW5zWzIgKiBqICsgMl0gOiBsaW5lLmxlbmd0aDtcbiAgICAgIGlmIChzdGFydEluZGV4ID09PSBuZXh0U3RhcnRJbmRleClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHJlc3VsdC50b2tlbnNbMiAqIGogKyAxXTtcbiAgICAgIGNvbnN0IGNvbG9yID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhcbiAgICAgICAgY29sb3JNYXBbRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9yZWdyb3VuZChtZXRhZGF0YSldLFxuICAgICAgICBjb2xvclJlcGxhY2VtZW50c1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGZvbnRTdHlsZSA9IEVuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvbnRTdHlsZShtZXRhZGF0YSk7XG4gICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgY29udGVudDogbGluZS5zdWJzdHJpbmcoc3RhcnRJbmRleCwgbmV4dFN0YXJ0SW5kZXgpLFxuICAgICAgICBvZmZzZXQ6IGxpbmVPZmZzZXQgKyBzdGFydEluZGV4LFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZm9udFN0eWxlXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUV4cGxhbmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUV4cGxhbmF0aW9uICE9PSBcInNjb3BlTmFtZVwiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBzZXR0aW5nIG9mIHRoZW1lLnNldHRpbmdzKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0b3JzO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2V0dGluZy5zY29wZSkge1xuICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gc2V0dGluZy5zY29wZS5zcGxpdCgvLC8pLm1hcCgoc2NvcGUpID0+IHNjb3BlLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBzZXR0aW5nLnNjb3BlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlbWVTZXR0aW5nc1NlbGVjdG9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmcsXG4gICAgICAgICAgICAgIHNlbGVjdG9yczogc2VsZWN0b3JzLm1hcCgoc2VsZWN0b3IpID0+IHNlbGVjdG9yLnNwbGl0KC8gLykpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4uZXhwbGFuYXRpb24gPSBbXTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4ICsgb2Zmc2V0IDwgbmV4dFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbldpdGhTY29wZXMgPSB0b2tlbnNXaXRoU2NvcGVzW3Rva2Vuc1dpdGhTY29wZXNJbmRleF07XG4gICAgICAgICAgY29uc3QgdG9rZW5XaXRoU2NvcGVzVGV4dCA9IGxpbmUuc3Vic3RyaW5nKFxuICAgICAgICAgICAgdG9rZW5XaXRoU2NvcGVzLnN0YXJ0SW5kZXgsXG4gICAgICAgICAgICB0b2tlbldpdGhTY29wZXMuZW5kSW5kZXhcbiAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNldCArPSB0b2tlbldpdGhTY29wZXNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICB0b2tlbi5leHBsYW5hdGlvbi5wdXNoKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuV2l0aFNjb3Blc1RleHQsXG4gICAgICAgICAgICBzY29wZXM6IG9wdGlvbnMuaW5jbHVkZUV4cGxhbmF0aW9uID09PSBcInNjb3BlTmFtZVwiID8gZXhwbGFpblRoZW1lU2NvcGVzTmFtZU9ubHkoXG4gICAgICAgICAgICAgIHRva2VuV2l0aFNjb3Blcy5zY29wZXNcbiAgICAgICAgICAgICkgOiBleHBsYWluVGhlbWVTY29wZXNGdWxsKFxuICAgICAgICAgICAgICB0aGVtZVNldHRpbmdzU2VsZWN0b3JzLFxuICAgICAgICAgICAgICB0b2tlbldpdGhTY29wZXMuc2NvcGVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdG9rZW5zV2l0aFNjb3Blc0luZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdHVhbC5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgZmluYWwucHVzaChhY3R1YWwpO1xuICAgIGFjdHVhbCA9IFtdO1xuICAgIHN0YXRlU3RhY2sgPSByZXN1bHQucnVsZVN0YWNrO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9rZW5zOiBmaW5hbCxcbiAgICBzdGF0ZVN0YWNrXG4gIH07XG59XG5mdW5jdGlvbiBleHBsYWluVGhlbWVTY29wZXNOYW1lT25seShzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5tYXAoKHNjb3BlKSA9PiAoeyBzY29wZU5hbWU6IHNjb3BlIH0pKTtcbn1cbmZ1bmN0aW9uIGV4cGxhaW5UaGVtZVNjb3Blc0Z1bGwodGhlbWVTZWxlY3RvcnMsIHNjb3Blcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNjb3Blcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHNjb3BlID0gc2NvcGVzW2ldO1xuICAgIHJlc3VsdFtpXSA9IHtcbiAgICAgIHNjb3BlTmFtZTogc2NvcGUsXG4gICAgICB0aGVtZU1hdGNoZXM6IGV4cGxhaW5UaGVtZVNjb3BlKHRoZW1lU2VsZWN0b3JzLCBzY29wZSwgc2NvcGVzLnNsaWNlKDAsIGkpKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNPbmUoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PT0gc2NvcGUgfHwgc2NvcGUuc3Vic3RyaW5nKDAsIHNlbGVjdG9yLmxlbmd0aCkgPT09IHNlbGVjdG9yICYmIHNjb3BlW3NlbGVjdG9yLmxlbmd0aF0gPT09IFwiLlwiO1xufVxuZnVuY3Rpb24gbWF0Y2hlcyhzZWxlY3RvcnMsIHNjb3BlLCBwYXJlbnRTY29wZXMpIHtcbiAgaWYgKCFtYXRjaGVzT25lKHNlbGVjdG9yc1tzZWxlY3RvcnMubGVuZ3RoIC0gMV0sIHNjb3BlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBzZWxlY3RvclBhcmVudEluZGV4ID0gc2VsZWN0b3JzLmxlbmd0aCAtIDI7XG4gIGxldCBwYXJlbnRJbmRleCA9IHBhcmVudFNjb3Blcy5sZW5ndGggLSAxO1xuICB3aGlsZSAoc2VsZWN0b3JQYXJlbnRJbmRleCA+PSAwICYmIHBhcmVudEluZGV4ID49IDApIHtcbiAgICBpZiAobWF0Y2hlc09uZShzZWxlY3RvcnNbc2VsZWN0b3JQYXJlbnRJbmRleF0sIHBhcmVudFNjb3Blc1twYXJlbnRJbmRleF0pKVxuICAgICAgc2VsZWN0b3JQYXJlbnRJbmRleCAtPSAxO1xuICAgIHBhcmVudEluZGV4IC09IDE7XG4gIH1cbiAgaWYgKHNlbGVjdG9yUGFyZW50SW5kZXggPT09IC0xKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBleHBsYWluVGhlbWVTY29wZSh0aGVtZVNldHRpbmdzU2VsZWN0b3JzLCBzY29wZSwgcGFyZW50U2NvcGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IHsgc2VsZWN0b3JzLCBzZXR0aW5ncyB9IG9mIHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yUGllY2VzIG9mIHNlbGVjdG9ycykge1xuICAgICAgaWYgKG1hdGNoZXMoc2VsZWN0b3JQaWVjZXMsIHNjb3BlLCBwYXJlbnRTY29wZXMpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHNldHRpbmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGhlbWVzID0gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50aGVtZXMpLmZpbHRlcigoaSkgPT4gaVsxXSkubWFwKChpKSA9PiAoeyBjb2xvcjogaVswXSwgdGhlbWU6IGlbMV0gfSkpO1xuICBjb25zdCB0aGVtZWRUb2tlbnMgPSB0aGVtZXMubWFwKCh0KSA9PiB7XG4gICAgY29uc3QgdG9rZW5zMiA9IGNvZGVUb1Rva2Vuc0Jhc2UoaW50ZXJuYWwsIGNvZGUsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0aGVtZTogdC50aGVtZVxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAodG9rZW5zMik7XG4gICAgY29uc3QgdGhlbWUgPSB0eXBlb2YgdC50aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHQudGhlbWUgOiB0LnRoZW1lLm5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogdG9rZW5zMixcbiAgICAgIHN0YXRlLFxuICAgICAgdGhlbWVcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgdG9rZW5zID0gc3luY1RoZW1lc1Rva2VuaXphdGlvbihcbiAgICAuLi50aGVtZWRUb2tlbnMubWFwKChpKSA9PiBpLnRva2VucylcbiAgKTtcbiAgY29uc3QgbWVyZ2VkVG9rZW5zID0gdG9rZW5zWzBdLm1hcChcbiAgICAobGluZSwgbGluZUlkeCkgPT4gbGluZS5tYXAoKF90b2tlbiwgdG9rZW5JZHgpID0+IHtcbiAgICAgIGNvbnN0IG1lcmdlZFRva2VuID0ge1xuICAgICAgICBjb250ZW50OiBfdG9rZW4uY29udGVudCxcbiAgICAgICAgdmFyaWFudHM6IHt9LFxuICAgICAgICBvZmZzZXQ6IF90b2tlbi5vZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoXCJpbmNsdWRlRXhwbGFuYXRpb25cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZUV4cGxhbmF0aW9uKSB7XG4gICAgICAgIG1lcmdlZFRva2VuLmV4cGxhbmF0aW9uID0gX3Rva2VuLmV4cGxhbmF0aW9uO1xuICAgICAgfVxuICAgICAgdG9rZW5zLmZvckVhY2goKHQsIHRoZW1lSWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb250ZW50OiBfLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBfXyxcbiAgICAgICAgICBvZmZzZXQ6IF9fXyxcbiAgICAgICAgICAuLi5zdHlsZXNcbiAgICAgICAgfSA9IHRbbGluZUlkeF1bdG9rZW5JZHhdO1xuICAgICAgICBtZXJnZWRUb2tlbi52YXJpYW50c1t0aGVtZXNbdGhlbWVJZHhdLmNvbG9yXSA9IHN0eWxlcztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lcmdlZFRva2VuO1xuICAgIH0pXG4gICk7XG4gIGNvbnN0IG1lcmdlZEdyYW1tYXJTdGF0ZSA9IHRoZW1lZFRva2Vuc1swXS5zdGF0ZSA/IG5ldyBHcmFtbWFyU3RhdGUoXG4gICAgT2JqZWN0LmZyb21FbnRyaWVzKHRoZW1lZFRva2Vucy5tYXAoKHMpID0+IFtzLnRoZW1lLCBzLnN0YXRlPy5nZXRJbnRlcm5hbFN0YWNrKHMudGhlbWUpXSkpLFxuICAgIHRoZW1lZFRva2Vuc1swXS5zdGF0ZS5sYW5nXG4gICkgOiB2b2lkIDA7XG4gIGlmIChtZXJnZWRHcmFtbWFyU3RhdGUpXG4gICAgc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKG1lcmdlZFRva2VucywgbWVyZ2VkR3JhbW1hclN0YXRlKTtcbiAgcmV0dXJuIG1lcmdlZFRva2Vucztcbn1cbmZ1bmN0aW9uIHN5bmNUaGVtZXNUb2tlbml6YXRpb24oLi4udGhlbWVzKSB7XG4gIGNvbnN0IG91dFRoZW1lcyA9IHRoZW1lcy5tYXAoKCkgPT4gW10pO1xuICBjb25zdCBjb3VudCA9IHRoZW1lcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhlbWVzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZXMgPSB0aGVtZXMubWFwKCh0KSA9PiB0W2ldKTtcbiAgICBjb25zdCBvdXRMaW5lcyA9IG91dFRoZW1lcy5tYXAoKCkgPT4gW10pO1xuICAgIG91dFRoZW1lcy5mb3JFYWNoKCh0LCBpMikgPT4gdC5wdXNoKG91dExpbmVzW2kyXSkpO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBsaW5lcy5tYXAoKCkgPT4gMCk7XG4gICAgY29uc3QgY3VycmVudCA9IGxpbmVzLm1hcCgobCkgPT4gbFswXSk7XG4gICAgd2hpbGUgKGN1cnJlbnQuZXZlcnkoKHQpID0+IHQpKSB7XG4gICAgICBjb25zdCBtaW5MZW5ndGggPSBNYXRoLm1pbiguLi5jdXJyZW50Lm1hcCgodCkgPT4gdC5jb250ZW50Lmxlbmd0aCkpO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBjb3VudDsgbisrKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gY3VycmVudFtuXTtcbiAgICAgICAgaWYgKHRva2VuLmNvbnRlbnQubGVuZ3RoID09PSBtaW5MZW5ndGgpIHtcbiAgICAgICAgICBvdXRMaW5lc1tuXS5wdXNoKHRva2VuKTtcbiAgICAgICAgICBpbmRleGVzW25dICs9IDE7XG4gICAgICAgICAgY3VycmVudFtuXSA9IGxpbmVzW25dW2luZGV4ZXNbbl1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dExpbmVzW25dLnB1c2goe1xuICAgICAgICAgICAgLi4udG9rZW4sXG4gICAgICAgICAgICBjb250ZW50OiB0b2tlbi5jb250ZW50LnNsaWNlKDAsIG1pbkxlbmd0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50W25dID0ge1xuICAgICAgICAgICAgLi4udG9rZW4sXG4gICAgICAgICAgICBjb250ZW50OiB0b2tlbi5jb250ZW50LnNsaWNlKG1pbkxlbmd0aCksXG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuLm9mZnNldCArIG1pbkxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFRoZW1lcztcbn1cblxuZnVuY3Rpb24gY29kZVRvVG9rZW5zKGludGVybmFsLCBjb2RlLCBvcHRpb25zKSB7XG4gIGxldCBiZztcbiAgbGV0IGZnO1xuICBsZXQgdG9rZW5zO1xuICBsZXQgdGhlbWVOYW1lO1xuICBsZXQgcm9vdFN0eWxlO1xuICBsZXQgZ3JhbW1hclN0YXRlO1xuICBpZiAoXCJ0aGVtZXNcIiBpbiBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVmYXVsdENvbG9yID0gXCJsaWdodFwiLFxuICAgICAgY3NzVmFyaWFibGVQcmVmaXggPSBcIi0tc2hpa2ktXCIsXG4gICAgICBjb2xvcnNSZW5kZXJpbmcgPSBcImNzcy12YXJzXCJcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0aGVtZXMgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLnRoZW1lcykuZmlsdGVyKChpKSA9PiBpWzFdKS5tYXAoKGkpID0+ICh7IGNvbG9yOiBpWzBdLCB0aGVtZTogaVsxXSB9KSkuc29ydCgoYSwgYikgPT4gYS5jb2xvciA9PT0gZGVmYXVsdENvbG9yID8gLTEgOiBiLmNvbG9yID09PSBkZWZhdWx0Q29sb3IgPyAxIDogMCk7XG4gICAgaWYgKHRoZW1lcy5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKFwiYHRoZW1lc2Agb3B0aW9uIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICAgIGNvbnN0IHRoZW1lVG9rZW5zID0gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhcbiAgICAgIGludGVybmFsLFxuICAgICAgY29kZSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGdyYW1tYXJTdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRoZW1lVG9rZW5zKTtcbiAgICBpZiAoZGVmYXVsdENvbG9yICYmIERFRkFVTFRfQ09MT1JfTElHSFRfREFSSyAhPT0gZGVmYXVsdENvbG9yICYmICF0aGVtZXMuZmluZCgodCkgPT4gdC5jb2xvciA9PT0gZGVmYXVsdENvbG9yKSlcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYFxcYHRoZW1lc1xcYCBvcHRpb24gbXVzdCBjb250YWluIHRoZSBkZWZhdWx0Q29sb3Iga2V5IFxcYCR7ZGVmYXVsdENvbG9yfVxcYGApO1xuICAgIGNvbnN0IHRoZW1lUmVncyA9IHRoZW1lcy5tYXAoKHQpID0+IGludGVybmFsLmdldFRoZW1lKHQudGhlbWUpKTtcbiAgICBjb25zdCB0aGVtZXNPcmRlciA9IHRoZW1lcy5tYXAoKHQpID0+IHQuY29sb3IpO1xuICAgIHRva2VucyA9IHRoZW1lVG9rZW5zLm1hcCgobGluZSkgPT4gbGluZS5tYXAoKHRva2VuKSA9PiBmbGF0VG9rZW5WYXJpYW50cyh0b2tlbiwgdGhlbWVzT3JkZXIsIGNzc1ZhcmlhYmxlUHJlZml4LCBkZWZhdWx0Q29sb3IsIGNvbG9yc1JlbmRlcmluZykpKTtcbiAgICBpZiAoZ3JhbW1hclN0YXRlKVxuICAgICAgc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKHRva2VucywgZ3JhbW1hclN0YXRlKTtcbiAgICBjb25zdCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzID0gdGhlbWVzLm1hcCgodCkgPT4gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKHQudGhlbWUsIG9wdGlvbnMpKTtcbiAgICBmZyA9IG1hcFRoZW1lQ29sb3JzKHRoZW1lcywgdGhlbWVSZWdzLCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzLCBjc3NWYXJpYWJsZVByZWZpeCwgZGVmYXVsdENvbG9yLCBcImZnXCIsIGNvbG9yc1JlbmRlcmluZyk7XG4gICAgYmcgPSBtYXBUaGVtZUNvbG9ycyh0aGVtZXMsIHRoZW1lUmVncywgdGhlbWVDb2xvclJlcGxhY2VtZW50cywgY3NzVmFyaWFibGVQcmVmaXgsIGRlZmF1bHRDb2xvciwgXCJiZ1wiLCBjb2xvcnNSZW5kZXJpbmcpO1xuICAgIHRoZW1lTmFtZSA9IGBzaGlraS10aGVtZXMgJHt0aGVtZVJlZ3MubWFwKCh0KSA9PiB0Lm5hbWUpLmpvaW4oXCIgXCIpfWA7XG4gICAgcm9vdFN0eWxlID0gZGVmYXVsdENvbG9yID8gdm9pZCAwIDogW2ZnLCBiZ10uam9pbihcIjtcIik7XG4gIH0gZWxzZSBpZiAoXCJ0aGVtZVwiIGluIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb2xvclJlcGxhY2VtZW50cyA9IHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyhvcHRpb25zLnRoZW1lLCBvcHRpb25zKTtcbiAgICB0b2tlbnMgPSBjb2RlVG9Ub2tlbnNCYXNlKFxuICAgICAgaW50ZXJuYWwsXG4gICAgICBjb2RlLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgX3RoZW1lID0gaW50ZXJuYWwuZ2V0VGhlbWUob3B0aW9ucy50aGVtZSk7XG4gICAgYmcgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKF90aGVtZS5iZywgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgIGZnID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhfdGhlbWUuZmcsIGNvbG9yUmVwbGFjZW1lbnRzKTtcbiAgICB0aGVtZU5hbWUgPSBfdGhlbWUubmFtZTtcbiAgICBncmFtbWFyU3RhdGUgPSBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcCh0b2tlbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJJbnZhbGlkIG9wdGlvbnMsIGVpdGhlciBgdGhlbWVgIG9yIGB0aGVtZXNgIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnMsXG4gICAgZmcsXG4gICAgYmcsXG4gICAgdGhlbWVOYW1lLFxuICAgIHJvb3RTdHlsZSxcbiAgICBncmFtbWFyU3RhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcFRoZW1lQ29sb3JzKHRoZW1lcywgdGhlbWVSZWdzLCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzLCBjc3NWYXJpYWJsZVByZWZpeCwgZGVmYXVsdENvbG9yLCBwcm9wZXJ0eSwgY29sb3JzUmVuZGVyaW5nKSB7XG4gIHJldHVybiB0aGVtZXMubWFwKCh0LCBpZHgpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHModGhlbWVSZWdzW2lkeF1bcHJvcGVydHldLCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzW2lkeF0pIHx8IFwiaW5oZXJpdFwiO1xuICAgIGNvbnN0IGNzc1ZhciA9IGAke2Nzc1ZhcmlhYmxlUHJlZml4ICsgdC5jb2xvcn0ke3Byb3BlcnR5ID09PSBcImJnXCIgPyBcIi1iZ1wiIDogXCJcIn06JHt2YWx1ZX1gO1xuICAgIGlmIChpZHggPT09IDAgJiYgZGVmYXVsdENvbG9yKSB7XG4gICAgICBpZiAoZGVmYXVsdENvbG9yID09PSBERUZBVUxUX0NPTE9SX0xJR0hUX0RBUksgJiYgdGhlbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbGlnaHRJbmRleCA9IHRoZW1lcy5maW5kSW5kZXgoKHQyKSA9PiB0Mi5jb2xvciA9PT0gXCJsaWdodFwiKTtcbiAgICAgICAgY29uc3QgZGFya0luZGV4ID0gdGhlbWVzLmZpbmRJbmRleCgodDIpID0+IHQyLmNvbG9yID09PSBcImRhcmtcIik7XG4gICAgICAgIGlmIChsaWdodEluZGV4ID09PSAtMSB8fCBkYXJrSW5kZXggPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoJ1doZW4gdXNpbmcgYGRlZmF1bHRDb2xvcjogXCJsaWdodC1kYXJrKClcImAsIHlvdSBtdXN0IHByb3ZpZGUgYm90aCBgbGlnaHRgIGFuZCBgZGFya2AgdGhlbWVzJyk7XG4gICAgICAgIGNvbnN0IGxpZ2h0VmFsdWUgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lUmVnc1tsaWdodEluZGV4XVtwcm9wZXJ0eV0sIHRoZW1lQ29sb3JSZXBsYWNlbWVudHNbbGlnaHRJbmRleF0pIHx8IFwiaW5oZXJpdFwiO1xuICAgICAgICBjb25zdCBkYXJrVmFsdWUgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lUmVnc1tkYXJrSW5kZXhdW3Byb3BlcnR5XSwgdGhlbWVDb2xvclJlcGxhY2VtZW50c1tkYXJrSW5kZXhdKSB8fCBcImluaGVyaXRcIjtcbiAgICAgICAgcmV0dXJuIGBsaWdodC1kYXJrKCR7bGlnaHRWYWx1ZX0sICR7ZGFya1ZhbHVlfSk7JHtjc3NWYXJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNvbG9yc1JlbmRlcmluZyA9PT0gXCJjc3MtdmFyc1wiKSB7XG4gICAgICByZXR1cm4gY3NzVmFyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSkuZmlsdGVyKChpKSA9PiAhIWkpLmpvaW4oXCI7XCIpO1xufVxuXG5mdW5jdGlvbiBjb2RlVG9IYXN0KGludGVybmFsLCBjb2RlLCBvcHRpb25zLCB0cmFuc2Zvcm1lckNvbnRleHQgPSB7XG4gIG1ldGE6IHt9LFxuICBvcHRpb25zLFxuICBjb2RlVG9IYXN0OiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9IYXN0KGludGVybmFsLCBfY29kZSwgX29wdGlvbnMpLFxuICBjb2RlVG9Ub2tlbnM6IChfY29kZSwgX29wdGlvbnMpID0+IGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKVxufSkge1xuICBsZXQgaW5wdXQgPSBjb2RlO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIGdldFRyYW5zZm9ybWVycyhvcHRpb25zKSlcbiAgICBpbnB1dCA9IHRyYW5zZm9ybWVyLnByZXByb2Nlc3M/LmNhbGwodHJhbnNmb3JtZXJDb250ZXh0LCBpbnB1dCwgb3B0aW9ucykgfHwgaW5wdXQ7XG4gIGxldCB7XG4gICAgdG9rZW5zLFxuICAgIGZnLFxuICAgIGJnLFxuICAgIHRoZW1lTmFtZSxcbiAgICByb290U3R5bGUsXG4gICAgZ3JhbW1hclN0YXRlXG4gIH0gPSBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGlucHV0LCBvcHRpb25zKTtcbiAgY29uc3Qge1xuICAgIG1lcmdlV2hpdGVzcGFjZXMgPSB0cnVlLFxuICAgIG1lcmdlU2FtZVN0eWxlVG9rZW5zID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChtZXJnZVdoaXRlc3BhY2VzID09PSB0cnVlKVxuICAgIHRva2VucyA9IG1lcmdlV2hpdGVzcGFjZVRva2Vucyh0b2tlbnMpO1xuICBlbHNlIGlmIChtZXJnZVdoaXRlc3BhY2VzID09PSBcIm5ldmVyXCIpXG4gICAgdG9rZW5zID0gc3BsaXRXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucyk7XG4gIGlmIChtZXJnZVNhbWVTdHlsZVRva2Vucykge1xuICAgIHRva2VucyA9IG1lcmdlQWRqYWNlbnRTdHlsZWRUb2tlbnModG9rZW5zKTtcbiAgfVxuICBjb25zdCBjb250ZXh0U291cmNlID0ge1xuICAgIC4uLnRyYW5zZm9ybWVyQ29udGV4dCxcbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgdG9rZW5zID0gdHJhbnNmb3JtZXIudG9rZW5zPy5jYWxsKGNvbnRleHRTb3VyY2UsIHRva2VucykgfHwgdG9rZW5zO1xuICByZXR1cm4gdG9rZW5zVG9IYXN0KFxuICAgIHRva2VucyxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZmcsXG4gICAgICBiZyxcbiAgICAgIHRoZW1lTmFtZSxcbiAgICAgIHJvb3RTdHlsZTogb3B0aW9ucy5yb290U3R5bGUgPT09IGZhbHNlID8gZmFsc2UgOiBvcHRpb25zLnJvb3RTdHlsZSA/PyByb290U3R5bGVcbiAgICB9LFxuICAgIGNvbnRleHRTb3VyY2UsXG4gICAgZ3JhbW1hclN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiB0b2tlbnNUb0hhc3QodG9rZW5zLCBvcHRpb25zLCB0cmFuc2Zvcm1lckNvbnRleHQsIGdyYW1tYXJTdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2VucykpIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBjb25zdCByb290ID0ge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBjb25zdCB7XG4gICAgc3RydWN0dXJlID0gXCJjbGFzc2ljXCIsXG4gICAgdGFiaW5kZXggPSBcIjBcIlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICBjbGFzczogYHNoaWtpICR7b3B0aW9ucy50aGVtZU5hbWUgfHwgXCJcIn1gXG4gIH07XG4gIGlmIChvcHRpb25zLnJvb3RTdHlsZSAhPT0gZmFsc2UpIHtcbiAgICBpZiAob3B0aW9ucy5yb290U3R5bGUgIT0gbnVsbClcbiAgICAgIHByb3BlcnRpZXMuc3R5bGUgPSBvcHRpb25zLnJvb3RTdHlsZTtcbiAgICBlbHNlXG4gICAgICBwcm9wZXJ0aWVzLnN0eWxlID0gYGJhY2tncm91bmQtY29sb3I6JHtvcHRpb25zLmJnfTtjb2xvcjoke29wdGlvbnMuZmd9YDtcbiAgfVxuICBpZiAodGFiaW5kZXggIT09IGZhbHNlICYmIHRhYmluZGV4ICE9IG51bGwpXG4gICAgcHJvcGVydGllcy50YWJpbmRleCA9IHRhYmluZGV4LnRvU3RyaW5nKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMubWV0YSB8fCB7fSkpIHtcbiAgICBpZiAoIWtleS5zdGFydHNXaXRoKFwiX1wiKSlcbiAgICAgIHByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIGxldCBwcmVOb2RlID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwicHJlXCIsXG4gICAgcHJvcGVydGllcyxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgZGF0YTogb3B0aW9ucy5kYXRhXG4gIH07XG4gIGxldCBjb2RlTm9kZSA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImNvZGVcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbGluZXNcbiAgfTtcbiAgY29uc3QgbGluZU5vZGVzID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgLi4udHJhbnNmb3JtZXJDb250ZXh0LFxuICAgIHN0cnVjdHVyZSxcbiAgICBhZGRDbGFzc1RvSGFzdCxcbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyQ29udGV4dC5zb3VyY2U7XG4gICAgfSxcbiAgICBnZXQgdG9rZW5zKCkge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9LFxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH0sXG4gICAgZ2V0IHByZSgpIHtcbiAgICAgIHJldHVybiBwcmVOb2RlO1xuICAgIH0sXG4gICAgZ2V0IGNvZGUoKSB7XG4gICAgICByZXR1cm4gY29kZU5vZGU7XG4gICAgfSxcbiAgICBnZXQgbGluZXMoKSB7XG4gICAgICByZXR1cm4gbGluZU5vZGVzO1xuICAgIH1cbiAgfTtcbiAgdG9rZW5zLmZvckVhY2goKGxpbmUsIGlkeCkgPT4ge1xuICAgIGlmIChpZHgpIHtcbiAgICAgIGlmIChzdHJ1Y3R1cmUgPT09IFwiaW5saW5lXCIpXG4gICAgICAgIHJvb3QuY2hpbGRyZW4ucHVzaCh7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcImJyXCIsIHByb3BlcnRpZXM6IHt9LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICBlbHNlIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKVxuICAgICAgICBsaW5lcy5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIlxcblwiIH0pO1xuICAgIH1cbiAgICBsZXQgbGluZU5vZGUgPSB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgcHJvcGVydGllczogeyBjbGFzczogXCJsaW5lXCIgfSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBsaW5lKSB7XG4gICAgICBsZXQgdG9rZW5Ob2RlID0ge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAuLi50b2tlbi5odG1sQXR0cnNcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogdG9rZW4uY29udGVudCB9XVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0eWxlID0gc3RyaW5naWZ5VG9rZW5TdHlsZSh0b2tlbi5odG1sU3R5bGUgfHwgZ2V0VG9rZW5TdHlsZU9iamVjdCh0b2tlbikpO1xuICAgICAgaWYgKHN0eWxlKVxuICAgICAgICB0b2tlbk5vZGUucHJvcGVydGllcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpXG4gICAgICAgIHRva2VuTm9kZSA9IHRyYW5zZm9ybWVyPy5zcGFuPy5jYWxsKGNvbnRleHQsIHRva2VuTm9kZSwgaWR4ICsgMSwgY29sLCBsaW5lTm9kZSwgdG9rZW4pIHx8IHRva2VuTm9kZTtcbiAgICAgIGlmIChzdHJ1Y3R1cmUgPT09IFwiaW5saW5lXCIpXG4gICAgICAgIHJvb3QuY2hpbGRyZW4ucHVzaCh0b2tlbk5vZGUpO1xuICAgICAgZWxzZSBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIilcbiAgICAgICAgbGluZU5vZGUuY2hpbGRyZW4ucHVzaCh0b2tlbk5vZGUpO1xuICAgICAgY29sICs9IHRva2VuLmNvbnRlbnQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIikge1xuICAgICAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpXG4gICAgICAgIGxpbmVOb2RlID0gdHJhbnNmb3JtZXI/LmxpbmU/LmNhbGwoY29udGV4dCwgbGluZU5vZGUsIGlkeCArIDEpIHx8IGxpbmVOb2RlO1xuICAgICAgbGluZU5vZGVzLnB1c2gobGluZU5vZGUpO1xuICAgICAgbGluZXMucHVzaChsaW5lTm9kZSk7XG4gICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGxpbmVOb2Rlcy5wdXNoKGxpbmVOb2RlKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIikge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgY29kZU5vZGUgPSB0cmFuc2Zvcm1lcj8uY29kZT8uY2FsbChjb250ZXh0LCBjb2RlTm9kZSkgfHwgY29kZU5vZGU7XG4gICAgcHJlTm9kZS5jaGlsZHJlbi5wdXNoKGNvZGVOb2RlKTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICAgIHByZU5vZGUgPSB0cmFuc2Zvcm1lcj8ucHJlPy5jYWxsKGNvbnRleHQsIHByZU5vZGUpIHx8IHByZU5vZGU7XG4gICAgcm9vdC5jaGlsZHJlbi5wdXNoKHByZU5vZGUpO1xuICB9IGVsc2UgaWYgKHN0cnVjdHVyZSA9PT0gXCJpbmxpbmVcIikge1xuICAgIGNvbnN0IHN5bnRoZXRpY0xpbmVzID0gW107XG4gICAgbGV0IGN1cnJlbnRMaW5lID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgIHByb3BlcnRpZXM6IHsgY2xhc3M6IFwibGluZVwiIH0sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygcm9vdC5jaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIGNoaWxkLnRhZ05hbWUgPT09IFwiYnJcIikge1xuICAgICAgICBzeW50aGV0aWNMaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgY3VycmVudExpbmUgPSB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgICAgdGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgICAgcHJvcGVydGllczogeyBjbGFzczogXCJsaW5lXCIgfSxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gXCJlbGVtZW50XCIgfHwgY2hpbGQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY3VycmVudExpbmUuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN5bnRoZXRpY0xpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgIGNvbnN0IHN5bnRoZXRpY0NvZGUgPSB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IFwiY29kZVwiLFxuICAgICAgcHJvcGVydGllczoge30sXG4gICAgICBjaGlsZHJlbjogc3ludGhldGljTGluZXNcbiAgICB9O1xuICAgIGxldCB0cmFuc2Zvcm1lZENvZGUgPSBzeW50aGV0aWNDb2RlO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgdHJhbnNmb3JtZWRDb2RlID0gdHJhbnNmb3JtZXI/LmNvZGU/LmNhbGwoY29udGV4dCwgdHJhbnNmb3JtZWRDb2RlKSB8fCB0cmFuc2Zvcm1lZENvZGU7XG4gICAgcm9vdC5jaGlsZHJlbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRDb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApXG4gICAgICAgIHJvb3QuY2hpbGRyZW4ucHVzaCh7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcImJyXCIsIHByb3BlcnRpZXM6IHt9LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICBjb25zdCBsaW5lID0gdHJhbnNmb3JtZWRDb2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGxpbmUudHlwZSA9PT0gXCJlbGVtZW50XCIpXG4gICAgICAgIHJvb3QuY2hpbGRyZW4ucHVzaCguLi5saW5lLmNoaWxkcmVuKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHJvb3Q7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgIHJlc3VsdCA9IHRyYW5zZm9ybWVyPy5yb290Py5jYWxsKGNvbnRleHQsIHJlc3VsdCkgfHwgcmVzdWx0O1xuICBpZiAoZ3JhbW1hclN0YXRlKVxuICAgIHNldExhc3RHcmFtbWFyU3RhdGVUb01hcChyZXN1bHQsIGdyYW1tYXJTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZXJnZVdoaXRlc3BhY2VUb2tlbnModG9rZW5zKSB7XG4gIHJldHVybiB0b2tlbnMubWFwKChsaW5lKSA9PiB7XG4gICAgY29uc3QgbmV3TGluZSA9IFtdO1xuICAgIGxldCBjYXJyeU9uQ29udGVudCA9IFwiXCI7XG4gICAgbGV0IGZpcnN0T2Zmc2V0O1xuICAgIGxpbmUuZm9yRWFjaCgodG9rZW4sIGlkeCkgPT4ge1xuICAgICAgY29uc3QgaXNEZWNvcmF0ZWQgPSB0b2tlbi5mb250U3R5bGUgJiYgKHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5VbmRlcmxpbmUgfHwgdG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLlN0cmlrZXRocm91Z2gpO1xuICAgICAgY29uc3QgY291bGRNZXJnZSA9ICFpc0RlY29yYXRlZDtcbiAgICAgIGlmIChjb3VsZE1lcmdlICYmIHRva2VuLmNvbnRlbnQubWF0Y2goL15cXHMrJC8pICYmIGxpbmVbaWR4ICsgMV0pIHtcbiAgICAgICAgaWYgKGZpcnN0T2Zmc2V0ID09PSB2b2lkIDApXG4gICAgICAgICAgZmlyc3RPZmZzZXQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgIGNhcnJ5T25Db250ZW50ICs9IHRva2VuLmNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FycnlPbkNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoY291bGRNZXJnZSkge1xuICAgICAgICAgICAgbmV3TGluZS5wdXNoKHtcbiAgICAgICAgICAgICAgLi4udG9rZW4sXG4gICAgICAgICAgICAgIG9mZnNldDogZmlyc3RPZmZzZXQsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGNhcnJ5T25Db250ZW50ICsgdG9rZW4uY29udGVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xpbmUucHVzaChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNhcnJ5T25Db250ZW50LFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmlyc3RPZmZzZXRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpcnN0T2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgICAgIGNhcnJ5T25Db250ZW50ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMaW5lLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0xpbmU7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3BsaXRXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmZsYXRNYXAoKHRva2VuKSA9PiB7XG4gICAgICBpZiAodG9rZW4uY29udGVudC5tYXRjaCgvXlxccyskLykpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIGNvbnN0IG1hdGNoID0gdG9rZW4uY29udGVudC5tYXRjaCgvXihcXHMqKSguKj8pKFxccyopJC8pO1xuICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgY29uc3QgWywgbGVhZGluZywgY29udGVudCwgdHJhaWxpbmddID0gbWF0Y2g7XG4gICAgICBpZiAoIWxlYWRpbmcgJiYgIXRyYWlsaW5nKVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICBjb25zdCBleHBhbmRlZCA9IFt7XG4gICAgICAgIC4uLnRva2VuLFxuICAgICAgICBvZmZzZXQ6IHRva2VuLm9mZnNldCArIGxlYWRpbmcubGVuZ3RoLFxuICAgICAgICBjb250ZW50XG4gICAgICB9XTtcbiAgICAgIGlmIChsZWFkaW5nKSB7XG4gICAgICAgIGV4cGFuZGVkLnVuc2hpZnQoe1xuICAgICAgICAgIGNvbnRlbnQ6IGxlYWRpbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhaWxpbmcpIHtcbiAgICAgICAgZXhwYW5kZWQucHVzaCh7XG4gICAgICAgICAgY29udGVudDogdHJhaWxpbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBsZWFkaW5nLmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lcmdlQWRqYWNlbnRTdHlsZWRUb2tlbnModG9rZW5zKSB7XG4gIHJldHVybiB0b2tlbnMubWFwKChsaW5lKSA9PiB7XG4gICAgY29uc3QgbmV3TGluZSA9IFtdO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbGluZSkge1xuICAgICAgaWYgKG5ld0xpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5ld0xpbmUucHVzaCh7IC4uLnRva2VuIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZUb2tlbiA9IG5ld0xpbmVbbmV3TGluZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IHByZXZTdHlsZSA9IHN0cmluZ2lmeVRva2VuU3R5bGUocHJldlRva2VuLmh0bWxTdHlsZSB8fCBnZXRUb2tlblN0eWxlT2JqZWN0KHByZXZUb2tlbikpO1xuICAgICAgY29uc3QgY3VycmVudFN0eWxlID0gc3RyaW5naWZ5VG9rZW5TdHlsZSh0b2tlbi5odG1sU3R5bGUgfHwgZ2V0VG9rZW5TdHlsZU9iamVjdCh0b2tlbikpO1xuICAgICAgY29uc3QgaXNQcmV2RGVjb3JhdGVkID0gcHJldlRva2VuLmZvbnRTdHlsZSAmJiAocHJldlRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5VbmRlcmxpbmUgfHwgcHJldlRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoKTtcbiAgICAgIGNvbnN0IGlzRGVjb3JhdGVkID0gdG9rZW4uZm9udFN0eWxlICYmICh0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuVW5kZXJsaW5lIHx8IHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5TdHJpa2V0aHJvdWdoKTtcbiAgICAgIGlmICghaXNQcmV2RGVjb3JhdGVkICYmICFpc0RlY29yYXRlZCAmJiBwcmV2U3R5bGUgPT09IGN1cnJlbnRTdHlsZSkge1xuICAgICAgICBwcmV2VG9rZW4uY29udGVudCArPSB0b2tlbi5jb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TGluZS5wdXNoKHsgLi4udG9rZW4gfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdMaW5lO1xuICB9KTtcbn1cblxuY29uc3QgaGFzdFRvSHRtbCA9IHRvSHRtbDtcbmZ1bmN0aW9uIGNvZGVUb0h0bWwoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBtZXRhOiB7fSxcbiAgICBvcHRpb25zLFxuICAgIGNvZGVUb0hhc3Q6IChfY29kZSwgX29wdGlvbnMpID0+IGNvZGVUb0hhc3QoaW50ZXJuYWwsIF9jb2RlLCBfb3B0aW9ucyksXG4gICAgY29kZVRvVG9rZW5zOiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIF9jb2RlLCBfb3B0aW9ucylcbiAgfTtcbiAgbGV0IHJlc3VsdCA9IGhhc3RUb0h0bWwoY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9ucywgY29udGV4dCkpO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIGdldFRyYW5zZm9ybWVycyhvcHRpb25zKSlcbiAgICByZXN1bHQgPSB0cmFuc2Zvcm1lci5wb3N0cHJvY2Vzcz8uY2FsbChjb250ZXh0LCByZXN1bHQsIG9wdGlvbnMpIHx8IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9GRyA9IHsgbGlnaHQ6IFwiIzMzMzMzM1wiLCBkYXJrOiBcIiNiYmJiYmJcIiB9O1xuY29uc3QgVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9CRyA9IHsgbGlnaHQ6IFwiI2ZmZmZmZVwiLCBkYXJrOiBcIiMxZTFlMWVcIiB9O1xuY29uc3QgUkVTT0xWRURfS0VZID0gXCJfX3NoaWtpX3Jlc29sdmVkXCI7XG5mdW5jdGlvbiBub3JtYWxpemVUaGVtZShyYXdUaGVtZSkge1xuICBpZiAocmF3VGhlbWU/LltSRVNPTFZFRF9LRVldKVxuICAgIHJldHVybiByYXdUaGVtZTtcbiAgY29uc3QgdGhlbWUgPSB7XG4gICAgLi4ucmF3VGhlbWVcbiAgfTtcbiAgaWYgKHRoZW1lLnRva2VuQ29sb3JzICYmICF0aGVtZS5zZXR0aW5ncykge1xuICAgIHRoZW1lLnNldHRpbmdzID0gdGhlbWUudG9rZW5Db2xvcnM7XG4gICAgZGVsZXRlIHRoZW1lLnRva2VuQ29sb3JzO1xuICB9XG4gIHRoZW1lLnR5cGUgfHw9IFwiZGFya1wiO1xuICB0aGVtZS5jb2xvclJlcGxhY2VtZW50cyA9IHsgLi4udGhlbWUuY29sb3JSZXBsYWNlbWVudHMgfTtcbiAgdGhlbWUuc2V0dGluZ3MgfHw9IFtdO1xuICBsZXQgeyBiZywgZmcgfSA9IHRoZW1lO1xuICBpZiAoIWJnIHx8ICFmZykge1xuICAgIGNvbnN0IGdsb2JhbFNldHRpbmcgPSB0aGVtZS5zZXR0aW5ncyA/IHRoZW1lLnNldHRpbmdzLmZpbmQoKHMpID0+ICFzLm5hbWUgJiYgIXMuc2NvcGUpIDogdm9pZCAwO1xuICAgIGlmIChnbG9iYWxTZXR0aW5nPy5zZXR0aW5ncz8uZm9yZWdyb3VuZClcbiAgICAgIGZnID0gZ2xvYmFsU2V0dGluZy5zZXR0aW5ncy5mb3JlZ3JvdW5kO1xuICAgIGlmIChnbG9iYWxTZXR0aW5nPy5zZXR0aW5ncz8uYmFja2dyb3VuZClcbiAgICAgIGJnID0gZ2xvYmFsU2V0dGluZy5zZXR0aW5ncy5iYWNrZ3JvdW5kO1xuICAgIGlmICghZmcgJiYgdGhlbWU/LmNvbG9ycz8uW1wiZWRpdG9yLmZvcmVncm91bmRcIl0pXG4gICAgICBmZyA9IHRoZW1lLmNvbG9yc1tcImVkaXRvci5mb3JlZ3JvdW5kXCJdO1xuICAgIGlmICghYmcgJiYgdGhlbWU/LmNvbG9ycz8uW1wiZWRpdG9yLmJhY2tncm91bmRcIl0pXG4gICAgICBiZyA9IHRoZW1lLmNvbG9yc1tcImVkaXRvci5iYWNrZ3JvdW5kXCJdO1xuICAgIGlmICghZmcpXG4gICAgICBmZyA9IHRoZW1lLnR5cGUgPT09IFwibGlnaHRcIiA/IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfRkcubGlnaHQgOiBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0ZHLmRhcms7XG4gICAgaWYgKCFiZylcbiAgICAgIGJnID0gdGhlbWUudHlwZSA9PT0gXCJsaWdodFwiID8gVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9CRy5saWdodCA6IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcuZGFyaztcbiAgICB0aGVtZS5mZyA9IGZnO1xuICAgIHRoZW1lLmJnID0gYmc7XG4gIH1cbiAgaWYgKCEodGhlbWUuc2V0dGluZ3NbMF0gJiYgdGhlbWUuc2V0dGluZ3NbMF0uc2V0dGluZ3MgJiYgIXRoZW1lLnNldHRpbmdzWzBdLnNjb3BlKSkge1xuICAgIHRoZW1lLnNldHRpbmdzLnVuc2hpZnQoe1xuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgZm9yZWdyb3VuZDogdGhlbWUuZmcsXG4gICAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmJnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlcGxhY2VtZW50Q291bnQgPSAwO1xuICBjb25zdCByZXBsYWNlbWVudE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGdldFJlcGxhY2VtZW50Q29sb3IodmFsdWUpIHtcbiAgICBpZiAocmVwbGFjZW1lbnRNYXAuaGFzKHZhbHVlKSlcbiAgICAgIHJldHVybiByZXBsYWNlbWVudE1hcC5nZXQodmFsdWUpO1xuICAgIHJlcGxhY2VtZW50Q291bnQgKz0gMTtcbiAgICBjb25zdCBoZXggPSBgIyR7cmVwbGFjZW1lbnRDb3VudC50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpLnRvTG93ZXJDYXNlKCl9YDtcbiAgICBpZiAodGhlbWUuY29sb3JSZXBsYWNlbWVudHM/LltgIyR7aGV4fWBdKVxuICAgICAgcmV0dXJuIGdldFJlcGxhY2VtZW50Q29sb3IodmFsdWUpO1xuICAgIHJlcGxhY2VtZW50TWFwLnNldCh2YWx1ZSwgaGV4KTtcbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIHRoZW1lLnNldHRpbmdzID0gdGhlbWUuc2V0dGluZ3MubWFwKChzZXR0aW5nKSA9PiB7XG4gICAgY29uc3QgcmVwbGFjZUZnID0gc2V0dGluZy5zZXR0aW5ncz8uZm9yZWdyb3VuZCAmJiAhc2V0dGluZy5zZXR0aW5ncy5mb3JlZ3JvdW5kLnN0YXJ0c1dpdGgoXCIjXCIpO1xuICAgIGNvbnN0IHJlcGxhY2VCZyA9IHNldHRpbmcuc2V0dGluZ3M/LmJhY2tncm91bmQgJiYgIXNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZC5zdGFydHNXaXRoKFwiI1wiKTtcbiAgICBpZiAoIXJlcGxhY2VGZyAmJiAhcmVwbGFjZUJnKVxuICAgICAgcmV0dXJuIHNldHRpbmc7XG4gICAgY29uc3QgY2xvbmUgPSB7XG4gICAgICAuLi5zZXR0aW5nLFxuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgLi4uc2V0dGluZy5zZXR0aW5nc1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHJlcGxhY2VGZykge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBnZXRSZXBsYWNlbWVudENvbG9yKHNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZCk7XG4gICAgICB0aGVtZS5jb2xvclJlcGxhY2VtZW50c1tyZXBsYWNlbWVudF0gPSBzZXR0aW5nLnNldHRpbmdzLmZvcmVncm91bmQ7XG4gICAgICBjbG9uZS5zZXR0aW5ncy5mb3JlZ3JvdW5kID0gcmVwbGFjZW1lbnQ7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlQmcpIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcihzZXR0aW5nLnNldHRpbmdzLmJhY2tncm91bmQpO1xuICAgICAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdID0gc2V0dGluZy5zZXR0aW5ncy5iYWNrZ3JvdW5kO1xuICAgICAgY2xvbmUuc2V0dGluZ3MuYmFja2dyb3VuZCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH0pO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGVtZS5jb2xvcnMgfHwge30pKSB7XG4gICAgaWYgKGtleSA9PT0gXCJlZGl0b3IuZm9yZWdyb3VuZFwiIHx8IGtleSA9PT0gXCJlZGl0b3IuYmFja2dyb3VuZFwiIHx8IGtleS5zdGFydHNXaXRoKFwidGVybWluYWwuYW5zaVwiKSkge1xuICAgICAgaWYgKCF0aGVtZS5jb2xvcnNba2V5XT8uc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBnZXRSZXBsYWNlbWVudENvbG9yKHRoZW1lLmNvbG9yc1trZXldKTtcbiAgICAgICAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdID0gdGhlbWUuY29sb3JzW2tleV07XG4gICAgICAgIHRoZW1lLmNvbG9yc1trZXldID0gcmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGVtZSwgUkVTT0xWRURfS0VZLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gdGhlbWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVMYW5ncyhsYW5ncykge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KChhd2FpdCBQcm9taXNlLmFsbChcbiAgICBsYW5ncy5maWx0ZXIoKGwpID0+ICFpc1NwZWNpYWxMYW5nKGwpKS5tYXAoYXN5bmMgKGxhbmcpID0+IGF3YWl0IG5vcm1hbGl6ZUdldHRlcihsYW5nKS50aGVuKChyKSA9PiBBcnJheS5pc0FycmF5KHIpID8gciA6IFtyXSkpXG4gICkpLmZsYXQoKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVRoZW1lcyh0aGVtZXMpIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0aGVtZXMubWFwKFxuICAgICAgYXN5bmMgKHRoZW1lKSA9PiBpc1NwZWNpYWxUaGVtZSh0aGVtZSkgPyBudWxsIDogbm9ybWFsaXplVGhlbWUoYXdhaXQgbm9ybWFsaXplR2V0dGVyKHRoZW1lKSlcbiAgICApXG4gICk7XG4gIHJldHVybiByZXNvbHZlZC5maWx0ZXIoKGkpID0+ICEhaSk7XG59XG5cbmxldCBfZW1pdERlcHJlY2F0aW9uID0gMztcbmxldCBfZW1pdEVycm9yID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVEZXByZWNhdGlvbldhcm5pbmdzKGVtaXREZXByZWNhdGlvbiA9IHRydWUsIGVtaXRFcnJvciA9IGZhbHNlKSB7XG4gIF9lbWl0RGVwcmVjYXRpb24gPSBlbWl0RGVwcmVjYXRpb247XG4gIF9lbWl0RXJyb3IgPSBlbWl0RXJyb3I7XG59XG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRlZChtZXNzYWdlLCB2ZXJzaW9uID0gMykge1xuICBpZiAoIV9lbWl0RGVwcmVjYXRpb24pXG4gICAgcmV0dXJuO1xuICBpZiAodHlwZW9mIF9lbWl0RGVwcmVjYXRpb24gPT09IFwibnVtYmVyXCIgJiYgdmVyc2lvbiA+IF9lbWl0RGVwcmVjYXRpb24pXG4gICAgcmV0dXJuO1xuICBpZiAoX2VtaXRFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgW1NISUtJIERFUFJFQ0FURV06ICR7bWVzc2FnZX1gKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLnRyYWNlKGBbU0hJS0kgREVQUkVDQVRFXTogJHttZXNzYWdlfWApO1xuICB9XG59XG5cbmNsYXNzIFNoaWtpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNoaWtpRXJyb3JcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTGFuZ0FsaWFzKG5hbWUsIGFsaWFzKSB7XG4gIGlmICghYWxpYXMpXG4gICAgcmV0dXJuIG5hbWU7XG4gIGlmIChhbGlhc1tuYW1lXSkge1xuICAgIGNvbnN0IHJlc29sdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW25hbWVdKTtcbiAgICB3aGlsZSAoYWxpYXNbbmFtZV0pIHtcbiAgICAgIG5hbWUgPSBhbGlhc1tuYW1lXTtcbiAgICAgIGlmIChyZXNvbHZlZC5oYXMobmFtZSkpXG4gICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBDaXJjdWxhciBhbGlhcyBcXGAke0FycmF5LmZyb20ocmVzb2x2ZWQpLmpvaW4oXCIgLT4gXCIpfSAtPiAke25hbWV9XFxgYCk7XG4gICAgICByZXNvbHZlZC5hZGQobmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYW1lO1xufVxuXG5jbGFzcyBSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5JDEge1xuICBjb25zdHJ1Y3RvcihfcmVzb2x2ZXIsIF90aGVtZXMsIF9sYW5ncywgX2FsaWFzID0ge30pIHtcbiAgICBzdXBlcihfcmVzb2x2ZXIpO1xuICAgIHRoaXMuX3Jlc29sdmVyID0gX3Jlc29sdmVyO1xuICAgIHRoaXMuX3RoZW1lcyA9IF90aGVtZXM7XG4gICAgdGhpcy5fbGFuZ3MgPSBfbGFuZ3M7XG4gICAgdGhpcy5fYWxpYXMgPSBfYWxpYXM7XG4gICAgdGhpcy5fdGhlbWVzLm1hcCgodCkgPT4gdGhpcy5sb2FkVGhlbWUodCkpO1xuICAgIHRoaXMubG9hZExhbmd1YWdlcyh0aGlzLl9sYW5ncyk7XG4gIH1cbiAgX3Jlc29sdmVkVGhlbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3Jlc29sdmVkR3JhbW1hcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfbGFuZ01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9sYW5nR3JhcGggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfdGV4dG1hdGVUaGVtZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIF9sb2FkZWRUaGVtZXNDYWNoZSA9IG51bGw7XG4gIF9sb2FkZWRMYW5ndWFnZXNDYWNoZSA9IG51bGw7XG4gIGdldFRoZW1lKHRoZW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZFRoZW1lcy5nZXQodGhlbWUpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmxvYWRUaGVtZSh0aGVtZSk7XG4gIH1cbiAgbG9hZFRoZW1lKHRoZW1lKSB7XG4gICAgY29uc3QgX3RoZW1lID0gbm9ybWFsaXplVGhlbWUodGhlbWUpO1xuICAgIGlmIChfdGhlbWUubmFtZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZWRUaGVtZXMuc2V0KF90aGVtZS5uYW1lLCBfdGhlbWUpO1xuICAgICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3RoZW1lO1xuICB9XG4gIGdldExvYWRlZFRoZW1lcygpIHtcbiAgICBpZiAoIXRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlKVxuICAgICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBbLi4udGhpcy5fcmVzb2x2ZWRUaGVtZXMua2V5cygpXTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGU7XG4gIH1cbiAgLy8gT3ZlcnJpZGUgYW5kIHJlLWltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBjYWNoZSB0aGUgdGV4dG1hdGUgdGhlbWVzIGFzIGBUZXh0TWF0ZVRoZW1lLmNyZWF0ZUZyb21SYXdUaGVtZWBcbiAgLy8gaXMgZXhwZW5zaXZlLiBUaGVtZXMgY2FuIHN3aXRjaCBvZnRlbiBlc3BlY2lhbGx5IGZvciBkdWFsLXRoZW1lIHN1cHBvcnQuXG4gIC8vXG4gIC8vIFRoZSBwYXJlbnQgY2xhc3MgYWxzbyBhY2NlcHRzIGBjb2xvck1hcGAgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIsIGJ1dCBzaW5jZSB3ZSBkb24ndCB1c2UgdGhhdCxcbiAgLy8gd2Ugb21pdCBoZXJlIHNvIGl0J3MgZWFzaWVyIHRvIGNhY2hlIHRoZSB0aGVtZXMuXG4gIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgbGV0IHRleHRtYXRlVGhlbWUgPSB0aGlzLl90ZXh0bWF0ZVRoZW1lQ2FjaGUuZ2V0KHRoZW1lKTtcbiAgICBpZiAoIXRleHRtYXRlVGhlbWUpIHtcbiAgICAgIHRleHRtYXRlVGhlbWUgPSBUaGVtZS5jcmVhdGVGcm9tUmF3VGhlbWUodGhlbWUpO1xuICAgICAgdGhpcy5fdGV4dG1hdGVUaGVtZUNhY2hlLnNldCh0aGVtZSwgdGV4dG1hdGVUaGVtZSk7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5zZXRUaGVtZSh0ZXh0bWF0ZVRoZW1lKTtcbiAgfVxuICBnZXRHcmFtbWFyKG5hbWUpIHtcbiAgICBuYW1lID0gcmVzb2x2ZUxhbmdBbGlhcyhuYW1lLCB0aGlzLl9hbGlhcyk7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuZ2V0KG5hbWUpO1xuICB9XG4gIGxvYWRMYW5ndWFnZShsYW5nKSB7XG4gICAgaWYgKHRoaXMuZ2V0R3JhbW1hcihsYW5nLm5hbWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVtYmVkZGVkTGF6aWx5QnkgPSBuZXcgU2V0KFxuICAgICAgWy4uLnRoaXMuX2xhbmdNYXAudmFsdWVzKCldLmZpbHRlcigoaSkgPT4gaS5lbWJlZGRlZExhbmdzTGF6eT8uaW5jbHVkZXMobGFuZy5uYW1lKSlcbiAgICApO1xuICAgIHRoaXMuX3Jlc29sdmVyLmFkZExhbmd1YWdlKGxhbmcpO1xuICAgIGNvbnN0IGdyYW1tYXJDb25maWcgPSB7XG4gICAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnM6IGxhbmcuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtcIipcIl0sXG4gICAgICB1bmJhbGFuY2VkQnJhY2tldFNlbGVjdG9yczogbGFuZy51bmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyB8fCBbXVxuICAgIH07XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5Ll9yYXdHcmFtbWFycy5zZXQobGFuZy5zY29wZU5hbWUsIGxhbmcpO1xuICAgIGNvbnN0IGcgPSB0aGlzLmxvYWRHcmFtbWFyV2l0aENvbmZpZ3VyYXRpb24obGFuZy5zY29wZU5hbWUsIDEsIGdyYW1tYXJDb25maWcpO1xuICAgIGcubmFtZSA9IGxhbmcubmFtZTtcbiAgICB0aGlzLl9yZXNvbHZlZEdyYW1tYXJzLnNldChsYW5nLm5hbWUsIGcpO1xuICAgIGlmIChsYW5nLmFsaWFzZXMpIHtcbiAgICAgIGxhbmcuYWxpYXNlcy5mb3JFYWNoKChhbGlhcykgPT4ge1xuICAgICAgICB0aGlzLl9hbGlhc1thbGlhc10gPSBsYW5nLm5hbWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBudWxsO1xuICAgIGlmIChlbWJlZGRlZExhemlseUJ5LnNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgZSBvZiBlbWJlZGRlZExhemlseUJ5KSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuZGVsZXRlKGUubmFtZSk7XG4gICAgICAgIHRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3luY1JlZ2lzdHJ5Py5faW5qZWN0aW9uR3JhbW1hcnM/LmRlbGV0ZShlLnNjb3BlTmFtZSk7XG4gICAgICAgIHRoaXMuX3N5bmNSZWdpc3RyeT8uX2dyYW1tYXJzPy5kZWxldGUoZS5zY29wZU5hbWUpO1xuICAgICAgICB0aGlzLmxvYWRMYW5ndWFnZSh0aGlzLl9sYW5nTWFwLmdldChlLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5fcmVzb2x2ZWRUaGVtZXMuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlZEdyYW1tYXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fbGFuZ01hcC5jbGVhcigpO1xuICAgIHRoaXMuX2xhbmdHcmFwaC5jbGVhcigpO1xuICAgIHRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlID0gbnVsbDtcbiAgfVxuICBsb2FkTGFuZ3VhZ2VzKGxhbmdzKSB7XG4gICAgZm9yIChjb25zdCBsYW5nIG9mIGxhbmdzKVxuICAgICAgdGhpcy5yZXNvbHZlRW1iZWRkZWRMYW5ndWFnZXMobGFuZyk7XG4gICAgY29uc3QgbGFuZ3NHcmFwaEFycmF5ID0gQXJyYXkuZnJvbSh0aGlzLl9sYW5nR3JhcGguZW50cmllcygpKTtcbiAgICBjb25zdCBtaXNzaW5nTGFuZ3MgPSBsYW5nc0dyYXBoQXJyYXkuZmlsdGVyKChbXywgbGFuZ10pID0+ICFsYW5nKTtcbiAgICBpZiAobWlzc2luZ0xhbmdzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZGVwZW5kZW50cyA9IGxhbmdzR3JhcGhBcnJheS5maWx0ZXIoKFtfLCBsYW5nXSkgPT4ge1xuICAgICAgICBpZiAoIWxhbmcpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlbWJlZGRlZCA9IGxhbmcuZW1iZWRkZWRMYW5ndWFnZXMgfHwgbGFuZy5lbWJlZGRlZExhbmdzO1xuICAgICAgICByZXR1cm4gZW1iZWRkZWQ/LnNvbWUoKGwpID0+IG1pc3NpbmdMYW5ncy5tYXAoKFtuYW1lXSkgPT4gbmFtZSkuaW5jbHVkZXMobCkpO1xuICAgICAgfSkuZmlsdGVyKChsYW5nKSA9PiAhbWlzc2luZ0xhbmdzLmluY2x1ZGVzKGxhbmcpKTtcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBNaXNzaW5nIGxhbmd1YWdlcyAke21pc3NpbmdMYW5ncy5tYXAoKFtuYW1lXSkgPT4gYFxcYCR7bmFtZX1cXGBgKS5qb2luKFwiLCBcIil9LCByZXF1aXJlZCBieSAke2RlcGVuZGVudHMubWFwKChbbmFtZV0pID0+IGBcXGAke25hbWV9XFxgYCkuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtfLCBsYW5nXSBvZiBsYW5nc0dyYXBoQXJyYXkpXG4gICAgICB0aGlzLl9yZXNvbHZlci5hZGRMYW5ndWFnZShsYW5nKTtcbiAgICBmb3IgKGNvbnN0IFtfLCBsYW5nXSBvZiBsYW5nc0dyYXBoQXJyYXkpXG4gICAgICB0aGlzLmxvYWRMYW5ndWFnZShsYW5nKTtcbiAgfVxuICBnZXRMb2FkZWRMYW5ndWFnZXMoKSB7XG4gICAgaWYgKCF0aGlzLl9sb2FkZWRMYW5ndWFnZXNDYWNoZSkge1xuICAgICAgdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBbXG4gICAgICAgIC4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi50aGlzLl9yZXNvbHZlZEdyYW1tYXJzLmtleXMoKSwgLi4uT2JqZWN0LmtleXModGhpcy5fYWxpYXMpXSlcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb2FkZWRMYW5ndWFnZXNDYWNoZTtcbiAgfVxuICByZXNvbHZlRW1iZWRkZWRMYW5ndWFnZXMobGFuZykge1xuICAgIHRoaXMuX2xhbmdNYXAuc2V0KGxhbmcubmFtZSwgbGFuZyk7XG4gICAgdGhpcy5fbGFuZ0dyYXBoLnNldChsYW5nLm5hbWUsIGxhbmcpO1xuICAgIGNvbnN0IGVtYmVkZGVkID0gbGFuZy5lbWJlZGRlZExhbmd1YWdlcyA/PyBsYW5nLmVtYmVkZGVkTGFuZ3M7XG4gICAgaWYgKGVtYmVkZGVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGVtYmVkZGVkTGFuZyBvZiBlbWJlZGRlZClcbiAgICAgICAgdGhpcy5fbGFuZ0dyYXBoLnNldChlbWJlZGRlZExhbmcsIHRoaXMuX2xhbmdNYXAuZ2V0KGVtYmVkZGVkTGFuZykpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZXNvbHZlciB7XG4gIF9sYW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9zY29wZVRvTGFuZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9pbmplY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX29uaWdMaWI7XG4gIGNvbnN0cnVjdG9yKGVuZ2luZSwgbGFuZ3MpIHtcbiAgICB0aGlzLl9vbmlnTGliID0ge1xuICAgICAgY3JlYXRlT25pZ1NjYW5uZXI6IChwYXR0ZXJucykgPT4gZW5naW5lLmNyZWF0ZVNjYW5uZXIocGF0dGVybnMpLFxuICAgICAgY3JlYXRlT25pZ1N0cmluZzogKHMpID0+IGVuZ2luZS5jcmVhdGVTdHJpbmcocylcbiAgICB9O1xuICAgIGxhbmdzLmZvckVhY2goKGkpID0+IHRoaXMuYWRkTGFuZ3VhZ2UoaSkpO1xuICB9XG4gIGdldCBvbmlnTGliKCkge1xuICAgIHJldHVybiB0aGlzLl9vbmlnTGliO1xuICB9XG4gIGdldExhbmdSZWdpc3RyYXRpb24obGFuZ0lkT3JBbGlhcykge1xuICAgIHJldHVybiB0aGlzLl9sYW5ncy5nZXQobGFuZ0lkT3JBbGlhcyk7XG4gIH1cbiAgbG9hZEdyYW1tYXIoc2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njb3BlVG9MYW5nLmdldChzY29wZU5hbWUpO1xuICB9XG4gIGFkZExhbmd1YWdlKGwpIHtcbiAgICB0aGlzLl9sYW5ncy5zZXQobC5uYW1lLCBsKTtcbiAgICBpZiAobC5hbGlhc2VzKSB7XG4gICAgICBsLmFsaWFzZXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICB0aGlzLl9sYW5ncy5zZXQoYSwgbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fc2NvcGVUb0xhbmcuc2V0KGwuc2NvcGVOYW1lLCBsKTtcbiAgICBpZiAobC5pbmplY3RUbykge1xuICAgICAgbC5pbmplY3RUby5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5faW5qZWN0aW9ucy5nZXQoaSkpXG4gICAgICAgICAgdGhpcy5faW5qZWN0aW9ucy5zZXQoaSwgW10pO1xuICAgICAgICB0aGlzLl9pbmplY3Rpb25zLmdldChpKS5wdXNoKGwuc2NvcGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRJbmplY3Rpb25zKHNjb3BlTmFtZSkge1xuICAgIGNvbnN0IHNjb3BlUGFydHMgPSBzY29wZU5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIGxldCBpbmplY3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc2NvcGVQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViU2NvcGVOYW1lID0gc2NvcGVQYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiLlwiKTtcbiAgICAgIGluamVjdGlvbnMgPSBbLi4uaW5qZWN0aW9ucywgLi4udGhpcy5faW5qZWN0aW9ucy5nZXQoc3ViU2NvcGVOYW1lKSB8fCBbXV07XG4gICAgfVxuICAgIHJldHVybiBpbmplY3Rpb25zO1xuICB9XG59XG5cbmxldCBpbnN0YW5jZXNDb3VudCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVTaGlraUludGVybmFsU3luYyhvcHRpb25zKSB7XG4gIGluc3RhbmNlc0NvdW50ICs9IDE7XG4gIGlmIChvcHRpb25zLndhcm5pbmdzICE9PSBmYWxzZSAmJiBpbnN0YW5jZXNDb3VudCA+PSAxMCAmJiBpbnN0YW5jZXNDb3VudCAlIDEwID09PSAwKVxuICAgIGNvbnNvbGUud2FybihgW1NoaWtpXSAke2luc3RhbmNlc0NvdW50fSBpbnN0YW5jZXMgaGF2ZSBiZWVuIGNyZWF0ZWQuIFNoaWtpIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgYXMgYSBzaW5nbGV0b24sIGNvbnNpZGVyIHJlZmFjdG9yaW5nIHlvdXIgY29kZSB0byBjYWNoZSB5b3VyIGhpZ2hsaWdodGVyIGluc3RhbmNlOyBPciBjYWxsIFxcYGhpZ2hsaWdodGVyLmRpc3Bvc2UoKVxcYCB0byByZWxlYXNlIHVudXNlZCBpbnN0YW5jZXMuYCk7XG4gIGxldCBpc0Rpc3Bvc2VkID0gZmFsc2U7XG4gIGlmICghb3B0aW9ucy5lbmdpbmUpXG4gICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoXCJgZW5naW5lYCBvcHRpb24gaXMgcmVxdWlyZWQgZm9yIHN5bmNocm9ub3VzIG1vZGVcIik7XG4gIGNvbnN0IGxhbmdzID0gKG9wdGlvbnMubGFuZ3MgfHwgW10pLmZsYXQoMSk7XG4gIGNvbnN0IHRoZW1lcyA9IChvcHRpb25zLnRoZW1lcyB8fCBbXSkuZmxhdCgxKS5tYXAobm9ybWFsaXplVGhlbWUpO1xuICBjb25zdCByZXNvbHZlciA9IG5ldyBSZXNvbHZlcihvcHRpb25zLmVuZ2luZSwgbGFuZ3MpO1xuICBjb25zdCBfcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkocmVzb2x2ZXIsIHRoZW1lcywgbGFuZ3MsIG9wdGlvbnMubGFuZ0FsaWFzKTtcbiAgbGV0IF9sYXN0VGhlbWU7XG4gIGZ1bmN0aW9uIHJlc29sdmVMYW5nQWxpYXMkMShuYW1lKSB7XG4gICAgcmV0dXJuIHJlc29sdmVMYW5nQWxpYXMobmFtZSwgb3B0aW9ucy5sYW5nQWxpYXMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldExhbmd1YWdlKG5hbWUpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIGNvbnN0IF9sYW5nID0gX3JlZ2lzdHJ5LmdldEdyYW1tYXIodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgPyBuYW1lIDogbmFtZS5uYW1lKTtcbiAgICBpZiAoIV9sYW5nKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoYExhbmd1YWdlIFxcYCR7bmFtZX1cXGAgbm90IGZvdW5kLCB5b3UgbWF5IG5lZWQgdG8gbG9hZCBpdCBmaXJzdGApO1xuICAgIHJldHVybiBfbGFuZztcbiAgfVxuICBmdW5jdGlvbiBnZXRUaGVtZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IFwibm9uZVwiKVxuICAgICAgcmV0dXJuIHsgYmc6IFwiXCIsIGZnOiBcIlwiLCBuYW1lOiBcIm5vbmVcIiwgc2V0dGluZ3M6IFtdLCB0eXBlOiBcImRhcmtcIiB9O1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgY29uc3QgX3RoZW1lID0gX3JlZ2lzdHJ5LmdldFRoZW1lKG5hbWUpO1xuICAgIGlmICghX3RoZW1lKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoYFRoZW1lIFxcYCR7bmFtZX1cXGAgbm90IGZvdW5kLCB5b3UgbWF5IG5lZWQgdG8gbG9hZCBpdCBmaXJzdGApO1xuICAgIHJldHVybiBfdGhlbWU7XG4gIH1cbiAgZnVuY3Rpb24gc2V0VGhlbWUobmFtZSkge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgY29uc3QgdGhlbWUgPSBnZXRUaGVtZShuYW1lKTtcbiAgICBpZiAoX2xhc3RUaGVtZSAhPT0gbmFtZSkge1xuICAgICAgX3JlZ2lzdHJ5LnNldFRoZW1lKHRoZW1lKTtcbiAgICAgIF9sYXN0VGhlbWUgPSBuYW1lO1xuICAgIH1cbiAgICBjb25zdCBjb2xvck1hcCA9IF9yZWdpc3RyeS5nZXRDb2xvck1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0aGVtZSxcbiAgICAgIGNvbG9yTWFwXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRMb2FkZWRUaGVtZXMoKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICByZXR1cm4gX3JlZ2lzdHJ5LmdldExvYWRlZFRoZW1lcygpO1xuICB9XG4gIGZ1bmN0aW9uIGdldExvYWRlZExhbmd1YWdlcygpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIHJldHVybiBfcmVnaXN0cnkuZ2V0TG9hZGVkTGFuZ3VhZ2VzKCk7XG4gIH1cbiAgZnVuY3Rpb24gbG9hZExhbmd1YWdlU3luYyguLi5sYW5nczIpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIF9yZWdpc3RyeS5sb2FkTGFuZ3VhZ2VzKGxhbmdzMi5mbGF0KDEpKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2UoLi4ubGFuZ3MyKSB7XG4gICAgcmV0dXJuIGxvYWRMYW5ndWFnZVN5bmMoYXdhaXQgcmVzb2x2ZUxhbmdzKGxhbmdzMikpO1xuICB9XG4gIGZ1bmN0aW9uIGxvYWRUaGVtZVN5bmMoLi4udGhlbWVzMikge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgZm9yIChjb25zdCB0aGVtZSBvZiB0aGVtZXMyLmZsYXQoMSkpIHtcbiAgICAgIF9yZWdpc3RyeS5sb2FkVGhlbWUodGhlbWUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkVGhlbWUoLi4udGhlbWVzMikge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIGxvYWRUaGVtZVN5bmMoYXdhaXQgcmVzb2x2ZVRoZW1lcyh0aGVtZXMyKSk7XG4gIH1cbiAgZnVuY3Rpb24gZW5zdXJlTm90RGlzcG9zZWQoKSB7XG4gICAgaWYgKGlzRGlzcG9zZWQpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihcIlNoaWtpIGluc3RhbmNlIGhhcyBiZWVuIGRpc3Bvc2VkXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKGlzRGlzcG9zZWQpXG4gICAgICByZXR1cm47XG4gICAgaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgX3JlZ2lzdHJ5LmRpc3Bvc2UoKTtcbiAgICBpbnN0YW5jZXNDb3VudCAtPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2V0VGhlbWUsXG4gICAgZ2V0VGhlbWUsXG4gICAgZ2V0TGFuZ3VhZ2UsXG4gICAgZ2V0TG9hZGVkVGhlbWVzLFxuICAgIGdldExvYWRlZExhbmd1YWdlcyxcbiAgICByZXNvbHZlTGFuZ0FsaWFzOiByZXNvbHZlTGFuZ0FsaWFzJDEsXG4gICAgbG9hZExhbmd1YWdlLFxuICAgIGxvYWRMYW5ndWFnZVN5bmMsXG4gICAgbG9hZFRoZW1lLFxuICAgIGxvYWRUaGVtZVN5bmMsXG4gICAgZGlzcG9zZSxcbiAgICBbU3ltYm9sLmRpc3Bvc2VdOiBkaXNwb3NlXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNoaWtpSW50ZXJuYWwob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMuZW5naW5lKSB7XG4gICAgd2FybkRlcHJlY2F0ZWQoXCJgZW5naW5lYCBvcHRpb24gaXMgcmVxdWlyZWQuIFVzZSBgY3JlYXRlT25pZ3VydW1hRW5naW5lYCBvciBgY3JlYXRlSmF2YVNjcmlwdFJlZ2V4RW5naW5lYCB0byBjcmVhdGUgYW4gZW5naW5lLlwiKTtcbiAgfVxuICBjb25zdCBbXG4gICAgdGhlbWVzLFxuICAgIGxhbmdzLFxuICAgIGVuZ2luZVxuICBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIHJlc29sdmVUaGVtZXMob3B0aW9ucy50aGVtZXMgfHwgW10pLFxuICAgIHJlc29sdmVMYW5ncyhvcHRpb25zLmxhbmdzIHx8IFtdKSxcbiAgICBvcHRpb25zLmVuZ2luZVxuICBdKTtcbiAgcmV0dXJuIGNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRoZW1lcyxcbiAgICBsYW5ncyxcbiAgICBlbmdpbmVcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZShvcHRpb25zKSB7XG4gIGNvbnN0IGludGVybmFsID0gYXdhaXQgY3JlYXRlU2hpa2lJbnRlcm5hbChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBnZXRMYXN0R3JhbW1hclN0YXRlOiAoLi4uYXJncykgPT4gZ2V0TGFzdEdyYW1tYXJTdGF0ZShpbnRlcm5hbCwgLi4uYXJncyksXG4gICAgY29kZVRvVG9rZW5zQmFzZTogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnNCYXNlKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvVG9rZW5zV2l0aFRoZW1lczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvVG9rZW5zOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb0hhc3Q6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb0h0bWw6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvSHRtbChpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGdldEJ1bmRsZWRMYW5ndWFnZXM6ICgpID0+ICh7fSksXG4gICAgZ2V0QnVuZGxlZFRoZW1lczogKCkgPT4gKHt9KSxcbiAgICAuLi5pbnRlcm5hbCxcbiAgICBnZXRJbnRlcm5hbENvbnRleHQ6ICgpID0+IGludGVybmFsXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIaWdobGlnaHRlckNvcmVTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3QgaW50ZXJuYWwgPSBjcmVhdGVTaGlraUludGVybmFsU3luYyhvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBnZXRMYXN0R3JhbW1hclN0YXRlOiAoLi4uYXJncykgPT4gZ2V0TGFzdEdyYW1tYXJTdGF0ZShpbnRlcm5hbCwgLi4uYXJncyksXG4gICAgY29kZVRvVG9rZW5zQmFzZTogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnNCYXNlKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvVG9rZW5zV2l0aFRoZW1lczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvVG9rZW5zOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb0hhc3Q6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb0h0bWw6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvSHRtbChpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGdldEJ1bmRsZWRMYW5ndWFnZXM6ICgpID0+ICh7fSksXG4gICAgZ2V0QnVuZGxlZFRoZW1lczogKCkgPT4gKHt9KSxcbiAgICAuLi5pbnRlcm5hbCxcbiAgICBnZXRJbnRlcm5hbENvbnRleHQ6ICgpID0+IGludGVybmFsXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlKGNyZWF0ZUhpZ2hsaWdodGVyKSB7XG4gIGxldCBfc2hpa2k7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZTIob3B0aW9ucykge1xuICAgIGlmICghX3NoaWtpKSB7XG4gICAgICBfc2hpa2kgPSBjcmVhdGVIaWdobGlnaHRlcih7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRoZW1lczogb3B0aW9ucy50aGVtZXMgfHwgW10sXG4gICAgICAgIGxhbmdzOiBvcHRpb25zLmxhbmdzIHx8IFtdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfc2hpa2k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCBfc2hpa2k7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHMubG9hZFRoZW1lKC4uLm9wdGlvbnMudGhlbWVzIHx8IFtdKSxcbiAgICAgICAgcy5sb2FkTGFuZ3VhZ2UoLi4ub3B0aW9ucy5sYW5ncyB8fCBbXSlcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRTaW5nbGV0b25IaWdobGlnaHRlckNvcmUyO1xufVxuY29uc3QgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlID0gLyogQF9fUFVSRV9fICovIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlckNvcmUoY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlKTtcblxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlZEhpZ2hsaWdodGVyKG9wdGlvbnMpIHtcbiAgY29uc3QgYnVuZGxlZExhbmd1YWdlcyA9IG9wdGlvbnMubGFuZ3M7XG4gIGNvbnN0IGJ1bmRsZWRUaGVtZXMgPSBvcHRpb25zLnRoZW1lcztcbiAgY29uc3QgZW5naW5lID0gb3B0aW9ucy5lbmdpbmU7XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodGVyKG9wdGlvbnMyKSB7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUxhbmcobGFuZykge1xuICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxhbmcgPSBvcHRpb25zMi5sYW5nQWxpYXM/LltsYW5nXSB8fCBsYW5nO1xuICAgICAgICBpZiAoaXNTcGVjaWFsTGFuZyhsYW5nKSlcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IGJ1bmRsZWRMYW5ndWFnZXNbbGFuZ107XG4gICAgICAgIGlmICghYnVuZGxlKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYExhbmd1YWdlIFxcYCR7bGFuZ31cXGAgaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYnVuZGxlLiBZb3UgbWF5IHdhbnQgdG8gbG9hZCBpdCBmcm9tIGV4dGVybmFsIHNvdXJjZS5gKTtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlVGhlbWUodGhlbWUpIHtcbiAgICAgIGlmIChpc1NwZWNpYWxUaGVtZSh0aGVtZSkpXG4gICAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICAgIGlmICh0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gYnVuZGxlZFRoZW1lc1t0aGVtZV07XG4gICAgICAgIGlmICghYnVuZGxlKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYFRoZW1lIFxcYCR7dGhlbWV9XFxgIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGJ1bmRsZS4gWW91IG1heSB3YW50IHRvIGxvYWQgaXQgZnJvbSBleHRlcm5hbCBzb3VyY2UuYCk7XG4gICAgICAgIHJldHVybiBidW5kbGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhlbWU7XG4gICAgfVxuICAgIGNvbnN0IF90aGVtZXMgPSAob3B0aW9uczIudGhlbWVzID8/IFtdKS5tYXAoKGkpID0+IHJlc29sdmVUaGVtZShpKSk7XG4gICAgY29uc3QgbGFuZ3MgPSAob3B0aW9uczIubGFuZ3MgPz8gW10pLm1hcCgoaSkgPT4gcmVzb2x2ZUxhbmcoaSkpO1xuICAgIGNvbnN0IGNvcmUgPSBhd2FpdCBjcmVhdGVIaWdobGlnaHRlckNvcmUoe1xuICAgICAgZW5naW5lOiBvcHRpb25zMi5lbmdpbmUgPz8gZW5naW5lKCksXG4gICAgICAuLi5vcHRpb25zMixcbiAgICAgIHRoZW1lczogX3RoZW1lcyxcbiAgICAgIGxhbmdzXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvcmUsXG4gICAgICBsb2FkTGFuZ3VhZ2UoLi4ubGFuZ3MyKSB7XG4gICAgICAgIHJldHVybiBjb3JlLmxvYWRMYW5ndWFnZSguLi5sYW5nczIubWFwKHJlc29sdmVMYW5nKSk7XG4gICAgICB9LFxuICAgICAgbG9hZFRoZW1lKC4uLnRoZW1lcykge1xuICAgICAgICByZXR1cm4gY29yZS5sb2FkVGhlbWUoLi4udGhlbWVzLm1hcChyZXNvbHZlVGhlbWUpKTtcbiAgICAgIH0sXG4gICAgICBnZXRCdW5kbGVkTGFuZ3VhZ2VzKCkge1xuICAgICAgICByZXR1cm4gYnVuZGxlZExhbmd1YWdlcztcbiAgICAgIH0sXG4gICAgICBnZXRCdW5kbGVkVGhlbWVzKCkge1xuICAgICAgICByZXR1cm4gYnVuZGxlZFRoZW1lcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVIaWdobGlnaHRlcjtcbn1cbmZ1bmN0aW9uIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlcihjcmVhdGVIaWdobGlnaHRlcikge1xuICBsZXQgX3NoaWtpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRTaW5nbGV0b25IaWdobGlnaHRlcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIV9zaGlraSkge1xuICAgICAgX3NoaWtpID0gY3JlYXRlSGlnaGxpZ2h0ZXIoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0aGVtZXM6IFtdLFxuICAgICAgICBsYW5nczogW11cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcyA9IGF3YWl0IF9zaGlraTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgcy5sb2FkVGhlbWUoLi4ub3B0aW9ucy50aGVtZXMgfHwgW10pLFxuICAgICAgICBzLmxvYWRMYW5ndWFnZSguLi5vcHRpb25zLmxhbmdzIHx8IFtdKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcyA9IGF3YWl0IF9zaGlraTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgcy5sb2FkVGhlbWUoLi4ub3B0aW9ucy50aGVtZXMgfHwgW10pLFxuICAgICAgICBzLmxvYWRMYW5ndWFnZSguLi5vcHRpb25zLmxhbmdzIHx8IFtdKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uU2hvcnRoYW5kcyhjcmVhdGVIaWdobGlnaHRlciwgY29uZmlnKSB7XG4gIGNvbnN0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyID0gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyKGNyZWF0ZUhpZ2hsaWdodGVyKTtcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0KGNvZGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKHtcbiAgICAgIGxhbmdzOiBbb3B0aW9ucy5sYW5nXSxcbiAgICAgIHRoZW1lczogXCJ0aGVtZVwiIGluIG9wdGlvbnMgPyBbb3B0aW9ucy50aGVtZV0gOiBPYmplY3QudmFsdWVzKG9wdGlvbnMudGhlbWVzKVxuICAgIH0pO1xuICAgIGNvbnN0IGxhbmdzID0gYXdhaXQgY29uZmlnPy5ndWVzc0VtYmVkZGVkTGFuZ3VhZ2VzPy4oY29kZSwgb3B0aW9ucy5sYW5nLCBzaGlraSk7XG4gICAgaWYgKGxhbmdzKSB7XG4gICAgICBhd2FpdCBzaGlraS5sb2FkTGFuZ3VhZ2UoLi4ubGFuZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gc2hpa2k7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTaW5nbGV0b25IaWdobGlnaHRlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIob3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9IdG1sKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0KGNvZGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb0h0bWwoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9IYXN0KGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0KGNvZGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb0hhc3QoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9Ub2tlbnMoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXQoY29kZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvVG9rZW5zKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvVG9rZW5zQmFzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldChjb2RlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9Ub2tlbnNCYXNlKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldChjb2RlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgZ2V0TGFzdEdyYW1tYXJTdGF0ZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKHtcbiAgICAgICAgbGFuZ3M6IFtvcHRpb25zLmxhbmddLFxuICAgICAgICB0aGVtZXM6IFtvcHRpb25zLnRoZW1lXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2hpa2kuZ2V0TGFzdEdyYW1tYXJTdGF0ZShjb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBjcmVhdGVkQnVuZGxlZEhpZ2hsaWdodGVyID0gY3JlYXRlQnVuZGxlZEhpZ2hsaWdodGVyO1xuXG5mdW5jdGlvbiBjcmVhdGVDc3NWYXJpYWJsZXNUaGVtZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcImNzcy12YXJpYWJsZXNcIixcbiAgICB2YXJpYWJsZVByZWZpeCA9IFwiLS1zaGlraS1cIixcbiAgICBmb250U3R5bGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB2YXJpYWJsZSA9IChuYW1lMikgPT4ge1xuICAgIGlmIChvcHRpb25zLnZhcmlhYmxlRGVmYXVsdHM/LltuYW1lMl0pXG4gICAgICByZXR1cm4gYHZhcigke3ZhcmlhYmxlUHJlZml4fSR7bmFtZTJ9LCAke29wdGlvbnMudmFyaWFibGVEZWZhdWx0c1tuYW1lMl19KWA7XG4gICAgcmV0dXJuIGB2YXIoJHt2YXJpYWJsZVByZWZpeH0ke25hbWUyfSlgO1xuICB9O1xuICBjb25zdCB0aGVtZSA9IHtcbiAgICBuYW1lLFxuICAgIHR5cGU6IFwiZGFya1wiLFxuICAgIGNvbG9yczoge1xuICAgICAgXCJlZGl0b3IuZm9yZWdyb3VuZFwiOiB2YXJpYWJsZShcImZvcmVncm91bmRcIiksXG4gICAgICBcImVkaXRvci5iYWNrZ3JvdW5kXCI6IHZhcmlhYmxlKFwiYmFja2dyb3VuZFwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJsYWNrXCI6IHZhcmlhYmxlKFwiYW5zaS1ibGFja1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaVJlZFwiOiB2YXJpYWJsZShcImFuc2ktcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpR3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWdyZWVuXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpWWVsbG93XCI6IHZhcmlhYmxlKFwiYW5zaS15ZWxsb3dcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCbHVlXCI6IHZhcmlhYmxlKFwiYW5zaS1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpTWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktbWFnZW50YVwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUN5YW5cIjogdmFyaWFibGUoXCJhbnNpLWN5YW5cIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lXaGl0ZVwiOiB2YXJpYWJsZShcImFuc2ktd2hpdGVcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRCbGFja1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LWJsYWNrXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0UmVkXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0R3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ncmVlblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFllbGxvd1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LXllbGxvd1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodEJsdWVcIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0TWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LW1hZ2VudGFcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRDeWFuXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtY3lhblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFdoaXRlXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtd2hpdGVcIilcbiAgICB9LFxuICAgIHRva2VuQ29sb3JzOiBbXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkLm9wZXJhdG9yLmFjY2Vzc29yXCIsXG4gICAgICAgICAgXCJtZXRhLmdyb3VwLmJyYWNlcy5yb3VuZC5mdW5jdGlvbi5hcmd1bWVudHNcIixcbiAgICAgICAgICBcIm1ldGEudGVtcGxhdGUuZXhwcmVzc2lvblwiLFxuICAgICAgICAgIFwibWFya3VwLmZlbmNlZF9jb2RlIG1ldGEuZW1iZWRkZWQuYmxvY2tcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwiZm9yZWdyb3VuZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJlbXBoYXNpc1wiLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3Ryb25nXCIsIFwibWFya3VwLmhlYWRpbmcubWFya2Rvd25cIiwgXCJtYXJrdXAuYm9sZC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb250U3R5bGU6IFwiYm9sZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXCJtYXJrdXAuaXRhbGljLm1hcmtkb3duXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJtZXRhLmxpbmsuaW5saW5lLm1hcmtkb3duXCIsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9udFN0eWxlOiBcInVuZGVybGluZVwiLFxuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tbGlua1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3RyaW5nXCIsIFwibWFya3VwLmZlbmNlZF9jb2RlXCIsIFwibWFya3VwLmlubGluZVwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wiY29tbWVudFwiLCBcInN0cmluZy5xdW90ZWQuZG9jc3RyaW5nLm11bHRpXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tY29tbWVudFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwiY29uc3RhbnQubnVtZXJpY1wiLFxuICAgICAgICAgIFwiY29uc3RhbnQubGFuZ3VhZ2VcIixcbiAgICAgICAgICBcImNvbnN0YW50Lm90aGVyLnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5jaGFyYWN0ZXIuZm9ybWF0LnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5sYW5ndWFnZS50aGlzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5vYmplY3RcIixcbiAgICAgICAgICBcInZhcmlhYmxlLm90aGVyLmNsYXNzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5jb25zdGFudFwiLFxuICAgICAgICAgIFwibWV0YS5wcm9wZXJ0eS1uYW1lXCIsXG4gICAgICAgICAgXCJtZXRhLnByb3BlcnR5LXZhbHVlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0XCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWNvbnN0YW50XCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLm1vZGlmaWVyXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLnR5cGVcIixcbiAgICAgICAgICBcInN0b3JhZ2UuY29udHJvbC5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS5mdW5jdGlvbi5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS50YWcueWFtbFwiLFxuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvbi5ub2RlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0LnR5cGUucHJvcGVydHktbmFtZS5qc29uXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5zZXBhcmF0b3Iua2V5LXZhbHVlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnRlbXBsYXRlLWV4cHJlc3Npb25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJ2YXJpYWJsZS5wYXJhbWV0ZXIuZnVuY3Rpb25cIixcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXBhcmFtZXRlclwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvblwiLFxuICAgICAgICAgIFwiZW50aXR5Lm5hbWUudHlwZVwiLFxuICAgICAgICAgIFwiZW50aXR5Lm90aGVyLmluaGVyaXRlZC1jbGFzc1wiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsXCIsXG4gICAgICAgICAgXCJtZXRhLmluc3RhbmNlLmNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgXCJlbnRpdHkub3RoZXIuYXR0cmlidXRlLW5hbWVcIixcbiAgICAgICAgICBcImVudGl0eS5uYW1lLmZ1bmN0aW9uXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5rZXl3b3JkLmNsb2p1cmVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZnVuY3Rpb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcImVudGl0eS5uYW1lLnRhZ1wiLFxuICAgICAgICAgIFwic3RyaW5nLnF1b3RlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnJlZ2V4cFwiLFxuICAgICAgICAgIFwic3RyaW5nLmludGVycG9sYXRlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnRlbXBsYXRlXCIsXG4gICAgICAgICAgXCJzdHJpbmcudW5xdW90ZWQucGxhaW4ub3V0LnlhbWxcIixcbiAgICAgICAgICBcImtleXdvcmQub3RoZXIudGVtcGxhdGVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tc3RyaW5nLWV4cHJlc3Npb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uYXJndW1lbnRzXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRpY3RcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLnNlcGFyYXRvclwiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsLmFyZ3VtZW50c1wiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1wdW5jdHVhdGlvblwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBsaW5rc1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLnVuZGVybGluZS5saW5rXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLm1ldGFkYXRhLm1hcmtkb3duXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWxpbmtcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gW0N1c3RvbV0gTWFya2Rvd24gbGlzdFxuICAgICAgICBzY29wZTogW1wiYmVnaW5uaW5nLnB1bmN0dWF0aW9uLmRlZmluaXRpb24ubGlzdC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBwdW5jdHVhdGlvbiBkZWZpbml0aW9uIGJyYWNrZXRzXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnN0cmluZy5iZWdpbi5tYXJrZG93blwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuZW5kLm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJzdHJpbmcub3RoZXIubGluay50aXRsZS5tYXJrZG93blwiLFxuICAgICAgICAgIFwic3RyaW5nLm90aGVyLmxpbmsuZGVzY3JpcHRpb24ubWFya2Rvd25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBEaWZmXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJtYXJrdXAuaW5zZXJ0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIudG8tZmlsZVwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5pbnNlcnRlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1pbnNlcnRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmRlbGV0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIuZnJvbS1maWxlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRlbGV0ZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZGVsZXRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmNoYW5nZWRcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uY2hhbmdlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1jaGFuZ2VkXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGlmICghZm9udFN0eWxlKSB7XG4gICAgdGhlbWUudG9rZW5Db2xvcnMgPSB0aGVtZS50b2tlbkNvbG9ycz8ubWFwKCh0b2tlbkNvbG9yKSA9PiB7XG4gICAgICBpZiAodG9rZW5Db2xvci5zZXR0aW5ncz8uZm9udFN0eWxlKVxuICAgICAgICBkZWxldGUgdG9rZW5Db2xvci5zZXR0aW5ncy5mb250U3R5bGU7XG4gICAgICByZXR1cm4gdG9rZW5Db2xvcjtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhlbWU7XG59XG5cbmV4cG9ydCB7IGFkZENsYXNzVG9IYXN0LCBhcHBseUNvbG9yUmVwbGFjZW1lbnRzLCBjb2RlVG9IYXN0LCBjb2RlVG9IdG1sLCBjb2RlVG9Ub2tlbnMsIGNvZGVUb1Rva2Vuc0Jhc2UsIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMsIGNyZWF0ZUJ1bmRsZWRIaWdobGlnaHRlciwgY3JlYXRlQ3NzVmFyaWFibGVzVGhlbWUsIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZSwgY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlU3luYywgY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIsIGNyZWF0ZVNoaWtpSW50ZXJuYWwsIGNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jLCBjcmVhdGVTaW5nbGV0b25TaG9ydGhhbmRzLCBjcmVhdGVkQnVuZGxlZEhpZ2hsaWdodGVyLCBlbmFibGVEZXByZWNhdGlvbldhcm5pbmdzLCBmbGF0VG9rZW5WYXJpYW50cywgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlLCBnZXRUb2tlblN0eWxlT2JqZWN0LCBndWVzc0VtYmVkZGVkTGFuZ3VhZ2VzLCBoYXN0VG9IdG1sLCBpc05vbmVUaGVtZSwgaXNQbGFpbkxhbmcsIGlzU3BlY2lhbExhbmcsIGlzU3BlY2lhbFRoZW1lLCBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXIsIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlckNvcmUsIG5vcm1hbGl6ZUdldHRlciwgbm9ybWFsaXplVGhlbWUsIHJlc29sdmVDb2xvclJlcGxhY2VtZW50cywgc3BsaXRMaW5lcywgc3BsaXRUb2tlbiwgc3BsaXRUb2tlbnMsIHN0cmluZ2lmeVRva2VuU3R5bGUsIHRvQXJyYXksIHRva2VuaXplQW5zaVdpdGhUaGVtZSwgdG9rZW5pemVXaXRoVGhlbWUsIHRva2Vuc1RvSGFzdCwgdHJhbnNmb3JtZXJEZWNvcmF0aW9ucywgd2FybkRlcHJlY2F0ZWQgfTtcbiJdLCJuYW1lcyI6WyJTaGlraUVycm9yIiwiU2hpa2lFcnJvciQxIiwiRm9udFN0eWxlIiwiSU5JVElBTCIsIkVuY29kZWRUb2tlbk1ldGFkYXRhIiwiUmVnaXN0cnkiLCJSZWdpc3RyeSQxIiwiVGhlbWUiLCJ0b0h0bWwiLCJyZXNvbHZlQ29sb3JSZXBsYWNlbWVudHMiLCJ0aGVtZSIsIm9wdGlvbnMiLCJyZXBsYWNlbWVudHMiLCJjb2xvclJlcGxhY2VtZW50cyIsInRoZW1lTmFtZSIsIm5hbWUiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJhc3NpZ24iLCJhcHBseUNvbG9yUmVwbGFjZW1lbnRzIiwiY29sb3IiLCJ0b0xvd2VyQ2FzZSIsInRvQXJyYXkiLCJ4IiwiQXJyYXkiLCJpc0FycmF5Iiwibm9ybWFsaXplR2V0dGVyIiwicCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInIiLCJkZWZhdWx0IiwiaXNQbGFpbkxhbmciLCJsYW5nIiwiaW5jbHVkZXMiLCJpc1NwZWNpYWxMYW5nIiwiaXNOb25lVGhlbWUiLCJpc1NwZWNpYWxUaGVtZSIsImFkZENsYXNzVG9IYXN0Iiwibm9kZSIsImNsYXNzTmFtZSIsInByb3BlcnRpZXMiLCJjbGFzcyIsInNwbGl0IiwidGFyZ2V0cyIsImMiLCJwdXNoIiwic3BsaXRMaW5lcyIsImNvZGUiLCJwcmVzZXJ2ZUVuZGluZyIsImxlbmd0aCIsInBhcnRzIiwiaW5kZXgiLCJsaW5lcyIsImkiLCJsaW5lIiwiY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIiLCJtYXAiLCJpbmRleFRvUG9zIiwiY2hhcmFjdGVyIiwibGluZVRleHQiLCJwb3NUb0luZGV4IiwiZ3Vlc3NFbWJlZGRlZExhbmd1YWdlcyIsIl9sYW5nIiwiaGlnaGxpZ2h0ZXIiLCJsYW5ncyIsIlNldCIsIm1hdGNoIiwibWF0Y2hBbGwiLCJ0cmltIiwiYWRkIiwiZnVsbFR5cGUiLCJwb3AiLCJmcm9tIiwiYnVuZGxlIiwiZ2V0QnVuZGxlZExhbmd1YWdlcyIsImZpbHRlciIsImwiLCJERUZBVUxUX0NPTE9SX0xJR0hUX0RBUksiLCJDT0xPUl9LRVlTIiwic3BsaXRUb2tlbiIsInRva2VuIiwib2Zmc2V0cyIsImxhc3RPZmZzZXQiLCJ0b2tlbnMiLCJvZmZzZXQiLCJjb250ZW50Iiwic2xpY2UiLCJzcGxpdFRva2VucyIsImJyZWFrcG9pbnRzIiwic29ydGVkIiwic29ydCIsImEiLCJiIiwiZmxhdE1hcCIsImJyZWFrcG9pbnRzSW5Ub2tlbiIsImZsYXRUb2tlblZhcmlhbnRzIiwibWVyZ2VkIiwidmFyaWFudHNPcmRlciIsImNzc1ZhcmlhYmxlUHJlZml4IiwiZGVmYXVsdENvbG9yIiwiY29sb3JzUmVuZGVyaW5nIiwiZXhwbGFuYXRpb24iLCJzdHlsZXMiLCJ0IiwiZ2V0VG9rZW5TdHlsZU9iamVjdCIsInZhcmlhbnRzIiwic3R5bGVLZXlzIiwia2V5cyIsIm1lcmdlZFN0eWxlcyIsInZhcktleSIsImlkeCIsImtleU5hbWUiLCJmb3JFYWNoIiwiY3VyIiwibGlnaHRJbmRleCIsImZpbmRJbmRleCIsImRhcmtJbmRleCIsImxpZ2h0VmFsdWUiLCJkYXJrVmFsdWUiLCJodG1sU3R5bGUiLCJiZ0NvbG9yIiwiZm9udFN0eWxlIiwiSXRhbGljIiwiQm9sZCIsImRlY29yYXRpb25zIiwiVW5kZXJsaW5lIiwiU3RyaWtldGhyb3VnaCIsImpvaW4iLCJzdHJpbmdpZnlUb2tlblN0eWxlIiwiX2dyYW1tYXJTdGF0ZU1hcCIsIldlYWtNYXAiLCJzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAiLCJzdGF0ZSIsInNldCIsImdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwIiwiZ2V0IiwiR3JhbW1hclN0YXRlIiwidGhlbWVzIiwiX3N0YWNrcyIsIl9zdGFjayIsImluaXRpYWwiLCJmcm9tRW50cmllcyIsImNvbnN0cnVjdG9yIiwiYXJncyIsInN0YWNrc01hcCIsInN0YWNrIiwiZ2V0SW50ZXJuYWxTdGFjayIsImdldFNjb3BlcyIsInRvSlNPTiIsInNjb3BlcyIsInZpc2l0ZWQiLCJwdXNoU2NvcGUiLCJzdGFjazIiLCJoYXMiLCJuYW1lU2NvcGVzTGlzdCIsInNjb3BlTmFtZSIsInBhcmVudCIsImdldEdyYW1tYXJTdGFjayIsInRyYW5zZm9ybWVyRGVjb3JhdGlvbnMiLCJnZXRDb250ZXh0Iiwic2hpa2kiLCJtZXRhIiwibm9ybWFsaXplUG9zaXRpb24iLCJzb3VyY2UiLCJjb252ZXJ0ZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZCIsInN0YXJ0IiwiZW5kIiwidmVyaWZ5SW50ZXJzZWN0aW9ucyIsImN0eCIsInNwbGl0dGVkIiwiY29kZUVsIiwiY2hpbGRyZW4iLCJ0eXBlIiwidGFnTmFtZSIsImFwcGx5TGluZVNlY3Rpb24iLCJkZWNvcmF0aW9uIiwibGluZUVsIiwidGV4dCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiYWx3YXlzV3JhcCIsImFwcGx5RGVjb3JhdGlvbiIsIndyYXBwZXIiLCJzcGxpY2UiLCJhcHBseUxpbmUiLCJlbCIsInRyYW5zZm9ybSIsImxpbmVBcHBsaWVzIiwidW5zaGlmdCIsIml0ZW1zIiwiZm9vIiwiaiIsImJhciIsImlzRm9vSGFzQmFyU3RhcnQiLCJpc0Zvb0hhc0JhckVuZCIsImlzQmFySGFzRm9vU3RhcnQiLCJpc0Jhckhhc0Zvb0VuZCIsImJ1aWx0SW5UcmFuc2Zvcm1lcnMiLCJnZXRUcmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lcnMiLCJzb3J0VHJhbnNmb3JtZXJzQnlFbmZvcmNlbWVudCIsInByZSIsIm5vcm1hbCIsInBvc3QiLCJ0cmFuc2Zvcm1lciIsImVuZm9yY2UiLCJuYW1lZENvbG9ycyIsImZpbmRTZXF1ZW5jZSIsInBvc2l0aW9uIiwibmV4dEVzY2FwZSIsImluZGV4T2YiLCJuZXh0Q2xvc2UiLCJzZXF1ZW5jZSIsInN1YnN0cmluZyIsInN0YXJ0UG9zaXRpb24iLCJwYXJzZUNvbG9yIiwiY29sb3JNb2RlIiwic2hpZnQiLCJyZ2IiLCJwYXJzZUludCIsInNvbWUiLCJpc05hTiIsInBhcnNlU2VxdWVuY2UiLCJjb21tYW5kcyIsImNvZGVJbnQiLCJjcmVhdGVBbnNpU2VxdWVuY2VQYXJzZXIiLCJmb3JlZ3JvdW5kIiwiYmFja2dyb3VuZCIsImRlY29yYXRpb25zMiIsInBhcnNlIiwiZmluZFJlc3VsdCIsInN0eWxlVG9rZW4iLCJjbGVhciIsImRlbGV0ZSIsImRlZmF1bHROYW1lZENvbG9yc01hcCIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJibHVlIiwibWFnZW50YSIsImN5YW4iLCJ3aGl0ZSIsImJyaWdodEJsYWNrIiwiYnJpZ2h0UmVkIiwiYnJpZ2h0R3JlZW4iLCJicmlnaHRZZWxsb3ciLCJicmlnaHRCbHVlIiwiYnJpZ2h0TWFnZW50YSIsImJyaWdodEN5YW4iLCJicmlnaHRXaGl0ZSIsImNyZWF0ZUNvbG9yUGFsZXR0ZSIsIm5hbWVkQ29sb3JzTWFwIiwibmFtZWRDb2xvciIsInJnYkNvbG9yIiwiTWF0aCIsIm1heCIsIm1pbiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJjb2xvclRhYmxlIiwiZ2V0Q29sb3JUYWJsZSIsImxldmVscyIsImciLCJsZXZlbCIsInRhYmxlQ29sb3IiLCJkZWZhdWx0QW5zaUNvbG9ycyIsInRva2VuaXplQW5zaVdpdGhUaGVtZSIsImZpbGVDb250ZW50cyIsImFuc2lQYWxldHRlIiwidG9VcHBlckNhc2UiLCJ0aGVtZUNvbG9yIiwiY29sb3JzIiwiY29sb3JQYWxldHRlIiwicGFyc2VyIiwiYmciLCJmZyIsImRpbUNvbG9yIiwiTm9uZSIsImhleE1hdGNoIiwiaGV4IiwiYWxwaGEiLCJyb3VuZCIsImNzc1Zhck1hdGNoIiwiY29kZVRvVG9rZW5zQmFzZSIsImludGVybmFsIiwiZ2V0TG9hZGVkVGhlbWVzIiwicmVzb2x2ZUxhbmdBbGlhcyIsImNvbG9yTWFwIiwic2V0VGhlbWUiLCJfZ3JhbW1hciIsImdldExhbmd1YWdlIiwiZ3JhbW1hclN0YXRlIiwidG9rZW5pemVXaXRoVGhlbWUiLCJnZXRMYXN0R3JhbW1hclN0YXRlIiwiX3Rva2VuaXplV2l0aFRoZW1lIiwic3RhdGVTdGFjayIsImdyYW1tYXIiLCJyZXN1bHQiLCJ0b2tlbml6ZU1heExpbmVMZW5ndGgiLCJ0b2tlbml6ZVRpbWVMaW1pdCIsImdyYW1tYXJDb250ZXh0Q29kZSIsImFjdHVhbCIsImZpbmFsIiwibGVuIiwibGluZU9mZnNldCIsInJlc3VsdFdpdGhTY29wZXMiLCJ0b2tlbnNXaXRoU2NvcGVzIiwidG9rZW5zV2l0aFNjb3Blc0luZGV4IiwiaW5jbHVkZUV4cGxhbmF0aW9uIiwidG9rZW5pemVMaW5lIiwidG9rZW5pemVMaW5lMiIsInRva2Vuc0xlbmd0aCIsIm5leHRTdGFydEluZGV4IiwibWV0YWRhdGEiLCJnZXRGb3JlZ3JvdW5kIiwiZ2V0Rm9udFN0eWxlIiwidGhlbWVTZXR0aW5nc1NlbGVjdG9ycyIsInNldHRpbmciLCJzZXR0aW5ncyIsInNlbGVjdG9ycyIsInNjb3BlIiwic2VsZWN0b3IiLCJ0b2tlbldpdGhTY29wZXMiLCJ0b2tlbldpdGhTY29wZXNUZXh0IiwiZXhwbGFpblRoZW1lU2NvcGVzTmFtZU9ubHkiLCJleHBsYWluVGhlbWVTY29wZXNGdWxsIiwicnVsZVN0YWNrIiwidGhlbWVTZWxlY3RvcnMiLCJ0aGVtZU1hdGNoZXMiLCJleHBsYWluVGhlbWVTY29wZSIsIm1hdGNoZXNPbmUiLCJtYXRjaGVzIiwicGFyZW50U2NvcGVzIiwic2VsZWN0b3JQYXJlbnRJbmRleCIsInBhcmVudEluZGV4Iiwic2VsZWN0b3JQaWVjZXMiLCJjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzIiwidGhlbWVkVG9rZW5zIiwidG9rZW5zMiIsInN5bmNUaGVtZXNUb2tlbml6YXRpb24iLCJtZXJnZWRUb2tlbnMiLCJsaW5lSWR4IiwiX3Rva2VuIiwidG9rZW5JZHgiLCJtZXJnZWRUb2tlbiIsInRoZW1lSWR4IiwiXyIsIl9fIiwiX19fIiwibWVyZ2VkR3JhbW1hclN0YXRlIiwicyIsIm91dFRoZW1lcyIsImNvdW50Iiwib3V0TGluZXMiLCJpMiIsImluZGV4ZXMiLCJjdXJyZW50IiwiZXZlcnkiLCJtaW5MZW5ndGgiLCJuIiwiY29kZVRvVG9rZW5zIiwicm9vdFN0eWxlIiwidGhlbWVUb2tlbnMiLCJmaW5kIiwidGhlbWVSZWdzIiwiZ2V0VGhlbWUiLCJ0aGVtZXNPcmRlciIsInRoZW1lQ29sb3JSZXBsYWNlbWVudHMiLCJtYXBUaGVtZUNvbG9ycyIsIl90aGVtZSIsInByb3BlcnR5IiwiY3NzVmFyIiwidDIiLCJjb2RlVG9IYXN0IiwidHJhbnNmb3JtZXJDb250ZXh0IiwiX2NvZGUiLCJfb3B0aW9ucyIsImlucHV0IiwicHJlcHJvY2VzcyIsImNhbGwiLCJtZXJnZVdoaXRlc3BhY2VzIiwibWVyZ2VTYW1lU3R5bGVUb2tlbnMiLCJtZXJnZVdoaXRlc3BhY2VUb2tlbnMiLCJzcGxpdFdoaXRlc3BhY2VUb2tlbnMiLCJtZXJnZUFkamFjZW50U3R5bGVkVG9rZW5zIiwiY29udGV4dFNvdXJjZSIsInRva2Vuc1RvSGFzdCIsInJvb3QiLCJzdHJ1Y3R1cmUiLCJ0YWJpbmRleCIsInN0eWxlIiwic3RhcnRzV2l0aCIsInByZU5vZGUiLCJkYXRhIiwiY29kZU5vZGUiLCJsaW5lTm9kZXMiLCJjb250ZXh0IiwibGluZU5vZGUiLCJjb2wiLCJ0b2tlbk5vZGUiLCJodG1sQXR0cnMiLCJzcGFuIiwic3ludGhldGljTGluZXMiLCJjdXJyZW50TGluZSIsImNoaWxkIiwic3ludGhldGljQ29kZSIsInRyYW5zZm9ybWVkQ29kZSIsIm5ld0xpbmUiLCJjYXJyeU9uQ29udGVudCIsImZpcnN0T2Zmc2V0IiwiaXNEZWNvcmF0ZWQiLCJjb3VsZE1lcmdlIiwibGVhZGluZyIsInRyYWlsaW5nIiwiZXhwYW5kZWQiLCJwcmV2VG9rZW4iLCJwcmV2U3R5bGUiLCJjdXJyZW50U3R5bGUiLCJpc1ByZXZEZWNvcmF0ZWQiLCJoYXN0VG9IdG1sIiwiY29kZVRvSHRtbCIsInBvc3Rwcm9jZXNzIiwiVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9GRyIsImxpZ2h0IiwiZGFyayIsIlZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkciLCJSRVNPTFZFRF9LRVkiLCJub3JtYWxpemVUaGVtZSIsInJhd1RoZW1lIiwidG9rZW5Db2xvcnMiLCJnbG9iYWxTZXR0aW5nIiwicmVwbGFjZW1lbnRDb3VudCIsInJlcGxhY2VtZW50TWFwIiwiTWFwIiwiZ2V0UmVwbGFjZW1lbnRDb2xvciIsInJlcGxhY2VGZyIsInJlcGxhY2VCZyIsImNsb25lIiwicmVwbGFjZW1lbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInJlc29sdmVMYW5ncyIsImFsbCIsImZsYXQiLCJyZXNvbHZlVGhlbWVzIiwicmVzb2x2ZWQiLCJfZW1pdERlcHJlY2F0aW9uIiwiX2VtaXRFcnJvciIsImVuYWJsZURlcHJlY2F0aW9uV2FybmluZ3MiLCJlbWl0RGVwcmVjYXRpb24iLCJlbWl0RXJyb3IiLCJ3YXJuRGVwcmVjYXRlZCIsIm1lc3NhZ2UiLCJ2ZXJzaW9uIiwiRXJyb3IiLCJjb25zb2xlIiwidHJhY2UiLCJhbGlhcyIsIl9yZXNvbHZlciIsIl90aGVtZXMiLCJfbGFuZ3MiLCJfYWxpYXMiLCJfcmVzb2x2ZWRUaGVtZXMiLCJfcmVzb2x2ZWRHcmFtbWFycyIsIl9sYW5nTWFwIiwiX2xhbmdHcmFwaCIsIl90ZXh0bWF0ZVRoZW1lQ2FjaGUiLCJfbG9hZGVkVGhlbWVzQ2FjaGUiLCJfbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUiLCJsb2FkVGhlbWUiLCJsb2FkTGFuZ3VhZ2VzIiwidGV4dG1hdGVUaGVtZSIsImNyZWF0ZUZyb21SYXdUaGVtZSIsIl9zeW5jUmVnaXN0cnkiLCJnZXRHcmFtbWFyIiwibG9hZExhbmd1YWdlIiwiZW1iZWRkZWRMYXppbHlCeSIsInZhbHVlcyIsImVtYmVkZGVkTGFuZ3NMYXp5IiwiYWRkTGFuZ3VhZ2UiLCJncmFtbWFyQ29uZmlnIiwiYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIiwidW5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMiLCJfcmF3R3JhbW1hcnMiLCJsb2FkR3JhbW1hcldpdGhDb25maWd1cmF0aW9uIiwiYWxpYXNlcyIsInNpemUiLCJlIiwiX2luamVjdGlvbkdyYW1tYXJzIiwiX2dyYW1tYXJzIiwiZGlzcG9zZSIsInJlc29sdmVFbWJlZGRlZExhbmd1YWdlcyIsImxhbmdzR3JhcGhBcnJheSIsIm1pc3NpbmdMYW5ncyIsImRlcGVuZGVudHMiLCJlbWJlZGRlZCIsImVtYmVkZGVkTGFuZ3VhZ2VzIiwiZW1iZWRkZWRMYW5ncyIsImdldExvYWRlZExhbmd1YWdlcyIsImVtYmVkZGVkTGFuZyIsIlJlc29sdmVyIiwiZW5naW5lIiwiX3Njb3BlVG9MYW5nIiwiX2luamVjdGlvbnMiLCJfb25pZ0xpYiIsImNyZWF0ZU9uaWdTY2FubmVyIiwicGF0dGVybnMiLCJjcmVhdGVTY2FubmVyIiwiY3JlYXRlT25pZ1N0cmluZyIsImNyZWF0ZVN0cmluZyIsIm9uaWdMaWIiLCJnZXRMYW5nUmVnaXN0cmF0aW9uIiwibGFuZ0lkT3JBbGlhcyIsImxvYWRHcmFtbWFyIiwiaW5qZWN0VG8iLCJnZXRJbmplY3Rpb25zIiwic2NvcGVQYXJ0cyIsImluamVjdGlvbnMiLCJzdWJTY29wZU5hbWUiLCJpbnN0YW5jZXNDb3VudCIsImNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jIiwid2FybmluZ3MiLCJ3YXJuIiwiaXNEaXNwb3NlZCIsInJlc29sdmVyIiwiX3JlZ2lzdHJ5IiwibGFuZ0FsaWFzIiwiX2xhc3RUaGVtZSIsInJlc29sdmVMYW5nQWxpYXMkMSIsImVuc3VyZU5vdERpc3Bvc2VkIiwiZ2V0Q29sb3JNYXAiLCJsb2FkTGFuZ3VhZ2VTeW5jIiwibGFuZ3MyIiwibG9hZFRoZW1lU3luYyIsInRoZW1lczIiLCJTeW1ib2wiLCJjcmVhdGVTaGlraUludGVybmFsIiwiY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlIiwib3B0aW9uczIiLCJnZXRCdW5kbGVkVGhlbWVzIiwiZ2V0SW50ZXJuYWxDb250ZXh0IiwiY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlU3luYyIsIm1ha2VTaW5nbGV0b25IaWdobGlnaHRlckNvcmUiLCJjcmVhdGVIaWdobGlnaHRlciIsIl9zaGlraSIsImdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZTIiLCJnZXRTaW5nbGV0b25IaWdobGlnaHRlckNvcmUiLCJjcmVhdGVCdW5kbGVkSGlnaGxpZ2h0ZXIiLCJidW5kbGVkTGFuZ3VhZ2VzIiwiYnVuZGxlZFRoZW1lcyIsInJlc29sdmVMYW5nIiwicmVzb2x2ZVRoZW1lIiwiY29yZSIsIm1ha2VTaW5nbGV0b25IaWdobGlnaHRlciIsImdldFNpbmdsZXRvbkhpZ2hsaWdodGVyIiwiY3JlYXRlU2luZ2xldG9uU2hvcnRoYW5kcyIsImNvbmZpZyIsImNyZWF0ZWRCdW5kbGVkSGlnaGxpZ2h0ZXIiLCJjcmVhdGVDc3NWYXJpYWJsZXNUaGVtZSIsInZhcmlhYmxlUHJlZml4IiwidmFyaWFibGUiLCJuYW1lMiIsInZhcmlhYmxlRGVmYXVsdHMiLCJ0b2tlbkNvbG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@shikijs+core@3.21.0/node_modules/@shikijs/core/dist/index.mjs\n");

/***/ })

};
;