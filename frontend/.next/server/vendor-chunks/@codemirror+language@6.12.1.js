"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+language@6.12.1";
exports.ids = ["vendor-chunks/@codemirror+language@6.12.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@codemirror+language@6.12.1/node_modules/@codemirror/language/dist/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@codemirror+language@6.12.1/node_modules/@codemirror/language/dist/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/.pnpm/@codemirror+state@6.5.4/node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/.pnpm/@codemirror+view@6.39.11/node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/.pnpm/@lezer+highlight@1.2.3/node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/.pnpm/style-mod@4.1.3/node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/ const languageDataProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/ function defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n        combine: baseData ? (values)=>values.concat(baseData) : undefined\n    });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/ const sublanguageProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/ class Language {\n    /**\n    Construct a language object. If you need to invoke this\n    directly, first define a data facet with\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n    to the language's outer syntax node.\n    */ constructor(/**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n    used for this language.\n    */ data, parser, extraExtensions = [], /**\n    A language name.\n    */ name = \"\"){\n        this.data = data;\n        this.name = name;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n            get () {\n                return syntaxTree(this);\n            }\n        });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side)=>{\n                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);\n                if (!data) return [];\n                let base = state.facet(data), sub = top.type.prop(sublanguageProp);\n                if (sub) {\n                    let innerNode = top.resolve(pos - top.from, side);\n                    for (let sublang of sub)if (sublang.test(innerNode, state)) {\n                        let data = state.facet(sublang.facet);\n                        return sublang.type == \"replace\" ? data : data.concat(base);\n                    }\n                }\n                return base;\n            })\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */ isActiveAt(state, pos, side = -1) {\n        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */ findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [\n            {\n                from: 0,\n                to: state.doc.length\n            }\n        ];\n        if (!lang || !lang.allowsNesting) return [];\n        let result = [];\n        let explore = (tree, from)=>{\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({\n                    from,\n                    to: from + tree.length\n                });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay) for (let r of mount.overlay)result.push({\n                        from: r.from + from,\n                        to: r.to + from\n                    });\n                    else result.push({\n                        from: from,\n                        to: from + tree.length\n                    });\n                    return;\n                } else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size) return;\n                }\n            }\n            for(let i = 0; i < tree.children.length; i++){\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */ get allowsNesting() {\n        return true;\n    }\n}\n/**\n@internal\n*/ Language.setState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n    let topLang = state.facet(language), tree = syntaxTree(state).topNode;\n    if (!topLang || topLang.allowsNesting) {\n        for(let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers | _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.EnterBracketed))if (node.type.isTop) tree = node;\n    }\n    return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/ class LRLanguage extends Language {\n    constructor(data, parser, name){\n        super(data, parser, [], name);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */ static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [\n                languageDataProp.add((type)=>type.isTop ? data : undefined)\n            ]\n        }), spec.name);\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser and optionally a new name.\n    */ configure(options, name) {\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n    }\n    get allowsNesting() {\n        return this.parser.hasWrappers();\n    }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/ function syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/ function ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    if (!parse) return null;\n    let oldVieport = parse.viewport;\n    parse.updateViewport({\n        from: 0,\n        to: upto\n    });\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n    parse.updateViewport(oldVieport);\n    return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of thatâ€”the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/ function syntaxTreeAvailable(state, upto = state.doc.length) {\n    var _a;\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/ function forceParsing(view, upto = view.viewport.to, timeout = 100) {\n    let success = ensureSyntaxTree(view.state, upto, timeout);\n    if (success != syntaxTree(view.state)) view.dispatch({});\n    return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/ function syntaxParserRunning(view) {\n    var _a;\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/ class DocInput {\n    /**\n    Create an input object for the given document.\n    */ constructor(doc){\n        this.doc = doc;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get length() {\n        return this.doc.length;\n    }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() {\n        return true;\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);\n        else return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/ class ParseContext {\n    constructor(parser, /**\n    The current editor state.\n    */ state, /**\n    Tree fragments that can be reused by incremental re-parses.\n    */ fragments = [], /**\n    @internal\n    */ tree, /**\n    @internal\n    */ treeLen, /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */ viewport, /**\n    @internal\n    */ skipped, /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */ scheduleOn){\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */ this.tempSkipped = [];\n    }\n    /**\n    @internal\n    */ static create(parser, state, viewport) {\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */ work(until, upto) {\n        if (upto != null && upto >= this.state.doc.length) upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(()=>{\n            var _a;\n            if (typeof until == \"number\") {\n                let endTime = Date.now() + until;\n                until = ()=>Date.now() > endTime;\n            }\n            if (!this.parse) this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n            for(;;){\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();\n                    else return true;\n                }\n                if (until()) return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */ takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n            this.withContext(()=>{\n                while(!(tree = this.parse.advance())){}\n            });\n            this.treeLen = pos;\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        } finally{\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for(let r; r = this.tempSkipped.pop();)fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */ changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB)=>ranges.push({\n                    fromA,\n                    toA,\n                    fromB,\n                    toB\n                }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = {\n                from: changes.mapPos(viewport.from, -1),\n                to: changes.mapPos(viewport.to, 1)\n            };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped){\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to) skipped.push({\n                        from,\n                        to\n                    });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */ updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for(let i = 0; i < this.skipped.length; i++){\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen) return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */ reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */ skipUntilInView(from, to) {\n        this.skipped.push({\n            from,\n            to\n        });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */ static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance () {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)cx.tempSkipped.push(r);\n                            if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([\n                                cx.scheduleOn,\n                                until\n                            ]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt () {}\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */ isDone(upto) {\n        upto = Math.min(upto, this.state.doc.length);\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */ static get() {\n        return currentContext;\n    }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [\n        {\n            fromA: from,\n            toA: to,\n            fromB: from,\n            toB: to\n        }\n    ]);\n}\nclass LanguageState {\n    constructor(// A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context){\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged && this.tree == this.context.tree) return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(20 /* Work.Apply */ , upto)) newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let vpTo = Math.min(3000 /* Work.InitViewport */ , state.doc.length);\n        let parseState = ParseContext.create(state.facet(language).parser, state, {\n            from: 0,\n            to: vpTo\n        });\n        if (!parseState.work(20 /* Work.Apply */ , vpTo)) parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create: LanguageState.init,\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(Language.setState)) return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = (callback)=>{\n    let timeout = setTimeout(()=>callback(), 500 /* Work.MaxPause */ );\n    return ()=>clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = (callback)=>{\n    let idle = -1, timeout = setTimeout(()=>{\n        idle = requestIdleCallback(callback, {\n            timeout: 500 /* Work.MaxPause */  - 100 /* Work.MinPause */ \n        });\n    }, 100 /* Work.MinPause */ );\n    return ()=>idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? ()=>navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view){\n        this.view = view;\n        this.working = null;\n        this.workScheduled = 0;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n        if (update.docChanged || update.selectionSet) {\n            if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */ ;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working) return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n    }\n    work(deadline) {\n        this.working = null;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n            this.chunkEnd = now + 30000 /* Work.ChunkTime */ ;\n            this.chunkBudget = 3000 /* Work.ChunkBudget */ ;\n        }\n        if (this.chunkBudget <= 0) return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */ )) return;\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */ , deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */ , deadline.timeRemaining() - 5) : 1e9);\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n        let done = field.context.work(()=>{\n            return isInputPending && isInputPending() || Date.now() > endTime;\n        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */ ));\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0) {\n            field.context.takeTree();\n            this.view.dispatch({\n                effects: Language.setState.of(new LanguageState(field.context))\n            });\n        }\n        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            this.workScheduled++;\n            cx.scheduleOn.then(()=>this.scheduleWork()).catch((err)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(()=>this.workScheduled--);\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working) this.working();\n    }\n    isWorking() {\n        return !!(this.working || this.workScheduled > 0);\n    }\n}, {\n    eventHandlers: {\n        focus () {\n            this.scheduleWork();\n        }\n    }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/ const language = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (languages) {\n        return languages.length ? languages[0] : null;\n    },\n    enables: (language)=>[\n            Language.state,\n            parseWorker,\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([\n                language\n            ], (state)=>{\n                let lang = state.facet(language);\n                return lang && lang.name ? {\n                    \"data-language\": lang.name\n                } : {};\n            })\n        ]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/ class LanguageSupport {\n    /**\n    Create a language support object.\n    */ constructor(/**\n    The language object.\n    */ language, /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */ support = []){\n        this.language = language;\n        this.support = support;\n        this.extension = [\n            language,\n            support\n        ];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/ class LanguageDescription {\n    constructor(/**\n    The name of this language.\n    */ name, /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */ alias, /**\n    File extensions associated with this language.\n    */ extensions, /**\n    Optional filename pattern that should be associated with this\n    language.\n    */ filename, loadFunc, /**\n    If the language has been loaded, this will hold its value.\n    */ support = undefined){\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        this.support = support;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */ load() {\n        return this.loading || (this.loading = this.loadFunc().then((support)=>this.support = support, (err)=>{\n            this.loading = null;\n            throw err;\n        }));\n    }\n    /**\n    Create a language description.\n    */ static of(spec) {\n        let { load, support } = spec;\n        if (!load) {\n            if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n            load = ()=>Promise.resolve(support);\n        }\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s)=>s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */ static matchFilename(descs, filename) {\n        for (let d of descs)if (d.filename && d.filename.test(filename)) return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext) {\n            for (let d of descs)if (d.extensions.indexOf(ext[1]) > -1) return d;\n        }\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */ static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)if (d.alias.some((a)=>a == name)) return d;\n        if (fuzzy) for (let d of descs)for (let a of d.alias){\n            let found = name.indexOf(a);\n            if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n        }\n        return null;\n    }\n}\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/ const indentService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting entirely of the same whitespace character.\nWhen not set, this defaults to 2 spaces.\n*/ const indentUnit = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        if (!values.length) return \"  \";\n        let unit = values[0];\n        if (!unit || /\\S/.test(unit) || Array.from(unit).some((e)=>e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return unit;\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/ function getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/ function indentString(state, cols) {\n    let result = \"\", ts = state.tabSize, ch = state.facet(indentUnit)[0];\n    if (ch == \"\t\") {\n        while(cols >= ts){\n            result += \"\t\";\n            cols -= ts;\n        }\n        ch = \" \";\n    }\n    for(let i = 0; i < cols; i++)result += ch;\n    return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/ function getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)){\n        let result = service(context, pos);\n        if (result !== undefined) return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/ function indentRange(state, from, to) {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, {\n        overrideIndentation: (start)=>{\n            var _a;\n            return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n        }\n    });\n    let changes = [];\n    for(let pos = from; pos <= to;){\n        let line = state.doc.lineAt(pos);\n        pos = line.to + 1;\n        let indent = getIndentation(context, line.from);\n        if (indent == null) continue;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    }\n    return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/ class IndentContext {\n    /**\n    Create an indent context.\n    */ constructor(/**\n    The editor state.\n    */ state, /**\n    @internal\n    */ options = {}){\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */ lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak, simulateDoubleBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (simulateDoubleBreak && simulateBreak == pos) return {\n                text: \"\",\n                from: pos\n            };\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n                text: line.text.slice(simulateBreak - line.from),\n                from: simulateBreak\n            };\n            else return {\n                text: line.text.slice(0, simulateBreak - line.from),\n                from: line.from\n            };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */ column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */ countColumn(line, pos = line.length) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */ lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1) return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */ get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/ const indentNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let stack = ast.resolveStack(pos);\n    let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);\n    if (inner != stack.node) {\n        let add = [];\n        for(let cur = inner; cur && !(cur.from < stack.node.from || cur.to > stack.node.to || cur.from == stack.node.from && cur.type == stack.node.type); cur = cur.parent)add.push(cur);\n        for(let i = add.length - 1; i >= 0; i--)stack = {\n            node: add[i],\n            next: stack\n        };\n    }\n    return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n    for(let cur = stack; cur; cur = cur.next){\n        let strategy = indentStrategy(cur.node);\n        if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n    }\n    return 0;\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy) return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return (cx)=>delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n    return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/ class TreeIndentContext extends IndentContext {\n    constructor(base, /**\n    The position at which indentation is being computed.\n    */ pos, /**\n    @internal\n    */ context){\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.context = context;\n    }\n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */ get node() {\n        return this.context.node;\n    }\n    /**\n    @internal\n    */ static create(base, pos, context) {\n        return new TreeIndentContext(base, pos, context);\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */ get baseIndent() {\n        return this.baseIndentFor(this.node);\n    }\n    /**\n    Get the indentation for the reference line of the given node\n    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n    */ baseIndentFor(node) {\n        let line = this.state.doc.lineAt(node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for(;;){\n            let atBreak = node.resolve(line.from);\n            while(atBreak.parent && atBreak.parent.from == atBreak.from)atBreak = atBreak.parent;\n            if (isParent(atBreak, node)) break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */ continue() {\n        return indentFor(this.context.next, this.base, this.pos);\n    }\n}\nfunction isParent(parent, of) {\n    for(let cur = of; cur; cur = cur.parent)if (parent == cur) return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken) return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for(let pos = openToken.to;;){\n        let next = tree.childAfter(pos);\n        if (!next || next == last) return null;\n        if (!next.type.isSkipped) {\n            if (next.from >= lineEnd) return null;\n            let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;\n            return {\n                from: openToken.from,\n                to: openToken.to + space\n            };\n        }\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/ function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context)=>delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/ const flatIndent = (context)=>context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/ function continuedIndent({ except, units = 1 } = {}) {\n    return (context)=>{\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/ function indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of((tr)=>{\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length) return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond) return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some((r)=>r.test(lineStart))) return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges){\n            let line = state.doc.lineAt(head);\n            if (line.from == last) continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null) continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm) changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n        return changes.length ? [\n            tr,\n            {\n                changes,\n                sequential: true\n            }\n        ] : tr;\n    });\n}\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/ const foldService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/ const foldNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/ function foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? {\n        from: first.to,\n        to: last.type.isError ? node.to : last.from\n    } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length < end) return null;\n    let stack = tree.resolveStack(end, 1);\n    let found = null;\n    for(let iter = stack; iter; iter = iter.next){\n        let cur = iter.node;\n        if (cur.to <= end || cur.from > end) continue;\n        if (found && cur.from < start) break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n        }\n    }\n    return found;\n}\nfunction isUnfinished(node) {\n    let ch = node.lastChild;\n    return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/ function foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)){\n        let result = service(state, lineStart, lineEnd);\n        if (result) return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : {\n        from,\n        to\n    };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstancesâ€”usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/ const foldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/ const unfoldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges){\n        if (lines.some((l)=>l.from <= head && l.to >= head)) continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/ const foldState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (folded, tr) {\n        if (tr.isUserEvent(\"delete\")) tr.changes.iterChangedRanges((fromA, toA)=>folded = clearTouchedFolds(folded, fromA, toA));\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects){\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n                let { preparePlaceholder } = tr.state.facet(foldConfig);\n                let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n                    widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n                });\n                folded = folded.update({\n                    add: [\n                        widget.range(e.value.from, e.value.to)\n                    ]\n                });\n            } else if (e.is(unfoldEffect)) {\n                folded = folded.update({\n                    filter: (from, to)=>e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from,\n                    filterTo: e.value.to\n                });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) folded = clearTouchedFolds(folded, tr.selection.main.head);\n        return folded;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n    toJSON (folded, state) {\n        let ranges = [];\n        folded.between(0, state.doc.length, (from, to)=>{\n            ranges.push(from, to);\n        });\n        return ranges;\n    },\n    fromJSON (value) {\n        if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n        let ranges = [];\n        for(let i = 0; i < value.length;){\n            let from = value[i++], to = value[i++];\n            if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n            ranges.push(foldWidget.range(from, to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n    }\n});\nfunction clearTouchedFolds(folded, from, to = from) {\n    let touched = false;\n    folded.between(from, to, (a, b)=>{\n        if (a < to && b > from) touched = true;\n    });\n    return !touched ? folded : folded.update({\n        filterFrom: from,\n        filterTo: to,\n        filter: (a, b)=>a >= to || b <= from\n    });\n}\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/ function foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to)=>{\n        if (!found || found.from > from) found = {\n            from,\n            to\n        };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b)=>{\n        if (a == from && b == to) found = true;\n    });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/ const foldCode = (view)=>{\n    for (let line of selectedLines(view)){\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({\n                effects: maybeEnable(view.state, [\n                    foldEffect.of(range),\n                    announceFold(view, range)\n                ])\n            });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/ const unfoldCode = (view)=>{\n    if (!view.state.field(foldState, false)) return false;\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length) view.dispatch({\n        effects\n    });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/ const foldAll = (view)=>{\n    let { state } = view, effects = [];\n    for(let pos = 0; pos < state.doc.length;){\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range) effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/ const unfoldAll = (view)=>{\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size) return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to)=>{\n        effects.push(unfoldEffect.of({\n            from,\n            to\n        }));\n    });\n    view.dispatch({\n        effects\n    });\n    return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n    // Look backwards through line blocks until we find a foldable region that\n    // intersects with the line\n    for(let line = lineBlock;;){\n        let foldableRegion = foldable(view.state, line.from, line.to);\n        if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n        if (!line.from) return null;\n        line = view.lineBlockAt(line.from - 1);\n    }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/ const toggleFold = (view)=>{\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n        } else {\n            let foldRange = foldableContainer(view, line);\n            if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n        }\n    }\n    if (effects.length > 0) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/ const foldKeymap = [\n    {\n        key: \"Ctrl-Shift-[\",\n        mac: \"Cmd-Alt-[\",\n        run: foldCode\n    },\n    {\n        key: \"Ctrl-Shift-]\",\n        mac: \"Cmd-Alt-]\",\n        run: unfoldCode\n    },\n    {\n        key: \"Ctrl-Alt-[\",\n        run: foldAll\n    },\n    {\n        key: \"Ctrl-Alt-]\",\n        run: unfoldAll\n    }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    preparePlaceholder: null,\n    placeholderText: \"â€¦\"\n};\nconst foldConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n    }\n});\n/**\nCreate an extension that configures code folding.\n*/ function codeFolding(config) {\n    let result = [\n        foldState,\n        baseTheme$1\n    ];\n    if (config) result.push(foldConfig.of(config));\n    return result;\n}\nfunction widgetToDOM(view, prepared) {\n    let { state } = view, conf = state.facet(foldConfig);\n    let onclick = (event)=>{\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n            effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n    };\n    if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n    let element = document.createElement(\"span\");\n    element.textContent = conf.placeholderText;\n    element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n    element.title = state.phrase(\"unfold\");\n    element.className = \"cm-foldPlaceholder\";\n    element.onclick = onclick;\n    return element;\n}\nconst foldWidget = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n        toDOM(view) {\n            return widgetToDOM(view, null);\n        }\n    }\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    eq(other) {\n        return this.value == other.value;\n    }\n    toDOM(view) {\n        return widgetToDOM(view, this.value);\n    }\n}\nconst foldGutterDefaults = {\n    openText: \"âŒ„\",\n    closedText: \"â€º\",\n    markerDOM: null,\n    domEventHandlers: {},\n    foldingChanged: ()=>false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open){\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) {\n        return this.config == other.config && this.open == other.open;\n    }\n    toDOM(view) {\n        if (this.config.markerDOM) return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/ function foldGutter(config = {}) {\n    let fullConfig = {\n        ...foldGutterDefaults,\n        ...config\n    };\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n        constructor(view){\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n            for (let line of view.viewportLineBlocks){\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark) builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    let { domEventHandlers } = fullConfig;\n    return [\n        markers,\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers (view) {\n                var _a;\n                return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n            },\n            initialSpacer () {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: {\n                ...domEventHandlers,\n                click: (view, line, event)=>{\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n                    let folded = findFold(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({\n                            effects: unfoldEffect.of(folded)\n                        });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({\n                            effects: foldEffect.of(range)\n                        });\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n/**\nA highlight style associates CSS styles with highlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/ class HighlightStyle {\n    constructor(/**\n    The tag styles used to create this highlight style.\n    */ specs, options){\n        this.specs = specs;\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n        const scopeOpt = options.scope;\n        this.scope = scopeOpt instanceof Language ? (type)=>type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type)=>type == scopeOpt : undefined;\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map((style)=>({\n                tag: style.tag,\n                class: style.class || def(Object.assign({}, style, {\n                    tag: null\n                }))\n            })), {\n            all\n        }).style;\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n        this.themeType = options.themeType;\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The specs must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighter\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */ static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n}\nconst highlighterFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return values.length ? [\n            values[0]\n        ] : null;\n    }\n});\nfunction getHighlighters(state) {\n    let main = state.facet(highlighterFacet);\n    return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/ function syntaxHighlighting(highlighter, options) {\n    let ext = [\n        treeHighlighter\n    ], themeType;\n    if (highlighter instanceof HighlightStyle) {\n        if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n        themeType = highlighter.themeType;\n    }\n    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));\n    else if (themeType) ext.push(highlighterFacet.computeN([\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme\n    ], (state)=>{\n        return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [\n            highlighter\n        ] : [];\n    }));\n    else ext.push(highlighterFacet.of(highlighter));\n    return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/ function highlightingFor(state, tags, scope) {\n    let highlighters = getHighlighters(state);\n    let result = null;\n    if (highlighters) for (let highlighter of highlighters){\n        if (!highlighter.scope || scope && highlighter.scope(scope)) {\n            let cls = highlighter.style(tags);\n            if (cls) result = result ? result + \" \" + cls : cls;\n        }\n    }\n    return result;\n}\nclass TreeHighlighter {\n    constructor(view){\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\n        this.decoratedTo = view.viewport.to;\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\n        let styleChange = highlighters != getHighlighters(update.startState);\n        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);\n        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n            this.decoratedTo = decoratedToMapped;\n        } else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, highlighters);\n            this.decoratedTo = viewport.to;\n        }\n    }\n    buildDeco(view, highlighters) {\n        if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges){\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style)=>{\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n                    class: style\n                })));\n            }, from, to);\n        }\n        return builder.finish();\n    }\n}\nconst treeHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: (v)=>v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/ const defaultHighlightStyle = /*@__PURE__*/ HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n        color: \"#404740\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n        color: \"#708\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName\n        ],\n        color: \"#219\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted\n        ],\n        color: \"#164\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted\n        ],\n        color: \"#a11\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)\n        ],\n        color: \"#e40\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#00f\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#30a\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace\n        ],\n        color: \"#085\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n        color: \"#167\"\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName\n        ],\n        color: \"#256\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n        color: \"#00c\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n        color: \"#940\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n        color: \"#f00\"\n    }\n]);\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": {\n        backgroundColor: \"#328c8252\"\n    },\n    \"&.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bb555544\"\n    }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist,\n            renderMatch: defaultRenderMatch\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n}), nonmatchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n});\nfunction defaultRenderMatch(match) {\n    let decorations = [];\n    let mark = match.matched ? matchingMark : nonmatchingMark;\n    decorations.push(mark.range(match.start.from, match.start.to));\n    if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (deco, tr) {\n        if (!tr.docChanged && !tr.selection) return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges){\n            if (!range.empty) continue;\n            let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n            if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/ function bracketMatching(config = {}) {\n    return [\n        bracketMatchingConfig.of(config),\n        bracketMatchingUnique\n    ];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a â€˜handleâ€™â€”the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/ const bracketMatchingHandle = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp) return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [\n            brackets[index + dir]\n        ];\n    }\n    return null;\n}\nfunction findHandle(node) {\n    let hasHandle = node.type.prop(bracketMatchingHandle);\n    return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/ function matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for(let cur = node; cur; cur = cur.parent){\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to) {\n            let handle = findHandle(cur);\n            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n        }\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n    let parent = token.parent, firstToken = {\n        from: handle.from,\n        to: handle.to\n    };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n            if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                let endHandle = findHandle(cursor);\n                return {\n                    start: firstToken,\n                    end: endHandle ? {\n                        from: endHandle.from,\n                        to: endHandle.to\n                    } : undefined,\n                    matched: true\n                };\n            } else if (matchingNodes(cursor.type, dir, brackets)) {\n                depth++;\n            } else if (matchingNodes(cursor.type, -dir, brackets)) {\n                if (depth == 0) {\n                    let endHandle = findHandle(cursor);\n                    return {\n                        start: firstToken,\n                        end: endHandle && endHandle.from < endHandle.to ? {\n                            from: endHandle.from,\n                            to: endHandle.to\n                        } : undefined,\n                        matched: false\n                    };\n                }\n                depth--;\n            }\n        }\n    }while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return {\n        start: firstToken,\n        matched: false\n    };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n    let startToken = {\n        from: dir < 0 ? pos - 1 : pos,\n        to: dir > 0 ? pos + 1 : pos\n    };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for(let distance = 0; !iter.next().done && distance <= maxScanDistance;){\n        let text = iter.value;\n        if (dir < 0) distance += text.length;\n        let basePos = pos + distance * dir;\n        for(let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir){\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n            if (found % 2 == 0 == dir > 0) {\n                depth++;\n            } else if (depth == 1) {\n                return {\n                    start: startToken,\n                    end: {\n                        from: basePos + pos,\n                        to: basePos + pos + 1\n                    },\n                    matched: found >> 1 == bracket >> 1\n                };\n            } else {\n                depth--;\n            }\n        }\n        if (dir > 0) distance += text.length;\n    }\n    return iter.done ? {\n        start: startToken,\n        matched: false\n    } : null;\n}\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1) end = string.length;\n    }\n    let n = startValue;\n    for(let i = startIndex; i < end; i++){\n        if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;\n        else n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/ class StringStream {\n    /**\n    Create a stream.\n    */ constructor(/**\n    The line.\n    */ string, tabSize, /**\n    The current indent unit size.\n    */ indentUnit, overrideIndent){\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        this.overrideIndent = overrideIndent;\n        /**\n        The current position on the line.\n        */ this.pos = 0;\n        /**\n        The start position of the current token.\n        */ this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */ eol() {\n        return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */ sol() {\n        return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */ peek() {\n        return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */ next() {\n        if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */ eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\") ok = ch == match;\n        else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */ eatWhile(match) {\n        let start = this.pos;\n        while(this.eat(match)){}\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */ eatSpace() {\n        let start = this.pos;\n        while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */ skipToEnd() {\n        this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */ skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */ backUp(n) {\n        this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */ column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */ indentation() {\n        var _a;\n        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */ match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str)=>caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false) this.pos += pattern.length;\n                return true;\n            } else return null;\n        } else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0) return null;\n            if (match && consume !== false) this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */ current() {\n        return this.string.slice(this.start, this.pos);\n    }\n}\nfunction fullParser(spec) {\n    return {\n        name: spec.name || \"\",\n        token: spec.token,\n        blankLine: spec.blankLine || (()=>{}),\n        startState: spec.startState || (()=>true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (()=>null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens,\n        mergeTokens: spec.mergeTokens !== false\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\") return state;\n    let newState = {};\n    for(let prop in state){\n        let val = state[prop];\n        newState[prop] = val instanceof Array ? val.slice() : val;\n    }\n    return newState;\n}\nconst IndentedFrom = /*@__PURE__*/ new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/ class StreamLanguage extends Language {\n    constructor(parser){\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, [], parser.name);\n        this.topNode = docID(data, this);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n            perNode: true\n        });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    /**\n    Define a stream language.\n    */ static define(spec) {\n        return new StreamLanguage(spec);\n    }\n    /**\n    @internal\n    */ getIndent(cx) {\n        let from = undefined;\n        let { overrideIndentation } = cx.options;\n        if (overrideIndentation) {\n            from = IndentedFrom.get(cx.state);\n            if (from != null && from < cx.pos - 1e4) from = undefined;\n        }\n        let start = findState(this, cx.node.tree, cx.node.from, cx.node.from, from !== null && from !== void 0 ? from : cx.pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        } else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = cx.node.from;\n        }\n        if (cx.pos - statePos > 10000 /* C.MaxIndentScanDist */ ) return null;\n        while(statePos < cx.pos){\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(cx.pos, line.to);\n            if (line.length) {\n                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n                while(stream.pos < end - line.from)readToken(this.streamParser.token, stream, state);\n            } else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == cx.pos) break;\n            statePos = line.to + 1;\n        }\n        let line = cx.lineAt(cx.pos);\n        if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n    }\n    get allowsNesting() {\n        return false;\n    }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state) return {\n        state: lang.streamParser.copyState(state),\n        pos: off + tree.length\n    };\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found) return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length) return tree;\n    if (!inside && from == 0 && tree.type == lang.topNode) inside = true;\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n            return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, endPos, editorState) {\n    for (let f of fragments){\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && found.pos <= endPos && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n            state: found.state,\n            tree\n        };\n    }\n    return {\n        state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n        tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n    };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges){\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for(let i = 0; i < tree.children.length; i++){\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */  && ranges.some((r)=>r.from <= context.viewport.from && r.to >= context.viewport.from)) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 512 /* C.ChunkSize */ );\n        if (context) end = Math.min(end, context.viewport.to);\n        while(this.parsedPos < end)this.parseLine(context);\n        if (this.chunkStart < this.parsedPos) this.finishChunk();\n        if (this.parsedPos >= parseEnd) return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1) chunk = chunk.slice(0, eol);\n        } else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for(let index = this.rangeIndex;;){\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end) break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length) break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return {\n            line,\n            end\n        };\n    }\n    skipGapsTo(pos, offset, side) {\n        for(;;){\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos) break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while(this.ranges[this.rangeIndex].to < this.parsedPos)this.rangeIndex++;\n    }\n    emitToken(id, from, to, offset) {\n        let size = 4;\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        let last = this.chunk.length - 4;\n        if (this.lang.streamParser.mergeTokens && size == 4 && last >= 0 && this.chunk[last] == id && this.chunk[last + 2] == from) this.chunk[last + 2] = to;\n        else this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        } else {\n            while(!stream.eol()){\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);\n                if (stream.start > 10000 /* C.MaxLineLength */ ) break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to) this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 512 /* C.ChunkSize */ ,\n            reused: this.chunkReused\n        });\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [\n            [\n                this.lang.stateAfter,\n                this.lang.streamParser.copyState(this.state)\n            ]\n        ]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for(let i = 0; i < 10; i++){\n        let result = token(stream, state);\n        if (stream.pos > stream.start) return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/ Object.create(null);\nconst typeArray = [\n    _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none\n];\nconst nodeSet = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/ Object.create(null);\nconst defaultTable = /*@__PURE__*/ Object.create(null);\nfor (let [legacyName, name] of [\n    [\n        \"variable\",\n        \"variableName\"\n    ],\n    [\n        \"variable-2\",\n        \"variableName.special\"\n    ],\n    [\n        \"string-2\",\n        \"string.special\"\n    ],\n    [\n        \"def\",\n        \"variableName.definition\"\n    ],\n    [\n        \"tag\",\n        \"tagName\"\n    ],\n    [\n        \"attribute\",\n        \"attributeName\"\n    ],\n    [\n        \"type\",\n        \"typeName\"\n    ],\n    [\n        \"builtin\",\n        \"variableName.standard\"\n    ],\n    [\n        \"qualifier\",\n        \"modifier\"\n    ],\n    [\n        \"error\",\n        \"invalid\"\n    ],\n    [\n        \"header\",\n        \"heading\"\n    ],\n    [\n        \"property\",\n        \"propertyName\"\n    ]\n])defaultTable[legacyName] = /*@__PURE__*/ createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra){\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/ new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1) return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tags$1 = [];\n    for (let name of tagStr.split(\" \")){\n        let found = [];\n        for (let part of name.split(\".\")){\n            let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n            if (!value) {\n                warnForPart(part, `Unknown highlighting tag ${part}`);\n            } else if (typeof value == \"function\") {\n                if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);\n                else found = found.map(value);\n            } else {\n                if (found.length) warnForPart(part, `Tag ${part} used as modifier`);\n                else found = Array.isArray(value) ? value : [\n                    value\n                ];\n            }\n        }\n        for (let tag of found)tags$1.push(tag);\n    }\n    if (!tags$1.length) return 0;\n    let name = tagStr.replace(/ /g, \"_\"), key = name + \" \" + tags$1.map((t)=>t.id);\n    let known = byTag[key];\n    if (known) return known.id;\n    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n                [name]: tags$1\n            })\n        ]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data, lang) {\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name: \"Document\",\n        props: [\n            languageDataProp.add(()=>data),\n            indentNodeProp.add(()=>(cx)=>lang.getIndent(cx))\n        ],\n        top: true\n    });\n    typeArray.push(type);\n    return type;\n}\nfunction buildForLine(line) {\n    return line.length <= 4096 && /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/.test(line);\n}\nfunction textHasRTL(text) {\n    for(let i = text.iter(); !i.next().done;)if (buildForLine(i.value)) return true;\n    return false;\n}\nfunction changeAddsRTL(change) {\n    let added = false;\n    change.iterChanges((fA, tA, fB, tB, ins)=>{\n        if (!added && textHasRTL(ins)) added = true;\n    });\n    return added;\n}\nconst alwaysIsolate = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nMake sure nodes\n[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)\nas isolating for bidirectional text are rendered in a way that\nisolates them from the surrounding text.\n*/ function bidiIsolates(options = {}) {\n    let extensions = [\n        isolateMarks\n    ];\n    if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));\n    return extensions;\n}\nconst isolateMarks = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        this.hasRTL = !this.always && textHasRTL(view.state.doc);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    }\n    update(update) {\n        let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;\n        if (!always && !this.hasRTL) return;\n        let tree = syntaxTree(update.state);\n        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {\n            this.tree = tree;\n            this.always = always;\n            this.decorations = buildDeco(update.view, tree, always);\n        }\n    }\n}, {\n    provide: (plugin)=>{\n        function access(view) {\n            var _a, _b;\n            return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        }\n        return [\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))\n        ];\n    }\n});\nfunction buildDeco(view, tree, always) {\n    let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    let ranges = view.visibleRanges;\n    if (!always) ranges = clipRTLLines(ranges, view.state.doc);\n    for (let { from, to } of ranges){\n        tree.iterate({\n            enter: (node)=>{\n                let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);\n                if (iso) deco.add(node.from, node.to, marks[iso]);\n            },\n            from,\n            to\n        });\n    }\n    return deco.finish();\n}\nfunction clipRTLLines(ranges, doc) {\n    let cur = doc.iter(), pos = 0, result = [], last = null;\n    for (let { from, to } of ranges){\n        if (last && last.to > from) {\n            from = last.to;\n            if (from >= to) continue;\n        }\n        if (pos + cur.value.length < from) {\n            cur.next(from - (pos + cur.value.length));\n            pos = from;\n        }\n        for(;;){\n            let start = pos, end = pos + cur.value.length;\n            if (!cur.lineBreak && buildForLine(cur.value)) {\n                if (last && last.to > start - 10) last.to = Math.min(to, end);\n                else result.push(last = {\n                    from: start,\n                    to: Math.min(to, end)\n                });\n            }\n            if (end >= to) break;\n            pos = end;\n            cur.next();\n        }\n    }\n    return result;\n}\nconst marks = {\n    rtl: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"rtl\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL\n    }),\n    ltr: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"ltr\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR\n    }),\n    auto: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"auto\"\n        },\n        bidiIsolate: null\n    })\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3IrbGFuZ3VhZ2VANi4xMi4xL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5ndWFnZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtHO0FBQzJDO0FBQ1o7QUFDL0M7QUFDMUM7QUFFeEMsSUFBSTZCO0FBQ0o7OztBQUdBLEdBQ0EsTUFBTUMsbUJBQW1CLFdBQVcsR0FBRSxJQUFJOUIsbURBQVFBO0FBQ2xEOzs7Ozs7O0FBT0EsR0FDQSxTQUFTK0Isb0JBQW9CQyxRQUFRO0lBQ2pDLE9BQU92QixvREFBS0EsQ0FBQ3dCLE1BQU0sQ0FBQztRQUNoQkMsU0FBU0YsV0FBV0csQ0FBQUEsU0FBVUEsT0FBT0MsTUFBTSxDQUFDSixZQUFZSztJQUM1RDtBQUNKO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTUMsa0JBQWtCLFdBQVcsR0FBRSxJQUFJdEMsbURBQVFBO0FBQ2pEOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTXVDO0lBQ0Y7Ozs7OztJQU1BLEdBQ0FDLFlBQ0E7OztJQUdBLEdBQ0FDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRSxFQUNsQzs7SUFFQSxHQUNBQyxPQUFPLEVBQUUsQ0FBRTtRQUNQLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0csSUFBSSxHQUFHQTtRQUNaLDJEQUEyRDtRQUMzRCx5REFBeUQ7UUFDekQsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ2xDLDBEQUFXQSxDQUFDbUMsU0FBUyxDQUFDQyxjQUFjLENBQUMsU0FDdENDLE9BQU9DLGNBQWMsQ0FBQ3RDLDBEQUFXQSxDQUFDbUMsU0FBUyxFQUFFLFFBQVE7WUFBRUk7Z0JBQVEsT0FBT0MsV0FBVyxJQUFJO1lBQUc7UUFBRTtRQUM5RixJQUFJLENBQUNSLE1BQU0sR0FBR0E7UUFDZCxJ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QUMzQyxJQUFJd0wsUUFBUUEsS0FBS3BQLEVBQUUsR0FBR2lOLFFBQVEsSUFDMUJtQyxLQUFLcFAsRUFBRSxHQUFHa0gsS0FBS0MsR0FBRyxDQUFDbkgsSUFBSXFTO3FCQUV2QmpTLE9BQU9HLElBQUksQ0FBQzZPLE9BQU87b0JBQUUxUCxNQUFNdU47b0JBQU9qTixJQUFJa0gsS0FBS0MsR0FBRyxDQUFDbkgsSUFBSXFTO2dCQUFLO1lBQ2hFO1lBQ0EsSUFBSUEsT0FBT3JTLElBQ1A7WUFDSmpCLE1BQU1zVDtZQUNOL0UsSUFBSTNKLElBQUk7UUFDWjtJQUNKO0lBQ0EsT0FBT3ZEO0FBQ1g7QUFDQSxNQUFNMm9CLFFBQVE7SUFDVkUsS0FBSyxXQUFXLEdBQUV2c0Isd0RBQVVBLENBQUMrYixJQUFJLENBQUM7UUFBRUUsT0FBTztRQUFVdVEsV0FBVztRQUFNQyxZQUFZO1lBQUUxSyxLQUFLO1FBQU07UUFBRzJLLGFBQWF0c0IsdURBQVNBLENBQUN1c0IsR0FBRztJQUFDO0lBQzdIQyxLQUFLLFdBQVcsR0FBRTVzQix3REFBVUEsQ0FBQytiLElBQUksQ0FBQztRQUFFRSxPQUFPO1FBQVV1USxXQUFXO1FBQU1DLFlBQVk7WUFBRTFLLEtBQUs7UUFBTTtRQUFHMkssYUFBYXRzQix1REFBU0EsQ0FBQ3FyQixHQUFHO0lBQUM7SUFDN0hvQixNQUFNLFdBQVcsR0FBRTdzQix3REFBVUEsQ0FBQytiLElBQUksQ0FBQztRQUFFRSxPQUFPO1FBQVV1USxXQUFXO1FBQU1DLFlBQVk7WUFBRTFLLEtBQUs7UUFBTztRQUFHMkssYUFBYTtJQUFLO0FBQzFIO0FBRXd5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK2xhbmd1YWdlQDYuMTIuMS9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcz9jZDBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wLCBJdGVyTW9kZSwgVHJlZSwgVHJlZUZyYWdtZW50LCBQYXJzZXIsIE5vZGVUeXBlLCBOb2RlU2V0IH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRmFjZXQsIEVkaXRvclN0YXRlLCBjb3VudENvbHVtbiwgY29tYmluZUNvbmZpZywgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUHJlYyB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgRWRpdG9yVmlldywgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwgZ3V0dGVyLCBHdXR0ZXJNYXJrZXIsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuXG52YXIgX2E7XG4vKipcbk5vZGUgcHJvcCBzdG9yZWQgaW4gYSBwYXJzZXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuU3ludGF4IG5vZGUgcHJvcCB1c2VkIHRvIHJlZ2lzdGVyIHN1Ymxhbmd1YWdlcy4gU2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdG9wIGxldmVsIG5vZGUgdHlwZSBmb3IgdGhlIGxhbmd1YWdlLlxuKi9cbmNvbnN0IHN1Ymxhbmd1YWdlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFRoZSBjbGFzc1xuY2FuIGJlIHVzZWQgZGlyZWN0bHksIHZpYSB0aGUgW2BMUkxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MUkxhbmd1YWdlKVxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXG52aWEgdGhlIFtgU3RyZWFtTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbUxhbmd1YWdlKSBzdWJjbGFzc1xuZm9yIHN0cmVhbSBwYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gICAgZGlyZWN0bHksIGZpcnN0IGRlZmluZSBhIGRhdGEgZmFjZXQgd2l0aFxuICAgIFtgZGVmaW5lTGFuZ3VhZ2VGYWNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCksIGFuZCB0aGVuXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgICB0byB0aGUgbGFuZ3VhZ2UncyBvdXRlciBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZmFjZXRcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBleHRyYUV4dGVuc2lvbnMgPSBbXSwgXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBuYW1lLlxuICAgICovXG4gICAgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSwgZGF0YSA9IHRvcC50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBzdGF0ZS5mYWNldChkYXRhKSwgc3ViID0gdG9wLnR5cGUucHJvcChzdWJsYW5ndWFnZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZSA9IHRvcC5yZXNvbHZlKHBvcyAtIHRvcC5mcm9tLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VibGFuZyBvZiBzdWIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibGFuZy50ZXN0KGlubmVyTm9kZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBzdGF0ZS5mYWNldChzdWJsYW5nLmZhY2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibGFuZy50eXBlID09IFwicmVwbGFjZVwiID8gZGF0YSA6IGRhdGEuY29uY2F0KGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0uY29uY2F0KGV4dHJhRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBpcyBhY3RpdmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCByZWdpb25zIHRoYXQgd2VyZSBwYXJzZWQgdXNpbmcgdGhpcyBsYW5ndWFnZS5cbiAgICBUaGUgcmV0dXJuZWQgcmVnaW9ucyB3aWxsIF9pbmNsdWRlXyBhbnkgbmVzdGVkIGxhbmd1YWdlcyByb290ZWRcbiAgICBpbiB0aGlzIGxhbmd1YWdlLCB3aGVuIHRob3NlIGV4aXN0LlxuICAgICovXG4gICAgZmluZFJlZ2lvbnMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgIGlmICgobGFuZyA9PT0gbnVsbCB8fCBsYW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYW5nLmRhdGEpID09IHRoaXMuZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiAwLCB0bzogc3RhdGUuZG9jLmxlbmd0aCB9XTtcbiAgICAgICAgaWYgKCFsYW5nIHx8ICFsYW5nLmFsbG93c05lc3RpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAodHJlZSwgZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdW50ID0gdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgaWYgKG1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50LnRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiByLmZyb20gKyBmcm9tLCB0bzogci50byArIGZyb20gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiBzaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShjaCwgdHJlZS5wb3NpdGlvbnNbaV0gKyBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwbG9yZShzeW50YXhUcmVlKHN0YXRlKSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgYWxsb3dzIG5lc3RlZCBsYW5ndWFnZXMuIFRoZVxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAgICovXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0cnVlOyB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkxhbmd1YWdlLnNldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKSwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7XG4gICAgaWYgKCF0b3BMYW5nIHx8IHRvcExhbmcuYWxsb3dzTmVzdGluZykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdHJlZTsgbm9kZTsgbm9kZSA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycyB8IEl0ZXJNb2RlLkVudGVyQnJhY2tldGVkKSlcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuaXNUb3ApXG4gICAgICAgICAgICAgICAgdHJlZSA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0cmVlO1xufVxuLyoqXG5BIHN1YmNsYXNzIG9mIFtgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBmb3IgdXNlIHdpdGggTGV6ZXJcbltMUiBwYXJzZXJzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2xyLkxSUGFyc2VyKVxucGFyc2Vycy5cbiovXG5jbGFzcyBMUkxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHBhcnNlciwgbmFtZSkge1xuICAgICAgICBzdXBlcihkYXRhLCBwYXJzZXIsIFtdLCBuYW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIGxhbmd1YWdlIGZyb20gYSBwYXJzZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHNwZWMubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKGRhdGEsIHNwZWMucGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKHR5cGUgPT4gdHlwZS5pc1RvcCA/IGRhdGEgOiB1bmRlZmluZWQpXVxuICAgICAgICB9KSwgc3BlYy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbGFuZ3VhZ2Ugd2l0aCBhIHJlY29uZmlndXJlZFxuICAgIHZlcnNpb24gb2YgaXRzIHBhcnNlciBhbmQgb3B0aW9uYWxseSBhIG5ldyBuYW1lLlxuICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKG9wdGlvbnMpLCBuYW1lIHx8IHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdGhpcy5wYXJzZXIuaGFzV3JhcHBlcnMoKTsgfVxufVxuLyoqXG5HZXQgdGhlIHN5bnRheCB0cmVlIGZvciBhIHN0YXRlLCB3aGljaCBpcyB0aGUgY3VycmVudCAocG9zc2libHlcbmluY29tcGxldGUpIHBhcnNlIHRyZWUgb2YgdGhlIGFjdGl2ZVxuW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSwgb3IgdGhlIGVtcHR5IHRyZWUgaWYgdGhlcmUgaXMgbm9cbmxhbmd1YWdlIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlKHN0YXRlKSB7XG4gICAgbGV0IGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmllbGQgPyBmaWVsZC50cmVlIDogVHJlZS5lbXB0eTtcbn1cbi8qKlxuVHJ5IHRvIGdldCBhIHBhcnNlIHRyZWUgdGhhdCBzcGFucyBhdCBsZWFzdCB1cCB0byBgdXB0b2AuIFRoZVxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcbnVwIHRvIHRoYXQgcG9pbnQgaWYgdGhlIHRyZWUgaXNuJ3QgYWxyZWFkeSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJzZSA9IChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0O1xuICAgIGlmICghcGFyc2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvbGRWaWVwb3J0ID0gcGFyc2Uudmlld3BvcnQ7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQoeyBmcm9tOiAwLCB0bzogdXB0byB9KTtcbiAgICBsZXQgcmVzdWx0ID0gcGFyc2UuaXNEb25lKHVwdG8pIHx8IHBhcnNlLndvcmsodGltZW91dCwgdXB0bykgPyBwYXJzZS50cmVlIDogbnVsbDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydChvbGRWaWVwb3J0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5RdWVyaWVzIHdoZXRoZXIgdGhlcmUgaXMgYSBmdWxsIHN5bnRheCB0cmVlIGF2YWlsYWJsZSB1cCB0byB0aGVcbmdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBJZiB0aGVyZSBpc24ndCwgdGhlIGJhY2tncm91bmQgcGFyc2VcbnByb2Nlc3MgX21pZ2h0XyBzdGlsbCBiZSB3b3JraW5nIGFuZCB1cGRhdGUgdGhlIHRyZWUgZnVydGhlciwgYnV0XG50aGVyZSBpcyBubyBndWFyYW50ZWUgb2YgdGhhdOKAlHRoZSBwYXJzZXIgd2lsbCBbc3RvcFxud29ya2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhQYXJzZXJSdW5uaW5nKSB3aGVuIGl0IGhhcyBzcGVudCBhXG5jZXJ0YWluIGFtb3VudCBvZiB0aW1lIG9yIGhhcyBtb3ZlZCBiZXlvbmQgdGhlIHZpc2libGUgdmlld3BvcnQuXG5BbHdheXMgcmV0dXJucyBmYWxzZSBpZiBubyBsYW5ndWFnZSBoYXMgYmVlbiBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWVBdmFpbGFibGUoc3RhdGUsIHVwdG8gPSBzdGF0ZS5kb2MubGVuZ3RoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQuaXNEb25lKHVwdG8pKSB8fCBmYWxzZTtcbn1cbi8qKlxuTW92ZSBwYXJzaW5nIGZvcndhcmQsIGFuZCB1cGRhdGUgdGhlIGVkaXRvciBzdGF0ZSBhZnRlcndhcmRzIHRvXG5yZWZsZWN0IHRoZSBuZXcgdHJlZS4gV2lsbCB3b3JrIGZvciBhdCBtb3N0IGB0aW1lb3V0YFxubWlsbGlzZWNvbmRzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcnNlciBtYW5hZ2VkIGdldCB0byB0aGUgZ2l2ZW5cbnBvc2l0aW9uIGluIHRoYXQgdGltZS5cbiovXG5mdW5jdGlvbiBmb3JjZVBhcnNpbmcodmlldywgdXB0byA9IHZpZXcudmlld3BvcnQudG8sIHRpbWVvdXQgPSAxMDApIHtcbiAgICBsZXQgc3VjY2VzcyA9IGVuc3VyZVN5bnRheFRyZWUodmlldy5zdGF0ZSwgdXB0bywgdGltZW91dCk7XG4gICAgaWYgKHN1Y2Nlc3MgIT0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7fSk7XG4gICAgcmV0dXJuICEhc3VjY2Vzcztcbn1cbi8qKlxuVGVsbHMgeW91IHdoZXRoZXIgdGhlIGxhbmd1YWdlIHBhcnNlciBpcyBwbGFubmluZyB0byBkbyBtb3JlXG5wYXJzaW5nIHdvcmsgKGluIGEgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHBzZXVkby10aHJlYWQpIG9yIGhhc1xuc3RvcHBlZCBydW5uaW5nLCBlaXRoZXIgYmVjYXVzZSBpdCBwYXJzZWQgdGhlIGVudGlyZSBkb2N1bWVudCxcbmJlY2F1c2UgaXQgc3BlbnQgdG9vIG11Y2ggdGltZSBhbmQgd2FzIGN1dCBvZmYsIG9yIGJlY2F1c2UgdGhlcmVcbmlzIG5vIGxhbmd1YWdlIHBhcnNlciBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFBhcnNlclJ1bm5pbmcodmlldykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBhcnNlV29ya2VyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzV29ya2luZygpKSB8fCBmYWxzZTtcbn1cbi8qKlxuTGV6ZXItc3R5bGVcbltgSW5wdXRgXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2NvbW1vbi5JbnB1dClcbm9iamVjdCBmb3IgYSBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIG9iamVjdC5cbiovXG5jbGFzcyBEb2NJbnB1dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGlucHV0IG9iamVjdCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5kb2MubGVuZ3RoOyB9XG4gICAgc3luY1RvKHBvcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHRoaXMuY3Vyc29yLm5leHQocG9zIC0gdGhpcy5jdXJzb3JQb3MpLnZhbHVlO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcyArIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBjaHVuayhwb3MpIHtcbiAgICAgICAgdGhpcy5zeW5jVG8ocG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzdHJpbmdTdGFydCA9IHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbSA8IHN0cmluZ1N0YXJ0IHx8IHRvID49IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20gLSBzdHJpbmdTdGFydCwgdG8gLSBzdHJpbmdTdGFydCk7XG4gICAgfVxufVxubGV0IGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcbi8qKlxuQSBwYXJzZSBjb250ZXh0IHByb3ZpZGVkIHRvIHBhcnNlcnMgd29ya2luZyBvbiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4qL1xuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUcmVlIGZyYWdtZW50cyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgaW5jcmVtZW50YWwgcmUtcGFyc2VzLlxuICAgICovXG4gICAgZnJhZ21lbnRzID0gW10sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlTGVuLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igdmlld3BvcnQgKG9yIHNvbWUgb3ZlcmFwcHJveGltYXRpb25cbiAgICB0aGVyZW9mKS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBmb3Igb3Bwb3J0dW5pc3RpY2FsbHkgYXZvaWRpbmdcbiAgICB3b3JrIChpbiB3aGljaCBjYXNlXG4gICAgW2Bza2lwVW50aWxJblZpZXdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlBhcnNlQ29udGV4dC5za2lwVW50aWxJblZpZXcpXG4gICAgc2hvdWxkIGJlIGNhbGxlZCB0byBtYWtlIHN1cmUgdGhlIHBhcnNlciBpcyByZXN0YXJ0ZWQgd2hlbiB0aGVcbiAgICBza2lwcGVkIHJlZ2lvbiBiZWNvbWVzIHZpc2libGUpLlxuICAgICovXG4gICAgdmlld3BvcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2tpcHBlZCwgXG4gICAgLyoqXG4gICAgVGhpcyBpcyB3aGVyZSBza2lwcGluZyBwYXJzZXJzIGNhbiByZWdpc3RlciBhIHByb21pc2UgdGhhdCxcbiAgICB3aGVuIHJlc29sdmVkLCB3aWxsIHNjaGVkdWxlIGEgbmV3IHBhcnNlLiBJdCBpcyBjbGVhcmVkIHdoZW5cbiAgICB0aGUgcGFyc2Ugd29ya2VyIHBpY2tzIHVwIHRoZSBwcm9taXNlLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjaGVkdWxlT24pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMudHJlZUxlbiA9IHRyZWVMZW47XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy5za2lwcGVkID0gc2tpcHBlZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU9uID0gc2NoZWR1bGVPbjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wU2tpcHBlZCA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyc2VyLCBzdGF0ZSwgdmlld3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQocGFyc2VyLCBzdGF0ZSwgW10sIFRyZWUuZW1wdHksIDAsIHZpZXdwb3J0LCBbXSwgbnVsbCk7XG4gICAgfVxuICAgIHN0YXJ0UGFyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dCh0aGlzLnN0YXRlLmRvYyksIHRoaXMuZnJhZ21lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3b3JrKHVudGlsLCB1cHRvKSB7XG4gICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgdXB0byA+PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB1cHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy50cmVlICE9IFRyZWUuZW1wdHkgJiYgdGhpcy5pc0RvbmUodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bnRpbCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgdW50aWw7XG4gICAgICAgICAgICAgICAgdW50aWwgPSAoKSA9PiBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICBpZiAodXB0byAhPSBudWxsICYmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gdXB0bykgJiZcbiAgICAgICAgICAgICAgICB1cHRvIDwgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHVwdG8pO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZShkb25lLCB0aGlzLmZyYWdtZW50cywgdGhpcy5wYXJzZS5zdG9wcGVkQXQgIT0gbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSAoX2EgPSB0aGlzLnBhcnNlLnN0b3BwZWRBdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJlZUxlbiA8ICh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVudGlsKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdGFrZVRyZWUoKSB7XG4gICAgICAgIGxldCBwb3MsIHRyZWU7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlICYmIChwb3MgPSB0aGlzLnBhcnNlLnBhcnNlZFBvcykgPj0gdGhpcy50cmVlTGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHBvcylcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICAgICAgdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7IHdoaWxlICghKHRyZWUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKSkpIHsgfSB9KTtcbiAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IHBvcztcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKHRoaXMudHJlZSwgdGhpcy5mcmFnbWVudHMsIHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb250ZXh0KGYpIHtcbiAgICAgICAgbGV0IHByZXYgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgY3VycmVudENvbnRleHQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gcHJldjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRob3V0VGVtcFNraXBwZWQoZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHI7IHIgPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOylcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIHIuZnJvbSwgci50byk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hhbmdlcyhjaGFuZ2VzLCBuZXdTdGF0ZSkge1xuICAgICAgICBsZXQgeyBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgIGlmICghY2hhbmdlcy5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gcmFuZ2VzLnB1c2goeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0pKTtcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgdHJlZSA9IFRyZWUuZW1wdHk7XG4gICAgICAgICAgICB0cmVlTGVuID0gMDtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0geyBmcm9tOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSkgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5za2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Moci5mcm9tLCAxKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyhyLnRvLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQodGhpcy5wYXJzZXIsIG5ld1N0YXRlLCBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkLCB0aGlzLnNjaGVkdWxlT24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVwZGF0ZVZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmZyb20gPT0gdmlld3BvcnQuZnJvbSAmJiB0aGlzLnZpZXdwb3J0LnRvID09IHZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBzdGFydExlbiA9IHRoaXMuc2tpcHBlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5za2lwcGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5za2lwcGVkW2ldO1xuICAgICAgICAgICAgaWYgKGZyb20gPCB2aWV3cG9ydC50byAmJiB0byA+IHZpZXdwb3J0LmZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyh0aGlzLmZyYWdtZW50cywgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcHBlZC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCA+PSBzdGFydExlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE5vdGlmeSB0aGUgcGFyc2Ugc2NoZWR1bGVyIHRoYXQgdGhlIGdpdmVuIHJlZ2lvbiB3YXMgc2tpcHBlZFxuICAgIGJlY2F1c2UgaXQgd2Fzbid0IGluIHZpZXcsIGFuZCB0aGUgcGFyc2Ugc2hvdWxkIGJlIHJlc3RhcnRlZFxuICAgIHdoZW4gaXQgY29tZXMgaW50byB2aWV3LlxuICAgICovXG4gICAgc2tpcFVudGlsSW5WaWV3KGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBwYXJzZXIgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBwbGFjZWhvbGRlciB3aGVuXG4gICAgYXN5bmNocm9ub3VzbHkgbG9hZGluZyBhIG5lc3RlZCBwYXJzZXIuIEl0J2xsIHNraXAgaXRzIGlucHV0IGFuZFxuICAgIG1hcmsgaXQgYXMgbm90LXJlYWxseS1wYXJzZWQsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcGFyc2VcbiAgICBpdCBhZ2Fpbi5cbiAgICBcbiAgICBXaGVuIGB1bnRpbGAgaXMgZ2l2ZW4sIGEgcmVwYXJzZSB3aWxsIGJlIHNjaGVkdWxlZCB3aGVuIHRoYXRcbiAgICBwcm9taXNlIHJlc29sdmVzLlxuICAgICovXG4gICAgc3RhdGljIGdldFNraXBwaW5nUGFyc2VyKHVudGlsKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbMF0uZnJvbSwgdG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFBvczogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnRlbXBTa2lwcGVkLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVudGlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gY3guc2NoZWR1bGVPbiA/IFByb21pc2UuYWxsKFtjeC5zY2hlZHVsZU9uLCB1bnRpbF0pIDogdW50aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdG8gLSBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZEF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQoKSB7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNEb25lKHVwdG8pIHtcbiAgICAgICAgdXB0byA9IE1hdGgubWluKHVwdG8sIHRoaXMuc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBmcmFncyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlTGVuID49IHVwdG8gJiYgZnJhZ3MubGVuZ3RoICYmIGZyYWdzWzBdLmZyb20gPT0gMCAmJiBmcmFnc1swXS50byA+PSB1cHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHBhcnNlLCBvciBgbnVsbGAgaWYgbm8gZWRpdG9yXG4gICAgcGFyc2UgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KCkgeyByZXR1cm4gY3VycmVudENvbnRleHQ7IH1cbn1cbmZ1bmN0aW9uIGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBbeyBmcm9tQTogZnJvbSwgdG9BOiB0bywgZnJvbUI6IGZyb20sIHRvQjogdG8gfV0pO1xufVxuY2xhc3MgTGFuZ3VhZ2VTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gQSBtdXRhYmxlIHBhcnNlIHN0YXRlIHRoYXQgaXMgdXNlZCB0byBwcmVzZXJ2ZSB3b3JrIGRvbmUgZHVyaW5nXG4gICAgLy8gdGhlIGxpZmV0aW1lIG9mIGEgc3RhdGUgd2hlbiBtb3ZpbmcgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRyZWUgPSBjb250ZXh0LnRyZWU7XG4gICAgfVxuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiB0aGlzLnRyZWUgPT0gdGhpcy5jb250ZXh0LnRyZWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IG5ld0N4ID0gdGhpcy5jb250ZXh0LmNoYW5nZXModHIuY2hhbmdlcywgdHIuc3RhdGUpO1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcGFyc2Ugd2Fzbid0IGRvbmUsIGdvIGZvcndhcmQgb25seSB1cCB0byBpdHNcbiAgICAgICAgLy8gZW5kIHBvc2l0aW9uIG9yIHRoZSBlbmQgb2YgdGhlIHZpZXdwb3J0LCB0byBhdm9pZCBzbG93aW5nIGRvd25cbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlcyB3aXRoIHBhcnNlIHdvcmsgYmV5b25kIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgbGV0IHVwdG8gPSB0aGlzLmNvbnRleHQudHJlZUxlbiA9PSB0ci5zdGFydFN0YXRlLmRvYy5sZW5ndGggPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogTWF0aC5tYXgodHIuY2hhbmdlcy5tYXBQb3ModGhpcy5jb250ZXh0LnRyZWVMZW4pLCBuZXdDeC52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICghbmV3Q3gud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB1cHRvKSlcbiAgICAgICAgICAgIG5ld0N4LnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShuZXdDeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2cFRvID0gTWF0aC5taW4oMzAwMCAvKiBXb3JrLkluaXRWaWV3cG9ydCAqLywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gUGFyc2VDb250ZXh0LmNyZWF0ZShzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgeyBmcm9tOiAwLCB0bzogdnBUbyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZVN0YXRlLndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdnBUbykpXG4gICAgICAgICAgICBwYXJzZVN0YXRlLnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShwYXJzZVN0YXRlKTtcbiAgICB9XG59XG5MYW5ndWFnZS5zdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlOiBMYW5ndWFnZVN0YXRlLmluaXQsXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhMYW5ndWFnZS5zZXRTdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIGlmICh0ci5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB0ci5zdGF0ZS5mYWNldChsYW5ndWFnZSkpXG4gICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2VTdGF0ZS5pbml0KHRyLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRyKTtcbiAgICB9XG59KTtcbmxldCByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjaygpLCA1MDAgLyogV29yay5NYXhQYXVzZSAqLyk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn07XG5pZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgaWRsZSA9IC0xLCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZGxlID0gcmVxdWVzdElkbGVDYWxsYmFjayhjYWxsYmFjaywgeyB0aW1lb3V0OiA1MDAgLyogV29yay5NYXhQYXVzZSAqLyAtIDEwMCAvKiBXb3JrLk1pblBhdXNlICovIH0pO1xuICAgICAgICB9LCAxMDAgLyogV29yay5NaW5QYXVzZSAqLyk7XG4gICAgICAgIHJldHVybiAoKSA9PiBpZGxlIDwgMCA/IGNsZWFyVGltZW91dCh0aW1lb3V0KSA6IGNhbmNlbElkbGVDYWxsYmFjayhpZGxlKTtcbiAgICB9O1xuY29uc3QgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgKChfYSA9IG5hdmlnYXRvci5zY2hlZHVsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNJbnB1dFBlbmRpbmcpXG4gICAgPyAoKSA9PiBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZygpIDogbnVsbDtcbmNvbnN0IHBhcnNlV29ya2VyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIFBhcnNlV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCA9IDA7XG4gICAgICAgIC8vIEVuZCBvZiB0aGUgY3VycmVudCB0aW1lIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtFbmQgPSAtMTtcbiAgICAgICAgLy8gTWlsbGlzZWNvbmRzIG9mIGJ1ZGdldCBsZWZ0IGZvciB0aGlzIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAtMTtcbiAgICAgICAgdGhpcy53b3JrID0gdGhpcy53b3JrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGN4ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKS5jb250ZXh0O1xuICAgICAgICBpZiAoY3gudXBkYXRlVmlld3BvcnQodXBkYXRlLnZpZXcudmlld3BvcnQpIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA+IGN4LnRyZWVMZW4pXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5oYXNGb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ICs9IDUwIC8qIFdvcmsuQ2hhbmdlQm9udXMgKi87XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGN4KTtcbiAgICB9XG4gICAgc2NoZWR1bGVXb3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgIT0gZmllbGQuY29udGV4dC50cmVlIHx8ICFmaWVsZC5jb250ZXh0LmlzRG9uZShzdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yayk7XG4gICAgfVxuICAgIHdvcmsoZGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rRW5kIDwgbm93ICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpKSB7IC8vIFN0YXJ0IGEgbmV3IGNodW5rXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogV29yay5DaHVua1RpbWUgKi87XG4gICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gMzAwMCAvKiBXb3JrLkNodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCAxMDAgLyogV29yay5TbGljZSAqLywgZGVhZGxpbmUgJiYgIWlzSW5wdXRQZW5kaW5nID8gTWF0aC5tYXgoMjUgLyogV29yay5NaW5TbGljZSAqLywgZGVhZGxpbmUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpO1xuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xuICAgICAgICBsZXQgZG9uZSA9IGZpZWxkLmNvbnRleHQud29yaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNJbnB1dFBlbmRpbmcgJiYgaXNJbnB1dFBlbmRpbmcoKSB8fCBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKTtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCAtPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICBpZiAoZG9uZSB8fCB0aGlzLmNodW5rQnVkZ2V0IDw9IDApIHtcbiAgICAgICAgICAgIGZpZWxkLmNvbnRleHQudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IExhbmd1YWdlLnNldFN0YXRlLm9mKG5ldyBMYW5ndWFnZVN0YXRlKGZpZWxkLmNvbnRleHQpKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA+IDAgJiYgIShkb25lICYmICF2aWV3cG9ydEZpcnN0KSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGZpZWxkLmNvbnRleHQpO1xuICAgIH1cbiAgICBjaGVja0FzeW5jU2NoZWR1bGUoY3gpIHtcbiAgICAgICAgaWYgKGN4LnNjaGVkdWxlT24pIHtcbiAgICAgICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCsrO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPblxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMud29ya1NjaGVkdWxlZC0tKTtcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcoKTtcbiAgICB9XG4gICAgaXNXb3JraW5nKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy53b3JraW5nIHx8IHRoaXMud29ya1NjaGVkdWxlZCA+IDApO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7IGZvY3VzKCkgeyB0aGlzLnNjaGVkdWxlV29yaygpOyB9IH1cbn0pO1xuLyoqXG5UaGUgZmFjZXQgdXNlZCB0byBhc3NvY2lhdGUgYSBsYW5ndWFnZSB3aXRoIGFuIGVkaXRvciBzdGF0ZS4gVXNlZFxuYnkgYExhbmd1YWdlYCBvYmplY3QncyBgZXh0ZW5zaW9uYCBwcm9wZXJ0eSAoc28geW91IGRvbid0IG5lZWQgdG9cbm1hbnVhbGx5IHdyYXAgeW91ciBsYW5ndWFnZXMgaW4gdGhpcykuIENhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGVcbmN1cnJlbnQgbGFuZ3VhZ2Ugb24gYSBzdGF0ZS5cbiovXG5jb25zdCBsYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobGFuZ3VhZ2VzKSB7IHJldHVybiBsYW5ndWFnZXMubGVuZ3RoID8gbGFuZ3VhZ2VzWzBdIDogbnVsbDsgfSxcbiAgICBlbmFibGVzOiBsYW5ndWFnZSA9PiBbXG4gICAgICAgIExhbmd1YWdlLnN0YXRlLFxuICAgICAgICBwYXJzZVdvcmtlcixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5jb21wdXRlKFtsYW5ndWFnZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcgJiYgbGFuZy5uYW1lID8geyBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZy5uYW1lIH0gOiB7fTtcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbi8qKlxuVGhpcyBjbGFzcyBidW5kbGVzIGEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSB3aXRoIGFuXG5vcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBMYW5ndWFnZSBwYWNrYWdlcyBhcmVcbmVuY291cmFnZWQgdG8gZXhwb3J0IGEgZnVuY3Rpb24gdGhhdCBvcHRpb25hbGx5IHRha2VzIGFcbmNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCByZXR1cm5zIGEgYExhbmd1YWdlU3VwcG9ydGAgaW5zdGFuY2UsIGFzXG50aGUgbWFpbiB3YXkgZm9yIGNsaWVudCBjb2RlIHRvIHVzZSB0aGUgcGFja2FnZS5cbiovXG5jbGFzcyBMYW5ndWFnZVN1cHBvcnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIHN1cHBvcnQgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICAqL1xuICAgIGxhbmd1YWdlLCBcbiAgICAvKipcbiAgICBBbiBvcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBXaGVuIG5lc3RpbmcgYVxuICAgIGxhbmd1YWdlIGluIGFub3RoZXIgbGFuZ3VhZ2UsIHRoZSBvdXRlciBsYW5ndWFnZSBpcyBlbmNvdXJhZ2VkXG4gICAgdG8gaW5jbHVkZSB0aGUgc3VwcG9ydGluZyBleHRlbnNpb25zIGZvciBpdHMgaW5uZXIgbGFuZ3VhZ2VzXG4gICAgaW4gaXRzIG93biBzZXQgb2Ygc3VwcG9ydCBleHRlbnNpb25zLlxuICAgICovXG4gICAgc3VwcG9ydCA9IFtdKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbbGFuZ3VhZ2UsIHN1cHBvcnRdO1xuICAgIH1cbn1cbi8qKlxuTGFuZ3VhZ2UgZGVzY3JpcHRpb25zIGFyZSB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0IGxhbmd1YWdlc1xuYW5kIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlbS4gVGhlaXIgbWFpbiByb2xlIGlzIGZpbmRpbmcgdGhlXG5hcHByb3ByaWF0ZSBsYW5ndWFnZSBmb3IgYSBmaWxlbmFtZSBvciBkeW5hbWljYWxseSBsb2FkaW5nIG5lc3RlZFxucGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZURlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQWx0ZXJuYXRpdmUgbmFtZXMgZm9yIHRoZSBtb2RlIChsb3dlcmNhc2VkLCBpbmNsdWRlcyBgdGhpcy5uYW1lYCkuXG4gICAgKi9cbiAgICBhbGlhcywgXG4gICAgLyoqXG4gICAgRmlsZSBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZXh0ZW5zaW9ucywgXG4gICAgLyoqXG4gICAgT3B0aW9uYWwgZmlsZW5hbWUgcGF0dGVybiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgIGxhbmd1YWdlLlxuICAgICovXG4gICAgZmlsZW5hbWUsIGxvYWRGdW5jLCBcbiAgICAvKipcbiAgICBJZiB0aGUgbGFuZ3VhZ2UgaGFzIGJlZW4gbG9hZGVkLCB0aGlzIHdpbGwgaG9sZCBpdHMgdmFsdWUuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmxvYWRGdW5jID0gbG9hZEZ1bmM7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGxvYWRpbmcgdGhlIHRoZSBsYW5ndWFnZS4gV2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXRcbiAgICByZXNvbHZlcyB0byBhIFtgTGFuZ3VhZ2VTdXBwb3J0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQpXG4gICAgb2JqZWN0IHdoZW4gdGhlIGxhbmd1YWdlIHN1Y2Nlc3NmdWxseSBsb2Fkcy5cbiAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmcgfHwgKHRoaXMubG9hZGluZyA9IHRoaXMubG9hZEZ1bmMoKS50aGVuKHN1cHBvcnQgPT4gdGhpcy5zdXBwb3J0ID0gc3VwcG9ydCwgZXJyID0+IHsgdGhpcy5sb2FkaW5nID0gbnVsbDsgdGhyb3cgZXJyOyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIGRlc2NyaXB0aW9uLlxuICAgICovXG4gICAgc3RhdGljIG9mKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgbG9hZCwgc3VwcG9ydCB9ID0gc3BlYztcbiAgICAgICAgaWYgKCFsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdXN0IHBhc3MgZWl0aGVyICdsb2FkJyBvciAnc3VwcG9ydCcgdG8gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5vZlwiKTtcbiAgICAgICAgICAgIGxvYWQgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZURlc2NyaXB0aW9uKHNwZWMubmFtZSwgKHNwZWMuYWxpYXMgfHwgW10pLmNvbmNhdChzcGVjLm5hbWUpLm1hcChzID0+IHMudG9Mb3dlckNhc2UoKSksIHNwZWMuZXh0ZW5zaW9ucyB8fCBbXSwgc3BlYy5maWxlbmFtZSwgbG9hZCwgc3VwcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGgsIGFzIGEgY29sdW1uIG51bWJlciAoc2VlXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSksIGF0IHRoZSBzdGFydCBvZiBhIGdpdmVuXG5saW5lLiBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgaW5kaWNhdGVzIG5vIGluZGVudGF0aW9uIGNhbiBiZVxuZGV0ZXJtaW5lZCwgYW5kIHRoZSBsaW5lIHNob3VsZCBpbmhlcml0IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgb25lXG5hYm92ZSBpdC4gQSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgZGVmZXJzIHRvIHRoZSBuZXh0IGluZGVudFxuc2VydmljZS5cbiovXG5jb25zdCBpbmRlbnRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCBmb3Igb3ZlcnJpZGluZyB0aGUgdW5pdCBieSB3aGljaCBpbmRlbnRhdGlvbiBoYXBwZW5zLiBTaG91bGRcbmJlIGEgc3RyaW5nIGNvbnNpc3RpbmcgZW50aXJlbHkgb2YgdGhlIHNhbWUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG5XaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCI7XG4gICAgICAgIGxldCB1bml0ID0gdmFsdWVzWzBdO1xuICAgICAgICBpZiAoIXVuaXQgfHwgL1xcUy8udGVzdCh1bml0KSB8fCBBcnJheS5mcm9tKHVuaXQpLnNvbWUoZSA9PiBlICE9IHVuaXRbMF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbMF0pKTtcbiAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxufSk7XG4vKipcblJldHVybiB0aGUgX2NvbHVtbiB3aWR0aF8gb2YgYW4gaW5kZW50IHVuaXQgaW4gdGhlIHN0YXRlLlxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxuZmFjZXQsIGFuZCBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIHdoZW4gdGhhdFxuY29udGFpbnMgdGFicy5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRVbml0KHN0YXRlKSB7XG4gICAgbGV0IHVuaXQgPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxuV2lsbCB1c2UgdGFicyBmb3IgYXMgbXVjaCBvZiB0aGUgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHRoZVxuW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBmYWNldCBjb250YWluc1xudGFicy5cbiovXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RhdGUsIGNvbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplLCBjaCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpWzBdO1xuICAgIGlmIChjaCA9PSBcIlxcdFwiKSB7XG4gICAgICAgIHdoaWxlIChjb2xzID49IHRzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGNvbHMgLT0gdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSBcIiBcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbldpbGwgZmlyc3QgY29uc3VsdCBhbnkgW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKVxudGhhdCBhcmUgcmVnaXN0ZXJlZCwgYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLFxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnROb2RlUHJvcCkgYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGFcbm51bWJlciB3aGVuIGFuIGluZGVudGF0aW9uIGNvdWxkIGJlIGRldGVybWluZWQsIGFuZCBudWxsXG5vdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgcG9zKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcbiAgICAgICAgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2YgY29udGV4dC5zdGF0ZS5mYWNldChpbmRlbnRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSk7XG4gICAgcmV0dXJuIHRyZWUubGVuZ3RoID49IHBvcyA/IHN5bnRheEluZGVudGF0aW9uKGNvbnRleHQsIHRyZWUsIHBvcykgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYSBjaGFuZ2Ugc2V0IHRoYXQgYXV0by1pbmRlbnRzIGFsbCBsaW5lcyB0b3VjaGVkIGJ5IHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcmFuZ2UuXG4qL1xuZnVuY3Rpb24gaW5kZW50UmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB1cGRhdGVkW3N0YXJ0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7IH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcbiAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSkge1xuICAgICAgICAgICAgdXBkYXRlZFtsaW5lLmZyb21dID0gaW5kZW50O1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xufVxuLyoqXG5JbmRlbnRhdGlvbiBjb250ZXh0cyBhcmUgdXNlZCB3aGVuIGNhbGxpbmcgW2luZGVudGF0aW9uXG5zZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKS4gVGhleSBwcm92aWRlIGhlbHBlciB1dGlsaXRpZXNcbnVzZWZ1bCBpbiBpbmRlbnRhdGlvbiBsb2dpYywgYW5kIGNhbiBzZWxlY3RpdmVseSBvdmVycmlkZSB0aGVcbmluZGVudGF0aW9uIHJlcG9ydGVkIGZvciBzb21lIGxpbmVzLlxuKi9cbmNsYXNzIEluZGVudENvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbmRlbnQgY29udGV4dC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVuaXQgPSBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCB0YWtpbmdcbiAgICBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgaW50byBhY2NvdW50LiBJZiB0aGVyZSBpcyBzdWNoIGEgYnJlYWsgYXQgYHBvc2AsIHRoZSBgYmlhc2BcbiAgICBhcmd1bWVudCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnQgb2YgdGhlIGxpbmUgbGluZSBiZWZvcmUgb3JcbiAgICBhZnRlciB0aGUgYnJlYWsgaXMgdXNlZC5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCB7IHNpbXVsYXRlQnJlYWssIHNpbXVsYXRlRG91YmxlQnJlYWsgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNpbXVsYXRlQnJlYWsgIT0gbnVsbCAmJiBzaW11bGF0ZUJyZWFrID49IGxpbmUuZnJvbSAmJiBzaW11bGF0ZUJyZWFrIDw9IGxpbmUudG8pIHtcbiAgICAgICAgICAgIGlmIChzaW11bGF0ZURvdWJsZUJyZWFrICYmIHNpbXVsYXRlQnJlYWsgPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IFwiXCIsIGZyb206IHBvcyB9O1xuICAgICAgICAgICAgZWxzZSBpZiAoYmlhcyA8IDAgPyBzaW11bGF0ZUJyZWFrIDwgcG9zIDogc2ltdWxhdGVCcmVhayA8PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBzaW11bGF0ZUJyZWFrIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKDAsIHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBsaW5lLmZyb20gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGBwb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgdGV4dEFmdGVyUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrICYmIHBvcyA9PSB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShwb3MgLSBmcm9tLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgcG9zICsgMTAwIC0gZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gZm9yIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvbHVtbihwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHBvcyAtIGZyb20pO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbiA/IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uKGZyb20pIDogLTE7XG4gICAgICAgIGlmIChvdmVycmlkZSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0ICs9IG92ZXJyaWRlIC0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBwb3NpdGlvbiAodGFraW5nIHRhYnMgaW50byBhY2NvdW50KSBvZiB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgY291bnRDb2x1bW4obGluZSwgcG9zID0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50Q29sdW1uKGxpbmUsIHRoaXMuc3RhdGUudGFiU2l6ZSwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAqL1xuICAgIGxpbmVJbmRlbnQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbjtcbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcnJpZGVuID0gb3ZlcnJpZGUoZnJvbSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVuID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGZvciB0aGlzIGNvbnRleHQsIGlmIGFueS5cbiAgICAqL1xuICAgIGdldCBzaW11bGF0ZWRCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5BIHN5bnRheCB0cmVlIG5vZGUgcHJvcCB1c2VkIHRvIGFzc29jaWF0ZSBpbmRlbnRhdGlvbiBzdHJhdGVnaWVzXG53aXRoIG5vZGUgdHlwZXMuIFN1Y2ggYSBzdHJhdGVneSBpcyBhIGZ1bmN0aW9uIGZyb20gYW4gaW5kZW50YXRpb25cbmNvbnRleHQgdG8gYSBjb2x1bW4gbnVtYmVyIChzZWUgYWxzb1xuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpIG9yIG51bGwsIHdoZXJlIG51bGxcbmluZGljYXRlcyB0aGF0IG5vIGRlZmluaXRpdmUgaW5kZW50YXRpb24gY2FuIGJlIGRldGVybWluZWQuXG4qL1xuY29uc3QgaW5kZW50Tm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vLyBDb21wdXRlIHRoZSBpbmRlbnRhdGlvbiBmb3IgYSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoZSBzeW50YXggdHJlZS5cbmZ1bmN0aW9uIHN5bnRheEluZGVudGF0aW9uKGN4LCBhc3QsIHBvcykge1xuICAgIGxldCBzdGFjayA9IGFzdC5yZXNvbHZlU3RhY2socG9zKTtcbiAgICBsZXQgaW5uZXIgPSBhc3QucmVzb2x2ZUlubmVyKHBvcywgLTEpLnJlc29sdmUocG9zLCAwKS5lbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpO1xuICAgIGlmIChpbm5lciAhPSBzdGFjay5ub2RlKSB7XG4gICAgICAgIGxldCBhZGQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gaW5uZXI7IGN1ciAmJiAhKGN1ci5mcm9tIDwgc3RhY2subm9kZS5mcm9tIHx8IGN1ci50byA+IHN0YWNrLm5vZGUudG8gfHxcbiAgICAgICAgICAgIGN1ci5mcm9tID09IHN0YWNrLm5vZGUuZnJvbSAmJiBjdXIudHlwZSA9PSBzdGFjay5ub2RlLnR5cGUpOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgYWRkLnB1c2goY3VyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFkZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIHN0YWNrID0geyBub2RlOiBhZGRbaV0sIG5leHQ6IHN0YWNrIH07XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpO1xufVxuZnVuY3Rpb24gaW5kZW50Rm9yKHN0YWNrLCBjeCwgcG9zKSB7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhY2s7IGN1cjsgY3VyID0gY3VyLm5leHQpIHtcbiAgICAgICAgbGV0IHN0cmF0ZWd5ID0gaW5kZW50U3RyYXRlZ3koY3VyLm5vZGUpO1xuICAgICAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koVHJlZUluZGVudENvbnRleHQuY3JlYXRlKGN4LCBwb3MsIGN1cikpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlnbm9yZUNsb3NlZChjeCkge1xuICAgIHJldHVybiBjeC5wb3MgPT0gY3gub3B0aW9ucy5zaW11bGF0ZUJyZWFrICYmIGN4Lm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhaztcbn1cbmZ1bmN0aW9uIGluZGVudFN0cmF0ZWd5KHRyZWUpIHtcbiAgICBsZXQgc3RyYXRlZ3kgPSB0cmVlLnR5cGUucHJvcChpbmRlbnROb2RlUHJvcCk7XG4gICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICByZXR1cm4gc3RyYXRlZ3k7XG4gICAgbGV0IGZpcnN0ID0gdHJlZS5maXJzdENoaWxkLCBjbG9zZTtcbiAgICBpZiAoZmlyc3QgJiYgKGNsb3NlID0gZmlyc3QudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0cmVlLmxhc3RDaGlsZCwgY2xvc2VkID0gbGFzdCAmJiBjbG9zZS5pbmRleE9mKGxhc3QubmFtZSkgPiAtMTtcbiAgICAgICAgcmV0dXJuIGN4ID0+IGRlbGltaXRlZFN0cmF0ZWd5KGN4LCB0cnVlLCAxLCB1bmRlZmluZWQsIGNsb3NlZCAmJiAhaWdub3JlQ2xvc2VkKGN4KSA/IGxhc3QuZnJvbSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLnBhcmVudCA9PSBudWxsID8gdG9wSW5kZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvcEluZGVudCgpIHsgcmV0dXJuIDA7IH1cbi8qKlxuT2JqZWN0cyBvZiB0aGlzIHR5cGUgcHJvdmlkZSBjb250ZXh0IGluZm9ybWF0aW9uIGFuZCBoZWxwZXJcbm1ldGhvZHMgdG8gaW5kZW50YXRpb24gZnVuY3Rpb25zIHJlZ2lzdGVyZWQgb24gc3ludGF4IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVJbmRlbnRDb250ZXh0IGV4dGVuZHMgSW5kZW50Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIGluZGVudGF0aW9uIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoYmFzZS5zdGF0ZSwgYmFzZS5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzeW50YXggdHJlZSBub2RlIHRvIHdoaWNoIHRoZSBpbmRlbnRhdGlvbiBzdHJhdGVneVxuICAgIGFwcGxpZXMuXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5ub2RlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGJhc2UsIHBvcywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVJbmRlbnRDb250ZXh0KGJhc2UsIHBvcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICAgIGlzIHRoZSBsaW5lIG9uIHdoaWNoIGl0IHN0YXJ0cywgdW5sZXNzIHRoZXJlIGlzIGEgbm9kZSB0aGF0IGlzXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXG4gICAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gICAgb24gaWYgaXQgaXMgY292ZXJlZCBieSBhbm90aGVyIHN1Y2ggbm9kZS5cbiAgICAqL1xuICAgIGdldCBiYXNlSW5kZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlSW5kZW50Rm9yKHRoaXMubm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gZm9yIHRoZSByZWZlcmVuY2UgbGluZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIChzZWUgW2BiYXNlSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5UcmVlSW5kZW50Q29udGV4dC5iYXNlSW5kZW50KSkuXG4gICAgKi9cbiAgICBiYXNlSW5kZW50Rm9yKG5vZGUpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQobm9kZS5mcm9tKTtcbiAgICAgICAgLy8gU2tpcCBsaW5lIHN0YXJ0cyB0aGF0IGFyZSBjb3ZlcmVkIGJ5IGEgc2libGluZyAob3IgY291c2luLCBldGMpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEJyZWFrID0gbm9kZS5yZXNvbHZlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXG4gICAgICAgICAgICAgICAgYXRCcmVhayA9IGF0QnJlYWsucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50KGF0QnJlYWssIG5vZGUpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChhdEJyZWFrLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbmRlbnQobGluZS5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbG9va2luZyBmb3IgaW5kZW50YXRpb25zIGluIHRoZSBub2RlJ3MgcGFyZW50IG5vZGVzLFxuICAgIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGF0LlxuICAgICovXG4gICAgY29udGludWUoKSB7XG4gICAgICAgIHJldHVybiBpbmRlbnRGb3IodGhpcy5jb250ZXh0Lm5leHQsIHRoaXMuYmFzZSwgdGhpcy5wb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGFyZW50KHBhcmVudCwgb2YpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBvZjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICBpZiAocGFyZW50ID09IGN1cilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIENoZWNrIHdoZXRoZXIgYSBkZWxpbWl0ZWQgbm9kZSBpcyBhbGlnbmVkIChtZWFuaW5nIHRoZXJlIGFyZVxuLy8gbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgb3BlbmluZyBkZWxpbWl0ZXIpLiBBbmRcbi8vIGlmIHNvLCByZXR1cm4gdGhlIG9wZW5pbmcgdG9rZW4uXG5mdW5jdGlvbiBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIHtcbiAgICBsZXQgdHJlZSA9IGNvbnRleHQubm9kZTtcbiAgICBsZXQgb3BlblRva2VuID0gdHJlZS5jaGlsZEFmdGVyKHRyZWUuZnJvbSksIGxhc3QgPSB0cmVlLmxhc3RDaGlsZDtcbiAgICBpZiAoIW9wZW5Ub2tlbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHNpbSA9IGNvbnRleHQub3B0aW9ucy5zaW11bGF0ZUJyZWFrO1xuICAgIGxldCBvcGVuTGluZSA9IGNvbnRleHQuc3RhdGUuZG9jLmxpbmVBdChvcGVuVG9rZW4uZnJvbSk7XG4gICAgbGV0IGxpbmVFbmQgPSBzaW0gPT0gbnVsbCB8fCBzaW0gPD0gb3BlbkxpbmUuZnJvbSA/IG9wZW5MaW5lLnRvIDogTWF0aC5taW4ob3BlbkxpbmUudG8sIHNpbSk7XG4gICAgZm9yIChsZXQgcG9zID0gb3BlblRva2VuLnRvOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSB0cmVlLmNoaWxkQWZ0ZXIocG9zKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT0gbGFzdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIW5leHQudHlwZS5pc1NraXBwZWQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPj0gbGluZUVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBzcGFjZSA9IC9eICovLmV4ZWMob3BlbkxpbmUudGV4dC5zbGljZShvcGVuVG9rZW4udG8gLSBvcGVuTGluZS5mcm9tKSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogb3BlblRva2VuLmZyb20sIHRvOiBvcGVuVG9rZW4udG8gKyBzcGFjZSB9O1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IG5leHQudG87XG4gICAgfVxufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSBmb3IgZGVsaW1pdGVkICh1c3VhbGx5IGJyYWNrZXRlZCkgbm9kZXMuXG5XaWxsLCBieSBkZWZhdWx0LCBpbmRlbnQgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBwYXJlbnQncyBiYXNlXG5pbmRlbnQgdW5sZXNzIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgY2xvc2luZyB0b2tlbi4gV2hlbiBgYWxpZ25gXG5pcyB0cnVlIGFuZCB0aGVyZSBhcmUgbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIG5vZGUncyBvcGVuaW5nXG5saW5lLCB0aGUgY29udGVudCBvZiB0aGUgbm9kZSB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgZW5kIG9mIHRoZVxub3BlbmluZyBub2RlLCBsaWtlIHRoaXM6XG5cbiAgICBmb28oYmFyLFxuICAgICAgICBiYXopXG4qL1xuZnVuY3Rpb24gZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZywgYWxpZ24gPSB0cnVlLCB1bml0cyA9IDEgfSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nKTtcbn1cbmZ1bmN0aW9uIGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZywgY2xvc2VkQXQpIHtcbiAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgc3BhY2UgPSBhZnRlci5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG4gICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcgJiYgYWZ0ZXIuc2xpY2Uoc3BhY2UsIHNwYWNlICsgY2xvc2luZy5sZW5ndGgpID09IGNsb3NpbmcgfHwgY2xvc2VkQXQgPT0gY29udGV4dC5wb3MgKyBzcGFjZTtcbiAgICBsZXQgYWxpZ25lZCA9IGFsaWduID8gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSA6IG51bGw7XG4gICAgaWYgKGFsaWduZWQpXG4gICAgICAgIHJldHVybiBjbG9zZWQgPyBjb250ZXh0LmNvbHVtbihhbGlnbmVkLmZyb20pIDogY29udGV4dC5jb2x1bW4oYWxpZ25lZC50byk7XG4gICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0ICogdW5pdHMpO1xufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0IGFsaWducyBhIG5vZGUncyBjb250ZW50IHRvIGl0cyBiYXNlXG5pbmRlbnRhdGlvbi5cbiovXG5jb25zdCBmbGF0SW5kZW50ID0gKGNvbnRleHQpID0+IGNvbnRleHQuYmFzZUluZGVudDtcbi8qKlxuQ3JlYXRlcyBhbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0LCBieSBkZWZhdWx0LCBpbmRlbnRzXG5jb250aW51ZWQgbGluZXMgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBub2RlJ3MgYmFzZSBpbmRlbnRhdGlvbi5cbllvdSBjYW4gcHJvdmlkZSBgZXhjZXB0YCB0byBwcmV2ZW50IGluZGVudGF0aW9uIG9mIGxpbmVzIHRoYXRcbm1hdGNoIGEgcGF0dGVybiAoZm9yIGV4YW1wbGUgYC9eZWxzZVxcYi9gIGluIGBpZmAvYGVsc2VgXG5jb25zdHJ1Y3RzKSwgYW5kIHlvdSBjYW4gY2hhbmdlIHRoZSBhbW91bnQgb2YgdW5pdHMgdXNlZCB3aXRoIHRoZVxuYHVuaXRzYCBvcHRpb24uXG4qL1xuZnVuY3Rpb24gY29udGludWVkSW5kZW50KHsgZXhjZXB0LCB1bml0cyA9IDEgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaEV4Y2VwdCA9IGV4Y2VwdCAmJiBleGNlcHQudGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAobWF0Y2hFeGNlcHQgPyAwIDogdW5pdHMgKiBjb250ZXh0LnVuaXQpO1xuICAgIH07XG59XG5jb25zdCBEb250SW5kZW50QmV5b25kID0gMjAwO1xuLyoqXG5FbmFibGVzIHJlaW5kZW50YXRpb24gb24gaW5wdXQuIFdoZW4gYSBsYW5ndWFnZSBkZWZpbmVzIGFuXG5gaW5kZW50T25JbnB1dGAgZmllbGQgaW4gaXRzIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCksIHdoaWNoIG11c3QgaG9sZCBhIHJlZ3VsYXJcbmV4cHJlc3Npb24sIHRoZSBsaW5lIGF0IHRoZSBjdXJzb3Igd2lsbCBiZSByZWluZGVudGVkIHdoZW5ldmVyIG5ld1xudGV4dCBpcyB0eXBlZCBhbmQgdGhlIGlucHV0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHVwIHRvIHRoZVxuY3Vyc29yIG1hdGNoZXMgdGhhdCByZWdleHAuXG5cblRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlaW5kZW50cywgaXQgaXMgcmVjb21tZW5kZWQgdG8gc3RhcnQgdGhlXG5yZWdleHAgd2l0aCBgXmAgKHVzdWFsbHkgZm9sbG93ZWQgYnkgYFxccypgKSwgYW5kIGVuZCBpdCB3aXRoIGAkYC5cbkZvciBleGFtcGxlLCBgL15cXHMqXFx9JC9gIHdpbGwgcmVpbmRlbnQgd2hlbiBhIGNsb3NpbmcgYnJhY2UgaXNcbmFkZGVkIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuXG4qL1xuZnVuY3Rpb24gaW5kZW50T25JbnB1dCgpIHtcbiAgICByZXR1cm4gRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIub2YodHIgPT4ge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgfHwgIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSAmJiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHJ1bGVzID0gdHIuc3RhcnRTdGF0ZS5sYW5ndWFnZURhdGFBdChcImluZGVudE9uSW5wdXRcIiwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBkb2MgPSB0ci5uZXdEb2MsIHsgaGVhZCB9ID0gdHIubmV3U2VsZWN0aW9uLm1haW4sIGxpbmUgPSBkb2MubGluZUF0KGhlYWQpO1xuICAgICAgICBpZiAoaGVhZCA+IGxpbmUuZnJvbSArIERvbnRJbmRlbnRCZXlvbmQpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBkb2Muc2xpY2VTdHJpbmcobGluZS5mcm9tLCBoZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5zb21lKHIgPT4gci50ZXN0KGxpbmVTdGFydCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGxhc3QgPSAtMSwgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsYXN0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKHN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgICAgICBpZiAoY3VyICE9IG5vcm0pXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmxlbmd0aCA/IFt0ciwgeyBjaGFuZ2VzLCBzZXF1ZW50aWFsOiB0cnVlIH1dIDogdHI7XG4gICAgfSk7XG59XG5cbi8qKlxuQSBmYWNldCB0aGF0IHJlZ2lzdGVycyBhIGNvZGUgZm9sZGluZyBzZXJ2aWNlLiBXaGVuIGNhbGxlZCB3aXRoXG50aGUgZXh0ZW50IG9mIGEgbGluZSwgc3VjaCBhIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmb2xkYWJsZVxucmFuZ2UgdGhhdCBzdGFydHMgb24gdGhhdCBsaW5lIChidXQgY29udGludWVzIGJleW9uZCBpdCksIGlmIG9uZVxuY2FuIGJlIGZvdW5kLlxuKi9cbmNvbnN0IGZvbGRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5UaGlzIG5vZGUgcHJvcCBpcyB1c2VkIHRvIGFzc29jaWF0ZSBmb2xkaW5nIGluZm9ybWF0aW9uIHdpdGhcbnN5bnRheCBub2RlIHR5cGVzLiBHaXZlbiBhIHN5bnRheCBub2RlLCBpdCBzaG91bGQgY2hlY2sgd2hldGhlclxudGhhdCB0cmVlIGlzIGZvbGRhYmxlIGFuZCByZXR1cm4gdGhlIHJhbmdlIHRoYXQgY2FuIGJlIGNvbGxhcHNlZFxud2hlbiBpdCBpcy5cbiovXG5jb25zdCBmb2xkTm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbltGb2xkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgZnVuY3Rpb24gdGhhdCBmb2xkcyBldmVyeXRoaW5nIGJ1dFxudGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBjaGlsZCBvZiBhIHN5bnRheCBub2RlLiBVc2VmdWwgZm9yIG5vZGVzXG50aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCBkZWxpbWl0ZXJzLlxuKi9cbmZ1bmN0aW9uIGZvbGRJbnNpZGUobm9kZSkge1xuICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC50byA8IGxhc3QuZnJvbSA/IHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0LnR5cGUuaXNFcnJvciA/IG5vZGUudG8gOiBsYXN0LmZyb20gfSA6IG51bGw7XG59XG5mdW5jdGlvbiBzeW50YXhGb2xkaW5nKHN0YXRlLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcbiAgICBpZiAodHJlZS5sZW5ndGggPCBlbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFjayA9IHRyZWUucmVzb2x2ZVN0YWNrKGVuZCwgMSk7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBpdGVyID0gc3RhY2s7IGl0ZXI7IGl0ZXIgPSBpdGVyLm5leHQpIHtcbiAgICAgICAgbGV0IGN1ciA9IGl0ZXIubm9kZTtcbiAgICAgICAgaWYgKGN1ci50byA8PSBlbmQgfHwgY3VyLmZyb20gPiBlbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGN1ci5mcm9tIDwgc3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IHByb3AgPSBjdXIudHlwZS5wcm9wKGZvbGROb2RlUHJvcCk7XG4gICAgICAgIGlmIChwcm9wICYmIChjdXIudG8gPCB0cmVlLmxlbmd0aCAtIDUwIHx8IHRyZWUubGVuZ3RoID09IHN0YXRlLmRvYy5sZW5ndGggfHwgIWlzVW5maW5pc2hlZChjdXIpKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcChjdXIsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5mcm9tIDw9IGVuZCAmJiB2YWx1ZS5mcm9tID49IHN0YXJ0ICYmIHZhbHVlLnRvID4gZW5kKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaXNVbmZpbmlzaGVkKG5vZGUpIHtcbiAgICBsZXQgY2ggPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gY2ggJiYgY2gudG8gPT0gbm9kZS50byAmJiBjaC50eXBlLmlzRXJyb3I7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGxpbmUgaXMgZm9sZGFibGUuIEZpcnN0IGFza3MgYW55IGZvbGRcbnNlcnZpY2VzIHJlZ2lzdGVyZWQgdGhyb3VnaFxuW2Bmb2xkU2VydmljZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZFNlcnZpY2UpLCBhbmQgaWYgbm9uZSBvZiB0aGVtIHJldHVyblxuYSByZXN1bHQsIHRyaWVzIHRvIHF1ZXJ5IHRoZSBbZm9sZCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgb2Ygc3ludGF4IG5vZGVzIHRoYXQgY292ZXIgdGhlIGVuZFxub2YgdGhlIGxpbmUuXG4qL1xuZnVuY3Rpb24gZm9sZGFibGUoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2Ygc3RhdGUuZmFjZXQoZm9sZFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN5bnRheEZvbGRpbmcoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG59XG5mdW5jdGlvbiBtYXBSYW5nZShyYW5nZSwgbWFwcGluZykge1xuICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBQb3MocmFuZ2UuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBQb3MocmFuZ2UudG8sIC0xKTtcbiAgICByZXR1cm4gZnJvbSA+PSB0byA/IHVuZGVmaW5lZCA6IHsgZnJvbSwgdG8gfTtcbn1cbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gZm9sZCB0aGVcbmdpdmVuIHJhbmdlLiAoWW91IHByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIGluIGV4Y2VwdGlvbmFsXG5jaXJjdW1zdGFuY2Vz4oCUdXN1YWxseSB5b3UnbGwganVzdCB3YW50IHRvIGxldFxuW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpIGFuZCB0aGUgW2ZvbGRcbmd1dHRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkR3V0dGVyKSBjcmVhdGUgdGhlIHRyYW5zYWN0aW9ucy4pXG4qL1xuY29uc3QgZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCB1bmZvbGRzIHRoZSBnaXZlbiByYW5nZSAoaWYgaXQgd2FzIGZvbGRlZCkuXG4qL1xuY29uc3QgdW5mb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVzKHZpZXcpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbmVzLnNvbWUobCA9PiBsLmZyb20gPD0gaGVhZCAmJiBsLnRvID49IGhlYWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxpbmVzLnB1c2godmlldy5saW5lQmxvY2tBdChoZWFkKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHRoYXQgc3RvcmVzIHRoZSBmb2xkZWQgcmFuZ2VzIChhcyBhIFtkZWNvcmF0aW9uXG5zZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSkuIENhbiBiZSBwYXNzZWQgdG9cbltgRWRpdG9yU3RhdGUudG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIGFuZFxuW2Bmcm9tSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHRvIHNlcmlhbGl6ZSB0aGUgZm9sZFxuc3RhdGUuXG4qL1xuY29uc3QgZm9sZFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZGVkLCB0cikge1xuICAgICAgICBpZiAodHIuaXNVc2VyRXZlbnQoXCJkZWxldGVcIikpXG4gICAgICAgICAgICB0ci5jaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BKSA9PiBmb2xkZWQgPSBjbGVhclRvdWNoZWRGb2xkcyhmb2xkZWQsIGZyb21BLCB0b0EpKTtcbiAgICAgICAgZm9sZGVkID0gZm9sZGVkLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZS5pcyhmb2xkRWZmZWN0KSAmJiAhZm9sZEV4aXN0cyhmb2xkZWQsIGUudmFsdWUuZnJvbSwgZS52YWx1ZS50bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBwcmVwYXJlUGxhY2Vob2xkZXIgfSA9IHRyLnN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgICAgICAgICAgICAgIGxldCB3aWRnZXQgPSAhcHJlcGFyZVBsYWNlaG9sZGVyID8gZm9sZFdpZGdldCA6XG4gICAgICAgICAgICAgICAgICAgIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFByZXBhcmVkRm9sZFdpZGdldChwcmVwYXJlUGxhY2Vob2xkZXIodHIuc3RhdGUsIGUudmFsdWUpKSB9KTtcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgYWRkOiBbd2lkZ2V0LnJhbmdlKGUudmFsdWUuZnJvbSwgZS52YWx1ZS50byldIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5pcyh1bmZvbGRFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGZpbHRlcjogKGZyb20sIHRvKSA9PiBlLnZhbHVlLmZyb20gIT0gZnJvbSB8fCBlLnZhbHVlLnRvICE9IHRvLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBlLnZhbHVlLmZyb20sIGZpbHRlclRvOiBlLnZhbHVlLnRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGZvbGRlZCByYW5nZXMgdGhhdCBjb3ZlciB0aGUgc2VsZWN0aW9uIGhlYWRcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGZvbGRlZCA9IGNsZWFyVG91Y2hlZEZvbGRzKGZvbGRlZCwgdHIuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIHJldHVybiBmb2xkZWQ7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKSxcbiAgICB0b0pTT04oZm9sZGVkLCBzdGF0ZSkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvbGRlZC5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyByYW5nZXMucHVzaChmcm9tLCB0byk7IH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG4gICAgZnJvbUpTT04odmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggJSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlW2krK10sIHRvID0gdmFsdWVbaSsrXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goZm9sZFdpZGdldC5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChyYW5nZXMsIHRydWUpO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gY2xlYXJUb3VjaGVkRm9sZHMoZm9sZGVkLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuICAgIGZvbGRlZC5iZXR3ZWVuKGZyb20sIHRvLCAoYSwgYikgPT4geyBpZiAoYSA8IHRvICYmIGIgPiBmcm9tKVxuICAgICAgICB0b3VjaGVkID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuICF0b3VjaGVkID8gZm9sZGVkIDogZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgIGZpbHRlckZyb206IGZyb20sXG4gICAgICAgIGZpbHRlclRvOiB0byxcbiAgICAgICAgZmlsdGVyOiAoYSwgYikgPT4gYSA+PSB0byB8fCBiIDw9IGZyb21cbiAgICB9KTtcbn1cbi8qKlxuR2V0IGEgW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgY29udGFpbmluZyB0aGUgZm9sZGVkIHJhbmdlc1xuaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZvbGRlZFJhbmdlcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fCBSYW5nZVNldC5lbXB0eTtcbn1cbmZ1bmN0aW9uIGZpbmRGb2xkKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIChfYSA9IHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmV0d2Vlbihmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQuZnJvbSA+IGZyb20pXG4gICAgICAgICAgICBmb3VuZCA9IHsgZnJvbSwgdG8gfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmb2xkRXhpc3RzKGZvbGRlZCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb2xkZWQuYmV0d2Vlbihmcm9tLCBmcm9tLCAoYSwgYikgPT4geyBpZiAoYSA9PSBmcm9tICYmIGIgPT0gdG8pXG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGUoc3RhdGUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpID8gb3RoZXIgOiBvdGhlci5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGNvZGVGb2xkaW5nKCkpKTtcbn1cbi8qKlxuRm9sZCB0aGUgbGluZXMgdGhhdCBhcmUgc2VsZWN0ZWQsIGlmIHBvc3NpYmxlLlxuKi9cbmNvbnN0IGZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIFtmb2xkRWZmZWN0Lm9mKHJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlKV0pIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuVW5mb2xkIGZvbGRlZCByYW5nZXMgb24gc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgdW5mb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiBlZmZlY3RzLmxlbmd0aCA+IDA7XG59O1xuZnVuY3Rpb24gYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xuICAgIGxldCBsaW5lRnJvbSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKS5udW1iZXIsIGxpbmVUbyA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50bykubnVtYmVyO1xuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKGZvbGQgPyBcIkZvbGRlZCBsaW5lc1wiIDogXCJVbmZvbGRlZCBsaW5lc1wiKX0gJHtsaW5lRnJvbX0gJHt2aWV3LnN0YXRlLnBocmFzZShcInRvXCIpfSAke2xpbmVUb30uYCk7XG59XG4vKipcbkZvbGQgYWxsIHRvcC1sZXZlbCBmb2xkYWJsZSByYW5nZXMuIE5vdGUgdGhhdCwgaW4gbW9zdCBjYXNlcyxcbmZvbGRpbmcgaW5mb3JtYXRpb24gd2lsbCBkZXBlbmQgb24gdGhlIFtzeW50YXhcbnRyZWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSksIGFuZCBmb2xkaW5nIGV2ZXJ5dGhpbmcgbWF5IG5vdCB3b3JrXG5yZWxpYWJseSB3aGVuIHRoZSBkb2N1bWVudCBoYXNuJ3QgYmVlbiBmdWxseSBwYXJzZWQgKGVpdGhlclxuYmVjYXVzZSB0aGUgZWRpdG9yIHN0YXRlIHdhcyBvbmx5IGp1c3QgaW5pdGlhbGl6ZWQsIG9yIGJlY2F1c2UgdGhlXG5kb2N1bWVudCBpcyBzbyBiaWcgdGhhdCB0aGUgcGFyc2VyIGRlY2lkZWQgbm90IHRvIHBhcnNlIGl0XG5lbnRpcmVseSkuXG4qL1xuY29uc3QgZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgc3RhdGUuZG9jLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyksIHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICAgIHBvcyA9IChyYW5nZSA/IHZpZXcubGluZUJsb2NrQXQocmFuZ2UudG8pIDogbGluZSkudG8gKyAxO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcblVuZm9sZCBhbGwgZm9sZGVkIGNvZGUuXG4qL1xuY29uc3QgdW5mb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmaWVsZC5iZXR3ZWVuKDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoeyBmcm9tLCB0byB9KSk7IH0pO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgdGhlIGZvbGRhYmxlIHJlZ2lvbiBjb250YWluaW5nIHRoZSBnaXZlbiBsaW5lLCBpZiBvbmUgZXhpc3RzXG5mdW5jdGlvbiBmb2xkYWJsZUNvbnRhaW5lcih2aWV3LCBsaW5lQmxvY2spIHtcbiAgICAvLyBMb29rIGJhY2t3YXJkcyB0aHJvdWdoIGxpbmUgYmxvY2tzIHVudGlsIHdlIGZpbmQgYSBmb2xkYWJsZSByZWdpb24gdGhhdFxuICAgIC8vIGludGVyc2VjdHMgd2l0aCB0aGUgbGluZVxuICAgIGZvciAobGV0IGxpbmUgPSBsaW5lQmxvY2s7Oykge1xuICAgICAgICBsZXQgZm9sZGFibGVSZWdpb24gPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGFibGVSZWdpb24gJiYgZm9sZGFibGVSZWdpb24udG8gPiBsaW5lQmxvY2suZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBmb2xkYWJsZVJlZ2lvbjtcbiAgICAgICAgaWYgKCFsaW5lLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGluZSA9IHZpZXcubGluZUJsb2NrQXQobGluZS5mcm9tIC0gMSk7XG4gICAgfVxufVxuLyoqXG5Ub2dnbGUgZm9sZGluZyBhdCBjdXJzb3JzLiBVbmZvbGRzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGZvbGRcbnN0YXJ0aW5nIGluIHRoYXQgbGluZSwgdHJpZXMgdG8gZmluZCBhIGZvbGRhYmxlIHJhbmdlIGFyb3VuZCBpdFxub3RoZXJ3aXNlLlxuKi9cbmNvbnN0IHRvZ2dsZUZvbGQgPSAodmlldykgPT4ge1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm9sZFJhbmdlID0gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZSk7XG4gICAgICAgICAgICBpZiAoZm9sZFJhbmdlKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKGZvbGRSYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkUmFuZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5EZWZhdWx0IGZvbGQtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIEN0cmwtU2hpZnQtWyAoQ21kLUFsdC1bIG9uIG1hY09TKTogW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpLlxuIC0gQ3RybC1TaGlmdC1dIChDbWQtQWx0LV0gb24gbWFjT1MpOiBbYHVuZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZENvZGUpLlxuIC0gQ3RybC1BbHQtWzogW2Bmb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQWxsKS5cbiAtIEN0cmwtQWx0LV06IFtgdW5mb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRBbGwpLlxuKi9cbmNvbnN0IGZvbGRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1bXCIsIG1hYzogXCJDbWQtQWx0LVtcIiwgcnVuOiBmb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtXVwiLCBtYWM6IFwiQ21kLUFsdC1dXCIsIHJ1bjogdW5mb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LVtcIiwgcnVuOiBmb2xkQWxsIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtXVwiLCBydW46IHVuZm9sZEFsbCB9XG5dO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBwbGFjZWhvbGRlckRPTTogbnVsbCxcbiAgICBwcmVwYXJlUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgcGxhY2Vob2xkZXJUZXh0OiBcIuKAplwiXG59O1xuY29uc3QgZm9sZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgZGVmYXVsdENvbmZpZyk7IH1cbn0pO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyBjb2RlIGZvbGRpbmcuXG4qL1xuZnVuY3Rpb24gY29kZUZvbGRpbmcoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtmb2xkU3RhdGUsIGJhc2VUaGVtZSQxXTtcbiAgICBpZiAoY29uZmlnKVxuICAgICAgICByZXN1bHQucHVzaChmb2xkQ29uZmlnLm9mKGNvbmZpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aWRnZXRUb0RPTSh2aWV3LCBwcmVwYXJlZCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHZpZXcucG9zQXRET00oZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgaWYgKGNvbmYucGxhY2Vob2xkZXJET00pXG4gICAgICAgIHJldHVybiBjb25mLnBsYWNlaG9sZGVyRE9NKHZpZXcsIG9uY2xpY2ssIHByZXBhcmVkKTtcbiAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25mLnBsYWNlaG9sZGVyVGV4dDtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc3RhdGUucGhyYXNlKFwiZm9sZGVkIGNvZGVcIikpO1xuICAgIGVsZW1lbnQudGl0bGUgPSBzdGF0ZS5waHJhc2UoXCJ1bmZvbGRcIik7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImNtLWZvbGRQbGFjZWhvbGRlclwiO1xuICAgIGVsZW1lbnQub25jbGljayA9IG9uY2xpY2s7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5jb25zdCBmb2xkV2lkZ2V0ID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICB0b0RPTSh2aWV3KSB7IHJldHVybiB3aWRnZXRUb0RPTSh2aWV3LCBudWxsKTsgfVxuICAgIH0gfSk7XG5jbGFzcyBQcmVwYXJlZEZvbGRXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLnZhbHVlID09IG90aGVyLnZhbHVlOyB9XG4gICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgdGhpcy52YWx1ZSk7IH1cbn1cbmNvbnN0IGZvbGRHdXR0ZXJEZWZhdWx0cyA9IHtcbiAgICBvcGVuVGV4dDogXCLijIRcIixcbiAgICBjbG9zZWRUZXh0OiBcIuKAulwiLFxuICAgIG1hcmtlckRPTTogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fSxcbiAgICBmb2xkaW5nQ2hhbmdlZDogKCkgPT4gZmFsc2Vcbn07XG5jbGFzcyBGb2xkTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNvbmZpZyA9PSBvdGhlci5jb25maWcgJiYgdGhpcy5vcGVuID09IG90aGVyLm9wZW47IH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWFya2VyRE9NKHRoaXMub3Blbik7XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wZW4gPyB0aGlzLmNvbmZpZy5vcGVuVGV4dCA6IHRoaXMuY29uZmlnLmNsb3NlZFRleHQ7XG4gICAgICAgIHNwYW4udGl0bGUgPSB2aWV3LnN0YXRlLnBocmFzZSh0aGlzLm9wZW4gPyBcIkZvbGQgbGluZVwiIDogXCJVbmZvbGQgbGluZVwiKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIGEgZm9sZCBndXR0ZXIsIHdoaWNoIHNob3dzIGFcbmZvbGQgc3RhdHVzIGluZGljYXRvciBiZWZvcmUgZm9sZGFibGUgbGluZXMgKHdoaWNoIGNhbiBiZSBjbGlja2VkXG50byBmb2xkIG9yIHVuZm9sZCB0aGUgbGluZSkuXG4qL1xuZnVuY3Rpb24gZm9sZEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIGxldCBmdWxsQ29uZmlnID0geyAuLi5mb2xkR3V0dGVyRGVmYXVsdHMsIC4uLmNvbmZpZyB9O1xuICAgIGxldCBjYW5Gb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgdHJ1ZSksIGNhblVuZm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICBsZXQgbWFya2VycyA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdmlldy52aWV3cG9ydC5mcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpICE9IHVwZGF0ZS5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIHN5bnRheFRyZWUodXBkYXRlLnN0YXJ0U3RhdGUpICE9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSB8fFxuICAgICAgICAgICAgICAgIGZ1bGxDb25maWcuZm9sZGluZ0NoYW5nZWQodXBkYXRlKSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh1cGRhdGUudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRNYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZSBvZiB2aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhblVuZm9sZFxuICAgICAgICAgICAgICAgICAgICA6IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5Gb2xkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQobGluZS5mcm9tLCBsaW5lLmZyb20sIG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgeyBkb21FdmVudEhhbmRsZXJzIH0gPSBmdWxsQ29uZmlnO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtlcnMsXG4gICAgICAgIGd1dHRlcih7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1mb2xkR3V0dGVyXCIsXG4gICAgICAgICAgICBtYXJrZXJzKHZpZXcpIHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKG1hcmtlcnMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VycykgfHwgUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgICAgICAgICBpbml0aWFsU3BhY2VyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVyczoge1xuICAgICAgICAgICAgICAgIC4uLmRvbUV2ZW50SGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnaGxpZ2h0aW5nXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKS5cbiovXG5jbGFzcyBIaWdobGlnaHRTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRhZyBzdHlsZXMgdXNlZCB0byBjcmVhdGUgdGhpcyBoaWdobGlnaHQgc3R5bGUuXG4gICAgKi9cbiAgICBzcGVjcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgIGxldCBtb2RTcGVjO1xuICAgICAgICBmdW5jdGlvbiBkZWYoc3BlYykge1xuICAgICAgICAgICAgbGV0IGNscyA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgICAgIChtb2RTcGVjIHx8IChtb2RTcGVjID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW1wiLlwiICsgY2xzXSA9IHNwZWM7XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbCA9IHR5cGVvZiBvcHRpb25zLmFsbCA9PSBcInN0cmluZ1wiID8gb3B0aW9ucy5hbGwgOiBvcHRpb25zLmFsbCA/IGRlZihvcHRpb25zLmFsbCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlT3B0ID0gb3B0aW9ucy5zY29wZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlT3B0IGluc3RhbmNlb2YgTGFuZ3VhZ2UgPyAodHlwZSkgPT4gdHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHNjb3BlT3B0LmRhdGFcbiAgICAgICAgICAgIDogc2NvcGVPcHQgPyAodHlwZSkgPT4gdHlwZSA9PSBzY29wZU9wdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHRhZ0hpZ2hsaWdodGVyKHNwZWNzLm1hcChzdHlsZSA9PiAoe1xuICAgICAgICAgICAgdGFnOiBzdHlsZS50YWcsXG4gICAgICAgICAgICBjbGFzczogc3R5bGUuY2xhc3MgfHwgZGVmKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlLCB7IHRhZzogbnVsbCB9KSlcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgICBhbGwsXG4gICAgICAgIH0pLnN0eWxlO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZFNwZWMgPyBuZXcgU3R5bGVNb2R1bGUobW9kU3BlYykgOiBudWxsO1xuICAgICAgICB0aGlzLnRoZW1lVHlwZSA9IG9wdGlvbnMudGhlbWVUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBoaWdobGlnaHRlciBzdHlsZSB0aGF0IGFzc29jaWF0ZXMgdGhlIGdpdmVuIHN0eWxlcyB0b1xuICAgIHRoZSBnaXZlbiB0YWdzLiBUaGUgc3BlY3MgbXVzdCBiZSBvYmplY3RzIHRoYXQgaG9sZCBhIHN0eWxlIHRhZ1xuICAgIG9yIGFycmF5IG9mIHRhZ3MgaW4gdGhlaXIgYHRhZ2AgcHJvcGVydHksIGFuZCBlaXRoZXIgYSBzaW5nbGVcbiAgICBgY2xhc3NgIHByb3BlcnR5IHByb3ZpZGluZyBhIHN0YXRpYyBDU1MgY2xhc3MgKGZvciBoaWdobGlnaHRlclxuICAgIHRoYXQgcmVseSBvbiBleHRlcm5hbCBzdHlsaW5nKSwgb3IgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pLXN0eWxlXG4gICAgc2V0IG9mIENTUyBwcm9wZXJ0aWVzICh3aGljaCBkZWZpbmUgdGhlIHN0eWxpbmcgZm9yIHRob3NlIHRhZ3MpLlxuICAgIFxuICAgIFRoZSBDU1MgcnVsZXMgY3JlYXRlZCBmb3IgYSBoaWdobGlnaHRlciB3aWxsIGJlIGVtaXR0ZWQgaW4gdGhlXG4gICAgb3JkZXIgb2YgdGhlIHNwZWMncyBwcm9wZXJ0aWVzLiBUaGF0IG1lYW5zIHRoYXQgZm9yIGVsZW1lbnRzIHRoYXRcbiAgICBoYXZlIG11bHRpcGxlIHRhZ3MgYXNzb2NpYXRlZCB3aXRoIHRoZW0sIHN0eWxlcyBkZWZpbmVkIGZ1cnRoZXJcbiAgICBkb3duIGluIHRoZSBsaXN0IHdpbGwgaGF2ZSBhIGhpZ2hlciBDU1MgcHJlY2VkZW5jZSB0aGFuIHN0eWxlc1xuICAgIGRlZmluZWQgZWFybGllci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRTdHlsZShzcGVjcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgfVxufVxuY29uc3QgaGlnaGxpZ2h0ZXJGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZhbGxiYWNrSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gdmFsdWVzLmxlbmd0aCA/IFt2YWx1ZXNbMF1dIDogbnVsbDsgfVxufSk7XG5mdW5jdGlvbiBnZXRIaWdobGlnaHRlcnMoc3RhdGUpIHtcbiAgICBsZXQgbWFpbiA9IHN0YXRlLmZhY2V0KGhpZ2hsaWdodGVyRmFjZXQpO1xuICAgIHJldHVybiBtYWluLmxlbmd0aCA/IG1haW4gOiBzdGF0ZS5mYWNldChmYWxsYmFja0hpZ2hsaWdodGVyKTtcbn1cbi8qKlxuV3JhcCBhIGhpZ2hsaWdodGVyIGluIGFuIGVkaXRvciBleHRlbnNpb24gdGhhdCB1c2VzIGl0IHRvIGFwcGx5XG5zeW50YXggaGlnaGxpZ2h0aW5nIHRvIHRoZSBlZGl0b3IgY29udGVudC5cblxuV2hlbiBtdWx0aXBsZSAobm9uLWZhbGxiYWNrKSBzdHlsZXMgYXJlIHByb3ZpZGVkLCB0aGUgc3R5bGluZ1xuYXBwbGllZCBpcyB0aGUgdW5pb24gb2YgdGhlIGNsYXNzZXMgdGhleSBlbWl0LlxuKi9cbmZ1bmN0aW9uIHN5bnRheEhpZ2hsaWdodGluZyhoaWdobGlnaHRlciwgb3B0aW9ucykge1xuICAgIGxldCBleHQgPSBbdHJlZUhpZ2hsaWdodGVyXSwgdGhlbWVUeXBlO1xuICAgIGlmIChoaWdobGlnaHRlciBpbnN0YW5jZW9mIEhpZ2hsaWdodFN0eWxlKSB7XG4gICAgICAgIGlmIChoaWdobGlnaHRlci5tb2R1bGUpXG4gICAgICAgICAgICBleHQucHVzaChFZGl0b3JWaWV3LnN0eWxlTW9kdWxlLm9mKGhpZ2hsaWdodGVyLm1vZHVsZSkpO1xuICAgICAgICB0aGVtZVR5cGUgPSBoaWdobGlnaHRlci50aGVtZVR5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2spXG4gICAgICAgIGV4dC5wdXNoKGZhbGxiYWNrSGlnaGxpZ2h0ZXIub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICBlbHNlIGlmICh0aGVtZVR5cGUpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQuY29tcHV0ZU4oW0VkaXRvclZpZXcuZGFya1RoZW1lXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZhY2V0KEVkaXRvclZpZXcuZGFya1RoZW1lKSA9PSAodGhlbWVUeXBlID09IFwiZGFya1wiKSA/IFtoaWdobGlnaHRlcl0gOiBbXTtcbiAgICAgICAgfSkpO1xuICAgIGVsc2VcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5vZihoaWdobGlnaHRlcikpO1xuICAgIHJldHVybiBleHQ7XG59XG4vKipcblJldHVybnMgdGhlIENTUyBjbGFzc2VzIChpZiBhbnkpIHRoYXQgdGhlIGhpZ2hsaWdodGVycyBhY3RpdmUgaW5cbnRoZSBzdGF0ZSB3b3VsZCBhc3NpZ24gdG8gdGhlIGdpdmVuIHN0eWxlXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKSBhbmRcbihvcHRpb25hbCkgbGFuZ3VhZ2VcbltzY29wZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5IaWdobGlnaHRTdHlsZV5kZWZpbmVeb3B0aW9ucy5zY29wZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0aW5nRm9yKHN0YXRlLCB0YWdzLCBzY29wZSkge1xuICAgIGxldCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnMoc3RhdGUpO1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmIChoaWdobGlnaHRlcnMpXG4gICAgICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRlci5zY29wZSB8fCBzY29wZSAmJiBoaWdobGlnaHRlci5zY29wZShzY29wZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xzID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyBjbHMgOiBjbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgVHJlZUhpZ2hsaWdodGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubWFya0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHZpZXcsIGdldEhpZ2hsaWdodGVycyh2aWV3LnN0YXRlKSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSB2aWV3LnZpZXdwb3J0LnRvO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpLCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgbGV0IHN0eWxlQ2hhbmdlID0gaGlnaGxpZ2h0ZXJzICE9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhcnRTdGF0ZSk7XG4gICAgICAgIGxldCB7IHZpZXdwb3J0IH0gPSB1cGRhdGUudmlldywgZGVjb3JhdGVkVG9NYXBwZWQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5kZWNvcmF0ZWRUbywgMSk7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA8IHZpZXdwb3J0LnRvICYmICFzdHlsZUNoYW5nZSAmJiB0cmVlLnR5cGUgPT0gdGhpcy50cmVlLnR5cGUgJiYgZGVjb3JhdGVkVG9NYXBwZWQgPj0gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlZFRvID0gZGVjb3JhdGVkVG9NYXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBzdHlsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh1cGRhdGUudmlldywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSB2aWV3cG9ydC50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZERlY28odmlldywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGlmICghaGlnaGxpZ2h0ZXJzIHx8ICF0aGlzLnRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFRyZWUodGhpcy50cmVlLCBoaWdobGlnaHRlcnMsIChmcm9tLCB0bywgc3R5bGUpID0+IHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgdGhpcy5tYXJrQ2FjaGVbc3R5bGVdIHx8ICh0aGlzLm1hcmtDYWNoZVtzdHlsZV0gPSBEZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogc3R5bGUgfSkpKTtcbiAgICAgICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59XG5jb25zdCB0cmVlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoKC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhUcmVlSGlnaGxpZ2h0ZXIsIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KSk7XG4vKipcbkEgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGUgKHdvcmtzIHdlbGwgd2l0aCBsaWdodCB0aGVtZXMpLlxuKi9cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9IaWdobGlnaHRTdHlsZS5kZWZpbmUoW1xuICAgIHsgdGFnOiB0YWdzLm1ldGEsXG4gICAgICAgIGNvbG9yOiBcIiM0MDQ3NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpbmssXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsXG4gICAgICAgIGNvbG9yOiBcIiM3MDhcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIHRhZ3MudXJsLCB0YWdzLmNvbnRlbnRTZXBhcmF0b3IsIHRhZ3MubGFiZWxOYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzIxOVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxpdGVyYWwsIHRhZ3MuaW5zZXJ0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjMTY0XCIgfSxcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nLCB0YWdzLmRlbGV0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjYTExXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLFxuICAgICAgICBjb2xvcjogXCIjZTQwXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMzMGFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsXG4gICAgICAgIGNvbG9yOiBcIiMxNjdcIiB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIHRhZ3MubWFjcm9OYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzI1NlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBjXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LFxuICAgICAgICBjb2xvcjogXCIjOTQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogXCIjZjAwXCIgfVxuXSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMzI4YzgyNTJcIiB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JiNTU1NTQ0XCIgfVxufSk7XG5jb25zdCBEZWZhdWx0U2NhbkRpc3QgPSAxMDAwMCwgRGVmYXVsdEJyYWNrZXRzID0gXCIoKVtde31cIjtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdCxcbiAgICAgICAgICAgIHJlbmRlck1hdGNoOiBkZWZhdWx0UmVuZGVyTWF0Y2hcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBtYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbWF0Y2hpbmdCcmFja2V0XCIgfSksIG5vbm1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1ub25tYXRjaGluZ0JyYWNrZXRcIiB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNYXRjaChtYXRjaCkge1xuICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgIGxldCBtYXJrID0gbWF0Y2gubWF0Y2hlZCA/IG1hdGNoaW5nTWFyayA6IG5vbm1hdGNoaW5nTWFyaztcbiAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guc3RhcnQuZnJvbSwgbWF0Y2guc3RhcnQudG8pKTtcbiAgICBpZiAobWF0Y2guZW5kKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guZW5kLmZyb20sIG1hdGNoLmVuZC50bykpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1N0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBEZWNvcmF0aW9uLm5vbmU7IH0sXG4gICAgdXBkYXRlKGRlY28sIHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiAhdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGRlY287XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoYnJhY2tldE1hdGNoaW5nQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdHIuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIC0xLCBjb25maWcpXG4gICAgICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxLCBjb25maWcpKVxuICAgICAgICAgICAgICAgIHx8IChjb25maWcuYWZ0ZXJDdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIDEsIGNvbmZpZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYW5nZS5oZWFkIDwgdHIuc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEsIGNvbmZpZykpKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucy5jb25jYXQoY29uZmlnLnJlbmRlck1hdGNoKG1hdGNoLCB0ci5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvcmF0aW9ucywgdHJ1ZSk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKVxufSk7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdVbmlxdWUgPSBbXG4gICAgYnJhY2tldE1hdGNoaW5nU3RhdGUsXG4gICAgYmFzZVRoZW1lXG5dO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBicmFja2V0IG1hdGNoaW5nLiBXaGVuZXZlciB0aGVcbmN1cnNvciBpcyBuZXh0IHRvIGEgYnJhY2tldCwgdGhhdCBicmFja2V0IGFuZCB0aGUgb25lIGl0IG1hdGNoZXNcbmFyZSBoaWdobGlnaHRlZC4gT3IsIHdoZW4gbm8gbWF0Y2hpbmcgYnJhY2tldCBpcyBmb3VuZCwgYW5vdGhlclxuaGlnaGxpZ2h0aW5nIHN0eWxlIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhpcy5cbiovXG5mdW5jdGlvbiBicmFja2V0TWF0Y2hpbmcoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2JyYWNrZXRNYXRjaGluZ0NvbmZpZy5vZihjb25maWcpLCBicmFja2V0TWF0Y2hpbmdVbmlxdWVdO1xufVxuLyoqXG5XaGVuIGxhcmdlciBzeW50YXggbm9kZXMsIHN1Y2ggYXMgSFRNTCB0YWdzLCBhcmUgbWFya2VkIGFzXG5vcGVuaW5nL2Nsb3NpbmcsIGl0IGNhbiBiZSBhIGJpdCBtZXNzeSB0byB0cmVhdCB0aGUgd2hvbGUgbm9kZSBhc1xuYSBtYXRjaGFibGUgYnJhY2tldC4gVGhpcyBub2RlIHByb3AgYWxsb3dzIHlvdSB0byBkZWZpbmUsIGZvciBzdWNoXG5hIG5vZGUsIGEg4oCYaGFuZGxl4oCZ4oCUdGhlIHBhcnQgb2YgdGhlIG5vZGUgdGhhdCBpcyBoaWdobGlnaHRlZCwgYW5kXG50aGF0IHRoZSBjdXJzb3IgbXVzdCBiZSBvbiB0byBhY3RpdmF0ZSBoaWdobGlnaHRpbmcgaW4gdGhlIGZpcnN0XG5wbGFjZS5cbiovXG5jb25zdCBicmFja2V0TWF0Y2hpbmdIYW5kbGUgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG5mdW5jdGlvbiBtYXRjaGluZ05vZGVzKG5vZGUsIGRpciwgYnJhY2tldHMpIHtcbiAgICBsZXQgYnlQcm9wID0gbm9kZS5wcm9wKGRpciA8IDAgPyBOb2RlUHJvcC5vcGVuZWRCeSA6IE5vZGVQcm9wLmNsb3NlZEJ5KTtcbiAgICBpZiAoYnlQcm9wKVxuICAgICAgICByZXR1cm4gYnlQcm9wO1xuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gYnJhY2tldHMuaW5kZXhPZihub2RlLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBpbmRleCAlIDIgPT0gKGRpciA8IDAgPyAxIDogMCkpXG4gICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRzW2luZGV4ICsgZGlyXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEhhbmRsZShub2RlKSB7XG4gICAgbGV0IGhhc0hhbmRsZSA9IG5vZGUudHlwZS5wcm9wKGJyYWNrZXRNYXRjaGluZ0hhbmRsZSk7XG4gICAgcmV0dXJuIGhhc0hhbmRsZSA/IGhhc0hhbmRsZShub2RlLm5vZGUpIDogbm9kZTtcbn1cbi8qKlxuRmluZCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBmb3IgdGhlIHRva2VuIGF0IGBwb3NgLCBzY2FubmluZ1xuZGlyZWN0aW9uIGBkaXJgLiBPbmx5IHRoZSBgYnJhY2tldHNgIGFuZCBgbWF4U2NhbkRpc3RhbmNlYFxucHJvcGVydGllcyBhcmUgdXNlZCBmcm9tIGBjb25maWdgLCBpZiBnaXZlbi4gUmV0dXJucyBudWxsIGlmIG5vXG5icmFja2V0IHdhcyBmb3VuZCBhdCBgcG9zYCwgb3IgYSBtYXRjaCByZXN1bHQgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjb25maWcgPSB7fSkge1xuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIG5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIGRpcik7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhjdXIudHlwZSwgZGlyLCBicmFja2V0cyk7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIGN1ci5mcm9tIDwgY3VyLnRvKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlID0gZmluZEhhbmRsZShjdXIpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiAoZGlyID4gMCA/IHBvcyA+PSBoYW5kbGUuZnJvbSAmJiBwb3MgPCBoYW5kbGUudG8gOiBwb3MgPiBoYW5kbGUuZnJvbSAmJiBwb3MgPD0gaGFuZGxlLnRvKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hNYXJrZWRCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGN1ciwgaGFuZGxlLCBtYXRjaGVzLCBicmFja2V0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIG5vZGUudHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cyk7XG59XG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgaGFuZGxlLCBtYXRjaGluZywgYnJhY2tldHMpIHtcbiAgICBsZXQgcGFyZW50ID0gdG9rZW4ucGFyZW50LCBmaXJzdFRva2VuID0geyBmcm9tOiBoYW5kbGUuZnJvbSwgdG86IGhhbmRsZS50byB9O1xuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3IoKTtcbiAgICBpZiAoY3Vyc29yICYmIChkaXIgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHRva2VuLmZyb20pIDogY3Vyc29yLmNoaWxkQWZ0ZXIodG9rZW4udG8pKSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDAgJiYgbWF0Y2hpbmcuaW5kZXhPZihjdXJzb3IudHlwZS5uYW1lKSA+IC0xICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBlbmQ6IGVuZEhhbmRsZSA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCwgbWF0Y2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCBkaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCAtZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kSGFuZGxlICYmIGVuZEhhbmRsZS5mcm9tIDwgZW5kSGFuZGxlLnRvID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXIgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCB0b2tlblR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpIHtcbiAgICBsZXQgc3RhcnRDaCA9IGRpciA8IDAgPyBzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpIDogc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKTtcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XG4gICAgaWYgKGJyYWNrZXQgPCAwIHx8IChicmFja2V0ICUgMiA9PSAwKSAhPSAoZGlyID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XG4gICAgbGV0IGl0ZXIgPSBzdGF0ZS5kb2MuaXRlclJhbmdlKHBvcywgZGlyID4gMCA/IHN0YXRlLmRvYy5sZW5ndGggOiAwKSwgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGRpc3RhbmNlID0gMDsgIShpdGVyLm5leHQoKSkuZG9uZSAmJiBkaXN0YW5jZSA8PSBtYXhTY2FuRGlzdGFuY2U7KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZGlyID4gMCA/IDAgOiB0ZXh0Lmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyB0ZXh0Lmxlbmd0aCA6IC0xOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBicmFja2V0cy5pbmRleE9mKHRleHRbcG9zXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZUlubmVyKGJhc2VQb3MgKyBwb3MsIDEpLnR5cGUgIT0gdG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChmb3VuZCAlIDIgPT0gMCkgPT0gKGRpciA+IDApKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09IDEpIHsgLy8gQ2xvc2luZ1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydFRva2VuLCBlbmQ6IHsgZnJvbTogYmFzZVBvcyArIHBvcywgdG86IGJhc2VQb3MgKyBwb3MgKyAxIH0sIG1hdGNoZWQ6IChmb3VuZCA+PiAxKSA9PSAoYnJhY2tldCA+PiAxKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5kb25lID8geyBzdGFydDogc3RhcnRUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfSA6IG51bGw7XG59XG5cbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbmZ1bmN0aW9uIGNvdW50Q29sKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4ID0gMCwgc3RhcnRWYWx1ZSA9IDApIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgICBpZiAoZW5kID09IC0xKVxuICAgICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG4gPSBzdGFydFZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpXG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuKys7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5FbmNhcHN1bGF0ZXMgYSBzaW5nbGUgbGluZSBvZiBpbnB1dC4gR2l2ZW4gdG8gc3RyZWFtIHN5bnRheCBjb2RlLFxud2hpY2ggdXNlcyBpdCB0byB0b2tlbml6ZSB0aGUgY29udGVudC5cbiovXG5jbGFzcyBTdHJpbmdTdHJlYW0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN0cmVhbS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsaW5lLlxuICAgICovXG4gICAgc3RyaW5nLCB0YWJTaXplLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBpbmRlbnQgdW5pdCBzaXplLlxuICAgICovXG4gICAgaW5kZW50VW5pdCwgb3ZlcnJpZGVJbmRlbnQpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgIHRoaXMuaW5kZW50VW5pdCA9IGluZGVudFVuaXQ7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVJbmRlbnQgPSBvdmVycmlkZUluZGVudDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBzb2woKSB7IHJldHVybiB0aGlzLnBvcyA9PSAwOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXG4gICAgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxuICAgIC8qKlxuICAgIFJlYWQgdGhlIG5leHQgY29kZSB1bml0IGFuZCBhZHZhbmNlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXG4gICAgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlLiBDb25zdW1lIGFuZCByZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIGVhdChtYXRjaCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgb2s7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbWF0Y2hpbmcgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzdHJpbmcsXG4gICAgcmVndWxhciBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIFJldHVybiB0cnVlIGlmIGFueVxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cbiAgICAqL1xuICAgIGVhdFdoaWxlKG1hdGNoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN1bWUgd2hpdGVzcGFjZSBhaGVhZCBvZiBgdGhpcy5wb3NgLiBSZXR1cm4gdHJ1ZSBpZiBhbnkgd2FzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBlYXRTcGFjZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNraXBUb0VuZCgpIHsgdGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIGRpcmVjdGx5IGJlZm9yZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcbiAgICBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG8oY2gpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBmb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIGJhY2tVcChuKSB7IHRoaXMucG9zIC09IG47IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgY29sdW1uKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbCh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3ZlcnJpZGVJbmRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvdW50Q29sKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgaW5wdXQgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICh3aGljaCBzaG91bGQgc3RhcnQgd2l0aCBhIGBeYCkuIFJldHVybiB0cnVlIG9yIHRoZSByZWdleHAgbWF0Y2hcbiAgICBpZiBpdCBtYXRjaGVzLlxuICAgIFxuICAgIFVubGVzcyBgY29uc3VtZWAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoaXMgd2lsbCBtb3ZlIGB0aGlzLnBvc2BcbiAgICBwYXN0IHRoZSBtYXRjaGVkIHRleHQuXG4gICAgXG4gICAgV2hlbiBtYXRjaGluZyBhIHN0cmluZyBgY2FzZUluc2Vuc2l0aXZlYCBjYW4gYmUgc2V0IHRvIHRydWUgdG9cbiAgICBtYWtlIHRoZSBtYXRjaCBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICovXG4gICAgbWF0Y2gocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgY2FzZWQgPSAoc3RyKSA9PiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjtcbiAgICAgICAgICAgIGxldCBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAqL1xuICAgIGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7IH1cbn1cblxuZnVuY3Rpb24gZnVsbFBhcnNlcihzcGVjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogc3BlYy5uYW1lIHx8IFwiXCIsXG4gICAgICAgIHRva2VuOiBzcGVjLnRva2VuLFxuICAgICAgICBibGFua0xpbmU6IHNwZWMuYmxhbmtMaW5lIHx8ICgoKSA9PiB7IH0pLFxuICAgICAgICBzdGFydFN0YXRlOiBzcGVjLnN0YXJ0U3RhdGUgfHwgKCgpID0+IHRydWUpLFxuICAgICAgICBjb3B5U3RhdGU6IHNwZWMuY29weVN0YXRlIHx8IGRlZmF1bHRDb3B5U3RhdGUsXG4gICAgICAgIGluZGVudDogc3BlYy5pbmRlbnQgfHwgKCgpID0+IG51bGwpLFxuICAgICAgICBsYW5ndWFnZURhdGE6IHNwZWMubGFuZ3VhZ2VEYXRhIHx8IHt9LFxuICAgICAgICB0b2tlblRhYmxlOiBzcGVjLnRva2VuVGFibGUgfHwgbm9Ub2tlbnMsXG4gICAgICAgIG1lcmdlVG9rZW5zOiBzcGVjLm1lcmdlVG9rZW5zICE9PSBmYWxzZVxuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29weVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgbGV0IG5ld1N0YXRlID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsID0gc3RhdGVbcHJvcF07XG4gICAgICAgIG5ld1N0YXRlW3Byb3BdID0gKHZhbCBpbnN0YW5jZW9mIEFycmF5ID8gdmFsLnNsaWNlKCkgOiB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG59XG5jb25zdCBJbmRlbnRlZEZyb20gPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8qKlxuQSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGNsYXNzIGJhc2VkIG9uIGEgQ29kZU1pcnJvclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxuKi9cbmNsYXNzIFN0cmVhbUxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQocGFyc2VyLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIGxldCBwID0gZnVsbFBhcnNlcihwYXJzZXIpLCBzZWxmO1xuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHNlbGYsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKGRhdGEsIGltcGwsIFtdLCBwYXJzZXIubmFtZSk7XG4gICAgICAgIHRoaXMudG9wTm9kZSA9IGRvY0lEKGRhdGEsIHRoaXMpO1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnRva2VuVGFibGUgPSBwYXJzZXIudG9rZW5UYWJsZSA/IG5ldyBUb2tlblRhYmxlKHAudG9rZW5UYWJsZSkgOiBkZWZhdWx0VG9rZW5UYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RyZWFtIGxhbmd1YWdlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEluZGVudChjeCkge1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHsgb3ZlcnJpZGVJbmRlbnRhdGlvbiB9ID0gY3gub3B0aW9ucztcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgIGZyb20gPSBJbmRlbnRlZEZyb20uZ2V0KGN4LnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmcm9tICE9IG51bGwgJiYgZnJvbSA8IGN4LnBvcyAtIDFlNClcbiAgICAgICAgICAgICAgICBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZpbmRTdGF0ZSh0aGlzLCBjeC5ub2RlLnRyZWUsIGN4Lm5vZGUuZnJvbSwgY3gubm9kZS5mcm9tLCBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBjeC5wb3MpLCBzdGF0ZVBvcywgc3RhdGU7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gc3RhcnQucG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShjeC51bml0KTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gY3gubm9kZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjeC5wb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIEMuTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgY3gucG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihjeC5wb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudGF0aW9uID0gb3ZlcnJpZGVJbmRlbnRhdGlvbiA/IG92ZXJyaWRlSW5kZW50YXRpb24obGluZS5mcm9tKSA6IC0xO1xuICAgICAgICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY3guc3RhdGUudGFiU2l6ZSwgY3gudW5pdCwgaW5kZW50YXRpb24gPCAwID8gdW5kZWZpbmVkIDogaW5kZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICByZWFkVG9rZW4odGhpcy5zdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHN0YXRlLCBjeC51bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT0gY3gucG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IGN4LmxpbmVBdChjeC5wb3MpO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbiAmJiBmcm9tID09IG51bGwpXG4gICAgICAgICAgICBJbmRlbnRlZEZyb20uc2V0KGN4LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1QYXJzZXIuaW5kZW50KHN0YXRlLCAvXlxccyooLiopLy5leGVjKGxpbmUudGV4dClbMV0sIGN4KTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuZnVuY3Rpb24gZmluZFN0YXRlKGxhbmcsIHRyZWUsIG9mZiwgc3RhcnRQb3MsIGJlZm9yZSkge1xuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XG4gICAgaWYgKHN0YXRlKVxuICAgICAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHN0YXRlKSwgcG9zOiBvZmYgKyB0cmVlLmxlbmd0aCB9O1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIHBvcyA9IG9mZiArIHRyZWUucG9zaXRpb25zW2ldO1xuICAgICAgICBsZXQgZm91bmQgPSBjaGlsZCBpbnN0YW5jZW9mIFRyZWUgJiYgcG9zIDwgYmVmb3JlICYmIGZpbmRTdGF0ZShsYW5nLCBjaGlsZCwgcG9zLCBzdGFydFBvcywgYmVmb3JlKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGN1dFRyZWUobGFuZywgdHJlZSwgZnJvbSwgdG8sIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICBpZiAoIWluc2lkZSAmJiBmcm9tID09IDAgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XG4gICAgICAgIGlmIChwb3MgPCB0byAmJiBjaGlsZCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChpbm5lciksIHRyZWUucG9zaXRpb25zLnNsaWNlKDAsIGkgKyAxKSwgcG9zICsgaW5uZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgc3RhcnRQb3MsIGVuZFBvcywgZWRpdG9yU3RhdGUpIHtcbiAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cykge1xuICAgICAgICBsZXQgZnJvbSA9IGYuZnJvbSArIChmLm9wZW5TdGFydCA/IDI1IDogMCksIHRvID0gZi50byAtIChmLm9wZW5FbmQgPyAyNSA6IDApO1xuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgZm91bmQucG9zIDw9IGVuZFBvcyAmJiAodHJlZSA9IGN1dFRyZWUobGFuZywgZi50cmVlLCBzdGFydFBvcyArIGYub2Zmc2V0LCBmb3VuZC5wb3MgKyBmLm9mZnNldCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBmb3VuZC5zdGF0ZSwgdHJlZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShlZGl0b3JTdGF0ZSA/IGdldEluZGVudFVuaXQoZWRpdG9yU3RhdGUpIDogNCksIHRyZWU6IFRyZWUuZW1wdHkgfTtcbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5nLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKSwgZnJvbSA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICBsZXQgeyBzdGF0ZSwgdHJlZSB9ID0gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBmcm9tLCB0aGlzLnRvLCBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuc3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gdGhpcy5jaHVua1N0YXJ0ID0gZnJvbSArIHRyZWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godHJlZS5wb3NpdGlvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zIDwgY29udGV4dC52aWV3cG9ydC5mcm9tIC0gMTAwMDAwIC8qIEMuTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLyAmJlxuICAgICAgICAgICAgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gY29udGV4dC52aWV3cG9ydC5mcm9tICYmIHIudG8gPj0gY29udGV4dC52aWV3cG9ydC5mcm9tKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKTtcbiAgICAgICAgbGV0IHBhcnNlRW5kID0gdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCA/IHRoaXMudG8gOiBNYXRoLm1pbih0aGlzLnRvLCB0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgNTEyIC8qIEMuQ2h1bmtTaXplICovKTtcbiAgICAgICAgaWYgKGNvbnRleHQpXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNvbnRleHQudmlld3BvcnQudG8pO1xuICAgICAgICB3aGlsZSAodGhpcy5wYXJzZWRQb3MgPCBlbmQpXG4gICAgICAgICAgICB0aGlzLnBhcnNlTGluZShjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuaygpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPj0gcGFyc2VFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPj0gY29udGV4dC52aWV3cG9ydC50bykge1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIHBhcnNlRW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICBsaW5lQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsocG9zKTtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmxpbmVDaHVua3MpIHtcbiAgICAgICAgICAgIGxldCBlb2wgPSBjaHVuay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgaWYgKGVvbCA+IC0xKVxuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UoMCwgZW9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuayA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBjaHVuayA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyArIGNodW5rLmxlbmd0aCA8PSB0aGlzLnRvID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKTtcbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5wYXJzZWRQb3MsIGxpbmUgPSB0aGlzLmxpbmVBZnRlcihmcm9tKSwgZW5kID0gZnJvbSArIGxpbmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDs7KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VFbmQgPSB0aGlzLnJhbmdlc1tpbmRleF0udG87XG4gICAgICAgICAgICBpZiAocmFuZ2VFbmQgPj0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgcmFuZ2VFbmQgLSAoZW5kIC0gbGluZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHJhbmdlU3RhcnQgPSB0aGlzLnJhbmdlc1tpbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHRoaXMubGluZUFmdGVyKHJhbmdlU3RhcnQpO1xuICAgICAgICAgICAgbGluZSArPSBhZnRlcjtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlU3RhcnQgKyBhZnRlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgZW5kIH07XG4gICAgfVxuICAgIHNraXBHYXBzVG8ocG9zLCBvZmZzZXQsIHNpZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8sIG9mZlBvcyA9IHBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzaWRlID4gMCA/IGVuZCA+IG9mZlBvcyA6IGVuZCA+PSBvZmZQb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF0uZnJvbTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdGFydCAtIGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBtb3ZlUmFuZ2VJbmRleCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8gPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCsrO1xuICAgIH1cbiAgICBlbWl0VG9rZW4oaWQsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNpemUgPSA0O1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDQ7XG4gICAgICAgIGlmICh0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLm1lcmdlVG9rZW5zICYmIHNpemUgPT0gNCAmJiBsYXN0ID49IDAgJiZcbiAgICAgICAgICAgIHRoaXMuY2h1bmtbbGFzdF0gPT0gaWQgJiYgdGhpcy5jaHVua1tsYXN0ICsgMl0gPT0gZnJvbSlcbiAgICAgICAgICAgIHRoaXMuY2h1bmtbbGFzdCArIDJdID0gdG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2h1bmsucHVzaChpZCwgZnJvbSwgdG8sIHNpemUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBwYXJzZUxpbmUoY29udGV4dCkge1xuICAgICAgICBsZXQgeyBsaW5lLCBlbmQgfSA9IHRoaXMubmV4dExpbmUoKSwgb2Zmc2V0ID0gMCwgeyBzdHJlYW1QYXJzZXIgfSA9IHRoaXMubGFuZztcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZSwgY29udGV4dCA/IGNvbnRleHQuc3RhdGUudGFiU2l6ZSA6IDQsIGNvbnRleHQgPyBnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpIDogMik7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIHN0cmVhbVBhcnNlci5ibGFua0xpbmUodGhpcy5zdGF0ZSwgc3RyZWFtLmluZGVudFVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSByZWFkVG9rZW4oc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5lbWl0VG9rZW4odGhpcy5sYW5nLnRva2VuVGFibGUucmVzb2x2ZSh0b2tlbiksIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnN0YXJ0LCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5wb3MsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zdGFydCA+IDEwMDAwIC8qIEMuTWF4TGluZUxlbmd0aCAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zIDwgdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zKys7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKCkge1xuICAgICAgICBsZXQgdHJlZSA9IFRyZWUuYnVpbGQoe1xuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmNodW5rLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5wYXJzZWRQb3MgLSB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IDAsXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDUxMiAvKiBDLkNodW5rU2l6ZSAqLyxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJlZSA9IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmxhbmcudG9wTm9kZSwgdGhpcy5jaHVua3MsIHRoaXMuY2h1bmtQb3MsIHRoaXMucGFyc2VkUG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSkuYmFsYW5jZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbih0b2tlbiwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gcGFyc2VyIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG59XG5jb25zdCBub1Rva2VucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW05vZGVUeXBlLm5vbmVdO1xuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xuY29uc3Qgd2FybmVkID0gW107XG4vLyBDYWNoZSBvZiBub2RlIHR5cGVzIGJ5IG5hbWUgYW5kIHRhZ3NcbmNvbnN0IGJ5VGFnID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZWZhdWx0VGFibGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXG4gICAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gICAgW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCJdLFxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXG4gICAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gICAgW1widGFnXCIsIFwidGFnTmFtZVwiXSxcbiAgICBbXCJhdHRyaWJ1dGVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgICBbXCJidWlsdGluXCIsIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCJdLFxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxuICAgIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgICBbXCJoZWFkZXJcIiwgXCJoZWFkaW5nXCJdLFxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXG5dKVxuICAgIGRlZmF1bHRUYWJsZVtsZWdhY3lOYW1lXSA9IC8qQF9fUFVSRV9fKi9jcmVhdGVUb2tlblR5cGUobm9Ub2tlbnMsIG5hbWUpO1xuY2xhc3MgVG9rZW5UYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhZykge1xuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFncyQxID0gW107XG4gICAgZm9yIChsZXQgbmFtZSBvZiB0YWdTdHIuc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIG5hbWUuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFVua25vd24gaGlnaGxpZ2h0aW5nIHRhZyAke3BhcnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLm1hcCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVGFnICR7cGFydH0gdXNlZCBhcyBtb2RpZmllcmApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0YWcgb2YgZm91bmQpXG4gICAgICAgICAgICB0YWdzJDEucHVzaCh0YWcpO1xuICAgIH1cbiAgICBpZiAoIXRhZ3MkMS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBuYW1lID0gdGFnU3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpLCBrZXkgPSBuYW1lICsgXCIgXCIgKyB0YWdzJDEubWFwKHQgPT4gdC5pZCk7XG4gICAgbGV0IGtub3duID0gYnlUYWdba2V5XTtcbiAgICBpZiAoa25vd24pXG4gICAgICAgIHJldHVybiBrbm93bi5pZDtcbiAgICBsZXQgdHlwZSA9IGJ5VGFnW2tleV0gPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZ3MkMSB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEsIGxhbmcpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbXG4gICAgICAgICAgICBsYW5ndWFnZURhdGFQcm9wLmFkZCgoKSA9PiBkYXRhKSxcbiAgICAgICAgICAgIGluZGVudE5vZGVQcm9wLmFkZCgoKSA9PiBjeCA9PiBsYW5nLmdldEluZGVudChjeCkpXG4gICAgICAgIF0sIHRvcDogdHJ1ZSB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5sZW5ndGggPD0gNDA5NiAmJiAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vLnRlc3QobGluZSk7XG59XG5mdW5jdGlvbiB0ZXh0SGFzUlRMKHRleHQpIHtcbiAgICBmb3IgKGxldCBpID0gdGV4dC5pdGVyKCk7ICFpLm5leHQoKS5kb25lOylcbiAgICAgICAgaWYgKGJ1aWxkRm9yTGluZShpLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoYW5nZUFkZHNSVEwoY2hhbmdlKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgY2hhbmdlLml0ZXJDaGFuZ2VzKChmQSwgdEEsIGZCLCB0QiwgaW5zKSA9PiB7XG4gICAgICAgIGlmICghYWRkZWQgJiYgdGV4dEhhc1JUTChpbnMpKVxuICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBhZGRlZDtcbn1cbmNvbnN0IGFsd2F5c0lzb2xhdGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geCkgfSk7XG4vKipcbk1ha2Ugc3VyZSBub2Rlc1xuW21hcmtlZF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbW9uLk5vZGVQcm9wXmlzb2xhdGUpXG5hcyBpc29sYXRpbmcgZm9yIGJpZGlyZWN0aW9uYWwgdGV4dCBhcmUgcmVuZGVyZWQgaW4gYSB3YXkgdGhhdFxuaXNvbGF0ZXMgdGhlbSBmcm9tIHRoZSBzdXJyb3VuZGluZyB0ZXh0LlxuKi9cbmZ1bmN0aW9uIGJpZGlJc29sYXRlcyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZXh0ZW5zaW9ucyA9IFtpc29sYXRlTWFya3NdO1xuICAgIGlmIChvcHRpb25zLmFsd2F5c0lzb2xhdGUpXG4gICAgICAgIGV4dGVuc2lvbnMucHVzaChhbHdheXNJc29sYXRlLm9mKHRydWUpKTtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucztcbn1cbmNvbnN0IGlzb2xhdGVNYXJrcyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmFsd2F5cyA9IHZpZXcuc3RhdGUuZmFjZXQoYWx3YXlzSXNvbGF0ZSkgfHxcbiAgICAgICAgICAgIHZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSIHx8XG4gICAgICAgICAgICB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmhhc1JUTCA9ICF0aGlzLmFsd2F5cyAmJiB0ZXh0SGFzUlRMKHZpZXcuc3RhdGUuZG9jKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYWx3YXlzIHx8IHRoaXMuaGFzUlRMID8gYnVpbGREZWNvKHZpZXcsIHRoaXMudHJlZSwgdGhpcy5hbHdheXMpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBhbHdheXMgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWx3YXlzSXNvbGF0ZSkgfHxcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiB8fFxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIWFsd2F5cyAmJiAhdGhpcy5oYXNSVEwgJiYgY2hhbmdlQWRkc1JUTCh1cGRhdGUuY2hhbmdlcykpXG4gICAgICAgICAgICB0aGlzLmhhc1JUTCA9IHRydWU7XG4gICAgICAgIGlmICghYWx3YXlzICYmICF0aGlzLmhhc1JUTClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChhbHdheXMgIT0gdGhpcy5hbHdheXMgfHwgdHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuYWx3YXlzID0gYWx3YXlzO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGJ1aWxkRGVjbyh1cGRhdGUudmlldywgdHJlZSwgYWx3YXlzKTtcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4ge1xuICAgICAgICBmdW5jdGlvbiBhY2Nlc3Modmlldykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjb3JhdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW0VkaXRvclZpZXcub3V0ZXJEZWNvcmF0aW9ucy5vZihhY2Nlc3MpLFxuICAgICAgICAgICAgUHJlYy5sb3dlc3QoRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMub2YoYWNjZXNzKSldO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gYnVpbGREZWNvKHZpZXcsIHRyZWUsIGFsd2F5cykge1xuICAgIGxldCBkZWNvID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgIGxldCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKCFhbHdheXMpXG4gICAgICAgIHJhbmdlcyA9IGNsaXBSVExMaW5lcyhyYW5nZXMsIHZpZXcuc3RhdGUuZG9jKTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIHRyZWUuaXRlcmF0ZSh7XG4gICAgICAgICAgICBlbnRlcjogbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzbyA9IG5vZGUudHlwZS5wcm9wKE5vZGVQcm9wLmlzb2xhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc28pXG4gICAgICAgICAgICAgICAgICAgIGRlY28uYWRkKG5vZGUuZnJvbSwgbm9kZS50bywgbWFya3NbaXNvXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbSwgdG9cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvLmZpbmlzaCgpO1xufVxuZnVuY3Rpb24gY2xpcFJUTExpbmVzKHJhbmdlcywgZG9jKSB7XG4gICAgbGV0IGN1ciA9IGRvYy5pdGVyKCksIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsYXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QudG8gPiBmcm9tKSB7XG4gICAgICAgICAgICBmcm9tID0gbGFzdC50bztcbiAgICAgICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgKyBjdXIudmFsdWUubGVuZ3RoIDwgZnJvbSkge1xuICAgICAgICAgICAgY3VyLm5leHQoZnJvbSAtIChwb3MgKyBjdXIudmFsdWUubGVuZ3RoKSk7XG4gICAgICAgICAgICBwb3MgPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcywgZW5kID0gcG9zICsgY3VyLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghY3VyLmxpbmVCcmVhayAmJiBidWlsZEZvckxpbmUoY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QudG8gPiBzdGFydCAtIDEwKVxuICAgICAgICAgICAgICAgICAgICBsYXN0LnRvID0gTWF0aC5taW4odG8sIGVuZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXN0ID0geyBmcm9tOiBzdGFydCwgdG86IE1hdGgubWluKHRvLCBlbmQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG1hcmtzID0ge1xuICAgIHJ0bDogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcInJ0bFwiIH0sIGJpZGlJc29sYXRlOiBEaXJlY3Rpb24uUlRMIH0pLFxuICAgIGx0cjogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcImx0clwiIH0sIGJpZGlJc29sYXRlOiBEaXJlY3Rpb24uTFRSIH0pLFxuICAgIGF1dG86IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJhdXRvXCIgfSwgYmlkaUlzb2xhdGU6IG51bGwgfSlcbn07XG5cbmV4cG9ydCB7IERvY0lucHV0LCBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYmlkaUlzb2xhdGVzLCBicmFja2V0TWF0Y2hpbmcsIGJyYWNrZXRNYXRjaGluZ0hhbmRsZSwgY29kZUZvbGRpbmcsIGNvbnRpbnVlZEluZGVudCwgZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBkZWxpbWl0ZWRJbmRlbnQsIGVuc3VyZVN5bnRheFRyZWUsIGZsYXRJbmRlbnQsIGZvbGRBbGwsIGZvbGRDb2RlLCBmb2xkRWZmZWN0LCBmb2xkR3V0dGVyLCBmb2xkSW5zaWRlLCBmb2xkS2V5bWFwLCBmb2xkTm9kZVByb3AsIGZvbGRTZXJ2aWNlLCBmb2xkU3RhdGUsIGZvbGRhYmxlLCBmb2xkZWRSYW5nZXMsIGZvcmNlUGFyc2luZywgZ2V0SW5kZW50VW5pdCwgZ2V0SW5kZW50YXRpb24sIGhpZ2hsaWdodGluZ0ZvciwgaW5kZW50Tm9kZVByb3AsIGluZGVudE9uSW5wdXQsIGluZGVudFJhbmdlLCBpbmRlbnRTZXJ2aWNlLCBpbmRlbnRTdHJpbmcsIGluZGVudFVuaXQsIGxhbmd1YWdlLCBsYW5ndWFnZURhdGFQcm9wLCBtYXRjaEJyYWNrZXRzLCBzdWJsYW5ndWFnZVByb3AsIHN5bnRheEhpZ2hsaWdodGluZywgc3ludGF4UGFyc2VyUnVubmluZywgc3ludGF4VHJlZSwgc3ludGF4VHJlZUF2YWlsYWJsZSwgdG9nZ2xlRm9sZCwgdW5mb2xkQWxsLCB1bmZvbGRDb2RlLCB1bmZvbGRFZmZlY3QgfTtcbiJdLCJuYW1lcyI6WyJOb2RlUHJvcCIsIkl0ZXJNb2RlIiwiVHJlZSIsIlRyZWVGcmFnbWVudCIsIlBhcnNlciIsIk5vZGVUeXBlIiwiTm9kZVNldCIsIlN0YXRlRWZmZWN0IiwiU3RhdGVGaWVsZCIsIkZhY2V0IiwiRWRpdG9yU3RhdGUiLCJjb3VudENvbHVtbiIsImNvbWJpbmVDb25maWciLCJSYW5nZVNldCIsIlJhbmdlU2V0QnVpbGRlciIsIlByZWMiLCJWaWV3UGx1Z2luIiwibG9nRXhjZXB0aW9uIiwiRWRpdG9yVmlldyIsIkRlY29yYXRpb24iLCJXaWRnZXRUeXBlIiwiZ3V0dGVyIiwiR3V0dGVyTWFya2VyIiwiRGlyZWN0aW9uIiwidGFncyIsInRhZ0hpZ2hsaWdodGVyIiwiaGlnaGxpZ2h0VHJlZSIsInN0eWxlVGFncyIsIlN0eWxlTW9kdWxlIiwiX2EiLCJsYW5ndWFnZURhdGFQcm9wIiwiZGVmaW5lTGFuZ3VhZ2VGYWNldCIsImJhc2VEYXRhIiwiZGVmaW5lIiwiY29tYmluZSIsInZhbHVlcyIsImNvbmNhdCIsInVuZGVmaW5lZCIsInN1Ymxhbmd1YWdlUHJvcCIsIkxhbmd1YWdlIiwiY29uc3RydWN0b3IiLCJkYXRhIiwicGFyc2VyIiwiZXh0cmFFeHRlbnNpb25zIiwibmFtZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJzeW50YXhUcmVlIiwiZXh0ZW5zaW9uIiwibGFuZ3VhZ2UiLCJvZiIsImxhbmd1YWdlRGF0YSIsInN0YXRlIiwicG9zIiwic2lkZSIsInRvcCIsInRvcE5vZGVBdCIsInR5cGUiLCJwcm9wIiwiYmFzZSIsImZhY2V0Iiwic3ViIiwiaW5uZXJOb2RlIiwicmVzb2x2ZSIsImZyb20iLCJzdWJsYW5nIiwidGVzdCIsImlzQWN0aXZlQXQiLCJmaW5kUmVnaW9ucyIsImxhbmciLCJ0byIsImRvYyIsImxlbmd0aCIsImFsbG93c05lc3RpbmciLCJyZXN1bHQiLCJleHBsb3JlIiwidHJlZSIsInB1c2giLCJtb3VudCIsIm1vdW50ZWQiLCJvdmVybGF5IiwiciIsInNpemUiLCJpIiwiY2hpbGRyZW4iLCJjaCIsInBvc2l0aW9ucyIsInNldFN0YXRlIiwidG9wTGFuZyIsInRvcE5vZGUiLCJub2RlIiwiZW50ZXIiLCJFeGNsdWRlQnVmZmVycyIsIkVudGVyQnJhY2tldGVkIiwiaXNUb3AiLCJMUkxhbmd1YWdlIiwic3BlYyIsImNvbmZpZ3VyZSIsInByb3BzIiwiYWRkIiwib3B0aW9ucyIsImhhc1dyYXBwZXJzIiwiZmllbGQiLCJlbXB0eSIsImVuc3VyZVN5bnRheFRyZWUiLCJ1cHRvIiwidGltZW91dCIsInBhcnNlIiwiY29udGV4dCIsIm9sZFZpZXBvcnQiLCJ2aWV3cG9ydCIsInVwZGF0ZVZpZXdwb3J0IiwiaXNEb25lIiwid29yayIsInN5bnRheFRyZWVBdmFpbGFibGUiLCJmb3JjZVBhcnNpbmciLCJ2aWV3Iiwic3VjY2VzcyIsImRpc3BhdGNoIiwic3ludGF4UGFyc2VyUnVubmluZyIsInBsdWdpbiIsInBhcnNlV29ya2VyIiwiaXNXb3JraW5nIiwiRG9jSW5wdXQiLCJjdXJzb3JQb3MiLCJzdHJpbmciLCJjdXJzb3IiLCJpdGVyIiwic3luY1RvIiwibmV4dCIsInZhbHVlIiwiY2h1bmsiLCJsaW5lQ2h1bmtzIiwicmVhZCIsInN0cmluZ1N0YXJ0Iiwic2xpY2VTdHJpbmciLCJzbGljZSIsImN1cnJlbnRDb250ZXh0IiwiUGFyc2VDb250ZXh0IiwiZnJhZ21lbnRzIiwidHJlZUxlbiIsInNraXBwZWQiLCJzY2hlZHVsZU9uIiwidGVtcFNraXBwZWQiLCJjcmVhdGUiLCJzdGFydFBhcnNlIiwidW50aWwiLCJ0YWtlVHJlZSIsIndpdGhDb250ZXh0IiwiZW5kVGltZSIsIkRhdGUiLCJub3ciLCJzdG9wcGVkQXQiLCJzdG9wQXQiLCJkb25lIiwiYWR2YW5jZSIsIndpdGhvdXRUZW1wU2tpcHBlZCIsImFkZFRyZWUiLCJwYXJzZWRQb3MiLCJmIiwicHJldiIsInBvcCIsImN1dEZyYWdtZW50cyIsImNoYW5nZXMiLCJuZXdTdGF0ZSIsInJhbmdlcyIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImFwcGx5Q2hhbmdlcyIsIm1hcFBvcyIsInN0YXJ0TGVuIiwic3BsaWNlIiwicmVzZXQiLCJza2lwVW50aWxJblZpZXciLCJnZXRTa2lwcGluZ1BhcnNlciIsImNyZWF0ZVBhcnNlIiwiaW5wdXQiLCJjeCIsIlByb21pc2UiLCJhbGwiLCJub25lIiwiTWF0aCIsIm1pbiIsImZyYWdzIiwiTGFuZ3VhZ2VTdGF0ZSIsImFwcGx5IiwidHIiLCJkb2NDaGFuZ2VkIiwibmV3Q3giLCJzdGFydFN0YXRlIiwibWF4IiwiaW5pdCIsInZwVG8iLCJwYXJzZVN0YXRlIiwidXBkYXRlIiwiZSIsImVmZmVjdHMiLCJpcyIsInJlcXVlc3RJZGxlIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdElkbGVDYWxsYmFjayIsImlkbGUiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJpc0lucHV0UGVuZGluZyIsIm5hdmlnYXRvciIsInNjaGVkdWxpbmciLCJmcm9tQ2xhc3MiLCJQYXJzZVdvcmtlciIsIndvcmtpbmciLCJ3b3JrU2NoZWR1bGVkIiwiY2h1bmtFbmQiLCJjaHVua0J1ZGdldCIsImJpbmQiLCJzY2hlZHVsZVdvcmsiLCJzZWxlY3Rpb25TZXQiLCJoYXNGb2N1cyIsImNoZWNrQXN5bmNTY2hlZHVsZSIsImRlYWRsaW5lIiwidGltZVJlbWFpbmluZyIsInZpZXdwb3J0Rmlyc3QiLCJ0aGVuIiwiY2F0Y2giLCJlcnIiLCJkZXN0cm95IiwiZXZlbnRIYW5kbGVycyIsImZvY3VzIiwibGFuZ3VhZ2VzIiwiZW5hYmxlcyIsImNvbnRlbnRBdHRyaWJ1dGVzIiwiY29tcHV0ZSIsIkxhbmd1YWdlU3VwcG9ydCIsInN1cHBvcnQiLCJMYW5ndWFnZURlc2NyaXB0aW9uIiwiYWxpYXMiLCJleHRlbnNpb25zIiwiZmlsZW5hbWUiLCJsb2FkRnVuYyIsImxvYWRpbmciLCJsb2FkIiwiUmFuZ2VFcnJvciIsIm1hcCIsInMiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoRmlsZW5hbWUiLCJkZXNjcyIsImQiLCJleHQiLCJleGVjIiwiaW5kZXhPZiIsIm1hdGNoTGFuZ3VhZ2VOYW1lIiwiZnV6enkiLCJzb21lIiwiYSIsImZvdW5kIiwiaW5kZW50U2VydmljZSIsImluZGVudFVuaXQiLCJ1bml0IiwiQXJyYXkiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRJbmRlbnRVbml0IiwiY2hhckNvZGVBdCIsInRhYlNpemUiLCJpbmRlbnRTdHJpbmciLCJjb2xzIiwidHMiLCJnZXRJbmRlbnRhdGlvbiIsIkluZGVudENvbnRleHQiLCJzZXJ2aWNlIiwic3ludGF4SW5kZW50YXRpb24iLCJpbmRlbnRSYW5nZSIsInVwZGF0ZWQiLCJvdmVycmlkZUluZGVudGF0aW9uIiwic3RhcnQiLCJsaW5lIiwibGluZUF0IiwiaW5kZW50IiwidGV4dCIsImN1ciIsIm5vcm0iLCJpbnNlcnQiLCJiaWFzIiwic2ltdWxhdGVCcmVhayIsInNpbXVsYXRlRG91YmxlQnJlYWsiLCJ0ZXh0QWZ0ZXJQb3MiLCJjb2x1bW4iLCJvdmVycmlkZSIsInNlYXJjaCIsImxpbmVJbmRlbnQiLCJvdmVycmlkZW4iLCJzaW11bGF0ZWRCcmVhayIsImluZGVudE5vZGVQcm9wIiwiYXN0Iiwic3RhY2siLCJyZXNvbHZlU3RhY2siLCJpbm5lciIsInJlc29sdmVJbm5lciIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwicGFyZW50IiwiaW5kZW50Rm9yIiwic3RyYXRlZ3kiLCJpbmRlbnRTdHJhdGVneSIsIlRyZWVJbmRlbnRDb250ZXh0IiwiaWdub3JlQ2xvc2VkIiwiZmlyc3QiLCJmaXJzdENoaWxkIiwiY2xvc2UiLCJjbG9zZWRCeSIsImxhc3QiLCJsYXN0Q2hpbGQiLCJjbG9zZWQiLCJkZWxpbWl0ZWRTdHJhdGVneSIsInRvcEluZGVudCIsInRleHRBZnRlciIsImJhc2VJbmRlbnQiLCJiYXNlSW5kZW50Rm9yIiwiYXRCcmVhayIsImlzUGFyZW50IiwiY29udGludWUiLCJicmFja2V0ZWRBbGlnbmVkIiwib3BlblRva2VuIiwiY2hpbGRBZnRlciIsInNpbSIsIm9wZW5MaW5lIiwibGluZUVuZCIsImlzU2tpcHBlZCIsInNwYWNlIiwiZGVsaW1pdGVkSW5kZW50IiwiY2xvc2luZyIsImFsaWduIiwidW5pdHMiLCJjbG9zZWRBdCIsImFmdGVyIiwibWF0Y2giLCJhbGlnbmVkIiwiZmxhdEluZGVudCIsImNvbnRpbnVlZEluZGVudCIsImV4Y2VwdCIsIm1hdGNoRXhjZXB0IiwiRG9udEluZGVudEJleW9uZCIsImluZGVudE9uSW5wdXQiLCJ0cmFuc2FjdGlvbkZpbHRlciIsImlzVXNlckV2ZW50IiwicnVsZXMiLCJsYW5ndWFnZURhdGFBdCIsInNlbGVjdGlvbiIsIm1haW4iLCJoZWFkIiwibmV3RG9jIiwibmV3U2VsZWN0aW9uIiwibGluZVN0YXJ0Iiwic2VxdWVudGlhbCIsImZvbGRTZXJ2aWNlIiwiZm9sZE5vZGVQcm9wIiwiZm9sZEluc2lkZSIsImlzRXJyb3IiLCJzeW50YXhGb2xkaW5nIiwiZW5kIiwiaXNVbmZpbmlzaGVkIiwiZm9sZGFibGUiLCJtYXBSYW5nZSIsInJhbmdlIiwibWFwcGluZyIsImZvbGRFZmZlY3QiLCJ1bmZvbGRFZmZlY3QiLCJzZWxlY3RlZExpbmVzIiwibGluZXMiLCJsIiwibGluZUJsb2NrQXQiLCJmb2xkU3RhdGUiLCJmb2xkZWQiLCJjbGVhclRvdWNoZWRGb2xkcyIsImZvbGRFeGlzdHMiLCJwcmVwYXJlUGxhY2Vob2xkZXIiLCJmb2xkQ29uZmlnIiwid2lkZ2V0IiwiZm9sZFdpZGdldCIsInJlcGxhY2UiLCJQcmVwYXJlZEZvbGRXaWRnZXQiLCJmaWx0ZXIiLCJmaWx0ZXJGcm9tIiwiZmlsdGVyVG8iLCJwcm92aWRlIiwiZGVjb3JhdGlvbnMiLCJ0b0pTT04iLCJiZXR3ZWVuIiwiZnJvbUpTT04iLCJpc0FycmF5Iiwic2V0IiwidG91Y2hlZCIsImIiLCJmb2xkZWRSYW5nZXMiLCJmaW5kRm9sZCIsIm1heWJlRW5hYmxlIiwib3RoZXIiLCJhcHBlbmRDb25maWciLCJjb2RlRm9sZGluZyIsImZvbGRDb2RlIiwiYW5ub3VuY2VGb2xkIiwidW5mb2xkQ29kZSIsImZvbGQiLCJsaW5lRnJvbSIsIm51bWJlciIsImxpbmVUbyIsImFubm91bmNlIiwicGhyYXNlIiwiZm9sZEFsbCIsInVuZm9sZEFsbCIsImZvbGRhYmxlQ29udGFpbmVyIiwibGluZUJsb2NrIiwiZm9sZGFibGVSZWdpb24iLCJ0b2dnbGVGb2xkIiwiZm9sZFJhbmdlIiwiZm9sZEtleW1hcCIsImtleSIsIm1hYyIsInJ1biIsImRlZmF1bHRDb25maWciLCJwbGFjZWhvbGRlckRPTSIsInBsYWNlaG9sZGVyVGV4dCIsImNvbmZpZyIsImJhc2VUaGVtZSQxIiwid2lkZ2V0VG9ET00iLCJwcmVwYXJlZCIsImNvbmYiLCJvbmNsaWNrIiwiZXZlbnQiLCJwb3NBdERPTSIsInRhcmdldCIsInByZXZlbnREZWZhdWx0IiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInRleHRDb250ZW50Iiwic2V0QXR0cmlidXRlIiwidGl0bGUiLCJjbGFzc05hbWUiLCJ0b0RPTSIsImVxIiwiZm9sZEd1dHRlckRlZmF1bHRzIiwib3BlblRleHQiLCJjbG9zZWRUZXh0IiwibWFya2VyRE9NIiwiZG9tRXZlbnRIYW5kbGVycyIsImZvbGRpbmdDaGFuZ2VkIiwiRm9sZE1hcmtlciIsIm9wZW4iLCJzcGFuIiwiZm9sZEd1dHRlciIsImZ1bGxDb25maWciLCJjYW5Gb2xkIiwiY2FuVW5mb2xkIiwibWFya2VycyIsImJ1aWxkTWFya2VycyIsInZpZXdwb3J0Q2hhbmdlZCIsImJ1aWxkZXIiLCJ2aWV3cG9ydExpbmVCbG9ja3MiLCJtYXJrIiwiZmluaXNoIiwiY2xhc3MiLCJpbml0aWFsU3BhY2VyIiwiY2xpY2siLCJiYXNlVGhlbWUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJjb2xvciIsImJvcmRlclJhZGl1cyIsIm1hcmdpbiIsInBhZGRpbmciLCJIaWdobGlnaHRTdHlsZSIsInNwZWNzIiwibW9kU3BlYyIsImRlZiIsImNscyIsIm5ld05hbWUiLCJzY29wZU9wdCIsInNjb3BlIiwic3R5bGUiLCJ0YWciLCJhc3NpZ24iLCJtb2R1bGUiLCJ0aGVtZVR5cGUiLCJoaWdobGlnaHRlckZhY2V0IiwiZmFsbGJhY2tIaWdobGlnaHRlciIsImdldEhpZ2hsaWdodGVycyIsInN5bnRheEhpZ2hsaWdodGluZyIsImhpZ2hsaWdodGVyIiwidHJlZUhpZ2hsaWdodGVyIiwic3R5bGVNb2R1bGUiLCJmYWxsYmFjayIsImNvbXB1dGVOIiwiZGFya1RoZW1lIiwiaGlnaGxpZ2h0aW5nRm9yIiwiaGlnaGxpZ2h0ZXJzIiwiVHJlZUhpZ2hsaWdodGVyIiwibWFya0NhY2hlIiwiYnVpbGREZWNvIiwiZGVjb3JhdGVkVG8iLCJzdHlsZUNoYW5nZSIsImRlY29yYXRlZFRvTWFwcGVkIiwidmlzaWJsZVJhbmdlcyIsImhpZ2giLCJ2IiwiZGVmYXVsdEhpZ2hsaWdodFN0eWxlIiwibWV0YSIsImxpbmsiLCJ0ZXh0RGVjb3JhdGlvbiIsImhlYWRpbmciLCJmb250V2VpZ2h0IiwiZW1waGFzaXMiLCJmb250U3R5bGUiLCJzdHJvbmciLCJzdHJpa2V0aHJvdWdoIiwia2V5d29yZCIsImF0b20iLCJib29sIiwidXJsIiwiY29udGVudFNlcGFyYXRvciIsImxhYmVsTmFtZSIsImxpdGVyYWwiLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJyZWdleHAiLCJlc2NhcGUiLCJzcGVjaWFsIiwiZGVmaW5pdGlvbiIsInZhcmlhYmxlTmFtZSIsImxvY2FsIiwidHlwZU5hbWUiLCJuYW1lc3BhY2UiLCJtYWNyb05hbWUiLCJwcm9wZXJ0eU5hbWUiLCJjb21tZW50IiwiaW52YWxpZCIsIkRlZmF1bHRTY2FuRGlzdCIsIkRlZmF1bHRCcmFja2V0cyIsImJyYWNrZXRNYXRjaGluZ0NvbmZpZyIsImNvbmZpZ3MiLCJhZnRlckN1cnNvciIsImJyYWNrZXRzIiwibWF4U2NhbkRpc3RhbmNlIiwicmVuZGVyTWF0Y2giLCJkZWZhdWx0UmVuZGVyTWF0Y2giLCJtYXRjaGluZ01hcmsiLCJub25tYXRjaGluZ01hcmsiLCJtYXRjaGVkIiwiYnJhY2tldE1hdGNoaW5nU3RhdGUiLCJkZWNvIiwibWF0Y2hCcmFja2V0cyIsImJyYWNrZXRNYXRjaGluZ1VuaXF1ZSIsImJyYWNrZXRNYXRjaGluZyIsImJyYWNrZXRNYXRjaGluZ0hhbmRsZSIsIm1hdGNoaW5nTm9kZXMiLCJkaXIiLCJieVByb3AiLCJvcGVuZWRCeSIsImluZGV4IiwiZmluZEhhbmRsZSIsImhhc0hhbmRsZSIsIm1hdGNoZXMiLCJoYW5kbGUiLCJtYXRjaE1hcmtlZEJyYWNrZXRzIiwibWF0Y2hQbGFpbkJyYWNrZXRzIiwiX3N0YXRlIiwiX3BvcyIsInRva2VuIiwibWF0Y2hpbmciLCJmaXJzdFRva2VuIiwiZGVwdGgiLCJjaGlsZEJlZm9yZSIsImVuZEhhbmRsZSIsInByZXZTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJ0b2tlblR5cGUiLCJzdGFydENoIiwic2xpY2VEb2MiLCJicmFja2V0Iiwic3RhcnRUb2tlbiIsIml0ZXJSYW5nZSIsImRpc3RhbmNlIiwiYmFzZVBvcyIsImNvdW50Q29sIiwic3RhcnRJbmRleCIsInN0YXJ0VmFsdWUiLCJuIiwiU3RyaW5nU3RyZWFtIiwib3ZlcnJpZGVJbmRlbnQiLCJsYXN0Q29sdW1uUG9zIiwibGFzdENvbHVtblZhbHVlIiwiZW9sIiwic29sIiwicGVlayIsImNoYXJBdCIsImVhdCIsIm9rIiwiUmVnRXhwIiwiZWF0V2hpbGUiLCJlYXRTcGFjZSIsInNraXBUb0VuZCIsInNraXBUbyIsImJhY2tVcCIsImluZGVudGF0aW9uIiwicGF0dGVybiIsImNvbnN1bWUiLCJjYXNlSW5zZW5zaXRpdmUiLCJjYXNlZCIsInN0ciIsInN1YnN0ciIsImN1cnJlbnQiLCJmdWxsUGFyc2VyIiwiYmxhbmtMaW5lIiwiY29weVN0YXRlIiwiZGVmYXVsdENvcHlTdGF0ZSIsInRva2VuVGFibGUiLCJub1Rva2VucyIsIm1lcmdlVG9rZW5zIiwidmFsIiwiSW5kZW50ZWRGcm9tIiwiV2Vha01hcCIsIlN0cmVhbUxhbmd1YWdlIiwicCIsInNlbGYiLCJpbXBsIiwiUGFyc2UiLCJkb2NJRCIsInN0cmVhbVBhcnNlciIsInN0YXRlQWZ0ZXIiLCJwZXJOb2RlIiwiVG9rZW5UYWJsZSIsImRlZmF1bHRUb2tlblRhYmxlIiwiZ2V0SW5kZW50IiwiZmluZFN0YXRlIiwic3RhdGVQb3MiLCJzdHJlYW0iLCJyZWFkVG9rZW4iLCJvZmYiLCJzdGFydFBvcyIsImJlZm9yZSIsImNoaWxkIiwiY3V0VHJlZSIsImluc2lkZSIsImZpbmRTdGFydEluRnJhZ21lbnRzIiwiZW5kUG9zIiwiZWRpdG9yU3RhdGUiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib2Zmc2V0IiwiY2h1bmtzIiwiY2h1bmtQb3MiLCJjaHVua1JldXNlZCIsInJhbmdlSW5kZXgiLCJjaHVua1N0YXJ0IiwibW92ZVJhbmdlSW5kZXgiLCJwYXJzZUVuZCIsInBhcnNlTGluZSIsImZpbmlzaENodW5rIiwibGluZUFmdGVyIiwibmV4dExpbmUiLCJyYW5nZUVuZCIsInJhbmdlU3RhcnQiLCJza2lwR2Fwc1RvIiwib2ZmUG9zIiwiZW1pdFRva2VuIiwiaWQiLCJsZW4wIiwiYnVpbGQiLCJidWZmZXIiLCJub2RlU2V0IiwidG9wSUQiLCJtYXhCdWZmZXJMZW5ndGgiLCJyZXVzZWQiLCJiYWxhbmNlIiwidHlwZUFycmF5Iiwid2FybmVkIiwiYnlUYWciLCJkZWZhdWx0VGFibGUiLCJsZWdhY3lOYW1lIiwiY3JlYXRlVG9rZW5UeXBlIiwiZXh0cmEiLCJ0YWJsZSIsIndhcm5Gb3JQYXJ0IiwicGFydCIsIm1zZyIsImNvbnNvbGUiLCJ3YXJuIiwidGFnU3RyIiwidGFncyQxIiwic3BsaXQiLCJ0Iiwia25vd24iLCJidWlsZEZvckxpbmUiLCJ0ZXh0SGFzUlRMIiwiY2hhbmdlQWRkc1JUTCIsImNoYW5nZSIsImFkZGVkIiwiaXRlckNoYW5nZXMiLCJmQSIsInRBIiwiZkIiLCJ0QiIsImlucyIsImFsd2F5c0lzb2xhdGUiLCJ4IiwiYmlkaUlzb2xhdGVzIiwiaXNvbGF0ZU1hcmtzIiwiYWx3YXlzIiwidGV4dERpcmVjdGlvbiIsIkxUUiIsInBlckxpbmVUZXh0RGlyZWN0aW9uIiwiaGFzUlRMIiwiYWNjZXNzIiwiX2IiLCJvdXRlckRlY29yYXRpb25zIiwibG93ZXN0IiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiY2xpcFJUTExpbmVzIiwiaXRlcmF0ZSIsImlzbyIsImlzb2xhdGUiLCJtYXJrcyIsImxpbmVCcmVhayIsInJ0bCIsImluY2x1c2l2ZSIsImF0dHJpYnV0ZXMiLCJiaWRpSXNvbGF0ZSIsIlJUTCIsImx0ciIsImF1dG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@codemirror+language@6.12.1/node_modules/@codemirror/language/dist/index.js\n");

/***/ })

};
;