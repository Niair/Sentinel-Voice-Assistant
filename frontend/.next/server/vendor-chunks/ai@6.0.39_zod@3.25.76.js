"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai@6.0.39_zod@3.25.76";
exports.ids = ["vendor-chunks/ai@6.0.39_zod@3.25.76"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ai@6.0.39_zod@3.25.76/node_modules/ai/dist/index.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@6.0.39_zod@3.25.76/node_modules/ai/dist/index.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AbstractChat: () => (/* binding */ AbstractChat),\n/* harmony export */   DefaultChatTransport: () => (/* binding */ DefaultChatTransport),\n/* harmony export */   DirectChatTransport: () => (/* binding */ DirectChatTransport),\n/* harmony export */   DownloadError: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   Experimental_Agent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   HttpChatTransport: () => (/* binding */ HttpChatTransport),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolApprovalError: () => (/* binding */ InvalidToolApprovalError),\n/* harmony export */   InvalidToolInputError: () => (/* binding */ InvalidToolInputError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   JsonToSseTransformStream: () => (/* binding */ JsonToSseTransformStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputGeneratedError: () => (/* binding */ NoOutputGeneratedError),\n/* harmony export */   NoSpeechGeneratedError: () => (/* binding */ NoSpeechGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   SerialJobExecutor: () => (/* binding */ SerialJobExecutor),\n/* harmony export */   TextStreamChatTransport: () => (/* binding */ TextStreamChatTransport),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TooManyEmbeddingValuesForCallError),\n/* harmony export */   ToolCallNotFoundForApprovalError: () => (/* binding */ ToolCallNotFoundForApprovalError),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolLoopAgent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UIMessageStreamError: () => (/* binding */ UIMessageStreamError),\n/* harmony export */   UI_MESSAGE_STREAM_HEADERS: () => (/* binding */ UI_MESSAGE_STREAM_HEADERS),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedModelVersionError: () => (/* binding */ UnsupportedModelVersionError),\n/* harmony export */   addToolInputExamplesMiddleware: () => (/* binding */ addToolInputExamplesMiddleware),\n/* harmony export */   asSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema),\n/* harmony export */   assistantModelMessageSchema: () => (/* binding */ assistantModelMessageSchema),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   consumeStream: () => (/* binding */ consumeStream),\n/* harmony export */   convertFileListToFileUIParts: () => (/* binding */ convertFileListToFileUIParts),\n/* harmony export */   convertToModelMessages: () => (/* binding */ convertToModelMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createAgentUIStream: () => (/* binding */ createAgentUIStream),\n/* harmony export */   createAgentUIStreamResponse: () => (/* binding */ createAgentUIStreamResponse),\n/* harmony export */   createGateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.createGateway),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   createTextStreamResponse: () => (/* binding */ createTextStreamResponse),\n/* harmony export */   createUIMessageStream: () => (/* binding */ createUIMessageStream),\n/* harmony export */   createUIMessageStreamResponse: () => (/* binding */ createUIMessageStreamResponse),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultEmbeddingSettingsMiddleware: () => (/* binding */ defaultEmbeddingSettingsMiddleware),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   dynamicTool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ experimental_generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   extractJsonMiddleware: () => (/* binding */ extractJsonMiddleware),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   gateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateImage: () => (/* binding */ generateImage),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getStaticToolName: () => (/* binding */ getStaticToolName),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   getToolName: () => (/* binding */ getToolName),\n/* harmony export */   getToolOrDynamicToolName: () => (/* binding */ getToolOrDynamicToolName),\n/* harmony export */   hasToolCall: () => (/* binding */ hasToolCall),\n/* harmony export */   isDataUIPart: () => (/* binding */ isDataUIPart),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   isFileUIPart: () => (/* binding */ isFileUIPart),\n/* harmony export */   isReasoningUIPart: () => (/* binding */ isReasoningUIPart),\n/* harmony export */   isStaticToolUIPart: () => (/* binding */ isStaticToolUIPart),\n/* harmony export */   isTextUIPart: () => (/* binding */ isTextUIPart),\n/* harmony export */   isToolOrDynamicToolUIPart: () => (/* binding */ isToolOrDynamicToolUIPart),\n/* harmony export */   isToolUIPart: () => (/* binding */ isToolUIPart),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema),\n/* harmony export */   lastAssistantMessageIsCompleteWithApprovalResponses: () => (/* binding */ lastAssistantMessageIsCompleteWithApprovalResponses),\n/* harmony export */   lastAssistantMessageIsCompleteWithToolCalls: () => (/* binding */ lastAssistantMessageIsCompleteWithToolCalls),\n/* harmony export */   modelMessageSchema: () => (/* binding */ modelMessageSchema),\n/* harmony export */   parseJsonEventStream: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   pipeAgentUIStreamToResponse: () => (/* binding */ pipeAgentUIStreamToResponse),\n/* harmony export */   pipeTextStreamToResponse: () => (/* binding */ pipeTextStreamToResponse),\n/* harmony export */   pipeUIMessageStreamToResponse: () => (/* binding */ pipeUIMessageStreamToResponse),\n/* harmony export */   pruneMessages: () => (/* binding */ pruneMessages),\n/* harmony export */   readUIMessageStream: () => (/* binding */ readUIMessageStream),\n/* harmony export */   rerank: () => (/* binding */ rerank),\n/* harmony export */   safeValidateUIMessages: () => (/* binding */ safeValidateUIMessages),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   stepCountIs: () => (/* binding */ stepCountIs),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   systemModelMessageSchema: () => (/* binding */ systemModelMessageSchema),\n/* harmony export */   tool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool),\n/* harmony export */   toolModelMessageSchema: () => (/* binding */ toolModelMessageSchema),\n/* harmony export */   uiMessageChunkSchema: () => (/* binding */ uiMessageChunkSchema),\n/* harmony export */   userModelMessageSchema: () => (/* binding */ userModelMessageSchema),\n/* harmony export */   validateUIMessages: () => (/* binding */ validateUIMessages),\n/* harmony export */   wrapEmbeddingModel: () => (/* binding */ wrapEmbeddingModel),\n/* harmony export */   wrapImageModel: () => (/* binding */ wrapImageModel),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   wrapProvider: () => (/* binding */ wrapProvider),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/gateway */ \"(ssr)/./node_modules/.pnpm/@ai-sdk+gateway@3.0.16_zod@3.25.76/node_modules/@ai-sdk/gateway/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/.pnpm/@ai-sdk+provider-utils@4.0.8_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/.pnpm/@ai-sdk+provider@3.0.4/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/schemas.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_@opentelemetry+_95d5a05ac7ec0d735f17a907e734f3d8/node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name17 in all)__defProp(target, name17, {\n        get: all[name17],\n        enumerable: true\n    });\n};\n// src/index.ts\n\n\n// src/generate-text/generate-text.ts\n\n// src/error/index.ts\n\n// src/error/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n    }\n};\n_a = symbol;\n// src/error/invalid-stream-part-error.ts\n\nvar name2 = \"AI_InvalidStreamPartError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ chunk, message }){\n        super({\n            name: name2,\n            message\n        });\n        this[_a2] = true;\n        this.chunk = chunk;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n    }\n};\n_a2 = symbol2;\n// src/error/invalid-tool-approval-error.ts\n\nvar name3 = \"AI_InvalidToolApprovalError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidToolApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ approvalId }){\n        super({\n            name: name3,\n            message: `Tool approval response references unknown approvalId: \"${approvalId}\". No matching tool-approval-request found in message history.`\n        });\n        this[_a3] = true;\n        this.approvalId = approvalId;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n    }\n};\n_a3 = symbol3;\n// src/error/invalid-tool-input-error.ts\n\nvar name4 = \"AI_InvalidToolInputError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidToolInputError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolInput, toolName, cause, message = `Invalid input for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}` }){\n        super({\n            name: name4,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.toolInput = toolInput;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// src/error/tool-call-not-found-for-approval-error.ts\n\nvar name5 = \"AI_ToolCallNotFoundForApprovalError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar ToolCallNotFoundForApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolCallId, approvalId }){\n        super({\n            name: name5,\n            message: `Tool call \"${toolCallId}\" not found for approval request \"${approvalId}\".`\n        });\n        this[_a5] = true;\n        this.toolCallId = toolCallId;\n        this.approvalId = approvalId;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n    }\n};\n_a5 = symbol5;\n// src/error/no-image-generated-error.ts\n\nvar name6 = \"AI_NoImageGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message = \"No image generated.\", cause, responses }){\n        super({\n            name: name6,\n            message,\n            cause\n        });\n        this[_a6] = true;\n        this.responses = responses;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// src/error/no-object-generated-error.ts\n\nvar name7 = \"AI_NoObjectGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message = \"No object generated.\", cause, text: text2, response, usage, finishReason }){\n        super({\n            name: name7,\n            message,\n            cause\n        });\n        this[_a7] = true;\n        this.text = text2;\n        this.response = response;\n        this.usage = usage;\n        this.finishReason = finishReason;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n    }\n};\n_a7 = symbol7;\n// src/error/no-output-generated-error.ts\n\nvar name8 = \"AI_NoOutputGeneratedError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoOutputGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    // used in isInstance\n    constructor({ message = \"No output generated.\", cause } = {}){\n        super({\n            name: name8,\n            message,\n            cause\n        });\n        this[_a8] = true;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n    }\n};\n_a8 = symbol8;\n// src/error/no-speech-generated-error.ts\n\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_NoSpeechGeneratedError\",\n            message: \"No speech audio generated.\"\n        });\n        this.responses = options.responses;\n    }\n};\n// src/error/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name9,\n            message\n        });\n        this[_a9] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n    }\n};\n_a9 = symbol9;\n// src/error/tool-call-repair-error.ts\n\nvar name10 = \"AI_ToolCallRepairError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ cause, originalError, message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}` }){\n        super({\n            name: name10,\n            message,\n            cause\n        });\n        this[_a10] = true;\n        this.originalError = originalError;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n    }\n};\n_a10 = symbol10;\n// src/error/unsupported-model-version-error.ts\n\nvar UnsupportedModelVersionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_UnsupportedModelVersionError\",\n            message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n        });\n        this.version = options.version;\n        this.provider = options.provider;\n        this.modelId = options.modelId;\n    }\n};\n// src/error/ui-message-stream-error.ts\n\nvar name11 = \"AI_UIMessageStreamError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar UIMessageStreamError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ chunkType, chunkId, message }){\n        super({\n            name: name11,\n            message\n        });\n        this[_a11] = true;\n        this.chunkType = chunkType;\n        this.chunkId = chunkId;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n    }\n};\n_a11 = symbol11;\n// src/prompt/invalid-data-content-error.ts\n\nvar name12 = \"AI_InvalidDataContentError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name12,\n            message,\n            cause\n        });\n        this[_a12] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker12);\n    }\n};\n_a12 = symbol12;\n// src/prompt/invalid-message-role-error.ts\n\nvar name13 = \"AI_InvalidMessageRoleError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name13,\n            message\n        });\n        this[_a13] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker13);\n    }\n};\n_a13 = symbol13;\n// src/prompt/message-conversion-error.ts\n\nvar name14 = \"AI_MessageConversionError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name14,\n            message\n        });\n        this[_a14] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker14);\n    }\n};\n_a14 = symbol14;\n// src/error/index.ts\n\n// src/util/retry-error.ts\n\nvar name15 = \"AI_RetryError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name: name15,\n            message\n        });\n        this[_a15] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker15);\n    }\n};\n_a15 = symbol15;\n// src/logger/log-warnings.ts\nfunction formatWarning({ warning, provider, model }) {\n    const prefix = `AI SDK Warning (${provider} / ${model}):`;\n    switch(warning.type){\n        case \"unsupported\":\n            {\n                let message = `${prefix} The feature \"${warning.feature}\" is not supported.`;\n                if (warning.details) {\n                    message += ` ${warning.details}`;\n                }\n                return message;\n            }\n        case \"compatibility\":\n            {\n                let message = `${prefix} The feature \"${warning.feature}\" is used in a compatibility mode.`;\n                if (warning.details) {\n                    message += ` ${warning.details}`;\n                }\n                return message;\n            }\n        case \"other\":\n            {\n                return `${prefix} ${warning.message}`;\n            }\n        default:\n            {\n                return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n            }\n    }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = (options)=>{\n    if (options.warnings.length === 0) {\n        return;\n    }\n    const logger = globalThis.AI_SDK_LOG_WARNINGS;\n    if (logger === false) {\n        return;\n    }\n    if (typeof logger === \"function\") {\n        logger(options);\n        return;\n    }\n    if (!hasLoggedBefore) {\n        hasLoggedBefore = true;\n        console.info(FIRST_WARNING_INFO_MESSAGE);\n    }\n    for (const warning of options.warnings){\n        console.warn(formatWarning({\n            warning,\n            provider: options.provider,\n            model: options.model\n        }));\n    }\n};\n// src/model/resolve-model.ts\n\n// src/util/log-v2-compatibility-warning.ts\nfunction logV2CompatibilityWarning({ provider, modelId }) {\n    logWarnings({\n        warnings: [\n            {\n                type: \"compatibility\",\n                feature: \"specificationVersion\",\n                details: `Using v2 specification compatibility mode. Some features may not be available.`\n            }\n        ],\n        provider,\n        model: modelId\n    });\n}\n// src/model/as-embedding-model-v3.ts\nfunction asEmbeddingModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/as-image-model-v3.ts\nfunction asImageModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/as-language-model-v3.ts\nfunction asLanguageModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            switch(prop){\n                case \"specificationVersion\":\n                    return \"v3\";\n                case \"doGenerate\":\n                    return async (...args)=>{\n                        const result = await target.doGenerate(...args);\n                        return {\n                            ...result,\n                            finishReason: convertV2FinishReasonToV3(result.finishReason),\n                            usage: convertV2UsageToV3(result.usage)\n                        };\n                    };\n                case \"doStream\":\n                    return async (...args)=>{\n                        const result = await target.doStream(...args);\n                        return {\n                            ...result,\n                            stream: convertV2StreamToV3(result.stream)\n                        };\n                    };\n                default:\n                    return target[prop];\n            }\n        }\n    });\n}\nfunction convertV2StreamToV3(stream) {\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            switch(chunk.type){\n                case \"finish\":\n                    controller.enqueue({\n                        ...chunk,\n                        finishReason: convertV2FinishReasonToV3(chunk.finishReason),\n                        usage: convertV2UsageToV3(chunk.usage)\n                    });\n                    break;\n                default:\n                    controller.enqueue(chunk);\n                    break;\n            }\n        }\n    }));\n}\nfunction convertV2FinishReasonToV3(finishReason) {\n    return {\n        unified: finishReason === \"unknown\" ? \"other\" : finishReason,\n        raw: void 0\n    };\n}\nfunction convertV2UsageToV3(usage) {\n    return {\n        inputTokens: {\n            total: usage.inputTokens,\n            noCache: void 0,\n            cacheRead: usage.cachedInputTokens,\n            cacheWrite: void 0\n        },\n        outputTokens: {\n            total: usage.outputTokens,\n            text: void 0,\n            reasoning: usage.reasoningTokens\n        }\n    };\n}\n// src/model/as-speech-model-v3.ts\nfunction asSpeechModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/as-transcription-model-v3.ts\nfunction asTranscriptionModelV3(model) {\n    if (model.specificationVersion === \"v3\") {\n        return model;\n    }\n    logV2CompatibilityWarning({\n        provider: model.provider,\n        modelId: model.modelId\n    });\n    return new Proxy(model, {\n        get (target, prop) {\n            if (prop === \"specificationVersion\") return \"v3\";\n            return target[prop];\n        }\n    });\n}\n// src/model/resolve-model.ts\nfunction resolveLanguageModel(model) {\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asLanguageModelV3(model);\n    }\n    return getGlobalProvider().languageModel(model);\n}\nfunction resolveEmbeddingModel(model) {\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asEmbeddingModelV3(model);\n    }\n    return getGlobalProvider().embeddingModel(model);\n}\nfunction resolveTranscriptionModel(model) {\n    var _a17, _b;\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asTranscriptionModelV3(model);\n    }\n    return (_b = (_a17 = getGlobalProvider()).transcriptionModel) == null ? void 0 : _b.call(_a17, model);\n}\nfunction resolveSpeechModel(model) {\n    var _a17, _b;\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asSpeechModelV3(model);\n    }\n    return (_b = (_a17 = getGlobalProvider()).speechModel) == null ? void 0 : _b.call(_a17, model);\n}\nfunction resolveImageModel(model) {\n    if (typeof model !== \"string\") {\n        if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n            const unsupportedModel = model;\n            throw new UnsupportedModelVersionError({\n                version: unsupportedModel.specificationVersion,\n                provider: unsupportedModel.provider,\n                modelId: unsupportedModel.modelId\n            });\n        }\n        return asImageModelV3(model);\n    }\n    return getGlobalProvider().imageModel(model);\n}\nfunction getGlobalProvider() {\n    var _a17;\n    return (_a17 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a17 : _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway;\n}\n// src/prompt/call-settings.ts\nfunction getTotalTimeoutMs(timeout) {\n    if (timeout == null) {\n        return void 0;\n    }\n    if (typeof timeout === \"number\") {\n        return timeout;\n    }\n    return timeout.totalMs;\n}\nfunction getStepTimeoutMs(timeout) {\n    if (timeout == null || typeof timeout === \"number\") {\n        return void 0;\n    }\n    return timeout.stepMs;\n}\nfunction getChunkTimeoutMs(timeout) {\n    if (timeout == null || typeof timeout === \"number\") {\n        return void 0;\n    }\n    return timeout.chunkMs;\n}\n// src/prompt/convert-to-language-model-prompt.ts\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n    {\n        mediaType: \"image/gif\",\n        bytesPrefix: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mediaType: \"image/png\",\n        bytesPrefix: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mediaType: \"image/jpeg\",\n        bytesPrefix: [\n            255,\n            216\n        ]\n    },\n    {\n        mediaType: \"image/webp\",\n        bytesPrefix: [\n            82,\n            73,\n            70,\n            70,\n            // \"RIFF\"\n            null,\n            null,\n            null,\n            null,\n            // file size (variable)\n            87,\n            69,\n            66,\n            80\n        ]\n    },\n    {\n        mediaType: \"image/bmp\",\n        bytesPrefix: [\n            66,\n            77\n        ]\n    },\n    {\n        mediaType: \"image/tiff\",\n        bytesPrefix: [\n            73,\n            73,\n            42,\n            0\n        ]\n    },\n    {\n        mediaType: \"image/tiff\",\n        bytesPrefix: [\n            77,\n            77,\n            0,\n            42\n        ]\n    },\n    {\n        mediaType: \"image/avif\",\n        bytesPrefix: [\n            0,\n            0,\n            0,\n            32,\n            102,\n            116,\n            121,\n            112,\n            97,\n            118,\n            105,\n            102\n        ]\n    },\n    {\n        mediaType: \"image/heic\",\n        bytesPrefix: [\n            0,\n            0,\n            0,\n            32,\n            102,\n            116,\n            121,\n            112,\n            104,\n            101,\n            105,\n            99\n        ]\n    }\n];\nvar audioMediaTypeSignatures = [\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            251\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            250\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            243\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            242\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            227\n        ]\n    },\n    {\n        mediaType: \"audio/mpeg\",\n        bytesPrefix: [\n            255,\n            226\n        ]\n    },\n    {\n        mediaType: \"audio/wav\",\n        bytesPrefix: [\n            82,\n            // R\n            73,\n            // I\n            70,\n            // F\n            70,\n            // F\n            null,\n            null,\n            null,\n            null,\n            87,\n            // W\n            65,\n            // A\n            86,\n            // V\n            69\n        ]\n    },\n    {\n        mediaType: \"audio/ogg\",\n        bytesPrefix: [\n            79,\n            103,\n            103,\n            83\n        ]\n    },\n    {\n        mediaType: \"audio/flac\",\n        bytesPrefix: [\n            102,\n            76,\n            97,\n            67\n        ]\n    },\n    {\n        mediaType: \"audio/aac\",\n        bytesPrefix: [\n            64,\n            21,\n            0,\n            0\n        ]\n    },\n    {\n        mediaType: \"audio/mp4\",\n        bytesPrefix: [\n            102,\n            116,\n            121,\n            112\n        ]\n    },\n    {\n        mediaType: \"audio/webm\",\n        bytesPrefix: [\n            26,\n            69,\n            223,\n            163\n        ]\n    }\n];\nvar stripID3 = (data)=>{\n    const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n    const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n    return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n    const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n    data[1] === 68 && // 'D'\n    data[2] === 51;\n    return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({ data, signatures }) {\n    const processedData = stripID3TagsIfPresent(data);\n    const bytes = typeof processedData === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(processedData.substring(0, Math.min(processedData.length, 24))) : processedData;\n    for (const signature of signatures){\n        if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index)=>byte === null || bytes[index] === byte)) {\n            return signature.mediaType;\n        }\n    }\n    return void 0;\n}\n// src/util/download/download.ts\n\n\n// src/version.ts\nvar VERSION =  true ? \"6.0.39\" : 0;\n// src/util/download/download.ts\nvar download = async ({ url })=>{\n    var _a17;\n    const urlText = url.toString();\n    try {\n        const response = await fetch(urlText, {\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)({}, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)())\n        });\n        if (!response.ok) {\n            throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mediaType: (_a17 = response.headers.get(\"content-type\")) != null ? _a17 : void 0\n        };\n    } catch (error) {\n        if (_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n};\n// src/util/download/download-function.ts\nvar createDefaultDownloadFunction = (download2 = download)=>(requestedDownloads)=>Promise.all(requestedDownloads.map(async (requestedDownload)=>requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)));\n// src/prompt/data-content.ts\n\n\n\n// src/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mediaType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mediaType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// src/prompt/data-content.ts\nvar dataContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](Uint8Array),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](ArrayBuffer),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a17, _b;\n        return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertToLanguageModelV3DataContent(content) {\n    if (content instanceof Uint8Array) {\n        return {\n            data: content,\n            mediaType: void 0\n        };\n    }\n    if (content instanceof ArrayBuffer) {\n        return {\n            data: new Uint8Array(content),\n            mediaType: void 0\n        };\n    }\n    if (typeof content === \"string\") {\n        try {\n            content = new URL(content);\n        } catch (error) {}\n    }\n    if (content instanceof URL && content.protocol === \"data:\") {\n        const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());\n        if (dataUrlMediaType == null || base64Content == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n                name: \"InvalidDataContentError\",\n                message: `Invalid data URL format in content ${content.toString()}`\n            });\n        }\n        return {\n            data: base64Content,\n            mediaType: dataUrlMediaType\n        };\n    }\n    return {\n        data: content,\n        mediaType: void 0\n    };\n}\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\n// src/util/as-array.ts\nfunction asArray(value) {\n    return value === void 0 ? [] : Array.isArray(value) ? value : [\n        value\n    ];\n}\n// src/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, supportedUrls, download: download2 = createDefaultDownloadFunction() }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, download2, supportedUrls);\n    const messages = [\n        ...prompt.system != null ? typeof prompt.system === \"string\" ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : asArray(prompt.system).map((message)=>({\n                role: \"system\",\n                content: message.content,\n                providerOptions: message.providerOptions\n            })) : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage({\n                message,\n                downloadedAssets\n            }))\n    ];\n    const combinedMessages = [];\n    for (const message of messages){\n        if (message.role !== \"tool\") {\n            combinedMessages.push(message);\n            continue;\n        }\n        const lastCombinedMessage = combinedMessages.at(-1);\n        if ((lastCombinedMessage == null ? void 0 : lastCombinedMessage.role) === \"tool\") {\n            lastCombinedMessage.content.push(...message.content);\n        } else {\n            combinedMessages.push(message);\n        }\n    }\n    return combinedMessages;\n}\nfunction convertToLanguageModelMessage({ message, downloadedAssets }) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerOptions: message.providerOptions\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerOptions: message.providerOptions\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerOptions: message.providerOptions\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerOptions: message.providerOptions\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts (no text, and no provider options):\n                    (part)=>part.type !== \"text\" || part.text !== \"\" || part.providerOptions != null).filter((part)=>part.type !== \"tool-approval-request\").map((part)=>{\n                        const providerOptions = part.providerOptions;\n                        switch(part.type){\n                            case \"file\":\n                                {\n                                    const { data, mediaType } = convertToLanguageModelV3DataContent(part.data);\n                                    return {\n                                        type: \"file\",\n                                        data,\n                                        filename: part.filename,\n                                        mediaType: mediaType != null ? mediaType : part.mediaType,\n                                        providerOptions\n                                    };\n                                }\n                            case \"reasoning\":\n                                {\n                                    return {\n                                        type: \"reasoning\",\n                                        text: part.text,\n                                        providerOptions\n                                    };\n                                }\n                            case \"text\":\n                                {\n                                    return {\n                                        type: \"text\",\n                                        text: part.text,\n                                        providerOptions\n                                    };\n                                }\n                            case \"tool-call\":\n                                {\n                                    return {\n                                        type: \"tool-call\",\n                                        toolCallId: part.toolCallId,\n                                        toolName: part.toolName,\n                                        input: part.input,\n                                        providerExecuted: part.providerExecuted,\n                                        providerOptions\n                                    };\n                                }\n                            case \"tool-result\":\n                                {\n                                    return {\n                                        type: \"tool-result\",\n                                        toolCallId: part.toolCallId,\n                                        toolName: part.toolName,\n                                        output: mapToolResultOutput(part.output),\n                                        providerOptions\n                                    };\n                                }\n                        }\n                    }),\n                    providerOptions: message.providerOptions\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.filter(// Only include tool-approval-response for provider-executed tools\n                    (part)=>part.type !== \"tool-approval-response\" || part.providerExecuted).map((part)=>{\n                        switch(part.type){\n                            case \"tool-result\":\n                                {\n                                    return {\n                                        type: \"tool-result\",\n                                        toolCallId: part.toolCallId,\n                                        toolName: part.toolName,\n                                        output: mapToolResultOutput(part.output),\n                                        providerOptions: part.providerOptions\n                                    };\n                                }\n                            case \"tool-approval-response\":\n                                {\n                                    return {\n                                        type: \"tool-approval-response\",\n                                        approvalId: part.approvalId,\n                                        approved: part.approved,\n                                        reason: part.reason\n                                    };\n                                }\n                        }\n                    }),\n                    providerOptions: message.providerOptions\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n    const plannedDownloads = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").map((part)=>{\n        var _a17;\n        const mediaType = (_a17 = part.mediaType) != null ? _a17 : part.type === \"image\" ? \"image/*\" : void 0;\n        let data = part.type === \"image\" ? part.image : part.data;\n        if (typeof data === \"string\") {\n            try {\n                data = new URL(data);\n            } catch (ignored) {}\n        }\n        return {\n            mediaType,\n            data\n        };\n    }).filter((part)=>part.data instanceof URL).map((part)=>({\n            url: part.data,\n            isUrlSupportedByModel: part.mediaType != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isUrlSupported)({\n                url: part.data.toString(),\n                mediaType: part.mediaType,\n                supportedUrls\n            })\n        }));\n    const downloadedFiles = await download2(plannedDownloads);\n    return Object.fromEntries(downloadedFiles.map((file, index)=>file == null ? null : [\n            plannedDownloads[index].url.toString(),\n            {\n                data: file.data,\n                mediaType: file.mediaType\n            }\n        ]).filter((file)=>file != null));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    var _a17;\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerOptions: part.providerOptions\n        };\n    }\n    let originalData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            originalData = part.image;\n            break;\n        case \"file\":\n            originalData = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV3DataContent(originalData);\n    let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n    let data = convertedData;\n    if (data instanceof URL) {\n        const downloadedFile = downloadedAssets[data.toString()];\n        if (downloadedFile) {\n            data = downloadedFile.data;\n            mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n        }\n    }\n    switch(type){\n        case \"image\":\n            {\n                if (data instanceof Uint8Array || typeof data === \"string\") {\n                    mediaType = (_a17 = detectMediaType({\n                        data,\n                        signatures: imageMediaTypeSignatures\n                    })) != null ? _a17 : mediaType;\n                }\n                return {\n                    type: \"file\",\n                    mediaType: mediaType != null ? mediaType : \"image/*\",\n                    // any image\n                    filename: void 0,\n                    data,\n                    providerOptions: part.providerOptions\n                };\n            }\n        case \"file\":\n            {\n                if (mediaType == null) {\n                    throw new Error(`Media type is missing for file part`);\n                }\n                return {\n                    type: \"file\",\n                    mediaType,\n                    filename: part.filename,\n                    data,\n                    providerOptions: part.providerOptions\n                };\n            }\n    }\n}\nfunction mapToolResultOutput(output) {\n    if (output.type !== \"content\") {\n        return output;\n    }\n    return {\n        type: \"content\",\n        value: output.value.map((item)=>{\n            if (item.type !== \"media\") {\n                return item;\n            }\n            if (item.mediaType.startsWith(\"image/\")) {\n                return {\n                    type: \"image-data\",\n                    data: item.data,\n                    mediaType: item.mediaType\n                };\n            }\n            return {\n                type: \"file-data\",\n                data: item.data,\n                mediaType: item.mediaType\n            };\n        })\n    };\n}\n// src/prompt/create-tool-model-output.ts\n\nasync function createToolModelOutput({ toolCallId, input, output, tool: tool2, errorMode }) {\n    if (errorMode === \"text\") {\n        return {\n            type: \"error-text\",\n            value: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(output)\n        };\n    } else if (errorMode === \"json\") {\n        return {\n            type: \"error-json\",\n            value: toJSONValue(output)\n        };\n    }\n    if (tool2 == null ? void 0 : tool2.toModelOutput) {\n        return await tool2.toModelOutput({\n            toolCallId,\n            input,\n            output\n        });\n    }\n    return typeof output === \"string\" ? {\n        type: \"text\",\n        value: output\n    } : {\n        type: \"json\",\n        value: toJSONValue(output)\n    };\n}\nfunction toJSONValue(value) {\n    return value === void 0 ? null : value;\n}\n// src/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxOutputTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, seed, stopSequences }) {\n    if (maxOutputTokens != null) {\n        if (!Number.isInteger(maxOutputTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxOutputTokens\",\n                value: maxOutputTokens,\n                message: \"maxOutputTokens must be an integer\"\n            });\n        }\n        if (maxOutputTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxOutputTokens\",\n                value: maxOutputTokens,\n                message: \"maxOutputTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    return {\n        maxOutputTokens,\n        temperature,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences,\n        seed\n    };\n}\n// src/prompt/prepare-tools-and-tool-choice.ts\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n    return object2 != null && Object.keys(object2).length > 0;\n}\n// src/prompt/prepare-tools-and-tool-choice.ts\nasync function prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name17])=>activeTools.includes(name17)) : Object.entries(tools);\n    const languageModelTools = [];\n    for (const [name17, tool2] of filteredTools){\n        const toolType = tool2.type;\n        switch(toolType){\n            case void 0:\n            case \"dynamic\":\n            case \"function\":\n                languageModelTools.push({\n                    type: \"function\",\n                    name: name17,\n                    description: tool2.description,\n                    inputSchema: await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema).jsonSchema,\n                    ...tool2.inputExamples != null ? {\n                        inputExamples: tool2.inputExamples\n                    } : {},\n                    providerOptions: tool2.providerOptions,\n                    ...tool2.strict != null ? {\n                        strict: tool2.strict\n                    } : {}\n                });\n                break;\n            case \"provider\":\n                languageModelTools.push({\n                    type: \"provider\",\n                    name: name17,\n                    id: tool2.id,\n                    args: tool2.args\n                });\n                break;\n            default:\n                {\n                    const exhaustiveCheck = toolType;\n                    throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                }\n        }\n    }\n    return {\n        tools: languageModelTools,\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// src/prompt/standardize-prompt.ts\n\n\n\n// src/prompt/message.ts\n\n// src/types/provider-metadata.ts\n\n// src/types/json-value.ts\n\nvar jsonValueSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.lazy(()=>zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"null\"](),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.number(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema.optional()),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(jsonValueSchema)\n    ]));\n// src/types/provider-metadata.ts\nvar providerMetadataSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema.optional()));\n// src/prompt/content-part.ts\n\nvar textPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n    text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n    image: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        dataContentSchema,\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)\n    ]),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n    data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        dataContentSchema,\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)\n    ]),\n    filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n    text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-call\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    providerOptions: providerMetadataSchema.optional(),\n    providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n});\nvar outputSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.discriminatedUnion(\"type\", [\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n        value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"json\"),\n        value: jsonValueSchema,\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"execution-denied\"),\n        reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-text\"),\n        value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error-json\"),\n        value: jsonValueSchema,\n        providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"content\"),\n        value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n                text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"media\"),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file-data\"),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file-url\"),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file-id\"),\n                fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n                ]),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image-data\"),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image-url\"),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"image-file-id\"),\n                fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    zod_v4__WEBPACK_IMPORTED_MODULE_3__.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.string())\n                ]),\n                providerOptions: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"custom\"),\n                providerOptions: providerMetadataSchema.optional()\n            })\n        ]))\n    })\n]);\nvar toolResultPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-result\"),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    output: outputSchema,\n    providerOptions: providerMetadataSchema.optional()\n});\nvar toolApprovalRequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-approval-request\"),\n    approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n});\nvar toolApprovalResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-approval-response\"),\n    approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n});\n// src/prompt/message.ts\nvar systemModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"system\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar userModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"user\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"assistant\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n            textPartSchema,\n            filePartSchema,\n            reasoningPartSchema,\n            toolCallPartSchema,\n            toolResultPartSchema,\n            toolApprovalRequestSchema\n        ]))\n    ]),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        toolResultPartSchema,\n        toolApprovalResponseSchema\n    ])),\n    providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n    systemModelMessageSchema,\n    userModelMessageSchema,\n    assistantModelMessageSchema,\n    toolModelMessageSchema\n]);\n// src/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\" && !asArray(prompt.system).every((message)=>typeof message === \"object\" && message !== null && \"role\" in message && message.role === \"system\")) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string, SystemModelMessage, or array of SystemModelMessage\"\n        });\n    }\n    let messages;\n    if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n        messages = [\n            {\n                role: \"user\",\n                content: prompt.prompt\n            }\n        ];\n    } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n        messages = prompt.prompt;\n    } else if (prompt.messages != null) {\n        messages = prompt.messages;\n    } else {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (messages.length === 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"messages must not be empty\"\n        });\n    }\n    const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: messages,\n        schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(modelMessageSchema)\n    });\n    if (!validationResult.success) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"The messages do not match the ModelMessage[] schema.\",\n            cause: validationResult.error\n        });\n    }\n    return {\n        messages,\n        system: prompt.system\n    };\n}\n// src/prompt/wrap-gateway-error.ts\n\n\nfunction wrapGatewayError(error) {\n    if (!_ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayAuthenticationError.isInstance(error)) return error;\n    const isProductionEnv = (process == null ? void 0 : \"development\") === \"production\";\n    const moreInfoURL = \"https://ai-sdk.dev/unauthenticated-ai-gateway\";\n    if (isProductionEnv) {\n        return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n            name: \"GatewayError\",\n            message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`\n        });\n    }\n    return Object.assign(new Error(`\\x1B[1m\\x1B[31mUnauthenticated request to AI Gateway.\\x1B[0m\n\nTo authenticate, set the \\x1B[33mAI_GATEWAY_API_KEY\\x1B[0m environment variable with your API key.\n\nAlternatively, you can use a provider module instead of the AI Gateway.\n\nLearn more: \\x1B[34m${moreInfoURL}\\x1B[0m\n\n`), {\n        name: \"GatewayAuthenticationError\"\n    });\n}\n// src/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({ operationId, telemetry }) {\n    return {\n        // standardized operation and resource name:\n        \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n        \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n        // detailed, AI SDK specific data:\n        \"ai.operationId\": operationId,\n        \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n    };\n}\n// src/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {\n    var _a17;\n    return {\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // settings:\n        ...Object.entries(settings).reduce((attributes, [key, value])=>{\n            if (key === \"timeout\") {\n                const totalTimeoutMs = getTotalTimeoutMs(value);\n                if (totalTimeoutMs != null) {\n                    attributes[`ai.settings.${key}`] = totalTimeoutMs;\n                }\n            } else {\n                attributes[`ai.settings.${key}`] = value;\n            }\n            return attributes;\n        }, {}),\n        // add metadata as attributes:\n        ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce((attributes, [key, value])=>{\n            attributes[`ai.telemetry.metadata.${key}`] = value;\n            return attributes;\n        }, {}),\n        // request headers\n        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{\n            if (value !== void 0) {\n                attributes[`ai.request.headers.${key}`] = value;\n            }\n            return attributes;\n        }, {})\n    };\n}\n// src/telemetry/get-tracer.ts\n\n// src/telemetry/noop-tracer.ts\nvar noopTracer = {\n    startSpan () {\n        return noopSpan;\n    },\n    startActiveSpan (name17, arg1, arg2, arg3) {\n        if (typeof arg1 === \"function\") {\n            return arg1(noopSpan);\n        }\n        if (typeof arg2 === \"function\") {\n            return arg2(noopSpan);\n        }\n        if (typeof arg3 === \"function\") {\n            return arg3(noopSpan);\n        }\n    }\n};\nvar noopSpan = {\n    spanContext () {\n        return noopSpanContext;\n    },\n    setAttribute () {\n        return this;\n    },\n    setAttributes () {\n        return this;\n    },\n    addEvent () {\n        return this;\n    },\n    addLink () {\n        return this;\n    },\n    addLinks () {\n        return this;\n    },\n    setStatus () {\n        return this;\n    },\n    updateName () {\n        return this;\n    },\n    end () {\n        return this;\n    },\n    isRecording () {\n        return false;\n    },\n    recordException () {\n        return this;\n    }\n};\nvar noopSpanContext = {\n    traceId: \"\",\n    spanId: \"\",\n    traceFlags: 0\n};\n// src/telemetry/get-tracer.ts\nfunction getTracer({ isEnabled = false, tracer } = {}) {\n    if (!isEnabled) {\n        return noopTracer;\n    }\n    if (tracer) {\n        return tracer;\n    }\n    return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.trace.getTracer(\"ai\");\n}\n// src/telemetry/record-span.ts\n\nasync function recordSpan({ name: name17, tracer, attributes, fn, endWhenDone = true }) {\n    return tracer.startActiveSpan(name17, {\n        attributes: await attributes\n    }, async (span)=>{\n        const ctx = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.context.active();\n        try {\n            const result = await _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.context.with(ctx, ()=>fn(span));\n            if (endWhenDone) {\n                span.end();\n            }\n            return result;\n        } catch (error) {\n            try {\n                recordErrorOnSpan(span, error);\n            } finally{\n                span.end();\n            }\n            throw error;\n        }\n    });\n}\nfunction recordErrorOnSpan(span, error) {\n    if (error instanceof Error) {\n        span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n        });\n        span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR,\n            message: error.message\n        });\n    } else {\n        span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR\n        });\n    }\n}\n// src/telemetry/select-telemetry-attributes.ts\nasync function selectTelemetryAttributes({ telemetry, attributes }) {\n    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n        return {};\n    }\n    const resultAttributes = {};\n    for (const [key, value] of Object.entries(attributes)){\n        if (value == null) {\n            continue;\n        }\n        if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n                continue;\n            }\n            const result = await value.input();\n            if (result != null) {\n                resultAttributes[key] = result;\n            }\n            continue;\n        }\n        if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n                continue;\n            }\n            const result = await value.output();\n            if (result != null) {\n                resultAttributes[key] = result;\n            }\n            continue;\n        }\n        resultAttributes[key] = value;\n    }\n    return resultAttributes;\n}\n// src/telemetry/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n    return JSON.stringify(prompt.map((message)=>({\n            ...message,\n            content: typeof message.content === \"string\" ? message.content : message.content.map((part)=>part.type === \"file\" ? {\n                    ...part,\n                    data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n                } : part)\n        })));\n}\n// src/types/usage.ts\nfunction asLanguageModelUsage(usage) {\n    return {\n        inputTokens: usage.inputTokens.total,\n        inputTokenDetails: {\n            noCacheTokens: usage.inputTokens.noCache,\n            cacheReadTokens: usage.inputTokens.cacheRead,\n            cacheWriteTokens: usage.inputTokens.cacheWrite\n        },\n        outputTokens: usage.outputTokens.total,\n        outputTokenDetails: {\n            textTokens: usage.outputTokens.text,\n            reasoningTokens: usage.outputTokens.reasoning\n        },\n        totalTokens: addTokenCounts(usage.inputTokens.total, usage.outputTokens.total),\n        raw: usage.raw,\n        reasoningTokens: usage.outputTokens.reasoning,\n        cachedInputTokens: usage.inputTokens.cacheRead\n    };\n}\nfunction createNullLanguageModelUsage() {\n    return {\n        inputTokens: void 0,\n        inputTokenDetails: {\n            noCacheTokens: void 0,\n            cacheReadTokens: void 0,\n            cacheWriteTokens: void 0\n        },\n        outputTokens: void 0,\n        outputTokenDetails: {\n            textTokens: void 0,\n            reasoningTokens: void 0\n        },\n        totalTokens: void 0,\n        raw: void 0\n    };\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n    var _a17, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    return {\n        inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n        inputTokenDetails: {\n            noCacheTokens: addTokenCounts((_a17 = usage1.inputTokenDetails) == null ? void 0 : _a17.noCacheTokens, (_b = usage2.inputTokenDetails) == null ? void 0 : _b.noCacheTokens),\n            cacheReadTokens: addTokenCounts((_c = usage1.inputTokenDetails) == null ? void 0 : _c.cacheReadTokens, (_d = usage2.inputTokenDetails) == null ? void 0 : _d.cacheReadTokens),\n            cacheWriteTokens: addTokenCounts((_e = usage1.inputTokenDetails) == null ? void 0 : _e.cacheWriteTokens, (_f = usage2.inputTokenDetails) == null ? void 0 : _f.cacheWriteTokens)\n        },\n        outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n        outputTokenDetails: {\n            textTokens: addTokenCounts((_g = usage1.outputTokenDetails) == null ? void 0 : _g.textTokens, (_h = usage2.outputTokenDetails) == null ? void 0 : _h.textTokens),\n            reasoningTokens: addTokenCounts((_i = usage1.outputTokenDetails) == null ? void 0 : _i.reasoningTokens, (_j = usage2.outputTokenDetails) == null ? void 0 : _j.reasoningTokens)\n        },\n        totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n        reasoningTokens: addTokenCounts(usage1.reasoningTokens, usage2.reasoningTokens),\n        cachedInputTokens: addTokenCounts(usage1.cachedInputTokens, usage2.cachedInputTokens)\n    };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n    return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\nfunction addImageModelUsage(usage1, usage2) {\n    return {\n        inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n        outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n        totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens)\n    };\n}\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n    if (base === void 0 && overrides === void 0) {\n        return void 0;\n    }\n    if (base === void 0) {\n        return overrides;\n    }\n    if (overrides === void 0) {\n        return base;\n    }\n    const result = {\n        ...base\n    };\n    for(const key in overrides){\n        if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n            const overridesValue = overrides[key];\n            if (overridesValue === void 0) continue;\n            const baseValue = key in base ? base[key] : void 0;\n            const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n            const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n            if (isSourceObject && isTargetObject) {\n                result[key] = mergeObjects(baseValue, overridesValue);\n            } else {\n                result[key] = overridesValue;\n            }\n        }\n    }\n    return result;\n}\n// src/util/retry-with-exponential-backoff.ts\n\n\nfunction getRetryDelayInMs({ error, exponentialBackoffDelay }) {\n    const headers = error.responseHeaders;\n    if (!headers) return exponentialBackoffDelay;\n    let ms;\n    const retryAfterMs = headers[\"retry-after-ms\"];\n    if (retryAfterMs) {\n        const timeoutMs = parseFloat(retryAfterMs);\n        if (!Number.isNaN(timeoutMs)) {\n            ms = timeoutMs;\n        }\n    }\n    const retryAfter = headers[\"retry-after\"];\n    if (retryAfter && ms === void 0) {\n        const timeoutSeconds = parseFloat(retryAfter);\n        if (!Number.isNaN(timeoutSeconds)) {\n            ms = timeoutSeconds * 1e3;\n        } else {\n            ms = Date.parse(retryAfter) - Date.now();\n        }\n    }\n    if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n        return ms;\n    }\n    return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2, abortSignal } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor,\n            abortSignal\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor, abortSignal }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(getRetryDelayInMs({\n                error,\n                exponentialBackoffDelay: delayInMs\n            }), {\n                abortSignal\n            });\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor,\n                abortSignal\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// src/util/prepare-retries.ts\nfunction prepareRetries({ maxRetries, abortSignal }) {\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n    return {\n        maxRetries: maxRetriesResult,\n        retry: retryWithExponentialBackoffRespectingRetryHeaders({\n            maxRetries: maxRetriesResult,\n            abortSignal\n        })\n    };\n}\n// src/generate-text/collect-tool-approvals.ts\nfunction collectToolApprovals({ messages }) {\n    const lastMessage = messages.at(-1);\n    if ((lastMessage == null ? void 0 : lastMessage.role) != \"tool\") {\n        return {\n            approvedToolApprovals: [],\n            deniedToolApprovals: []\n        };\n    }\n    const toolCallsByToolCallId = {};\n    for (const message of messages){\n        if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n            const content = message.content;\n            for (const part of content){\n                if (part.type === \"tool-call\") {\n                    toolCallsByToolCallId[part.toolCallId] = part;\n                }\n            }\n        }\n    }\n    const toolApprovalRequestsByApprovalId = {};\n    for (const message of messages){\n        if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n            const content = message.content;\n            for (const part of content){\n                if (part.type === \"tool-approval-request\") {\n                    toolApprovalRequestsByApprovalId[part.approvalId] = part;\n                }\n            }\n        }\n    }\n    const toolResults = {};\n    for (const part of lastMessage.content){\n        if (part.type === \"tool-result\") {\n            toolResults[part.toolCallId] = part;\n        }\n    }\n    const approvedToolApprovals = [];\n    const deniedToolApprovals = [];\n    const approvalResponses = lastMessage.content.filter((part)=>part.type === \"tool-approval-response\");\n    for (const approvalResponse of approvalResponses){\n        const approvalRequest = toolApprovalRequestsByApprovalId[approvalResponse.approvalId];\n        if (approvalRequest == null) {\n            throw new InvalidToolApprovalError({\n                approvalId: approvalResponse.approvalId\n            });\n        }\n        if (toolResults[approvalRequest.toolCallId] != null) {\n            continue;\n        }\n        const toolCall = toolCallsByToolCallId[approvalRequest.toolCallId];\n        if (toolCall == null) {\n            throw new ToolCallNotFoundForApprovalError({\n                toolCallId: approvalRequest.toolCallId,\n                approvalId: approvalRequest.approvalId\n            });\n        }\n        const approval = {\n            approvalRequest,\n            approvalResponse,\n            toolCall\n        };\n        if (approvalResponse.approved) {\n            approvedToolApprovals.push(approval);\n        } else {\n            deniedToolApprovals.push(approval);\n        }\n    }\n    return {\n        approvedToolApprovals,\n        deniedToolApprovals\n    };\n}\n// src/generate-text/execute-tool-call.ts\n\nasync function executeToolCall({ toolCall, tools, tracer, telemetry, messages, abortSignal, experimental_context, onPreliminaryToolResult }) {\n    const { toolName, toolCallId, input } = toolCall;\n    const tool2 = tools == null ? void 0 : tools[toolName];\n    if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n    }\n    return recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.toolCall\",\n                    telemetry\n                }),\n                \"ai.toolCall.name\": toolName,\n                \"ai.toolCall.id\": toolCallId,\n                \"ai.toolCall.args\": {\n                    output: ()=>JSON.stringify(input)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            let output;\n            try {\n                const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n                    execute: tool2.execute.bind(tool2),\n                    input,\n                    options: {\n                        toolCallId,\n                        messages,\n                        abortSignal,\n                        experimental_context\n                    }\n                });\n                for await (const part of stream){\n                    if (part.type === \"preliminary\") {\n                        onPreliminaryToolResult == null ? void 0 : onPreliminaryToolResult({\n                            ...toolCall,\n                            type: \"tool-result\",\n                            output: part.output,\n                            preliminary: true\n                        });\n                    } else {\n                        output = part.output;\n                    }\n                }\n            } catch (error) {\n                recordErrorOnSpan(span, error);\n                return {\n                    type: \"tool-error\",\n                    toolCallId,\n                    toolName,\n                    input,\n                    error,\n                    dynamic: tool2.type === \"dynamic\",\n                    ...toolCall.providerMetadata != null ? {\n                        providerMetadata: toolCall.providerMetadata\n                    } : {}\n                };\n            }\n            try {\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.toolCall.result\": {\n                            output: ()=>JSON.stringify(output)\n                        }\n                    }\n                }));\n            } catch (ignored) {}\n            return {\n                type: \"tool-result\",\n                toolCallId,\n                toolName,\n                input,\n                output,\n                dynamic: tool2.type === \"dynamic\",\n                ...toolCall.providerMetadata != null ? {\n                    providerMetadata: toolCall.providerMetadata\n                } : {}\n            };\n        }\n    });\n}\n// src/generate-text/extract-text-content.ts\nfunction extractTextContent(content) {\n    const parts = content.filter((content2)=>content2.type === \"text\");\n    if (parts.length === 0) {\n        return void 0;\n    }\n    return parts.map((content2)=>content2.text).join(\"\");\n}\n// src/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n    constructor({ data, mediaType }){\n        const isUint8Array = data instanceof Uint8Array;\n        this.base64Data = isUint8Array ? void 0 : data;\n        this.uint8ArrayData = isUint8Array ? data : void 0;\n        this.mediaType = mediaType;\n    }\n    // lazy conversion with caching to avoid unnecessary conversion overhead:\n    get base64() {\n        if (this.base64Data == null) {\n            this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n        }\n        return this.base64Data;\n    }\n    // lazy conversion with caching to avoid unnecessary conversion overhead:\n    get uint8Array() {\n        if (this.uint8ArrayData == null) {\n            this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n        }\n        return this.uint8ArrayData;\n    }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n    constructor(options){\n        super(options);\n        this.type = \"file\";\n    }\n};\n// src/generate-text/is-approval-needed.ts\nasync function isApprovalNeeded({ tool: tool2, toolCall, messages, experimental_context }) {\n    if (tool2.needsApproval == null) {\n        return false;\n    }\n    if (typeof tool2.needsApproval === \"boolean\") {\n        return tool2.needsApproval;\n    }\n    return await tool2.needsApproval(toolCall.input, {\n        toolCallId: toolCall.toolCallId,\n        messages,\n        experimental_context\n    });\n}\n// src/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n    array: ()=>array,\n    choice: ()=>choice,\n    json: ()=>json,\n    object: ()=>object,\n    text: ()=>text\n});\n\n\n// src/util/parse-partial-json.ts\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n    const stack = [\n        \"ROOT\"\n    ];\n    let lastValidIndex = -1;\n    let literalStart = null;\n    function processValueStart(char, i, swapState) {\n        {\n            switch(char){\n                case '\"':\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_STRING\");\n                        break;\n                    }\n                case \"f\":\n                case \"t\":\n                case \"n\":\n                    {\n                        lastValidIndex = i;\n                        literalStart = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_LITERAL\");\n                        break;\n                    }\n                case \"-\":\n                    {\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"0\":\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"{\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_OBJECT_START\");\n                        break;\n                    }\n                case \"[\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_ARRAY_START\");\n                        break;\n                    }\n            }\n        }\n    }\n    function processAfterObjectValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n                    break;\n                }\n            case \"}\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    function processAfterArrayValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                    break;\n                }\n            case \"]\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    for(let i = 0; i < input.length; i++){\n        const char = input[i];\n        const currentState = stack[stack.length - 1];\n        switch(currentState){\n            case \"ROOT\":\n                processValueStart(char, i, \"FINISH\");\n                break;\n            case \"INSIDE_OBJECT_START\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n                {\n                    switch(char){\n                        case \":\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n                {\n                    processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    processAfterObjectValue(char, i);\n                    break;\n                }\n            case \"INSIDE_STRING\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"\\\\\":\n                            {\n                                stack.push(\"INSIDE_STRING_ESCAPE\");\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n                {\n                    switch(char){\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    switch(char){\n                        case \",\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n                {\n                    processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_STRING_ESCAPE\":\n                {\n                    stack.pop();\n                    lastValidIndex = i;\n                    break;\n                }\n            case \"INSIDE_NUMBER\":\n                {\n                    switch(char){\n                        case \"0\":\n                        case \"1\":\n                        case \"2\":\n                        case \"3\":\n                        case \"4\":\n                        case \"5\":\n                        case \"6\":\n                        case \"7\":\n                        case \"8\":\n                        case \"9\":\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"e\":\n                        case \"E\":\n                        case \"-\":\n                        case \".\":\n                            {\n                                break;\n                            }\n                        case \",\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                break;\n                            }\n                        default:\n                            {\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, i + 1);\n                    if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n                        stack.pop();\n                        if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                            processAfterObjectValue(char, i);\n                        } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                            processAfterArrayValue(char, i);\n                        }\n                    } else {\n                        lastValidIndex = i;\n                    }\n                    break;\n                }\n        }\n    }\n    let result = input.slice(0, lastValidIndex + 1);\n    for(let i = stack.length - 1; i >= 0; i--){\n        const state = stack[i];\n        switch(state){\n            case \"INSIDE_STRING\":\n                {\n                    result += '\"';\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n            case \"INSIDE_OBJECT_START\":\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    result += \"}\";\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    result += \"]\";\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, input.length);\n                    if (\"true\".startsWith(partialLiteral)) {\n                        result += \"true\".slice(partialLiteral.length);\n                    } else if (\"false\".startsWith(partialLiteral)) {\n                        result += \"false\".slice(partialLiteral.length);\n                    } else if (\"null\".startsWith(partialLiteral)) {\n                        result += \"null\".slice(partialLiteral.length);\n                    }\n                }\n        }\n    }\n    return result;\n}\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n    if (jsonText === void 0) {\n        return {\n            value: void 0,\n            state: \"undefined-input\"\n        };\n    }\n    let result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: jsonText\n    });\n    if (result.success) {\n        return {\n            value: result.value,\n            state: \"successful-parse\"\n        };\n    }\n    result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: fixJson(jsonText)\n    });\n    if (result.success) {\n        return {\n            value: result.value,\n            state: \"repaired-parse\"\n        };\n    }\n    return {\n        value: void 0,\n        state: \"failed-parse\"\n    };\n}\n// src/generate-text/output.ts\nvar text = ()=>({\n        name: \"text\",\n        responseFormat: Promise.resolve({\n            type: \"text\"\n        }),\n        async parseCompleteOutput ({ text: text2 }) {\n            return text2;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            return {\n                partial: text2\n            };\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    });\nvar object = ({ schema: inputSchema, name: name17, description })=>{\n    const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema);\n    return {\n        name: \"object\",\n        responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(schema.jsonSchema).then((jsonSchema2)=>({\n                type: \"json\",\n                schema: jsonSchema2,\n                ...name17 != null && {\n                    name: name17\n                },\n                ...description != null && {\n                    description\n                }\n            })),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value: parseResult.value,\n                schema\n            });\n            if (!validationResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: validationResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            return validationResult.value;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        return {\n                            // Note: currently no validation of partial results:\n                            partial: result.value\n                        };\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    };\n};\nvar array = ({ element: inputElementSchema, name: name17, description })=>{\n    const elementSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputElementSchema);\n    return {\n        name: \"array\",\n        // JSON schema that describes an array of elements:\n        responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(elementSchema.jsonSchema).then((jsonSchema2)=>{\n            const { $schema, ...itemSchema } = jsonSchema2;\n            return {\n                type: \"json\",\n                schema: {\n                    $schema: \"http://json-schema.org/draft-07/schema#\",\n                    type: \"object\",\n                    properties: {\n                        elements: {\n                            type: \"array\",\n                            items: itemSchema\n                        }\n                    },\n                    required: [\n                        \"elements\"\n                    ],\n                    additionalProperties: false\n                },\n                ...name17 != null && {\n                    name: name17\n                },\n                ...description != null && {\n                    description\n                }\n            };\n        }),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            const outerValue = parseResult.value;\n            if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value: outerValue,\n                        cause: \"response must be an object with an elements array\"\n                    }),\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            for (const element of outerValue.elements){\n                const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema: elementSchema\n                });\n                if (!validationResult.success) {\n                    throw new NoObjectGeneratedError({\n                        message: \"No object generated: response did not match schema.\",\n                        cause: validationResult.error,\n                        text: text2,\n                        response: context2.response,\n                        usage: context2.usage,\n                        finishReason: context2.finishReason\n                    });\n                }\n            }\n            return outerValue.elements;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        const outerValue = result.value;\n                        if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n                            return void 0;\n                        }\n                        const rawElements = result.state === \"repaired-parse\" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;\n                        const parsedElements = [];\n                        for (const rawElement of rawElements){\n                            const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                                value: rawElement,\n                                schema: elementSchema\n                            });\n                            if (validationResult.success) {\n                                parsedElements.push(validationResult.value);\n                            }\n                        }\n                        return {\n                            partial: parsedElements\n                        };\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            let publishedElements = 0;\n            return new TransformStream({\n                transform ({ partialOutput }, controller) {\n                    if (partialOutput != null) {\n                        for(; publishedElements < partialOutput.length; publishedElements++){\n                            controller.enqueue(partialOutput[publishedElements]);\n                        }\n                    }\n                }\n            });\n        }\n    };\n};\nvar choice = ({ options: choiceOptions, name: name17, description })=>{\n    return {\n        name: \"choice\",\n        // JSON schema that describes an enumeration:\n        responseFormat: Promise.resolve({\n            type: \"json\",\n            schema: {\n                $schema: \"http://json-schema.org/draft-07/schema#\",\n                type: \"object\",\n                properties: {\n                    result: {\n                        type: \"string\",\n                        enum: choiceOptions\n                    }\n                },\n                required: [\n                    \"result\"\n                ],\n                additionalProperties: false\n            },\n            ...name17 != null && {\n                name: name17\n            },\n            ...description != null && {\n                description\n            }\n        }),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            const outerValue = parseResult.value;\n            if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\" || !choiceOptions.includes(outerValue.result)) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value: outerValue,\n                        cause: \"response must be an object that contains a choice value.\"\n                    }),\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            return outerValue.result;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        const outerValue = result.value;\n                        if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\") {\n                            return void 0;\n                        }\n                        const potentialMatches = choiceOptions.filter((choiceOption)=>choiceOption.startsWith(outerValue.result));\n                        if (result.state === \"successful-parse\") {\n                            return potentialMatches.includes(outerValue.result) ? {\n                                partial: outerValue.result\n                            } : void 0;\n                        } else {\n                            return potentialMatches.length === 1 ? {\n                                partial: potentialMatches[0]\n                            } : void 0;\n                        }\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    };\n};\nvar json = ({ name: name17, description } = {})=>{\n    return {\n        name: \"json\",\n        responseFormat: Promise.resolve({\n            type: \"json\",\n            ...name17 != null && {\n                name: name17\n            },\n            ...description != null && {\n                description\n            }\n        }),\n        async parseCompleteOutput ({ text: text2 }, context2) {\n            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context2.response,\n                    usage: context2.usage,\n                    finishReason: context2.finishReason\n                });\n            }\n            return parseResult.value;\n        },\n        async parsePartialOutput ({ text: text2 }) {\n            const result = await parsePartialJson(text2);\n            switch(result.state){\n                case \"failed-parse\":\n                case \"undefined-input\":\n                    {\n                        return void 0;\n                    }\n                case \"repaired-parse\":\n                case \"successful-parse\":\n                    {\n                        return result.value === void 0 ? void 0 : {\n                            partial: result.value\n                        };\n                    }\n            }\n        },\n        createElementStreamTransform () {\n            return void 0;\n        }\n    };\n};\n// src/generate-text/parse-tool-call.ts\n\nasync function parseToolCall({ toolCall, tools, repairToolCall, system, messages }) {\n    var _a17;\n    try {\n        if (tools == null) {\n            if (toolCall.providerExecuted && toolCall.dynamic) {\n                return await parseProviderExecutedDynamicToolCall(toolCall);\n            }\n            throw new NoSuchToolError({\n                toolName: toolCall.toolName\n            });\n        }\n        try {\n            return await doParseToolCall({\n                toolCall,\n                tools\n            });\n        } catch (error) {\n            if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {\n                throw error;\n            }\n            let repairedToolCall = null;\n            try {\n                repairedToolCall = await repairToolCall({\n                    toolCall,\n                    tools,\n                    inputSchema: async ({ toolName })=>{\n                        const { inputSchema } = tools[toolName];\n                        return await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema).jsonSchema;\n                    },\n                    system,\n                    messages,\n                    error\n                });\n            } catch (repairError) {\n                throw new ToolCallRepairError({\n                    cause: repairError,\n                    originalError: error\n                });\n            }\n            if (repairedToolCall == null) {\n                throw error;\n            }\n            return await doParseToolCall({\n                toolCall: repairedToolCall,\n                tools\n            });\n        }\n    } catch (error) {\n        const parsedInput = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n            text: toolCall.input\n        });\n        const input = parsedInput.success ? parsedInput.value : toolCall.input;\n        return {\n            type: \"tool-call\",\n            toolCallId: toolCall.toolCallId,\n            toolName: toolCall.toolName,\n            input,\n            dynamic: true,\n            invalid: true,\n            error,\n            title: (_a17 = tools == null ? void 0 : tools[toolCall.toolName]) == null ? void 0 : _a17.title,\n            providerExecuted: toolCall.providerExecuted,\n            providerMetadata: toolCall.providerMetadata\n        };\n    }\n}\nasync function parseProviderExecutedDynamicToolCall(toolCall) {\n    const parseResult = toolCall.input.trim() === \"\" ? {\n        success: true,\n        value: {}\n    } : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: toolCall.input\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolInputError({\n            toolName: toolCall.toolName,\n            toolInput: toolCall.input,\n            cause: parseResult.error\n        });\n    }\n    return {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        input: parseResult.value,\n        providerExecuted: true,\n        dynamic: true,\n        providerMetadata: toolCall.providerMetadata\n    };\n}\nasync function doParseToolCall({ toolCall, tools }) {\n    const toolName = toolCall.toolName;\n    const tool2 = tools[toolName];\n    if (tool2 == null) {\n        if (toolCall.providerExecuted && toolCall.dynamic) {\n            return await parseProviderExecutedDynamicToolCall(toolCall);\n        }\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName,\n            availableTools: Object.keys(tools)\n        });\n    }\n    const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema);\n    const parseResult = toolCall.input.trim() === \"\" ? await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: {},\n        schema\n    }) : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: toolCall.input,\n        schema\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolInputError({\n            toolName,\n            toolInput: toolCall.input,\n            cause: parseResult.error\n        });\n    }\n    return tool2.type === \"dynamic\" ? {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        input: parseResult.value,\n        providerExecuted: toolCall.providerExecuted,\n        providerMetadata: toolCall.providerMetadata,\n        dynamic: true,\n        title: tool2.title\n    } : {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        input: parseResult.value,\n        providerExecuted: toolCall.providerExecuted,\n        providerMetadata: toolCall.providerMetadata,\n        title: tool2.title\n    };\n}\n// src/generate-text/step-result.ts\nvar DefaultStepResult = class {\n    constructor({ content, finishReason, rawFinishReason, usage, warnings, request, response, providerMetadata }){\n        this.content = content;\n        this.finishReason = finishReason;\n        this.rawFinishReason = rawFinishReason;\n        this.usage = usage;\n        this.warnings = warnings;\n        this.request = request;\n        this.response = response;\n        this.providerMetadata = providerMetadata;\n    }\n    get text() {\n        return this.content.filter((part)=>part.type === \"text\").map((part)=>part.text).join(\"\");\n    }\n    get reasoning() {\n        return this.content.filter((part)=>part.type === \"reasoning\");\n    }\n    get reasoningText() {\n        return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part)=>part.text).join(\"\");\n    }\n    get files() {\n        return this.content.filter((part)=>part.type === \"file\").map((part)=>part.file);\n    }\n    get sources() {\n        return this.content.filter((part)=>part.type === \"source\");\n    }\n    get toolCalls() {\n        return this.content.filter((part)=>part.type === \"tool-call\");\n    }\n    get staticToolCalls() {\n        return this.toolCalls.filter((toolCall)=>toolCall.dynamic !== true);\n    }\n    get dynamicToolCalls() {\n        return this.toolCalls.filter((toolCall)=>toolCall.dynamic === true);\n    }\n    get toolResults() {\n        return this.content.filter((part)=>part.type === \"tool-result\");\n    }\n    get staticToolResults() {\n        return this.toolResults.filter((toolResult)=>toolResult.dynamic !== true);\n    }\n    get dynamicToolResults() {\n        return this.toolResults.filter((toolResult)=>toolResult.dynamic === true);\n    }\n};\n// src/generate-text/stop-condition.ts\nfunction stepCountIs(stepCount) {\n    return ({ steps })=>steps.length === stepCount;\n}\nfunction hasToolCall(toolName) {\n    return ({ steps })=>{\n        var _a17, _b, _c;\n        return (_c = (_b = (_a17 = steps[steps.length - 1]) == null ? void 0 : _a17.toolCalls) == null ? void 0 : _b.some((toolCall)=>toolCall.toolName === toolName)) != null ? _c : false;\n    };\n}\nasync function isStopConditionMet({ stopConditions, steps }) {\n    return (await Promise.all(stopConditions.map((condition)=>condition({\n            steps\n        })))).some((result)=>result);\n}\n// src/generate-text/to-response-messages.ts\nasync function toResponseMessages({ content: inputContent, tools }) {\n    const responseMessages = [];\n    const content = [];\n    for (const part of inputContent){\n        if (part.type === \"source\") {\n            continue;\n        }\n        if ((part.type === \"tool-result\" || part.type === \"tool-error\") && !part.providerExecuted) {\n            continue;\n        }\n        if (part.type === \"text\" && part.text.length === 0) {\n            continue;\n        }\n        switch(part.type){\n            case \"text\":\n                content.push({\n                    type: \"text\",\n                    text: part.text,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"reasoning\":\n                content.push({\n                    type: \"reasoning\",\n                    text: part.text,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"file\":\n                content.push({\n                    type: \"file\",\n                    data: part.file.base64,\n                    mediaType: part.file.mediaType,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"tool-call\":\n                content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName: part.toolName,\n                    input: part.input,\n                    providerExecuted: part.providerExecuted,\n                    providerOptions: part.providerMetadata\n                });\n                break;\n            case \"tool-result\":\n                {\n                    const output = await createToolModelOutput({\n                        toolCallId: part.toolCallId,\n                        input: part.input,\n                        tool: tools == null ? void 0 : tools[part.toolName],\n                        output: part.output,\n                        errorMode: \"none\"\n                    });\n                    content.push({\n                        type: \"tool-result\",\n                        toolCallId: part.toolCallId,\n                        toolName: part.toolName,\n                        output,\n                        providerOptions: part.providerMetadata\n                    });\n                    break;\n                }\n            case \"tool-error\":\n                {\n                    const output = await createToolModelOutput({\n                        toolCallId: part.toolCallId,\n                        input: part.input,\n                        tool: tools == null ? void 0 : tools[part.toolName],\n                        output: part.error,\n                        errorMode: \"json\"\n                    });\n                    content.push({\n                        type: \"tool-result\",\n                        toolCallId: part.toolCallId,\n                        toolName: part.toolName,\n                        output,\n                        providerOptions: part.providerMetadata\n                    });\n                    break;\n                }\n            case \"tool-approval-request\":\n                content.push({\n                    type: \"tool-approval-request\",\n                    approvalId: part.approvalId,\n                    toolCallId: part.toolCall.toolCallId\n                });\n                break;\n        }\n    }\n    if (content.length > 0) {\n        responseMessages.push({\n            role: \"assistant\",\n            content\n        });\n    }\n    const toolResultContent = [];\n    for (const part of inputContent){\n        if (!(part.type === \"tool-result\" || part.type === \"tool-error\") || part.providerExecuted) {\n            continue;\n        }\n        const output = await createToolModelOutput({\n            toolCallId: part.toolCallId,\n            input: part.input,\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.type === \"tool-result\" ? part.output : part.error,\n            errorMode: part.type === \"tool-error\" ? \"text\" : \"none\"\n        });\n        toolResultContent.push({\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            output,\n            ...part.providerMetadata != null ? {\n                providerOptions: part.providerMetadata\n            } : {}\n        });\n    }\n    if (toolResultContent.length > 0) {\n        responseMessages.push({\n            role: \"tool\",\n            content: toolResultContent\n        });\n    }\n    return responseMessages;\n}\n// src/util/merge-abort-signals.ts\nfunction mergeAbortSignals(...signals) {\n    const validSignals = signals.filter((signal)=>signal != null);\n    if (validSignals.length === 0) {\n        return void 0;\n    }\n    if (validSignals.length === 1) {\n        return validSignals[0];\n    }\n    const controller = new AbortController();\n    for (const signal of validSignals){\n        if (signal.aborted) {\n            controller.abort(signal.reason);\n            return controller.signal;\n        }\n        signal.addEventListener(\"abort\", ()=>{\n            controller.abort(signal.reason);\n        }, {\n            once: true\n        });\n    }\n    return controller.signal;\n}\n// src/generate-text/generate-text.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function generateText({ model: modelArg, tools, toolChoice, system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, timeout, headers, stopWhen = stepCountIs(1), experimental_output, output = experimental_output, experimental_telemetry: telemetry, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_prepareStep, prepareStep = experimental_prepareStep, experimental_repairToolCall: repairToolCall, experimental_download: download2, experimental_context, _internal: { generateId: generateId2 = originalGenerateId } = {}, onStepFinish, onFinish, ...settings }) {\n    const model = resolveLanguageModel(modelArg);\n    const stopConditions = asArray(stopWhen);\n    const totalTimeoutMs = getTotalTimeoutMs(timeout);\n    const stepTimeoutMs = getStepTimeoutMs(timeout);\n    const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n    const mergedAbortSignal = mergeAbortSignals(abortSignal, totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0, stepAbortController == null ? void 0 : stepAbortController.signal);\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal: mergedAbortSignal\n    });\n    const callSettings = prepareCallSettings(settings);\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            ...callSettings,\n            maxRetries\n        }\n    });\n    const initialPrompt = await standardizePrompt({\n        system,\n        prompt,\n        messages\n    });\n    const tracer = getTracer(telemetry);\n    try {\n        return await recordSpan({\n            name: \"ai.generateText\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.generateText\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // model:\n                    \"ai.model.provider\": model.provider,\n                    \"ai.model.id\": model.modelId,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    }\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                var _a17, _b, _c, _d, _e, _f, _g, _h;\n                const initialMessages = initialPrompt.messages;\n                const responseMessages = [];\n                const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({\n                    messages: initialMessages\n                });\n                const localApprovedToolApprovals = approvedToolApprovals.filter((toolApproval)=>!toolApproval.toolCall.providerExecuted);\n                if (deniedToolApprovals.length > 0 || localApprovedToolApprovals.length > 0) {\n                    const toolOutputs = await executeTools({\n                        toolCalls: localApprovedToolApprovals.map((toolApproval)=>toolApproval.toolCall),\n                        tools,\n                        tracer,\n                        telemetry,\n                        messages: initialMessages,\n                        abortSignal: mergedAbortSignal,\n                        experimental_context\n                    });\n                    const toolContent = [];\n                    for (const output2 of toolOutputs){\n                        const modelOutput = await createToolModelOutput({\n                            toolCallId: output2.toolCallId,\n                            input: output2.input,\n                            tool: tools == null ? void 0 : tools[output2.toolName],\n                            output: output2.type === \"tool-result\" ? output2.output : output2.error,\n                            errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n                        });\n                        toolContent.push({\n                            type: \"tool-result\",\n                            toolCallId: output2.toolCallId,\n                            toolName: output2.toolName,\n                            output: modelOutput\n                        });\n                    }\n                    for (const toolApproval of deniedToolApprovals){\n                        toolContent.push({\n                            type: \"tool-result\",\n                            toolCallId: toolApproval.toolCall.toolCallId,\n                            toolName: toolApproval.toolCall.toolName,\n                            output: {\n                                type: \"execution-denied\",\n                                reason: toolApproval.approvalResponse.reason,\n                                // For provider-executed tools, include approvalId so provider can correlate\n                                ...toolApproval.toolCall.providerExecuted && {\n                                    providerOptions: {\n                                        openai: {\n                                            approvalId: toolApproval.approvalResponse.approvalId\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                    }\n                    responseMessages.push({\n                        role: \"tool\",\n                        content: toolContent\n                    });\n                }\n                const providerExecutedToolApprovals = [\n                    ...approvedToolApprovals,\n                    ...deniedToolApprovals\n                ].filter((toolApproval)=>toolApproval.toolCall.providerExecuted);\n                if (providerExecutedToolApprovals.length > 0) {\n                    responseMessages.push({\n                        role: \"tool\",\n                        content: providerExecutedToolApprovals.map((toolApproval)=>({\n                                type: \"tool-approval-response\",\n                                approvalId: toolApproval.approvalResponse.approvalId,\n                                approved: toolApproval.approvalResponse.approved,\n                                reason: toolApproval.approvalResponse.reason,\n                                providerExecuted: true\n                            }))\n                    });\n                }\n                const callSettings2 = prepareCallSettings(settings);\n                let currentModelResponse;\n                let clientToolCalls = [];\n                let clientToolOutputs = [];\n                const steps = [];\n                const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n                do {\n                    const stepTimeoutId = stepTimeoutMs != null ? setTimeout(()=>stepAbortController.abort(), stepTimeoutMs) : void 0;\n                    try {\n                        const stepInputMessages = [\n                            ...initialMessages,\n                            ...responseMessages\n                        ];\n                        const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n                            model,\n                            steps,\n                            stepNumber: steps.length,\n                            messages: stepInputMessages,\n                            experimental_context\n                        }));\n                        const stepModel = resolveLanguageModel((_a17 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a17 : model);\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: {\n                                system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n                            },\n                            supportedUrls: await stepModel.supportedUrls,\n                            download: download2\n                        });\n                        experimental_context = (_d = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _d : experimental_context;\n                        const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n                            tools,\n                            toolChoice: (_e = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _e : toolChoice,\n                            activeTools: (_f = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _f : activeTools\n                        });\n                        currentModelResponse = await retry(()=>{\n                            var _a18;\n                            return recordSpan({\n                                name: \"ai.generateText.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateText.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        // model:\n                                        \"ai.model.provider\": stepModel.provider,\n                                        \"ai.model.id\": stepModel.modelId,\n                                        // prompt:\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>stringifyForTelemetry(promptMessages)\n                                        },\n                                        \"ai.prompt.tools\": {\n                                            // convert the language model level tools:\n                                            input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))\n                                        },\n                                        \"ai.prompt.toolChoice\": {\n                                            input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                                        },\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": stepModel.provider,\n                                        \"gen_ai.request.model\": stepModel.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                        \"gen_ai.request.temperature\": (_a18 = settings.temperature) != null ? _a18 : void 0,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a19, _b2, _c2, _d2, _e2, _f2, _g2, _h2;\n                                    const stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions);\n                                    const result = await stepModel.doGenerate({\n                                        ...callSettings2,\n                                        tools: stepTools,\n                                        toolChoice: stepToolChoice,\n                                        responseFormat: await (output == null ? void 0 : output.responseFormat),\n                                        prompt: promptMessages,\n                                        providerOptions: stepProviderOptions,\n                                        abortSignal: mergedAbortSignal,\n                                        headers: headersWithUserAgent\n                                    });\n                                    const responseData = {\n                                        id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId2(),\n                                        timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : /* @__PURE__ */ new Date(),\n                                        modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                                        headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                                        body: (_h2 = result.response) == null ? void 0 : _h2.body\n                                    };\n                                    span2.setAttributes(await selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result.finishReason.unified,\n                                            \"ai.response.text\": {\n                                                output: ()=>extractTextContent(result.content)\n                                            },\n                                            \"ai.response.toolCalls\": {\n                                                output: ()=>{\n                                                    const toolCalls = asToolCalls(result.content);\n                                                    return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                                                }\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.response.providerMetadata\": JSON.stringify(result.providerMetadata),\n                                            // TODO rename telemetry attributes to inputTokens and outputTokens\n                                            \"ai.usage.promptTokens\": result.usage.inputTokens.total,\n                                            \"ai.usage.completionTokens\": result.usage.outputTokens.total,\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result.finishReason.unified\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.input_tokens\": result.usage.inputTokens.total,\n                                            \"gen_ai.usage.output_tokens\": result.usage.outputTokens.total\n                                        }\n                                    }));\n                                    return {\n                                        ...result,\n                                        response: responseData\n                                    };\n                                }\n                            });\n                        });\n                        const stepToolCalls = await Promise.all(currentModelResponse.content.filter((part)=>part.type === \"tool-call\").map((toolCall)=>parseToolCall({\n                                toolCall,\n                                tools,\n                                repairToolCall,\n                                system,\n                                messages: stepInputMessages\n                            })));\n                        const toolApprovalRequests = {};\n                        for (const toolCall of stepToolCalls){\n                            if (toolCall.invalid) {\n                                continue;\n                            }\n                            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                            if (tool2 == null) {\n                                continue;\n                            }\n                            if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null) {\n                                await tool2.onInputAvailable({\n                                    input: toolCall.input,\n                                    toolCallId: toolCall.toolCallId,\n                                    messages: stepInputMessages,\n                                    abortSignal: mergedAbortSignal,\n                                    experimental_context\n                                });\n                            }\n                            if (await isApprovalNeeded({\n                                tool: tool2,\n                                toolCall,\n                                messages: stepInputMessages,\n                                experimental_context\n                            })) {\n                                toolApprovalRequests[toolCall.toolCallId] = {\n                                    type: \"tool-approval-request\",\n                                    approvalId: generateId2(),\n                                    toolCall\n                                };\n                            }\n                        }\n                        const invalidToolCalls = stepToolCalls.filter((toolCall)=>toolCall.invalid && toolCall.dynamic);\n                        clientToolOutputs = [];\n                        for (const toolCall of invalidToolCalls){\n                            clientToolOutputs.push({\n                                type: \"tool-error\",\n                                toolCallId: toolCall.toolCallId,\n                                toolName: toolCall.toolName,\n                                input: toolCall.input,\n                                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                                dynamic: true\n                            });\n                        }\n                        clientToolCalls = stepToolCalls.filter((toolCall)=>!toolCall.providerExecuted);\n                        if (tools != null) {\n                            clientToolOutputs.push(...await executeTools({\n                                toolCalls: clientToolCalls.filter((toolCall)=>!toolCall.invalid && toolApprovalRequests[toolCall.toolCallId] == null),\n                                tools,\n                                tracer,\n                                telemetry,\n                                messages: stepInputMessages,\n                                abortSignal: mergedAbortSignal,\n                                experimental_context\n                            }));\n                        }\n                        for (const toolCall of stepToolCalls){\n                            if (!toolCall.providerExecuted) continue;\n                            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                            if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                                const hasResultInResponse = currentModelResponse.content.some((part)=>part.type === \"tool-result\" && part.toolCallId === toolCall.toolCallId);\n                                if (!hasResultInResponse) {\n                                    pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                                        toolName: toolCall.toolName\n                                    });\n                                }\n                            }\n                        }\n                        for (const part of currentModelResponse.content){\n                            if (part.type === \"tool-result\") {\n                                pendingDeferredToolCalls.delete(part.toolCallId);\n                            }\n                        }\n                        const stepContent = asContent({\n                            content: currentModelResponse.content,\n                            toolCalls: stepToolCalls,\n                            toolOutputs: clientToolOutputs,\n                            toolApprovalRequests: Object.values(toolApprovalRequests),\n                            tools\n                        });\n                        responseMessages.push(...await toResponseMessages({\n                            content: stepContent,\n                            tools\n                        }));\n                        const currentStepResult = new DefaultStepResult({\n                            content: stepContent,\n                            finishReason: currentModelResponse.finishReason.unified,\n                            rawFinishReason: currentModelResponse.finishReason.raw,\n                            usage: asLanguageModelUsage(currentModelResponse.usage),\n                            warnings: currentModelResponse.warnings,\n                            providerMetadata: currentModelResponse.providerMetadata,\n                            request: (_g = currentModelResponse.request) != null ? _g : {},\n                            response: {\n                                ...currentModelResponse.response,\n                                // deep clone msgs to avoid mutating past messages in multi-step:\n                                messages: structuredClone(responseMessages)\n                            }\n                        });\n                        logWarnings({\n                            warnings: (_h = currentModelResponse.warnings) != null ? _h : [],\n                            provider: stepModel.provider,\n                            model: stepModel.modelId\n                        });\n                        steps.push(currentStepResult);\n                        await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    } finally{\n                        if (stepTimeoutId != null) {\n                            clearTimeout(stepTimeoutId);\n                        }\n                    }\n                }while (// Continue if:\n                // 1. There are client tool calls that have all been executed, OR\n                // 2. There are pending deferred results from provider-executed tools\n                (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n                !await isStopConditionMet({\n                    stopConditions,\n                    steps\n                }));\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.response.finishReason\": currentModelResponse.finishReason.unified,\n                        \"ai.response.text\": {\n                            output: ()=>extractTextContent(currentModelResponse.content)\n                        },\n                        \"ai.response.toolCalls\": {\n                            output: ()=>{\n                                const toolCalls = asToolCalls(currentModelResponse.content);\n                                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                            }\n                        },\n                        \"ai.response.providerMetadata\": JSON.stringify(currentModelResponse.providerMetadata),\n                        // TODO rename telemetry attributes to inputTokens and outputTokens\n                        \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens.total,\n                        \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens.total\n                    }\n                }));\n                const lastStep = steps[steps.length - 1];\n                const totalUsage = steps.reduce((totalUsage2, step)=>{\n                    return addLanguageModelUsage(totalUsage2, step.usage);\n                }, {\n                    inputTokens: void 0,\n                    outputTokens: void 0,\n                    totalTokens: void 0,\n                    reasoningTokens: void 0,\n                    cachedInputTokens: void 0\n                });\n                await (onFinish == null ? void 0 : onFinish({\n                    finishReason: lastStep.finishReason,\n                    rawFinishReason: lastStep.rawFinishReason,\n                    usage: lastStep.usage,\n                    content: lastStep.content,\n                    text: lastStep.text,\n                    reasoningText: lastStep.reasoningText,\n                    reasoning: lastStep.reasoning,\n                    files: lastStep.files,\n                    sources: lastStep.sources,\n                    toolCalls: lastStep.toolCalls,\n                    staticToolCalls: lastStep.staticToolCalls,\n                    dynamicToolCalls: lastStep.dynamicToolCalls,\n                    toolResults: lastStep.toolResults,\n                    staticToolResults: lastStep.staticToolResults,\n                    dynamicToolResults: lastStep.dynamicToolResults,\n                    request: lastStep.request,\n                    response: lastStep.response,\n                    warnings: lastStep.warnings,\n                    providerMetadata: lastStep.providerMetadata,\n                    steps,\n                    totalUsage,\n                    experimental_context\n                }));\n                let resolvedOutput;\n                if (lastStep.finishReason === \"stop\") {\n                    const outputSpecification = output != null ? output : text();\n                    resolvedOutput = await outputSpecification.parseCompleteOutput({\n                        text: lastStep.text\n                    }, {\n                        response: lastStep.response,\n                        usage: lastStep.usage,\n                        finishReason: lastStep.finishReason\n                    });\n                }\n                return new DefaultGenerateTextResult({\n                    steps,\n                    totalUsage,\n                    output: resolvedOutput\n                });\n            }\n        });\n    } catch (error) {\n        throw wrapGatewayError(error);\n    }\n}\nasync function executeTools({ toolCalls, tools, tracer, telemetry, messages, abortSignal, experimental_context }) {\n    const toolOutputs = await Promise.all(toolCalls.map(async (toolCall)=>executeToolCall({\n            toolCall,\n            tools,\n            tracer,\n            telemetry,\n            messages,\n            abortSignal,\n            experimental_context\n        })));\n    return toolOutputs.filter((output)=>output != null);\n}\nvar DefaultGenerateTextResult = class {\n    constructor(options){\n        this.steps = options.steps;\n        this._output = options.output;\n        this.totalUsage = options.totalUsage;\n    }\n    get finalStep() {\n        return this.steps[this.steps.length - 1];\n    }\n    get content() {\n        return this.finalStep.content;\n    }\n    get text() {\n        return this.finalStep.text;\n    }\n    get files() {\n        return this.finalStep.files;\n    }\n    get reasoningText() {\n        return this.finalStep.reasoningText;\n    }\n    get reasoning() {\n        return this.finalStep.reasoning;\n    }\n    get toolCalls() {\n        return this.finalStep.toolCalls;\n    }\n    get staticToolCalls() {\n        return this.finalStep.staticToolCalls;\n    }\n    get dynamicToolCalls() {\n        return this.finalStep.dynamicToolCalls;\n    }\n    get toolResults() {\n        return this.finalStep.toolResults;\n    }\n    get staticToolResults() {\n        return this.finalStep.staticToolResults;\n    }\n    get dynamicToolResults() {\n        return this.finalStep.dynamicToolResults;\n    }\n    get sources() {\n        return this.finalStep.sources;\n    }\n    get finishReason() {\n        return this.finalStep.finishReason;\n    }\n    get rawFinishReason() {\n        return this.finalStep.rawFinishReason;\n    }\n    get warnings() {\n        return this.finalStep.warnings;\n    }\n    get providerMetadata() {\n        return this.finalStep.providerMetadata;\n    }\n    get response() {\n        return this.finalStep.response;\n    }\n    get request() {\n        return this.finalStep.request;\n    }\n    get usage() {\n        return this.finalStep.usage;\n    }\n    get experimental_output() {\n        return this.output;\n    }\n    get output() {\n        if (this._output == null) {\n            throw new NoOutputGeneratedError();\n        }\n        return this._output;\n    }\n};\nfunction asToolCalls(content) {\n    const parts = content.filter((part)=>part.type === \"tool-call\");\n    if (parts.length === 0) {\n        return void 0;\n    }\n    return parts.map((toolCall)=>({\n            toolCallId: toolCall.toolCallId,\n            toolName: toolCall.toolName,\n            input: toolCall.input\n        }));\n}\nfunction asContent({ content, toolCalls, toolOutputs, toolApprovalRequests, tools }) {\n    const contentParts = [];\n    for (const part of content){\n        switch(part.type){\n            case \"text\":\n            case \"reasoning\":\n            case \"source\":\n                contentParts.push(part);\n                break;\n            case \"file\":\n                {\n                    contentParts.push({\n                        type: \"file\",\n                        file: new DefaultGeneratedFile(part),\n                        ...part.providerMetadata != null ? {\n                            providerMetadata: part.providerMetadata\n                        } : {}\n                    });\n                    break;\n                }\n            case \"tool-call\":\n                {\n                    contentParts.push(toolCalls.find((toolCall)=>toolCall.toolCallId === part.toolCallId));\n                    break;\n                }\n            case \"tool-result\":\n                {\n                    const toolCall = toolCalls.find((toolCall2)=>toolCall2.toolCallId === part.toolCallId);\n                    if (toolCall == null) {\n                        const tool2 = tools == null ? void 0 : tools[part.toolName];\n                        const supportsDeferredResults = (tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults;\n                        if (!supportsDeferredResults) {\n                            throw new Error(`Tool call ${part.toolCallId} not found.`);\n                        }\n                        if (part.isError) {\n                            contentParts.push({\n                                type: \"tool-error\",\n                                toolCallId: part.toolCallId,\n                                toolName: part.toolName,\n                                input: void 0,\n                                error: part.result,\n                                providerExecuted: true,\n                                dynamic: part.dynamic\n                            });\n                        } else {\n                            contentParts.push({\n                                type: \"tool-result\",\n                                toolCallId: part.toolCallId,\n                                toolName: part.toolName,\n                                input: void 0,\n                                output: part.result,\n                                providerExecuted: true,\n                                dynamic: part.dynamic\n                            });\n                        }\n                        break;\n                    }\n                    if (part.isError) {\n                        contentParts.push({\n                            type: \"tool-error\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            input: toolCall.input,\n                            error: part.result,\n                            providerExecuted: true,\n                            dynamic: toolCall.dynamic\n                        });\n                    } else {\n                        contentParts.push({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            input: toolCall.input,\n                            output: part.result,\n                            providerExecuted: true,\n                            dynamic: toolCall.dynamic\n                        });\n                    }\n                    break;\n                }\n            case \"tool-approval-request\":\n                {\n                    const toolCall = toolCalls.find((toolCall2)=>toolCall2.toolCallId === part.toolCallId);\n                    if (toolCall == null) {\n                        throw new ToolCallNotFoundForApprovalError({\n                            toolCallId: part.toolCallId,\n                            approvalId: part.approvalId\n                        });\n                    }\n                    contentParts.push({\n                        type: \"tool-approval-request\",\n                        approvalId: part.approvalId,\n                        toolCall\n                    });\n                    break;\n                }\n        }\n    }\n    return [\n        ...contentParts,\n        ...toolOutputs,\n        ...toolApprovalRequests\n    ];\n}\n// src/generate-text/stream-text.ts\n\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n    const responseHeaders = new Headers(headers != null ? headers : {});\n    for (const [key, value] of Object.entries(defaultHeaders)){\n        if (!responseHeaders.has(key)) {\n            responseHeaders.set(key, value);\n        }\n    }\n    return responseHeaders;\n}\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({ status, statusText, headers, textStream }) {\n    return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n        status: status != null ? status : 200,\n        statusText,\n        headers: prepareHeaders(headers, {\n            \"content-type\": \"text/plain; charset=utf-8\"\n        })\n    });\n}\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({ response, status, statusText, headers, stream }) {\n    const statusCode = status != null ? status : 200;\n    if (statusText !== void 0) {\n        response.writeHead(statusCode, statusText, headers);\n    } else {\n        response.writeHead(statusCode, headers);\n    }\n    const reader = stream.getReader();\n    const read = async ()=>{\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                const canContinue = response.write(value);\n                if (!canContinue) {\n                    await new Promise((resolve3)=>{\n                        response.once(\"drain\", resolve3);\n                    });\n                }\n            }\n        } catch (error) {\n            throw error;\n        } finally{\n            response.end();\n        }\n    };\n    read();\n}\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({ response, status, statusText, headers, textStream }) {\n    writeToServerResponse({\n        response,\n        status,\n        statusText,\n        headers: Object.fromEntries(prepareHeaders(headers, {\n            \"content-type\": \"text/plain; charset=utf-8\"\n        }).entries()),\n        stream: textStream.pipeThrough(new TextEncoderStream())\n    });\n}\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n    constructor(){\n        super({\n            transform (part, controller) {\n                controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n            },\n            flush (controller) {\n                controller.enqueue(\"data: [DONE]\\n\\n\");\n            }\n        });\n    }\n};\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar UI_MESSAGE_STREAM_HEADERS = {\n    \"content-type\": \"text/event-stream\",\n    \"cache-control\": \"no-cache\",\n    connection: \"keep-alive\",\n    \"x-vercel-ai-ui-message-stream\": \"v1\",\n    \"x-accel-buffering\": \"no\"\n};\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({ status, statusText, headers, stream, consumeSseStream }) {\n    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n    if (consumeSseStream) {\n        const [stream1, stream2] = sseStream.tee();\n        sseStream = stream1;\n        consumeSseStream({\n            stream: stream2\n        });\n    }\n    return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n        status,\n        statusText,\n        headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n    });\n}\n// src/ui-message-stream/get-response-ui-message-id.ts\nfunction getResponseUIMessageId({ originalMessages, responseMessageId }) {\n    if (originalMessages == null) {\n        return void 0;\n    }\n    const lastMessage = originalMessages[originalMessages.length - 1];\n    return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\n// src/ui/process-ui-message-stream.ts\n\n// src/ui-message-stream/ui-message-chunks.ts\n\n\nvar uiMessageChunkSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(()=>(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-start\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-delta\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text-end\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"error\"),\n            errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-start\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            providerMetadata: providerMetadataSchema.optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-delta\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            inputTextDelta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-available\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            providerMetadata: providerMetadataSchema.optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-input-error\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            providerMetadata: providerMetadataSchema.optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-approval-request\"),\n            approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-available\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-error\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n            dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-output-denied\"),\n            toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-start\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-delta\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning-end\"),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n            sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n            sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n            providerMetadata: providerMetadataSchema.optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.custom((value)=>typeof value === \"string\" && value.startsWith(\"data-\"), {\n                message: 'Type must start with \"data-\"'\n            }),\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n            transient: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start-step\")\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish-step\")\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"start\"),\n            messageId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n            messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"finish\"),\n            finishReason: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\n                \"stop\",\n                \"length\",\n                \"content-filter\",\n                \"tool-calls\",\n                \"error\",\n                \"other\"\n            ]).optional(),\n            messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"abort\"),\n            reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n        }),\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.strictObject({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"message-metadata\"),\n            messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n        })\n    ])));\nfunction isDataUIMessageChunk(chunk) {\n    return chunk.type.startsWith(\"data-\");\n}\n// src/ui/ui-messages.ts\nfunction isDataUIPart(part) {\n    return part.type.startsWith(\"data-\");\n}\nfunction isTextUIPart(part) {\n    return part.type === \"text\";\n}\nfunction isFileUIPart(part) {\n    return part.type === \"file\";\n}\nfunction isReasoningUIPart(part) {\n    return part.type === \"reasoning\";\n}\nfunction isStaticToolUIPart(part) {\n    return part.type.startsWith(\"tool-\");\n}\nfunction isDynamicToolUIPart(part) {\n    return part.type === \"dynamic-tool\";\n}\nfunction isToolUIPart(part) {\n    return isStaticToolUIPart(part) || isDynamicToolUIPart(part);\n}\nvar isToolOrDynamicToolUIPart = isToolUIPart;\nfunction getStaticToolName(part) {\n    return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction getToolName(part) {\n    return isDynamicToolUIPart(part) ? part.toolName : getStaticToolName(part);\n}\nvar getToolOrDynamicToolName = getToolName;\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({ lastMessage, messageId }) {\n    return {\n        message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n            id: messageId,\n            metadata: void 0,\n            role: \"assistant\",\n            parts: []\n        },\n        activeTextParts: {},\n        activeReasoningParts: {},\n        partialToolCalls: {}\n    };\n}\nfunction processUIMessageStream({ stream, messageMetadataSchema, dataPartSchemas, runUpdateMessageJob, onError, onToolCall, onData }) {\n    return stream.pipeThrough(new TransformStream({\n        async transform (chunk, controller) {\n            await runUpdateMessageJob(async ({ state, write })=>{\n                var _a17, _b, _c, _d;\n                function getToolInvocation(toolCallId) {\n                    const toolInvocations = state.message.parts.filter(isToolUIPart);\n                    const toolInvocation = toolInvocations.find((invocation)=>invocation.toolCallId === toolCallId);\n                    if (toolInvocation == null) {\n                        throw new UIMessageStreamError({\n                            chunkType: \"tool-invocation\",\n                            chunkId: toolCallId,\n                            message: `No tool invocation found for tool call ID \"${toolCallId}\".`\n                        });\n                    }\n                    return toolInvocation;\n                }\n                function updateToolPart(options) {\n                    var _a18;\n                    const part = state.message.parts.find((part2)=>isStaticToolUIPart(part2) && part2.toolCallId === options.toolCallId);\n                    const anyOptions = options;\n                    const anyPart = part;\n                    if (part != null) {\n                        part.state = options.state;\n                        anyPart.input = anyOptions.input;\n                        anyPart.output = anyOptions.output;\n                        anyPart.errorText = anyOptions.errorText;\n                        anyPart.rawInput = anyOptions.rawInput;\n                        anyPart.preliminary = anyOptions.preliminary;\n                        if (options.title !== void 0) {\n                            anyPart.title = options.title;\n                        }\n                        anyPart.providerExecuted = (_a18 = anyOptions.providerExecuted) != null ? _a18 : part.providerExecuted;\n                        if (anyOptions.providerMetadata != null) {\n                            part.callProviderMetadata = anyOptions.providerMetadata;\n                        }\n                    } else {\n                        state.message.parts.push({\n                            type: `tool-${options.toolName}`,\n                            toolCallId: options.toolCallId,\n                            state: options.state,\n                            title: options.title,\n                            input: anyOptions.input,\n                            output: anyOptions.output,\n                            rawInput: anyOptions.rawInput,\n                            errorText: anyOptions.errorText,\n                            providerExecuted: anyOptions.providerExecuted,\n                            preliminary: anyOptions.preliminary,\n                            ...anyOptions.providerMetadata != null ? {\n                                callProviderMetadata: anyOptions.providerMetadata\n                            } : {}\n                        });\n                    }\n                }\n                function updateDynamicToolPart(options) {\n                    var _a18, _b2;\n                    const part = state.message.parts.find((part2)=>part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId);\n                    const anyOptions = options;\n                    const anyPart = part;\n                    if (part != null) {\n                        part.state = options.state;\n                        anyPart.toolName = options.toolName;\n                        anyPart.input = anyOptions.input;\n                        anyPart.output = anyOptions.output;\n                        anyPart.errorText = anyOptions.errorText;\n                        anyPart.rawInput = (_a18 = anyOptions.rawInput) != null ? _a18 : anyPart.rawInput;\n                        anyPart.preliminary = anyOptions.preliminary;\n                        if (options.title !== void 0) {\n                            anyPart.title = options.title;\n                        }\n                        anyPart.providerExecuted = (_b2 = anyOptions.providerExecuted) != null ? _b2 : part.providerExecuted;\n                        if (anyOptions.providerMetadata != null) {\n                            part.callProviderMetadata = anyOptions.providerMetadata;\n                        }\n                    } else {\n                        state.message.parts.push({\n                            type: \"dynamic-tool\",\n                            toolName: options.toolName,\n                            toolCallId: options.toolCallId,\n                            state: options.state,\n                            input: anyOptions.input,\n                            output: anyOptions.output,\n                            errorText: anyOptions.errorText,\n                            preliminary: anyOptions.preliminary,\n                            providerExecuted: anyOptions.providerExecuted,\n                            title: options.title,\n                            ...anyOptions.providerMetadata != null ? {\n                                callProviderMetadata: anyOptions.providerMetadata\n                            } : {}\n                        });\n                    }\n                }\n                async function updateMessageMetadata(metadata) {\n                    if (metadata != null) {\n                        const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n                        if (messageMetadataSchema != null) {\n                            await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                                value: mergedMetadata,\n                                schema: messageMetadataSchema\n                            });\n                        }\n                        state.message.metadata = mergedMetadata;\n                    }\n                }\n                switch(chunk.type){\n                    case \"text-start\":\n                        {\n                            const textPart = {\n                                type: \"text\",\n                                text: \"\",\n                                providerMetadata: chunk.providerMetadata,\n                                state: \"streaming\"\n                            };\n                            state.activeTextParts[chunk.id] = textPart;\n                            state.message.parts.push(textPart);\n                            write();\n                            break;\n                        }\n                    case \"text-delta\":\n                        {\n                            const textPart = state.activeTextParts[chunk.id];\n                            if (textPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"text-delta\",\n                                    chunkId: chunk.id,\n                                    message: `Received text-delta for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-delta\" chunks.`\n                                });\n                            }\n                            textPart.text += chunk.delta;\n                            textPart.providerMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textPart.providerMetadata;\n                            write();\n                            break;\n                        }\n                    case \"text-end\":\n                        {\n                            const textPart = state.activeTextParts[chunk.id];\n                            if (textPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"text-end\",\n                                    chunkId: chunk.id,\n                                    message: `Received text-end for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-end\" chunks.`\n                                });\n                            }\n                            textPart.state = \"done\";\n                            textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n                            delete state.activeTextParts[chunk.id];\n                            write();\n                            break;\n                        }\n                    case \"reasoning-start\":\n                        {\n                            const reasoningPart = {\n                                type: \"reasoning\",\n                                text: \"\",\n                                providerMetadata: chunk.providerMetadata,\n                                state: \"streaming\"\n                            };\n                            state.activeReasoningParts[chunk.id] = reasoningPart;\n                            state.message.parts.push(reasoningPart);\n                            write();\n                            break;\n                        }\n                    case \"reasoning-delta\":\n                        {\n                            const reasoningPart = state.activeReasoningParts[chunk.id];\n                            if (reasoningPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"reasoning-delta\",\n                                    chunkId: chunk.id,\n                                    message: `Received reasoning-delta for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-delta\" chunks.`\n                                });\n                            }\n                            reasoningPart.text += chunk.delta;\n                            reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n                            write();\n                            break;\n                        }\n                    case \"reasoning-end\":\n                        {\n                            const reasoningPart = state.activeReasoningParts[chunk.id];\n                            if (reasoningPart == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"reasoning-end\",\n                                    chunkId: chunk.id,\n                                    message: `Received reasoning-end for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-end\" chunks.`\n                                });\n                            }\n                            reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n                            reasoningPart.state = \"done\";\n                            delete state.activeReasoningParts[chunk.id];\n                            write();\n                            break;\n                        }\n                    case \"file\":\n                        {\n                            state.message.parts.push({\n                                type: \"file\",\n                                mediaType: chunk.mediaType,\n                                url: chunk.url\n                            });\n                            write();\n                            break;\n                        }\n                    case \"source-url\":\n                        {\n                            state.message.parts.push({\n                                type: \"source-url\",\n                                sourceId: chunk.sourceId,\n                                url: chunk.url,\n                                title: chunk.title,\n                                providerMetadata: chunk.providerMetadata\n                            });\n                            write();\n                            break;\n                        }\n                    case \"source-document\":\n                        {\n                            state.message.parts.push({\n                                type: \"source-document\",\n                                sourceId: chunk.sourceId,\n                                mediaType: chunk.mediaType,\n                                title: chunk.title,\n                                filename: chunk.filename,\n                                providerMetadata: chunk.providerMetadata\n                            });\n                            write();\n                            break;\n                        }\n                    case \"tool-input-start\":\n                        {\n                            const toolInvocations = state.message.parts.filter(isStaticToolUIPart);\n                            state.partialToolCalls[chunk.toolCallId] = {\n                                text: \"\",\n                                toolName: chunk.toolName,\n                                index: toolInvocations.length,\n                                dynamic: chunk.dynamic,\n                                title: chunk.title\n                            };\n                            if (chunk.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-streaming\",\n                                    input: void 0,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: chunk.title,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-streaming\",\n                                    input: void 0,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: chunk.title,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-input-delta\":\n                        {\n                            const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n                            if (partialToolCall == null) {\n                                throw new UIMessageStreamError({\n                                    chunkType: \"tool-input-delta\",\n                                    chunkId: chunk.toolCallId,\n                                    message: `Received tool-input-delta for missing tool call with ID \"${chunk.toolCallId}\". Ensure a \"tool-input-start\" chunk is sent before any \"tool-input-delta\" chunks.`\n                                });\n                            }\n                            partialToolCall.text += chunk.inputTextDelta;\n                            const { value: partialArgs } = await parsePartialJson(partialToolCall.text);\n                            if (partialToolCall.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: partialToolCall.toolName,\n                                    state: \"input-streaming\",\n                                    input: partialArgs,\n                                    title: partialToolCall.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: partialToolCall.toolName,\n                                    state: \"input-streaming\",\n                                    input: partialArgs,\n                                    title: partialToolCall.title\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-input-available\":\n                        {\n                            if (chunk.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-available\",\n                                    input: chunk.input,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata,\n                                    title: chunk.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"input-available\",\n                                    input: chunk.input,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata,\n                                    title: chunk.title\n                                });\n                            }\n                            write();\n                            if (onToolCall && !chunk.providerExecuted) {\n                                await onToolCall({\n                                    toolCall: chunk\n                                });\n                            }\n                            break;\n                        }\n                    case \"tool-input-error\":\n                        {\n                            if (chunk.dynamic) {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"output-error\",\n                                    input: chunk.input,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName,\n                                    state: \"output-error\",\n                                    input: void 0,\n                                    rawInput: chunk.input,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    providerMetadata: chunk.providerMetadata\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-approval-request\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            toolInvocation.state = \"approval-requested\";\n                            toolInvocation.approval = {\n                                id: chunk.approvalId\n                            };\n                            write();\n                            break;\n                        }\n                    case \"tool-output-denied\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            toolInvocation.state = \"output-denied\";\n                            write();\n                            break;\n                        }\n                    case \"tool-output-available\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            if (toolInvocation.type === \"dynamic-tool\") {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: toolInvocation.toolName,\n                                    state: \"output-available\",\n                                    input: toolInvocation.input,\n                                    output: chunk.output,\n                                    preliminary: chunk.preliminary,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: toolInvocation.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: getStaticToolName(toolInvocation),\n                                    state: \"output-available\",\n                                    input: toolInvocation.input,\n                                    output: chunk.output,\n                                    providerExecuted: chunk.providerExecuted,\n                                    preliminary: chunk.preliminary,\n                                    title: toolInvocation.title\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"tool-output-error\":\n                        {\n                            const toolInvocation = getToolInvocation(chunk.toolCallId);\n                            if (toolInvocation.type === \"dynamic-tool\") {\n                                updateDynamicToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: toolInvocation.toolName,\n                                    state: \"output-error\",\n                                    input: toolInvocation.input,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: toolInvocation.title\n                                });\n                            } else {\n                                updateToolPart({\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: getStaticToolName(toolInvocation),\n                                    state: \"output-error\",\n                                    input: toolInvocation.input,\n                                    rawInput: toolInvocation.rawInput,\n                                    errorText: chunk.errorText,\n                                    providerExecuted: chunk.providerExecuted,\n                                    title: toolInvocation.title\n                                });\n                            }\n                            write();\n                            break;\n                        }\n                    case \"start-step\":\n                        {\n                            state.message.parts.push({\n                                type: \"step-start\"\n                            });\n                            break;\n                        }\n                    case \"finish-step\":\n                        {\n                            state.activeTextParts = {};\n                            state.activeReasoningParts = {};\n                            break;\n                        }\n                    case \"start\":\n                        {\n                            if (chunk.messageId != null) {\n                                state.message.id = chunk.messageId;\n                            }\n                            await updateMessageMetadata(chunk.messageMetadata);\n                            if (chunk.messageId != null || chunk.messageMetadata != null) {\n                                write();\n                            }\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (chunk.finishReason != null) {\n                                state.finishReason = chunk.finishReason;\n                            }\n                            await updateMessageMetadata(chunk.messageMetadata);\n                            if (chunk.messageMetadata != null) {\n                                write();\n                            }\n                            break;\n                        }\n                    case \"message-metadata\":\n                        {\n                            await updateMessageMetadata(chunk.messageMetadata);\n                            if (chunk.messageMetadata != null) {\n                                write();\n                            }\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            onError == null ? void 0 : onError(new Error(chunk.errorText));\n                            break;\n                        }\n                    default:\n                        {\n                            if (isDataUIMessageChunk(chunk)) {\n                                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                                    await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                                        value: chunk.data,\n                                        schema: dataPartSchemas[chunk.type]\n                                    });\n                                }\n                                const dataChunk = chunk;\n                                if (dataChunk.transient) {\n                                    onData == null ? void 0 : onData(dataChunk);\n                                    break;\n                                }\n                                const existingUIPart = dataChunk.id != null ? state.message.parts.find((chunkArg)=>dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id) : void 0;\n                                if (existingUIPart != null) {\n                                    existingUIPart.data = dataChunk.data;\n                                } else {\n                                    state.message.parts.push(dataChunk);\n                                }\n                                onData == null ? void 0 : onData(dataChunk);\n                                write();\n                            }\n                        }\n                }\n                controller.enqueue(chunk);\n            });\n        }\n    }));\n}\n// src/ui-message-stream/handle-ui-message-stream-finish.ts\nfunction handleUIMessageStreamFinish({ messageId, originalMessages = [], onFinish, onError, stream }) {\n    let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n    if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n        lastMessage = void 0;\n    } else {\n        messageId = lastMessage.id;\n    }\n    let isAborted = false;\n    const idInjectedStream = stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk.type === \"start\") {\n                const startChunk = chunk;\n                if (startChunk.messageId == null && messageId != null) {\n                    startChunk.messageId = messageId;\n                }\n            }\n            if (chunk.type === \"abort\") {\n                isAborted = true;\n            }\n            controller.enqueue(chunk);\n        }\n    }));\n    if (onFinish == null) {\n        return idInjectedStream;\n    }\n    const state = createStreamingUIMessageState({\n        lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n        messageId: messageId != null ? messageId : \"\"\n    });\n    const runUpdateMessageJob = async (job)=>{\n        await job({\n            state,\n            write: ()=>{}\n        });\n    };\n    let finishCalled = false;\n    const callOnFinish = async ()=>{\n        if (finishCalled || !onFinish) {\n            return;\n        }\n        finishCalled = true;\n        const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n        await onFinish({\n            isAborted,\n            isContinuation,\n            responseMessage: state.message,\n            messages: [\n                ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n                state.message\n            ],\n            finishReason: state.finishReason\n        });\n    };\n    return processUIMessageStream({\n        stream: idInjectedStream,\n        runUpdateMessageJob,\n        onError\n    }).pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(chunk);\n        },\n        // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n        async cancel () {\n            await callOnFinish();\n        },\n        async flush () {\n            await callOnFinish();\n        }\n    }));\n}\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({ response, status, statusText, headers, stream, consumeSseStream }) {\n    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n    if (consumeSseStream) {\n        const [stream1, stream2] = sseStream.tee();\n        sseStream = stream1;\n        consumeSseStream({\n            stream: stream2\n        });\n    }\n    writeToServerResponse({\n        response,\n        status,\n        statusText,\n        headers: Object.fromEntries(prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()),\n        stream: sseStream.pipeThrough(new TextEncoderStream())\n    });\n}\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n    const stream = source.pipeThrough(new TransformStream());\n    stream[Symbol.asyncIterator] = function() {\n        const reader = this.getReader();\n        let finished = false;\n        async function cleanup(cancelStream) {\n            var _a17;\n            if (finished) return;\n            finished = true;\n            try {\n                if (cancelStream) {\n                    await ((_a17 = reader.cancel) == null ? void 0 : _a17.call(reader));\n                }\n            } finally{\n                try {\n                    reader.releaseLock();\n                } catch (e) {}\n            }\n        }\n        return {\n            /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */ async next () {\n                if (finished) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const { done, value } = await reader.read();\n                if (done) {\n                    await cleanup(true);\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                return {\n                    done: false,\n                    value\n                };\n            },\n            /**\n       * May be called on early exit (e.g., break from for-await) or after completion.\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */ async return () {\n                await cleanup(true);\n                return {\n                    done: true,\n                    value: void 0\n                };\n            },\n            /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */ async throw (err) {\n                await cleanup(true);\n                throw err;\n            }\n        };\n    };\n    return stream;\n}\n// src/util/consume-stream.ts\nasync function consumeStream({ stream, onError }) {\n    const reader = stream.getReader();\n    try {\n        while(true){\n            const { done } = await reader.read();\n            if (done) break;\n        }\n    } catch (error) {\n        onError == null ? void 0 : onError(error);\n    } finally{\n        reader.releaseLock();\n    }\n}\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve3;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve3 = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve: resolve3,\n        reject\n    };\n}\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n    let innerStreamReaders = [];\n    let controller = null;\n    let isClosed = false;\n    let waitForNewStream = createResolvablePromise();\n    const terminate = ()=>{\n        isClosed = true;\n        waitForNewStream.resolve();\n        innerStreamReaders.forEach((reader)=>reader.cancel());\n        innerStreamReaders = [];\n        controller == null ? void 0 : controller.close();\n    };\n    const processPull = async ()=>{\n        if (isClosed && innerStreamReaders.length === 0) {\n            controller == null ? void 0 : controller.close();\n            return;\n        }\n        if (innerStreamReaders.length === 0) {\n            waitForNewStream = createResolvablePromise();\n            await waitForNewStream.promise;\n            return processPull();\n        }\n        try {\n            const { value, done } = await innerStreamReaders[0].read();\n            if (done) {\n                innerStreamReaders.shift();\n                if (innerStreamReaders.length === 0 && isClosed) {\n                    controller == null ? void 0 : controller.close();\n                } else {\n                    await processPull();\n                }\n            } else {\n                controller == null ? void 0 : controller.enqueue(value);\n            }\n        } catch (error) {\n            controller == null ? void 0 : controller.error(error);\n            innerStreamReaders.shift();\n            terminate();\n        }\n    };\n    return {\n        stream: new ReadableStream({\n            start (controllerParam) {\n                controller = controllerParam;\n            },\n            pull: processPull,\n            async cancel () {\n                for (const reader of innerStreamReaders){\n                    await reader.cancel();\n                }\n                innerStreamReaders = [];\n                isClosed = true;\n            }\n        }),\n        addStream: (innerStream)=>{\n            if (isClosed) {\n                throw new Error(\"Cannot add inner stream: outer stream is closed\");\n            }\n            innerStreamReaders.push(innerStream.getReader());\n            waitForNewStream.resolve();\n        },\n        /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */ close: ()=>{\n            isClosed = true;\n            waitForNewStream.resolve();\n            if (innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        },\n        /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */ terminate\n    };\n}\n// src/util/now.ts\nfunction now() {\n    var _a17, _b;\n    return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();\n}\n// src/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({ tools, generatorStream, tracer, telemetry, system, messages, abortSignal, repairToolCall, experimental_context, generateId: generateId2 }) {\n    let toolResultsStreamController = null;\n    const toolResultsStream = new ReadableStream({\n        start (controller) {\n            toolResultsStreamController = controller;\n        }\n    });\n    const outstandingToolResults = /* @__PURE__ */ new Set();\n    const toolInputs = /* @__PURE__ */ new Map();\n    const toolCallsByToolCallId = /* @__PURE__ */ new Map();\n    let canClose = false;\n    let finishChunk = void 0;\n    function attemptClose() {\n        if (canClose && outstandingToolResults.size === 0) {\n            if (finishChunk != null) {\n                toolResultsStreamController.enqueue(finishChunk);\n            }\n            toolResultsStreamController.close();\n        }\n    }\n    const forwardStream = new TransformStream({\n        async transform (chunk, controller) {\n            const chunkType = chunk.type;\n            switch(chunkType){\n                case \"stream-start\":\n                case \"text-start\":\n                case \"text-delta\":\n                case \"text-end\":\n                case \"reasoning-start\":\n                case \"reasoning-delta\":\n                case \"reasoning-end\":\n                case \"tool-input-start\":\n                case \"tool-input-delta\":\n                case \"tool-input-end\":\n                case \"source\":\n                case \"response-metadata\":\n                case \"error\":\n                case \"raw\":\n                    {\n                        controller.enqueue(chunk);\n                        break;\n                    }\n                case \"file\":\n                    {\n                        controller.enqueue({\n                            type: \"file\",\n                            file: new DefaultGeneratedFileWithType({\n                                data: chunk.data,\n                                mediaType: chunk.mediaType\n                            })\n                        });\n                        break;\n                    }\n                case \"finish\":\n                    {\n                        finishChunk = {\n                            type: \"finish\",\n                            finishReason: chunk.finishReason.unified,\n                            rawFinishReason: chunk.finishReason.raw,\n                            usage: asLanguageModelUsage(chunk.usage),\n                            providerMetadata: chunk.providerMetadata\n                        };\n                        break;\n                    }\n                case \"tool-approval-request\":\n                    {\n                        const toolCall = toolCallsByToolCallId.get(chunk.toolCallId);\n                        if (toolCall == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new ToolCallNotFoundForApprovalError({\n                                    toolCallId: chunk.toolCallId,\n                                    approvalId: chunk.approvalId\n                                })\n                            });\n                            break;\n                        }\n                        controller.enqueue({\n                            type: \"tool-approval-request\",\n                            approvalId: chunk.approvalId,\n                            toolCall\n                        });\n                        break;\n                    }\n                case \"tool-call\":\n                    {\n                        try {\n                            const toolCall = await parseToolCall({\n                                toolCall: chunk,\n                                tools,\n                                repairToolCall,\n                                system,\n                                messages\n                            });\n                            toolCallsByToolCallId.set(toolCall.toolCallId, toolCall);\n                            controller.enqueue(toolCall);\n                            if (toolCall.invalid) {\n                                toolResultsStreamController.enqueue({\n                                    type: \"tool-error\",\n                                    toolCallId: toolCall.toolCallId,\n                                    toolName: toolCall.toolName,\n                                    input: toolCall.input,\n                                    error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                                    dynamic: true,\n                                    title: toolCall.title\n                                });\n                                break;\n                            }\n                            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                            if (tool2 == null) {\n                                break;\n                            }\n                            if (tool2.onInputAvailable != null) {\n                                await tool2.onInputAvailable({\n                                    input: toolCall.input,\n                                    toolCallId: toolCall.toolCallId,\n                                    messages,\n                                    abortSignal,\n                                    experimental_context\n                                });\n                            }\n                            if (await isApprovalNeeded({\n                                tool: tool2,\n                                toolCall,\n                                messages,\n                                experimental_context\n                            })) {\n                                toolResultsStreamController.enqueue({\n                                    type: \"tool-approval-request\",\n                                    approvalId: generateId2(),\n                                    toolCall\n                                });\n                                break;\n                            }\n                            toolInputs.set(toolCall.toolCallId, toolCall.input);\n                            if (tool2.execute != null && toolCall.providerExecuted !== true) {\n                                const toolExecutionId = generateId2();\n                                outstandingToolResults.add(toolExecutionId);\n                                executeToolCall({\n                                    toolCall,\n                                    tools,\n                                    tracer,\n                                    telemetry,\n                                    messages,\n                                    abortSignal,\n                                    experimental_context,\n                                    onPreliminaryToolResult: (result)=>{\n                                        toolResultsStreamController.enqueue(result);\n                                    }\n                                }).then((result)=>{\n                                    toolResultsStreamController.enqueue(result);\n                                }).catch((error)=>{\n                                    toolResultsStreamController.enqueue({\n                                        type: \"error\",\n                                        error\n                                    });\n                                }).finally(()=>{\n                                    outstandingToolResults.delete(toolExecutionId);\n                                    attemptClose();\n                                });\n                            }\n                        } catch (error) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error\n                            });\n                        }\n                        break;\n                    }\n                case \"tool-result\":\n                    {\n                        const toolName = chunk.toolName;\n                        if (chunk.isError) {\n                            toolResultsStreamController.enqueue({\n                                type: \"tool-error\",\n                                toolCallId: chunk.toolCallId,\n                                toolName,\n                                input: toolInputs.get(chunk.toolCallId),\n                                providerExecuted: true,\n                                error: chunk.result,\n                                dynamic: chunk.dynamic\n                            });\n                        } else {\n                            controller.enqueue({\n                                type: \"tool-result\",\n                                toolCallId: chunk.toolCallId,\n                                toolName,\n                                input: toolInputs.get(chunk.toolCallId),\n                                output: chunk.result,\n                                providerExecuted: true,\n                                dynamic: chunk.dynamic\n                            });\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = chunkType;\n                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        flush () {\n            canClose = true;\n            attemptClose();\n        }\n    });\n    return new ReadableStream({\n        async start (controller) {\n            return Promise.all([\n                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {}\n                })),\n                toolResultsStream.pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    }\n                }))\n            ]);\n        }\n    });\n}\n// src/generate-text/stream-text.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nfunction streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, timeout, headers, stopWhen = stepCountIs(1), experimental_output, output = experimental_output, experimental_telemetry: telemetry, prepareStep, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_repairToolCall: repairToolCall, experimental_transform: transform, experimental_download: download2, includeRawChunks = false, onChunk, onError = ({ error })=>{\n    console.error(error);\n}, onFinish, onAbort, onStepFinish, experimental_context, _internal: { now: now2 = now, generateId: generateId2 = originalGenerateId2 } = {}, ...settings }) {\n    const totalTimeoutMs = getTotalTimeoutMs(timeout);\n    const stepTimeoutMs = getStepTimeoutMs(timeout);\n    const chunkTimeoutMs = getChunkTimeoutMs(timeout);\n    const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n    const chunkAbortController = chunkTimeoutMs != null ? new AbortController() : void 0;\n    return new DefaultStreamTextResult({\n        model: resolveLanguageModel(model),\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal: mergeAbortSignals(abortSignal, totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0, stepAbortController == null ? void 0 : stepAbortController.signal, chunkAbortController == null ? void 0 : chunkAbortController.signal),\n        stepTimeoutMs,\n        stepAbortController,\n        chunkTimeoutMs,\n        chunkAbortController,\n        system,\n        prompt,\n        messages,\n        tools,\n        toolChoice,\n        transforms: asArray(transform),\n        activeTools,\n        repairToolCall,\n        stopConditions: asArray(stopWhen),\n        output,\n        providerOptions,\n        prepareStep,\n        includeRawChunks,\n        onChunk,\n        onError,\n        onFinish,\n        onAbort,\n        onStepFinish,\n        now: now2,\n        generateId: generateId2,\n        experimental_context,\n        download: download2\n    });\n}\nfunction createOutputTransformStream(output) {\n    let firstTextChunkId = void 0;\n    let text2 = \"\";\n    let textChunk = \"\";\n    let textProviderMetadata = void 0;\n    let lastPublishedJson = \"\";\n    function publishTextChunk({ controller, partialOutput = void 0 }) {\n        controller.enqueue({\n            part: {\n                type: \"text-delta\",\n                id: firstTextChunkId,\n                text: textChunk,\n                providerMetadata: textProviderMetadata\n            },\n            partialOutput\n        });\n        textChunk = \"\";\n    }\n    return new TransformStream({\n        async transform (chunk, controller) {\n            var _a17;\n            if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n                publishTextChunk({\n                    controller\n                });\n            }\n            if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            if (firstTextChunkId == null) {\n                firstTextChunkId = chunk.id;\n            } else if (chunk.id !== firstTextChunkId) {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            if (chunk.type === \"text-start\") {\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            if (chunk.type === \"text-end\") {\n                if (textChunk.length > 0) {\n                    publishTextChunk({\n                        controller\n                    });\n                }\n                controller.enqueue({\n                    part: chunk,\n                    partialOutput: void 0\n                });\n                return;\n            }\n            text2 += chunk.text;\n            textChunk += chunk.text;\n            textProviderMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textProviderMetadata;\n            const result = await output.parsePartialOutput({\n                text: text2\n            });\n            if (result !== void 0) {\n                const currentJson = JSON.stringify(result.partial);\n                if (currentJson !== lastPublishedJson) {\n                    publishTextChunk({\n                        controller,\n                        partialOutput: result.partial\n                    });\n                    lastPublishedJson = currentJson;\n                }\n            }\n        }\n    });\n}\nvar DefaultStreamTextResult = class {\n    constructor({ model, telemetry, headers, settings, maxRetries: maxRetriesArg, abortSignal, stepTimeoutMs, stepAbortController, chunkTimeoutMs, chunkAbortController, system, prompt, messages, tools, toolChoice, transforms, activeTools, repairToolCall, stopConditions, output, providerOptions, prepareStep, includeRawChunks, now: now2, generateId: generateId2, onChunk, onError, onFinish, onAbort, onStepFinish, experimental_context, download: download2 }){\n        this._totalUsage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._rawFinishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._steps = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this.outputSpecification = output;\n        this.includeRawChunks = includeRawChunks;\n        this.tools = tools;\n        let stepFinish;\n        let recordedContent = [];\n        const recordedResponseMessages = [];\n        let recordedFinishReason = void 0;\n        let recordedRawFinishReason = void 0;\n        let recordedTotalUsage = void 0;\n        let recordedRequest = {};\n        let recordedWarnings = [];\n        const recordedSteps = [];\n        const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n        let rootSpan;\n        let activeTextContent = {};\n        let activeReasoningContent = {};\n        const eventProcessor = new TransformStream({\n            async transform (chunk, controller) {\n                var _a17, _b, _c, _d;\n                controller.enqueue(chunk);\n                const { part } = chunk;\n                if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n                    await (onChunk == null ? void 0 : onChunk({\n                        chunk: part\n                    }));\n                }\n                if (part.type === \"error\") {\n                    await onError({\n                        error: wrapGatewayError(part.error)\n                    });\n                }\n                if (part.type === \"text-start\") {\n                    activeTextContent[part.id] = {\n                        type: \"text\",\n                        text: \"\",\n                        providerMetadata: part.providerMetadata\n                    };\n                    recordedContent.push(activeTextContent[part.id]);\n                }\n                if (part.type === \"text-delta\") {\n                    const activeText = activeTextContent[part.id];\n                    if (activeText == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `text part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeText.text += part.text;\n                    activeText.providerMetadata = (_a17 = part.providerMetadata) != null ? _a17 : activeText.providerMetadata;\n                }\n                if (part.type === \"text-end\") {\n                    const activeText = activeTextContent[part.id];\n                    if (activeText == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `text part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeText.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeText.providerMetadata;\n                    delete activeTextContent[part.id];\n                }\n                if (part.type === \"reasoning-start\") {\n                    activeReasoningContent[part.id] = {\n                        type: \"reasoning\",\n                        text: \"\",\n                        providerMetadata: part.providerMetadata\n                    };\n                    recordedContent.push(activeReasoningContent[part.id]);\n                }\n                if (part.type === \"reasoning-delta\") {\n                    const activeReasoning = activeReasoningContent[part.id];\n                    if (activeReasoning == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `reasoning part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeReasoning.text += part.text;\n                    activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n                }\n                if (part.type === \"reasoning-end\") {\n                    const activeReasoning = activeReasoningContent[part.id];\n                    if (activeReasoning == null) {\n                        controller.enqueue({\n                            part: {\n                                type: \"error\",\n                                error: `reasoning part ${part.id} not found`\n                            },\n                            partialOutput: void 0\n                        });\n                        return;\n                    }\n                    activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;\n                    delete activeReasoningContent[part.id];\n                }\n                if (part.type === \"file\") {\n                    recordedContent.push({\n                        type: \"file\",\n                        file: part.file\n                    });\n                }\n                if (part.type === \"source\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-call\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-result\" && !part.preliminary) {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-approval-request\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"tool-error\") {\n                    recordedContent.push(part);\n                }\n                if (part.type === \"start-step\") {\n                    recordedContent = [];\n                    activeReasoningContent = {};\n                    activeTextContent = {};\n                    recordedRequest = part.request;\n                    recordedWarnings = part.warnings;\n                }\n                if (part.type === \"finish-step\") {\n                    const stepMessages = await toResponseMessages({\n                        content: recordedContent,\n                        tools\n                    });\n                    const currentStepResult = new DefaultStepResult({\n                        content: recordedContent,\n                        finishReason: part.finishReason,\n                        rawFinishReason: part.rawFinishReason,\n                        usage: part.usage,\n                        warnings: recordedWarnings,\n                        request: recordedRequest,\n                        response: {\n                            ...part.response,\n                            messages: [\n                                ...recordedResponseMessages,\n                                ...stepMessages\n                            ]\n                        },\n                        providerMetadata: part.providerMetadata\n                    });\n                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    logWarnings({\n                        warnings: recordedWarnings,\n                        provider: model.provider,\n                        model: model.modelId\n                    });\n                    recordedSteps.push(currentStepResult);\n                    recordedResponseMessages.push(...stepMessages);\n                    stepFinish.resolve();\n                }\n                if (part.type === \"finish\") {\n                    recordedTotalUsage = part.totalUsage;\n                    recordedFinishReason = part.finishReason;\n                    recordedRawFinishReason = part.rawFinishReason;\n                }\n            },\n            async flush (controller) {\n                try {\n                    if (recordedSteps.length === 0) {\n                        const error = (abortSignal == null ? void 0 : abortSignal.aborted) ? abortSignal.reason : new NoOutputGeneratedError({\n                            message: \"No output generated. Check the stream for errors.\"\n                        });\n                        self._finishReason.reject(error);\n                        self._rawFinishReason.reject(error);\n                        self._totalUsage.reject(error);\n                        self._steps.reject(error);\n                        return;\n                    }\n                    const finishReason = recordedFinishReason != null ? recordedFinishReason : \"other\";\n                    const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : createNullLanguageModelUsage();\n                    self._finishReason.resolve(finishReason);\n                    self._rawFinishReason.resolve(recordedRawFinishReason);\n                    self._totalUsage.resolve(totalUsage);\n                    self._steps.resolve(recordedSteps);\n                    const finalStep = recordedSteps[recordedSteps.length - 1];\n                    await (onFinish == null ? void 0 : onFinish({\n                        finishReason: finalStep.finishReason,\n                        rawFinishReason: finalStep.rawFinishReason,\n                        totalUsage,\n                        usage: finalStep.usage,\n                        content: finalStep.content,\n                        text: finalStep.text,\n                        reasoningText: finalStep.reasoningText,\n                        reasoning: finalStep.reasoning,\n                        files: finalStep.files,\n                        sources: finalStep.sources,\n                        toolCalls: finalStep.toolCalls,\n                        staticToolCalls: finalStep.staticToolCalls,\n                        dynamicToolCalls: finalStep.dynamicToolCalls,\n                        toolResults: finalStep.toolResults,\n                        staticToolResults: finalStep.staticToolResults,\n                        dynamicToolResults: finalStep.dynamicToolResults,\n                        request: finalStep.request,\n                        response: finalStep.response,\n                        warnings: finalStep.warnings,\n                        providerMetadata: finalStep.providerMetadata,\n                        steps: recordedSteps,\n                        experimental_context\n                    }));\n                    rootSpan.setAttributes(await selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.response.finishReason\": finishReason,\n                            \"ai.response.text\": {\n                                output: ()=>finalStep.text\n                            },\n                            \"ai.response.toolCalls\": {\n                                output: ()=>{\n                                    var _a17;\n                                    return ((_a17 = finalStep.toolCalls) == null ? void 0 : _a17.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                                }\n                            },\n                            \"ai.response.providerMetadata\": JSON.stringify(finalStep.providerMetadata),\n                            \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                            \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                            \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                            \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                            \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n                        }\n                    }));\n                } catch (error) {\n                    controller.error(error);\n                } finally{\n                    rootSpan.end();\n                }\n            }\n        });\n        const stitchableStream = createStitchableStream();\n        this.addStream = stitchableStream.addStream;\n        this.closeStream = stitchableStream.close;\n        const reader = stitchableStream.stream.getReader();\n        let stream = new ReadableStream({\n            async start (controller) {\n                controller.enqueue({\n                    type: \"start\"\n                });\n            },\n            async pull (controller) {\n                function abort() {\n                    onAbort == null ? void 0 : onAbort({\n                        steps: recordedSteps\n                    });\n                    controller.enqueue({\n                        type: \"abort\",\n                        // The `reason` is usually of type DOMException, but it can also be of any type,\n                        // so we use getErrorMessage for serialization because it is already designed to accept values of the unknown type.\n                        // See: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason\n                        ...(abortSignal == null ? void 0 : abortSignal.reason) !== void 0 ? {\n                            reason: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(abortSignal.reason)\n                        } : {}\n                    });\n                    controller.close();\n                }\n                try {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        controller.close();\n                        return;\n                    }\n                    if (abortSignal == null ? void 0 : abortSignal.aborted) {\n                        abort();\n                        return;\n                    }\n                    controller.enqueue(value);\n                } catch (error) {\n                    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n                        abort();\n                    } else {\n                        controller.error(error);\n                    }\n                }\n            },\n            cancel (reason) {\n                return stitchableStream.stream.cancel(reason);\n            }\n        });\n        for (const transform of transforms){\n            stream = stream.pipeThrough(transform({\n                tools,\n                stopStream () {\n                    stitchableStream.terminate();\n                }\n            }));\n        }\n        this.baseStream = stream.pipeThrough(createOutputTransformStream(output != null ? output : text())).pipeThrough(eventProcessor);\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg,\n            abortSignal\n        });\n        const tracer = getTracer(telemetry);\n        const callSettings = prepareCallSettings(settings);\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...callSettings,\n                maxRetries\n            }\n        });\n        const self = this;\n        recordSpan({\n            name: \"ai.streamText\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamText\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    }\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpanArg)=>{\n                rootSpan = rootSpanArg;\n                const initialPrompt = await standardizePrompt({\n                    system,\n                    prompt,\n                    messages\n                });\n                const initialMessages = initialPrompt.messages;\n                const initialResponseMessages = [];\n                const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({\n                    messages: initialMessages\n                });\n                if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {\n                    const providerExecutedToolApprovals = [\n                        ...approvedToolApprovals,\n                        ...deniedToolApprovals\n                    ].filter((toolApproval)=>toolApproval.toolCall.providerExecuted);\n                    const localApprovedToolApprovals = approvedToolApprovals.filter((toolApproval)=>!toolApproval.toolCall.providerExecuted);\n                    const localDeniedToolApprovals = deniedToolApprovals.filter((toolApproval)=>!toolApproval.toolCall.providerExecuted);\n                    const deniedProviderExecutedToolApprovals = deniedToolApprovals.filter((toolApproval)=>toolApproval.toolCall.providerExecuted);\n                    let toolExecutionStepStreamController;\n                    const toolExecutionStepStream = new ReadableStream({\n                        start (controller) {\n                            toolExecutionStepStreamController = controller;\n                        }\n                    });\n                    self.addStream(toolExecutionStepStream);\n                    try {\n                        for (const toolApproval of [\n                            ...localDeniedToolApprovals,\n                            ...deniedProviderExecutedToolApprovals\n                        ]){\n                            toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue({\n                                type: \"tool-output-denied\",\n                                toolCallId: toolApproval.toolCall.toolCallId,\n                                toolName: toolApproval.toolCall.toolName\n                            });\n                        }\n                        const toolOutputs = [];\n                        await Promise.all(localApprovedToolApprovals.map(async (toolApproval)=>{\n                            const result = await executeToolCall({\n                                toolCall: toolApproval.toolCall,\n                                tools,\n                                tracer,\n                                telemetry,\n                                messages: initialMessages,\n                                abortSignal,\n                                experimental_context,\n                                onPreliminaryToolResult: (result2)=>{\n                                    toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result2);\n                                }\n                            });\n                            if (result != null) {\n                                toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result);\n                                toolOutputs.push(result);\n                            }\n                        }));\n                        if (providerExecutedToolApprovals.length > 0) {\n                            initialResponseMessages.push({\n                                role: \"tool\",\n                                content: providerExecutedToolApprovals.map((toolApproval)=>({\n                                        type: \"tool-approval-response\",\n                                        approvalId: toolApproval.approvalResponse.approvalId,\n                                        approved: toolApproval.approvalResponse.approved,\n                                        reason: toolApproval.approvalResponse.reason,\n                                        providerExecuted: true\n                                    }))\n                            });\n                        }\n                        if (toolOutputs.length > 0 || localDeniedToolApprovals.length > 0) {\n                            const localToolContent = [];\n                            for (const output2 of toolOutputs){\n                                localToolContent.push({\n                                    type: \"tool-result\",\n                                    toolCallId: output2.toolCallId,\n                                    toolName: output2.toolName,\n                                    output: await createToolModelOutput({\n                                        toolCallId: output2.toolCallId,\n                                        input: output2.input,\n                                        tool: tools == null ? void 0 : tools[output2.toolName],\n                                        output: output2.type === \"tool-result\" ? output2.output : output2.error,\n                                        errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n                                    })\n                                });\n                            }\n                            for (const toolApproval of localDeniedToolApprovals){\n                                localToolContent.push({\n                                    type: \"tool-result\",\n                                    toolCallId: toolApproval.toolCall.toolCallId,\n                                    toolName: toolApproval.toolCall.toolName,\n                                    output: {\n                                        type: \"execution-denied\",\n                                        reason: toolApproval.approvalResponse.reason\n                                    }\n                                });\n                            }\n                            initialResponseMessages.push({\n                                role: \"tool\",\n                                content: localToolContent\n                            });\n                        }\n                    } finally{\n                        toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.close();\n                    }\n                }\n                recordedResponseMessages.push(...initialResponseMessages);\n                async function streamStep({ currentStep, responseMessages, usage }) {\n                    var _a17, _b, _c, _d, _e, _f;\n                    const includeRawChunks2 = self.includeRawChunks;\n                    const stepTimeoutId = stepTimeoutMs != null ? setTimeout(()=>stepAbortController.abort(), stepTimeoutMs) : void 0;\n                    let chunkTimeoutId = void 0;\n                    function resetChunkTimeout() {\n                        if (chunkTimeoutMs != null) {\n                            if (chunkTimeoutId != null) {\n                                clearTimeout(chunkTimeoutId);\n                            }\n                            chunkTimeoutId = setTimeout(()=>chunkAbortController.abort(), chunkTimeoutMs);\n                        }\n                    }\n                    function clearChunkTimeout() {\n                        if (chunkTimeoutId != null) {\n                            clearTimeout(chunkTimeoutId);\n                            chunkTimeoutId = void 0;\n                        }\n                    }\n                    function clearStepTimeout() {\n                        if (stepTimeoutId != null) {\n                            clearTimeout(stepTimeoutId);\n                        }\n                    }\n                    stepFinish = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n                    const stepInputMessages = [\n                        ...initialMessages,\n                        ...responseMessages\n                    ];\n                    const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n                        model,\n                        steps: recordedSteps,\n                        stepNumber: recordedSteps.length,\n                        messages: stepInputMessages,\n                        experimental_context\n                    }));\n                    const stepModel = resolveLanguageModel((_a17 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a17 : model);\n                    const promptMessages = await convertToLanguageModelPrompt({\n                        prompt: {\n                            system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                            messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n                        },\n                        supportedUrls: await stepModel.supportedUrls,\n                        download: download2\n                    });\n                    const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n                        tools,\n                        toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n                        activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n                    });\n                    experimental_context = (_f = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _f : experimental_context;\n                    const stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions);\n                    const { result: { stream: stream2, response, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                            name: \"ai.streamText.doStream\",\n                            attributes: selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    ...assembleOperationName({\n                                        operationId: \"ai.streamText.doStream\",\n                                        telemetry\n                                    }),\n                                    ...baseTelemetryAttributes,\n                                    // model:\n                                    \"ai.model.provider\": stepModel.provider,\n                                    \"ai.model.id\": stepModel.modelId,\n                                    // prompt:\n                                    \"ai.prompt.messages\": {\n                                        input: ()=>stringifyForTelemetry(promptMessages)\n                                    },\n                                    \"ai.prompt.tools\": {\n                                        // convert the language model level tools:\n                                        input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))\n                                    },\n                                    \"ai.prompt.toolChoice\": {\n                                        input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                                    },\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.system\": stepModel.provider,\n                                    \"gen_ai.request.model\": stepModel.modelId,\n                                    \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                                    \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                                    \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                                    \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                                    \"gen_ai.request.temperature\": callSettings.temperature,\n                                    \"gen_ai.request.top_k\": callSettings.topK,\n                                    \"gen_ai.request.top_p\": callSettings.topP\n                                }\n                            }),\n                            tracer,\n                            endWhenDone: false,\n                            fn: async (doStreamSpan2)=>({\n                                    startTimestampMs: now2(),\n                                    // get before the call\n                                    doStreamSpan: doStreamSpan2,\n                                    result: await stepModel.doStream({\n                                        ...callSettings,\n                                        tools: stepTools,\n                                        toolChoice: stepToolChoice,\n                                        responseFormat: await (output == null ? void 0 : output.responseFormat),\n                                        prompt: promptMessages,\n                                        providerOptions: stepProviderOptions,\n                                        abortSignal,\n                                        headers,\n                                        includeRawChunks: includeRawChunks2\n                                    })\n                                })\n                        }));\n                    const streamWithToolResults = runToolsTransformation({\n                        tools,\n                        generatorStream: stream2,\n                        tracer,\n                        telemetry,\n                        system,\n                        messages: stepInputMessages,\n                        repairToolCall,\n                        abortSignal,\n                        experimental_context,\n                        generateId: generateId2\n                    });\n                    const stepRequest = request != null ? request : {};\n                    const stepToolCalls = [];\n                    const stepToolOutputs = [];\n                    let warnings;\n                    const activeToolCallToolNames = {};\n                    let stepFinishReason = \"other\";\n                    let stepRawFinishReason = void 0;\n                    let stepUsage = createNullLanguageModelUsage();\n                    let stepProviderMetadata;\n                    let stepFirstChunk = true;\n                    let stepResponse = {\n                        id: generateId2(),\n                        timestamp: /* @__PURE__ */ new Date(),\n                        modelId: model.modelId\n                    };\n                    let activeText = \"\";\n                    self.addStream(streamWithToolResults.pipeThrough(new TransformStream({\n                        async transform (chunk, controller) {\n                            var _a18, _b2, _c2, _d2, _e2;\n                            resetChunkTimeout();\n                            if (chunk.type === \"stream-start\") {\n                                warnings = chunk.warnings;\n                                return;\n                            }\n                            if (stepFirstChunk) {\n                                const msToFirstChunk = now2() - startTimestampMs;\n                                stepFirstChunk = false;\n                                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                                doStreamSpan.setAttributes({\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                                controller.enqueue({\n                                    type: \"start-step\",\n                                    request: stepRequest,\n                                    warnings: warnings != null ? warnings : []\n                                });\n                            }\n                            const chunkType = chunk.type;\n                            switch(chunkType){\n                                case \"tool-approval-request\":\n                                case \"text-start\":\n                                case \"text-end\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"text-delta\":\n                                    {\n                                        if (chunk.delta.length > 0) {\n                                            controller.enqueue({\n                                                type: \"text-delta\",\n                                                id: chunk.id,\n                                                text: chunk.delta,\n                                                providerMetadata: chunk.providerMetadata\n                                            });\n                                            activeText += chunk.delta;\n                                        }\n                                        break;\n                                    }\n                                case \"reasoning-start\":\n                                case \"reasoning-end\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"reasoning-delta\":\n                                    {\n                                        controller.enqueue({\n                                            type: \"reasoning-delta\",\n                                            id: chunk.id,\n                                            text: chunk.delta,\n                                            providerMetadata: chunk.providerMetadata\n                                        });\n                                        break;\n                                    }\n                                case \"tool-call\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolCalls.push(chunk);\n                                        break;\n                                    }\n                                case \"tool-result\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        if (!chunk.preliminary) {\n                                            stepToolOutputs.push(chunk);\n                                        }\n                                        break;\n                                    }\n                                case \"tool-error\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolOutputs.push(chunk);\n                                        break;\n                                    }\n                                case \"response-metadata\":\n                                    {\n                                        stepResponse = {\n                                            id: (_a18 = chunk.id) != null ? _a18 : stepResponse.id,\n                                            timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,\n                                            modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                                        };\n                                        break;\n                                    }\n                                case \"finish\":\n                                    {\n                                        stepUsage = chunk.usage;\n                                        stepFinishReason = chunk.finishReason;\n                                        stepRawFinishReason = chunk.rawFinishReason;\n                                        stepProviderMetadata = chunk.providerMetadata;\n                                        const msToFinish = now2() - startTimestampMs;\n                                        doStreamSpan.addEvent(\"ai.stream.finish\");\n                                        doStreamSpan.setAttributes({\n                                            \"ai.response.msToFinish\": msToFinish,\n                                            \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                                        });\n                                        break;\n                                    }\n                                case \"file\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"source\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"tool-input-start\":\n                                    {\n                                        activeToolCallToolNames[chunk.id] = chunk.toolName;\n                                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];\n                                        if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {\n                                            await tool2.onInputStart({\n                                                toolCallId: chunk.id,\n                                                messages: stepInputMessages,\n                                                abortSignal,\n                                                experimental_context\n                                            });\n                                        }\n                                        controller.enqueue({\n                                            ...chunk,\n                                            dynamic: (_e2 = chunk.dynamic) != null ? _e2 : (tool2 == null ? void 0 : tool2.type) === \"dynamic\",\n                                            title: tool2 == null ? void 0 : tool2.title\n                                        });\n                                        break;\n                                    }\n                                case \"tool-input-end\":\n                                    {\n                                        delete activeToolCallToolNames[chunk.id];\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"tool-input-delta\":\n                                    {\n                                        const toolName = activeToolCallToolNames[chunk.id];\n                                        const tool2 = tools == null ? void 0 : tools[toolName];\n                                        if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {\n                                            await tool2.onInputDelta({\n                                                inputTextDelta: chunk.delta,\n                                                toolCallId: chunk.id,\n                                                messages: stepInputMessages,\n                                                abortSignal,\n                                                experimental_context\n                                            });\n                                        }\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"error\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepFinishReason = \"error\";\n                                        break;\n                                    }\n                                case \"raw\":\n                                    {\n                                        if (includeRawChunks2) {\n                                            controller.enqueue(chunk);\n                                        }\n                                        break;\n                                    }\n                                default:\n                                    {\n                                        const exhaustiveCheck = chunkType;\n                                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                                    }\n                            }\n                        },\n                        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                        async flush (controller) {\n                            const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                            try {\n                                doStreamSpan.setAttributes(await selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        \"ai.response.finishReason\": stepFinishReason,\n                                        \"ai.response.text\": {\n                                            output: ()=>activeText\n                                        },\n                                        \"ai.response.toolCalls\": {\n                                            output: ()=>stepToolCallsJson\n                                        },\n                                        \"ai.response.id\": stepResponse.id,\n                                        \"ai.response.model\": stepResponse.modelId,\n                                        \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                                        \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                                        \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                                        \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                                        \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                                        \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                                        \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.response.finish_reasons\": [\n                                            stepFinishReason\n                                        ],\n                                        \"gen_ai.response.id\": stepResponse.id,\n                                        \"gen_ai.response.model\": stepResponse.modelId,\n                                        \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                                        \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                                    }\n                                }));\n                            } catch (error) {} finally{\n                                doStreamSpan.end();\n                            }\n                            controller.enqueue({\n                                type: \"finish-step\",\n                                finishReason: stepFinishReason,\n                                rawFinishReason: stepRawFinishReason,\n                                usage: stepUsage,\n                                providerMetadata: stepProviderMetadata,\n                                response: {\n                                    ...stepResponse,\n                                    headers: response == null ? void 0 : response.headers\n                                }\n                            });\n                            const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                            await stepFinish.promise;\n                            const clientToolCalls = stepToolCalls.filter((toolCall)=>toolCall.providerExecuted !== true);\n                            const clientToolOutputs = stepToolOutputs.filter((toolOutput)=>toolOutput.providerExecuted !== true);\n                            for (const toolCall of stepToolCalls){\n                                if (toolCall.providerExecuted !== true) continue;\n                                const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                                if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                                    const hasResultInStep = stepToolOutputs.some((output2)=>output2.type === \"tool-result\" && output2.toolCallId === toolCall.toolCallId);\n                                    if (!hasResultInStep) {\n                                        pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                                            toolName: toolCall.toolName\n                                        });\n                                    }\n                                }\n                            }\n                            for (const output2 of stepToolOutputs){\n                                if (output2.type === \"tool-result\") {\n                                    pendingDeferredToolCalls.delete(output2.toolCallId);\n                                }\n                            }\n                            clearStepTimeout();\n                            clearChunkTimeout();\n                            if (// Continue if:\n                            // 1. There are client tool calls that have all been executed, OR\n                            // 2. There are pending deferred results from provider-executed tools\n                            (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n                            !await isStopConditionMet({\n                                stopConditions,\n                                steps: recordedSteps\n                            })) {\n                                responseMessages.push(...await toResponseMessages({\n                                    content: // use transformed content to create the messages for the next step:\n                                    recordedSteps[recordedSteps.length - 1].content,\n                                    tools\n                                }));\n                                try {\n                                    await streamStep({\n                                        currentStep: currentStep + 1,\n                                        responseMessages,\n                                        usage: combinedUsage\n                                    });\n                                } catch (error) {\n                                    controller.enqueue({\n                                        type: \"error\",\n                                        error\n                                    });\n                                    self.closeStream();\n                                }\n                            } else {\n                                controller.enqueue({\n                                    type: \"finish\",\n                                    finishReason: stepFinishReason,\n                                    rawFinishReason: stepRawFinishReason,\n                                    totalUsage: combinedUsage\n                                });\n                                self.closeStream();\n                            }\n                        }\n                    })));\n                }\n                await streamStep({\n                    currentStep: 0,\n                    responseMessages: initialResponseMessages,\n                    usage: createNullLanguageModelUsage()\n                });\n            }\n        }).catch((error)=>{\n            self.addStream(new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"error\",\n                        error\n                    });\n                    controller.close();\n                }\n            }));\n            self.closeStream();\n        });\n    }\n    get steps() {\n        this.consumeStream();\n        return this._steps.promise;\n    }\n    get finalStep() {\n        return this.steps.then((steps)=>steps[steps.length - 1]);\n    }\n    get content() {\n        return this.finalStep.then((step)=>step.content);\n    }\n    get warnings() {\n        return this.finalStep.then((step)=>step.warnings);\n    }\n    get providerMetadata() {\n        return this.finalStep.then((step)=>step.providerMetadata);\n    }\n    get text() {\n        return this.finalStep.then((step)=>step.text);\n    }\n    get reasoningText() {\n        return this.finalStep.then((step)=>step.reasoningText);\n    }\n    get reasoning() {\n        return this.finalStep.then((step)=>step.reasoning);\n    }\n    get sources() {\n        return this.finalStep.then((step)=>step.sources);\n    }\n    get files() {\n        return this.finalStep.then((step)=>step.files);\n    }\n    get toolCalls() {\n        return this.finalStep.then((step)=>step.toolCalls);\n    }\n    get staticToolCalls() {\n        return this.finalStep.then((step)=>step.staticToolCalls);\n    }\n    get dynamicToolCalls() {\n        return this.finalStep.then((step)=>step.dynamicToolCalls);\n    }\n    get toolResults() {\n        return this.finalStep.then((step)=>step.toolResults);\n    }\n    get staticToolResults() {\n        return this.finalStep.then((step)=>step.staticToolResults);\n    }\n    get dynamicToolResults() {\n        return this.finalStep.then((step)=>step.dynamicToolResults);\n    }\n    get usage() {\n        return this.finalStep.then((step)=>step.usage);\n    }\n    get request() {\n        return this.finalStep.then((step)=>step.request);\n    }\n    get response() {\n        return this.finalStep.then((step)=>step.response);\n    }\n    get totalUsage() {\n        this.consumeStream();\n        return this._totalUsage.promise;\n    }\n    get finishReason() {\n        this.consumeStream();\n        return this._finishReason.promise;\n    }\n    get rawFinishReason() {\n        this.consumeStream();\n        return this._rawFinishReason.promise;\n    }\n    /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */ teeStream() {\n        const [stream1, stream2] = this.baseStream.tee();\n        this.baseStream = stream2;\n        return stream1;\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ part }, controller) {\n                if (part.type === \"text-delta\") {\n                    controller.enqueue(part.text);\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ part }, controller) {\n                controller.enqueue(part);\n            }\n        })));\n    }\n    async consumeStream(options) {\n        var _a17;\n        try {\n            await consumeStream({\n                stream: this.fullStream,\n                onError: options == null ? void 0 : options.onError\n            });\n        } catch (error) {\n            (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);\n        }\n    }\n    get experimental_partialOutputStream() {\n        return this.partialOutputStream;\n    }\n    get partialOutputStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform ({ partialOutput }, controller) {\n                if (partialOutput != null) {\n                    controller.enqueue(partialOutput);\n                }\n            }\n        })));\n    }\n    get elementStream() {\n        var _a17, _b, _c;\n        const transform = (_a17 = this.outputSpecification) == null ? void 0 : _a17.createElementStreamTransform();\n        if (transform == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: `element streams in ${(_c = (_b = this.outputSpecification) == null ? void 0 : _b.name) != null ? _c : \"text\"} mode`\n            });\n        }\n        return createAsyncIterableStream(this.teeStream().pipeThrough(transform));\n    }\n    get output() {\n        return this.finalStep.then((step)=>{\n            var _a17;\n            const output = (_a17 = this.outputSpecification) != null ? _a17 : text();\n            return output.parseCompleteOutput({\n                text: step.text\n            }, {\n                response: step.response,\n                usage: step.usage,\n                finishReason: step.finishReason\n            });\n        });\n    }\n    toUIMessageStream({ originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning = true, sendSources = false, sendStart = true, sendFinish = true, onError = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage } = {}) {\n        const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n            originalMessages,\n            responseMessageId: generateMessageId\n        }) : void 0;\n        const isDynamic = (part)=>{\n            var _a17;\n            const tool2 = (_a17 = this.tools) == null ? void 0 : _a17[part.toolName];\n            if (tool2 == null) {\n                return part.dynamic;\n            }\n            return (tool2 == null ? void 0 : tool2.type) === \"dynamic\" ? true : void 0;\n        };\n        const baseStream = this.fullStream.pipeThrough(new TransformStream({\n            transform: async (part, controller)=>{\n                const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({\n                    part\n                });\n                const partType = part.type;\n                switch(partType){\n                    case \"text-start\":\n                        {\n                            controller.enqueue({\n                                type: \"text-start\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"text-delta\":\n                        {\n                            controller.enqueue({\n                                type: \"text-delta\",\n                                id: part.id,\n                                delta: part.text,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"text-end\":\n                        {\n                            controller.enqueue({\n                                type: \"text-end\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"reasoning-start\":\n                        {\n                            controller.enqueue({\n                                type: \"reasoning-start\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"reasoning-delta\":\n                        {\n                            if (sendReasoning) {\n                                controller.enqueue({\n                                    type: \"reasoning-delta\",\n                                    id: part.id,\n                                    delta: part.text,\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"reasoning-end\":\n                        {\n                            controller.enqueue({\n                                type: \"reasoning-end\",\n                                id: part.id,\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"file\":\n                        {\n                            controller.enqueue({\n                                type: \"file\",\n                                mediaType: part.file.mediaType,\n                                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n                            });\n                            break;\n                        }\n                    case \"source\":\n                        {\n                            if (sendSources && part.sourceType === \"url\") {\n                                controller.enqueue({\n                                    type: \"source-url\",\n                                    sourceId: part.id,\n                                    url: part.url,\n                                    title: part.title,\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {}\n                                });\n                            }\n                            if (sendSources && part.sourceType === \"document\") {\n                                controller.enqueue({\n                                    type: \"source-document\",\n                                    sourceId: part.id,\n                                    mediaType: part.mediaType,\n                                    title: part.title,\n                                    filename: part.filename,\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"tool-input-start\":\n                        {\n                            const dynamic = isDynamic(part);\n                            controller.enqueue({\n                                type: \"tool-input-start\",\n                                toolCallId: part.id,\n                                toolName: part.toolName,\n                                ...part.providerExecuted != null ? {\n                                    providerExecuted: part.providerExecuted\n                                } : {},\n                                ...part.providerMetadata != null ? {\n                                    providerMetadata: part.providerMetadata\n                                } : {},\n                                ...dynamic != null ? {\n                                    dynamic\n                                } : {},\n                                ...part.title != null ? {\n                                    title: part.title\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"tool-input-delta\":\n                        {\n                            controller.enqueue({\n                                type: \"tool-input-delta\",\n                                toolCallId: part.id,\n                                inputTextDelta: part.delta\n                            });\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const dynamic = isDynamic(part);\n                            if (part.invalid) {\n                                controller.enqueue({\n                                    type: \"tool-input-error\",\n                                    toolCallId: part.toolCallId,\n                                    toolName: part.toolName,\n                                    input: part.input,\n                                    ...part.providerExecuted != null ? {\n                                        providerExecuted: part.providerExecuted\n                                    } : {},\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {},\n                                    ...dynamic != null ? {\n                                        dynamic\n                                    } : {},\n                                    errorText: onError(part.error),\n                                    ...part.title != null ? {\n                                        title: part.title\n                                    } : {}\n                                });\n                            } else {\n                                controller.enqueue({\n                                    type: \"tool-input-available\",\n                                    toolCallId: part.toolCallId,\n                                    toolName: part.toolName,\n                                    input: part.input,\n                                    ...part.providerExecuted != null ? {\n                                        providerExecuted: part.providerExecuted\n                                    } : {},\n                                    ...part.providerMetadata != null ? {\n                                        providerMetadata: part.providerMetadata\n                                    } : {},\n                                    ...dynamic != null ? {\n                                        dynamic\n                                    } : {},\n                                    ...part.title != null ? {\n                                        title: part.title\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"tool-approval-request\":\n                        {\n                            controller.enqueue({\n                                type: \"tool-approval-request\",\n                                approvalId: part.approvalId,\n                                toolCallId: part.toolCall.toolCallId\n                            });\n                            break;\n                        }\n                    case \"tool-result\":\n                        {\n                            const dynamic = isDynamic(part);\n                            controller.enqueue({\n                                type: \"tool-output-available\",\n                                toolCallId: part.toolCallId,\n                                output: part.output,\n                                ...part.providerExecuted != null ? {\n                                    providerExecuted: part.providerExecuted\n                                } : {},\n                                ...part.preliminary != null ? {\n                                    preliminary: part.preliminary\n                                } : {},\n                                ...dynamic != null ? {\n                                    dynamic\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"tool-error\":\n                        {\n                            const dynamic = isDynamic(part);\n                            controller.enqueue({\n                                type: \"tool-output-error\",\n                                toolCallId: part.toolCallId,\n                                errorText: onError(part.error),\n                                ...part.providerExecuted != null ? {\n                                    providerExecuted: part.providerExecuted\n                                } : {},\n                                ...dynamic != null ? {\n                                    dynamic\n                                } : {}\n                            });\n                            break;\n                        }\n                    case \"tool-output-denied\":\n                        {\n                            controller.enqueue({\n                                type: \"tool-output-denied\",\n                                toolCallId: part.toolCallId\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            controller.enqueue({\n                                type: \"error\",\n                                errorText: onError(part.error)\n                            });\n                            break;\n                        }\n                    case \"start-step\":\n                        {\n                            controller.enqueue({\n                                type: \"start-step\"\n                            });\n                            break;\n                        }\n                    case \"finish-step\":\n                        {\n                            controller.enqueue({\n                                type: \"finish-step\"\n                            });\n                            break;\n                        }\n                    case \"start\":\n                        {\n                            if (sendStart) {\n                                controller.enqueue({\n                                    type: \"start\",\n                                    ...messageMetadataValue != null ? {\n                                        messageMetadata: messageMetadataValue\n                                    } : {},\n                                    ...responseMessageId != null ? {\n                                        messageId: responseMessageId\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (sendFinish) {\n                                controller.enqueue({\n                                    type: \"finish\",\n                                    finishReason: part.finishReason,\n                                    ...messageMetadataValue != null ? {\n                                        messageMetadata: messageMetadataValue\n                                    } : {}\n                                });\n                            }\n                            break;\n                        }\n                    case \"abort\":\n                        {\n                            controller.enqueue(part);\n                            break;\n                        }\n                    case \"tool-input-end\":\n                        {\n                            break;\n                        }\n                    case \"raw\":\n                        {\n                            break;\n                        }\n                    default:\n                        {\n                            const exhaustiveCheck = partType;\n                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                        }\n                }\n                if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n                    controller.enqueue({\n                        type: \"message-metadata\",\n                        messageMetadata: messageMetadataValue\n                    });\n                }\n            }\n        }));\n        return createAsyncIterableStream(handleUIMessageStreamFinish({\n            stream: baseStream,\n            messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n            originalMessages,\n            onFinish,\n            onError\n        }));\n    }\n    pipeUIMessageStreamToResponse(response, { originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {\n        pipeUIMessageStreamToResponse({\n            response,\n            stream: this.toUIMessageStream({\n                originalMessages,\n                generateMessageId,\n                onFinish,\n                messageMetadata,\n                sendReasoning,\n                sendSources,\n                sendFinish,\n                sendStart,\n                onError\n            }),\n            ...init\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        pipeTextStreamToResponse({\n            response,\n            textStream: this.textStream,\n            ...init\n        });\n    }\n    toUIMessageStreamResponse({ originalMessages, generateMessageId, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {\n        return createUIMessageStreamResponse({\n            stream: this.toUIMessageStream({\n                originalMessages,\n                generateMessageId,\n                onFinish,\n                messageMetadata,\n                sendReasoning,\n                sendSources,\n                sendFinish,\n                sendStart,\n                onError\n            }),\n            ...init\n        });\n    }\n    toTextStreamResponse(init) {\n        return createTextStreamResponse({\n            textStream: this.textStream,\n            ...init\n        });\n    }\n};\n// src/agent/tool-loop-agent.ts\nvar ToolLoopAgent = class {\n    constructor(settings){\n        this.version = \"agent-v1\";\n        this.settings = settings;\n    }\n    /**\n   * The id of the agent.\n   */ get id() {\n        return this.settings.id;\n    }\n    /**\n   * The tools that the agent can use.\n   */ get tools() {\n        return this.settings.tools;\n    }\n    async prepareCall(options) {\n        var _a17, _b, _c, _d;\n        const baseCallArgs = {\n            ...this.settings,\n            stopWhen: (_a17 = this.settings.stopWhen) != null ? _a17 : stepCountIs(20),\n            ...options\n        };\n        const preparedCallArgs = (_d = await ((_c = (_b = this.settings).prepareCall) == null ? void 0 : _c.call(_b, baseCallArgs))) != null ? _d : baseCallArgs;\n        const { instructions, messages, prompt, ...callArgs } = preparedCallArgs;\n        return {\n            ...callArgs,\n            // restore prompt types\n            ...{\n                system: instructions,\n                messages,\n                prompt\n            }\n        };\n    }\n    /**\n   * Generates an output from the agent (non-streaming).\n   */ async generate({ abortSignal, timeout, ...options }) {\n        return generateText({\n            ...await this.prepareCall(options),\n            abortSignal,\n            timeout\n        });\n    }\n    /**\n   * Streams an output from the agent (streaming).\n   */ async stream({ abortSignal, timeout, experimental_transform, ...options }) {\n        return streamText({\n            ...await this.prepareCall(options),\n            abortSignal,\n            timeout,\n            experimental_transform\n        });\n    }\n};\n// src/ui-message-stream/create-ui-message-stream.ts\n\nfunction createUIMessageStream({ execute, onError = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage, originalMessages, onFinish, generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId }) {\n    let controller;\n    const ongoingStreamPromises = [];\n    const stream = new ReadableStream({\n        start (controllerArg) {\n            controller = controllerArg;\n        }\n    });\n    function safeEnqueue(data) {\n        try {\n            controller.enqueue(data);\n        } catch (error) {}\n    }\n    try {\n        const result = execute({\n            writer: {\n                write (part) {\n                    safeEnqueue(part);\n                },\n                merge (streamArg) {\n                    ongoingStreamPromises.push((async ()=>{\n                        const reader = streamArg.getReader();\n                        while(true){\n                            const { done, value } = await reader.read();\n                            if (done) break;\n                            safeEnqueue(value);\n                        }\n                    })().catch((error)=>{\n                        safeEnqueue({\n                            type: \"error\",\n                            errorText: onError(error)\n                        });\n                    }));\n                },\n                onError\n            }\n        });\n        if (result) {\n            ongoingStreamPromises.push(result.catch((error)=>{\n                safeEnqueue({\n                    type: \"error\",\n                    errorText: onError(error)\n                });\n            }));\n        }\n    } catch (error) {\n        safeEnqueue({\n            type: \"error\",\n            errorText: onError(error)\n        });\n    }\n    const waitForStreams = new Promise(async (resolve3)=>{\n        while(ongoingStreamPromises.length > 0){\n            await ongoingStreamPromises.shift();\n        }\n        resolve3();\n    });\n    waitForStreams.finally(()=>{\n        try {\n            controller.close();\n        } catch (error) {}\n    });\n    return handleUIMessageStreamFinish({\n        stream,\n        messageId: generateId2(),\n        originalMessages,\n        onFinish,\n        onError\n    });\n}\n// src/ui-message-stream/read-ui-message-stream.ts\nfunction readUIMessageStream({ message, stream, onError, terminateOnError = false }) {\n    var _a17;\n    let controller;\n    let hasErrored = false;\n    const outputStream = new ReadableStream({\n        start (controllerParam) {\n            controller = controllerParam;\n        }\n    });\n    const state = createStreamingUIMessageState({\n        messageId: (_a17 = message == null ? void 0 : message.id) != null ? _a17 : \"\",\n        lastMessage: message\n    });\n    const handleError = (error)=>{\n        onError == null ? void 0 : onError(error);\n        if (!hasErrored && terminateOnError) {\n            hasErrored = true;\n            controller == null ? void 0 : controller.error(error);\n        }\n    };\n    consumeStream({\n        stream: processUIMessageStream({\n            stream,\n            runUpdateMessageJob (job) {\n                return job({\n                    state,\n                    write: ()=>{\n                        controller == null ? void 0 : controller.enqueue(structuredClone(state.message));\n                    }\n                });\n            },\n            onError: handleError\n        }),\n        onError: handleError\n    }).finally(()=>{\n        if (!hasErrored) {\n            controller == null ? void 0 : controller.close();\n        }\n    });\n    return createAsyncIterableStream(outputStream);\n}\n// src/ui/convert-to-model-messages.ts\n\nasync function convertToModelMessages(messages, options) {\n    const modelMessages = [];\n    if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {\n        messages = messages.map((message)=>({\n                ...message,\n                parts: message.parts.filter((part)=>!isToolUIPart(part) || part.state !== \"input-streaming\" && part.state !== \"input-available\")\n            }));\n    }\n    for (const message of messages){\n        switch(message.role){\n            case \"system\":\n                {\n                    const textParts = message.parts.filter((part)=>part.type === \"text\");\n                    const providerMetadata = textParts.reduce((acc, part)=>{\n                        if (part.providerMetadata != null) {\n                            return {\n                                ...acc,\n                                ...part.providerMetadata\n                            };\n                        }\n                        return acc;\n                    }, {});\n                    modelMessages.push({\n                        role: \"system\",\n                        content: textParts.map((part)=>part.text).join(\"\"),\n                        ...Object.keys(providerMetadata).length > 0 ? {\n                            providerOptions: providerMetadata\n                        } : {}\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    modelMessages.push({\n                        role: \"user\",\n                        content: message.parts.map((part)=>{\n                            var _a17;\n                            if (isTextUIPart(part)) {\n                                return {\n                                    type: \"text\",\n                                    text: part.text,\n                                    ...part.providerMetadata != null ? {\n                                        providerOptions: part.providerMetadata\n                                    } : {}\n                                };\n                            }\n                            if (isFileUIPart(part)) {\n                                return {\n                                    type: \"file\",\n                                    mediaType: part.mediaType,\n                                    filename: part.filename,\n                                    data: part.url,\n                                    ...part.providerMetadata != null ? {\n                                        providerOptions: part.providerMetadata\n                                    } : {}\n                                };\n                            }\n                            if (isDataUIPart(part)) {\n                                return (_a17 = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _a17.call(options, part);\n                            }\n                        }).filter(_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isNonNullable)\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (message.parts != null) {\n                        let block = [];\n                        async function processBlock() {\n                            var _a17, _b, _c, _d, _e, _f;\n                            if (block.length === 0) {\n                                return;\n                            }\n                            const content = [];\n                            for (const part of block){\n                                if (isTextUIPart(part)) {\n                                    content.push({\n                                        type: \"text\",\n                                        text: part.text,\n                                        ...part.providerMetadata != null ? {\n                                            providerOptions: part.providerMetadata\n                                        } : {}\n                                    });\n                                } else if (isFileUIPart(part)) {\n                                    content.push({\n                                        type: \"file\",\n                                        mediaType: part.mediaType,\n                                        filename: part.filename,\n                                        data: part.url\n                                    });\n                                } else if (isReasoningUIPart(part)) {\n                                    content.push({\n                                        type: \"reasoning\",\n                                        text: part.text,\n                                        providerOptions: part.providerMetadata\n                                    });\n                                } else if (isToolUIPart(part)) {\n                                    const toolName = getToolName(part);\n                                    if (part.state !== \"input-streaming\") {\n                                        content.push({\n                                            type: \"tool-call\",\n                                            toolCallId: part.toolCallId,\n                                            toolName,\n                                            input: part.state === \"output-error\" ? (_a17 = part.input) != null ? _a17 : \"rawInput\" in part ? part.rawInput : void 0 : part.input,\n                                            providerExecuted: part.providerExecuted,\n                                            ...part.callProviderMetadata != null ? {\n                                                providerOptions: part.callProviderMetadata\n                                            } : {}\n                                        });\n                                        if (part.approval != null) {\n                                            content.push({\n                                                type: \"tool-approval-request\",\n                                                approvalId: part.approval.id,\n                                                toolCallId: part.toolCallId\n                                            });\n                                        }\n                                        if (part.providerExecuted === true && part.state !== \"approval-responded\" && (part.state === \"output-available\" || part.state === \"output-error\")) {\n                                            content.push({\n                                                type: \"tool-result\",\n                                                toolCallId: part.toolCallId,\n                                                toolName,\n                                                output: await createToolModelOutput({\n                                                    toolCallId: part.toolCallId,\n                                                    input: part.input,\n                                                    output: part.state === \"output-error\" ? part.errorText : part.output,\n                                                    tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],\n                                                    errorMode: part.state === \"output-error\" ? \"json\" : \"none\"\n                                                }),\n                                                ...part.callProviderMetadata != null ? {\n                                                    providerOptions: part.callProviderMetadata\n                                                } : {}\n                                            });\n                                        }\n                                    }\n                                } else if (isDataUIPart(part)) {\n                                    const dataPart = (_c = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _c.call(options, part);\n                                    if (dataPart != null) {\n                                        content.push(dataPart);\n                                    }\n                                } else {\n                                    const _exhaustiveCheck = part;\n                                    throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                                }\n                            }\n                            modelMessages.push({\n                                role: \"assistant\",\n                                content\n                            });\n                            const toolParts = block.filter((part)=>{\n                                var _a18;\n                                return isToolUIPart(part) && (part.providerExecuted !== true || ((_a18 = part.approval) == null ? void 0 : _a18.approved) != null);\n                            });\n                            if (toolParts.length > 0) {\n                                {\n                                    const content2 = [];\n                                    for (const toolPart of toolParts){\n                                        if (((_d = toolPart.approval) == null ? void 0 : _d.approved) != null) {\n                                            content2.push({\n                                                type: \"tool-approval-response\",\n                                                approvalId: toolPart.approval.id,\n                                                approved: toolPart.approval.approved,\n                                                reason: toolPart.approval.reason,\n                                                providerExecuted: toolPart.providerExecuted\n                                            });\n                                        }\n                                        if (toolPart.providerExecuted === true) {\n                                            continue;\n                                        }\n                                        switch(toolPart.state){\n                                            case \"output-denied\":\n                                                {\n                                                    content2.push({\n                                                        type: \"tool-result\",\n                                                        toolCallId: toolPart.toolCallId,\n                                                        toolName: getToolName(toolPart),\n                                                        output: {\n                                                            type: \"error-text\",\n                                                            value: (_e = toolPart.approval.reason) != null ? _e : \"Tool execution denied.\"\n                                                        },\n                                                        ...toolPart.callProviderMetadata != null ? {\n                                                            providerOptions: toolPart.callProviderMetadata\n                                                        } : {}\n                                                    });\n                                                    break;\n                                                }\n                                            case \"output-error\":\n                                            case \"output-available\":\n                                                {\n                                                    const toolName = getToolName(toolPart);\n                                                    content2.push({\n                                                        type: \"tool-result\",\n                                                        toolCallId: toolPart.toolCallId,\n                                                        toolName,\n                                                        output: await createToolModelOutput({\n                                                            toolCallId: toolPart.toolCallId,\n                                                            input: toolPart.input,\n                                                            output: toolPart.state === \"output-error\" ? toolPart.errorText : toolPart.output,\n                                                            tool: (_f = options == null ? void 0 : options.tools) == null ? void 0 : _f[toolName],\n                                                            errorMode: toolPart.state === \"output-error\" ? \"text\" : \"none\"\n                                                        }),\n                                                        ...toolPart.callProviderMetadata != null ? {\n                                                            providerOptions: toolPart.callProviderMetadata\n                                                        } : {}\n                                                    });\n                                                    break;\n                                                }\n                                        }\n                                    }\n                                    if (content2.length > 0) {\n                                        modelMessages.push({\n                                            role: \"tool\",\n                                            content: content2\n                                        });\n                                    }\n                                }\n                            }\n                            block = [];\n                        }\n                        for (const part of message.parts){\n                            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolUIPart(part) || isDataUIPart(part)) {\n                                block.push(part);\n                            } else if (part.type === \"step-start\") {\n                                await processBlock();\n                            }\n                        }\n                        await processBlock();\n                        break;\n                    }\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = message.role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return modelMessages;\n}\n// src/ui/validate-ui-messages.ts\n\n\n\nvar uiMessagesSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(()=>(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n        role: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\n            \"system\",\n            \"user\",\n            \"assistant\"\n        ]),\n        metadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n        parts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.union([\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n                text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\n                    \"streaming\",\n                    \"done\"\n                ]).optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"reasoning\"),\n                text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__[\"enum\"]([\n                    \"streaming\",\n                    \"done\"\n                ]).optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-url\"),\n                sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"source-document\"),\n                sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n                mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"step-start\")\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"data-\"),\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n                data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-requested\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-responded\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"dynamic-tool\"),\n                toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-denied\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(false),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-streaming\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"input-available\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-requested\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"approval-responded\"),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-available\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-error\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown().optional(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(true),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().startsWith(\"tool-\"),\n                toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(\"output-denied\"),\n                providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n                input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n                output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.never().optional(),\n                callProviderMetadata: providerMetadataSchema.optional(),\n                approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.object({\n                    id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string(),\n                    approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.literal(false),\n                    reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n                })\n            })\n        ])).nonempty(\"Message must contain at least one part\")\n    })).nonempty(\"Messages array must not be empty\")));\nasync function safeValidateUIMessages({ messages, metadataSchema, dataSchemas, tools }) {\n    try {\n        if (messages == null) {\n            return {\n                success: false,\n                error: new InvalidArgumentError({\n                    parameter: \"messages\",\n                    value: messages,\n                    message: \"messages parameter must be provided\"\n                })\n            };\n        }\n        const validatedMessages = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n            value: messages,\n            schema: uiMessagesSchema\n        });\n        if (metadataSchema) {\n            for (const message of validatedMessages){\n                await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                    value: message.metadata,\n                    schema: metadataSchema\n                });\n            }\n        }\n        if (dataSchemas) {\n            for (const message of validatedMessages){\n                const dataParts = message.parts.filter((part)=>part.type.startsWith(\"data-\"));\n                for (const dataPart of dataParts){\n                    const dataName = dataPart.type.slice(5);\n                    const dataSchema = dataSchemas[dataName];\n                    if (!dataSchema) {\n                        return {\n                            success: false,\n                            error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                                value: dataPart.data,\n                                cause: `No data schema found for data part ${dataName}`\n                            })\n                        };\n                    }\n                    await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                        value: dataPart.data,\n                        schema: dataSchema\n                    });\n                }\n            }\n        }\n        if (tools) {\n            for (const message of validatedMessages){\n                const toolParts = message.parts.filter((part)=>part.type.startsWith(\"tool-\"));\n                for (const toolPart of toolParts){\n                    const toolName = toolPart.type.slice(5);\n                    const tool2 = tools[toolName];\n                    if (!tool2) {\n                        return {\n                            success: false,\n                            error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                                value: toolPart.input,\n                                cause: `No tool schema found for tool part ${toolName}`\n                            })\n                        };\n                    }\n                    if (toolPart.state === \"input-available\" || toolPart.state === \"output-available\" || toolPart.state === \"output-error\" && toolPart.input !== void 0) {\n                        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                            value: toolPart.input,\n                            schema: tool2.inputSchema\n                        });\n                    }\n                    if (toolPart.state === \"output-available\" && tool2.outputSchema) {\n                        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                            value: toolPart.output,\n                            schema: tool2.outputSchema\n                        });\n                    }\n                }\n            }\n        }\n        return {\n            success: true,\n            data: validatedMessages\n        };\n    } catch (error) {\n        const err = error;\n        return {\n            success: false,\n            error: err\n        };\n    }\n}\nasync function validateUIMessages({ messages, metadataSchema, dataSchemas, tools }) {\n    const response = await safeValidateUIMessages({\n        messages,\n        metadataSchema,\n        dataSchemas,\n        tools\n    });\n    if (!response.success) throw response.error;\n    return response.data;\n}\n// src/agent/create-agent-ui-stream.ts\nasync function createAgentUIStream({ agent, uiMessages, options, abortSignal, timeout, experimental_transform, ...uiMessageStreamOptions }) {\n    const validatedMessages = await validateUIMessages({\n        messages: uiMessages,\n        tools: agent.tools\n    });\n    const modelMessages = await convertToModelMessages(validatedMessages, {\n        tools: agent.tools\n    });\n    const result = await agent.stream({\n        prompt: modelMessages,\n        options,\n        abortSignal,\n        timeout,\n        experimental_transform\n    });\n    return result.toUIMessageStream(uiMessageStreamOptions);\n}\n// src/agent/create-agent-ui-stream-response.ts\nasync function createAgentUIStreamResponse({ headers, status, statusText, consumeSseStream, ...options }) {\n    return createUIMessageStreamResponse({\n        headers,\n        status,\n        statusText,\n        consumeSseStream,\n        stream: await createAgentUIStream(options)\n    });\n}\n// src/agent/pipe-agent-ui-stream-to-response.ts\nasync function pipeAgentUIStreamToResponse({ response, headers, status, statusText, consumeSseStream, ...options }) {\n    pipeUIMessageStreamToResponse({\n        response,\n        headers,\n        status,\n        statusText,\n        consumeSseStream,\n        stream: await createAgentUIStream(options)\n    });\n}\n// src/embed/embed.ts\n\nasync function embed({ model: modelArg, value, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const model = resolveEmbeddingModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embed\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embed\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.value\": {\n                    input: ()=>JSON.stringify(value)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const { embedding, usage, warnings, response, providerMetadata } = await retry(()=>// nested spans to align with the embedMany telemetry data:\n                recordSpan({\n                    name: \"ai.embed.doEmbed\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.embed.doEmbed\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.values\": {\n                                input: ()=>[\n                                        JSON.stringify(value)\n                                    ]\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doEmbedSpan)=>{\n                        var _a17;\n                        const modelResponse = await model.doEmbed({\n                            values: [\n                                value\n                            ],\n                            abortSignal,\n                            headers: headersWithUserAgent,\n                            providerOptions\n                        });\n                        const embedding2 = modelResponse.embeddings[0];\n                        const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : {\n                            tokens: NaN\n                        };\n                        doEmbedSpan.setAttributes(await selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.embeddings\": {\n                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))\n                                },\n                                \"ai.usage.tokens\": usage2.tokens\n                            }\n                        }));\n                        return {\n                            embedding: embedding2,\n                            usage: usage2,\n                            warnings: modelResponse.warnings,\n                            providerMetadata: modelResponse.providerMetadata,\n                            response: modelResponse.response\n                        };\n                    }\n                }));\n            span.setAttributes(await selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embedding\": {\n                        output: ()=>JSON.stringify(embedding)\n                    },\n                    \"ai.usage.tokens\": usage.tokens\n                }\n            }));\n            logWarnings({\n                warnings,\n                provider: model.provider,\n                model: model.modelId\n            });\n            return new DefaultEmbedResult({\n                value,\n                embedding,\n                usage,\n                warnings,\n                providerMetadata,\n                response\n            });\n        }\n    });\n}\nvar DefaultEmbedResult = class {\n    constructor(options){\n        this.value = options.value;\n        this.embedding = options.embedding;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.providerMetadata = options.providerMetadata;\n        this.response = options.response;\n    }\n};\n// src/embed/embed-many.ts\n\n// src/util/split-array.ts\nfunction splitArray(array2, chunkSize) {\n    if (chunkSize <= 0) {\n        throw new Error(\"chunkSize must be greater than 0\");\n    }\n    const result = [];\n    for(let i = 0; i < array2.length; i += chunkSize){\n        result.push(array2.slice(i, i + chunkSize));\n    }\n    return result;\n}\n// src/embed/embed-many.ts\nasync function embedMany({ model: modelArg, values, maxParallelCalls = Infinity, maxRetries: maxRetriesArg, abortSignal, headers, providerOptions, experimental_telemetry: telemetry }) {\n    const model = resolveEmbeddingModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embedMany\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embedMany\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                    input: ()=>values.map((value)=>JSON.stringify(value))\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a17;\n            const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n                model.maxEmbeddingsPerCall,\n                model.supportsParallelCalls\n            ]);\n            if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n                const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>values.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a18;\n                            const modelResponse = await model.doEmbed({\n                                values,\n                                abortSignal,\n                                headers: headersWithUserAgent,\n                                providerOptions\n                            });\n                            const embeddings3 = modelResponse.embeddings;\n                            const usage2 = (_a18 = modelResponse.usage) != null ? _a18 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings3,\n                                usage: usage2,\n                                warnings: modelResponse.warnings,\n                                providerMetadata: modelResponse.providerMetadata,\n                                response: modelResponse.response\n                            };\n                        }\n                    });\n                });\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.embeddings\": {\n                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                    }\n                }));\n                logWarnings({\n                    warnings: warnings2,\n                    provider: model.provider,\n                    model: model.modelId\n                });\n                return new DefaultEmbedManyResult({\n                    values,\n                    embeddings: embeddings2,\n                    usage,\n                    warnings: warnings2,\n                    providerMetadata: providerMetadata2,\n                    responses: [\n                        response\n                    ]\n                });\n            }\n            const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n            const embeddings = [];\n            const warnings = [];\n            const responses = [];\n            let tokens = 0;\n            let providerMetadata;\n            const parallelChunks = splitArray(valueChunks, supportsParallelCalls ? maxParallelCalls : 1);\n            for (const parallelChunk of parallelChunks){\n                const results = await Promise.all(parallelChunk.map((chunk)=>{\n                    return retry(()=>{\n                        return recordSpan({\n                            name: \"ai.embedMany.doEmbed\",\n                            attributes: selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    ...assembleOperationName({\n                                        operationId: \"ai.embedMany.doEmbed\",\n                                        telemetry\n                                    }),\n                                    ...baseTelemetryAttributes,\n                                    // specific settings that only make sense on the outer level:\n                                    \"ai.values\": {\n                                        input: ()=>chunk.map((value)=>JSON.stringify(value))\n                                    }\n                                }\n                            }),\n                            tracer,\n                            fn: async (doEmbedSpan)=>{\n                                var _a18;\n                                const modelResponse = await model.doEmbed({\n                                    values: chunk,\n                                    abortSignal,\n                                    headers: headersWithUserAgent,\n                                    providerOptions\n                                });\n                                const embeddings2 = modelResponse.embeddings;\n                                const usage = (_a18 = modelResponse.usage) != null ? _a18 : {\n                                    tokens: NaN\n                                };\n                                doEmbedSpan.setAttributes(await selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        \"ai.embeddings\": {\n                                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                                        },\n                                        \"ai.usage.tokens\": usage.tokens\n                                    }\n                                }));\n                                return {\n                                    embeddings: embeddings2,\n                                    usage,\n                                    warnings: modelResponse.warnings,\n                                    providerMetadata: modelResponse.providerMetadata,\n                                    response: modelResponse.response\n                                };\n                            }\n                        });\n                    });\n                }));\n                for (const result of results){\n                    embeddings.push(...result.embeddings);\n                    warnings.push(...result.warnings);\n                    responses.push(result.response);\n                    tokens += result.usage.tokens;\n                    if (result.providerMetadata) {\n                        if (!providerMetadata) {\n                            providerMetadata = {\n                                ...result.providerMetadata\n                            };\n                        } else {\n                            for (const [providerName, metadata] of Object.entries(result.providerMetadata)){\n                                providerMetadata[providerName] = {\n                                    ...(_a17 = providerMetadata[providerName]) != null ? _a17 : {},\n                                    ...metadata\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n            span.setAttributes(await selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embeddings\": {\n                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": tokens\n                }\n            }));\n            logWarnings({\n                warnings,\n                provider: model.provider,\n                model: model.modelId\n            });\n            return new DefaultEmbedManyResult({\n                values,\n                embeddings,\n                usage: {\n                    tokens\n                },\n                warnings,\n                providerMetadata,\n                responses\n            });\n        }\n    });\n}\nvar DefaultEmbedManyResult = class {\n    constructor(options){\n        this.values = options.values;\n        this.embeddings = options.embeddings;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.providerMetadata = options.providerMetadata;\n        this.responses = options.responses;\n    }\n};\n// src/generate-image/generate-image.ts\n\nasync function generateImage({ model: modelArg, prompt: promptArg, n = 1, maxImagesPerCall, size, aspectRatio, seed, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    var _a17, _b;\n    const model = resolveImageModel(modelArg);\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const maxImagesPerCallWithDefault = (_a17 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a17 : 1;\n    const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n    const callImageCounts = Array.from({\n        length: callCount\n    }, (_, i)=>{\n        if (i < callCount - 1) {\n            return maxImagesPerCallWithDefault;\n        }\n        const remainder = n % maxImagesPerCallWithDefault;\n        return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n    });\n    const results = await Promise.all(callImageCounts.map(async (callImageCount)=>retry(()=>{\n            const { prompt, files, mask } = normalizePrompt(promptArg);\n            return model.doGenerate({\n                prompt,\n                files,\n                mask,\n                n: callImageCount,\n                abortSignal,\n                headers: headersWithUserAgent,\n                size,\n                aspectRatio,\n                seed,\n                providerOptions: providerOptions != null ? providerOptions : {}\n            });\n        })));\n    const images = [];\n    const warnings = [];\n    const responses = [];\n    const providerMetadata = {};\n    let totalUsage = {\n        inputTokens: void 0,\n        outputTokens: void 0,\n        totalTokens: void 0\n    };\n    for (const result of results){\n        images.push(...result.images.map((image)=>{\n            var _a18;\n            return new DefaultGeneratedFile({\n                data: image,\n                mediaType: (_a18 = detectMediaType({\n                    data: image,\n                    signatures: imageMediaTypeSignatures\n                })) != null ? _a18 : \"image/png\"\n            });\n        }));\n        warnings.push(...result.warnings);\n        if (result.usage != null) {\n            totalUsage = addImageModelUsage(totalUsage, result.usage);\n        }\n        if (result.providerMetadata) {\n            for (const [providerName, metadata] of Object.entries(result.providerMetadata)){\n                if (providerName === \"gateway\") {\n                    const currentEntry = providerMetadata[providerName];\n                    if (currentEntry != null && typeof currentEntry === \"object\") {\n                        providerMetadata[providerName] = {\n                            ...currentEntry,\n                            ...metadata\n                        };\n                    } else {\n                        providerMetadata[providerName] = metadata;\n                    }\n                    const imagesValue = providerMetadata[providerName].images;\n                    if (Array.isArray(imagesValue) && imagesValue.length === 0) {\n                        delete providerMetadata[providerName].images;\n                    }\n                } else {\n                    (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = {\n                        images: []\n                    };\n                    providerMetadata[providerName].images.push(...result.providerMetadata[providerName].images);\n                }\n            }\n        }\n        responses.push(result.response);\n    }\n    logWarnings({\n        warnings,\n        provider: model.provider,\n        model: model.modelId\n    });\n    if (!images.length) {\n        throw new NoImageGeneratedError({\n            responses\n        });\n    }\n    return new DefaultGenerateImageResult({\n        images,\n        warnings,\n        responses,\n        providerMetadata,\n        usage: totalUsage\n    });\n}\nvar DefaultGenerateImageResult = class {\n    constructor(options){\n        this.images = options.images;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = options.providerMetadata;\n        this.usage = options.usage;\n    }\n    get image() {\n        return this.images[0];\n    }\n};\nasync function invokeModelMaxImagesPerCall(model) {\n    const isFunction = model.maxImagesPerCall instanceof Function;\n    if (!isFunction) {\n        return model.maxImagesPerCall;\n    }\n    return model.maxImagesPerCall({\n        modelId: model.modelId\n    });\n}\nfunction normalizePrompt(prompt) {\n    if (typeof prompt === \"string\") {\n        return {\n            prompt,\n            files: void 0,\n            mask: void 0\n        };\n    }\n    return {\n        prompt: prompt.text,\n        files: prompt.images.map(toImageModelV3File),\n        mask: prompt.mask ? toImageModelV3File(prompt.mask) : void 0\n    };\n}\nfunction toImageModelV3File(dataContent) {\n    if (typeof dataContent === \"string\" && dataContent.startsWith(\"http\")) {\n        return {\n            type: \"url\",\n            url: dataContent\n        };\n    }\n    if (typeof dataContent === \"string\" && dataContent.startsWith(\"data:\")) {\n        const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(dataContent);\n        if (base64Content != null) {\n            const uint8Data2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(base64Content);\n            return {\n                type: \"file\",\n                data: uint8Data2,\n                mediaType: dataUrlMediaType || detectMediaType({\n                    data: uint8Data2,\n                    signatures: imageMediaTypeSignatures\n                }) || \"image/png\"\n            };\n        }\n    }\n    const uint8Data = convertDataContentToUint8Array(dataContent);\n    return {\n        type: \"file\",\n        data: uint8Data,\n        mediaType: detectMediaType({\n            data: uint8Data,\n            signatures: imageMediaTypeSignatures\n        }) || \"image/png\"\n    };\n}\n// src/generate-image/index.ts\nvar experimental_generateImage = generateImage;\n// src/generate-object/generate-object.ts\n\n// src/generate-text/extract-reasoning-content.ts\nfunction extractReasoningContent(content) {\n    const parts = content.filter((content2)=>content2.type === \"reasoning\");\n    return parts.length === 0 ? void 0 : parts.map((content2)=>content2.text).join(\"\\n\");\n}\n// src/generate-object/output-strategy.ts\n\n\nvar noSchemaOutputStrategy = {\n    type: \"no-schema\",\n    jsonSchema: async ()=>void 0,\n    async validatePartialResult ({ value, textDelta }) {\n        return {\n            success: true,\n            value: {\n                partial: value,\n                textDelta\n            }\n        };\n    },\n    async validateFinalResult (value, context2) {\n        return value === void 0 ? {\n            success: false,\n            error: new NoObjectGeneratedError({\n                message: \"No object generated: response did not match schema.\",\n                text: context2.text,\n                response: context2.response,\n                usage: context2.usage,\n                finishReason: context2.finishReason\n            })\n        } : {\n            success: true,\n            value\n        };\n    },\n    createElementStream () {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n            functionality: \"element streams in no-schema mode\"\n        });\n    }\n};\nvar objectOutputStrategy = (schema)=>({\n        type: \"object\",\n        jsonSchema: async ()=>await schema.jsonSchema,\n        async validatePartialResult ({ value, textDelta }) {\n            return {\n                success: true,\n                value: {\n                    // Note: currently no validation of partial results:\n                    partial: value,\n                    textDelta\n                }\n            };\n        },\n        async validateFinalResult (value) {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value,\n                schema\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in object mode\"\n            });\n        }\n    });\nvar arrayOutputStrategy = (schema)=>{\n    return {\n        type: \"array\",\n        // wrap in object that contains array of elements, since most LLMs will not\n        // be able to generate an array directly:\n        // possible future optimization: use arrays directly when model supports grammar-guided generation\n        jsonSchema: async ()=>{\n            const { $schema, ...itemSchema } = await schema.jsonSchema;\n            return {\n                $schema: \"http://json-schema.org/draft-07/schema#\",\n                type: \"object\",\n                properties: {\n                    elements: {\n                        type: \"array\",\n                        items: itemSchema\n                    }\n                },\n                required: [\n                    \"elements\"\n                ],\n                additionalProperties: false\n            };\n        },\n        async validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {\n            var _a17;\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            const resultArray = [];\n            for(let i = 0; i < inputArray.length; i++){\n                const element = inputArray[i];\n                const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (i === inputArray.length - 1 && !isFinalDelta) {\n                    continue;\n                }\n                if (!result.success) {\n                    return result;\n                }\n                resultArray.push(result.value);\n            }\n            const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;\n            let textDelta = \"\";\n            if (isFirstDelta) {\n                textDelta += \"[\";\n            }\n            if (publishedElementCount > 0) {\n                textDelta += \",\";\n            }\n            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(\",\");\n            if (isFinalDelta) {\n                textDelta += \"]\";\n            }\n            return {\n                success: true,\n                value: {\n                    partial: resultArray,\n                    textDelta\n                }\n            };\n        },\n        async validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            for (const element of inputArray){\n                const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (!result.success) {\n                    return result;\n                }\n            }\n            return {\n                success: true,\n                value: inputArray\n            };\n        },\n        createElementStream (originalStream) {\n            let publishedElements = 0;\n            return createAsyncIterableStream(originalStream.pipeThrough(new TransformStream({\n                transform (chunk, controller) {\n                    switch(chunk.type){\n                        case \"object\":\n                            {\n                                const array2 = chunk.object;\n                                for(; publishedElements < array2.length; publishedElements++){\n                                    controller.enqueue(array2[publishedElements]);\n                                }\n                                break;\n                            }\n                        case \"text-delta\":\n                        case \"finish\":\n                        case \"error\":\n                            break;\n                        default:\n                            {\n                                const _exhaustiveCheck = chunk;\n                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                            }\n                    }\n                }\n            })));\n        }\n    };\n};\nvar enumOutputStrategy = (enumValues)=>{\n    return {\n        type: \"enum\",\n        // wrap in object that contains result, since most LLMs will not\n        // be able to generate an enum value directly:\n        // possible future optimization: use enums directly when model supports top-level enums\n        jsonSchema: async ()=>({\n                $schema: \"http://json-schema.org/draft-07/schema#\",\n                type: \"object\",\n                properties: {\n                    result: {\n                        type: \"string\",\n                        enum: enumValues\n                    }\n                },\n                required: [\n                    \"result\"\n                ],\n                additionalProperties: false\n            }),\n        async validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            return enumValues.includes(result) ? {\n                success: true,\n                value: result\n            } : {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                    value,\n                    cause: \"value must be a string in the enum\"\n                })\n            };\n        },\n        async validatePartialResult ({ value, textDelta }) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            const possibleEnumValues = enumValues.filter((enumValue)=>enumValue.startsWith(result));\n            if (value.result.length === 0 || possibleEnumValues.length === 0) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be a string in the enum\"\n                    })\n                };\n            }\n            return {\n                success: true,\n                value: {\n                    partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n                    textDelta\n                }\n            };\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in enum mode\"\n            });\n        }\n    };\n};\nfunction getOutputStrategy({ output, schema, enumValues }) {\n    switch(output){\n        case \"object\":\n            return objectOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n        case \"array\":\n            return arrayOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n        case \"enum\":\n            return enumOutputStrategy(enumValues);\n        case \"no-schema\":\n            return noSchemaOutputStrategy;\n        default:\n            {\n                const _exhaustiveCheck = output;\n                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n            }\n    }\n}\n// src/generate-object/parse-and-validate-object-result.ts\n\n\nasync function parseAndValidateObjectResult(result, outputStrategy, context2) {\n    const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: result\n    });\n    if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n            message: \"No object generated: could not parse the response.\",\n            cause: parseResult.error,\n            text: result,\n            response: context2.response,\n            usage: context2.usage,\n            finishReason: context2.finishReason\n        });\n    }\n    const validationResult = await outputStrategy.validateFinalResult(parseResult.value, {\n        text: result,\n        response: context2.response,\n        usage: context2.usage\n    });\n    if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n            message: \"No object generated: response did not match schema.\",\n            cause: validationResult.error,\n            text: result,\n            response: context2.response,\n            usage: context2.usage,\n            finishReason: context2.finishReason\n        });\n    }\n    return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context2) {\n    try {\n        return await parseAndValidateObjectResult(result, outputStrategy, context2);\n    } catch (error) {\n        if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error.cause))) {\n            const repairedText = await repairText({\n                text: result,\n                error: error.cause\n            });\n            if (repairedText === null) {\n                throw error;\n            }\n            return await parseAndValidateObjectResult(repairedText, outputStrategy, context2);\n        }\n        throw error;\n    }\n}\n// src/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({ output, schema, schemaName, schemaDescription, enumValues }) {\n    if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n        throw new InvalidArgumentError({\n            parameter: \"output\",\n            value: output,\n            message: \"Invalid output type.\"\n        });\n    }\n    if (output === \"no-schema\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for no-schema output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for no-schema output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for no-schema output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for no-schema output.\"\n            });\n        }\n    }\n    if (output === \"object\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is required for object output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for object output.\"\n            });\n        }\n    }\n    if (output === \"array\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Element schema is required for array output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for array output.\"\n            });\n        }\n    }\n    if (output === \"enum\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for enum output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for enum output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for enum output.\"\n            });\n        }\n        if (enumValues == null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are required for enum output.\"\n            });\n        }\n        for (const value of enumValues){\n            if (typeof value !== \"string\") {\n                throw new InvalidArgumentError({\n                    parameter: \"enumValues\",\n                    value,\n                    message: \"Enum values must be strings.\"\n                });\n            }\n        }\n    }\n}\n// src/generate-object/generate-object.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function generateObject(options) {\n    const { model: modelArg, output = \"object\", system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, experimental_repairText: repairText, experimental_telemetry: telemetry, experimental_download: download2, providerOptions, _internal: { generateId: generateId2 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings } = options;\n    const model = resolveLanguageModel(modelArg);\n    const enumValues = \"enum\" in options ? options.enum : void 0;\n    const { schema: inputSchema, schemaDescription, schemaName } = \"schema\" in options ? options : {};\n    validateObjectGenerationInput({\n        output,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    const callSettings = prepareCallSettings(settings);\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers: headersWithUserAgent,\n        settings: {\n            ...callSettings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const jsonSchema2 = await outputStrategy.jsonSchema();\n    try {\n        return await recordSpan({\n            name: \"ai.generateObject\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.generateObject\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.schema\": jsonSchema2 != null ? {\n                        input: ()=>JSON.stringify(jsonSchema2)\n                    } : void 0,\n                    \"ai.schema.name\": schemaName,\n                    \"ai.schema.description\": schemaDescription,\n                    \"ai.settings.output\": outputStrategy.type\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                var _a17;\n                let result;\n                let finishReason;\n                let usage;\n                let warnings;\n                let response;\n                let request;\n                let resultProviderMetadata;\n                let reasoning;\n                const standardizedPrompt = await standardizePrompt({\n                    system,\n                    prompt,\n                    messages\n                });\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: standardizedPrompt,\n                    supportedUrls: await model.supportedUrls,\n                    download: download2\n                });\n                const generateResult = await retry(()=>recordSpan({\n                        name: \"ai.generateObject.doGenerate\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.generateObject.doGenerate\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.messages\": {\n                                    input: ()=>stringifyForTelemetry(promptMessages)\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                                \"gen_ai.request.temperature\": callSettings.temperature,\n                                \"gen_ai.request.top_k\": callSettings.topK,\n                                \"gen_ai.request.top_p\": callSettings.topP\n                            }\n                        }),\n                        tracer,\n                        fn: async (span2)=>{\n                            var _a18, _b, _c, _d, _e, _f, _g, _h;\n                            const result2 = await model.doGenerate({\n                                responseFormat: {\n                                    type: \"json\",\n                                    schema: jsonSchema2,\n                                    name: schemaName,\n                                    description: schemaDescription\n                                },\n                                ...prepareCallSettings(settings),\n                                prompt: promptMessages,\n                                providerOptions,\n                                abortSignal,\n                                headers: headersWithUserAgent\n                            });\n                            const responseData = {\n                                id: (_b = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b : generateId2(),\n                                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n                                headers: (_g = result2.response) == null ? void 0 : _g.headers,\n                                body: (_h = result2.response) == null ? void 0 : _h.body\n                            };\n                            const text2 = extractTextContent(result2.content);\n                            const reasoning2 = extractReasoningContent(result2.content);\n                            if (text2 === void 0) {\n                                throw new NoObjectGeneratedError({\n                                    message: \"No object generated: the model did not return a response.\",\n                                    response: responseData,\n                                    usage: asLanguageModelUsage(result2.usage),\n                                    finishReason: result2.finishReason.unified\n                                });\n                            }\n                            span2.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": result2.finishReason.unified,\n                                    \"ai.response.object\": {\n                                        output: ()=>text2\n                                    },\n                                    \"ai.response.id\": responseData.id,\n                                    \"ai.response.model\": responseData.modelId,\n                                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                    \"ai.response.providerMetadata\": JSON.stringify(result2.providerMetadata),\n                                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                                    \"ai.usage.promptTokens\": result2.usage.inputTokens.total,\n                                    \"ai.usage.completionTokens\": result2.usage.outputTokens.total,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        result2.finishReason.unified\n                                    ],\n                                    \"gen_ai.response.id\": responseData.id,\n                                    \"gen_ai.response.model\": responseData.modelId,\n                                    \"gen_ai.usage.input_tokens\": result2.usage.inputTokens.total,\n                                    \"gen_ai.usage.output_tokens\": result2.usage.outputTokens.total\n                                }\n                            }));\n                            return {\n                                ...result2,\n                                objectText: text2,\n                                reasoning: reasoning2,\n                                responseData\n                            };\n                        }\n                    }));\n                result = generateResult.objectText;\n                finishReason = generateResult.finishReason.unified;\n                usage = asLanguageModelUsage(generateResult.usage);\n                warnings = generateResult.warnings;\n                resultProviderMetadata = generateResult.providerMetadata;\n                request = (_a17 = generateResult.request) != null ? _a17 : {};\n                response = generateResult.responseData;\n                reasoning = generateResult.reasoning;\n                logWarnings({\n                    warnings,\n                    provider: model.provider,\n                    model: model.modelId\n                });\n                const object2 = await parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, {\n                    response,\n                    usage,\n                    finishReason\n                });\n                span.setAttributes(await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.response.finishReason\": finishReason,\n                        \"ai.response.object\": {\n                            output: ()=>JSON.stringify(object2)\n                        },\n                        \"ai.response.providerMetadata\": JSON.stringify(resultProviderMetadata),\n                        // TODO rename telemetry attributes to inputTokens and outputTokens\n                        \"ai.usage.promptTokens\": usage.inputTokens,\n                        \"ai.usage.completionTokens\": usage.outputTokens\n                    }\n                }));\n                return new DefaultGenerateObjectResult({\n                    object: object2,\n                    reasoning,\n                    finishReason,\n                    usage,\n                    warnings,\n                    request,\n                    response,\n                    providerMetadata: resultProviderMetadata\n                });\n            }\n        });\n    } catch (error) {\n        throw wrapGatewayError(error);\n    }\n}\nvar DefaultGenerateObjectResult = class {\n    constructor(options){\n        this.object = options.object;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.providerMetadata = options.providerMetadata;\n        this.response = options.response;\n        this.request = options.request;\n        this.reasoning = options.reasoning;\n    }\n    toJsonResponse(init) {\n        var _a17;\n        return new Response(JSON.stringify(this.object), {\n            status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n            headers: prepareHeaders(init == null ? void 0 : init.headers, {\n                \"content-type\": \"application/json; charset=utf-8\"\n            })\n        });\n    }\n};\n// src/generate-object/stream-object.ts\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n    if (vector1.length !== vector2.length) {\n        throw new InvalidArgumentError({\n            parameter: \"vector1,vector2\",\n            value: {\n                vector1Length: vector1.length,\n                vector2Length: vector2.length\n            },\n            message: `Vectors must have the same length`\n        });\n    }\n    const n = vector1.length;\n    if (n === 0) {\n        return 0;\n    }\n    let magnitudeSquared1 = 0;\n    let magnitudeSquared2 = 0;\n    let dotProduct = 0;\n    for(let i = 0; i < n; i++){\n        const value1 = vector1[i];\n        const value2 = vector2[i];\n        magnitudeSquared1 += value1 * value1;\n        magnitudeSquared2 += value2 * value2;\n        dotProduct += value1 * value2;\n    }\n    return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n    const [header, base64Content] = dataUrl.split(\",\");\n    const mediaType = header.split(\";\")[0].split(\":\")[1];\n    if (mediaType == null || base64Content == null) {\n        throw new Error(\"Invalid data URL format\");\n    }\n    try {\n        return window.atob(base64Content);\n    } catch (error) {\n        throw new Error(`Error decoding data URL`);\n    }\n}\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n    if (obj1 === obj2) return true;\n    if (obj1 == null || obj2 == null) return false;\n    if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\") return obj1 === obj2;\n    if (obj1.constructor !== obj2.constructor) return false;\n    if (obj1 instanceof Date && obj2 instanceof Date) {\n        return obj1.getTime() === obj2.getTime();\n    }\n    if (Array.isArray(obj1)) {\n        if (obj1.length !== obj2.length) return false;\n        for(let i = 0; i < obj1.length; i++){\n            if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n        }\n        return true;\n    }\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    for (const key of keys1){\n        if (!keys2.includes(key)) return false;\n        if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n    }\n    return true;\n}\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n    constructor(){\n        this.queue = [];\n        this.isProcessing = false;\n    }\n    async processQueue() {\n        if (this.isProcessing) {\n            return;\n        }\n        this.isProcessing = true;\n        while(this.queue.length > 0){\n            await this.queue[0]();\n            this.queue.shift();\n        }\n        this.isProcessing = false;\n    }\n    async run(job) {\n        return new Promise((resolve3, reject)=>{\n            this.queue.push(async ()=>{\n                try {\n                    await job();\n                    resolve3();\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            void this.processQueue();\n        });\n    }\n};\n// src/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({ chunks, initialDelayInMs = 0, chunkDelayInMs = 0, _internal }) {\n    var _a17;\n    const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n    let index = 0;\n    return new ReadableStream({\n        async pull (controller) {\n            if (index < chunks.length) {\n                await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n                controller.enqueue(chunks[index++]);\n            } else {\n                controller.close();\n            }\n        }\n    });\n}\n// src/generate-object/stream-object.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nfunction streamObject(options) {\n    const { model, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_repairText: repairText, experimental_telemetry: telemetry, experimental_download: download2, providerOptions, onError = ({ error })=>{\n        console.error(error);\n    }, onFinish, _internal: { generateId: generateId2 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings } = options;\n    const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n    const { schema: inputSchema, schemaDescription, schemaName } = \"schema\" in options ? options : {};\n    validateObjectGenerationInput({\n        output,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    return new DefaultStreamObjectResult({\n        model,\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal,\n        outputStrategy,\n        system,\n        prompt,\n        messages,\n        schemaName,\n        schemaDescription,\n        providerOptions,\n        repairText,\n        onError,\n        onFinish,\n        download: download2,\n        generateId: generateId2,\n        currentDate,\n        now: now2\n    });\n}\nvar DefaultStreamObjectResult = class {\n    constructor({ model: modelArg, headers, telemetry, settings, maxRetries: maxRetriesArg, abortSignal, outputStrategy, system, prompt, messages, schemaName, schemaDescription, providerOptions, repairText, onError, onFinish, download: download2, generateId: generateId2, currentDate, now: now2 }){\n        this._object = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._usage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._providerMetadata = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._warnings = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._request = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._response = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n        const model = resolveLanguageModel(modelArg);\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg,\n            abortSignal\n        });\n        const callSettings = prepareCallSettings(settings);\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...callSettings,\n                maxRetries\n            }\n        });\n        const tracer = getTracer(telemetry);\n        const self = this;\n        const stitchableStream = createStitchableStream();\n        const eventProcessor = new TransformStream({\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"error\") {\n                    onError({\n                        error: wrapGatewayError(chunk.error)\n                    });\n                }\n            }\n        });\n        this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n        recordSpan({\n            name: \"ai.streamObject\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamObject\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.schema\": {\n                        input: async ()=>JSON.stringify(await outputStrategy.jsonSchema())\n                    },\n                    \"ai.schema.name\": schemaName,\n                    \"ai.schema.description\": schemaDescription,\n                    \"ai.settings.output\": outputStrategy.type\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpan)=>{\n                const standardizedPrompt = await standardizePrompt({\n                    system,\n                    prompt,\n                    messages\n                });\n                const callOptions = {\n                    responseFormat: {\n                        type: \"json\",\n                        schema: await outputStrategy.jsonSchema(),\n                        name: schemaName,\n                        description: schemaDescription\n                    },\n                    ...prepareCallSettings(settings),\n                    prompt: await convertToLanguageModelPrompt({\n                        prompt: standardizedPrompt,\n                        supportedUrls: await model.supportedUrls,\n                        download: download2\n                    }),\n                    providerOptions,\n                    abortSignal,\n                    headers,\n                    includeRawChunks: false\n                };\n                const transformer = {\n                    transform: (chunk, controller)=>{\n                        switch(chunk.type){\n                            case \"text-delta\":\n                                controller.enqueue(chunk.delta);\n                                break;\n                            case \"response-metadata\":\n                            case \"finish\":\n                            case \"error\":\n                            case \"stream-start\":\n                                controller.enqueue(chunk);\n                                break;\n                        }\n                    }\n                };\n                const { result: { stream, response, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                        name: \"ai.streamObject.doStream\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.streamObject.doStream\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.messages\": {\n                                    input: ()=>stringifyForTelemetry(callOptions.prompt)\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                                \"gen_ai.request.temperature\": callSettings.temperature,\n                                \"gen_ai.request.top_k\": callSettings.topK,\n                                \"gen_ai.request.top_p\": callSettings.topP\n                            }\n                        }),\n                        tracer,\n                        endWhenDone: false,\n                        fn: async (doStreamSpan2)=>({\n                                startTimestampMs: now2(),\n                                doStreamSpan: doStreamSpan2,\n                                result: await model.doStream(callOptions)\n                            })\n                    }));\n                self._request.resolve(request != null ? request : {});\n                let warnings;\n                let usage = createNullLanguageModelUsage();\n                let finishReason;\n                let providerMetadata;\n                let object2;\n                let error;\n                let accumulatedText = \"\";\n                let textDelta = \"\";\n                let fullResponse = {\n                    id: generateId2(),\n                    timestamp: currentDate(),\n                    modelId: model.modelId\n                };\n                let latestObjectJson = void 0;\n                let latestObject = void 0;\n                let isFirstChunk = true;\n                let isFirstDelta = true;\n                const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(new TransformStream({\n                    async transform (chunk, controller) {\n                        var _a17, _b, _c;\n                        if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                            warnings = chunk.warnings;\n                            return;\n                        }\n                        if (isFirstChunk) {\n                            const msToFirstChunk = now2() - startTimestampMs;\n                            isFirstChunk = false;\n                            doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                            doStreamSpan.setAttributes({\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                        }\n                        if (typeof chunk === \"string\") {\n                            accumulatedText += chunk;\n                            textDelta += chunk;\n                            const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                            if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                                const validationResult = await outputStrategy.validatePartialResult({\n                                    value: currentObjectJson,\n                                    textDelta,\n                                    latestObject,\n                                    isFirstDelta,\n                                    isFinalDelta: parseState === \"successful-parse\"\n                                });\n                                if (validationResult.success && !isDeepEqualData(latestObject, validationResult.value.partial)) {\n                                    latestObjectJson = currentObjectJson;\n                                    latestObject = validationResult.value.partial;\n                                    controller.enqueue({\n                                        type: \"object\",\n                                        object: latestObject\n                                    });\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        textDelta: validationResult.value.textDelta\n                                    });\n                                    textDelta = \"\";\n                                    isFirstDelta = false;\n                                }\n                            }\n                            return;\n                        }\n                        switch(chunk.type){\n                            case \"response-metadata\":\n                                {\n                                    fullResponse = {\n                                        id: (_a17 = chunk.id) != null ? _a17 : fullResponse.id,\n                                        timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                                        modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                                    };\n                                    break;\n                                }\n                            case \"finish\":\n                                {\n                                    if (textDelta !== \"\") {\n                                        controller.enqueue({\n                                            type: \"text-delta\",\n                                            textDelta\n                                        });\n                                    }\n                                    finishReason = chunk.finishReason.unified;\n                                    usage = asLanguageModelUsage(chunk.usage);\n                                    providerMetadata = chunk.providerMetadata;\n                                    controller.enqueue({\n                                        ...chunk,\n                                        finishReason: chunk.finishReason.unified,\n                                        usage,\n                                        response: fullResponse\n                                    });\n                                    logWarnings({\n                                        warnings: warnings != null ? warnings : [],\n                                        provider: model.provider,\n                                        model: model.modelId\n                                    });\n                                    self._usage.resolve(usage);\n                                    self._providerMetadata.resolve(providerMetadata);\n                                    self._warnings.resolve(warnings);\n                                    self._response.resolve({\n                                        ...fullResponse,\n                                        headers: response == null ? void 0 : response.headers\n                                    });\n                                    self._finishReason.resolve(finishReason != null ? finishReason : \"other\");\n                                    try {\n                                        object2 = await parseAndValidateObjectResultWithRepair(accumulatedText, outputStrategy, repairText, {\n                                            response: fullResponse,\n                                            usage,\n                                            finishReason\n                                        });\n                                        self._object.resolve(object2);\n                                    } catch (e) {\n                                        error = e;\n                                        self._object.reject(e);\n                                    }\n                                    break;\n                                }\n                            default:\n                                {\n                                    controller.enqueue(chunk);\n                                    break;\n                                }\n                        }\n                    },\n                    // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                    async flush (controller) {\n                        try {\n                            const finalUsage = usage != null ? usage : {\n                                promptTokens: NaN,\n                                completionTokens: NaN,\n                                totalTokens: NaN\n                            };\n                            doStreamSpan.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": finishReason,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    },\n                                    \"ai.response.id\": fullResponse.id,\n                                    \"ai.response.model\": fullResponse.modelId,\n                                    \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                                    \"ai.response.providerMetadata\": JSON.stringify(providerMetadata),\n                                    \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                                    \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                                    \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                                    \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                                    \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        finishReason\n                                    ],\n                                    \"gen_ai.response.id\": fullResponse.id,\n                                    \"gen_ai.response.model\": fullResponse.modelId,\n                                    \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                                    \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                                }\n                            }));\n                            doStreamSpan.end();\n                            rootSpan.setAttributes(await selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                                    \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                                    \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                                    \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                                    \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    },\n                                    \"ai.response.providerMetadata\": JSON.stringify(providerMetadata)\n                                }\n                            }));\n                            await (onFinish == null ? void 0 : onFinish({\n                                usage: finalUsage,\n                                object: object2,\n                                error,\n                                response: {\n                                    ...fullResponse,\n                                    headers: response == null ? void 0 : response.headers\n                                },\n                                warnings,\n                                providerMetadata\n                            }));\n                        } catch (error2) {\n                            controller.enqueue({\n                                type: \"error\",\n                                error: error2\n                            });\n                        } finally{\n                            rootSpan.end();\n                        }\n                    }\n                }));\n                stitchableStream.addStream(transformedStream);\n            }\n        }).catch((error)=>{\n            stitchableStream.addStream(new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"error\",\n                        error\n                    });\n                    controller.close();\n                }\n            }));\n        }).finally(()=>{\n            stitchableStream.close();\n        });\n        this.outputStrategy = outputStrategy;\n    }\n    get object() {\n        return this._object.promise;\n    }\n    get usage() {\n        return this._usage.promise;\n    }\n    get providerMetadata() {\n        return this._providerMetadata.promise;\n    }\n    get warnings() {\n        return this._warnings.promise;\n    }\n    get request() {\n        return this._request.promise;\n    }\n    get response() {\n        return this._response.promise;\n    }\n    get finishReason() {\n        return this._finishReason.promise;\n    }\n    get partialObjectStream() {\n        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"object\":\n                        controller.enqueue(chunk.object);\n                        break;\n                    case \"text-delta\":\n                    case \"finish\":\n                    case \"error\":\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get elementStream() {\n        return this.outputStrategy.createElementStream(this.baseStream);\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"text-delta\":\n                        controller.enqueue(chunk.textDelta);\n                        break;\n                    case \"object\":\n                    case \"finish\":\n                    case \"error\":\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.baseStream);\n    }\n    pipeTextStreamToResponse(response, init) {\n        pipeTextStreamToResponse({\n            response,\n            textStream: this.textStream,\n            ...init\n        });\n    }\n    toTextStreamResponse(init) {\n        return createTextStreamResponse({\n            textStream: this.textStream,\n            ...init\n        });\n    }\n};\n// src/generate-speech/generate-speech.ts\n\n// src/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n    constructor({ data, mediaType }){\n        super({\n            data,\n            mediaType\n        });\n        let format = \"mp3\";\n        if (mediaType) {\n            const mediaTypeParts = mediaType.split(\"/\");\n            if (mediaTypeParts.length === 2) {\n                if (mediaType !== \"audio/mpeg\") {\n                    format = mediaTypeParts[1];\n                }\n            }\n        }\n        if (!format) {\n            throw new Error(\"Audio format must be provided or determinable from media type\");\n        }\n        this.format = format;\n    }\n};\n// src/generate-speech/generate-speech.ts\nasync function generateSpeech({ model, text: text2, voice, outputFormat, instructions, speed, language, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    var _a17;\n    const resolvedModel = resolveSpeechModel(model);\n    if (!resolvedModel) {\n        throw new Error(\"Model could not be resolved\");\n    }\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const result = await retry(()=>resolvedModel.doGenerate({\n            text: text2,\n            voice,\n            outputFormat,\n            instructions,\n            speed,\n            language,\n            abortSignal,\n            headers: headersWithUserAgent,\n            providerOptions\n        }));\n    if (!result.audio || result.audio.length === 0) {\n        throw new NoSpeechGeneratedError({\n            responses: [\n                result.response\n            ]\n        });\n    }\n    logWarnings({\n        warnings: result.warnings,\n        provider: resolvedModel.provider,\n        model: resolvedModel.modelId\n    });\n    return new DefaultSpeechResult({\n        audio: new DefaultGeneratedAudioFile({\n            data: result.audio,\n            mediaType: (_a17 = detectMediaType({\n                data: result.audio,\n                signatures: audioMediaTypeSignatures\n            })) != null ? _a17 : \"audio/mp3\"\n        }),\n        warnings: result.warnings,\n        responses: [\n            result.response\n        ],\n        providerMetadata: result.providerMetadata\n    });\n}\nvar DefaultSpeechResult = class {\n    constructor(options){\n        var _a17;\n        this.audio = options.audio;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n    }\n};\n// src/generate-text/prune-messages.ts\nfunction pruneMessages({ messages, reasoning = \"none\", toolCalls = [], emptyMessages = \"remove\" }) {\n    if (reasoning === \"all\" || reasoning === \"before-last-message\") {\n        messages = messages.map((message, messageIndex)=>{\n            if (message.role !== \"assistant\" || typeof message.content === \"string\" || reasoning === \"before-last-message\" && messageIndex === messages.length - 1) {\n                return message;\n            }\n            return {\n                ...message,\n                content: message.content.filter((part)=>part.type !== \"reasoning\")\n            };\n        });\n    }\n    if (toolCalls === \"none\") {\n        toolCalls = [];\n    } else if (toolCalls === \"all\") {\n        toolCalls = [\n            {\n                type: \"all\"\n            }\n        ];\n    } else if (toolCalls === \"before-last-message\") {\n        toolCalls = [\n            {\n                type: \"before-last-message\"\n            }\n        ];\n    } else if (typeof toolCalls === \"string\") {\n        toolCalls = [\n            {\n                type: toolCalls\n            }\n        ];\n    }\n    for (const toolCall of toolCalls){\n        const keepLastMessagesCount = toolCall.type === \"all\" ? void 0 : toolCall.type === \"before-last-message\" ? 1 : Number(toolCall.type.slice(\"before-last-\".length).slice(0, -\"-messages\".length));\n        const keptToolCallIds = /* @__PURE__ */ new Set();\n        const keptApprovalIds = /* @__PURE__ */ new Set();\n        if (keepLastMessagesCount != null) {\n            for (const message of messages.slice(-keepLastMessagesCount)){\n                if ((message.role === \"assistant\" || message.role === \"tool\") && typeof message.content !== \"string\") {\n                    for (const part of message.content){\n                        if (part.type === \"tool-call\" || part.type === \"tool-result\") {\n                            keptToolCallIds.add(part.toolCallId);\n                        } else if (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") {\n                            keptApprovalIds.add(part.approvalId);\n                        }\n                    }\n                }\n            }\n        }\n        messages = messages.map((message, messageIndex)=>{\n            if (message.role !== \"assistant\" && message.role !== \"tool\" || typeof message.content === \"string\" || keepLastMessagesCount && messageIndex >= messages.length - keepLastMessagesCount) {\n                return message;\n            }\n            const toolCallIdToToolName = {};\n            const approvalIdToToolName = {};\n            return {\n                ...message,\n                content: message.content.filter((part)=>{\n                    if (part.type !== \"tool-call\" && part.type !== \"tool-result\" && part.type !== \"tool-approval-request\" && part.type !== \"tool-approval-response\") {\n                        return true;\n                    }\n                    if (part.type === \"tool-call\") {\n                        toolCallIdToToolName[part.toolCallId] = part.toolName;\n                    } else if (part.type === \"tool-approval-request\") {\n                        approvalIdToToolName[part.approvalId] = toolCallIdToToolName[part.toolCallId];\n                    }\n                    if ((part.type === \"tool-call\" || part.type === \"tool-result\") && keptToolCallIds.has(part.toolCallId) || (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") && keptApprovalIds.has(part.approvalId)) {\n                        return true;\n                    }\n                    return toolCall.tools != null && !toolCall.tools.includes(part.type === \"tool-call\" || part.type === \"tool-result\" ? part.toolName : approvalIdToToolName[part.approvalId]);\n                })\n            };\n        });\n    }\n    if (emptyMessages === \"remove\") {\n        messages = messages.filter((message)=>message.content.length > 0);\n    }\n    return messages;\n}\n// src/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n    word: /\\S+\\s+/m,\n    line: /\\n+/m\n};\nfunction smoothStream({ delayInMs = 10, chunking = \"word\", _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {} } = {}) {\n    let detectChunk;\n    if (chunking != null && typeof chunking === \"object\" && \"segment\" in chunking && typeof chunking.segment === \"function\") {\n        const segmenter = chunking;\n        detectChunk = (buffer)=>{\n            if (buffer.length === 0) return null;\n            const iterator = segmenter.segment(buffer)[Symbol.iterator]();\n            const first = iterator.next().value;\n            return (first == null ? void 0 : first.segment) || null;\n        };\n    } else if (typeof chunking === \"function\") {\n        detectChunk = (buffer)=>{\n            const match = chunking(buffer);\n            if (match == null) {\n                return null;\n            }\n            if (!match.length) {\n                throw new Error(`Chunking function must return a non-empty string.`);\n            }\n            if (!buffer.startsWith(match)) {\n                throw new Error(`Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`);\n            }\n            return match;\n        };\n    } else {\n        const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking instanceof RegExp ? chunking : void 0;\n        if (chunkingRegex == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n                argument: \"chunking\",\n                message: `Chunking must be \"word\", \"line\", a RegExp, an Intl.Segmenter, or a ChunkDetector function. Received: ${chunking}`\n            });\n        }\n        detectChunk = (buffer)=>{\n            const match = chunkingRegex.exec(buffer);\n            if (!match) {\n                return null;\n            }\n            return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n        };\n    }\n    return ()=>{\n        let buffer = \"\";\n        let id = \"\";\n        let type = void 0;\n        let providerMetadata = void 0;\n        function flushBuffer(controller) {\n            if (buffer.length > 0 && type !== void 0) {\n                controller.enqueue({\n                    type,\n                    text: buffer,\n                    id,\n                    ...providerMetadata != null ? {\n                        providerMetadata\n                    } : {}\n                });\n                buffer = \"\";\n                providerMetadata = void 0;\n            }\n        }\n        return new TransformStream({\n            async transform (chunk, controller) {\n                if (chunk.type !== \"text-delta\" && chunk.type !== \"reasoning-delta\") {\n                    flushBuffer(controller);\n                    controller.enqueue(chunk);\n                    return;\n                }\n                if ((chunk.type !== type || chunk.id !== id) && buffer.length > 0) {\n                    flushBuffer(controller);\n                }\n                buffer += chunk.text;\n                id = chunk.id;\n                type = chunk.type;\n                if (chunk.providerMetadata != null) {\n                    providerMetadata = chunk.providerMetadata;\n                }\n                let match;\n                while((match = detectChunk(buffer)) != null){\n                    controller.enqueue({\n                        type,\n                        text: match,\n                        id\n                    });\n                    buffer = buffer.slice(match.length);\n                    await delay2(delayInMs);\n                }\n            }\n        });\n    };\n}\n// src/middleware/default-embedding-settings-middleware.ts\nfunction defaultEmbeddingSettingsMiddleware({ settings }) {\n    return {\n        specificationVersion: \"v3\",\n        transformParams: async ({ params })=>{\n            return mergeObjects(settings, params);\n        }\n    };\n}\n// src/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({ settings }) {\n    return {\n        specificationVersion: \"v3\",\n        transformParams: async ({ params })=>{\n            return mergeObjects(settings, params);\n        }\n    };\n}\n// src/middleware/extract-json-middleware.ts\nfunction defaultTransform(text2) {\n    return text2.replace(/^```(?:json)?\\s*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\").trim();\n}\nfunction extractJsonMiddleware(options) {\n    var _a17;\n    const transform = (_a17 = options == null ? void 0 : options.transform) != null ? _a17 : defaultTransform;\n    const hasCustomTransform = (options == null ? void 0 : options.transform) !== void 0;\n    return {\n        specificationVersion: \"v3\",\n        wrapGenerate: async ({ doGenerate })=>{\n            const { content, ...rest } = await doGenerate();\n            const transformedContent = [];\n            for (const part of content){\n                if (part.type !== \"text\") {\n                    transformedContent.push(part);\n                    continue;\n                }\n                transformedContent.push({\n                    ...part,\n                    text: transform(part.text)\n                });\n            }\n            return {\n                content: transformedContent,\n                ...rest\n            };\n        },\n        wrapStream: async ({ doStream })=>{\n            const { stream, ...rest } = await doStream();\n            const textBlocks = {};\n            const SUFFIX_BUFFER_SIZE = 12;\n            return {\n                stream: stream.pipeThrough(new TransformStream({\n                    transform: (chunk, controller)=>{\n                        if (chunk.type === \"text-start\") {\n                            textBlocks[chunk.id] = {\n                                startEvent: chunk,\n                                // Custom transforms need to buffer all content\n                                phase: hasCustomTransform ? \"buffering\" : \"prefix\",\n                                buffer: \"\",\n                                prefixStripped: false\n                            };\n                            return;\n                        }\n                        if (chunk.type === \"text-delta\") {\n                            const block = textBlocks[chunk.id];\n                            if (!block) {\n                                controller.enqueue(chunk);\n                                return;\n                            }\n                            block.buffer += chunk.delta;\n                            if (block.phase === \"buffering\") {\n                                return;\n                            }\n                            if (block.phase === \"prefix\") {\n                                if (block.buffer.length > 0 && !block.buffer.startsWith(\"`\")) {\n                                    block.phase = \"streaming\";\n                                    controller.enqueue(block.startEvent);\n                                } else if (block.buffer.startsWith(\"```\")) {\n                                    if (block.buffer.includes(\"\\n\")) {\n                                        const prefixMatch = block.buffer.match(/^```(?:json)?\\s*\\n/);\n                                        if (prefixMatch) {\n                                            block.buffer = block.buffer.slice(prefixMatch[0].length);\n                                            block.prefixStripped = true;\n                                            block.phase = \"streaming\";\n                                            controller.enqueue(block.startEvent);\n                                        } else {\n                                            block.phase = \"streaming\";\n                                            controller.enqueue(block.startEvent);\n                                        }\n                                    }\n                                } else if (block.buffer.length >= 3 && !block.buffer.startsWith(\"```\")) {\n                                    block.phase = \"streaming\";\n                                    controller.enqueue(block.startEvent);\n                                }\n                            }\n                            if (block.phase === \"streaming\" && block.buffer.length > SUFFIX_BUFFER_SIZE) {\n                                const toStream = block.buffer.slice(0, -SUFFIX_BUFFER_SIZE);\n                                block.buffer = block.buffer.slice(-SUFFIX_BUFFER_SIZE);\n                                controller.enqueue({\n                                    type: \"text-delta\",\n                                    id: chunk.id,\n                                    delta: toStream\n                                });\n                            }\n                            return;\n                        }\n                        if (chunk.type === \"text-end\") {\n                            const block = textBlocks[chunk.id];\n                            if (block) {\n                                if (block.phase === \"prefix\" || block.phase === \"buffering\") {\n                                    controller.enqueue(block.startEvent);\n                                }\n                                let remaining = block.buffer;\n                                if (block.phase === \"buffering\") {\n                                    remaining = transform(remaining);\n                                } else if (block.prefixStripped) {\n                                    remaining = remaining.replace(/\\n?```\\s*$/, \"\").trimEnd();\n                                } else {\n                                    remaining = transform(remaining);\n                                }\n                                if (remaining.length > 0) {\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        id: chunk.id,\n                                        delta: remaining\n                                    });\n                                }\n                                controller.enqueue(chunk);\n                                delete textBlocks[chunk.id];\n                                return;\n                            }\n                        }\n                        controller.enqueue(chunk);\n                    }\n                })),\n                ...rest\n            };\n        }\n    };\n}\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n    if (searchedText.length === 0) {\n        return null;\n    }\n    const directIndex = text2.indexOf(searchedText);\n    if (directIndex !== -1) {\n        return directIndex;\n    }\n    for(let i = text2.length - 1; i >= 0; i--){\n        const suffix = text2.substring(i);\n        if (searchedText.startsWith(suffix)) {\n            return i;\n        }\n    }\n    return null;\n}\n// src/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({ tagName, separator = \"\\n\", startWithReasoning = false }) {\n    const openingTag = `<${tagName}>`;\n    const closingTag = `</${tagName}>`;\n    return {\n        specificationVersion: \"v3\",\n        wrapGenerate: async ({ doGenerate })=>{\n            const { content, ...rest } = await doGenerate();\n            const transformedContent = [];\n            for (const part of content){\n                if (part.type !== \"text\") {\n                    transformedContent.push(part);\n                    continue;\n                }\n                const text2 = startWithReasoning ? openingTag + part.text : part.text;\n                const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n                const matches = Array.from(text2.matchAll(regexp));\n                if (!matches.length) {\n                    transformedContent.push(part);\n                    continue;\n                }\n                const reasoningText = matches.map((match)=>match[1]).join(separator);\n                let textWithoutReasoning = text2;\n                for(let i = matches.length - 1; i >= 0; i--){\n                    const match = matches[i];\n                    const beforeMatch = textWithoutReasoning.slice(0, match.index);\n                    const afterMatch = textWithoutReasoning.slice(match.index + match[0].length);\n                    textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n                }\n                transformedContent.push({\n                    type: \"reasoning\",\n                    text: reasoningText\n                });\n                transformedContent.push({\n                    type: \"text\",\n                    text: textWithoutReasoning\n                });\n            }\n            return {\n                content: transformedContent,\n                ...rest\n            };\n        },\n        wrapStream: async ({ doStream })=>{\n            const { stream, ...rest } = await doStream();\n            const reasoningExtractions = {};\n            let delayedTextStart;\n            return {\n                stream: stream.pipeThrough(new TransformStream({\n                    transform: (chunk, controller)=>{\n                        if (chunk.type === \"text-start\") {\n                            delayedTextStart = chunk;\n                            return;\n                        }\n                        if (chunk.type === \"text-end\" && delayedTextStart) {\n                            controller.enqueue(delayedTextStart);\n                            delayedTextStart = void 0;\n                        }\n                        if (chunk.type !== \"text-delta\") {\n                            controller.enqueue(chunk);\n                            return;\n                        }\n                        if (reasoningExtractions[chunk.id] == null) {\n                            reasoningExtractions[chunk.id] = {\n                                isFirstReasoning: true,\n                                isFirstText: true,\n                                afterSwitch: false,\n                                isReasoning: startWithReasoning,\n                                buffer: \"\",\n                                idCounter: 0,\n                                textId: chunk.id\n                            };\n                        }\n                        const activeExtraction = reasoningExtractions[chunk.id];\n                        activeExtraction.buffer += chunk.delta;\n                        function publish(text2) {\n                            if (text2.length > 0) {\n                                const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : \"\";\n                                if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {\n                                    controller.enqueue({\n                                        type: \"reasoning-start\",\n                                        id: `reasoning-${activeExtraction.idCounter}`\n                                    });\n                                }\n                                if (activeExtraction.isReasoning) {\n                                    controller.enqueue({\n                                        type: \"reasoning-delta\",\n                                        delta: prefix + text2,\n                                        id: `reasoning-${activeExtraction.idCounter}`\n                                    });\n                                } else {\n                                    if (delayedTextStart) {\n                                        controller.enqueue(delayedTextStart);\n                                        delayedTextStart = void 0;\n                                    }\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        delta: prefix + text2,\n                                        id: activeExtraction.textId\n                                    });\n                                }\n                                activeExtraction.afterSwitch = false;\n                                if (activeExtraction.isReasoning) {\n                                    activeExtraction.isFirstReasoning = false;\n                                } else {\n                                    activeExtraction.isFirstText = false;\n                                }\n                            }\n                        }\n                        do {\n                            const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;\n                            const startIndex = getPotentialStartIndex(activeExtraction.buffer, nextTag);\n                            if (startIndex == null) {\n                                publish(activeExtraction.buffer);\n                                activeExtraction.buffer = \"\";\n                                break;\n                            }\n                            publish(activeExtraction.buffer.slice(0, startIndex));\n                            const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;\n                            if (foundFullMatch) {\n                                activeExtraction.buffer = activeExtraction.buffer.slice(startIndex + nextTag.length);\n                                if (activeExtraction.isReasoning) {\n                                    controller.enqueue({\n                                        type: \"reasoning-end\",\n                                        id: `reasoning-${activeExtraction.idCounter++}`\n                                    });\n                                }\n                                activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                                activeExtraction.afterSwitch = true;\n                            } else {\n                                activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);\n                                break;\n                            }\n                        }while (true);\n                    }\n                })),\n                ...rest\n            };\n        }\n    };\n}\n// src/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n    return {\n        specificationVersion: \"v3\",\n        wrapStream: async ({ doGenerate })=>{\n            const result = await doGenerate();\n            let id = 0;\n            const simulatedStream = new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"stream-start\",\n                        warnings: result.warnings\n                    });\n                    controller.enqueue({\n                        type: \"response-metadata\",\n                        ...result.response\n                    });\n                    for (const part of result.content){\n                        switch(part.type){\n                            case \"text\":\n                                {\n                                    if (part.text.length > 0) {\n                                        controller.enqueue({\n                                            type: \"text-start\",\n                                            id: String(id)\n                                        });\n                                        controller.enqueue({\n                                            type: \"text-delta\",\n                                            id: String(id),\n                                            delta: part.text\n                                        });\n                                        controller.enqueue({\n                                            type: \"text-end\",\n                                            id: String(id)\n                                        });\n                                        id++;\n                                    }\n                                    break;\n                                }\n                            case \"reasoning\":\n                                {\n                                    controller.enqueue({\n                                        type: \"reasoning-start\",\n                                        id: String(id),\n                                        providerMetadata: part.providerMetadata\n                                    });\n                                    controller.enqueue({\n                                        type: \"reasoning-delta\",\n                                        id: String(id),\n                                        delta: part.text\n                                    });\n                                    controller.enqueue({\n                                        type: \"reasoning-end\",\n                                        id: String(id)\n                                    });\n                                    id++;\n                                    break;\n                                }\n                            default:\n                                {\n                                    controller.enqueue(part);\n                                    break;\n                                }\n                        }\n                    }\n                    controller.enqueue({\n                        type: \"finish\",\n                        finishReason: result.finishReason,\n                        usage: result.usage,\n                        providerMetadata: result.providerMetadata\n                    });\n                    controller.close();\n                }\n            });\n            return {\n                stream: simulatedStream,\n                request: result.request,\n                response: result.response\n            };\n        }\n    };\n}\n// src/middleware/add-tool-input-examples-middleware.ts\nfunction defaultFormatExample(example) {\n    return JSON.stringify(example.input);\n}\nfunction addToolInputExamplesMiddleware({ prefix = \"Input Examples:\", format = defaultFormatExample, remove = true } = {}) {\n    return {\n        specificationVersion: \"v3\",\n        transformParams: async ({ params })=>{\n            var _a17;\n            if (!((_a17 = params.tools) == null ? void 0 : _a17.length)) {\n                return params;\n            }\n            const transformedTools = params.tools.map((tool2)=>{\n                var _a18;\n                if (tool2.type !== \"function\" || !((_a18 = tool2.inputExamples) == null ? void 0 : _a18.length)) {\n                    return tool2;\n                }\n                const formattedExamples = tool2.inputExamples.map((example, index)=>format(example, index)).join(\"\\n\");\n                const examplesSection = `${prefix}\n${formattedExamples}`;\n                const toolDescription = tool2.description ? `${tool2.description}\n\n${examplesSection}` : examplesSection;\n                return {\n                    ...tool2,\n                    description: toolDescription,\n                    inputExamples: remove ? void 0 : tool2.inputExamples\n                };\n            });\n            return {\n                ...params,\n                tools: transformedTools\n            };\n        }\n    };\n}\n// src/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{\n    return [\n        ...asArray(middlewareArg)\n    ].reverse().reduce((wrappedModel, middleware)=>{\n        return doWrap({\n            model: wrappedModel,\n            middleware,\n            modelId,\n            providerId\n        });\n    }, model);\n};\nvar doWrap = ({ model, middleware: { transformParams, wrapGenerate, wrapStream, overrideProvider, overrideModelId, overrideSupportedUrls }, modelId, providerId })=>{\n    var _a17, _b, _c;\n    async function doTransform({ params, type }) {\n        return transformParams ? await transformParams({\n            params,\n            type,\n            model\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v3\",\n        provider: (_a17 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({\n            model\n        })) != null ? _a17 : model.provider,\n        modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({\n            model\n        })) != null ? _b : model.modelId,\n        supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({\n            model\n        })) != null ? _c : model.supportedUrls,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"generate\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                doStream,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        },\n        async doStream (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"stream\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapStream ? wrapStream({\n                doGenerate,\n                doStream,\n                params: transformedParams,\n                model\n            }) : doStream();\n        }\n    };\n};\n// src/middleware/wrap-embedding-model.ts\nvar wrapEmbeddingModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{\n    return [\n        ...asArray(middlewareArg)\n    ].reverse().reduce((wrappedModel, middleware)=>{\n        return doWrap2({\n            model: wrappedModel,\n            middleware,\n            modelId,\n            providerId\n        });\n    }, model);\n};\nvar doWrap2 = ({ model, middleware: { transformParams, wrapEmbed, overrideProvider, overrideModelId, overrideMaxEmbeddingsPerCall, overrideSupportsParallelCalls }, modelId, providerId })=>{\n    var _a17, _b, _c, _d;\n    async function doTransform({ params }) {\n        return transformParams ? await transformParams({\n            params,\n            model\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v3\",\n        provider: (_a17 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({\n            model\n        })) != null ? _a17 : model.provider,\n        modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({\n            model\n        })) != null ? _b : model.modelId,\n        maxEmbeddingsPerCall: (_c = overrideMaxEmbeddingsPerCall == null ? void 0 : overrideMaxEmbeddingsPerCall({\n            model\n        })) != null ? _c : model.maxEmbeddingsPerCall,\n        supportsParallelCalls: (_d = overrideSupportsParallelCalls == null ? void 0 : overrideSupportsParallelCalls({\n            model\n        })) != null ? _d : model.supportsParallelCalls,\n        async doEmbed (params) {\n            const transformedParams = await doTransform({\n                params\n            });\n            const doEmbed = async ()=>model.doEmbed(transformedParams);\n            return wrapEmbed ? wrapEmbed({\n                doEmbed,\n                params: transformedParams,\n                model\n            }) : doEmbed();\n        }\n    };\n};\n// src/middleware/wrap-image-model.ts\nvar wrapImageModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{\n    return [\n        ...asArray(middlewareArg)\n    ].reverse().reduce((wrappedModel, middleware)=>{\n        return doWrap3({\n            model: wrappedModel,\n            middleware,\n            modelId,\n            providerId\n        });\n    }, model);\n};\nvar doWrap3 = ({ model, middleware: { transformParams, wrapGenerate, overrideProvider, overrideModelId, overrideMaxImagesPerCall }, modelId, providerId })=>{\n    var _a17, _b, _c;\n    async function doTransform({ params }) {\n        return transformParams ? await transformParams({\n            params,\n            model\n        }) : params;\n    }\n    const maxImagesPerCallRaw = (_a17 = overrideMaxImagesPerCall == null ? void 0 : overrideMaxImagesPerCall({\n        model\n    })) != null ? _a17 : model.maxImagesPerCall;\n    const maxImagesPerCall = maxImagesPerCallRaw instanceof Function ? maxImagesPerCallRaw.bind(model) : maxImagesPerCallRaw;\n    return {\n        specificationVersion: \"v3\",\n        provider: (_b = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({\n            model\n        })) != null ? _b : model.provider,\n        modelId: (_c = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({\n            model\n        })) != null ? _c : model.modelId,\n        maxImagesPerCall,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        }\n    };\n};\n// src/model/as-provider-v3.ts\nfunction asProviderV3(provider) {\n    if (\"specificationVersion\" in provider && provider.specificationVersion === \"v3\") {\n        return provider;\n    }\n    const v2Provider = provider;\n    return {\n        specificationVersion: \"v3\",\n        languageModel: (modelId)=>asLanguageModelV3(v2Provider.languageModel(modelId)),\n        embeddingModel: (modelId)=>asEmbeddingModelV3(v2Provider.textEmbeddingModel(modelId)),\n        imageModel: (modelId)=>asImageModelV3(v2Provider.imageModel(modelId)),\n        transcriptionModel: v2Provider.transcriptionModel ? (modelId)=>asTranscriptionModelV3(v2Provider.transcriptionModel(modelId)) : void 0,\n        speechModel: v2Provider.speechModel ? (modelId)=>asSpeechModelV3(v2Provider.speechModel(modelId)) : void 0,\n        rerankingModel: void 0\n    };\n}\n// src/middleware/wrap-provider.ts\nfunction wrapProvider({ provider, languageModelMiddleware, imageModelMiddleware }) {\n    const providerV3 = asProviderV3(provider);\n    return {\n        specificationVersion: \"v3\",\n        languageModel: (modelId)=>wrapLanguageModel({\n                model: providerV3.languageModel(modelId),\n                middleware: languageModelMiddleware\n            }),\n        embeddingModel: providerV3.embeddingModel,\n        imageModel: (modelId)=>{\n            let model = providerV3.imageModel(modelId);\n            if (imageModelMiddleware != null) {\n                model = wrapImageModel({\n                    model,\n                    middleware: imageModelMiddleware\n                });\n            }\n            return model;\n        },\n        transcriptionModel: providerV3.transcriptionModel,\n        speechModel: providerV3.speechModel,\n        rerankingModel: providerV3.rerankingModel\n    };\n}\n// src/registry/custom-provider.ts\n\nfunction customProvider({ languageModels, embeddingModels, imageModels, transcriptionModels, speechModels, rerankingModels, fallbackProvider: fallbackProviderArg }) {\n    const fallbackProvider = fallbackProviderArg ? asProviderV3(fallbackProviderArg) : void 0;\n    return {\n        specificationVersion: \"v3\",\n        languageModel (modelId) {\n            if (languageModels != null && modelId in languageModels) {\n                return languageModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.languageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"languageModel\"\n            });\n        },\n        embeddingModel (modelId) {\n            if (embeddingModels != null && modelId in embeddingModels) {\n                return embeddingModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.embeddingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"embeddingModel\"\n            });\n        },\n        imageModel (modelId) {\n            if (imageModels != null && modelId in imageModels) {\n                return imageModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n                return fallbackProvider.imageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"imageModel\"\n            });\n        },\n        transcriptionModel (modelId) {\n            if (transcriptionModels != null && modelId in transcriptionModels) {\n                return transcriptionModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {\n                return fallbackProvider.transcriptionModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"transcriptionModel\"\n            });\n        },\n        speechModel (modelId) {\n            if (speechModels != null && modelId in speechModels) {\n                return speechModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {\n                return fallbackProvider.speechModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"speechModel\"\n            });\n        },\n        rerankingModel (modelId) {\n            if (rerankingModels != null && modelId in rerankingModels) {\n                return rerankingModels[modelId];\n            }\n            if (fallbackProvider == null ? void 0 : fallbackProvider.rerankingModel) {\n                return fallbackProvider.rerankingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"rerankingModel\"\n            });\n        }\n    };\n}\nvar experimental_customProvider = customProvider;\n// src/registry/no-such-provider-error.ts\n\nvar name16 = \"AI_NoSuchProviderError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){\n        super({\n            errorName: name16,\n            modelId,\n            modelType,\n            message\n        });\n        this[_a16] = true;\n        this.providerId = providerId;\n        this.availableProviders = availableProviders;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker16);\n    }\n};\n_a16 = symbol16;\n// src/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, { separator = \":\", languageModelMiddleware, imageModelMiddleware } = {}) {\n    const registry = new DefaultProviderRegistry({\n        separator,\n        languageModelMiddleware,\n        imageModelMiddleware\n    });\n    for (const [id, provider] of Object.entries(providers)){\n        registry.registerProvider({\n            id,\n            provider\n        });\n    }\n    return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n    constructor({ separator, languageModelMiddleware, imageModelMiddleware }){\n        this.providers = {};\n        this.separator = separator;\n        this.languageModelMiddleware = languageModelMiddleware;\n        this.imageModelMiddleware = imageModelMiddleware;\n    }\n    registerProvider({ id, provider }) {\n        this.providers[id] = provider;\n    }\n    getProvider(id, modelType) {\n        const provider = this.providers[id];\n        if (provider == null) {\n            throw new NoSuchProviderError({\n                modelId: id,\n                modelType,\n                providerId: id,\n                availableProviders: Object.keys(this.providers)\n            });\n        }\n        return provider;\n    }\n    splitId(id, modelType) {\n        const index = id.indexOf(this.separator);\n        if (index === -1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType,\n                message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n            });\n        }\n        return [\n            id.slice(0, index),\n            id.slice(index + this.separator.length)\n        ];\n    }\n    languageModel(id) {\n        var _a17, _b;\n        const [providerId, modelId] = this.splitId(id, \"languageModel\");\n        let model = (_b = (_a17 = this.getProvider(providerId, \"languageModel\")).languageModel) == null ? void 0 : _b.call(_a17, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"languageModel\"\n            });\n        }\n        if (this.languageModelMiddleware != null) {\n            model = wrapLanguageModel({\n                model,\n                middleware: this.languageModelMiddleware\n            });\n        }\n        return model;\n    }\n    embeddingModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"embeddingModel\");\n        const provider = this.getProvider(providerId, \"embeddingModel\");\n        const model = (_a17 = provider.embeddingModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"embeddingModel\"\n            });\n        }\n        return model;\n    }\n    imageModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"imageModel\");\n        const provider = this.getProvider(providerId, \"imageModel\");\n        let model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"imageModel\"\n            });\n        }\n        if (this.imageModelMiddleware != null) {\n            model = wrapImageModel({\n                model,\n                middleware: this.imageModelMiddleware\n            });\n        }\n        return model;\n    }\n    transcriptionModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"transcriptionModel\");\n        const provider = this.getProvider(providerId, \"transcriptionModel\");\n        const model = (_a17 = provider.transcriptionModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"transcriptionModel\"\n            });\n        }\n        return model;\n    }\n    speechModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"speechModel\");\n        const provider = this.getProvider(providerId, \"speechModel\");\n        const model = (_a17 = provider.speechModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"speechModel\"\n            });\n        }\n        return model;\n    }\n    rerankingModel(id) {\n        var _a17;\n        const [providerId, modelId] = this.splitId(id, \"rerankingModel\");\n        const provider = this.getProvider(providerId, \"rerankingModel\");\n        const model = (_a17 = provider.rerankingModel) == null ? void 0 : _a17.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"rerankingModel\"\n            });\n        }\n        return model;\n    }\n};\n// src/rerank/rerank.ts\nasync function rerank({ model, documents, query, topN, maxRetries: maxRetriesArg, abortSignal, headers, providerOptions, experimental_telemetry: telemetry }) {\n    if (documents.length === 0) {\n        return new DefaultRerankResult({\n            originalDocuments: [],\n            ranking: [],\n            providerMetadata: void 0,\n            response: {\n                timestamp: /* @__PURE__ */ new Date(),\n                modelId: model.modelId\n            }\n        });\n    }\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const documentsToSend = typeof documents[0] === \"string\" ? {\n        type: \"text\",\n        values: documents\n    } : {\n        type: \"object\",\n        values: documents\n    };\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.rerank\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.rerank\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.documents\": {\n                    input: ()=>documents.map((document)=>JSON.stringify(document))\n                }\n            }\n        }),\n        tracer,\n        fn: async ()=>{\n            var _a17, _b;\n            const { ranking, response, providerMetadata, warnings } = await retry(()=>recordSpan({\n                    name: \"ai.rerank.doRerank\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.rerank.doRerank\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.documents\": {\n                                input: ()=>documents.map((document)=>JSON.stringify(document))\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doRerankSpan)=>{\n                        const modelResponse = await model.doRerank({\n                            documents: documentsToSend,\n                            query,\n                            topN,\n                            providerOptions,\n                            abortSignal,\n                            headers\n                        });\n                        const ranking2 = modelResponse.ranking;\n                        doRerankSpan.setAttributes(await selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.ranking.type\": documentsToSend.type,\n                                \"ai.ranking\": {\n                                    output: ()=>ranking2.map((ranking3)=>JSON.stringify(ranking3))\n                                }\n                            }\n                        }));\n                        return {\n                            ranking: ranking2,\n                            providerMetadata: modelResponse.providerMetadata,\n                            response: modelResponse.response,\n                            warnings: modelResponse.warnings\n                        };\n                    }\n                }));\n            logWarnings({\n                warnings: warnings != null ? warnings : [],\n                provider: model.provider,\n                model: model.modelId\n            });\n            return new DefaultRerankResult({\n                originalDocuments: documents,\n                ranking: ranking.map((ranking2)=>({\n                        originalIndex: ranking2.index,\n                        score: ranking2.relevanceScore,\n                        document: documents[ranking2.index]\n                    })),\n                providerMetadata,\n                response: {\n                    id: response == null ? void 0 : response.id,\n                    timestamp: (_a17 = response == null ? void 0 : response.timestamp) != null ? _a17 : /* @__PURE__ */ new Date(),\n                    modelId: (_b = response == null ? void 0 : response.modelId) != null ? _b : model.modelId,\n                    headers: response == null ? void 0 : response.headers,\n                    body: response == null ? void 0 : response.body\n                }\n            });\n        }\n    });\n}\nvar DefaultRerankResult = class {\n    constructor(options){\n        this.originalDocuments = options.originalDocuments;\n        this.ranking = options.ranking;\n        this.response = options.response;\n        this.providerMetadata = options.providerMetadata;\n    }\n    get rerankedDocuments() {\n        return this.ranking.map((ranking)=>ranking.document);\n    }\n};\n// src/transcribe/transcribe.ts\n\n// src/error/no-transcript-generated-error.ts\n\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor(options){\n        super({\n            name: \"AI_NoTranscriptGeneratedError\",\n            message: \"No transcript generated.\"\n        });\n        this.responses = options.responses;\n    }\n};\n// src/transcribe/transcribe.ts\nasync function transcribe({ model, audio, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    const resolvedModel = resolveTranscriptionModel(model);\n    if (!resolvedModel) {\n        throw new Error(\"Model could not be resolved\");\n    }\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg,\n        abortSignal\n    });\n    const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers != null ? headers : {}, `ai/${VERSION}`);\n    const audioData = audio instanceof URL ? (await download({\n        url: audio\n    })).data : convertDataContentToUint8Array(audio);\n    const result = await retry(()=>{\n        var _a17;\n        return resolvedModel.doGenerate({\n            audio: audioData,\n            abortSignal,\n            headers: headersWithUserAgent,\n            providerOptions,\n            mediaType: (_a17 = detectMediaType({\n                data: audioData,\n                signatures: audioMediaTypeSignatures\n            })) != null ? _a17 : \"audio/wav\"\n        });\n    });\n    logWarnings({\n        warnings: result.warnings,\n        provider: resolvedModel.provider,\n        model: resolvedModel.modelId\n    });\n    if (!result.text) {\n        throw new NoTranscriptGeneratedError({\n            responses: [\n                result.response\n            ]\n        });\n    }\n    return new DefaultTranscriptionResult({\n        text: result.text,\n        segments: result.segments,\n        language: result.language,\n        durationInSeconds: result.durationInSeconds,\n        warnings: result.warnings,\n        responses: [\n            result.response\n        ],\n        providerMetadata: result.providerMetadata\n    });\n}\nvar DefaultTranscriptionResult = class {\n    constructor(options){\n        var _a17;\n        this.text = options.text;\n        this.segments = options.segments;\n        this.language = options.language;\n        this.durationInSeconds = options.durationInSeconds;\n        this.warnings = options.warnings;\n        this.responses = options.responses;\n        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n    }\n};\n// src/ui/call-completion-api.ts\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({ stream, onTextPart }) {\n    const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        await onTextPart(value);\n    }\n}\n// src/ui/call-completion-api.ts\nvar getOriginalFetch = ()=>fetch;\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamProtocol = \"data\", setCompletion, setLoading, setError, setAbortController, onFinish, onError, fetch: fetch2 = getOriginalFetch() }) {\n    var _a17;\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const response = await fetch2(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)({\n                \"Content-Type\": \"application/json\",\n                ...headers\n            }, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()),\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (!response.ok) {\n            throw new Error((_a17 = await response.text()) != null ? _a17 : \"Failed to fetch the chat response.\");\n        }\n        if (!response.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        switch(streamProtocol){\n            case \"text\":\n                {\n                    await processTextStream({\n                        stream: response.body,\n                        onTextPart: (chunk)=>{\n                            result += chunk;\n                            setCompletion(result);\n                        }\n                    });\n                    break;\n                }\n            case \"data\":\n                {\n                    await consumeStream({\n                        stream: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n                            stream: response.body,\n                            schema: uiMessageChunkSchema\n                        }).pipeThrough(new TransformStream({\n                            async transform (part) {\n                                if (!part.success) {\n                                    throw part.error;\n                                }\n                                const streamPart = part.value;\n                                if (streamPart.type === \"text-delta\") {\n                                    result += streamPart.delta;\n                                    setCompletion(result);\n                                } else if (streamPart.type === \"error\") {\n                                    throw new Error(streamPart.errorText);\n                                }\n                            }\n                        })),\n                        onError: (error)=>{\n                            throw error;\n                        }\n                    });\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamProtocol;\n                    throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// src/ui/chat.ts\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n    if (files == null) {\n        return [];\n    }\n    if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n        throw new Error(\"FileList is not supported in the current environment\");\n    }\n    return Promise.all(Array.from(files).map(async (file)=>{\n        const { name: name17, type } = file;\n        const dataUrl = await new Promise((resolve3, reject)=>{\n            const reader = new FileReader();\n            reader.onload = (readerEvent)=>{\n                var _a17;\n                resolve3((_a17 = readerEvent.target) == null ? void 0 : _a17.result);\n            };\n            reader.onerror = (error)=>reject(error);\n            reader.readAsDataURL(file);\n        });\n        return {\n            type: \"file\",\n            mediaType: type,\n            filename: name17,\n            url: dataUrl\n        };\n    }));\n}\n// src/ui/default-chat-transport.ts\n\n// src/ui/http-chat-transport.ts\n\nvar HttpChatTransport = class {\n    constructor({ api = \"/api/chat\", credentials, headers, body, fetch: fetch2, prepareSendMessagesRequest, prepareReconnectToStreamRequest }){\n        this.api = api;\n        this.credentials = credentials;\n        this.headers = headers;\n        this.body = body;\n        this.fetch = fetch2;\n        this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n        this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n    }\n    async sendMessages({ abortSignal, ...options }) {\n        var _a17, _b, _c, _d, _e;\n        const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n        const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n        const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n        const baseHeaders = {\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n        };\n        const preparedRequest = await ((_a17 = this.prepareSendMessagesRequest) == null ? void 0 : _a17.call(this, {\n            api: this.api,\n            id: options.chatId,\n            messages: options.messages,\n            body: {\n                ...resolvedBody,\n                ...options.body\n            },\n            headers: baseHeaders,\n            credentials: resolvedCredentials,\n            requestMetadata: options.metadata,\n            trigger: options.trigger,\n            messageId: options.messageId\n        }));\n        const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : this.api;\n        const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n        const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {\n            ...resolvedBody,\n            ...options.body,\n            id: options.chatId,\n            messages: options.messages,\n            trigger: options.trigger,\n            messageId: options.messageId\n        };\n        const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n        const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n        const response = await fetch2(api, {\n            method: \"POST\",\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)({\n                \"Content-Type\": \"application/json\",\n                ...headers\n            }, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()),\n            body: JSON.stringify(body),\n            credentials,\n            signal: abortSignal\n        });\n        if (!response.ok) {\n            throw new Error((_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\");\n        }\n        if (!response.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        return this.processResponseStream(response.body);\n    }\n    async reconnectToStream(options) {\n        var _a17, _b, _c, _d, _e;\n        const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n        const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n        const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n        const baseHeaders = {\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n            ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n        };\n        const preparedRequest = await ((_a17 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a17.call(this, {\n            api: this.api,\n            id: options.chatId,\n            body: {\n                ...resolvedBody,\n                ...options.body\n            },\n            headers: baseHeaders,\n            credentials: resolvedCredentials,\n            requestMetadata: options.metadata\n        }));\n        const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : `${this.api}/${options.chatId}/stream`;\n        const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n        const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n        const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n        const response = await fetch2(api, {\n            method: \"GET\",\n            headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(headers, `ai-sdk/${VERSION}`, (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()),\n            credentials\n        });\n        if (response.status === 204) {\n            return null;\n        }\n        if (!response.ok) {\n            throw new Error((_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\");\n        }\n        if (!response.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        return this.processResponseStream(response.body);\n    }\n};\n// src/ui/default-chat-transport.ts\nvar DefaultChatTransport = class extends HttpChatTransport {\n    constructor(options = {}){\n        super(options);\n    }\n    processResponseStream(stream) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n            stream,\n            schema: uiMessageChunkSchema\n        }).pipeThrough(new TransformStream({\n            async transform (chunk, controller) {\n                if (!chunk.success) {\n                    throw chunk.error;\n                }\n                controller.enqueue(chunk.value);\n            }\n        }));\n    }\n};\n// src/ui/chat.ts\nvar AbstractChat = class {\n    constructor({ generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId, id = generateId2(), transport = new DefaultChatTransport(), messageMetadataSchema, dataPartSchemas, state, onError, onToolCall, onFinish, onData, sendAutomaticallyWhen }){\n        this.activeResponse = void 0;\n        this.jobExecutor = new SerialJobExecutor();\n        /**\n     * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n     * the assistant's response.\n     *\n     * If a messageId is provided, the message will be replaced.\n     */ this.sendMessage = async (message, options)=>{\n            var _a17, _b, _c, _d;\n            if (message == null) {\n                await this.makeRequest({\n                    trigger: \"submit-message\",\n                    messageId: (_a17 = this.lastMessage) == null ? void 0 : _a17.id,\n                    ...options\n                });\n                return;\n            }\n            let uiMessage;\n            if (\"text\" in message || \"files\" in message) {\n                const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);\n                uiMessage = {\n                    parts: [\n                        ...fileParts,\n                        ...\"text\" in message && message.text != null ? [\n                            {\n                                type: \"text\",\n                                text: message.text\n                            }\n                        ] : []\n                    ]\n                };\n            } else {\n                uiMessage = message;\n            }\n            if (message.messageId != null) {\n                const messageIndex = this.state.messages.findIndex((m)=>m.id === message.messageId);\n                if (messageIndex === -1) {\n                    throw new Error(`message with id ${message.messageId} not found`);\n                }\n                if (this.state.messages[messageIndex].role !== \"user\") {\n                    throw new Error(`message with id ${message.messageId} is not a user message`);\n                }\n                this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n                this.state.replaceMessage(messageIndex, {\n                    ...uiMessage,\n                    id: message.messageId,\n                    role: (_b = uiMessage.role) != null ? _b : \"user\",\n                    metadata: message.metadata\n                });\n            } else {\n                this.state.pushMessage({\n                    ...uiMessage,\n                    id: (_c = uiMessage.id) != null ? _c : this.generateId(),\n                    role: (_d = uiMessage.role) != null ? _d : \"user\",\n                    metadata: message.metadata\n                });\n            }\n            await this.makeRequest({\n                trigger: \"submit-message\",\n                messageId: message.messageId,\n                ...options\n            });\n        };\n        /**\n     * Regenerate the assistant message with the provided message id.\n     * If no message id is provided, the last assistant message will be regenerated.\n     */ this.regenerate = async ({ messageId, ...options } = {})=>{\n            const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message)=>message.id === messageId);\n            if (messageIndex === -1) {\n                throw new Error(`message ${messageId} not found`);\n            }\n            this.state.messages = this.state.messages.slice(0, // if the message is a user message, we need to include it in the request:\n            this.messages[messageIndex].role === \"assistant\" ? messageIndex : messageIndex + 1);\n            await this.makeRequest({\n                trigger: \"regenerate-message\",\n                messageId,\n                ...options\n            });\n        };\n        /**\n     * Attempt to resume an ongoing streaming response.\n     */ this.resumeStream = async (options = {})=>{\n            await this.makeRequest({\n                trigger: \"resume-stream\",\n                ...options\n            });\n        };\n        /**\n     * Clear the error state and set the status to ready if the chat is in an error state.\n     */ this.clearError = ()=>{\n            if (this.status === \"error\") {\n                this.state.error = void 0;\n                this.setStatus({\n                    status: \"ready\"\n                });\n            }\n        };\n        this.addToolApprovalResponse = async ({ id, approved, reason })=>this.jobExecutor.run(async ()=>{\n                var _a17, _b;\n                const messages = this.state.messages;\n                const lastMessage = messages[messages.length - 1];\n                const updatePart = (part)=>isToolUIPart(part) && part.state === \"approval-requested\" && part.approval.id === id ? {\n                        ...part,\n                        state: \"approval-responded\",\n                        approval: {\n                            id,\n                            approved,\n                            reason\n                        }\n                    } : part;\n                this.state.replaceMessage(messages.length - 1, {\n                    ...lastMessage,\n                    parts: lastMessage.parts.map(updatePart)\n                });\n                if (this.activeResponse) {\n                    this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n                }\n                if (this.status !== \"streaming\" && this.status !== \"submitted\" && ((_a17 = this.sendAutomaticallyWhen) == null ? void 0 : _a17.call(this, {\n                    messages: this.state.messages\n                }))) {\n                    this.makeRequest({\n                        trigger: \"submit-message\",\n                        messageId: (_b = this.lastMessage) == null ? void 0 : _b.id\n                    });\n                }\n            });\n        this.addToolOutput = async ({ state = \"output-available\", tool: tool2, toolCallId, output, errorText })=>this.jobExecutor.run(async ()=>{\n                var _a17, _b;\n                const messages = this.state.messages;\n                const lastMessage = messages[messages.length - 1];\n                const updatePart = (part)=>isToolUIPart(part) && part.toolCallId === toolCallId ? {\n                        ...part,\n                        state,\n                        output,\n                        errorText\n                    } : part;\n                this.state.replaceMessage(messages.length - 1, {\n                    ...lastMessage,\n                    parts: lastMessage.parts.map(updatePart)\n                });\n                if (this.activeResponse) {\n                    this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n                }\n                if (this.status !== \"streaming\" && this.status !== \"submitted\" && ((_a17 = this.sendAutomaticallyWhen) == null ? void 0 : _a17.call(this, {\n                    messages: this.state.messages\n                }))) {\n                    this.makeRequest({\n                        trigger: \"submit-message\",\n                        messageId: (_b = this.lastMessage) == null ? void 0 : _b.id\n                    });\n                }\n            });\n        /** @deprecated Use addToolOutput */ this.addToolResult = this.addToolOutput;\n        /**\n     * Abort the current request immediately, keep the generated tokens if any.\n     */ this.stop = async ()=>{\n            var _a17;\n            if (this.status !== \"streaming\" && this.status !== \"submitted\") return;\n            if ((_a17 = this.activeResponse) == null ? void 0 : _a17.abortController) {\n                this.activeResponse.abortController.abort();\n            }\n        };\n        this.id = id;\n        this.transport = transport;\n        this.generateId = generateId2;\n        this.messageMetadataSchema = messageMetadataSchema;\n        this.dataPartSchemas = dataPartSchemas;\n        this.state = state;\n        this.onError = onError;\n        this.onToolCall = onToolCall;\n        this.onFinish = onFinish;\n        this.onData = onData;\n        this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n    }\n    /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */ get status() {\n        return this.state.status;\n    }\n    setStatus({ status, error }) {\n        if (this.status === status) return;\n        this.state.status = status;\n        this.state.error = error;\n    }\n    get error() {\n        return this.state.error;\n    }\n    get messages() {\n        return this.state.messages;\n    }\n    get lastMessage() {\n        return this.state.messages[this.state.messages.length - 1];\n    }\n    set messages(messages) {\n        this.state.messages = messages;\n    }\n    async makeRequest({ trigger, metadata, headers, body, messageId }) {\n        var _a17, _b, _c, _d;\n        this.setStatus({\n            status: \"submitted\",\n            error: void 0\n        });\n        const lastMessage = this.lastMessage;\n        let isAbort = false;\n        let isDisconnect = false;\n        let isError = false;\n        try {\n            const activeResponse = {\n                state: createStreamingUIMessageState({\n                    lastMessage: this.state.snapshot(lastMessage),\n                    messageId: this.generateId()\n                }),\n                abortController: new AbortController()\n            };\n            activeResponse.abortController.signal.addEventListener(\"abort\", ()=>{\n                isAbort = true;\n            });\n            this.activeResponse = activeResponse;\n            let stream;\n            if (trigger === \"resume-stream\") {\n                const reconnect = await this.transport.reconnectToStream({\n                    chatId: this.id,\n                    metadata,\n                    headers,\n                    body\n                });\n                if (reconnect == null) {\n                    this.setStatus({\n                        status: \"ready\"\n                    });\n                    return;\n                }\n                stream = reconnect;\n            } else {\n                stream = await this.transport.sendMessages({\n                    chatId: this.id,\n                    messages: this.state.messages,\n                    abortSignal: activeResponse.abortController.signal,\n                    metadata,\n                    headers,\n                    body,\n                    trigger,\n                    messageId\n                });\n            }\n            const runUpdateMessageJob = (job)=>// serialize the job execution to avoid race conditions:\n                this.jobExecutor.run(()=>job({\n                        state: activeResponse.state,\n                        write: ()=>{\n                            var _a18;\n                            this.setStatus({\n                                status: \"streaming\"\n                            });\n                            const replaceLastMessage = activeResponse.state.message.id === ((_a18 = this.lastMessage) == null ? void 0 : _a18.id);\n                            if (replaceLastMessage) {\n                                this.state.replaceMessage(this.state.messages.length - 1, activeResponse.state.message);\n                            } else {\n                                this.state.pushMessage(activeResponse.state.message);\n                            }\n                        }\n                    }));\n            await consumeStream({\n                stream: processUIMessageStream({\n                    stream,\n                    onToolCall: this.onToolCall,\n                    onData: this.onData,\n                    messageMetadataSchema: this.messageMetadataSchema,\n                    dataPartSchemas: this.dataPartSchemas,\n                    runUpdateMessageJob,\n                    onError: (error)=>{\n                        throw error;\n                    }\n                }),\n                onError: (error)=>{\n                    throw error;\n                }\n            });\n            this.setStatus({\n                status: \"ready\"\n            });\n        } catch (err) {\n            if (isAbort || err.name === \"AbortError\") {\n                isAbort = true;\n                this.setStatus({\n                    status: \"ready\"\n                });\n                return null;\n            }\n            isError = true;\n            if (err instanceof TypeError && (err.message.toLowerCase().includes(\"fetch\") || err.message.toLowerCase().includes(\"network\"))) {\n                isDisconnect = true;\n            }\n            if (this.onError && err instanceof Error) {\n                this.onError(err);\n            }\n            this.setStatus({\n                status: \"error\",\n                error: err\n            });\n        } finally{\n            try {\n                (_b = this.onFinish) == null ? void 0 : _b.call(this, {\n                    message: this.activeResponse.state.message,\n                    messages: this.state.messages,\n                    isAbort,\n                    isDisconnect,\n                    isError,\n                    finishReason: (_a17 = this.activeResponse) == null ? void 0 : _a17.state.finishReason\n                });\n            } catch (err) {\n                console.error(err);\n            }\n            this.activeResponse = void 0;\n        }\n        if (((_c = this.sendAutomaticallyWhen) == null ? void 0 : _c.call(this, {\n            messages: this.state.messages\n        })) && !isError) {\n            await this.makeRequest({\n                trigger: \"submit-message\",\n                messageId: (_d = this.lastMessage) == null ? void 0 : _d.id,\n                metadata,\n                headers,\n                body\n            });\n        }\n    }\n};\n// src/ui/direct-chat-transport.ts\nvar DirectChatTransport = class {\n    constructor({ agent, options, ...uiMessageStreamOptions }){\n        this.agent = agent;\n        this.agentOptions = options;\n        this.uiMessageStreamOptions = uiMessageStreamOptions;\n    }\n    async sendMessages({ messages, abortSignal }) {\n        const validatedMessages = await validateUIMessages({\n            messages,\n            tools: this.agent.tools\n        });\n        const modelMessages = await convertToModelMessages(validatedMessages, {\n            tools: this.agent.tools\n        });\n        const result = await this.agent.stream({\n            prompt: modelMessages,\n            abortSignal,\n            ...this.agentOptions !== void 0 ? {\n                options: this.agentOptions\n            } : {}\n        });\n        return result.toUIMessageStream(this.uiMessageStreamOptions);\n    }\n    /**\n   * Direct transport does not support reconnection since there is no\n   * persistent server-side stream to reconnect to.\n   *\n   * @returns Always returns `null`\n   */ async reconnectToStream(_options) {\n        return null;\n    }\n};\n// src/ui/last-assistant-message-is-complete-with-approval-responses.ts\nfunction lastAssistantMessageIsCompleteWithApprovalResponses({ messages }) {\n    const message = messages[messages.length - 1];\n    if (!message) {\n        return false;\n    }\n    if (message.role !== \"assistant\") {\n        return false;\n    }\n    const lastStepStartIndex = message.parts.reduce((lastIndex, part, index)=>{\n        return part.type === \"step-start\" ? index : lastIndex;\n    }, -1);\n    const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part)=>!part.providerExecuted);\n    return(// has at least one tool approval response\n    lastStepToolInvocations.filter((part)=>part.state === \"approval-responded\").length > 0 && // all tool approvals must have a response\n    lastStepToolInvocations.every((part)=>part.state === \"output-available\" || part.state === \"output-error\" || part.state === \"approval-responded\"));\n}\n// src/ui/last-assistant-message-is-complete-with-tool-calls.ts\nfunction lastAssistantMessageIsCompleteWithToolCalls({ messages }) {\n    const message = messages[messages.length - 1];\n    if (!message) {\n        return false;\n    }\n    if (message.role !== \"assistant\") {\n        return false;\n    }\n    const lastStepStartIndex = message.parts.reduce((lastIndex, part, index)=>{\n        return part.type === \"step-start\" ? index : lastIndex;\n    }, -1);\n    const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part)=>!part.providerExecuted);\n    return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part)=>part.state === \"output-available\" || part.state === \"output-error\");\n}\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({ stream }) {\n    return stream.pipeThrough(new TransformStream({\n        start (controller) {\n            controller.enqueue({\n                type: \"start\"\n            });\n            controller.enqueue({\n                type: \"start-step\"\n            });\n            controller.enqueue({\n                type: \"text-start\",\n                id: \"text-1\"\n            });\n        },\n        async transform (part, controller) {\n            controller.enqueue({\n                type: \"text-delta\",\n                id: \"text-1\",\n                delta: part\n            });\n        },\n        async flush (controller) {\n            controller.enqueue({\n                type: \"text-end\",\n                id: \"text-1\"\n            });\n            controller.enqueue({\n                type: \"finish-step\"\n            });\n            controller.enqueue({\n                type: \"finish\"\n            });\n        }\n    }));\n}\n// src/ui/text-stream-chat-transport.ts\nvar TextStreamChatTransport = class extends HttpChatTransport {\n    constructor(options = {}){\n        super(options);\n    }\n    processResponseStream(stream) {\n        return transformTextToUiMessageStream({\n            stream: stream.pipeThrough(new TextDecoderStream())\n        });\n    }\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlANi4wLjM5X3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFVBQVVELElBQ2pCTCxVQUFVSSxRQUFRRSxRQUFRO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsT0FBTztRQUFFRSxZQUFZO0lBQUs7QUFDbkU7QUFFQSxlQUFlO0FBQ3NEO0FBVXJDO0FBRWhDLHFDQUFxQztBQUtMO0FBRWhDLHFCQUFxQjtBQWVLO0FBRTFCLHNDQUFzQztBQUNRO0FBQzlDLElBQUlrQyxPQUFPO0FBQ1gsSUFBSUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFRCxLQUFLLENBQUM7QUFDdEMsSUFBSUUsU0FBU0MsT0FBT0MsR0FBRyxDQUFDSDtBQUN4QixJQUFJSTtBQUNKLElBQUlDLHVCQUF1QixjQUFjcEIsd0RBQVVBO0lBQ2pEcUIsWUFBWSxFQUNWQyxTQUFTLEVBQ1RDLEtBQUssRUFDTEMsT0FBTyxFQUNSLENBQUU7UUFDRCxLQUFLLENBQUM7WUFDSlY7WUFDQVUsU0FBUyxDQUFDLCtCQUErQixFQUFFRixVQUFVLEVBQUUsRUFBRUUsUUFBUSxDQUFDO1FBQ3BFO1FBQ0EsSUFBSSxDQUFDTCxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNHLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2Y7SUFDQSxPQUFPRSxXQUFXQyxLQUFLLEVBQUU7UUFDdkIsT0FBTzFCLHdEQUFVQSxDQUFDMkIsU0FBUyxDQUFD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QUFLO1FBQ3JFO1FBQ0EsTUFBTTRkLE9BQU12bEIsVUFBVTtZQUNwQkEsV0FBV0MsT0FBTyxDQUFDO2dCQUFFbEMsTUFBTTtnQkFBWW9OLElBQUk7WUFBUztZQUNwRG5MLFdBQVdDLE9BQU8sQ0FBQztnQkFBRWxDLE1BQU07WUFBYztZQUN6Q2lDLFdBQVdDLE9BQU8sQ0FBQztnQkFBRWxDLE1BQU07WUFBUztRQUN0QztJQUNGO0FBRUo7QUFFQSx1Q0FBdUM7QUFDdkMsSUFBSW8wQywwQkFBMEIsY0FBY3BEO0lBQzFDajVDLFlBQVkrRCxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ3hCLEtBQUssQ0FBQ0E7SUFDUjtJQUNBODFDLHNCQUFzQmh3QyxNQUFNLEVBQUU7UUFDNUIsT0FBT3V5QywrQkFBK0I7WUFDcEN2eUMsUUFBUUEsT0FBT0UsV0FBVyxDQUFDLElBQUl1dEM7UUFDakM7SUFDRjtBQUNGO0FBMEhFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VudGluZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlANi4wLjM5X3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz9lNGEwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZTE3IGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lMTcsIHsgZ2V0OiBhbGxbbmFtZTE3XSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgY3JlYXRlR2F0ZXdheSwgZ2F0ZXdheSBhcyBnYXRld2F5MiB9IGZyb20gXCJAYWktc2RrL2dhdGV3YXlcIjtcbmltcG9ydCB7XG4gIGFzU2NoZW1hIGFzIGFzU2NoZW1hNSxcbiAgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3I1LFxuICBkeW5hbWljVG9vbCxcbiAgZ2VuZXJhdGVJZCxcbiAganNvblNjaGVtYSxcbiAgcGFyc2VKc29uRXZlbnRTdHJlYW0gYXMgcGFyc2VKc29uRXZlbnRTdHJlYW0zLFxuICB0b29sLFxuICB6b2RTY2hlbWEgYXMgem9kU2NoZW1hM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5pbXBvcnQge1xuICBjcmVhdGVJZEdlbmVyYXRvcixcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTUsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Vycm9yL2luZGV4LnRzXG5pbXBvcnQge1xuICBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOCxcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9JbnZhbGlkQXJndW1lbnRFcnJvclwiO1xudmFyIG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcmFtZXRlcixcbiAgICB2YWx1ZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lLFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gXG4gICAgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC1zdHJlYW0tcGFydC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTIgPSBcIkFJX0ludmFsaWRTdHJlYW1QYXJ0RXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIEludmFsaWRTdHJlYW1QYXJ0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNodW5rLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLXRvb2wtYXBwcm92YWwtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkVG9vbEFwcHJvdmFsRXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEludmFsaWRUb29sQXBwcm92YWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7IGFwcHJvdmFsSWQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUzLFxuICAgICAgbWVzc2FnZTogYFRvb2wgYXBwcm92YWwgcmVzcG9uc2UgcmVmZXJlbmNlcyB1bmtub3duIGFwcHJvdmFsSWQ6IFwiJHthcHByb3ZhbElkfVwiLiBObyBtYXRjaGluZyB0b29sLWFwcHJvdmFsLXJlcXVlc3QgZm91bmQgaW4gbWVzc2FnZSBoaXN0b3J5LmBcbiAgICB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICAgIHRoaXMuYXBwcm92YWxJZCA9IGFwcHJvdmFsSWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjMuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLXRvb2wtaW5wdXQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjQsIGdldEVycm9yTWVzc2FnZSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRUb29sSW5wdXRFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgSW52YWxpZFRvb2xJbnB1dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sSW5wdXQsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0IGZvciB0b29sICR7dG9vbE5hbWV9OiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xJbnB1dCA9IHRvb2xJbnB1dDtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG5cbi8vIHNyYy9lcnJvci90b29sLWNhbGwtbm90LWZvdW5kLWZvci1hcHByb3ZhbC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTUgPSBcIkFJX1Rvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBUb29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbENhbGxJZCxcbiAgICBhcHByb3ZhbElkXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNSxcbiAgICAgIG1lc3NhZ2U6IGBUb29sIGNhbGwgXCIke3Rvb2xDYWxsSWR9XCIgbm90IGZvdW5kIGZvciBhcHByb3ZhbCByZXF1ZXN0IFwiJHthcHByb3ZhbElkfVwiLmBcbiAgICB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMudG9vbENhbGxJZCA9IHRvb2xDYWxsSWQ7XG4gICAgdGhpcy5hcHByb3ZhbElkID0gYXBwcm92YWxJZDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gc3JjL2Vycm9yL25vLWltYWdlLWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTYgPSBcIkFJX05vSW1hZ2VHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgTm9JbWFnZUdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBpbWFnZSBnZW5lcmF0ZWQuXCIsXG4gICAgY2F1c2UsXG4gICAgcmVzcG9uc2VzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU2LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICAgIHRoaXMucmVzcG9uc2VzID0gcmVzcG9uc2VzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBzcmMvZXJyb3Ivbm8tb2JqZWN0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTcgPSBcIkFJX05vT2JqZWN0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I3IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIG9iamVjdCBnZW5lcmF0ZWQuXCIsXG4gICAgY2F1c2UsXG4gICAgdGV4dDogdGV4dDIsXG4gICAgcmVzcG9uc2UsXG4gICAgdXNhZ2UsXG4gICAgZmluaXNoUmVhc29uXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICAgIHRoaXMudGV4dCA9IHRleHQyO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBmaW5pc2hSZWFzb247XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIHNyYy9lcnJvci9uby1vdXRwdXQtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOCA9IFwiQUlfTm9PdXRwdXRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTm9PdXRwdXRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjgge1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIG91dHB1dCBnZW5lcmF0ZWQuXCIsXG4gICAgY2F1c2VcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gc3JjL2Vycm9yL25vLXNwZWVjaC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I5IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfTm9TcGVlY2hHZW5lcmF0ZWRFcnJvclwiLFxuICAgICAgbWVzc2FnZTogXCJObyBzcGVlY2ggYXVkaW8gZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9yL25vLXN1Y2gtdG9vbC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU5ID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIE5vU3VjaFRvb2xFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEwIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xOYW1lLFxuICAgIGF2YWlsYWJsZVRvb2xzID0gdm9pZCAwLFxuICAgIG1lc3NhZ2UgPSBgTW9kZWwgdHJpZWQgdG8gY2FsbCB1bmF2YWlsYWJsZSB0b29sICcke3Rvb2xOYW1lfScuICR7YXZhaWxhYmxlVG9vbHMgPT09IHZvaWQgMCA/IFwiTm8gdG9vbHMgYXJlIGF2YWlsYWJsZS5cIiA6IGBBdmFpbGFibGUgdG9vbHM6ICR7YXZhaWxhYmxlVG9vbHMuam9pbihcIiwgXCIpfS5gfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjkpO1xuICB9XG59O1xuX2E5ID0gc3ltYm9sOTtcblxuLy8gc3JjL2Vycm9yL3Rvb2wtY2FsbC1yZXBhaXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjExLCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTEwID0gXCJBSV9Ub29sQ2FsbFJlcGFpckVycm9yXCI7XG52YXIgbWFya2VyMTAgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xudmFyIFRvb2xDYWxsUmVwYWlyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYXVzZSxcbiAgICBvcmlnaW5hbEVycm9yLFxuICAgIG1lc3NhZ2UgPSBgRXJyb3IgcmVwYWlyaW5nIHRvb2wgY2FsbDogJHtnZXRFcnJvck1lc3NhZ2UyKGNhdXNlKX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTEuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIHNyYy9lcnJvci91bnN1cHBvcnRlZC1tb2RlbC12ZXJzaW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvclwiLFxuICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIG1vZGVsIHZlcnNpb24gJHtvcHRpb25zLnZlcnNpb259IGZvciBwcm92aWRlciBcIiR7b3B0aW9ucy5wcm92aWRlcn1cIiBhbmQgbW9kZWwgXCIke29wdGlvbnMubW9kZWxJZH1cIi4gQUkgU0RLIDUgb25seSBzdXBwb3J0cyBtb2RlbHMgdGhhdCBpbXBsZW1lbnQgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIFwidjJcIi5gXG4gICAgfSk7XG4gICAgdGhpcy52ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9yL3VpLW1lc3NhZ2Utc3RyZWFtLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTExID0gXCJBSV9VSU1lc3NhZ2VTdHJlYW1FcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBVSU1lc3NhZ2VTdHJlYW1FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNodW5rVHlwZSxcbiAgICBjaHVua0lkLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTExLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMuY2h1bmtUeXBlID0gY2h1bmtUeXBlO1xuICAgIHRoaXMuY2h1bmtJZCA9IGNodW5rSWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjEzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTEpO1xuICB9XG59O1xuX2ExMSA9IHN5bWJvbDExO1xuXG4vLyBzcmMvcHJvbXB0L2ludmFsaWQtZGF0YS1jb250ZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTEyID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjEyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMn1gO1xudmFyIHN5bWJvbDEyID0gU3ltYm9sLmZvcihtYXJrZXIxMik7XG52YXIgX2ExMjtcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTEyLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEyKTtcbiAgfVxufTtcbl9hMTIgPSBzeW1ib2wxMjtcblxuLy8gc3JjL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMyA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXIxMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxMyA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xudmFyIF9hMTM7XG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEzKTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcblxuLy8gc3JjL3Byb21wdC9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTQgPSBcIkFJX01lc3NhZ2VDb252ZXJzaW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTR9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgTWVzc2FnZUNvbnZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG9yaWdpbmFsTWVzc2FnZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTRdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTYuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNCk7XG4gIH1cbn07XG5fYTE0ID0gc3ltYm9sMTQ7XG5cbi8vIHNyYy9lcnJvci9pbmRleC50c1xuaW1wb3J0IHsgRG93bmxvYWRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL3JldHJ5LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE1ID0gXCJBSV9SZXRyeUVycm9yXCI7XG52YXIgbWFya2VyMTUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE1fWA7XG52YXIgc3ltYm9sMTUgPSBTeW1ib2wuZm9yKG1hcmtlcjE1KTtcbnZhciBfYTE1O1xudmFyIFJldHJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE1LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExNV0gPSB0cnVlO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSk7XG4gIH1cbn07XG5fYTE1ID0gc3ltYm9sMTU7XG5cbi8vIHNyYy9sb2dnZXIvbG9nLXdhcm5pbmdzLnRzXG5mdW5jdGlvbiBmb3JtYXRXYXJuaW5nKHtcbiAgd2FybmluZyxcbiAgcHJvdmlkZXIsXG4gIG1vZGVsXG59KSB7XG4gIGNvbnN0IHByZWZpeCA9IGBBSSBTREsgV2FybmluZyAoJHtwcm92aWRlcn0gLyAke21vZGVsfSk6YDtcbiAgc3dpdGNoICh3YXJuaW5nLnR5cGUpIHtcbiAgICBjYXNlIFwidW5zdXBwb3J0ZWRcIjoge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtwcmVmaXh9IFRoZSBmZWF0dXJlIFwiJHt3YXJuaW5nLmZlYXR1cmV9XCIgaXMgbm90IHN1cHBvcnRlZC5gO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgJHt3YXJuaW5nLmRldGFpbHN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBjYXNlIFwiY29tcGF0aWJpbGl0eVwiOiB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGAke3ByZWZpeH0gVGhlIGZlYXR1cmUgXCIke3dhcm5pbmcuZmVhdHVyZX1cIiBpcyB1c2VkIGluIGEgY29tcGF0aWJpbGl0eSBtb2RlLmA7XG4gICAgICBpZiAod2FybmluZy5kZXRhaWxzKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCAke3dhcm5pbmcuZGV0YWlsc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNhc2UgXCJvdGhlclwiOiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke3dhcm5pbmcubWVzc2FnZX1gO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke0pTT04uc3RyaW5naWZ5KHdhcm5pbmcsIG51bGwsIDIpfWA7XG4gICAgfVxuICB9XG59XG52YXIgRklSU1RfV0FSTklOR19JTkZPX01FU1NBR0UgPSBcIkFJIFNESyBXYXJuaW5nIFN5c3RlbTogVG8gdHVybiBvZmYgd2FybmluZyBsb2dnaW5nLCBzZXQgdGhlIEFJX1NES19MT0dfV0FSTklOR1MgZ2xvYmFsIHRvIGZhbHNlLlwiO1xudmFyIGhhc0xvZ2dlZEJlZm9yZSA9IGZhbHNlO1xudmFyIGxvZ1dhcm5pbmdzID0gKG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMud2FybmluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxvZ2dlciA9IGdsb2JhbFRoaXMuQUlfU0RLX0xPR19XQVJOSU5HUztcbiAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBsb2dnZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxvZ2dlcihvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFoYXNMb2dnZWRCZWZvcmUpIHtcbiAgICBoYXNMb2dnZWRCZWZvcmUgPSB0cnVlO1xuICAgIGNvbnNvbGUuaW5mbyhGSVJTVF9XQVJOSU5HX0lORk9fTUVTU0FHRSk7XG4gIH1cbiAgZm9yIChjb25zdCB3YXJuaW5nIG9mIG9wdGlvbnMud2FybmluZ3MpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBmb3JtYXRXYXJuaW5nKHtcbiAgICAgICAgd2FybmluZyxcbiAgICAgICAgcHJvdmlkZXI6IG9wdGlvbnMucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9tb2RlbC9yZXNvbHZlLW1vZGVsLnRzXG5pbXBvcnQgeyBnYXRld2F5IH0gZnJvbSBcIkBhaS1zZGsvZ2F0ZXdheVwiO1xuXG4vLyBzcmMvdXRpbC9sb2ctdjItY29tcGF0aWJpbGl0eS13YXJuaW5nLnRzXG5mdW5jdGlvbiBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgcHJvdmlkZXIsXG4gIG1vZGVsSWRcbn0pIHtcbiAgbG9nV2FybmluZ3Moe1xuICAgIHdhcm5pbmdzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiY29tcGF0aWJpbGl0eVwiLFxuICAgICAgICBmZWF0dXJlOiBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIsXG4gICAgICAgIGRldGFpbHM6IGBVc2luZyB2MiBzcGVjaWZpY2F0aW9uIGNvbXBhdGliaWxpdHkgbW9kZS4gU29tZSBmZWF0dXJlcyBtYXkgbm90IGJlIGF2YWlsYWJsZS5gXG4gICAgICB9XG4gICAgXSxcbiAgICBwcm92aWRlcixcbiAgICBtb2RlbDogbW9kZWxJZFxuICB9KTtcbn1cblxuLy8gc3JjL21vZGVsL2FzLWVtYmVkZGluZy1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNFbWJlZGRpbmdNb2RlbFYzKG1vZGVsKSB7XG4gIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9PT0gXCJ2M1wiKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGxvZ1YyQ29tcGF0aWJpbGl0eVdhcm5pbmcoe1xuICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gIH0pO1xuICByZXR1cm4gbmV3IFByb3h5KG1vZGVsLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHByb3AgPT09IFwic3BlY2lmaWNhdGlvblZlcnNpb25cIilcbiAgICAgICAgcmV0dXJuIFwidjNcIjtcbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL21vZGVsL2FzLWltYWdlLW1vZGVsLXYzLnRzXG5mdW5jdGlvbiBhc0ltYWdlTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1sYW5ndWFnZS1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNMYW5ndWFnZU1vZGVsVjMobW9kZWwpIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJveHkobW9kZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCI6XG4gICAgICAgICAgcmV0dXJuIFwidjNcIjtcbiAgICAgICAgY2FzZSBcImRvR2VuZXJhdGVcIjpcbiAgICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRhcmdldC5kb0dlbmVyYXRlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnZlcnRWMkZpbmlzaFJlYXNvblRvVjMocmVzdWx0LmZpbmlzaFJlYXNvbiksXG4gICAgICAgICAgICAgIHVzYWdlOiBjb252ZXJ0VjJVc2FnZVRvVjMocmVzdWx0LnVzYWdlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZG9TdHJlYW1cIjpcbiAgICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRhcmdldC5kb1N0cmVhbSguLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgc3RyZWFtOiBjb252ZXJ0VjJTdHJlYW1Ub1YzKHJlc3VsdC5zdHJlYW0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY29udmVydFYyU3RyZWFtVG9WMyhzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjb252ZXJ0VjJGaW5pc2hSZWFzb25Ub1YzKGNodW5rLmZpbmlzaFJlYXNvbiksXG4gICAgICAgICAgICAgIHVzYWdlOiBjb252ZXJ0VjJVc2FnZVRvVjMoY2h1bmsudXNhZ2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFYyRmluaXNoUmVhc29uVG9WMyhmaW5pc2hSZWFzb24pIHtcbiAgcmV0dXJuIHtcbiAgICB1bmlmaWVkOiBmaW5pc2hSZWFzb24gPT09IFwidW5rbm93blwiID8gXCJvdGhlclwiIDogZmluaXNoUmVhc29uLFxuICAgIHJhdzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VjJVc2FnZVRvVjModXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2Vuczoge1xuICAgICAgdG90YWw6IHVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgbm9DYWNoZTogdm9pZCAwLFxuICAgICAgY2FjaGVSZWFkOiB1c2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgIGNhY2hlV3JpdGU6IHZvaWQgMFxuICAgIH0sXG4gICAgb3V0cHV0VG9rZW5zOiB7XG4gICAgICB0b3RhbDogdXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgcmVhc29uaW5nOiB1c2FnZS5yZWFzb25pbmdUb2tlbnNcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1zcGVlY2gtbW9kZWwtdjMudHNcbmZ1bmN0aW9uIGFzU3BlZWNoTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy10cmFuc2NyaXB0aW9uLW1vZGVsLXYzLnRzXG5mdW5jdGlvbiBhc1RyYW5zY3JpcHRpb25Nb2RlbFYzKG1vZGVsKSB7XG4gIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9PT0gXCJ2M1wiKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGxvZ1YyQ29tcGF0aWJpbGl0eVdhcm5pbmcoe1xuICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gIH0pO1xuICByZXR1cm4gbmV3IFByb3h5KG1vZGVsLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHByb3AgPT09IFwic3BlY2lmaWNhdGlvblZlcnNpb25cIilcbiAgICAgICAgcmV0dXJuIFwidjNcIjtcbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL21vZGVsL3Jlc29sdmUtbW9kZWwudHNcbmZ1bmN0aW9uIHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNMYW5ndWFnZU1vZGVsVjMobW9kZWwpO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLmxhbmd1YWdlTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVtYmVkZGluZ01vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNFbWJlZGRpbmdNb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gZ2V0R2xvYmFsUHJvdmlkZXIoKS5lbWJlZGRpbmdNb2RlbChtb2RlbCk7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsKSB7XG4gIHZhciBfYTE3LCBfYjtcbiAgaWYgKHR5cGVvZiBtb2RlbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2M1wiICYmIG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICAgIGNvbnN0IHVuc3VwcG9ydGVkTW9kZWwgPSBtb2RlbDtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yKHtcbiAgICAgICAgdmVyc2lvbjogdW5zdXBwb3J0ZWRNb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IHVuc3VwcG9ydGVkTW9kZWwucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsSWQ6IHVuc3VwcG9ydGVkTW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhc1RyYW5zY3JpcHRpb25Nb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gKF9iID0gKF9hMTcgPSBnZXRHbG9iYWxQcm92aWRlcigpKS50cmFuc2NyaXB0aW9uTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMTcsIG1vZGVsKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTcGVlY2hNb2RlbChtb2RlbCkge1xuICB2YXIgX2ExNywgX2I7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNTcGVlY2hNb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gKF9iID0gKF9hMTcgPSBnZXRHbG9iYWxQcm92aWRlcigpKS5zcGVlY2hNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2ExNywgbW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUltYWdlTW9kZWwobW9kZWwpIHtcbiAgaWYgKHR5cGVvZiBtb2RlbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2M1wiICYmIG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICAgIGNvbnN0IHVuc3VwcG9ydGVkTW9kZWwgPSBtb2RlbDtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yKHtcbiAgICAgICAgdmVyc2lvbjogdW5zdXBwb3J0ZWRNb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IHVuc3VwcG9ydGVkTW9kZWwucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsSWQ6IHVuc3VwcG9ydGVkTW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhc0ltYWdlTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIGdldEdsb2JhbFByb3ZpZGVyKCkuaW1hZ2VNb2RlbChtb2RlbCk7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxQcm92aWRlcigpIHtcbiAgdmFyIF9hMTc7XG4gIHJldHVybiAoX2ExNyA9IGdsb2JhbFRoaXMuQUlfU0RLX0RFRkFVTFRfUFJPVklERVIpICE9IG51bGwgPyBfYTE3IDogZ2F0ZXdheTtcbn1cblxuLy8gc3JjL3Byb21wdC9jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBnZXRUb3RhbFRpbWVvdXRNcyh0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB0aW1lb3V0O1xuICB9XG4gIHJldHVybiB0aW1lb3V0LnRvdGFsTXM7XG59XG5mdW5jdGlvbiBnZXRTdGVwVGltZW91dE1zKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQgPT0gbnVsbCB8fCB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHRpbWVvdXQuc3RlcE1zO1xufVxuZnVuY3Rpb24gZ2V0Q2h1bmtUaW1lb3V0TXModGltZW91dCkge1xuICBpZiAodGltZW91dCA9PSBudWxsIHx8IHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gdGltZW91dC5jaHVua01zO1xufVxuXG4vLyBzcmMvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5pbXBvcnQge1xuICBpc1VybFN1cHBvcnRlZFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9kZXRlY3QtbWVkaWEtdHlwZS50c1xuaW1wb3J0IHsgY29udmVydEJhc2U2NFRvVWludDhBcnJheSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzID0gW1xuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2dpZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzEsIDczLCA3MF1cbiAgICAvLyBHSUZcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9wbmdcIixcbiAgICBieXRlc1ByZWZpeDogWzEzNywgODAsIDc4LCA3MV1cbiAgICAvLyBQTkdcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9qcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDIxNl1cbiAgICAvLyBKUEVHXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2Uvd2VicFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICA4MixcbiAgICAgIDczLFxuICAgICAgNzAsXG4gICAgICA3MCxcbiAgICAgIC8vIFwiUklGRlwiXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgLy8gZmlsZSBzaXplICh2YXJpYWJsZSlcbiAgICAgIDg3LFxuICAgICAgNjksXG4gICAgICA2NixcbiAgICAgIDgwXG4gICAgICAvLyBcIldFQlBcIlxuICAgIF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9ibXBcIixcbiAgICBieXRlc1ByZWZpeDogWzY2LCA3N11cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS90aWZmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MywgNzMsIDQyLCAwXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzc3LCA3NywgMCwgNDJdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvYXZpZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAzMixcbiAgICAgIDEwMixcbiAgICAgIDExNixcbiAgICAgIDEyMSxcbiAgICAgIDExMixcbiAgICAgIDk3LFxuICAgICAgMTE4LFxuICAgICAgMTA1LFxuICAgICAgMTAyXG4gICAgXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2hlaWNcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICAxMDQsXG4gICAgICAxMDEsXG4gICAgICAxMDUsXG4gICAgICA5OVxuICAgIF1cbiAgfVxuXTtcbnZhciBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyNTFdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyNTBdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyNDNdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyNDJdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyMjddXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyMjZdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vd2F2XCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDgyLFxuICAgICAgLy8gUlxuICAgICAgNzMsXG4gICAgICAvLyBJXG4gICAgICA3MCxcbiAgICAgIC8vIEZcbiAgICAgIDcwLFxuICAgICAgLy8gRlxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIDg3LFxuICAgICAgLy8gV1xuICAgICAgNjUsXG4gICAgICAvLyBBXG4gICAgICA4NixcbiAgICAgIC8vIFZcbiAgICAgIDY5XG4gICAgICAvLyBFXG4gICAgXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL29nZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzksIDEwMywgMTAzLCA4M11cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9mbGFjXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMDIsIDc2LCA5NywgNjddXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vYWFjXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs2NCwgMjEsIDAsIDBdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXA0XCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMDIsIDExNiwgMTIxLCAxMTJdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vd2VibVwiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjYsIDY5LCAyMjMsIDE2M11cbiAgfVxuXTtcbnZhciBzdHJpcElEMyA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGRhdGEpIDogZGF0YTtcbiAgY29uc3QgaWQzU2l6ZSA9IChieXRlc1s2XSAmIDEyNykgPDwgMjEgfCAoYnl0ZXNbN10gJiAxMjcpIDw8IDE0IHwgKGJ5dGVzWzhdICYgMTI3KSA8PCA3IHwgYnl0ZXNbOV0gJiAxMjc7XG4gIHJldHVybiBieXRlcy5zbGljZShpZDNTaXplICsgMTApO1xufTtcbmZ1bmN0aW9uIHN0cmlwSUQzVGFnc0lmUHJlc2VudChkYXRhKSB7XG4gIGNvbnN0IGhhc0lkMyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmIGRhdGEuc3RhcnRzV2l0aChcIlNVUXpcIikgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgJiYgZGF0YS5sZW5ndGggPiAxMCAmJiBkYXRhWzBdID09PSA3MyAmJiAvLyAnSSdcbiAgZGF0YVsxXSA9PT0gNjggJiYgLy8gJ0QnXG4gIGRhdGFbMl0gPT09IDUxO1xuICByZXR1cm4gaGFzSWQzID8gc3RyaXBJRDMoZGF0YSkgOiBkYXRhO1xufVxuZnVuY3Rpb24gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgZGF0YSxcbiAgc2lnbmF0dXJlc1xufSkge1xuICBjb25zdCBwcm9jZXNzZWREYXRhID0gc3RyaXBJRDNUYWdzSWZQcmVzZW50KGRhdGEpO1xuICBjb25zdCBieXRlcyA9IHR5cGVvZiBwcm9jZXNzZWREYXRhID09PSBcInN0cmluZ1wiID8gY29udmVydEJhc2U2NFRvVWludDhBcnJheShcbiAgICBwcm9jZXNzZWREYXRhLnN1YnN0cmluZygwLCBNYXRoLm1pbihwcm9jZXNzZWREYXRhLmxlbmd0aCwgMjQpKVxuICApIDogcHJvY2Vzc2VkRGF0YTtcbiAgZm9yIChjb25zdCBzaWduYXR1cmUgb2Ygc2lnbmF0dXJlcykge1xuICAgIGlmIChieXRlcy5sZW5ndGggPj0gc2lnbmF0dXJlLmJ5dGVzUHJlZml4Lmxlbmd0aCAmJiBzaWduYXR1cmUuYnl0ZXNQcmVmaXguZXZlcnkoXG4gICAgICAoYnl0ZSwgaW5kZXgpID0+IGJ5dGUgPT09IG51bGwgfHwgYnl0ZXNbaW5kZXhdID09PSBieXRlXG4gICAgKSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZS5tZWRpYVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLnRzXG5pbXBvcnQgeyBEb3dubG9hZEVycm9yIGFzIERvd25sb2FkRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7XG4gIHdpdGhVc2VyQWdlbnRTdWZmaXgsXG4gIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFZFUlNJT04gPSB0cnVlID8gXCI2LjAuMzlcIiA6IFwiMC4wLjAtdGVzdFwiO1xuXG4vLyBzcmMvdXRpbC9kb3dubG9hZC9kb3dubG9hZC50c1xudmFyIGRvd25sb2FkID0gYXN5bmMgKHsgdXJsIH0pID0+IHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybFRleHQsIHtcbiAgICAgIGhlYWRlcnM6IHdpdGhVc2VyQWdlbnRTdWZmaXgoXG4gICAgICAgIHt9LFxuICAgICAgICBgYWktc2RrLyR7VkVSU0lPTn1gLFxuICAgICAgICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQoKVxuICAgICAgKVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yMih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWVkaWFUeXBlOiAoX2ExNyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPSBudWxsID8gX2ExNyA6IHZvaWQgMFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IyKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLWZ1bmN0aW9uLnRzXG52YXIgY3JlYXRlRGVmYXVsdERvd25sb2FkRnVuY3Rpb24gPSAoZG93bmxvYWQyID0gZG93bmxvYWQpID0+IChyZXF1ZXN0ZWREb3dubG9hZHMpID0+IFByb21pc2UuYWxsKFxuICByZXF1ZXN0ZWREb3dubG9hZHMubWFwKFxuICAgIGFzeW5jIChyZXF1ZXN0ZWREb3dubG9hZCkgPT4gcmVxdWVzdGVkRG93bmxvYWQuaXNVcmxTdXBwb3J0ZWRCeU1vZGVsID8gbnVsbCA6IGRvd25sb2FkMihyZXF1ZXN0ZWREb3dubG9hZClcbiAgKVxuKTtcblxuLy8gc3JjL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTIsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy9wcm9tcHQvc3BsaXQtZGF0YS11cmwudHNcbmZ1bmN0aW9uIHNwbGl0RGF0YVVybChkYXRhVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFUeXBlOiBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXSxcbiAgICAgIGJhc2U2NENvbnRlbnRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtZWRpYVR5cGU6IHZvaWQgMCxcbiAgICAgIGJhc2U2NENvbnRlbnQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbnZhciBkYXRhQ29udGVudFNjaGVtYSA9IHoudW5pb24oW1xuICB6LnN0cmluZygpLFxuICB6Lmluc3RhbmNlb2YoVWludDhBcnJheSksXG4gIHouaW5zdGFuY2VvZihBcnJheUJ1ZmZlciksXG4gIHouY3VzdG9tKFxuICAgIC8vIEJ1ZmZlciBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIHNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQ2xvdWRGbGFyZTpcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMuQnVmZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5pc0J1ZmZlcih2YWx1ZSkpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIH0sXG4gICAgeyBtZXNzYWdlOiBcIk11c3QgYmUgYSBCdWZmZXJcIiB9XG4gIClcbl0pO1xuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFYzRGF0YUNvbnRlbnQoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4geyBkYXRhOiBjb250ZW50LCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyBkYXRhOiBuZXcgVWludDhBcnJheShjb250ZW50KSwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgY29udGVudCA9IG5ldyBVUkwoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVUkwgJiYgY29udGVudC5wcm90b2NvbCA9PT0gXCJkYXRhOlwiKSB7XG4gICAgY29uc3QgeyBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUsIGJhc2U2NENvbnRlbnQgfSA9IHNwbGl0RGF0YVVybChcbiAgICAgIGNvbnRlbnQudG9TdHJpbmcoKVxuICAgICk7XG4gICAgaWYgKGRhdGFVcmxNZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBSVNES0Vycm9yMTkoe1xuICAgICAgICBuYW1lOiBcIkludmFsaWREYXRhQ29udGVudEVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCBpbiBjb250ZW50ICR7Y29udGVudC50b1N0cmluZygpfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBiYXNlNjRDb250ZW50LCBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUgfTtcbiAgfVxuICByZXR1cm4geyBkYXRhOiBjb250ZW50LCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5Mihjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuXCIsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cblxuLy8gc3JjL3V0aWwvYXMtYXJyYXkudHNcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBbXSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vLyBzcmMvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgcHJvbXB0LFxuICBzdXBwb3J0ZWRVcmxzLFxuICBkb3dubG9hZDogZG93bmxvYWQyID0gY3JlYXRlRGVmYXVsdERvd25sb2FkRnVuY3Rpb24oKVxufSkge1xuICBjb25zdCBkb3dubG9hZGVkQXNzZXRzID0gYXdhaXQgZG93bmxvYWRBc3NldHMoXG4gICAgcHJvbXB0Lm1lc3NhZ2VzLFxuICAgIGRvd25sb2FkMixcbiAgICBzdXBwb3J0ZWRVcmxzXG4gICk7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW1xuICAgIC4uLnByb21wdC5zeXN0ZW0gIT0gbnVsbCA/IHR5cGVvZiBwcm9tcHQuc3lzdGVtID09PSBcInN0cmluZ1wiID8gW3sgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9XSA6IGFzQXJyYXkocHJvbXB0LnN5c3RlbSkubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICB9KSkgOiBbXSxcbiAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKFxuICAgICAgKG1lc3NhZ2UpID0+IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKHsgbWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cyB9KVxuICAgIClcbiAgXTtcbiAgY29uc3QgY29tYmluZWRNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZS5yb2xlICE9PSBcInRvb2xcIikge1xuICAgICAgY29tYmluZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDb21iaW5lZE1lc3NhZ2UgPSBjb21iaW5lZE1lc3NhZ2VzLmF0KC0xKTtcbiAgICBpZiAoKGxhc3RDb21iaW5lZE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RDb21iaW5lZE1lc3NhZ2Uucm9sZSkgPT09IFwidG9vbFwiKSB7XG4gICAgICBsYXN0Q29tYmluZWRNZXNzYWdlLmNvbnRlbnQucHVzaCguLi5tZXNzYWdlLmNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iaW5lZE1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21iaW5lZE1lc3NhZ2VzO1xufVxuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2Uoe1xuICBtZXNzYWdlLFxuICBkb3dubG9hZGVkQXNzZXRzXG59KSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+IGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChwYXJ0LCBkb3dubG9hZGVkQXNzZXRzKSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiksXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0cyAobm8gdGV4dCwgYW5kIG5vIHByb3ZpZGVyIG9wdGlvbnMpOlxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiB8fCBwYXJ0LnByb3ZpZGVyT3B0aW9ucyAhPSBudWxsXG4gICAgICAgICkuZmlsdGVyKFxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCJcbiAgICAgICAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlck9wdGlvbnMgPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucztcbiAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIG1lZGlhVHlwZSB9ID0gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFYzRGF0YUNvbnRlbnQoXG4gICAgICAgICAgICAgICAgcGFydC5kYXRhXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBtYXBUb29sUmVzdWx0T3V0cHV0KHBhcnQub3V0cHV0KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyBPbmx5IGluY2x1ZGUgdG9vbC1hcHByb3ZhbC1yZXNwb25zZSBmb3IgcHJvdmlkZXItZXhlY3V0ZWQgdG9vbHNcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIiB8fCBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIG91dHB1dDogbWFwVG9vbFJlc3VsdE91dHB1dChwYXJ0Lm91dHB1dCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHBhcnQuYXBwcm92YWxJZCxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogcGFydC5hcHByb3ZlZCxcbiAgICAgICAgICAgICAgICByZWFzb246IHBhcnQucmVhc29uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoeyByb2xlOiBfZXhoYXVzdGl2ZUNoZWNrIH0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBc3NldHMobWVzc2FnZXMsIGRvd25sb2FkMiwgc3VwcG9ydGVkVXJscykge1xuICBjb25zdCBwbGFubmVkRG93bmxvYWRzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgPT09IFwidXNlclwiKS5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudCkuZmlsdGVyKFxuICAgIChjb250ZW50KSA9PiBBcnJheS5pc0FycmF5KGNvbnRlbnQpXG4gICkuZmxhdCgpLmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICApLm1hcCgocGFydCkgPT4ge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IG1lZGlhVHlwZSA9IChfYTE3ID0gcGFydC5tZWRpYVR5cGUpICE9IG51bGwgPyBfYTE3IDogcGFydC50eXBlID09PSBcImltYWdlXCIgPyBcImltYWdlLypcIiA6IHZvaWQgMDtcbiAgICBsZXQgZGF0YSA9IHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiID8gcGFydC5pbWFnZSA6IHBhcnQuZGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVVJMKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtZWRpYVR5cGUsIGRhdGEgfTtcbiAgfSkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LmRhdGEgaW5zdGFuY2VvZiBVUkxcbiAgKS5tYXAoKHBhcnQpID0+ICh7XG4gICAgdXJsOiBwYXJ0LmRhdGEsXG4gICAgaXNVcmxTdXBwb3J0ZWRCeU1vZGVsOiBwYXJ0Lm1lZGlhVHlwZSAhPSBudWxsICYmIGlzVXJsU3VwcG9ydGVkKHtcbiAgICAgIHVybDogcGFydC5kYXRhLnRvU3RyaW5nKCksXG4gICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgc3VwcG9ydGVkVXJsc1xuICAgIH0pXG4gIH0pKTtcbiAgY29uc3QgZG93bmxvYWRlZEZpbGVzID0gYXdhaXQgZG93bmxvYWQyKHBsYW5uZWREb3dubG9hZHMpO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRGaWxlcy5tYXAoXG4gICAgICAoZmlsZSwgaW5kZXgpID0+IGZpbGUgPT0gbnVsbCA/IG51bGwgOiBbXG4gICAgICAgIHBsYW5uZWREb3dubG9hZHNbaW5kZXhdLnVybC50b1N0cmluZygpLFxuICAgICAgICB7IGRhdGE6IGZpbGUuZGF0YSwgbWVkaWFUeXBlOiBmaWxlLm1lZGlhVHlwZSB9XG4gICAgICBdXG4gICAgKS5maWx0ZXIoKGZpbGUpID0+IGZpbGUgIT0gbnVsbClcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChwYXJ0LCBkb3dubG9hZGVkQXNzZXRzKSB7XG4gIHZhciBfYTE3O1xuICBpZiAocGFydC50eXBlID09PSBcInRleHRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICB9O1xuICB9XG4gIGxldCBvcmlnaW5hbERhdGE7XG4gIGNvbnN0IHR5cGUgPSBwYXJ0LnR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgb3JpZ2luYWxEYXRhID0gcGFydC5pbWFnZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICBvcmlnaW5hbERhdGEgPSBwYXJ0LmRhdGE7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICBjb25zdCB7IGRhdGE6IGNvbnZlcnRlZERhdGEsIG1lZGlhVHlwZTogY29udmVydGVkTWVkaWFUeXBlIH0gPSBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjNEYXRhQ29udGVudChvcmlnaW5hbERhdGEpO1xuICBsZXQgbWVkaWFUeXBlID0gY29udmVydGVkTWVkaWFUeXBlICE9IG51bGwgPyBjb252ZXJ0ZWRNZWRpYVR5cGUgOiBwYXJ0Lm1lZGlhVHlwZTtcbiAgbGV0IGRhdGEgPSBjb252ZXJ0ZWREYXRhO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVSTCkge1xuICAgIGNvbnN0IGRvd25sb2FkZWRGaWxlID0gZG93bmxvYWRlZEFzc2V0c1tkYXRhLnRvU3RyaW5nKCldO1xuICAgIGlmIChkb3dubG9hZGVkRmlsZSkge1xuICAgICAgZGF0YSA9IGRvd25sb2FkZWRGaWxlLmRhdGE7XG4gICAgICBtZWRpYVR5cGUgIT0gbnVsbCA/IG1lZGlhVHlwZSA6IG1lZGlhVHlwZSA9IGRvd25sb2FkZWRGaWxlLm1lZGlhVHlwZTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZWRpYVR5cGUgPSAoX2ExNyA9IGRldGVjdE1lZGlhVHlwZSh7IGRhdGEsIHNpZ25hdHVyZXM6IGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlcyB9KSkgIT0gbnVsbCA/IF9hMTcgOiBtZWRpYVR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUgIT0gbnVsbCA/IG1lZGlhVHlwZSA6IFwiaW1hZ2UvKlwiLFxuICAgICAgICAvLyBhbnkgaW1hZ2VcbiAgICAgICAgZmlsZW5hbWU6IHZvaWQgMCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgaWYgKG1lZGlhVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVkaWEgdHlwZSBpcyBtaXNzaW5nIGZvciBmaWxlIHBhcnRgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFwVG9vbFJlc3VsdE91dHB1dChvdXRwdXQpIHtcbiAgaWYgKG91dHB1dC50eXBlICE9PSBcImNvbnRlbnRcIikge1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogb3V0cHV0LnZhbHVlLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gXCJtZWRpYVwiKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0ubWVkaWFUeXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImltYWdlLWRhdGFcIixcbiAgICAgICAgICBkYXRhOiBpdGVtLmRhdGEsXG4gICAgICAgICAgbWVkaWFUeXBlOiBpdGVtLm1lZGlhVHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlLWRhdGFcIixcbiAgICAgICAgZGF0YTogaXRlbS5kYXRhLFxuICAgICAgICBtZWRpYVR5cGU6IGl0ZW0ubWVkaWFUeXBlXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG59XG5cbi8vIHNyYy9wcm9tcHQvY3JlYXRlLXRvb2wtbW9kZWwtb3V0cHV0LnRzXG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICB0b29sQ2FsbElkLFxuICBpbnB1dCxcbiAgb3V0cHV0LFxuICB0b29sOiB0b29sMixcbiAgZXJyb3JNb2RlXG59KSB7XG4gIGlmIChlcnJvck1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvci10ZXh0XCIsIHZhbHVlOiBnZXRFcnJvck1lc3NhZ2UzKG91dHB1dCkgfTtcbiAgfSBlbHNlIGlmIChlcnJvck1vZGUgPT09IFwianNvblwiKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvci1qc29uXCIsIHZhbHVlOiB0b0pTT05WYWx1ZShvdXRwdXQpIH07XG4gIH1cbiAgaWYgKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50b01vZGVsT3V0cHV0KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRvb2wyLnRvTW9kZWxPdXRwdXQoeyB0b29sQ2FsbElkLCBpbnB1dCwgb3V0cHV0IH0pO1xuICB9XG4gIHJldHVybiB0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IG91dHB1dCB9IDogeyB0eXBlOiBcImpzb25cIiwgdmFsdWU6IHRvSlNPTlZhbHVlKG91dHB1dCkgfTtcbn1cbmZ1bmN0aW9uIHRvSlNPTlZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gbnVsbCA6IHZhbHVlO1xufVxuXG4vLyBzcmMvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50c1xuZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heE91dHB1dFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHRvcEssXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc2VlZCxcbiAgc3RvcFNlcXVlbmNlc1xufSkge1xuICBpZiAobWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4T3V0cHV0VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heE91dHB1dFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heE91dHB1dFRva2VucyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhPdXRwdXRUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4T3V0cHV0VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4T3V0cHV0VG9rZW5zIG11c3QgYmUgPj0gMVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBcInRlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BQXCIsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiBcInRvcFAgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcEsgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wSyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcEtcIixcbiAgICAgICAgdmFsdWU6IHRvcEssXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wSyBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInByZXNlbmNlUGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcInByZXNlbmNlUGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZnJlcXVlbmN5UGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJmcmVxdWVuY3lQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzZWVkXCIsXG4gICAgICAgIHZhbHVlOiBzZWVkLFxuICAgICAgICBtZXNzYWdlOiBcInNlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heE91dHB1dFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlcyxcbiAgICBzZWVkXG4gIH07XG59XG5cbi8vIHNyYy9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmltcG9ydCB7IGFzU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50c1xuZnVuY3Rpb24gaXNOb25FbXB0eU9iamVjdChvYmplY3QyKSB7XG4gIHJldHVybiBvYmplY3QyICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0MikubGVuZ3RoID4gMDtcbn1cblxuLy8gc3JjL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBhY3RpdmVUb29sc1xufSkge1xuICBpZiAoIWlzTm9uRW1wdHlPYmplY3QodG9vbHMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xzOiB2b2lkIDAsXG4gICAgICB0b29sQ2hvaWNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IGZpbHRlcmVkVG9vbHMgPSBhY3RpdmVUb29scyAhPSBudWxsID8gT2JqZWN0LmVudHJpZXModG9vbHMpLmZpbHRlcihcbiAgICAoW25hbWUxN10pID0+IGFjdGl2ZVRvb2xzLmluY2x1ZGVzKG5hbWUxNylcbiAgKSA6IE9iamVjdC5lbnRyaWVzKHRvb2xzKTtcbiAgY29uc3QgbGFuZ3VhZ2VNb2RlbFRvb2xzID0gW107XG4gIGZvciAoY29uc3QgW25hbWUxNywgdG9vbDJdIG9mIGZpbHRlcmVkVG9vbHMpIHtcbiAgICBjb25zdCB0b29sVHlwZSA9IHRvb2wyLnR5cGU7XG4gICAgc3dpdGNoICh0b29sVHlwZSkge1xuICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICBjYXNlIFwiZHluYW1pY1wiOlxuICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIGxhbmd1YWdlTW9kZWxUb29scy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sMi5kZXNjcmlwdGlvbixcbiAgICAgICAgICBpbnB1dFNjaGVtYTogYXdhaXQgYXNTY2hlbWEodG9vbDIuaW5wdXRTY2hlbWEpLmpzb25TY2hlbWEsXG4gICAgICAgICAgLi4udG9vbDIuaW5wdXRFeGFtcGxlcyAhPSBudWxsID8geyBpbnB1dEV4YW1wbGVzOiB0b29sMi5pbnB1dEV4YW1wbGVzIH0gOiB7fSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHRvb2wyLnByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAuLi50b29sMi5zdHJpY3QgIT0gbnVsbCA/IHsgc3RyaWN0OiB0b29sMi5zdHJpY3QgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcm92aWRlclwiOlxuICAgICAgICBsYW5ndWFnZU1vZGVsVG9vbHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJwcm92aWRlclwiLFxuICAgICAgICAgIG5hbWU6IG5hbWUxNyxcbiAgICAgICAgICBpZDogdG9vbDIuaWQsXG4gICAgICAgICAgYXJnczogdG9vbDIuYXJnc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHRvb2xUeXBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRvb2wgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGxhbmd1YWdlTW9kZWxUb29scyxcbiAgICB0b29sQ2hvaWNlOiB0b29sQ2hvaWNlID09IG51bGwgPyB7IHR5cGU6IFwiYXV0b1wiIH0gOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogdG9vbENob2ljZSB9IDogeyB0eXBlOiBcInRvb2xcIiwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgfVxuICB9O1xufVxuXG4vLyBzcmMvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIGFzIEludmFsaWRQcm9tcHRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgc2FmZVZhbGlkYXRlVHlwZXNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejYgfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy9wcm9tcHQvbWVzc2FnZS50c1xuaW1wb3J0IHsgeiBhcyB6NSB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvdHlwZXMvanNvbi12YWx1ZS50c1xuaW1wb3J0IHsgeiBhcyB6MiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBqc29uVmFsdWVTY2hlbWEgPSB6Mi5sYXp5KFxuICAoKSA9PiB6Mi51bmlvbihbXG4gICAgejIubnVsbCgpLFxuICAgIHoyLnN0cmluZygpLFxuICAgIHoyLm51bWJlcigpLFxuICAgIHoyLmJvb2xlYW4oKSxcbiAgICB6Mi5yZWNvcmQoejIuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYS5vcHRpb25hbCgpKSxcbiAgICB6Mi5hcnJheShqc29uVmFsdWVTY2hlbWEpXG4gIF0pXG4pO1xuXG4vLyBzcmMvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbnZhciBwcm92aWRlck1ldGFkYXRhU2NoZW1hID0gejMucmVjb3JkKFxuICB6My5zdHJpbmcoKSxcbiAgejMucmVjb3JkKHozLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEub3B0aW9uYWwoKSlcbik7XG5cbi8vIHNyYy9wcm9tcHQvY29udGVudC1wYXJ0LnRzXG5pbXBvcnQgeyB6IGFzIHo0IH0gZnJvbSBcInpvZC92NFwiO1xudmFyIHRleHRQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRleHRcIiksXG4gIHRleHQ6IHo0LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgaW1hZ2VQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcImltYWdlXCIpLFxuICBpbWFnZTogejQudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NC5pbnN0YW5jZW9mKFVSTCldKSxcbiAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgZmlsZVBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwiZmlsZVwiKSxcbiAgZGF0YTogejQudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NC5pbnN0YW5jZW9mKFVSTCldKSxcbiAgZmlsZW5hbWU6IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1lZGlhVHlwZTogejQuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciByZWFzb25pbmdQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInJlYXNvbmluZ1wiKSxcbiAgdGV4dDogejQuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciB0b29sQ2FsbFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidG9vbC1jYWxsXCIpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo0LnN0cmluZygpLFxuICBpbnB1dDogejQudW5rbm93bigpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJFeGVjdXRlZDogejQuYm9vbGVhbigpLm9wdGlvbmFsKClcbn0pO1xudmFyIG91dHB1dFNjaGVtYSA9IHo0LmRpc2NyaW1pbmF0ZWRVbmlvbihcbiAgXCJ0eXBlXCIsXG4gIFtcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcInRleHRcIiksXG4gICAgICB2YWx1ZTogejQuc3RyaW5nKCksXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwianNvblwiKSxcbiAgICAgIHZhbHVlOiBqc29uVmFsdWVTY2hlbWEsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZXhlY3V0aW9uLWRlbmllZFwiKSxcbiAgICAgIHJlYXNvbjogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgfSksXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJlcnJvci10ZXh0XCIpLFxuICAgICAgdmFsdWU6IHo0LnN0cmluZygpLFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImVycm9yLWpzb25cIiksXG4gICAgICB2YWx1ZToganNvblZhbHVlU2NoZW1hLFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImNvbnRlbnRcIiksXG4gICAgICB2YWx1ZTogejQuYXJyYXkoXG4gICAgICAgIHo0LnVuaW9uKFtcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcInRleHRcIiksXG4gICAgICAgICAgICB0ZXh0OiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJtZWRpYVwiKSxcbiAgICAgICAgICAgIGRhdGE6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZmlsZS1kYXRhXCIpLFxuICAgICAgICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBtZWRpYVR5cGU6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZmlsZS11cmxcIiksXG4gICAgICAgICAgICB1cmw6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImZpbGUtaWRcIiksXG4gICAgICAgICAgICBmaWxlSWQ6IHo0LnVuaW9uKFt6NC5zdHJpbmcoKSwgejQucmVjb3JkKHo0LnN0cmluZygpLCB6NC5zdHJpbmcoKSldKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJpbWFnZS1kYXRhXCIpLFxuICAgICAgICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBtZWRpYVR5cGU6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlLXVybFwiKSxcbiAgICAgICAgICAgIHVybDogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2UtZmlsZS1pZFwiKSxcbiAgICAgICAgICAgIGZpbGVJZDogejQudW5pb24oW3o0LnN0cmluZygpLCB6NC5yZWNvcmQoejQuc3RyaW5nKCksIHo0LnN0cmluZygpKV0pLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImN1c3RvbVwiKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICB9KVxuICBdXG4pO1xudmFyIHRvb2xSZXN1bHRQYXJ0U2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtcmVzdWx0XCIpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo0LnN0cmluZygpLFxuICBvdXRwdXQ6IG91dHB1dFNjaGVtYSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHRvb2xBcHByb3ZhbFJlcXVlc3RTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpLFxuICBhcHByb3ZhbElkOiB6NC5zdHJpbmcoKSxcbiAgdG9vbENhbGxJZDogejQuc3RyaW5nKClcbn0pO1xudmFyIHRvb2xBcHByb3ZhbFJlc3BvbnNlU2NoZW1hID0gejQub2JqZWN0KHtcbiAgdHlwZTogejQubGl0ZXJhbChcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIiksXG4gIGFwcHJvdmFsSWQ6IHo0LnN0cmluZygpLFxuICBhcHByb3ZlZDogejQuYm9vbGVhbigpLFxuICByZWFzb246IHo0LnN0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBzcmMvcHJvbXB0L21lc3NhZ2UudHNcbnZhciBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3QoXG4gIHtcbiAgICByb2xlOiB6NS5saXRlcmFsKFwic3lzdGVtXCIpLFxuICAgIGNvbnRlbnQ6IHo1LnN0cmluZygpLFxuICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH1cbik7XG52YXIgdXNlck1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoejUudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgYXNzaXN0YW50TW9kZWxNZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgcm9sZTogejUubGl0ZXJhbChcImFzc2lzdGFudFwiKSxcbiAgY29udGVudDogejUudW5pb24oW1xuICAgIHo1LnN0cmluZygpLFxuICAgIHo1LmFycmF5KFxuICAgICAgejUudW5pb24oW1xuICAgICAgICB0ZXh0UGFydFNjaGVtYSxcbiAgICAgICAgZmlsZVBhcnRTY2hlbWEsXG4gICAgICAgIHJlYXNvbmluZ1BhcnRTY2hlbWEsXG4gICAgICAgIHRvb2xDYWxsUGFydFNjaGVtYSxcbiAgICAgICAgdG9vbFJlc3VsdFBhcnRTY2hlbWEsXG4gICAgICAgIHRvb2xBcHByb3ZhbFJlcXVlc3RTY2hlbWFcbiAgICAgIF0pXG4gICAgKVxuICBdKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwidG9vbFwiKSxcbiAgY29udGVudDogejUuYXJyYXkoejUudW5pb24oW3Rvb2xSZXN1bHRQYXJ0U2NoZW1hLCB0b29sQXBwcm92YWxSZXNwb25zZVNjaGVtYV0pKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIG1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1LnVuaW9uKFtcbiAgc3lzdGVtTW9kZWxNZXNzYWdlU2NoZW1hLFxuICB1c2VyTW9kZWxNZXNzYWdlU2NoZW1hLFxuICBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWFcbl0pO1xuXG4vLyBzcmMvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZVwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnN5c3RlbSAhPT0gXCJzdHJpbmdcIiAmJiAhYXNBcnJheShwcm9tcHQuc3lzdGVtKS5ldmVyeShcbiAgICAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwib2JqZWN0XCIgJiYgbWVzc2FnZSAhPT0gbnVsbCAmJiBcInJvbGVcIiBpbiBtZXNzYWdlICYmIG1lc3NhZ2Uucm9sZSA9PT0gXCJzeXN0ZW1cIlxuICApKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJzeXN0ZW0gbXVzdCBiZSBhIHN0cmluZywgU3lzdGVtTW9kZWxNZXNzYWdlLCBvciBhcnJheSBvZiBTeXN0ZW1Nb2RlbE1lc3NhZ2VcIlxuICAgIH0pO1xuICB9XG4gIGxldCBtZXNzYWdlcztcbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1lc3NhZ2VzID0gW3sgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHByb21wdC5wcm9tcHQgfV07XG4gIH0gZWxzZSBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkocHJvbXB0LnByb21wdCkpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5wcm9tcHQ7XG4gIH0gZWxzZSBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5tZXNzYWdlcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3Qgbm90IGJlIGVtcHR5XCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICBzY2hlbWE6IHo2LmFycmF5KG1vZGVsTWVzc2FnZVNjaGVtYSlcbiAgfSk7XG4gIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJUaGUgbWVzc2FnZXMgZG8gbm90IG1hdGNoIHRoZSBNb2RlbE1lc3NhZ2VbXSBzY2hlbWEuXCIsXG4gICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIHNyYy9wcm9tcHQvd3JhcC1nYXRld2F5LWVycm9yLnRzXG5pbXBvcnQgeyBHYXRld2F5QXV0aGVudGljYXRpb25FcnJvciB9IGZyb20gXCJAYWktc2RrL2dhdGV3YXlcIjtcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIwIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIHdyYXBHYXRld2F5RXJyb3IoZXJyb3IpIHtcbiAgaWYgKCFHYXRld2F5QXV0aGVudGljYXRpb25FcnJvci5pc0luc3RhbmNlKGVycm9yKSlcbiAgICByZXR1cm4gZXJyb3I7XG4gIGNvbnN0IGlzUHJvZHVjdGlvbkVudiA9IChwcm9jZXNzID09IG51bGwgPyB2b2lkIDAgOiBwcm9jZXNzLmVudi5OT0RFX0VOVikgPT09IFwicHJvZHVjdGlvblwiO1xuICBjb25zdCBtb3JlSW5mb1VSTCA9IFwiaHR0cHM6Ly9haS1zZGsuZGV2L3VuYXV0aGVudGljYXRlZC1haS1nYXRld2F5XCI7XG4gIGlmIChpc1Byb2R1Y3Rpb25FbnYpIHtcbiAgICByZXR1cm4gbmV3IEFJU0RLRXJyb3IyMCh7XG4gICAgICBuYW1lOiBcIkdhdGV3YXlFcnJvclwiLFxuICAgICAgbWVzc2FnZTogYFVuYXV0aGVudGljYXRlZC4gQ29uZmlndXJlIEFJX0dBVEVXQVlfQVBJX0tFWSBvciB1c2UgYSBwcm92aWRlciBtb2R1bGUuIExlYXJuIG1vcmU6ICR7bW9yZUluZm9VUkx9YFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIG5ldyBFcnJvcihgXFx4MUJbMW1cXHgxQlszMW1VbmF1dGhlbnRpY2F0ZWQgcmVxdWVzdCB0byBBSSBHYXRld2F5LlxceDFCWzBtXG5cblRvIGF1dGhlbnRpY2F0ZSwgc2V0IHRoZSBcXHgxQlszM21BSV9HQVRFV0FZX0FQSV9LRVlcXHgxQlswbSBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRoIHlvdXIgQVBJIGtleS5cblxuQWx0ZXJuYXRpdmVseSwgeW91IGNhbiB1c2UgYSBwcm92aWRlciBtb2R1bGUgaW5zdGVhZCBvZiB0aGUgQUkgR2F0ZXdheS5cblxuTGVhcm4gbW9yZTogXFx4MUJbMzRtJHttb3JlSW5mb1VSTH1cXHgxQlswbVxuXG5gKSxcbiAgICB7IG5hbWU6IFwiR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3JcIiB9XG4gICk7XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvYXNzZW1ibGUtb3BlcmF0aW9uLW5hbWUudHNcbmZ1bmN0aW9uIGFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gIG9wZXJhdGlvbklkLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBzdGFuZGFyZGl6ZWQgb3BlcmF0aW9uIGFuZCByZXNvdXJjZSBuYW1lOlxuICAgIFwib3BlcmF0aW9uLm5hbWVcIjogYCR7b3BlcmF0aW9uSWR9JHsodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCkgIT0gbnVsbCA/IGAgJHt0ZWxlbWV0cnkuZnVuY3Rpb25JZH1gIDogXCJcIn1gLFxuICAgIFwicmVzb3VyY2UubmFtZVwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgIC8vIGRldGFpbGVkLCBBSSBTREsgc3BlY2lmaWMgZGF0YTpcbiAgICBcImFpLm9wZXJhdGlvbklkXCI6IG9wZXJhdGlvbklkLFxuICAgIFwiYWkudGVsZW1ldHJ5LmZ1bmN0aW9uSWRcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZFxuICB9O1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L2dldC1iYXNlLXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIG1vZGVsLFxuICBzZXR0aW5ncyxcbiAgdGVsZW1ldHJ5LFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3O1xuICByZXR1cm4ge1xuICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgXCJhaS5tb2RlbC5pZFwiOiBtb2RlbC5tb2RlbElkLFxuICAgIC8vIHNldHRpbmdzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKHNldHRpbmdzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJ0aW1lb3V0XCIpIHtcbiAgICAgICAgY29uc3QgdG90YWxUaW1lb3V0TXMgPSBnZXRUb3RhbFRpbWVvdXRNcyhcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICApO1xuICAgICAgICBpZiAodG90YWxUaW1lb3V0TXMgIT0gbnVsbCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdG90YWxUaW1lb3V0TXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSksXG4gICAgLy8gYWRkIG1ldGFkYXRhIGFzIGF0dHJpYnV0ZXM6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoKF9hMTcgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB7fSkucmVkdWNlKFxuICAgICAgKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS50ZWxlbWV0cnkubWV0YWRhdGEuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LFxuICAgICAge31cbiAgICApLFxuICAgIC8vIHJlcXVlc3QgaGVhZGVyc1xuICAgIC4uLk9iamVjdC5lbnRyaWVzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSkucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnJlcXVlc3QuaGVhZGVycy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pXG4gIH07XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5cbi8vIHNyYy90ZWxlbWV0cnkvbm9vcC10cmFjZXIudHNcbnZhciBub29wVHJhY2VyID0ge1xuICBzdGFydFNwYW4oKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuO1xuICB9LFxuICBzdGFydEFjdGl2ZVNwYW4obmFtZTE3LCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcxKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcyKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmczKG5vb3BTcGFuKTtcbiAgICB9XG4gIH1cbn07XG52YXIgbm9vcFNwYW4gPSB7XG4gIHNwYW5Db250ZXh0KCkge1xuICAgIHJldHVybiBub29wU3BhbkNvbnRleHQ7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmtzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHVwZGF0ZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaXNSZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICByZWNvcmRFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgbm9vcFNwYW5Db250ZXh0ID0ge1xuICB0cmFjZUlkOiBcIlwiLFxuICBzcGFuSWQ6IFwiXCIsXG4gIHRyYWNlRmxhZ3M6IDBcbn07XG5cbi8vIHNyYy90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuZnVuY3Rpb24gZ2V0VHJhY2VyKHtcbiAgaXNFbmFibGVkID0gZmFsc2UsXG4gIHRyYWNlclxufSA9IHt9KSB7XG4gIGlmICghaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG5vb3BUcmFjZXI7XG4gIH1cbiAgaWYgKHRyYWNlcikge1xuICAgIHJldHVybiB0cmFjZXI7XG4gIH1cbiAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcihcImFpXCIpO1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L3JlY29yZC1zcGFuLnRzXG5pbXBvcnQge1xuICBTcGFuU3RhdHVzQ29kZSxcbiAgY29udGV4dFxufSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5hc3luYyBmdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTE3LFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4oXG4gICAgbmFtZTE3LFxuICAgIHsgYXR0cmlidXRlczogYXdhaXQgYXR0cmlidXRlcyB9LFxuICAgIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCBjdHggPSBjb250ZXh0LmFjdGl2ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udGV4dC53aXRoKGN0eCwgKCkgPT4gZm4oc3BhbikpO1xuICAgICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlY29yZEVycm9yT25TcGFuKHNwYW4sIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHJlY29yZEVycm9yT25TcGFuKHNwYW4sIGVycm9yKSB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oe1xuICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICB9KTtcbiAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICB9XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvc2VsZWN0LXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5hc3luYyBmdW5jdGlvbiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgdGVsZW1ldHJ5LFxuICBhdHRyaWJ1dGVzXG59KSB7XG4gIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCByZXN1bHRBdHRyaWJ1dGVzID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRJbnB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbHVlLmlucHV0KCk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0QXR0cmlidXRlc1trZXldID0gcmVzdWx0O1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUub3V0cHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkT3V0cHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWUub3V0cHV0KCk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0QXR0cmlidXRlc1trZXldID0gcmVzdWx0O1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHRBdHRyaWJ1dGVzO1xufVxuXG4vLyBzcmMvdGVsZW1ldHJ5L3N0cmluZ2lmeS1mb3ItdGVsZW1ldHJ5LnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICBwcm9tcHQubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIGNvbnRlbnQ6IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlLmNvbnRlbnQgOiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImZpbGVcIiA/IHtcbiAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgIGRhdGE6IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhwYXJ0LmRhdGEpIDogcGFydC5kYXRhXG4gICAgICAgIH0gOiBwYXJ0XG4gICAgICApXG4gICAgfSkpXG4gICk7XG59XG5cbi8vIHNyYy90eXBlcy91c2FnZS50c1xuZnVuY3Rpb24gYXNMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgaW5wdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIG5vQ2FjaGVUb2tlbnM6IHVzYWdlLmlucHV0VG9rZW5zLm5vQ2FjaGUsXG4gICAgICBjYWNoZVJlYWRUb2tlbnM6IHVzYWdlLmlucHV0VG9rZW5zLmNhY2hlUmVhZCxcbiAgICAgIGNhY2hlV3JpdGVUb2tlbnM6IHVzYWdlLmlucHV0VG9rZW5zLmNhY2hlV3JpdGVcbiAgICB9LFxuICAgIG91dHB1dFRva2VuczogdXNhZ2Uub3V0cHV0VG9rZW5zLnRvdGFsLFxuICAgIG91dHB1dFRva2VuRGV0YWlsczoge1xuICAgICAgdGV4dFRva2VuczogdXNhZ2Uub3V0cHV0VG9rZW5zLnRleHQsXG4gICAgICByZWFzb25pbmdUb2tlbnM6IHVzYWdlLm91dHB1dFRva2Vucy5yZWFzb25pbmdcbiAgICB9LFxuICAgIHRvdGFsVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgIHVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgdXNhZ2Uub3V0cHV0VG9rZW5zLnRvdGFsXG4gICAgKSxcbiAgICByYXc6IHVzYWdlLnJhdyxcbiAgICByZWFzb25pbmdUb2tlbnM6IHVzYWdlLm91dHB1dFRva2Vucy5yZWFzb25pbmcsXG4gICAgY2FjaGVkSW5wdXRUb2tlbnM6IHVzYWdlLmlucHV0VG9rZW5zLmNhY2hlUmVhZFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTnVsbExhbmd1YWdlTW9kZWxVc2FnZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2Vuczogdm9pZCAwLFxuICAgIGlucHV0VG9rZW5EZXRhaWxzOiB7XG4gICAgICBub0NhY2hlVG9rZW5zOiB2b2lkIDAsXG4gICAgICBjYWNoZVJlYWRUb2tlbnM6IHZvaWQgMCxcbiAgICAgIGNhY2hlV3JpdGVUb2tlbnM6IHZvaWQgMFxuICAgIH0sXG4gICAgb3V0cHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgb3V0cHV0VG9rZW5EZXRhaWxzOiB7XG4gICAgICB0ZXh0VG9rZW5zOiB2b2lkIDAsXG4gICAgICByZWFzb25pbmdUb2tlbnM6IHZvaWQgMFxuICAgIH0sXG4gICAgdG90YWxUb2tlbnM6IHZvaWQgMCxcbiAgICByYXc6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlMSwgdXNhZ2UyKSB7XG4gIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qO1xuICByZXR1cm4ge1xuICAgIGlucHV0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEuaW5wdXRUb2tlbnMsIHVzYWdlMi5pbnB1dFRva2VucyksXG4gICAgaW5wdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIG5vQ2FjaGVUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgICAoX2ExNyA9IHVzYWdlMS5pbnB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubm9DYWNoZVRva2VucyxcbiAgICAgICAgKF9iID0gdXNhZ2UyLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2Iubm9DYWNoZVRva2Vuc1xuICAgICAgKSxcbiAgICAgIGNhY2hlUmVhZFRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICAgIChfYyA9IHVzYWdlMS5pbnB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhY2hlUmVhZFRva2VucyxcbiAgICAgICAgKF9kID0gdXNhZ2UyLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FjaGVSZWFkVG9rZW5zXG4gICAgICApLFxuICAgICAgY2FjaGVXcml0ZVRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICAgIChfZSA9IHVzYWdlMS5pbnB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmNhY2hlV3JpdGVUb2tlbnMsXG4gICAgICAgIChfZiA9IHVzYWdlMi5pbnB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNhY2hlV3JpdGVUb2tlbnNcbiAgICAgIClcbiAgICB9LFxuICAgIG91dHB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLm91dHB1dFRva2VucywgdXNhZ2UyLm91dHB1dFRva2VucyksXG4gICAgb3V0cHV0VG9rZW5EZXRhaWxzOiB7XG4gICAgICB0ZXh0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgICAgKF9nID0gdXNhZ2UxLm91dHB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLnRleHRUb2tlbnMsXG4gICAgICAgIChfaCA9IHVzYWdlMi5vdXRwdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfaC50ZXh0VG9rZW5zXG4gICAgICApLFxuICAgICAgcmVhc29uaW5nVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgICAgKF9pID0gdXNhZ2UxLm91dHB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgICAgKF9qID0gdXNhZ2UyLm91dHB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9qLnJlYXNvbmluZ1Rva2Vuc1xuICAgICAgKVxuICAgIH0sXG4gICAgdG90YWxUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS50b3RhbFRva2VucywgdXNhZ2UyLnRvdGFsVG9rZW5zKSxcbiAgICByZWFzb25pbmdUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgdXNhZ2UxLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgIHVzYWdlMi5yZWFzb25pbmdUb2tlbnNcbiAgICApLFxuICAgIGNhY2hlZElucHV0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgIHVzYWdlMS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgIHVzYWdlMi5jYWNoZWRJbnB1dFRva2Vuc1xuICAgIClcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZFRva2VuQ291bnRzKHRva2VuQ291bnQxLCB0b2tlbkNvdW50Mikge1xuICByZXR1cm4gdG9rZW5Db3VudDEgPT0gbnVsbCAmJiB0b2tlbkNvdW50MiA9PSBudWxsID8gdm9pZCAwIDogKHRva2VuQ291bnQxICE9IG51bGwgPyB0b2tlbkNvdW50MSA6IDApICsgKHRva2VuQ291bnQyICE9IG51bGwgPyB0b2tlbkNvdW50MiA6IDApO1xufVxuZnVuY3Rpb24gYWRkSW1hZ2VNb2RlbFVzYWdlKHVzYWdlMSwgdXNhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5pbnB1dFRva2VucywgdXNhZ2UyLmlucHV0VG9rZW5zKSxcbiAgICBvdXRwdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5vdXRwdXRUb2tlbnMsIHVzYWdlMi5vdXRwdXRUb2tlbnMpLFxuICAgIHRvdGFsVG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEudG90YWxUb2tlbnMsIHVzYWdlMi50b3RhbFRva2VucylcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWwvbWVyZ2Utb2JqZWN0cy50c1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKGJhc2UsIG92ZXJyaWRlcykge1xuICBpZiAoYmFzZSA9PT0gdm9pZCAwICYmIG92ZXJyaWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbiAgfVxuICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB7IC4uLmJhc2UgfTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3ZlcnJpZGVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdmVycmlkZXMsIGtleSkpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlc1ZhbHVlID0gb3ZlcnJpZGVzW2tleV07XG4gICAgICBpZiAob3ZlcnJpZGVzVmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBrZXkgaW4gYmFzZSA/IGJhc2Vba2V5XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzU291cmNlT2JqZWN0ID0gb3ZlcnJpZGVzVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIG92ZXJyaWRlc1ZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KG92ZXJyaWRlc1ZhbHVlKSAmJiAhKG92ZXJyaWRlc1ZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgIShvdmVycmlkZXNWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICBjb25zdCBpc1RhcmdldE9iamVjdCA9IGJhc2VWYWx1ZSAhPT0gbnVsbCAmJiBiYXNlVmFsdWUgIT09IHZvaWQgMCAmJiB0eXBlb2YgYmFzZVZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGJhc2VWYWx1ZSkgJiYgIShiYXNlVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKGJhc2VWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICBpZiAoaXNTb3VyY2VPYmplY3QgJiYgaXNUYXJnZXRPYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9iamVjdHMoXG4gICAgICAgICAgYmFzZVZhbHVlLFxuICAgICAgICAgIG92ZXJyaWRlc1ZhbHVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IG92ZXJyaWRlc1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGRlbGF5LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlNCwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXlJbk1zKHtcbiAgZXJyb3IsXG4gIGV4cG9uZW50aWFsQmFja29mZkRlbGF5XG59KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBlcnJvci5yZXNwb25zZUhlYWRlcnM7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4gZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXk7XG4gIGxldCBtcztcbiAgY29uc3QgcmV0cnlBZnRlck1zID0gaGVhZGVyc1tcInJldHJ5LWFmdGVyLW1zXCJdO1xuICBpZiAocmV0cnlBZnRlck1zKSB7XG4gICAgY29uc3QgdGltZW91dE1zID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyTXMpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRNcykpIHtcbiAgICAgIG1zID0gdGltZW91dE1zO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXRyeUFmdGVyID0gaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICBpZiAocmV0cnlBZnRlciAmJiBtcyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgdGltZW91dFNlY29uZHMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXIpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgbXMgPSB0aW1lb3V0U2Vjb25kcyAqIDFlMztcbiAgICB9IGVsc2Uge1xuICAgICAgbXMgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXIpIC0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1zICE9IG51bGwgJiYgIU51bWJlci5pc05hTihtcykgJiYgMCA8PSBtcyAmJiAobXMgPCA2MCAqIDFlMyB8fCBtcyA8IGV4cG9uZW50aWFsQmFja29mZkRlbGF5KSkge1xuICAgIHJldHVybiBtcztcbiAgfVxuICByZXR1cm4gZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXk7XG59XG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmUmVzcGVjdGluZ1JldHJ5SGVhZGVycyA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgYWJvcnRTaWduYWxcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3IsXG4gIGFib3J0U2lnbmFsXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3IsXG4gIGFib3J0U2lnbmFsXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTQoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoXG4gICAgICAgIGdldFJldHJ5RGVsYXlJbk1zKHtcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBleHBvbmVudGlhbEJhY2tvZmZEZWxheTogZGVsYXlJbk1zXG4gICAgICAgIH0pLFxuICAgICAgICB7IGFib3J0U2lnbmFsIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAge1xuICAgICAgICAgIG1heFJldHJpZXMsXG4gICAgICAgICAgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLFxuICAgICAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvcHJlcGFyZS1yZXRyaWVzLnRzXG5mdW5jdGlvbiBwcmVwYXJlUmV0cmllcyh7XG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXhSZXRyaWVzUmVzdWx0ID0gbWF4UmV0cmllcyAhPSBudWxsID8gbWF4UmV0cmllcyA6IDI7XG4gIHJldHVybiB7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc1Jlc3VsdCxcbiAgICByZXRyeTogcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmUmVzcGVjdGluZ1JldHJ5SGVhZGVycyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0LFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KVxuICB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9jb2xsZWN0LXRvb2wtYXBwcm92YWxzLnRzXG5mdW5jdGlvbiBjb2xsZWN0VG9vbEFwcHJvdmFscyh7XG4gIG1lc3NhZ2VzXG59KSB7XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXMuYXQoLTEpO1xuICBpZiAoKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSAhPSBcInRvb2xcIikge1xuICAgIHJldHVybiB7XG4gICAgICBhcHByb3ZlZFRvb2xBcHByb3ZhbHM6IFtdLFxuICAgICAgZGVuaWVkVG9vbEFwcHJvdmFsczogW11cbiAgICB9O1xuICB9XG4gIGNvbnN0IHRvb2xDYWxsc0J5VG9vbENhbGxJZCA9IHt9O1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiICYmIHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiKSB7XG4gICAgICAgICAgdG9vbENhbGxzQnlUb29sQ2FsbElkW3BhcnQudG9vbENhbGxJZF0gPSBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRvb2xBcHByb3ZhbFJlcXVlc3RzQnlBcHByb3ZhbElkID0ge307XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiYgdHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgY29udGVudCA9IG1lc3NhZ2UuY29udGVudDtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpIHtcbiAgICAgICAgICB0b29sQXBwcm92YWxSZXF1ZXN0c0J5QXBwcm92YWxJZFtwYXJ0LmFwcHJvdmFsSWRdID0gcGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCB0b29sUmVzdWx0cyA9IHt9O1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgbGFzdE1lc3NhZ2UuY29udGVudCkge1xuICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIikge1xuICAgICAgdG9vbFJlc3VsdHNbcGFydC50b29sQ2FsbElkXSA9IHBhcnQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFwcHJvdmVkVG9vbEFwcHJvdmFscyA9IFtdO1xuICBjb25zdCBkZW5pZWRUb29sQXBwcm92YWxzID0gW107XG4gIGNvbnN0IGFwcHJvdmFsUmVzcG9uc2VzID0gbGFzdE1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCJcbiAgKTtcbiAgZm9yIChjb25zdCBhcHByb3ZhbFJlc3BvbnNlIG9mIGFwcHJvdmFsUmVzcG9uc2VzKSB7XG4gICAgY29uc3QgYXBwcm92YWxSZXF1ZXN0ID0gdG9vbEFwcHJvdmFsUmVxdWVzdHNCeUFwcHJvdmFsSWRbYXBwcm92YWxSZXNwb25zZS5hcHByb3ZhbElkXTtcbiAgICBpZiAoYXBwcm92YWxSZXF1ZXN0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFwcHJvdmFsRXJyb3Ioe1xuICAgICAgICBhcHByb3ZhbElkOiBhcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodG9vbFJlc3VsdHNbYXBwcm92YWxSZXF1ZXN0LnRvb2xDYWxsSWRdICE9IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0b29sQ2FsbCA9IHRvb2xDYWxsc0J5VG9vbENhbGxJZFthcHByb3ZhbFJlcXVlc3QudG9vbENhbGxJZF07XG4gICAgaWYgKHRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUb29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvcih7XG4gICAgICAgIHRvb2xDYWxsSWQ6IGFwcHJvdmFsUmVxdWVzdC50b29sQ2FsbElkLFxuICAgICAgICBhcHByb3ZhbElkOiBhcHByb3ZhbFJlcXVlc3QuYXBwcm92YWxJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFwcHJvdmFsID0ge1xuICAgICAgYXBwcm92YWxSZXF1ZXN0LFxuICAgICAgYXBwcm92YWxSZXNwb25zZSxcbiAgICAgIHRvb2xDYWxsXG4gICAgfTtcbiAgICBpZiAoYXBwcm92YWxSZXNwb25zZS5hcHByb3ZlZCkge1xuICAgICAgYXBwcm92ZWRUb29sQXBwcm92YWxzLnB1c2goYXBwcm92YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZW5pZWRUb29sQXBwcm92YWxzLnB1c2goYXBwcm92YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBhcHByb3ZlZFRvb2xBcHByb3ZhbHMsIGRlbmllZFRvb2xBcHByb3ZhbHMgfTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZXhlY3V0ZS10b29sLWNhbGwudHNcbmltcG9ydCB7IGV4ZWN1dGVUb29sIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29sQ2FsbCh7XG4gIHRvb2xDYWxsLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIG9uUHJlbGltaW5hcnlUb29sUmVzdWx0XG59KSB7XG4gIGNvbnN0IHsgdG9vbE5hbWUsIHRvb2xDYWxsSWQsIGlucHV0IH0gPSB0b29sQ2FsbDtcbiAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leGVjdXRlKSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbE5hbWUsXG4gICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGxJZCxcbiAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGlucHV0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgbGV0IG91dHB1dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGV4ZWN1dGVUb29sKHtcbiAgICAgICAgICBleGVjdXRlOiB0b29sMi5leGVjdXRlLmJpbmQodG9vbDIpLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJwcmVsaW1pbmFyeVwiKSB7XG4gICAgICAgICAgICBvblByZWxpbWluYXJ5VG9vbFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogb25QcmVsaW1pbmFyeVRvb2xSZXN1bHQoe1xuICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHBhcnQub3V0cHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZHluYW1pYzogdG9vbDIudHlwZSA9PT0gXCJkeW5hbWljXCIsXG4gICAgICAgICAgLi4udG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIG91dHB1dCxcbiAgICAgICAgZHluYW1pYzogdG9vbDIudHlwZSA9PT0gXCJkeW5hbWljXCIsXG4gICAgICAgIC4uLnRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZXh0cmFjdC10ZXh0LWNvbnRlbnQudHNcbmZ1bmN0aW9uIGV4dHJhY3RUZXh0Q29udGVudChjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50eXBlID09PSBcInRleHRcIlxuICApO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcGFydHMubWFwKChjb250ZW50MikgPT4gY29udGVudDIudGV4dCkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGVkLWZpbGUudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTMsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQgYXMgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBEZWZhdWx0R2VuZXJhdGVkRmlsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVkaWFUeXBlXG4gIH0pIHtcbiAgICBjb25zdCBpc1VpbnQ4QXJyYXkgPSBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICB0aGlzLmJhc2U2NERhdGEgPSBpc1VpbnQ4QXJyYXkgPyB2b2lkIDAgOiBkYXRhO1xuICAgIHRoaXMudWludDhBcnJheURhdGEgPSBpc1VpbnQ4QXJyYXkgPyBkYXRhIDogdm9pZCAwO1xuICAgIHRoaXMubWVkaWFUeXBlID0gbWVkaWFUeXBlO1xuICB9XG4gIC8vIGxhenkgY29udmVyc2lvbiB3aXRoIGNhY2hpbmcgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udmVyc2lvbiBvdmVyaGVhZDpcbiAgZ2V0IGJhc2U2NCgpIHtcbiAgICBpZiAodGhpcy5iYXNlNjREYXRhID09IG51bGwpIHtcbiAgICAgIHRoaXMuYmFzZTY0RGF0YSA9IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyKHRoaXMudWludDhBcnJheURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iYXNlNjREYXRhO1xuICB9XG4gIC8vIGxhenkgY29udmVyc2lvbiB3aXRoIGNhY2hpbmcgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udmVyc2lvbiBvdmVyaGVhZDpcbiAgZ2V0IHVpbnQ4QXJyYXkoKSB7XG4gICAgaWYgKHRoaXMudWludDhBcnJheURhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy51aW50OEFycmF5RGF0YSA9IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkzKHRoaXMuYmFzZTY0RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQ4QXJyYXlEYXRhO1xuICB9XG59O1xudmFyIERlZmF1bHRHZW5lcmF0ZWRGaWxlV2l0aFR5cGUgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRHZW5lcmF0ZWRGaWxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudHlwZSA9IFwiZmlsZVwiO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9pcy1hcHByb3ZhbC1uZWVkZWQudHNcbmFzeW5jIGZ1bmN0aW9uIGlzQXBwcm92YWxOZWVkZWQoe1xuICB0b29sOiB0b29sMixcbiAgdG9vbENhbGwsXG4gIG1lc3NhZ2VzLFxuICBleHBlcmltZW50YWxfY29udGV4dFxufSkge1xuICBpZiAodG9vbDIubmVlZHNBcHByb3ZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgdG9vbDIubmVlZHNBcHByb3ZhbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdG9vbDIubmVlZHNBcHByb3ZhbDtcbiAgfVxuICByZXR1cm4gYXdhaXQgdG9vbDIubmVlZHNBcHByb3ZhbCh0b29sQ2FsbC5pbnB1dCwge1xuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgbWVzc2FnZXMsXG4gICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgfSk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L291dHB1dC50c1xudmFyIG91dHB1dF9leHBvcnRzID0ge307XG5fX2V4cG9ydChvdXRwdXRfZXhwb3J0cywge1xuICBhcnJheTogKCkgPT4gYXJyYXksXG4gIGNob2ljZTogKCkgPT4gY2hvaWNlLFxuICBqc29uOiAoKSA9PiBqc29uLFxuICBvYmplY3Q6ICgpID0+IG9iamVjdCxcbiAgdGV4dDogKCkgPT4gdGV4dFxufSk7XG5pbXBvcnQge1xuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTIsXG4gIHJlc29sdmUsXG4gIHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjIsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9maXgtanNvbi50c1xuZnVuY3Rpb24gZml4SnNvbihpbnB1dCkge1xuICBjb25zdCBzdGFjayA9IFtcIlJPT1RcIl07XG4gIGxldCBsYXN0VmFsaWRJbmRleCA9IC0xO1xuICBsZXQgbGl0ZXJhbFN0YXJ0ID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgc3dhcFN0YXRlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgY2FzZSBcIm5cIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBsaXRlcmFsU3RhcnQgPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0xJVEVSQUxcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwie1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiW1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGlucHV0W2ldO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHN3aXRjaCAoY3VycmVudFN0YXRlKSB7XG4gICAgICBjYXNlIFwiUk9PVFwiOlxuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIkZJTklTSFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjoge1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdfRVNDQVBFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR19FU0NBUEVcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTlVNQkVSXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgIGNhc2UgXCIuXCI6IHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaSArIDEpO1xuICAgICAgICBpZiAoIVwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgcmVzdWx0ID0gaW5wdXQuc2xpY2UoMCwgbGFzdFZhbGlkSW5kZXggKyAxKTtcbiAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdGFja1tpXTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHJlc3VsdCArPSAnXCInO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJ9XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGlmIChcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcInRydWVcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcImZhbHNlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcIm51bGxcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uVGV4dCkge1xuICBpZiAoanNvblRleHQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcInVuZGVmaW5lZC1pbnB1dFwiIH07XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiBqc29uVGV4dCB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwic3VjY2Vzc2Z1bC1wYXJzZVwiIH07XG4gIH1cbiAgcmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTih7IHRleHQ6IGZpeEpzb24oanNvblRleHQpIH0pO1xuICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBzdGF0ZTogXCJyZXBhaXJlZC1wYXJzZVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwiZmFpbGVkLXBhcnNlXCIgfTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvb3V0cHV0LnRzXG52YXIgdGV4dCA9ICgpID0+ICh7XG4gIG5hbWU6IFwidGV4dFwiLFxuICByZXNwb25zZUZvcm1hdDogUHJvbWlzZS5yZXNvbHZlKHsgdHlwZTogXCJ0ZXh0XCIgfSksXG4gIGFzeW5jIHBhcnNlQ29tcGxldGVPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgcmV0dXJuIHRleHQyO1xuICB9LFxuICBhc3luYyBwYXJzZVBhcnRpYWxPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgcmV0dXJuIHsgcGFydGlhbDogdGV4dDIgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59KTtcbnZhciBvYmplY3QgPSAoe1xuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBuYW1lOiBuYW1lMTcsXG4gIGRlc2NyaXB0aW9uXG59KSA9PiB7XG4gIGNvbnN0IHNjaGVtYSA9IGFzU2NoZW1hMihpbnB1dFNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJvYmplY3RcIixcbiAgICByZXNwb25zZUZvcm1hdDogcmVzb2x2ZShzY2hlbWEuanNvblNjaGVtYSkudGhlbigoanNvblNjaGVtYTIpID0+ICh7XG4gICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgIHNjaGVtYToganNvblNjaGVtYTIsXG4gICAgICAuLi5uYW1lMTcgIT0gbnVsbCAmJiB7IG5hbWU6IG5hbWUxNyB9LFxuICAgICAgLi4uZGVzY3JpcHRpb24gIT0gbnVsbCAmJiB7IGRlc2NyaXB0aW9uIH1cbiAgICB9KSksXG4gICAgYXN5bmMgcGFyc2VDb21wbGV0ZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQyKSB7XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogdGV4dDIgfSk7XG4gICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczIoe1xuICAgICAgICB2YWx1ZTogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgIHNjaGVtYVxuICAgICAgfSk7XG4gICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZVBhcnRpYWxPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKHRleHQyKTtcbiAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZC1pbnB1dFwiOiB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjoge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgICAgICBwYXJ0aWFsOiByZXN1bHQudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH07XG59O1xudmFyIGFycmF5ID0gKHtcbiAgZWxlbWVudDogaW5wdXRFbGVtZW50U2NoZW1hLFxuICBuYW1lOiBuYW1lMTcsXG4gIGRlc2NyaXB0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVsZW1lbnRTY2hlbWEgPSBhc1NjaGVtYTIoaW5wdXRFbGVtZW50U2NoZW1hKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImFycmF5XCIsXG4gICAgLy8gSlNPTiBzY2hlbWEgdGhhdCBkZXNjcmliZXMgYW4gYXJyYXkgb2YgZWxlbWVudHM6XG4gICAgcmVzcG9uc2VGb3JtYXQ6IHJlc29sdmUoZWxlbWVudFNjaGVtYS5qc29uU2NoZW1hKS50aGVuKChqc29uU2NoZW1hMikgPT4ge1xuICAgICAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBqc29uU2NoZW1hMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAkc2NoZW1hOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZWxlbWVudHM6IHsgdHlwZTogXCJhcnJheVwiLCBpdGVtczogaXRlbVNjaGVtYSB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogW1wiZWxlbWVudHNcIl0sXG4gICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm5hbWUxNyAhPSBudWxsICYmIHsgbmFtZTogbmFtZTE3IH0sXG4gICAgICAgIC4uLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgeyBkZXNjcmlwdGlvbiB9XG4gICAgICB9O1xuICAgIH0pLFxuICAgIGFzeW5jIHBhcnNlQ29tcGxldGVPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9LCBjb250ZXh0Mikge1xuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRlclZhbHVlID0gcGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICBpZiAob3V0ZXJWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBvdXRlclZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJlbGVtZW50c1wiIGluIG91dGVyVmFsdWUpIHx8ICFBcnJheS5pc0FycmF5KG91dGVyVmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWU6IG91dGVyVmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJyZXNwb25zZSBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIGFuIGVsZW1lbnRzIGFycmF5XCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIG91dGVyVmFsdWUuZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzMih7XG4gICAgICAgICAgdmFsdWU6IGVsZW1lbnQsXG4gICAgICAgICAgc2NoZW1hOiBlbGVtZW50U2NoZW1hXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dGVyVmFsdWUuZWxlbWVudHM7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZVBhcnRpYWxPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKHRleHQyKTtcbiAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZC1pbnB1dFwiOiB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjoge1xuICAgICAgICAgIGNvbnN0IG91dGVyVmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgaWYgKG91dGVyVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZWxlbWVudHNcIiBpbiBvdXRlclZhbHVlKSB8fCAhQXJyYXkuaXNBcnJheShvdXRlclZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmF3RWxlbWVudHMgPSByZXN1bHQuc3RhdGUgPT09IFwicmVwYWlyZWQtcGFyc2VcIiAmJiBvdXRlclZhbHVlLmVsZW1lbnRzLmxlbmd0aCA+IDAgPyBvdXRlclZhbHVlLmVsZW1lbnRzLnNsaWNlKDAsIC0xKSA6IG91dGVyVmFsdWUuZWxlbWVudHM7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJhd0VsZW1lbnQgb2YgcmF3RWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgICB2YWx1ZTogcmF3RWxlbWVudCxcbiAgICAgICAgICAgICAgc2NoZW1hOiBlbGVtZW50U2NoZW1hXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudHMucHVzaCh2YWxpZGF0aW9uUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgcGFydGlhbDogcGFyc2VkRWxlbWVudHMgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSgpIHtcbiAgICAgIGxldCBwdWJsaXNoZWRFbGVtZW50cyA9IDA7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybSh7IHBhcnRpYWxPdXRwdXQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmIChwYXJ0aWFsT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoOyBwdWJsaXNoZWRFbGVtZW50cyA8IHBhcnRpYWxPdXRwdXQubGVuZ3RoOyBwdWJsaXNoZWRFbGVtZW50cysrKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0aWFsT3V0cHV0W3B1Ymxpc2hlZEVsZW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xudmFyIGNob2ljZSA9ICh7XG4gIG9wdGlvbnM6IGNob2ljZU9wdGlvbnMsXG4gIG5hbWU6IG5hbWUxNyxcbiAgZGVzY3JpcHRpb25cbn0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImNob2ljZVwiLFxuICAgIC8vIEpTT04gc2NoZW1hIHRoYXQgZGVzY3JpYmVzIGFuIGVudW1lcmF0aW9uOlxuICAgIHJlc3BvbnNlRm9ybWF0OiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICBzY2hlbWE6IHtcbiAgICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHJlc3VsdDogeyB0eXBlOiBcInN0cmluZ1wiLCBlbnVtOiBjaG9pY2VPcHRpb25zIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICB9LFxuICAgICAgLi4ubmFtZTE3ICE9IG51bGwgJiYgeyBuYW1lOiBuYW1lMTcgfSxcbiAgICAgIC4uLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgeyBkZXNjcmlwdGlvbiB9XG4gICAgfSksXG4gICAgYXN5bmMgcGFyc2VDb21wbGV0ZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQyKSB7XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogdGV4dDIgfSk7XG4gICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dGVyVmFsdWUgPSBwYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgIGlmIChvdXRlclZhbHVlID09IG51bGwgfHwgdHlwZW9mIG91dGVyVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJlc3VsdFwiIGluIG91dGVyVmFsdWUpIHx8IHR5cGVvZiBvdXRlclZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIiB8fCAhY2hvaWNlT3B0aW9ucy5pbmNsdWRlcyhvdXRlclZhbHVlLnJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgY2F1c2U6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMih7XG4gICAgICAgICAgICB2YWx1ZTogb3V0ZXJWYWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInJlc3BvbnNlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBjaG9pY2UgdmFsdWUuXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dGVyVmFsdWUucmVzdWx0O1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjoge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlcGFpcmVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzZnVsLXBhcnNlXCI6IHtcbiAgICAgICAgICBjb25zdCBvdXRlclZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgIGlmIChvdXRlclZhbHVlID09IG51bGwgfHwgdHlwZW9mIG91dGVyVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJlc3VsdFwiIGluIG91dGVyVmFsdWUpIHx8IHR5cGVvZiBvdXRlclZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcG90ZW50aWFsTWF0Y2hlcyA9IGNob2ljZU9wdGlvbnMuZmlsdGVyKFxuICAgICAgICAgICAgKGNob2ljZU9wdGlvbikgPT4gY2hvaWNlT3B0aW9uLnN0YXJ0c1dpdGgob3V0ZXJWYWx1ZS5yZXN1bHQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN0YXRlID09PSBcInN1Y2Nlc3NmdWwtcGFyc2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIHBvdGVudGlhbE1hdGNoZXMuaW5jbHVkZXMob3V0ZXJWYWx1ZS5yZXN1bHQpID8geyBwYXJ0aWFsOiBvdXRlclZhbHVlLnJlc3VsdCB9IDogdm9pZCAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsTWF0Y2hlcy5sZW5ndGggPT09IDEgPyB7IHBhcnRpYWw6IHBvdGVudGlhbE1hdGNoZXNbMF0gfSA6IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfTtcbn07XG52YXIganNvbiA9ICh7XG4gIG5hbWU6IG5hbWUxNyxcbiAgZGVzY3JpcHRpb25cbn0gPSB7fSkgPT4ge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwianNvblwiLFxuICAgIHJlc3BvbnNlRm9ybWF0OiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAuLi5uYW1lMTcgIT0gbnVsbCAmJiB7IG5hbWU6IG5hbWUxNyB9LFxuICAgICAgLi4uZGVzY3JpcHRpb24gIT0gbnVsbCAmJiB7IGRlc2NyaXB0aW9uIH1cbiAgICB9KSxcbiAgICBhc3luYyBwYXJzZUNvbXBsZXRlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSwgY29udGV4dDIpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0LnZhbHVlO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbih0ZXh0Mik7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWQtaW5wdXRcIjoge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlcGFpcmVkLXBhcnNlXCI6XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzZnVsLXBhcnNlXCI6IHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB7IHBhcnRpYWw6IHJlc3VsdC52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9wYXJzZS10b29sLWNhbGwudHNcbmltcG9ydCB7XG4gIGFzU2NoZW1hIGFzIGFzU2NoZW1hMyxcbiAgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMyxcbiAgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzLFxuICByZXBhaXJUb29sQ2FsbCxcbiAgc3lzdGVtLFxuICBtZXNzYWdlc1xufSkge1xuICB2YXIgX2ExNztcbiAgdHJ5IHtcbiAgICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgICAgaWYgKHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgJiYgdG9vbENhbGwuZHluYW1pYykge1xuICAgICAgICByZXR1cm4gYXdhaXQgcGFyc2VQcm92aWRlckV4ZWN1dGVkRHluYW1pY1Rvb2xDYWxsKHRvb2xDYWxsKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGwsIHRvb2xzIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAocmVwYWlyVG9vbENhbGwgPT0gbnVsbCB8fCAhKE5vU3VjaFRvb2xFcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBJbnZhbGlkVG9vbElucHV0RXJyb3IuaXNJbnN0YW5jZShlcnJvcikpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgbGV0IHJlcGFpcmVkVG9vbENhbGwgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVwYWlyZWRUb29sQ2FsbCA9IGF3YWl0IHJlcGFpclRvb2xDYWxsKHtcbiAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBpbnB1dFNjaGVtYTogYXN5bmMgKHsgdG9vbE5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpbnB1dFNjaGVtYSB9ID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFzU2NoZW1hMyhpbnB1dFNjaGVtYSkuanNvblNjaGVtYTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKHJlcGFpckVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sQ2FsbFJlcGFpckVycm9yKHtcbiAgICAgICAgICBjYXVzZTogcmVwYWlyRXJyb3IsXG4gICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmVwYWlyZWRUb29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IGRvUGFyc2VUb29sQ2FsbCh7IHRvb2xDYWxsOiByZXBhaXJlZFRvb2xDYWxsLCB0b29scyB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgcGFyc2VkSW5wdXQgPSBhd2FpdCBzYWZlUGFyc2VKU09OMyh7IHRleHQ6IHRvb2xDYWxsLmlucHV0IH0pO1xuICAgIGNvbnN0IGlucHV0ID0gcGFyc2VkSW5wdXQuc3VjY2VzcyA/IHBhcnNlZElucHV0LnZhbHVlIDogdG9vbENhbGwuaW5wdXQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgaW5wdXQsXG4gICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgaW52YWxpZDogdHJ1ZSxcbiAgICAgIGVycm9yLFxuICAgICAgdGl0bGU6IChfYTE3ID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcudGl0bGUsXG4gICAgICBwcm92aWRlckV4ZWN1dGVkOiB0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YVxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlUHJvdmlkZXJFeGVjdXRlZER5bmFtaWNUb29sQ2FsbCh0b29sQ2FsbCkge1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmlucHV0LnRyaW0oKSA9PT0gXCJcIiA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHt9IH0gOiBhd2FpdCBzYWZlUGFyc2VKU09OMyh7IHRleHQ6IHRvb2xDYWxsLmlucHV0IH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xJbnB1dEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIHRvb2xJbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgaW5wdXQ6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgZHluYW1pYzogdHJ1ZSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkb1BhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgaWYgKHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgJiYgdG9vbENhbGwuZHluYW1pYykge1xuICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlUHJvdmlkZXJFeGVjdXRlZER5bmFtaWNUb29sQ2FsbCh0b29sQ2FsbCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNjaGVtYSA9IGFzU2NoZW1hMyh0b29sMi5pbnB1dFNjaGVtYSk7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gdG9vbENhbGwuaW5wdXQudHJpbSgpID09PSBcIlwiID8gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IHt9LCBzY2hlbWEgfSkgOiBhd2FpdCBzYWZlUGFyc2VKU09OMyh7IHRleHQ6IHRvb2xDYWxsLmlucHV0LCBzY2hlbWEgfSk7XG4gIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbElucHV0RXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sSW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRvb2wyLnR5cGUgPT09IFwiZHluYW1pY1wiID8ge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgaW5wdXQ6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogdG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSxcbiAgICBkeW5hbWljOiB0cnVlLFxuICAgIHRpdGxlOiB0b29sMi50aXRsZVxuICB9IDoge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZSxcbiAgICBpbnB1dDogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCxcbiAgICBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhLFxuICAgIHRpdGxlOiB0b29sMi50aXRsZVxuICB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zdGVwLXJlc3VsdC50c1xudmFyIERlZmF1bHRTdGVwUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGVudCxcbiAgICBmaW5pc2hSZWFzb24sXG4gICAgcmF3RmluaXNoUmVhc29uLFxuICAgIHVzYWdlLFxuICAgIHdhcm5pbmdzLFxuICAgIHJlcXVlc3QsXG4gICAgcmVzcG9uc2UsXG4gICAgcHJvdmlkZXJNZXRhZGF0YVxuICB9KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnJhd0ZpbmlzaFJlYXNvbiA9IHJhd0ZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IHByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpO1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIik7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZ1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhc29uaW5nLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHRoaXMucmVhc29uaW5nLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpO1xuICB9XG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcImZpbGVcIikubWFwKChwYXJ0KSA9PiBwYXJ0LmZpbGUpO1xuICB9XG4gIGdldCBzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwic291cmNlXCIpO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIik7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sQ2FsbHMuZmlsdGVyKFxuICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC5keW5hbWljICE9PSB0cnVlXG4gICAgKTtcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sQ2FsbHMuZmlsdGVyKFxuICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC5keW5hbWljID09PSB0cnVlXG4gICAgKTtcbiAgfVxuICBnZXQgdG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbFJlc3VsdHMuZmlsdGVyKFxuICAgICAgKHRvb2xSZXN1bHQpID0+IHRvb2xSZXN1bHQuZHluYW1pYyAhPT0gdHJ1ZVxuICAgICk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgICAodG9vbFJlc3VsdCkgPT4gdG9vbFJlc3VsdC5keW5hbWljID09PSB0cnVlXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RvcC1jb25kaXRpb24udHNcbmZ1bmN0aW9uIHN0ZXBDb3VudElzKHN0ZXBDb3VudCkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4gc3RlcHMubGVuZ3RoID09PSBzdGVwQ291bnQ7XG59XG5mdW5jdGlvbiBoYXNUb29sQ2FsbCh0b29sTmFtZSkge1xuICByZXR1cm4gKHsgc3RlcHMgfSkgPT4ge1xuICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYTE3ID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNvbWUoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnRvb2xOYW1lID09PSB0b29sTmFtZVxuICAgICkpICE9IG51bGwgPyBfYyA6IGZhbHNlO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaXNTdG9wQ29uZGl0aW9uTWV0KHtcbiAgc3RvcENvbmRpdGlvbnMsXG4gIHN0ZXBzXG59KSB7XG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoc3RvcENvbmRpdGlvbnMubWFwKChjb25kaXRpb24pID0+IGNvbmRpdGlvbih7IHN0ZXBzIH0pKSkpLnNvbWUoKHJlc3VsdCkgPT4gcmVzdWx0KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvdG8tcmVzcG9uc2UtbWVzc2FnZXMudHNcbmFzeW5jIGZ1bmN0aW9uIHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gIGNvbnRlbnQ6IGlucHV0Q29udGVudCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICBjb25zdCBjb250ZW50ID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBpbnB1dENvbnRlbnQpIHtcbiAgICBpZiAocGFydC50eXBlID09PSBcInNvdXJjZVwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1lcnJvclwiKSAmJiAhcGFydC5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgcGFydC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICBkYXRhOiBwYXJ0LmZpbGUuYmFzZTY0LFxuICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5maWxlLm1lZGlhVHlwZSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9vbC1jYWxsXCI6XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1twYXJ0LnRvb2xOYW1lXSxcbiAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgIGVycm9yTW9kZTogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtZXJyb3JcIjoge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbcGFydC50b29sTmFtZV0sXG4gICAgICAgICAgb3V0cHV0OiBwYXJ0LmVycm9yLFxuICAgICAgICAgIGVycm9yTW9kZTogXCJqc29uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOlxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGwudG9vbENhbGxJZFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB0b29sUmVzdWx0Q29udGVudCA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgaW5wdXRDb250ZW50KSB7XG4gICAgaWYgKCEocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikgfHwgcGFydC5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgb3V0cHV0OiBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiA/IHBhcnQub3V0cHV0IDogcGFydC5lcnJvcixcbiAgICAgIGVycm9yTW9kZTogcGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIiA/IFwidGV4dFwiIDogXCJub25lXCJcbiAgICB9KTtcbiAgICB0b29sUmVzdWx0Q29udGVudC5wdXNoKHtcbiAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgb3V0cHV0LFxuICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgIH0pO1xuICB9XG4gIGlmICh0b29sUmVzdWx0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgY29udGVudDogdG9vbFJlc3VsdENvbnRlbnRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlcztcbn1cblxuLy8gc3JjL3V0aWwvbWVyZ2UtYWJvcnQtc2lnbmFscy50c1xuZnVuY3Rpb24gbWVyZ2VBYm9ydFNpZ25hbHMoLi4uc2lnbmFscykge1xuICBjb25zdCB2YWxpZFNpZ25hbHMgPSBzaWduYWxzLmZpbHRlcihcbiAgICAoc2lnbmFsKSA9PiBzaWduYWwgIT0gbnVsbFxuICApO1xuICBpZiAodmFsaWRTaWduYWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHZhbGlkU2lnbmFscy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdmFsaWRTaWduYWxzWzBdO1xuICB9XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGZvciAoY29uc3Qgc2lnbmFsIG9mIHZhbGlkU2lnbmFscykge1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgY29udHJvbGxlci5hYm9ydChzaWduYWwucmVhc29uKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICB9XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImFib3J0XCIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoc2lnbmFsLnJlYXNvbik7XG4gICAgICB9LFxuICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKHtcbiAgcHJlZml4OiBcImFpdHh0XCIsXG4gIHNpemU6IDI0XG59KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIHRpbWVvdXQsXG4gIGhlYWRlcnMsXG4gIHN0b3BXaGVuID0gc3RlcENvdW50SXMoMSksXG4gIGV4cGVyaW1lbnRhbF9vdXRwdXQsXG4gIG91dHB1dCA9IGV4cGVyaW1lbnRhbF9vdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGFjdGl2ZVRvb2xzID0gZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzLFxuICBleHBlcmltZW50YWxfcHJlcGFyZVN0ZXAsXG4gIHByZXBhcmVTdGVwID0gZXhwZXJpbWVudGFsX3ByZXBhcmVTdGVwLFxuICBleHBlcmltZW50YWxfcmVwYWlyVG9vbENhbGw6IHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIF9pbnRlcm5hbDogeyBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZCB9ID0ge30sXG4gIG9uU3RlcEZpbmlzaCxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBzdG9wQ29uZGl0aW9ucyA9IGFzQXJyYXkoc3RvcFdoZW4pO1xuICBjb25zdCB0b3RhbFRpbWVvdXRNcyA9IGdldFRvdGFsVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBzdGVwVGltZW91dE1zID0gZ2V0U3RlcFRpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3Qgc3RlcEFib3J0Q29udHJvbGxlciA9IHN0ZXBUaW1lb3V0TXMgIT0gbnVsbCA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IHZvaWQgMDtcbiAgY29uc3QgbWVyZ2VkQWJvcnRTaWduYWwgPSBtZXJnZUFib3J0U2lnbmFscyhcbiAgICBhYm9ydFNpZ25hbCxcbiAgICB0b3RhbFRpbWVvdXRNcyAhPSBudWxsID8gQWJvcnRTaWduYWwudGltZW91dCh0b3RhbFRpbWVvdXRNcykgOiB2b2lkIDAsXG4gICAgc3RlcEFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogc3RlcEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgKTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4MihcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgY29uc3QgaW5pdGlhbE1lc3NhZ2VzID0gaW5pdGlhbFByb21wdC5tZXNzYWdlcztcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgICBjb25zdCB7IGFwcHJvdmVkVG9vbEFwcHJvdmFscywgZGVuaWVkVG9vbEFwcHJvdmFscyB9ID0gY29sbGVjdFRvb2xBcHByb3ZhbHMoeyBtZXNzYWdlczogaW5pdGlhbE1lc3NhZ2VzIH0pO1xuICAgICAgICBjb25zdCBsb2NhbEFwcHJvdmVkVG9vbEFwcHJvdmFscyA9IGFwcHJvdmVkVG9vbEFwcHJvdmFscy5maWx0ZXIoXG4gICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gIXRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkZW5pZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDAgfHwgbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xPdXRwdXRzID0gYXdhaXQgZXhlY3V0ZVRvb2xzKHtcbiAgICAgICAgICAgIHRvb2xDYWxsczogbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMubWFwKFxuICAgICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiB0b29sQXBwcm92YWwudG9vbENhbGxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBpbml0aWFsTWVzc2FnZXMsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogbWVyZ2VkQWJvcnRTaWduYWwsXG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHRvb2xDb250ZW50ID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBvdXRwdXQyIG9mIHRvb2xPdXRwdXRzKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbE91dHB1dCA9IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG91dHB1dDIudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgaW5wdXQ6IG91dHB1dDIuaW5wdXQsXG4gICAgICAgICAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1tvdXRwdXQyLnRvb2xOYW1lXSxcbiAgICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiA/IG91dHB1dDIub3V0cHV0IDogb3V0cHV0Mi5lcnJvcixcbiAgICAgICAgICAgICAgZXJyb3JNb2RlOiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1lcnJvclwiID8gXCJqc29uXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b29sQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvdXRwdXQyLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBvdXRwdXQyLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBvdXRwdXQ6IG1vZGVsT3V0cHV0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCB0b29sQXBwcm92YWwgb2YgZGVuaWVkVG9vbEFwcHJvdmFscykge1xuICAgICAgICAgICAgdG9vbENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQXBwcm92YWwudG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgIG91dHB1dDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXhlY3V0aW9uLWRlbmllZFwiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UucmVhc29uLFxuICAgICAgICAgICAgICAgIC8vIEZvciBwcm92aWRlci1leGVjdXRlZCB0b29scywgaW5jbHVkZSBhcHByb3ZhbElkIHNvIHByb3ZpZGVyIGNhbiBjb3JyZWxhdGVcbiAgICAgICAgICAgICAgICAuLi50b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAmJiB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmFpOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UuYXBwcm92YWxJZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY29udGVudDogdG9vbENvbnRlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscyA9IFtcbiAgICAgICAgICAuLi5hcHByb3ZlZFRvb2xBcHByb3ZhbHMsXG4gICAgICAgICAgLi4uZGVuaWVkVG9vbEFwcHJvdmFsc1xuICAgICAgICBdLmZpbHRlcigodG9vbEFwcHJvdmFsKSA9PiB0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCk7XG4gICAgICAgIGlmIChwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY29udGVudDogcHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMubWFwKFxuICAgICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWQsXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmVkLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UucmVhc29uLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsU2V0dGluZ3MyID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgICAgbGV0IGNsaWVudFRvb2xDYWxscyA9IFtdO1xuICAgICAgICBsZXQgY2xpZW50VG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgICAgICAgY29uc3QgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IHN0ZXBUaW1lb3V0SWQgPSBzdGVwVGltZW91dE1zICE9IG51bGwgPyBzZXRUaW1lb3V0KCgpID0+IHN0ZXBBYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgc3RlcFRpbWVvdXRNcykgOiB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJbnB1dE1lc3NhZ2VzID0gWy4uLmluaXRpYWxNZXNzYWdlcywgLi4ucmVzcG9uc2VNZXNzYWdlc107XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlU3RlcFJlc3VsdCA9IGF3YWl0IChwcmVwYXJlU3RlcCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXAoe1xuICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgICAgIHN0ZXBOdW1iZXI6IHN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcE1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwoXG4gICAgICAgICAgICAgIChfYTE3ID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1vZGVsKSAhPSBudWxsID8gX2ExNyA6IG1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgICAgc3lzdGVtOiAoX2IgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuc3lzdGVtKSAhPSBudWxsID8gX2IgOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogKF9jID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1lc3NhZ2VzKSAhPSBudWxsID8gX2MgOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBzdGVwTW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCA9IChfZCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5leHBlcmltZW50YWxfY29udGV4dCkgIT0gbnVsbCA/IF9kIDogZXhwZXJpbWVudGFsX2NvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCB7IHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLCB0b29sczogc3RlcFRvb2xzIH0gPSBhd2FpdCBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIHRvb2xDaG9pY2U6IChfZSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC50b29sQ2hvaWNlKSAhPSBudWxsID8gX2UgOiB0b29sQ2hvaWNlLFxuICAgICAgICAgICAgICBhY3RpdmVUb29sczogKF9mID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LmFjdGl2ZVRvb2xzKSAhPSBudWxsID8gX2YgOiBhY3RpdmVUb29sc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gbW9kZWw6XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9tcHQ6XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29scyA9PSBudWxsID8gdm9pZCAwIDogc3RlcFRvb2xzLm1hcCgodG9vbDIpID0+IEpTT04uc3RyaW5naWZ5KHRvb2wyKSlcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiAoX2ExOCA9IHNldHRpbmdzLnRlbXBlcmF0dXJlKSAhPSBudWxsID8gX2ExOCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ExOSwgX2IyLCBfYzIsIF9kMiwgX2UyLCBfZjIsIF9nMiwgX2gyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVwUHJvdmlkZXJPcHRpb25zID0gbWVyZ2VPYmplY3RzKFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQucHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0ZXBNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MyLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdGVwVG9vbHMsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IGF3YWl0IChvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5yZXNwb25zZUZvcm1hdCksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHN0ZXBQcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IChfYjIgPSAoX2ExOSA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTkuaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kMiA9IChfYzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYzIudGltZXN0YW1wKSAhPSBudWxsID8gX2QyIDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mMiA9IChfZTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZTIubW9kZWxJZCkgIT0gbnVsbCA/IF9mMiA6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IChfZzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZzIuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoX2gyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2gyLmJvZHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZXh0cmFjdFRleHRDb250ZW50KHJlc3VsdC5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhyZXN1bHQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9vbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIHRlbGVtZXRyeSBhdHRyaWJ1dGVzIHRvIGlucHV0VG9rZW5zIGFuZCBvdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbmlzaFJlYXNvbi51bmlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vucy50b3RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiXG4gICAgICAgICAgICAgICkubWFwKFxuICAgICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdG9vbEFwcHJvdmFsUmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2Ygc3RlcFRvb2xDYWxscykge1xuICAgICAgICAgICAgICBpZiAodG9vbENhbGwuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5vbklucHV0QXZhaWxhYmxlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdG9vbDIub25JbnB1dEF2YWlsYWJsZSh7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXdhaXQgaXNBcHByb3ZhbE5lZWRlZCh7XG4gICAgICAgICAgICAgICAgdG9vbDogdG9vbDIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgdG9vbEFwcHJvdmFsUmVxdWVzdHNbdG9vbENhbGwudG9vbENhbGxJZF0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW52YWxpZFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmludmFsaWQgJiYgdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGludmFsaWRUb29sQ2FsbHMpIHtcbiAgICAgICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvck1lc3NhZ2U1KHRvb2xDYWxsLmVycm9yKSxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50VG9vbENhbGxzID0gc3RlcFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gIXRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodG9vbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGllbnRUb29sT3V0cHV0cy5wdXNoKFxuICAgICAgICAgICAgICAgIC4uLmF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IGNsaWVudFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gIXRvb2xDYWxsLmludmFsaWQgJiYgdG9vbEFwcHJvdmFsUmVxdWVzdHNbdG9vbENhbGwudG9vbENhbGxJZF0gPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBzdGVwVG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgIGlmICghdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJwcm92aWRlclwiICYmIHRvb2wyLnN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzUmVzdWx0SW5SZXNwb25zZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQuc29tZShcbiAgICAgICAgICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghaGFzUmVzdWx0SW5SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCkge1xuICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMuZGVsZXRlKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0ZXBDb250ZW50ID0gYXNDb250ZW50KHtcbiAgICAgICAgICAgICAgY29udGVudDogY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCxcbiAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICB0b29sT3V0cHV0czogY2xpZW50VG9vbE91dHB1dHMsXG4gICAgICAgICAgICAgIHRvb2xBcHByb3ZhbFJlcXVlc3RzOiBPYmplY3QudmFsdWVzKHRvb2xBcHByb3ZhbFJlcXVlc3RzKSxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAuLi5hd2FpdCB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0ZXBDb250ZW50LFxuICAgICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSBuZXcgRGVmYXVsdFN0ZXBSZXN1bHQoe1xuICAgICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24ucmF3LFxuICAgICAgICAgICAgICB1c2FnZTogYXNMYW5ndWFnZU1vZGVsVXNhZ2UoY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UpLFxuICAgICAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgIHJlcXVlc3Q6IChfZyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfZyA6IHt9LFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIC8vIGRlZXAgY2xvbmUgbXNncyB0byBhdm9pZCBtdXRhdGluZyBwYXN0IG1lc3NhZ2VzIGluIG11bHRpLXN0ZXA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0cnVjdHVyZWRDbG9uZShyZXNwb25zZU1lc3NhZ2VzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICAgICAgd2FybmluZ3M6IChfaCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzKSAhPSBudWxsID8gX2ggOiBbXSxcbiAgICAgICAgICAgICAgcHJvdmlkZXI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgbW9kZWw6IHN0ZXBNb2RlbC5tb2RlbElkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChzdGVwVGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0ZXBUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoXG4gICAgICAgICAgLy8gQ29udGludWUgaWY6XG4gICAgICAgICAgLy8gMS4gVGhlcmUgYXJlIGNsaWVudCB0b29sIGNhbGxzIHRoYXQgaGF2ZSBhbGwgYmVlbiBleGVjdXRlZCwgT1JcbiAgICAgICAgICAvLyAyLiBUaGVyZSBhcmUgcGVuZGluZyBkZWZlcnJlZCByZXN1bHRzIGZyb20gcHJvdmlkZXItZXhlY3V0ZWQgdG9vbHNcbiAgICAgICAgICAoY2xpZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoIHx8IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5zaXplID4gMCkgJiYgLy8gY29udGludWUgdW50aWwgYSBzdG9wIGNvbmRpdGlvbiBpcyBtZXQ6XG4gICAgICAgICAgIWF3YWl0IGlzU3RvcENvbmRpdGlvbk1ldCh7IHN0b3BDb25kaXRpb25zLCBzdGVwcyB9KVxuICAgICAgICApO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZXh0cmFjdFRleHRDb250ZW50KGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IGFzVG9vbENhbGxzKGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xDYWxscyA9PSBudWxsID8gdm9pZCAwIDogSlNPTi5zdHJpbmdpZnkodG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIHRlbGVtZXRyeSBhdHRyaWJ1dGVzIHRvIGlucHV0VG9rZW5zIGFuZCBvdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5vdXRwdXRUb2tlbnMudG90YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBsYXN0U3RlcCA9IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCB0b3RhbFVzYWdlID0gc3RlcHMucmVkdWNlKFxuICAgICAgICAgICh0b3RhbFVzYWdlMiwgc3RlcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFkZExhbmd1YWdlTW9kZWxVc2FnZSh0b3RhbFVzYWdlMiwgc3RlcC51c2FnZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbnB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgb3V0cHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICB0b3RhbFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgcmVhc29uaW5nVG9rZW5zOiB2b2lkIDAsXG4gICAgICAgICAgICBjYWNoZWRJbnB1dFRva2Vuczogdm9pZCAwXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGxhc3RTdGVwLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICByYXdGaW5pc2hSZWFzb246IGxhc3RTdGVwLnJhd0ZpbmlzaFJlYXNvbixcbiAgICAgICAgICB1c2FnZTogbGFzdFN0ZXAudXNhZ2UsXG4gICAgICAgICAgY29udGVudDogbGFzdFN0ZXAuY29udGVudCxcbiAgICAgICAgICB0ZXh0OiBsYXN0U3RlcC50ZXh0LFxuICAgICAgICAgIHJlYXNvbmluZ1RleHQ6IGxhc3RTdGVwLnJlYXNvbmluZ1RleHQsXG4gICAgICAgICAgcmVhc29uaW5nOiBsYXN0U3RlcC5yZWFzb25pbmcsXG4gICAgICAgICAgZmlsZXM6IGxhc3RTdGVwLmZpbGVzLFxuICAgICAgICAgIHNvdXJjZXM6IGxhc3RTdGVwLnNvdXJjZXMsXG4gICAgICAgICAgdG9vbENhbGxzOiBsYXN0U3RlcC50b29sQ2FsbHMsXG4gICAgICAgICAgc3RhdGljVG9vbENhbGxzOiBsYXN0U3RlcC5zdGF0aWNUb29sQ2FsbHMsXG4gICAgICAgICAgZHluYW1pY1Rvb2xDYWxsczogbGFzdFN0ZXAuZHluYW1pY1Rvb2xDYWxscyxcbiAgICAgICAgICB0b29sUmVzdWx0czogbGFzdFN0ZXAudG9vbFJlc3VsdHMsXG4gICAgICAgICAgc3RhdGljVG9vbFJlc3VsdHM6IGxhc3RTdGVwLnN0YXRpY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgIGR5bmFtaWNUb29sUmVzdWx0czogbGFzdFN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgIHJlcXVlc3Q6IGxhc3RTdGVwLnJlcXVlc3QsXG4gICAgICAgICAgcmVzcG9uc2U6IGxhc3RTdGVwLnJlc3BvbnNlLFxuICAgICAgICAgIHdhcm5pbmdzOiBsYXN0U3RlcC53YXJuaW5ncyxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBsYXN0U3RlcC5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIHN0ZXBzLFxuICAgICAgICAgIHRvdGFsVXNhZ2UsXG4gICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRPdXRwdXQ7XG4gICAgICAgIGlmIChsYXN0U3RlcC5maW5pc2hSZWFzb24gPT09IFwic3RvcFwiKSB7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U3BlY2lmaWNhdGlvbiA9IG91dHB1dCAhPSBudWxsID8gb3V0cHV0IDogdGV4dCgpO1xuICAgICAgICAgIHJlc29sdmVkT3V0cHV0ID0gYXdhaXQgb3V0cHV0U3BlY2lmaWNhdGlvbi5wYXJzZUNvbXBsZXRlT3V0cHV0KFxuICAgICAgICAgICAgeyB0ZXh0OiBsYXN0U3RlcC50ZXh0IH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBsYXN0U3RlcC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgdXNhZ2U6IGxhc3RTdGVwLnVzYWdlLFxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGxhc3RTdGVwLmZpbmlzaFJlYXNvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0KHtcbiAgICAgICAgICBzdGVwcyxcbiAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgIG91dHB1dDogcmVzb2x2ZWRPdXRwdXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgd3JhcEdhdGV3YXlFcnJvcihlcnJvcik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29scyh7XG4gIHRvb2xDYWxscyxcbiAgdG9vbHMsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5LFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0XG59KSB7XG4gIGNvbnN0IHRvb2xPdXRwdXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChcbiAgICAgIGFzeW5jICh0b29sQ2FsbCkgPT4gZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgdG9vbENhbGwsXG4gICAgICAgIHRvb2xzLFxuICAgICAgICB0cmFjZXIsXG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgfSlcbiAgICApXG4gICk7XG4gIHJldHVybiB0b29sT3V0cHV0cy5maWx0ZXIoXG4gICAgKG91dHB1dCkgPT4gb3V0cHV0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGVwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5fb3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQ7XG4gICAgdGhpcy50b3RhbFVzYWdlID0gb3B0aW9ucy50b3RhbFVzYWdlO1xuICB9XG4gIGdldCBmaW5hbFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHNbdGhpcy5zdGVwcy5sZW5ndGggLSAxXTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuY29udGVudDtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGV4dDtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmZpbGVzO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZWFzb25pbmdUZXh0O1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlYXNvbmluZztcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50b29sQ2FsbHM7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuc3RhdGljVG9vbENhbGxzO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5keW5hbWljVG9vbENhbGxzO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudG9vbFJlc3VsdHM7XG4gIH1cbiAgZ2V0IHN0YXRpY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5zdGF0aWNUb29sUmVzdWx0cztcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5keW5hbWljVG9vbFJlc3VsdHM7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnNvdXJjZXM7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZmluaXNoUmVhc29uO1xuICB9XG4gIGdldCByYXdGaW5pc2hSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJhd0ZpbmlzaFJlYXNvbjtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLndhcm5pbmdzO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5wcm92aWRlck1ldGFkYXRhO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVzcG9uc2U7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlcXVlc3Q7XG4gIH1cbiAgZ2V0IHVzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC51c2FnZTtcbiAgfVxuICBnZXQgZXhwZXJpbWVudGFsX291dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXQ7XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBpZiAodGhpcy5fb3V0cHV0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb091dHB1dEdlbmVyYXRlZEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vdXRwdXQ7XG4gIH1cbn07XG5mdW5jdGlvbiBhc1Rvb2xDYWxscyhjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIlxuICApO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcGFydHMubWFwKCh0b29sQ2FsbCkgPT4gKHtcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICBpbnB1dDogdG9vbENhbGwuaW5wdXRcbiAgfSkpO1xufVxuZnVuY3Rpb24gYXNDb250ZW50KHtcbiAgY29udGVudCxcbiAgdG9vbENhbGxzLFxuICB0b29sT3V0cHV0cyxcbiAgdG9vbEFwcHJvdmFsUmVxdWVzdHMsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IGNvbnRlbnRQYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOlxuICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICBjb250ZW50UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICBmaWxlOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGUocGFydCksXG4gICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKFxuICAgICAgICAgIHRvb2xDYWxscy5maW5kKCh0b29sQ2FsbCkgPT4gdG9vbENhbGwudG9vbENhbGxJZCA9PT0gcGFydC50b29sQ2FsbElkKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzLmZpbmQoXG4gICAgICAgICAgKHRvb2xDYWxsMikgPT4gdG9vbENhbGwyLnRvb2xDYWxsSWQgPT09IHBhcnQudG9vbENhbGxJZFxuICAgICAgICApO1xuICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdO1xuICAgICAgICAgIGNvbnN0IHN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzID0gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJwcm92aWRlclwiICYmIHRvb2wyLnN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzO1xuICAgICAgICAgIGlmICghc3VwcG9ydHNEZWZlcnJlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCBjYWxsICR7cGFydC50b29sQ2FsbElkfSBub3QgZm91bmQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0LmlzRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgIGVycm9yOiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZHluYW1pYzogcGFydC5keW5hbWljXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgIG91dHB1dDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IHBhcnQuZHluYW1pY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LmlzRXJyb3IpIHtcbiAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtZXJyb3JcIixcbiAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgZXJyb3I6IHBhcnQucmVzdWx0LFxuICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGR5bmFtaWM6IHRvb2xDYWxsLmR5bmFtaWNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgIG91dHB1dDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgZHluYW1pYzogdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOiB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzLmZpbmQoXG4gICAgICAgICAgKHRvb2xDYWxsMikgPT4gdG9vbENhbGwyLnRvb2xDYWxsSWQgPT09IHBhcnQudG9vbENhbGxJZFxuICAgICAgICApO1xuICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvcih7XG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIixcbiAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsSWQsXG4gICAgICAgICAgdG9vbENhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLmNvbnRlbnRQYXJ0cywgLi4udG9vbE91dHB1dHMsIC4uLnRvb2xBcHByb3ZhbFJlcXVlc3RzXTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmltcG9ydCB7XG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U3LFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMixcbiAgRGVsYXllZFByb21pc2UsXG4gIGlzQWJvcnRFcnJvciBhcyBpc0Fib3J0RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL3ByZXBhcmUtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZUhlYWRlcnMoaGVhZGVycywgZGVmYXVsdEhlYWRlcnMpIHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9KTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGVmYXVsdEhlYWRlcnMpKSB7XG4gICAgaWYgKCFyZXNwb25zZUhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNwb25zZUhlYWRlcnM7XG59XG5cbi8vIHNyYy90ZXh0LXN0cmVhbS9jcmVhdGUtdGV4dC1zdHJlYW0tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSh7XG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgdGV4dFN0cmVhbVxufSkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgc3RhdHVzOiBzdGF0dXMgIT0gbnVsbCA/IHN0YXR1cyA6IDIwMCxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfSlcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlsL3dyaXRlLXRvLXNlcnZlci1yZXNwb25zZS50c1xuZnVuY3Rpb24gd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgc3RyZWFtXG59KSB7XG4gIGNvbnN0IHN0YXR1c0NvZGUgPSBzdGF0dXMgIT0gbnVsbCA/IHN0YXR1cyA6IDIwMDtcbiAgaWYgKHN0YXR1c1RleHQgIT09IHZvaWQgMCkge1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZChzdGF0dXNDb2RlLCBzdGF0dXNUZXh0LCBoZWFkZXJzKTtcbiAgfSBlbHNlIHtcbiAgICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzQ29kZSwgaGVhZGVycyk7XG4gIH1cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY29uc3QgY2FuQ29udGludWUgPSByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghY2FuQ29udGludWUpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTMpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uY2UoXCJkcmFpblwiLCByZXNvbHZlMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgIH1cbiAgfTtcbiAgcmVhZCgpO1xufVxuXG4vLyBzcmMvdGV4dC1zdHJlYW0vcGlwZS10ZXh0LXN0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgdGV4dFN0cmVhbVxufSkge1xuICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pLmVudHJpZXMoKVxuICAgICksXG4gICAgc3RyZWFtOiB0ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICB9KTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2pzb24tdG8tc3NlLXRyYW5zZm9ybS1zdHJlYW0udHNcbnZhciBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0gPSBjbGFzcyBleHRlbmRzIFRyYW5zZm9ybVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShgZGF0YTogJHtKU09OLnN0cmluZ2lmeShwYXJ0KX1cblxuYCk7XG4gICAgICB9LFxuICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXCJkYXRhOiBbRE9ORV1cXG5cXG5cIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS91aS1tZXNzYWdlLXN0cmVhbS1oZWFkZXJzLnRzXG52YXIgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUyA9IHtcbiAgXCJjb250ZW50LXR5cGVcIjogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICBcImNhY2hlLWNvbnRyb2xcIjogXCJuby1jYWNoZVwiLFxuICBjb25uZWN0aW9uOiBcImtlZXAtYWxpdmVcIixcbiAgXCJ4LXZlcmNlbC1haS11aS1tZXNzYWdlLXN0cmVhbVwiOiBcInYxXCIsXG4gIFwieC1hY2NlbC1idWZmZXJpbmdcIjogXCJub1wiXG4gIC8vIGRpc2FibGUgbmdpbnggYnVmZmVyaW5nXG59O1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vY3JlYXRlLXVpLW1lc3NhZ2Utc3RyZWFtLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgc3RyZWFtLFxuICBjb25zdW1lU3NlU3RyZWFtXG59KSB7XG4gIGxldCBzc2VTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSgpKTtcbiAgaWYgKGNvbnN1bWVTc2VTdHJlYW0pIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSBzc2VTdHJlYW0udGVlKCk7XG4gICAgc3NlU3RyZWFtID0gc3RyZWFtMTtcbiAgICBjb25zdW1lU3NlU3RyZWFtKHsgc3RyZWFtOiBzdHJlYW0yIH0pO1xuICB9XG4gIHJldHVybiBuZXcgUmVzcG9uc2Uoc3NlU3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMpXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vZ2V0LXJlc3BvbnNlLXVpLW1lc3NhZ2UtaWQudHNcbmZ1bmN0aW9uIGdldFJlc3BvbnNlVUlNZXNzYWdlSWQoe1xuICBvcmlnaW5hbE1lc3NhZ2VzLFxuICByZXNwb25zZU1lc3NhZ2VJZFxufSkge1xuICBpZiAob3JpZ2luYWxNZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBsYXN0TWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZXNbb3JpZ2luYWxNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgPT09IFwiYXNzaXN0YW50XCIgPyBsYXN0TWVzc2FnZS5pZCA6IHR5cGVvZiByZXNwb25zZU1lc3NhZ2VJZCA9PT0gXCJmdW5jdGlvblwiID8gcmVzcG9uc2VNZXNzYWdlSWQoKSA6IHJlc3BvbnNlTWVzc2FnZUlkO1xufVxuXG4vLyBzcmMvdWkvcHJvY2Vzcy11aS1tZXNzYWdlLXN0cmVhbS50c1xuaW1wb3J0IHsgdmFsaWRhdGVUeXBlcyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS91aS1tZXNzYWdlLWNodW5rcy50c1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2QvdjRcIjtcbmltcG9ydCB7IGxhenlTY2hlbWEsIHpvZFNjaGVtYSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgdWlNZXNzYWdlQ2h1bmtTY2hlbWEgPSBsYXp5U2NoZW1hKFxuICAoKSA9PiB6b2RTY2hlbWEoXG4gICAgejcudW5pb24oW1xuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRleHQtc3RhcnRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWRlbHRhXCIpLFxuICAgICAgICBpZDogejcuc3RyaW5nKCksXG4gICAgICAgIGRlbHRhOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LWVuZFwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcImVycm9yXCIpLFxuICAgICAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LXN0YXJ0XCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbE5hbWU6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtZGVsdGFcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBpbnB1dFRleHREZWx0YTogejcuc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbE5hbWU6IHo3LnN0cmluZygpLFxuICAgICAgICBpbnB1dDogejcudW5rbm93bigpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtaW5wdXQtZXJyb3JcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICB0b29sTmFtZTogejcuc3RyaW5nKCksXG4gICAgICAgIGlucHV0OiB6Ny51bmtub3duKCksXG4gICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpLFxuICAgICAgICB0aXRsZTogejcuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpLFxuICAgICAgICBhcHByb3ZhbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtb3V0cHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIG91dHB1dDogejcudW5rbm93bigpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHByZWxpbWluYXJ5OiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1vdXRwdXQtZXJyb3JcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBlcnJvclRleHQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtb3V0cHV0LWRlbmllZFwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1zdGFydFwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1kZWx0YVwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBkZWx0YTogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwicmVhc29uaW5nLWVuZFwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInNvdXJjZS11cmxcIiksXG4gICAgICAgIHNvdXJjZUlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdXJsOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwic291cmNlLWRvY3VtZW50XCIpLFxuICAgICAgICBzb3VyY2VJZDogejcuc3RyaW5nKCksXG4gICAgICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgZmlsZW5hbWU6IHo3LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmlsZVwiKSxcbiAgICAgICAgdXJsOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgbWVkaWFUeXBlOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmN1c3RvbShcbiAgICAgICAgICAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKFwiZGF0YS1cIiksXG4gICAgICAgICAgeyBtZXNzYWdlOiAnVHlwZSBtdXN0IHN0YXJ0IHdpdGggXCJkYXRhLVwiJyB9XG4gICAgICAgICksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBkYXRhOiB6Ny51bmtub3duKCksXG4gICAgICAgIHRyYW5zaWVudDogejcuYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInN0YXJ0LXN0ZXBcIilcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcImZpbmlzaC1zdGVwXCIpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzdGFydFwiKSxcbiAgICAgICAgbWVzc2FnZUlkOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJmaW5pc2hcIiksXG4gICAgICAgIGZpbmlzaFJlYXNvbjogejcuZW51bShbXG4gICAgICAgICAgXCJzdG9wXCIsXG4gICAgICAgICAgXCJsZW5ndGhcIixcbiAgICAgICAgICBcImNvbnRlbnQtZmlsdGVyXCIsXG4gICAgICAgICAgXCJ0b29sLWNhbGxzXCIsXG4gICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgIFwib3RoZXJcIlxuICAgICAgICBdKS5vcHRpb25hbCgpLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJhYm9ydFwiKSxcbiAgICAgICAgcmVhc29uOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJtZXNzYWdlLW1ldGFkYXRhXCIpLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGE6IHo3LnVua25vd24oKVxuICAgICAgfSlcbiAgICBdKVxuICApXG4pO1xuZnVuY3Rpb24gaXNEYXRhVUlNZXNzYWdlQ2h1bmsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnR5cGUuc3RhcnRzV2l0aChcImRhdGEtXCIpO1xufVxuXG4vLyBzcmMvdWkvdWktbWVzc2FnZXMudHNcbmZ1bmN0aW9uIGlzRGF0YVVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3RhcnRzV2l0aChcImRhdGEtXCIpO1xufVxuZnVuY3Rpb24gaXNUZXh0VUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCI7XG59XG5mdW5jdGlvbiBpc0ZpbGVVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlID09PSBcImZpbGVcIjtcbn1cbmZ1bmN0aW9uIGlzUmVhc29uaW5nVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIjtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljVG9vbFVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3RhcnRzV2l0aChcInRvb2wtXCIpO1xufVxuZnVuY3Rpb24gaXNEeW5hbWljVG9vbFVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUgPT09IFwiZHluYW1pYy10b29sXCI7XG59XG5mdW5jdGlvbiBpc1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gaXNTdGF0aWNUb29sVUlQYXJ0KHBhcnQpIHx8IGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCk7XG59XG52YXIgaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydCA9IGlzVG9vbFVJUGFydDtcbmZ1bmN0aW9uIGdldFN0YXRpY1Rvb2xOYW1lKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZS5zcGxpdChcIi1cIikuc2xpY2UoMSkuam9pbihcIi1cIik7XG59XG5mdW5jdGlvbiBnZXRUb29sTmFtZShwYXJ0KSB7XG4gIHJldHVybiBpc0R5bmFtaWNUb29sVUlQYXJ0KHBhcnQpID8gcGFydC50b29sTmFtZSA6IGdldFN0YXRpY1Rvb2xOYW1lKHBhcnQpO1xufVxudmFyIGdldFRvb2xPckR5bmFtaWNUb29sTmFtZSA9IGdldFRvb2xOYW1lO1xuXG4vLyBzcmMvdWkvcHJvY2Vzcy11aS1tZXNzYWdlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICBsYXN0TWVzc2FnZSxcbiAgbWVzc2FnZUlkXG59KSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSA9PT0gXCJhc3Npc3RhbnRcIiA/IGxhc3RNZXNzYWdlIDoge1xuICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgIG1ldGFkYXRhOiB2b2lkIDAsXG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgcGFydHM6IFtdXG4gICAgfSxcbiAgICBhY3RpdmVUZXh0UGFydHM6IHt9LFxuICAgIGFjdGl2ZVJlYXNvbmluZ1BhcnRzOiB7fSxcbiAgICBwYXJ0aWFsVG9vbENhbGxzOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1VJTWVzc2FnZVN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICBkYXRhUGFydFNjaGVtYXMsXG4gIHJ1blVwZGF0ZU1lc3NhZ2VKb2IsXG4gIG9uRXJyb3IsXG4gIG9uVG9vbENhbGwsXG4gIG9uRGF0YVxufSkge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGF3YWl0IHJ1blVwZGF0ZU1lc3NhZ2VKb2IoYXN5bmMgKHsgc3RhdGUsIHdyaXRlIH0pID0+IHtcbiAgICAgICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgICAgICAgICBmdW5jdGlvbiBnZXRUb29sSW52b2NhdGlvbih0b29sQ2FsbElkKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbHRlcihpc1Rvb2xVSVBhcnQpO1xuICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSB0b29sSW52b2NhdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgICAgICAgICAgIGNodW5rSWQ6IHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIHRvb2wgaW52b2NhdGlvbiBmb3VuZCBmb3IgdG9vbCBjYWxsIElEIFwiJHt0b29sQ2FsbElkfVwiLmBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbEludm9jYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRvb2xQYXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgKHBhcnQyKSA9PiBpc1N0YXRpY1Rvb2xVSVBhcnQocGFydDIpICYmIHBhcnQyLnRvb2xDYWxsSWQgPT09IG9wdGlvbnMudG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGFueU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgYW55UGFydCA9IHBhcnQ7XG4gICAgICAgICAgICBpZiAocGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnQuc3RhdGUgPSBvcHRpb25zLnN0YXRlO1xuICAgICAgICAgICAgICBhbnlQYXJ0LmlucHV0ID0gYW55T3B0aW9ucy5pbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5vdXRwdXQgPSBhbnlPcHRpb25zLm91dHB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5lcnJvclRleHQgPSBhbnlPcHRpb25zLmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgYW55UGFydC5yYXdJbnB1dCA9IGFueU9wdGlvbnMucmF3SW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucHJlbGltaW5hcnkgPSBhbnlPcHRpb25zLnByZWxpbWluYXJ5O1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYW55UGFydC50aXRsZSA9IG9wdGlvbnMudGl0bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYW55UGFydC5wcm92aWRlckV4ZWN1dGVkID0gKF9hMTggPSBhbnlPcHRpb25zLnByb3ZpZGVyRXhlY3V0ZWQpICE9IG51bGwgPyBfYTE4IDogcGFydC5wcm92aWRlckV4ZWN1dGVkO1xuICAgICAgICAgICAgICBpZiAoYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhID0gYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGB0b29sLSR7b3B0aW9ucy50b29sTmFtZX1gLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG9wdGlvbnMudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogYW55T3B0aW9ucy5pbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGFueU9wdGlvbnMub3V0cHV0LFxuICAgICAgICAgICAgICAgIHJhd0lucHV0OiBhbnlPcHRpb25zLnJhd0lucHV0LFxuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogYW55T3B0aW9ucy5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogYW55T3B0aW9ucy5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBhbnlPcHRpb25zLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgIC4uLmFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBjYWxsUHJvdmlkZXJNZXRhZGF0YTogYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTE4LCBfYjI7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgICAgICAgICAgICAocGFydDIpID0+IHBhcnQyLnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIgJiYgcGFydDIudG9vbENhbGxJZCA9PT0gb3B0aW9ucy50b29sQ2FsbElkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgYW55T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBhbnlQYXJ0ID0gcGFydDtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFydC5zdGF0ZSA9IG9wdGlvbnMuc3RhdGU7XG4gICAgICAgICAgICAgIGFueVBhcnQudG9vbE5hbWUgPSBvcHRpb25zLnRvb2xOYW1lO1xuICAgICAgICAgICAgICBhbnlQYXJ0LmlucHV0ID0gYW55T3B0aW9ucy5pbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5vdXRwdXQgPSBhbnlPcHRpb25zLm91dHB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5lcnJvclRleHQgPSBhbnlPcHRpb25zLmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgYW55UGFydC5yYXdJbnB1dCA9IChfYTE4ID0gYW55T3B0aW9ucy5yYXdJbnB1dCkgIT0gbnVsbCA/IF9hMTggOiBhbnlQYXJ0LnJhd0lucHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnByZWxpbWluYXJ5ID0gYW55T3B0aW9ucy5wcmVsaW1pbmFyeTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGFueVBhcnQudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFueVBhcnQucHJvdmlkZXJFeGVjdXRlZCA9IChfYjIgPSBhbnlPcHRpb25zLnByb3ZpZGVyRXhlY3V0ZWQpICE9IG51bGwgPyBfYjIgOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQ7XG4gICAgICAgICAgICAgIGlmIChhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgPSBhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkeW5hbWljLXRvb2xcIixcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogb3B0aW9ucy50b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBhbnlPcHRpb25zLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgICAgICAuLi5hbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkTWV0YWRhdGEgPSBzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhICE9IG51bGwgPyBtZXJnZU9iamVjdHMoc3RhdGUubWVzc2FnZS5tZXRhZGF0YSwgbWV0YWRhdGEpIDogbWV0YWRhdGE7XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlTWV0YWRhdGFTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lcmdlZE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBtZXNzYWdlTWV0YWRhdGFTY2hlbWFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhID0gbWVyZ2VkTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwic3RyZWFtaW5nXCJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXSA9IHRleHRQYXJ0O1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2godGV4dFBhcnQpO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFBhcnQgPSBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBpZiAodGV4dFBhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgdGV4dC1kZWx0YSBmb3IgbWlzc2luZyB0ZXh0IHBhcnQgd2l0aCBJRCBcIiR7Y2h1bmsuaWR9XCIuIEVuc3VyZSBhIFwidGV4dC1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInRleHQtZGVsdGFcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnRleHQgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDogdGV4dFBhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIGlmICh0ZXh0UGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVJTWVzc2FnZVN0cmVhbUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJ0ZXh0LWVuZFwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgdGV4dC1lbmQgZm9yIG1pc3NpbmcgdGV4dCBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInRleHQtc3RhcnRcIiBjaHVuayBpcyBzZW50IGJlZm9yZSBhbnkgXCJ0ZXh0LWVuZFwiIGNodW5rcy5gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dFBhcnQuc3RhdGUgPSBcImRvbmVcIjtcbiAgICAgICAgICAgICAgdGV4dFBhcnQucHJvdmlkZXJNZXRhZGF0YSA9IChfYiA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYiA6IHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCByZWFzb25pbmdQYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcInN0cmVhbWluZ1wiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzW2NodW5rLmlkXSA9IHJlYXNvbmluZ1BhcnQ7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaChyZWFzb25pbmdQYXJ0KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgaWYgKHJlYXNvbmluZ1BhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBjaHVua0lkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCByZWFzb25pbmctZGVsdGEgZm9yIG1pc3NpbmcgcmVhc29uaW5nIHBhcnQgd2l0aCBJRCBcIiR7Y2h1bmsuaWR9XCIuIEVuc3VyZSBhIFwicmVhc29uaW5nLXN0YXJ0XCIgY2h1bmsgaXMgc2VudCBiZWZvcmUgYW55IFwicmVhc29uaW5nLWRlbHRhXCIgY2h1bmtzLmBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnRleHQgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YSA9IChfYyA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYyA6IHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1BhcnQgPSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInJlYXNvbmluZy1lbmRcIixcbiAgICAgICAgICAgICAgICAgIGNodW5rSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHJlYXNvbmluZy1lbmQgZm9yIG1pc3NpbmcgcmVhc29uaW5nIHBhcnQgd2l0aCBJRCBcIiR7Y2h1bmsuaWR9XCIuIEVuc3VyZSBhIFwicmVhc29uaW5nLXN0YXJ0XCIgY2h1bmsgaXMgc2VudCBiZWZvcmUgYW55IFwicmVhc29uaW5nLWVuZFwiIGNodW5rcy5gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9kID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9kIDogcmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHVybDogY2h1bmsudXJsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2UtdXJsXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS11cmxcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgdXJsOiBjaHVuay51cmwsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNvdXJjZS1kb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogY2h1bmsuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBjaHVuay5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBjaHVuay5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maWx0ZXIoaXNTdGF0aWNUb29sVUlQYXJ0KTtcbiAgICAgICAgICAgICAgc3RhdGUucGFydGlhbFRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogdG9vbEludm9jYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiBjaHVuay5keW5hbWljLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY2h1bmsuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFRvb2xDYWxsID0gc3RhdGUucGFydGlhbFRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVJTWVzc2FnZVN0cmVhbUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBjaHVua0lkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHRvb2wtaW5wdXQtZGVsdGEgZm9yIG1pc3NpbmcgdG9vbCBjYWxsIHdpdGggSUQgXCIke2NodW5rLnRvb2xDYWxsSWR9XCIuIEVuc3VyZSBhIFwidG9vbC1pbnB1dC1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInRvb2wtaW5wdXQtZGVsdGFcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnRpYWxUb29sQ2FsbC50ZXh0ICs9IGNodW5rLmlucHV0VGV4dERlbHRhO1xuICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXJ0aWFsQXJncyB9ID0gYXdhaXQgcGFyc2VQYXJ0aWFsSnNvbihcbiAgICAgICAgICAgICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAocGFydGlhbFRvb2xDYWxsLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0aWFsVG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1zdHJlYW1pbmdcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0aWFsQXJncyxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0aWFsVG9vbENhbGwudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnRpYWxUb29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnRpYWxBcmdzLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnRpYWxUb29sQ2FsbC50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGlmIChvblRvb2xDYWxsICYmICFjaHVuay5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25Ub29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICByYXdJbnB1dDogY2h1bmsuaW5wdXQsXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGNodW5rLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb24uc3RhdGUgPSBcImFwcHJvdmFsLXJlcXVlc3RlZFwiO1xuICAgICAgICAgICAgICB0b29sSW52b2NhdGlvbi5hcHByb3ZhbCA9IHsgaWQ6IGNodW5rLmFwcHJvdmFsSWQgfTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtZGVuaWVkXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb24uc3RhdGUgPSBcIm91dHB1dC1kZW5pZWRcIjtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uLnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sSW52b2NhdGlvbi50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogY2h1bmsub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IGNodW5rLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b29sSW52b2NhdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogZ2V0U3RhdGljVG9vbE5hbWUodG9vbEludm9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjaHVuay5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IGNodW5rLnByZWxpbWluYXJ5LFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2xJbnZvY2F0aW9uLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1vdXRwdXQtZXJyb3JcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IGdldFRvb2xJbnZvY2F0aW9uKGNodW5rLnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgICBpZiAodG9vbEludm9jYXRpb24udHlwZSA9PT0gXCJkeW5hbWljLXRvb2xcIikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUR5bmFtaWNUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xJbnZvY2F0aW9uLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbEludm9jYXRpb24uaW5wdXQsXG4gICAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGNodW5rLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogdG9vbEludm9jYXRpb24udGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFN0YXRpY1Rvb2xOYW1lKHRvb2xJbnZvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IHRvb2xJbnZvY2F0aW9uLnJhd0lucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2xJbnZvY2F0aW9uLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnQtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7IHR5cGU6IFwic3RlcC1zdGFydFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2gtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHRQYXJ0cyA9IHt9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0cyA9IHt9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UuaWQgPSBjaHVuay5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlTWVzc2FnZU1ldGFkYXRhKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlSWQgIT0gbnVsbCB8fCBjaHVuay5tZXNzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShjaHVuay5tZXNzYWdlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IobmV3IEVycm9yKGNodW5rLmVycm9yVGV4dCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgaWYgKGlzRGF0YVVJTWVzc2FnZUNodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGlmICgoZGF0YVBhcnRTY2hlbWFzID09IG51bGwgPyB2b2lkIDAgOiBkYXRhUGFydFNjaGVtYXNbY2h1bmsudHlwZV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmsuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBkYXRhUGFydFNjaGVtYXNbY2h1bmsudHlwZV1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUNodW5rLnRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgICAgb25EYXRhID09IG51bGwgPyB2b2lkIDAgOiBvbkRhdGEoZGF0YUNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1VJUGFydCA9IGRhdGFDaHVuay5pZCAhPSBudWxsID8gc3RhdGUubWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgICAgICAgICAgICAgICAgKGNodW5rQXJnKSA9PiBkYXRhQ2h1bmsudHlwZSA9PT0gY2h1bmtBcmcudHlwZSAmJiBkYXRhQ2h1bmsuaWQgPT09IGNodW5rQXJnLmlkXG4gICAgICAgICAgICAgICAgKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdVSVBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdVSVBhcnQuZGF0YSA9IGRhdGFDaHVuay5kYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goZGF0YUNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25EYXRhID09IG51bGwgPyB2b2lkIDAgOiBvbkRhdGEoZGF0YUNodW5rKTtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9oYW5kbGUtdWktbWVzc2FnZS1zdHJlYW0tZmluaXNoLnRzXG5mdW5jdGlvbiBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICBtZXNzYWdlSWQsXG4gIG9yaWdpbmFsTWVzc2FnZXMgPSBbXSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIHN0cmVhbVxufSkge1xuICBsZXQgbGFzdE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2VzID09IG51bGwgPyB2b2lkIDAgOiBvcmlnaW5hbE1lc3NhZ2VzW29yaWdpbmFsTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGlmICgobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgbGFzdE1lc3NhZ2UgPSB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XG4gIH1cbiAgbGV0IGlzQWJvcnRlZCA9IGZhbHNlO1xuICBjb25zdCBpZEluamVjdGVkU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICBjb25zdCBzdGFydENodW5rID0gY2h1bms7XG4gICAgICAgICAgaWYgKHN0YXJ0Q2h1bmsubWVzc2FnZUlkID09IG51bGwgJiYgbWVzc2FnZUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0Q2h1bmsubWVzc2FnZUlkID0gbWVzc2FnZUlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICAgICAgaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG4gIGlmIChvbkZpbmlzaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkSW5qZWN0ZWRTdHJlYW07XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gICAgbGFzdE1lc3NhZ2U6IGxhc3RNZXNzYWdlID8gc3RydWN0dXJlZENsb25lKGxhc3RNZXNzYWdlKSA6IHZvaWQgMCxcbiAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCAhPSBudWxsID8gbWVzc2FnZUlkIDogXCJcIlxuICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3RyZWFtXG4gIH0pO1xuICBjb25zdCBydW5VcGRhdGVNZXNzYWdlSm9iID0gYXN5bmMgKGpvYikgPT4ge1xuICAgIGF3YWl0IGpvYih7IHN0YXRlLCB3cml0ZTogKCkgPT4ge1xuICAgIH0gfSk7XG4gIH07XG4gIGxldCBmaW5pc2hDYWxsZWQgPSBmYWxzZTtcbiAgY29uc3QgY2FsbE9uRmluaXNoID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChmaW5pc2hDYWxsZWQgfHwgIW9uRmluaXNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbmlzaENhbGxlZCA9IHRydWU7XG4gICAgY29uc3QgaXNDb250aW51YXRpb24gPSBzdGF0ZS5tZXNzYWdlLmlkID09PSAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLmlkKTtcbiAgICBhd2FpdCBvbkZpbmlzaCh7XG4gICAgICBpc0Fib3J0ZWQsXG4gICAgICBpc0NvbnRpbnVhdGlvbixcbiAgICAgIHJlc3BvbnNlTWVzc2FnZTogc3RhdGUubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIC4uLmlzQ29udGludWF0aW9uID8gb3JpZ2luYWxNZXNzYWdlcy5zbGljZSgwLCAtMSkgOiBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBzdGF0ZS5tZXNzYWdlXG4gICAgICBdLFxuICAgICAgZmluaXNoUmVhc29uOiBzdGF0ZS5maW5pc2hSZWFzb25cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICAgIHN0cmVhbTogaWRJbmplY3RlZFN0cmVhbSxcbiAgICBydW5VcGRhdGVNZXNzYWdlSm9iLFxuICAgIG9uRXJyb3JcbiAgfSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH0sXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbmNlbCBpcyBzdGlsbCBuZXcgYW5kIG1pc3NpbmcgZnJvbSB0eXBlcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNmb3JtU3RyZWFtI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBhd2FpdCBjYWxsT25GaW5pc2goKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgYXdhaXQgY2FsbE9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL3BpcGUtdWktbWVzc2FnZS1zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgc3RyZWFtLFxuICBjb25zdW1lU3NlU3RyZWFtXG59KSB7XG4gIGxldCBzc2VTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSgpKTtcbiAgaWYgKGNvbnN1bWVTc2VTdHJlYW0pIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSBzc2VTdHJlYW0udGVlKCk7XG4gICAgc3NlU3RyZWFtID0gc3RyZWFtMTtcbiAgICBjb25zdW1lU3NlU3RyZWFtKHsgc3RyZWFtOiBzdHJlYW0yIH0pO1xuICB9XG4gIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgcmVzcG9uc2UsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgcHJlcGFyZUhlYWRlcnMoaGVhZGVycywgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUykuZW50cmllcygpXG4gICAgKSxcbiAgICBzdHJlYW06IHNzZVN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlsL2FzeW5jLWl0ZXJhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShzb3VyY2UpIHtcbiAgY29uc3Qgc3RyZWFtID0gc291cmNlLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oKSk7XG4gIHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLmdldFJlYWRlcigpO1xuICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNsZWFudXAoY2FuY2VsU3RyZWFtKSB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhbmNlbFN0cmVhbSkge1xuICAgICAgICAgIGF3YWl0ICgoX2ExNyA9IHJlYWRlci5jYW5jZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwocmVhZGVyKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBSZWFkcyB0aGUgbmV4dCBjaHVuayBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXh0IEl0ZXJhdG9yUmVzdWx0LlxuICAgICAgICovXG4gICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE1heSBiZSBjYWxsZWQgb24gZWFybHkgZXhpdCAoZS5nLiwgYnJlYWsgZnJvbSBmb3ItYXdhaXQpIG9yIGFmdGVyIGNvbXBsZXRpb24uXG4gICAgICAgKiBFbnN1cmVzIHRoZSBzdHJlYW0gaXMgY2FuY2VsbGVkIGFuZCByZXNvdXJjZXMgYXJlIHJlbGVhc2VkLlxuICAgICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGNvbXBsZXRlZCBJdGVyYXRvclJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgb24gZWFybHkgZXhpdCB3aXRoIGVycm9yLlxuICAgICAgICogRW5zdXJlcyB0aGUgc3RyZWFtIGlzIGNhbmNlbGxlZCBhbmQgcmVzb3VyY2VzIGFyZSByZWxlYXNlZCwgdGhlbiByZXRocm93cyB0aGUgZXJyb3IuXG4gICAgICAgKiBAcGFyYW0gZXJyIFRoZSBlcnJvciB0byB0aHJvdy5cbiAgICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCB0aGUgcHJvdmlkZWQgZXJyb3IuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jIHRocm93KGVycikge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gc3JjL3V0aWwvY29uc3VtZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uRXJyb3Jcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTM7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlMyA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZTMsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1zdGl0Y2hhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpIHtcbiAgbGV0IGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICBsZXQgY29udHJvbGxlciA9IG51bGw7XG4gIGxldCBpc0Nsb3NlZCA9IGZhbHNlO1xuICBsZXQgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gIGNvbnN0IHRlcm1pbmF0ZSA9ICgpID0+IHtcbiAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgaW5uZXJTdHJlYW1SZWFkZXJzLmZvckVhY2goKHJlYWRlcikgPT4gcmVhZGVyLmNhbmNlbCgpKTtcbiAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NQdWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGF3YWl0IHdhaXRGb3JOZXdTdHJlYW0ucHJvbWlzZTtcbiAgICAgIHJldHVybiBwcm9jZXNzUHVsbCgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaW5uZXJTdHJlYW1SZWFkZXJzWzBdLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCAmJiBpc0Nsb3NlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCBwcm9jZXNzUHVsbCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgdGVybWluYXRlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IHByb2Nlc3NQdWxsLFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBpbm5lclN0cmVhbVJlYWRlcnMpIHtcbiAgICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRTdHJlYW06IChpbm5lclN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaW5uZXIgc3RyZWFtOiBvdXRlciBzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgfVxuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnB1c2goaW5uZXJTdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHcmFjZWZ1bGx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBsZXQgdGhlIGlubmVyIHN0cmVhbXNcbiAgICAgKiBmaW5pc2ggcHJvY2Vzc2luZyBhbmQgdGhlbiBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBjYW5jZWwgYWxsIGlubmVyIHN0cmVhbXNcbiAgICAgKiBhbmQgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGVcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWwvbm93LnRzXG5mdW5jdGlvbiBub3coKSB7XG4gIHZhciBfYTE3LCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYTE3ID0gZ2xvYmFsVGhpcyA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubm93KCkpICE9IG51bGwgPyBfYiA6IERhdGUubm93KCk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuaW1wb3J0IHtcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgc3lzdGVtLFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbn0pIHtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbFJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0b29sSW5wdXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdG9vbENhbGxzQnlUb29sQ2FsbElkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGxldCBmaW5pc2hDaHVuayA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gYXR0ZW1wdENsb3NlKCkge1xuICAgIGlmIChjYW5DbG9zZSAmJiBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLnNpemUgPT09IDApIHtcbiAgICAgIGlmIChmaW5pc2hDaHVuayAhPSBudWxsKSB7XG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKGZpbmlzaENodW5rKTtcbiAgICAgIH1cbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmVhbS1zdGFydFwiOlxuICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOlxuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjpcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zdGFydFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctZW5kXCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVuZFwiOlxuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZmlsZTogbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlV2l0aFR5cGUoe1xuICAgICAgICAgICAgICBkYXRhOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IGNodW5rLm1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICBmaW5pc2hDaHVuayA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24ucmF3LFxuICAgICAgICAgICAgdXNhZ2U6IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzQnlUb29sQ2FsbElkLmdldChjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogY2h1bmsuYXBwcm92YWxJZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgICBhcHByb3ZhbElkOiBjaHVuay5hcHByb3ZhbElkLFxuICAgICAgICAgICAgdG9vbENhbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBhd2FpdCBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9vbENhbGxzQnlUb29sQ2FsbElkLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB0b29sQ2FsbCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmludmFsaWQpIHtcbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZ2V0RXJyb3JNZXNzYWdlNih0b29sQ2FsbC5lcnJvciksXG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogdG9vbENhbGwudGl0bGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbDIub25JbnB1dEF2YWlsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXRBdmFpbGFibGUoe1xuICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF3YWl0IGlzQXBwcm92YWxOZWVkZWQoe1xuICAgICAgICAgICAgICB0b29sOiB0b29sMixcbiAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sSW5wdXRzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB0b29sQ2FsbC5pbnB1dCk7XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsICYmIHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvbklkID0gZ2VuZXJhdGVJZDIoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5hZGQodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgICAgIG9uUHJlbGltaW5hcnlUb29sUmVzdWx0OiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgIGlmIChjaHVuay5pc0Vycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnB1dHMuZ2V0KGNodW5rLnRvb2xDYWxsSWQpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgICBlcnJvcjogY2h1bmsucmVzdWx0LFxuICAgICAgICAgICAgICBkeW5hbWljOiBjaHVuay5keW5hbWljXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnB1dHMuZ2V0KGNodW5rLnRvb2xDYWxsSWQpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IGNodW5rLnJlc3VsdCxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZHluYW1pYzogY2h1bmsuZHluYW1pY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goKSB7XG4gICAgICBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZW5lcmF0b3JTdHJlYW0ucGlwZVRocm91Z2goZm9yd2FyZFN0cmVhbSkucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMiA9IGNyZWF0ZUlkR2VuZXJhdG9yMih7XG4gIHByZWZpeDogXCJhaXR4dFwiLFxuICBzaXplOiAyNFxufSk7XG5mdW5jdGlvbiBzdHJlYW1UZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICB0aW1lb3V0LFxuICBoZWFkZXJzLFxuICBzdG9wV2hlbiA9IHN0ZXBDb3VudElzKDEpLFxuICBleHBlcmltZW50YWxfb3V0cHV0LFxuICBvdXRwdXQgPSBleHBlcmltZW50YWxfb3V0cHV0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIHByZXBhcmVTdGVwLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgYWN0aXZlVG9vbHMgPSBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gIGluY2x1ZGVSYXdDaHVua3MgPSBmYWxzZSxcbiAgb25DaHVuayxcbiAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfSxcbiAgb25GaW5pc2gsXG4gIG9uQWJvcnQsXG4gIG9uU3RlcEZpbmlzaCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIF9pbnRlcm5hbDogeyBub3c6IG5vdzIgPSBub3csIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyID0gb3JpZ2luYWxHZW5lcmF0ZUlkMiB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IHRvdGFsVGltZW91dE1zID0gZ2V0VG90YWxUaW1lb3V0TXModGltZW91dCk7XG4gIGNvbnN0IHN0ZXBUaW1lb3V0TXMgPSBnZXRTdGVwVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBjaHVua1RpbWVvdXRNcyA9IGdldENodW5rVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBzdGVwQWJvcnRDb250cm9sbGVyID0gc3RlcFRpbWVvdXRNcyAhPSBudWxsID8gbmV3IEFib3J0Q29udHJvbGxlcigpIDogdm9pZCAwO1xuICBjb25zdCBjaHVua0Fib3J0Q29udHJvbGxlciA9IGNodW5rVGltZW91dE1zICE9IG51bGwgPyBuZXcgQWJvcnRDb250cm9sbGVyKCkgOiB2b2lkIDA7XG4gIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQoe1xuICAgIG1vZGVsOiByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbCksXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbDogbWVyZ2VBYm9ydFNpZ25hbHMoXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIHRvdGFsVGltZW91dE1zICE9IG51bGwgPyBBYm9ydFNpZ25hbC50aW1lb3V0KHRvdGFsVGltZW91dE1zKSA6IHZvaWQgMCxcbiAgICAgIHN0ZXBBYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBBYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgY2h1bmtBYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNodW5rQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICksXG4gICAgc3RlcFRpbWVvdXRNcyxcbiAgICBzdGVwQWJvcnRDb250cm9sbGVyLFxuICAgIGNodW5rVGltZW91dE1zLFxuICAgIGNodW5rQWJvcnRDb250cm9sbGVyLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgdG9vbHMsXG4gICAgdG9vbENob2ljZSxcbiAgICB0cmFuc2Zvcm1zOiBhc0FycmF5KHRyYW5zZm9ybSksXG4gICAgYWN0aXZlVG9vbHMsXG4gICAgcmVwYWlyVG9vbENhbGwsXG4gICAgc3RvcENvbmRpdGlvbnM6IGFzQXJyYXkoc3RvcFdoZW4pLFxuICAgIG91dHB1dCxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcHJlcGFyZVN0ZXAsXG4gICAgaW5jbHVkZVJhd0NodW5rcyxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25BYm9ydCxcbiAgICBvblN0ZXBGaW5pc2gsXG4gICAgbm93OiBub3cyLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVPdXRwdXRUcmFuc2Zvcm1TdHJlYW0ob3V0cHV0KSB7XG4gIGxldCBmaXJzdFRleHRDaHVua0lkID0gdm9pZCAwO1xuICBsZXQgdGV4dDIgPSBcIlwiO1xuICBsZXQgdGV4dENodW5rID0gXCJcIjtcbiAgbGV0IHRleHRQcm92aWRlck1ldGFkYXRhID0gdm9pZCAwO1xuICBsZXQgbGFzdFB1Ymxpc2hlZEpzb24gPSBcIlwiO1xuICBmdW5jdGlvbiBwdWJsaXNoVGV4dENodW5rKHtcbiAgICBjb250cm9sbGVyLFxuICAgIHBhcnRpYWxPdXRwdXQgPSB2b2lkIDBcbiAgfSkge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICBwYXJ0OiB7XG4gICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICBpZDogZmlyc3RUZXh0Q2h1bmtJZCxcbiAgICAgICAgdGV4dDogdGV4dENodW5rLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiB0ZXh0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIHBhcnRpYWxPdXRwdXRcbiAgICB9KTtcbiAgICB0ZXh0Q2h1bmsgPSBcIlwiO1xuICB9XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiZmluaXNoLXN0ZXBcIiAmJiB0ZXh0Q2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIiAmJiBjaHVuay50eXBlICE9PSBcInRleHQtc3RhcnRcIiAmJiBjaHVuay50eXBlICE9PSBcInRleHQtZW5kXCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0VGV4dENodW5rSWQgPT0gbnVsbCkge1xuICAgICAgICBmaXJzdFRleHRDaHVua0lkID0gY2h1bmsuaWQ7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLmlkICE9PSBmaXJzdFRleHRDaHVua0lkKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtc3RhcnRcIikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgIGlmICh0ZXh0Q2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRleHQyICs9IGNodW5rLnRleHQ7XG4gICAgICB0ZXh0Q2h1bmsgKz0gY2h1bmsudGV4dDtcbiAgICAgIHRleHRQcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2ExNyA6IHRleHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3V0cHV0LnBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRKc29uID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnBhcnRpYWwpO1xuICAgICAgICBpZiAoY3VycmVudEpzb24gIT09IGxhc3RQdWJsaXNoZWRKc29uKSB7XG4gICAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIsIHBhcnRpYWxPdXRwdXQ6IHJlc3VsdC5wYXJ0aWFsIH0pO1xuICAgICAgICAgIGxhc3RQdWJsaXNoZWRKc29uID0gY3VycmVudEpzb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzdGVwVGltZW91dE1zLFxuICAgIHN0ZXBBYm9ydENvbnRyb2xsZXIsXG4gICAgY2h1bmtUaW1lb3V0TXMsXG4gICAgY2h1bmtBYm9ydENvbnRyb2xsZXIsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlLFxuICAgIHRyYW5zZm9ybXMsXG4gICAgYWN0aXZlVG9vbHMsXG4gICAgcmVwYWlyVG9vbENhbGwsXG4gICAgc3RvcENvbmRpdGlvbnMsXG4gICAgb3V0cHV0LFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBwcmVwYXJlU3RlcCxcbiAgICBpbmNsdWRlUmF3Q2h1bmtzLFxuICAgIG5vdzogbm93MixcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25BYm9ydCxcbiAgICBvblN0ZXBGaW5pc2gsXG4gICAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICB9KSB7XG4gICAgdGhpcy5fdG90YWxVc2FnZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX2ZpbmlzaFJlYXNvbiA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX3Jhd0ZpbmlzaFJlYXNvbiA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMuX3N0ZXBzID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uID0gb3V0cHV0O1xuICAgIHRoaXMuaW5jbHVkZVJhd0NodW5rcyA9IGluY2x1ZGVSYXdDaHVua3M7XG4gICAgdGhpcy50b29scyA9IHRvb2xzO1xuICAgIGxldCBzdGVwRmluaXNoO1xuICAgIGxldCByZWNvcmRlZENvbnRlbnQgPSBbXTtcbiAgICBjb25zdCByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICBsZXQgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkUmF3RmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFRvdGFsVXNhZ2UgPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkUmVxdWVzdCA9IHt9O1xuICAgIGxldCByZWNvcmRlZFdhcm5pbmdzID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRTdGVwcyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHJvb3RTcGFuO1xuICAgIGxldCBhY3RpdmVUZXh0Q29udGVudCA9IHt9O1xuICAgIGxldCBhY3RpdmVSZWFzb25pbmdDb250ZW50ID0ge307XG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgY29uc3QgeyBwYXJ0IH0gPSBjaHVuaztcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInJlYXNvbmluZy1kZWx0YVwiIHx8IHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtaW5wdXQtc3RhcnRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnB1dC1kZWx0YVwiIHx8IHBhcnQudHlwZSA9PT0gXCJyYXdcIikge1xuICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bms6IHBhcnQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIGF3YWl0IG9uRXJyb3IoeyBlcnJvcjogd3JhcEdhdGV3YXlFcnJvcihwYXJ0LmVycm9yKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtc3RhcnRcIikge1xuICAgICAgICAgIGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdID0ge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVUZXh0ID0gYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgcGFydDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogYHRleHQgcGFydCAke3BhcnQuaWR9IG5vdCBmb3VuZGBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFydGlhbE91dHB1dDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlVGV4dC50ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICBhY3RpdmVUZXh0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiBhY3RpdmVUZXh0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlVGV4dCA9IGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICAgIGlmIChhY3RpdmVUZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHBhcnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGB0ZXh0IHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YSA9IChfYiA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9iIDogYWN0aXZlVGV4dC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIGRlbGV0ZSBhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1zdGFydFwiKSB7XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1kZWx0YVwiKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlUmVhc29uaW5nID0gYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgICBpZiAoYWN0aXZlUmVhc29uaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHBhcnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGByZWFzb25pbmcgcGFydCAke3BhcnQuaWR9IG5vdCBmb3VuZGBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFydGlhbE91dHB1dDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nLnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZy5wcm92aWRlck1ldGFkYXRhID0gKF9jID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2MgOiBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1lbmRcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVJlYXNvbmluZyA9IGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVJlYXNvbmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgcmVhc29uaW5nIHBhcnQgJHtwYXJ0LmlkfSBub3QgZm91bmRgXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZy5wcm92aWRlck1ldGFkYXRhID0gKF9kID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2QgOiBhY3RpdmVSZWFzb25pbmcucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICBkZWxldGUgYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHsgdHlwZTogXCJmaWxlXCIsIGZpbGU6IHBhcnQuZmlsZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiAmJiAhcGFydC5wcmVsaW1pbmFyeSkge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtZXJyb3JcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RhcnQtc3RlcFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50ID0gW107XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nQ29udGVudCA9IHt9O1xuICAgICAgICAgIGFjdGl2ZVRleHRDb250ZW50ID0ge307XG4gICAgICAgICAgcmVjb3JkZWRSZXF1ZXN0ID0gcGFydC5yZXF1ZXN0O1xuICAgICAgICAgIHJlY29yZGVkV2FybmluZ3MgPSBwYXJ0Lndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoLXN0ZXBcIikge1xuICAgICAgICAgIGNvbnN0IHN0ZXBNZXNzYWdlcyA9IGF3YWl0IHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICBjb250ZW50OiByZWNvcmRlZENvbnRlbnQsXG4gICAgICAgICAgICB0b29sc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0gbmV3IERlZmF1bHRTdGVwUmVzdWx0KHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlY29yZGVkQ29udGVudCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcGFydC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICByYXdGaW5pc2hSZWFzb246IHBhcnQucmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHBhcnQudXNhZ2UsXG4gICAgICAgICAgICB3YXJuaW5nczogcmVjb3JkZWRXYXJuaW5ncyxcbiAgICAgICAgICAgIHJlcXVlc3Q6IHJlY29yZGVkUmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgIC4uLnBhcnQucmVzcG9uc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBbLi4ucmVjb3JkZWRSZXNwb25zZU1lc3NhZ2VzLCAuLi5zdGVwTWVzc2FnZXNdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgICAgbG9nV2FybmluZ3Moe1xuICAgICAgICAgICAgd2FybmluZ3M6IHJlY29yZGVkV2FybmluZ3MsXG4gICAgICAgICAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlY29yZGVkU3RlcHMucHVzaChjdXJyZW50U3RlcFJlc3VsdCk7XG4gICAgICAgICAgcmVjb3JkZWRSZXNwb25zZU1lc3NhZ2VzLnB1c2goLi4uc3RlcE1lc3NhZ2VzKTtcbiAgICAgICAgICBzdGVwRmluaXNoLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbmlzaFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRUb3RhbFVzYWdlID0gcGFydC50b3RhbFVzYWdlO1xuICAgICAgICAgIHJlY29yZGVkRmluaXNoUmVhc29uID0gcGFydC5maW5pc2hSZWFzb247XG4gICAgICAgICAgcmVjb3JkZWRSYXdGaW5pc2hSZWFzb24gPSBwYXJ0LnJhd0ZpbmlzaFJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocmVjb3JkZWRTdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gKGFib3J0U2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSA/IGFib3J0U2lnbmFsLnJlYXNvbiA6IG5ldyBOb091dHB1dEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvdXRwdXQgZ2VuZXJhdGVkLiBDaGVjayB0aGUgc3RyZWFtIGZvciBlcnJvcnMuXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5fZmluaXNoUmVhc29uLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICBzZWxmLl9yYXdGaW5pc2hSZWFzb24ucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHNlbGYuX3RvdGFsVXNhZ2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHNlbGYuX3N0ZXBzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbmlzaFJlYXNvbiA9IHJlY29yZGVkRmluaXNoUmVhc29uICE9IG51bGwgPyByZWNvcmRlZEZpbmlzaFJlYXNvbiA6IFwib3RoZXJcIjtcbiAgICAgICAgICBjb25zdCB0b3RhbFVzYWdlID0gcmVjb3JkZWRUb3RhbFVzYWdlICE9IG51bGwgPyByZWNvcmRlZFRvdGFsVXNhZ2UgOiBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKCk7XG4gICAgICAgICAgc2VsZi5fZmluaXNoUmVhc29uLnJlc29sdmUoZmluaXNoUmVhc29uKTtcbiAgICAgICAgICBzZWxmLl9yYXdGaW5pc2hSZWFzb24ucmVzb2x2ZShyZWNvcmRlZFJhd0ZpbmlzaFJlYXNvbik7XG4gICAgICAgICAgc2VsZi5fdG90YWxVc2FnZS5yZXNvbHZlKHRvdGFsVXNhZ2UpO1xuICAgICAgICAgIHNlbGYuX3N0ZXBzLnJlc29sdmUocmVjb3JkZWRTdGVwcyk7XG4gICAgICAgICAgY29uc3QgZmluYWxTdGVwID0gcmVjb3JkZWRTdGVwc1tyZWNvcmRlZFN0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBmaW5hbFN0ZXAuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBmaW5hbFN0ZXAucmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdG90YWxVc2FnZSxcbiAgICAgICAgICAgIHVzYWdlOiBmaW5hbFN0ZXAudXNhZ2UsXG4gICAgICAgICAgICBjb250ZW50OiBmaW5hbFN0ZXAuY29udGVudCxcbiAgICAgICAgICAgIHRleHQ6IGZpbmFsU3RlcC50ZXh0LFxuICAgICAgICAgICAgcmVhc29uaW5nVGV4dDogZmluYWxTdGVwLnJlYXNvbmluZ1RleHQsXG4gICAgICAgICAgICByZWFzb25pbmc6IGZpbmFsU3RlcC5yZWFzb25pbmcsXG4gICAgICAgICAgICBmaWxlczogZmluYWxTdGVwLmZpbGVzLFxuICAgICAgICAgICAgc291cmNlczogZmluYWxTdGVwLnNvdXJjZXMsXG4gICAgICAgICAgICB0b29sQ2FsbHM6IGZpbmFsU3RlcC50b29sQ2FsbHMsXG4gICAgICAgICAgICBzdGF0aWNUb29sQ2FsbHM6IGZpbmFsU3RlcC5zdGF0aWNUb29sQ2FsbHMsXG4gICAgICAgICAgICBkeW5hbWljVG9vbENhbGxzOiBmaW5hbFN0ZXAuZHluYW1pY1Rvb2xDYWxscyxcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBmaW5hbFN0ZXAudG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBzdGF0aWNUb29sUmVzdWx0czogZmluYWxTdGVwLnN0YXRpY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgICAgZHluYW1pY1Rvb2xSZXN1bHRzOiBmaW5hbFN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzLFxuICAgICAgICAgICAgcmVxdWVzdDogZmluYWxTdGVwLnJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZTogZmluYWxTdGVwLnJlc3BvbnNlLFxuICAgICAgICAgICAgd2FybmluZ3M6IGZpbmFsU3RlcC53YXJuaW5ncyxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGZpbmFsU3RlcC5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgc3RlcHM6IHJlY29yZGVkU3RlcHMsXG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IGZpbmFsU3RlcC50ZXh0IH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChfYTE3ID0gZmluYWxTdGVwLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KGZpbmFsU3RlcC50b29sQ2FsbHMpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgZmluYWxTdGVwLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogdG90YWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IHRvdGFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogdG90YWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0aXRjaGFibGVTdHJlYW0gPSBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgdGhpcy5hZGRTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbTtcbiAgICB0aGlzLmNsb3NlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5jbG9zZTtcbiAgICBjb25zdCByZWFkZXIgPSBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICBvbkFib3J0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFib3J0KHsgc3RlcHM6IHJlY29yZGVkU3RlcHMgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWJvcnRcIixcbiAgICAgICAgICAgIC8vIFRoZSBgcmVhc29uYCBpcyB1c3VhbGx5IG9mIHR5cGUgRE9NRXhjZXB0aW9uLCBidXQgaXQgY2FuIGFsc28gYmUgb2YgYW55IHR5cGUsXG4gICAgICAgICAgICAvLyBzbyB3ZSB1c2UgZ2V0RXJyb3JNZXNzYWdlIGZvciBzZXJpYWxpemF0aW9uIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBkZXNpZ25lZCB0byBhY2NlcHQgdmFsdWVzIG9mIHRoZSB1bmtub3duIHR5cGUuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydFNpZ25hbC9yZWFzb25cbiAgICAgICAgICAgIC4uLihhYm9ydFNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRTaWduYWwucmVhc29uKSAhPT0gdm9pZCAwID8geyByZWFzb246IGdldEVycm9yTWVzc2FnZTcoYWJvcnRTaWduYWwucmVhc29uKSB9IDoge31cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhYm9ydFNpZ25hbCA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoaXNBYm9ydEVycm9yMihlcnJvcikgJiYgKGFib3J0U2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSkge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0uY2FuY2VsKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm0gb2YgdHJhbnNmb3Jtcykge1xuICAgICAgc3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICB0cmFuc2Zvcm0oe1xuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIHN0b3BTdHJlYW0oKSB7XG4gICAgICAgICAgICBzdGl0Y2hhYmxlU3RyZWFtLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuYmFzZVN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVPdXRwdXRUcmFuc2Zvcm1TdHJlYW0ob3V0cHV0ICE9IG51bGwgPyBvdXRwdXQgOiB0ZXh0KCkpKS5waXBlVGhyb3VnaChldmVudFByb2Nlc3Nvcik7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICBtb2RlbCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICBmbjogYXN5bmMgKHJvb3RTcGFuQXJnKSA9PiB7XG4gICAgICAgIHJvb3RTcGFuID0gcm9vdFNwYW5Bcmc7XG4gICAgICAgIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5pdGlhbE1lc3NhZ2VzID0gaW5pdGlhbFByb21wdC5tZXNzYWdlcztcbiAgICAgICAgY29uc3QgaW5pdGlhbFJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBhcHByb3ZlZFRvb2xBcHByb3ZhbHMsIGRlbmllZFRvb2xBcHByb3ZhbHMgfSA9IGNvbGxlY3RUb29sQXBwcm92YWxzKHsgbWVzc2FnZXM6IGluaXRpYWxNZXNzYWdlcyB9KTtcbiAgICAgICAgaWYgKGRlbmllZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCB8fCBhcHByb3ZlZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzID0gW1xuICAgICAgICAgICAgLi4uYXBwcm92ZWRUb29sQXBwcm92YWxzLFxuICAgICAgICAgICAgLi4uZGVuaWVkVG9vbEFwcHJvdmFsc1xuICAgICAgICAgIF0uZmlsdGVyKCh0b29sQXBwcm92YWwpID0+IHRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkKTtcbiAgICAgICAgICBjb25zdCBsb2NhbEFwcHJvdmVkVG9vbEFwcHJvdmFscyA9IGFwcHJvdmVkVG9vbEFwcHJvdmFscy5maWx0ZXIoXG4gICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiAhdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGxvY2FsRGVuaWVkVG9vbEFwcHJvdmFscyA9IGRlbmllZFRvb2xBcHByb3ZhbHMuZmlsdGVyKFxuICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gIXRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBkZW5pZWRQcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscyA9IGRlbmllZFRvb2xBcHByb3ZhbHMuZmlsdGVyKFxuICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuYWRkU3RyZWFtKHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQXBwcm92YWwgb2YgW1xuICAgICAgICAgICAgICAuLi5sb2NhbERlbmllZFRvb2xBcHByb3ZhbHMsXG4gICAgICAgICAgICAgIC4uLmRlbmllZFByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzXG4gICAgICAgICAgICBdKSB7XG4gICAgICAgICAgICAgIHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1vdXRwdXQtZGVuaWVkXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xBcHByb3ZhbC50b29sQ2FsbC50b29sTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvb2xPdXRwdXRzID0gW107XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMubWFwKGFzeW5jICh0b29sQXBwcm92YWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGw6IHRvb2xBcHByb3ZhbC50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IGluaXRpYWxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgICBvblByZWxpbWluYXJ5VG9vbFJlc3VsdDogKHJlc3VsdDIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyLmVucXVldWUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIHRvb2xPdXRwdXRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaW5pdGlhbFJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogcHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMubWFwKFxuICAgICAgICAgICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWQsXG4gICAgICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5hcHByb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sT3V0cHV0cy5sZW5ndGggPiAwIHx8IGxvY2FsRGVuaWVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsVG9vbENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBvdXRwdXQyIG9mIHRvb2xPdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxUb29sQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG91dHB1dDIudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBvdXRwdXQyLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvdXRwdXQyLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBvdXRwdXQyLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbb3V0cHV0Mi50b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0Mi50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgPyBvdXRwdXQyLm91dHB1dCA6IG91dHB1dDIuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTW9kZTogb3V0cHV0Mi50eXBlID09PSBcInRvb2wtZXJyb3JcIiA/IFwianNvblwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQXBwcm92YWwgb2YgbG9jYWxEZW5pZWRUb29sQXBwcm92YWxzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxUb29sQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xBcHByb3ZhbC50b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xBcHByb3ZhbC50b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImV4ZWN1dGlvbi1kZW5pZWRcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiB0b29sQXBwcm92YWwuYXBwcm92YWxSZXNwb25zZS5yZWFzb25cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbml0aWFsUmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBsb2NhbFRvb2xDb250ZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMucHVzaCguLi5pbml0aWFsUmVzcG9uc2VNZXNzYWdlcyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgdXNhZ2VcbiAgICAgICAgfSkge1xuICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgY29uc3QgaW5jbHVkZVJhd0NodW5rczIgPSBzZWxmLmluY2x1ZGVSYXdDaHVua3M7XG4gICAgICAgICAgY29uc3Qgc3RlcFRpbWVvdXRJZCA9IHN0ZXBUaW1lb3V0TXMgIT0gbnVsbCA/IHNldFRpbWVvdXQoKCkgPT4gc3RlcEFib3J0Q29udHJvbGxlci5hYm9ydCgpLCBzdGVwVGltZW91dE1zKSA6IHZvaWQgMDtcbiAgICAgICAgICBsZXQgY2h1bmtUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgICAgICAgZnVuY3Rpb24gcmVzZXRDaHVua1RpbWVvdXQoKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtUaW1lb3V0TXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoY2h1bmtUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjaHVua1RpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2h1bmtUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICgpID0+IGNodW5rQWJvcnRDb250cm9sbGVyLmFib3J0KCksXG4gICAgICAgICAgICAgICAgY2h1bmtUaW1lb3V0TXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2xlYXJDaHVua1RpbWVvdXQoKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmtUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICBjaHVua1RpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2xlYXJTdGVwVGltZW91dCgpIHtcbiAgICAgICAgICAgIGlmIChzdGVwVGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0ZXBUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGVwRmluaXNoID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbLi4uaW5pdGlhbE1lc3NhZ2VzLCAuLi5yZXNwb25zZU1lc3NhZ2VzXTtcbiAgICAgICAgICBjb25zdCBwcmVwYXJlU3RlcFJlc3VsdCA9IGF3YWl0IChwcmVwYXJlU3RlcCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXAoe1xuICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwcyxcbiAgICAgICAgICAgIHN0ZXBOdW1iZXI6IHJlY29yZGVkU3RlcHMubGVuZ3RoLFxuICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgY29uc3Qgc3RlcE1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwoXG4gICAgICAgICAgICAoX2ExNyA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tb2RlbCkgIT0gbnVsbCA/IF9hMTcgOiBtb2RlbFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICBzeXN0ZW06IChfYiA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5zeXN0ZW0pICE9IG51bGwgPyBfYiA6IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlczogKF9jID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1lc3NhZ2VzKSAhPSBudWxsID8gX2MgOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IHN0ZXBNb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHsgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsIHRvb2xzOiBzdGVwVG9vbHMgfSA9IGF3YWl0IHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICB0b29sQ2hvaWNlOiAoX2QgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQudG9vbENob2ljZSkgIT0gbnVsbCA/IF9kIDogdG9vbENob2ljZSxcbiAgICAgICAgICAgIGFjdGl2ZVRvb2xzOiAoX2UgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuYWN0aXZlVG9vbHMpICE9IG51bGwgPyBfZSA6IGFjdGl2ZVRvb2xzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHQgPSAoX2YgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuZXhwZXJpbWVudGFsX2NvbnRleHQpICE9IG51bGwgPyBfZiA6IGV4cGVyaW1lbnRhbF9jb250ZXh0O1xuICAgICAgICAgIGNvbnN0IHN0ZXBQcm92aWRlck9wdGlvbnMgPSBtZXJnZU9iamVjdHMoXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQucHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICByZXN1bHQ6IHsgc3RyZWFtOiBzdHJlYW0yLCByZXNwb25zZSwgcmVxdWVzdCB9LFxuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gbW9kZWw6XG4gICAgICAgICAgICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwuaWRcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAvLyBwcm9tcHQ6XG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdHJpbmdpZnlGb3JUZWxlbWV0cnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29scyA9PSBudWxsID8gdm9pZCAwIDogc3RlcFRvb2xzLm1hcCgodG9vbDIpID0+IEpTT04uc3RyaW5naWZ5KHRvb2wyKSlcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sQ2hvaWNlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogY2FsbFNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBjYWxsU2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogY2FsbFNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogY2FsbFNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgICAvLyBnZXQgYmVmb3JlIHRoZSBjYWxsXG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgc3RlcE1vZGVsLmRvU3RyZWFtKHtcbiAgICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdGVwVG9vbHMsXG4gICAgICAgICAgICAgICAgICB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiBhd2FpdCAob3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQpLFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogc3RlcFByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIGluY2x1ZGVSYXdDaHVua3M6IGluY2x1ZGVSYXdDaHVua3MyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBzdHJlYW1XaXRoVG9vbFJlc3VsdHMgPSBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW0yLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBzdGVwUmVxdWVzdCA9IHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fTtcbiAgICAgICAgICBjb25zdCBzdGVwVG9vbENhbGxzID0gW107XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xPdXRwdXRzID0gW107XG4gICAgICAgICAgbGV0IHdhcm5pbmdzO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzID0ge307XG4gICAgICAgICAgbGV0IHN0ZXBGaW5pc2hSZWFzb24gPSBcIm90aGVyXCI7XG4gICAgICAgICAgbGV0IHN0ZXBSYXdGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgICAgICAgbGV0IHN0ZXBVc2FnZSA9IGNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UoKTtcbiAgICAgICAgICBsZXQgc3RlcFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgbGV0IHN0ZXBGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBsZXQgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgIH07XG4gICAgICAgICAgbGV0IGFjdGl2ZVRleHQgPSBcIlwiO1xuICAgICAgICAgIHNlbGYuYWRkU3RyZWFtKFxuICAgICAgICAgICAgc3RyZWFtV2l0aFRvb2xSZXN1bHRzLnBpcGVUaHJvdWdoKFxuICAgICAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTE4LCBfYjIsIF9jMiwgX2QyLCBfZTI7XG4gICAgICAgICAgICAgICAgICByZXNldENodW5rVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwic3RyZWFtLXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MgPSBjaHVuay53YXJuaW5ncztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHN0ZXBGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaXJzdENodW5rID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXBNcztcbiAgICAgICAgICAgICAgICAgICAgc3RlcEZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhcnQtc3RlcFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWVuZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmRlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLmRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRleHQgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghY2h1bmsucHJlbGltaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sT3V0cHV0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xPdXRwdXRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IChfYTE4ID0gY2h1bmsuaWQpICE9IG51bGwgPyBfYTE4IDogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IyID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IyIDogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYzIgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MyIDogc3RlcFJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBVc2FnZSA9IGNodW5rLnVzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFJhd0ZpbmlzaFJlYXNvbiA9IGNodW5rLnJhd0ZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpbmlzaCA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpbmlzaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaW5pc2hcIjogbXNUb0ZpbmlzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuYXZnT3V0cHV0VG9rZW5zUGVyU2Vjb25kXCI6IDFlMyAqICgoX2QyID0gc3RlcFVzYWdlLm91dHB1dFRva2VucykgIT0gbnVsbCA/IF9kMiA6IDApIC8gbXNUb0ZpbmlzaFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzW2NodW5rLmlkXSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW2NodW5rLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5vbklucHV0U3RhcnQpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXRTdGFydCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWM6IChfZTIgPSBjaHVuay5keW5hbWljKSAhPSBudWxsID8gX2UyIDogKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJkeW5hbWljXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLnRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5vbklucHV0RGVsdGEpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXREZWx0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VGV4dERlbHRhOiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVJhd0NodW5rczIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxsc0pzb24gPSBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gYWN0aXZlVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoc3RlcFByb3ZpZGVyTWV0YWRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogc3RlcFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBzdGVwVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IHN0ZXBVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogc3RlcFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtzdGVwRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaC1zdGVwXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBzdGVwUmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogc3RlcFVzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjb21iaW5lZFVzYWdlID0gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlLCBzdGVwVXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgYXdhaXQgc3RlcEZpbmlzaC5wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50VG9vbENhbGxzID0gc3RlcFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAhPT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFRvb2xPdXRwdXRzID0gc3RlcFRvb2xPdXRwdXRzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKHRvb2xPdXRwdXQpID0+IHRvb2xPdXRwdXQucHJvdmlkZXJFeGVjdXRlZCAhPT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2Ygc3RlcFRvb2xDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJwcm92aWRlclwiICYmIHRvb2wyLnN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzUmVzdWx0SW5TdGVwID0gc3RlcFRvb2xPdXRwdXRzLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAob3V0cHV0MikgPT4gb3V0cHV0Mi50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgJiYgb3V0cHV0Mi50b29sQ2FsbElkID09PSB0b29sQ2FsbC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Jlc3VsdEluU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dDIgb2Ygc3RlcFRvb2xPdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5kZWxldGUob3V0cHV0Mi50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2xlYXJTdGVwVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgY2xlYXJDaHVua1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgaWY6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIFRoZXJlIGFyZSBjbGllbnQgdG9vbCBjYWxscyB0aGF0IGhhdmUgYWxsIGJlZW4gZXhlY3V0ZWQsIE9SXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIFRoZXJlIGFyZSBwZW5kaW5nIGRlZmVycmVkIHJlc3VsdHMgZnJvbSBwcm92aWRlci1leGVjdXRlZCB0b29sc1xuICAgICAgICAgICAgICAgICAgICAoY2xpZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoIHx8IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5zaXplID4gMCkgJiYgLy8gY29udGludWUgdW50aWwgYSBzdG9wIGNvbmRpdGlvbiBpcyBtZXQ6XG4gICAgICAgICAgICAgICAgICAgICFhd2FpdCBpc1N0b3BDb25kaXRpb25NZXQoe1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3BDb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiByZWNvcmRlZFN0ZXBzXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmF3YWl0IHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0cmFuc2Zvcm1lZCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgbWVzc2FnZXMgZm9yIHRoZSBuZXh0IHN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZGVkU3RlcHNbcmVjb3JkZWRTdGVwcy5sZW5ndGggLSAxXS5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGN1cnJlbnRTdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICByYXdGaW5pc2hSZWFzb246IHN0ZXBSYXdGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxVc2FnZTogY29tYmluZWRVc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXM6IGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgIHVzYWdlOiBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHN0ZXBzKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9zdGVwcy5wcm9taXNlO1xuICB9XG4gIGdldCBmaW5hbFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMudGhlbigoc3RlcHMpID0+IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5jb250ZW50KTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAud2FybmluZ3MpO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnByb3ZpZGVyTWV0YWRhdGEpO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRleHQpO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlYXNvbmluZ1RleHQpO1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAucmVhc29uaW5nKTtcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5zb3VyY2VzKTtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZmlsZXMpO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAudG9vbENhbGxzKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnN0YXRpY1Rvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZHluYW1pY1Rvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuc3RhdGljVG9vbFJlc3VsdHMpO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAudXNhZ2UpO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlcXVlc3QpO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZXNwb25zZSk7XG4gIH1cbiAgZ2V0IHRvdGFsVXNhZ2UoKSB7XG4gICAgdGhpcy5jb25zdW1lU3RyZWFtKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsVXNhZ2UucHJvbWlzZTtcbiAgfVxuICBnZXQgZmluaXNoUmVhc29uKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hSZWFzb24ucHJvbWlzZTtcbiAgfVxuICBnZXQgcmF3RmluaXNoUmVhc29uKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9yYXdGaW5pc2hSZWFzb24ucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgU3BsaXQgb3V0IGEgbmV3IHN0cmVhbSBmcm9tIHRoZSBvcmlnaW5hbCBzdHJlYW0uXG4gIFRoZSBvcmlnaW5hbCBzdHJlYW0gaXMgcmVwbGFjZWQgdG8gYWxsb3cgZm9yIGZ1cnRoZXIgc3BsaXR0aW5nLFxuICBzaW5jZSB3ZSBkbyBub3Qga25vdyBob3cgbWFueSB0aW1lcyB0aGUgc3RyZWFtIHdpbGwgYmUgc3BsaXQuXG4gIFxuICBOb3RlOiB0aGlzIGxlYWRzIHRvIGJ1ZmZlcmluZyB0aGUgc3RyZWFtIGNvbnRlbnQgb24gdGhlIHNlcnZlci5cbiAgSG93ZXZlciwgdGhlIExMTSByZXN1bHRzIGFyZSBleHBlY3RlZCB0byBiZSBzbWFsbCBlbm91Z2ggdG8gbm90IGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgdGVlU3RyZWFtKCkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHRoaXMuYmFzZVN0cmVhbS50ZWUoKTtcbiAgICB0aGlzLmJhc2VTdHJlYW0gPSBzdHJlYW0yO1xuICAgIHJldHVybiBzdHJlYW0xO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKHsgcGFydCB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGFzeW5jIGNvbnN1bWVTdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTE3O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiB0aGlzLmZ1bGxTdHJlYW0sXG4gICAgICAgIG9uRXJyb3I6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIChfYTE3ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKG9wdGlvbnMsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9wYXJ0aWFsT3V0cHV0U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRpYWxPdXRwdXRTdHJlYW07XG4gIH1cbiAgZ2V0IHBhcnRpYWxPdXRwdXRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnRpYWxPdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gKF9hMTcgPSB0aGlzLm91dHB1dFNwZWNpZmljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKTtcbiAgICBpZiAodHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIoe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBgZWxlbWVudCBzdHJlYW1zIGluICR7KF9jID0gKF9iID0gdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgIT0gbnVsbCA/IF9jIDogXCJ0ZXh0XCJ9IG1vZGVgXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaCh0cmFuc2Zvcm0pKTtcbiAgfVxuICBnZXQgb3V0cHV0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGNvbnN0IG91dHB1dCA9IChfYTE3ID0gdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uKSAhPSBudWxsID8gX2ExNyA6IHRleHQoKTtcbiAgICAgIHJldHVybiBvdXRwdXQucGFyc2VDb21wbGV0ZU91dHB1dChcbiAgICAgICAgeyB0ZXh0OiBzdGVwLnRleHQgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJlc3BvbnNlOiBzdGVwLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBzdGVwLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcC5maW5pc2hSZWFzb25cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICB0b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyA9IHRydWUsXG4gICAgc2VuZFNvdXJjZXMgPSBmYWxzZSxcbiAgICBzZW5kU3RhcnQgPSB0cnVlLFxuICAgIHNlbmRGaW5pc2ggPSB0cnVlLFxuICAgIG9uRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2U3XG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZUlkID0gZ2VuZXJhdGVNZXNzYWdlSWQgIT0gbnVsbCA/IGdldFJlc3BvbnNlVUlNZXNzYWdlSWQoe1xuICAgICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgIHJlc3BvbnNlTWVzc2FnZUlkOiBnZW5lcmF0ZU1lc3NhZ2VJZFxuICAgIH0pIDogdm9pZCAwO1xuICAgIGNvbnN0IGlzRHluYW1pYyA9IChwYXJ0KSA9PiB7XG4gICAgICB2YXIgX2ExNztcbiAgICAgIGNvbnN0IHRvb2wyID0gKF9hMTcgPSB0aGlzLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExN1twYXJ0LnRvb2xOYW1lXTtcbiAgICAgIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LmR5bmFtaWM7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJkeW5hbWljXCIgPyB0cnVlIDogdm9pZCAwO1xuICAgIH07XG4gICAgY29uc3QgYmFzZVN0cmVhbSA9IHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm06IGFzeW5jIChwYXJ0LCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZU1ldGFkYXRhVmFsdWUgPSBtZXNzYWdlTWV0YWRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VNZXRhZGF0YSh7IHBhcnQgfSk7XG4gICAgICAgICAgY29uc3QgcGFydFR5cGUgPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWVuZFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWVuZFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke3BhcnQuZmlsZS5tZWRpYVR5cGV9O2Jhc2U2NCwke3BhcnQuZmlsZS5iYXNlNjR9YFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRTb3VyY2VzICYmIHBhcnQuc291cmNlVHlwZSA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS11cmxcIixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgdXJsOiBwYXJ0LnVybCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2VuZFNvdXJjZXMgJiYgcGFydC5zb3VyY2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlckV4ZWN1dGVkICE9IG51bGwgPyB7IHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCB9IDoge30sXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnRpdGxlICE9IG51bGwgPyB7IHRpdGxlOiBwYXJ0LnRpdGxlIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICBpbnB1dFRleHREZWx0YTogcGFydC5kZWx0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgaWYgKHBhcnQuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihwYXJ0LmVycm9yKSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQudGl0bGUgIT0gbnVsbCA/IHsgdGl0bGU6IHBhcnQudGl0bGUgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQudGl0bGUgIT0gbnVsbCA/IHsgdGl0bGU6IHBhcnQudGl0bGUgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHBhcnQuYXBwcm92YWxJZCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtb3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJlbGltaW5hcnkgIT0gbnVsbCA/IHsgcHJlbGltaW5hcnk6IHBhcnQucHJlbGltaW5hcnkgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtZXJyb3JcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1vdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWRlbmllZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLW91dHB1dC1kZW5pZWRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydC1zdGVwXCIgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2gtc3RlcFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VJZCAhPSBudWxsID8geyBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHBhcnQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhYm9ydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lbmRcIjoge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gcGFydFR5cGU7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2VNZXRhZGF0YVZhbHVlICE9IG51bGwgJiYgcGFydFR5cGUgIT09IFwic3RhcnRcIiAmJiBwYXJ0VHlwZSAhPT0gXCJmaW5pc2hcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlLW1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2VNZXRhZGF0YTogbWVzc2FnZU1ldGFkYXRhVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgaGFuZGxlVUlNZXNzYWdlU3RyZWFtRmluaXNoKHtcbiAgICAgICAgc3RyZWFtOiBiYXNlU3RyZWFtLFxuICAgICAgICBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkICE9IG51bGwgPyByZXNwb25zZU1lc3NhZ2VJZCA6IGdlbmVyYXRlTWVzc2FnZUlkID09IG51bGwgPyB2b2lkIDAgOiBnZW5lcmF0ZU1lc3NhZ2VJZCgpLFxuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyxcbiAgICBzZW5kU291cmNlcyxcbiAgICBzZW5kRmluaXNoLFxuICAgIHNlbmRTdGFydCxcbiAgICBvbkVycm9yLFxuICAgIC4uLmluaXRcbiAgfSA9IHt9KSB7XG4gICAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIHNlbmRGaW5pc2gsXG4gICAgICAgIHNlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG4gIHRvVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgZ2VuZXJhdGVNZXNzYWdlSWQsXG4gICAgb25GaW5pc2gsXG4gICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgIHNlbmRSZWFzb25pbmcsXG4gICAgc2VuZFNvdXJjZXMsXG4gICAgc2VuZEZpbmlzaCxcbiAgICBzZW5kU3RhcnQsXG4gICAgb25FcnJvcixcbiAgICAuLi5pbml0XG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIHNlbmRGaW5pc2gsXG4gICAgICAgIHNlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvYWdlbnQvdG9vbC1sb29wLWFnZW50LnRzXG52YXIgVG9vbExvb3BBZ2VudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBcImFnZW50LXYxXCI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGFnZW50LlxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdG9vbHMgdGhhdCB0aGUgYWdlbnQgY2FuIHVzZS5cbiAgICovXG4gIGdldCB0b29scygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50b29scztcbiAgfVxuICBhc3luYyBwcmVwYXJlQ2FsbChvcHRpb25zKSB7XG4gICAgdmFyIF9hMTcsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgYmFzZUNhbGxBcmdzID0ge1xuICAgICAgLi4udGhpcy5zZXR0aW5ncyxcbiAgICAgIHN0b3BXaGVuOiAoX2ExNyA9IHRoaXMuc2V0dGluZ3Muc3RvcFdoZW4pICE9IG51bGwgPyBfYTE3IDogc3RlcENvdW50SXMoMjApLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRDYWxsQXJncyA9IChfZCA9IGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnNldHRpbmdzKS5wcmVwYXJlQ2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGJhc2VDYWxsQXJncykpKSAhPSBudWxsID8gX2QgOiBiYXNlQ2FsbEFyZ3M7XG4gICAgY29uc3QgeyBpbnN0cnVjdGlvbnMsIG1lc3NhZ2VzLCBwcm9tcHQsIC4uLmNhbGxBcmdzIH0gPSBwcmVwYXJlZENhbGxBcmdzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jYWxsQXJncyxcbiAgICAgIC8vIHJlc3RvcmUgcHJvbXB0IHR5cGVzXG4gICAgICAuLi57IHN5c3RlbTogaW5zdHJ1Y3Rpb25zLCBtZXNzYWdlcywgcHJvbXB0IH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gb3V0cHV0IGZyb20gdGhlIGFnZW50IChub24tc3RyZWFtaW5nKS5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlKHtcbiAgICBhYm9ydFNpZ25hbCxcbiAgICB0aW1lb3V0LFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHJldHVybiBnZW5lcmF0ZVRleHQoe1xuICAgICAgLi4uYXdhaXQgdGhpcy5wcmVwYXJlQ2FsbChvcHRpb25zKSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgdGltZW91dFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdHJlYW1zIGFuIG91dHB1dCBmcm9tIHRoZSBhZ2VudCAoc3RyZWFtaW5nKS5cbiAgICovXG4gIGFzeW5jIHN0cmVhbSh7XG4gICAgYWJvcnRTaWduYWwsXG4gICAgdGltZW91dCxcbiAgICBleHBlcmltZW50YWxfdHJhbnNmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHJldHVybiBzdHJlYW1UZXh0KHtcbiAgICAgIC4uLmF3YWl0IHRoaXMucHJlcGFyZUNhbGwob3B0aW9ucyksXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBleHBlcmltZW50YWxfdHJhbnNmb3JtXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9jcmVhdGUtdWktbWVzc2FnZS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEZ1bmMsXG4gIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U4XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW0oe1xuICBleGVjdXRlLFxuICBvbkVycm9yID0gZ2V0RXJyb3JNZXNzYWdlOCxcbiAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyID0gZ2VuZXJhdGVJZEZ1bmNcbn0pIHtcbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGNvbnN0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcyA9IFtdO1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXJBcmcpIHtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyQXJnO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIHNhZmVFbnF1ZXVlKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXhlY3V0ZSh7XG4gICAgICB3cml0ZXI6IHtcbiAgICAgICAgd3JpdGUocGFydCkge1xuICAgICAgICAgIHNhZmVFbnF1ZXVlKHBhcnQpO1xuICAgICAgICB9LFxuICAgICAgICBtZXJnZShzdHJlYW1BcmcpIHtcbiAgICAgICAgICBvbmdvaW5nU3RyZWFtUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbUFyZy5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgc2FmZUVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBzYWZlRW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihlcnJvcilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3JcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBvbmdvaW5nU3RyZWFtUHJvbWlzZXMucHVzaChcbiAgICAgICAgcmVzdWx0LmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIHNhZmVFbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihlcnJvcilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHNhZmVFbnF1ZXVlKHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIGVycm9yVGV4dDogb25FcnJvcihlcnJvcilcbiAgICB9KTtcbiAgfVxuICBjb25zdCB3YWl0Rm9yU3RyZWFtcyA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlMykgPT4ge1xuICAgIHdoaWxlIChvbmdvaW5nU3RyZWFtUHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgb25nb2luZ1N0cmVhbVByb21pc2VzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJlc29sdmUzKCk7XG4gIH0pO1xuICB3YWl0Rm9yU3RyZWFtcy5maW5hbGx5KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhhbmRsZVVJTWVzc2FnZVN0cmVhbUZpbmlzaCh7XG4gICAgc3RyZWFtLFxuICAgIG1lc3NhZ2VJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgIG9uRmluaXNoLFxuICAgIG9uRXJyb3JcbiAgfSk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9yZWFkLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiByZWFkVUlNZXNzYWdlU3RyZWFtKHtcbiAgbWVzc2FnZSxcbiAgc3RyZWFtLFxuICBvbkVycm9yLFxuICB0ZXJtaW5hdGVPbkVycm9yID0gZmFsc2Vcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGxldCBjb250cm9sbGVyO1xuICBsZXQgaGFzRXJyb3JlZCA9IGZhbHNlO1xuICBjb25zdCBvdXRwdXRTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJQYXJhbTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVN0cmVhbWluZ1VJTWVzc2FnZVN0YXRlKHtcbiAgICBtZXNzYWdlSWQ6IChfYTE3ID0gbWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZS5pZCkgIT0gbnVsbCA/IF9hMTcgOiBcIlwiLFxuICAgIGxhc3RNZXNzYWdlOiBtZXNzYWdlXG4gIH0pO1xuICBjb25zdCBoYW5kbGVFcnJvciA9IChlcnJvcikgPT4ge1xuICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoZXJyb3IpO1xuICAgIGlmICghaGFzRXJyb3JlZCAmJiB0ZXJtaW5hdGVPbkVycm9yKSB7XG4gICAgICBoYXNFcnJvcmVkID0gdHJ1ZTtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3VtZVN0cmVhbSh7XG4gICAgc3RyZWFtOiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgIHN0cmVhbSxcbiAgICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2Ioam9iKSB7XG4gICAgICAgIHJldHVybiBqb2Ioe1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHdyaXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVucXVldWUoc3RydWN0dXJlZENsb25lKHN0YXRlLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IGhhbmRsZUVycm9yXG4gICAgfSksXG4gICAgb25FcnJvcjogaGFuZGxlRXJyb3JcbiAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgaWYgKCFoYXNFcnJvcmVkKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0ob3V0cHV0U3RyZWFtKTtcbn1cblxuLy8gc3JjL3VpL2NvbnZlcnQtdG8tbW9kZWwtbWVzc2FnZXMudHNcbmltcG9ydCB7XG4gIGlzTm9uTnVsbGFibGVcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb01vZGVsTWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgbW9kZWxNZXNzYWdlcyA9IFtdO1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVJbmNvbXBsZXRlVG9vbENhbGxzKSB7XG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAuLi5tZXNzYWdlLFxuICAgICAgcGFydHM6IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAocGFydCkgPT4gIWlzVG9vbFVJUGFydChwYXJ0KSB8fCBwYXJ0LnN0YXRlICE9PSBcImlucHV0LXN0cmVhbWluZ1wiICYmIHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtYXZhaWxhYmxlXCJcbiAgICAgIClcbiAgICB9KSk7XG4gIH1cbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgc3dpdGNoIChtZXNzYWdlLnJvbGUpIHtcbiAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICBjb25zdCB0ZXh0UGFydHMgPSBtZXNzYWdlLnBhcnRzLmZpbHRlcihcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRleHRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwcm92aWRlck1ldGFkYXRhID0gdGV4dFBhcnRzLnJlZHVjZSgoYWNjLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgaWYgKHBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hY2MsIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiB0ZXh0UGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LnRleHQpLmpvaW4oXCJcIiksXG4gICAgICAgICAgLi4uT2JqZWN0LmtleXMocHJvdmlkZXJNZXRhZGF0YSkubGVuZ3RoID4gMCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogbWVzc2FnZS5wYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgICAgaWYgKGlzVGV4dFVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaWxlVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJ0LnVybCxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEYXRhVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoX2ExNyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udmVydERhdGFQYXJ0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcGFydFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmZpbHRlcihpc05vbk51bGxhYmxlKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydHMgIT0gbnVsbCkge1xuICAgICAgICAgIGxldCBibG9jayA9IFtdO1xuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NCbG9jaygpIHtcbiAgICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBpZiAoYmxvY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBibG9jaykge1xuICAgICAgICAgICAgICBpZiAoaXNUZXh0VUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlsZVVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWFzb25pbmdVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNUb29sVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBnZXRUb29sTmFtZShwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1zdHJlYW1pbmdcIikge1xuICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyAoX2ExNyA9IHBhcnQuaW5wdXQpICE9IG51bGwgPyBfYTE3IDogXCJyYXdJbnB1dFwiIGluIHBhcnQgPyBwYXJ0LnJhd0lucHV0IDogdm9pZCAwIDogcGFydC5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogcGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuYXBwcm92YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFydC5wcm92aWRlckV4ZWN1dGVkID09PSB0cnVlICYmIHBhcnQuc3RhdGUgIT09IFwiYXBwcm92YWwtcmVzcG9uZGVkXCIgJiYgKHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiIHx8IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IHBhcnQuZXJyb3JUZXh0IDogcGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sOiAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2JbdG9vbE5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNb2RlOiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gXCJqc29uXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEYXRhVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVBhcnQgPSAoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnZlcnREYXRhUGFydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwoXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgcGFydFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFQYXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChkYXRhUGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xQYXJ0cyA9IGJsb2NrLmZpbHRlcihcbiAgICAgICAgICAgICAgKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb29sVUlQYXJ0KHBhcnQpICYmIChwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUgfHwgKChfYTE4ID0gcGFydC5hcHByb3ZhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTguYXBwcm92ZWQpICE9IG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRvb2xQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50MiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbFBhcnQgb2YgdG9vbFBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKChfZCA9IHRvb2xQYXJ0LmFwcHJvdmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2QuYXBwcm92ZWQpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogdG9vbFBhcnQuYXBwcm92YWwuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHRvb2xQYXJ0LmFwcHJvdmFsLmFwcHJvdmVkLFxuICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogdG9vbFBhcnQuYXBwcm92YWwucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRvb2xQYXJ0LnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodG9vbFBhcnQucHJvdmlkZXJFeGVjdXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9vbFBhcnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm91dHB1dC1kZW5pZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbFBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBnZXRUb29sTmFtZSh0b29sUGFydCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvci10ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoX2UgPSB0b29sUGFydC5hcHByb3ZhbC5yZWFzb24pICE9IG51bGwgPyBfZSA6IFwiVG9vbCBleGVjdXRpb24gZGVuaWVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9vbFBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiB0b29sUGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3V0cHV0LWVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRwdXQtYXZhaWxhYmxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGdldFRvb2xOYW1lKHRvb2xQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xQYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbFBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xQYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gdG9vbFBhcnQuZXJyb3JUZXh0IDogdG9vbFBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sOiAoX2YgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ZbdG9vbE5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1vZGU6IHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gXCJ0ZXh0XCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50b29sUGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHRvb2xQYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudDJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2sgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UucGFydHMpIHtcbiAgICAgICAgICAgIGlmIChpc1RleHRVSVBhcnQocGFydCkgfHwgaXNSZWFzb25pbmdVSVBhcnQocGFydCkgfHwgaXNGaWxlVUlQYXJ0KHBhcnQpIHx8IGlzVG9vbFVJUGFydChwYXJ0KSB8fCBpc0RhdGFVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInN0ZXAtc3RhcnRcIikge1xuICAgICAgICAgICAgICBhd2FpdCBwcm9jZXNzQmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc0Jsb2NrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtZXNzYWdlLnJvbGU7XG4gICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kZWxNZXNzYWdlcztcbn1cblxuLy8gc3JjL3VpL3ZhbGlkYXRlLXVpLW1lc3NhZ2VzLnRzXG5pbXBvcnQgeyBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGxhenlTY2hlbWEgYXMgbGF6eVNjaGVtYTIsXG4gIHZhbGlkYXRlVHlwZXMgYXMgdmFsaWRhdGVUeXBlczIsXG4gIHpvZFNjaGVtYSBhcyB6b2RTY2hlbWEyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo4IH0gZnJvbSBcInpvZC92NFwiO1xudmFyIHVpTWVzc2FnZXNTY2hlbWEgPSBsYXp5U2NoZW1hMihcbiAgKCkgPT4gem9kU2NoZW1hMihcbiAgICB6OC5hcnJheShcbiAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgcm9sZTogejguZW51bShbXCJzeXN0ZW1cIiwgXCJ1c2VyXCIsIFwiYXNzaXN0YW50XCJdKSxcbiAgICAgICAgbWV0YWRhdGE6IHo4LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAgICAgICBwYXJ0czogejguYXJyYXkoXG4gICAgICAgICAgejgudW5pb24oW1xuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcInRleHRcIiksXG4gICAgICAgICAgICAgIHRleHQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejguZW51bShbXCJzdHJlYW1pbmdcIiwgXCJkb25lXCJdKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcInJlYXNvbmluZ1wiKSxcbiAgICAgICAgICAgICAgdGV4dDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5lbnVtKFtcInN0cmVhbWluZ1wiLCBcImRvbmVcIl0pLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwic291cmNlLXVybFwiKSxcbiAgICAgICAgICAgICAgc291cmNlSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB1cmw6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0aXRsZTogejguc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJzb3VyY2UtZG9jdW1lbnRcIiksXG4gICAgICAgICAgICAgIHNvdXJjZUlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgbWVkaWFUeXBlOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdGl0bGU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBmaWxlbmFtZTogejguc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJmaWxlXCIpLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBmaWxlbmFtZTogejguc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgdXJsOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJzdGVwLXN0YXJ0XCIpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSxcbiAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGRhdGE6IHo4LnVua25vd24oKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImlucHV0LXN0cmVhbWluZ1wiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiYXBwcm92YWwtcmVxdWVzdGVkXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4Lm5ldmVyKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImFwcHJvdmFsLXJlc3BvbmRlZFwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5ib29sZWFuKCksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwib3V0cHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmxpdGVyYWwodHJ1ZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtZXJyb3JcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHJhd0lucHV0OiB6OC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmxpdGVyYWwodHJ1ZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtZGVuaWVkXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmxpdGVyYWwoZmFsc2UpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImlucHV0LXN0cmVhbWluZ1wiKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiaW5wdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiYXBwcm92YWwtcmVxdWVzdGVkXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4Lm5ldmVyKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcImFwcHJvdmFsLXJlc3BvbmRlZFwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgYXBwcm92YWw6IHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiB6OC5ib29sZWFuKCksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwib3V0cHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJlbGltaW5hcnk6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmxpdGVyYWwodHJ1ZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtZXJyb3JcIiksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICByYXdJbnB1dDogejgudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIG91dHB1dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBlcnJvclRleHQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmxpdGVyYWwodHJ1ZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtZGVuaWVkXCIpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmxpdGVyYWwoZmFsc2UpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejguc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdKVxuICAgICAgICApLm5vbmVtcHR5KFwiTWVzc2FnZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHBhcnRcIilcbiAgICAgIH0pXG4gICAgKS5ub25lbXB0eShcIk1lc3NhZ2VzIGFycmF5IG11c3Qgbm90IGJlIGVtcHR5XCIpXG4gIClcbik7XG5hc3luYyBmdW5jdGlvbiBzYWZlVmFsaWRhdGVVSU1lc3NhZ2VzKHtcbiAgbWVzc2FnZXMsXG4gIG1ldGFkYXRhU2NoZW1hLFxuICBkYXRhU2NoZW1hcyxcbiAgdG9vbHNcbn0pIHtcbiAgdHJ5IHtcbiAgICBpZiAobWVzc2FnZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICAgIHBhcmFtZXRlcjogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkXCJcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRlZE1lc3NhZ2VzID0gYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgdmFsdWU6IG1lc3NhZ2VzLFxuICAgICAgc2NoZW1hOiB1aU1lc3NhZ2VzU2NoZW1hXG4gICAgfSk7XG4gICAgaWYgKG1ldGFkYXRhU2NoZW1hKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgdmFsaWRhdGVkTWVzc2FnZXMpIHtcbiAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgIHZhbHVlOiBtZXNzYWdlLm1ldGFkYXRhLFxuICAgICAgICAgIHNjaGVtYTogbWV0YWRhdGFTY2hlbWFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhU2NoZW1hcykge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHZhbGlkYXRlZE1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGRhdGFQYXJ0cyA9IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUuc3RhcnRzV2l0aChcImRhdGEtXCIpXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgZGF0YVBhcnQgb2YgZGF0YVBhcnRzKSB7XG4gICAgICAgICAgY29uc3QgZGF0YU5hbWUgPSBkYXRhUGFydC50eXBlLnNsaWNlKDUpO1xuICAgICAgICAgIGNvbnN0IGRhdGFTY2hlbWEgPSBkYXRhU2NoZW1hc1tkYXRhTmFtZV07XG4gICAgICAgICAgaWYgKCFkYXRhU2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMyh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFQYXJ0LmRhdGEsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGBObyBkYXRhIHNjaGVtYSBmb3VuZCBmb3IgZGF0YSBwYXJ0ICR7ZGF0YU5hbWV9YFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgdmFsdWU6IGRhdGFQYXJ0LmRhdGEsXG4gICAgICAgICAgICBzY2hlbWE6IGRhdGFTY2hlbWFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodG9vbHMpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiB2YWxpZGF0ZWRNZXNzYWdlcykge1xuICAgICAgICBjb25zdCB0b29sUGFydHMgPSBtZXNzYWdlLnBhcnRzLmZpbHRlcihcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xQYXJ0IG9mIHRvb2xQYXJ0cykge1xuICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdG9vbFBhcnQudHlwZS5zbGljZSg1KTtcbiAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICBpZiAoIXRvb2wyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMyh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvb2xQYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBgTm8gdG9vbCBzY2hlbWEgZm91bmQgZm9yIHRvb2wgcGFydCAke3Rvb2xOYW1lfWBcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b29sUGFydC5zdGF0ZSA9PT0gXCJpbnB1dC1hdmFpbGFibGVcIiB8fCB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgJiYgdG9vbFBhcnQuaW5wdXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgICB2YWx1ZTogdG9vbFBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgIHNjaGVtYTogdG9vbDIuaW5wdXRTY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiICYmIHRvb2wyLm91dHB1dFNjaGVtYSkge1xuICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgICB2YWx1ZTogdG9vbFBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICBzY2hlbWE6IHRvb2wyLm91dHB1dFNjaGVtYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YTogdmFsaWRhdGVkTWVzc2FnZXNcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGVyciA9IGVycm9yO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVVJTWVzc2FnZXMoe1xuICBtZXNzYWdlcyxcbiAgbWV0YWRhdGFTY2hlbWEsXG4gIGRhdGFTY2hlbWFzLFxuICB0b29sc1xufSkge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNhZmVWYWxpZGF0ZVVJTWVzc2FnZXMoe1xuICAgIG1lc3NhZ2VzLFxuICAgIG1ldGFkYXRhU2NoZW1hLFxuICAgIGRhdGFTY2hlbWFzLFxuICAgIHRvb2xzXG4gIH0pO1xuICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpXG4gICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gIHJldHVybiByZXNwb25zZS5kYXRhO1xufVxuXG4vLyBzcmMvYWdlbnQvY3JlYXRlLWFnZW50LXVpLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWdlbnRVSVN0cmVhbSh7XG4gIGFnZW50LFxuICB1aU1lc3NhZ2VzLFxuICBvcHRpb25zLFxuICBhYm9ydFNpZ25hbCxcbiAgdGltZW91dCxcbiAgZXhwZXJpbWVudGFsX3RyYW5zZm9ybSxcbiAgLi4udWlNZXNzYWdlU3RyZWFtT3B0aW9uc1xufSkge1xuICBjb25zdCB2YWxpZGF0ZWRNZXNzYWdlcyA9IGF3YWl0IHZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gICAgbWVzc2FnZXM6IHVpTWVzc2FnZXMsXG4gICAgdG9vbHM6IGFnZW50LnRvb2xzXG4gIH0pO1xuICBjb25zdCBtb2RlbE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTW9kZWxNZXNzYWdlcyh2YWxpZGF0ZWRNZXNzYWdlcywge1xuICAgIHRvb2xzOiBhZ2VudC50b29sc1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWdlbnQuc3RyZWFtKHtcbiAgICBwcm9tcHQ6IG1vZGVsTWVzc2FnZXMsXG4gICAgb3B0aW9ucyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICB0aW1lb3V0LFxuICAgIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQudG9VSU1lc3NhZ2VTdHJlYW0odWlNZXNzYWdlU3RyZWFtT3B0aW9ucyk7XG59XG5cbi8vIHNyYy9hZ2VudC9jcmVhdGUtYWdlbnQtdWktc3RyZWFtLXJlc3BvbnNlLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudFVJU3RyZWFtUmVzcG9uc2Uoe1xuICBoZWFkZXJzLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGNvbnN1bWVTc2VTdHJlYW0sXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgICBoZWFkZXJzLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNvbnN1bWVTc2VTdHJlYW0sXG4gICAgc3RyZWFtOiBhd2FpdCBjcmVhdGVBZ2VudFVJU3RyZWFtKG9wdGlvbnMpXG4gIH0pO1xufVxuXG4vLyBzcmMvYWdlbnQvcGlwZS1hZ2VudC11aS1zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHBpcGVBZ2VudFVJU3RyZWFtVG9SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBoZWFkZXJzLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGNvbnN1bWVTc2VTdHJlYW0sXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgIHJlc3BvbnNlLFxuICAgIGhlYWRlcnMsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY29uc3VtZVNzZVN0cmVhbSxcbiAgICBzdHJlYW06IGF3YWl0IGNyZWF0ZUFnZW50VUlTdHJlYW0ob3B0aW9ucylcbiAgfSk7XG59XG5cbi8vIHNyYy9lbWJlZC9lbWJlZC50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4MyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgdmFsdWUsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVFbWJlZGRpbmdNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXgzKFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkXCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkXCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIFwiYWkudmFsdWVcIjogeyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCB7IGVtYmVkZGluZywgdXNhZ2UsIHdhcm5pbmdzLCByZXNwb25zZSwgcHJvdmlkZXJNZXRhZGF0YSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZzIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3NbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTE3ID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTcgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3MubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVtYmVkZGluZzMpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZzMpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmc6IGVtYmVkZGluZzIsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHVzYWdlMixcbiAgICAgICAgICAgICAgICB3YXJuaW5nczogbW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBsb2dXYXJuaW5ncyh7IHdhcm5pbmdzLCBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsIG1vZGVsOiBtb2RlbC5tb2RlbElkIH0pO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRSZXN1bHQoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZW1iZWRkaW5nLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBzcmMvZW1iZWQvZW1iZWQtbWFueS50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4NCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL3NwbGl0LWFycmF5LnRzXG5mdW5jdGlvbiBzcGxpdEFycmF5KGFycmF5MiwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Mi5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgcmVzdWx0LnB1c2goYXJyYXkyLnNsaWNlKGksIGkgKyBjaHVua1NpemUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvZW1iZWQvZW1iZWQtbWFueS50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWRNYW55KHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICB2YWx1ZXMsXG4gIG1heFBhcmFsbGVsQ2FsbHMgPSBJbmZpbml0eSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUVtYmVkZGluZ01vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDQoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueVwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgY29uc3QgW21heEVtYmVkZGluZ3NQZXJDYWxsLCBzdXBwb3J0c1BhcmFsbGVsQ2FsbHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBtb2RlbC5tYXhFbWJlZGRpbmdzUGVyQ2FsbCxcbiAgICAgICAgbW9kZWwuc3VwcG9ydHNQYXJhbGxlbENhbGxzXG4gICAgICBdKTtcbiAgICAgIGlmIChtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9PSBudWxsIHx8IG1heEVtYmVkZGluZ3NQZXJDYWxsID09PSBJbmZpbml0eSkge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSwgd2FybmluZ3M6IHdhcm5pbmdzMiwgcmVzcG9uc2UsIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEyIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTE4ID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTggOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMyxcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MyLFxuICAgICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsXG4gICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzMixcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhMixcbiAgICAgICAgICByZXNwb25zZXM6IFtyZXNwb25zZV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICBsZXQgdG9rZW5zID0gMDtcbiAgICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgICAgY29uc3QgcGFyYWxsZWxDaHVua3MgPSBzcGxpdEFycmF5KFxuICAgICAgICB2YWx1ZUNodW5rcyxcbiAgICAgICAgc3VwcG9ydHNQYXJhbGxlbENhbGxzID8gbWF4UGFyYWxsZWxDYWxscyA6IDFcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IHBhcmFsbGVsQ2h1bmsgb2YgcGFyYWxsZWxDaHVua3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHBhcmFsbGVsQ2h1bmsubWFwKChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5KCgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjaHVuay5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXNhZ2UgPSAoX2ExOCA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE4IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMixcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3VsdC5lbWJlZGRpbmdzKTtcbiAgICAgICAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncyk7XG4gICAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVzdWx0LnJlc3BvbnNlKTtcbiAgICAgICAgICB0b2tlbnMgKz0gcmVzdWx0LnVzYWdlLnRva2VucztcbiAgICAgICAgICBpZiAocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0geyAuLi5yZXN1bHQucHJvdmlkZXJNZXRhZGF0YSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBbcHJvdmlkZXJOYW1lLCBtZXRhZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICAgICAgcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgIC4uLihfYTE3ID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdKSAhPSBudWxsID8gX2ExNyA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgIHJlc3BvbnNlc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRNYW55UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBvcHRpb25zLmVtYmVkZGluZ3M7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS1pbWFnZS9nZW5lcmF0ZS1pbWFnZS50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5NCxcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4NVxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZSh7XG4gIG1vZGVsOiBtb2RlbEFyZyxcbiAgcHJvbXB0OiBwcm9tcHRBcmcsXG4gIG4gPSAxLFxuICBtYXhJbWFnZXNQZXJDYWxsLFxuICBzaXplLFxuICBhc3BlY3RSYXRpbyxcbiAgc2VlZCxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExNywgX2I7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUltYWdlTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXg1KFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdCA9IChfYTE3ID0gbWF4SW1hZ2VzUGVyQ2FsbCAhPSBudWxsID8gbWF4SW1hZ2VzUGVyQ2FsbCA6IGF3YWl0IGludm9rZU1vZGVsTWF4SW1hZ2VzUGVyQ2FsbChtb2RlbCkpICE9IG51bGwgPyBfYTE3IDogMTtcbiAgY29uc3QgY2FsbENvdW50ID0gTWF0aC5jZWlsKG4gLyBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQpO1xuICBjb25zdCBjYWxsSW1hZ2VDb3VudHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjYWxsQ291bnQgfSwgKF8sIGkpID0+IHtcbiAgICBpZiAoaSA8IGNhbGxDb3VudCAtIDEpIHtcbiAgICAgIHJldHVybiBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmRlciA9IG4gJSBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQ7XG4gICAgcmV0dXJuIHJlbWFpbmRlciA9PT0gMCA/IG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdCA6IHJlbWFpbmRlcjtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBjYWxsSW1hZ2VDb3VudHMubWFwKFxuICAgICAgYXN5bmMgKGNhbGxJbWFnZUNvdW50KSA9PiByZXRyeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHJvbXB0LCBmaWxlcywgbWFzayB9ID0gbm9ybWFsaXplUHJvbXB0KHByb21wdEFyZyk7XG4gICAgICAgIHJldHVybiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgZmlsZXMsXG4gICAgICAgICAgbWFzayxcbiAgICAgICAgICBuOiBjYWxsSW1hZ2VDb3VudCxcbiAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHNlZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck9wdGlvbnMgIT0gbnVsbCA/IHByb3ZpZGVyT3B0aW9ucyA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICApXG4gICk7XG4gIGNvbnN0IGltYWdlcyA9IFtdO1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgY29uc3QgcHJvdmlkZXJNZXRhZGF0YSA9IHt9O1xuICBsZXQgdG90YWxVc2FnZSA9IHtcbiAgICBpbnB1dFRva2Vuczogdm9pZCAwLFxuICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgIHRvdGFsVG9rZW5zOiB2b2lkIDBcbiAgfTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGltYWdlcy5wdXNoKFxuICAgICAgLi4ucmVzdWx0LmltYWdlcy5tYXAoXG4gICAgICAgIChpbWFnZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlZEZpbGUoe1xuICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IChfYTE4ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICAgICAgZGF0YTogaW1hZ2UsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZXM6IGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgICAgICAgICAgfSkpICE9IG51bGwgPyBfYTE4IDogXCJpbWFnZS9wbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICB3YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncyk7XG4gICAgaWYgKHJlc3VsdC51c2FnZSAhPSBudWxsKSB7XG4gICAgICB0b3RhbFVzYWdlID0gYWRkSW1hZ2VNb2RlbFVzYWdlKHRvdGFsVXNhZ2UsIHJlc3VsdC51c2FnZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgZm9yIChjb25zdCBbcHJvdmlkZXJOYW1lLCBtZXRhZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEpKSB7XG4gICAgICAgIGlmIChwcm92aWRlck5hbWUgPT09IFwiZ2F0ZXdheVwiKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudEVudHJ5ID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdO1xuICAgICAgICAgIGlmIChjdXJyZW50RW50cnkgIT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudEVudHJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnRFbnRyeSxcbiAgICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IG1ldGFkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbWFnZXNWYWx1ZSA9IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXM7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW1hZ2VzVmFsdWUpICYmIGltYWdlc1ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChfYiA9IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSkgIT0gbnVsbCA/IF9iIDogcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdID0geyBpbWFnZXM6IFtdIH07XG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdLmltYWdlcy5wdXNoKFxuICAgICAgICAgICAgLi4ucmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3BvbnNlcy5wdXNoKHJlc3VsdC5yZXNwb25zZSk7XG4gIH1cbiAgbG9nV2FybmluZ3MoeyB3YXJuaW5ncywgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLCBtb2RlbDogbW9kZWwubW9kZWxJZCB9KTtcbiAgaWYgKCFpbWFnZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IE5vSW1hZ2VHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlcyB9KTtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZUltYWdlUmVzdWx0KHtcbiAgICBpbWFnZXMsXG4gICAgd2FybmluZ3MsXG4gICAgcmVzcG9uc2VzLFxuICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgdXNhZ2U6IHRvdGFsVXNhZ2VcbiAgfSk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICB9XG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZXNbMF07XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBpbnZva2VNb2RlbE1heEltYWdlc1BlckNhbGwobW9kZWwpIHtcbiAgY29uc3QgaXNGdW5jdGlvbiA9IG1vZGVsLm1heEltYWdlc1BlckNhbGwgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgaWYgKCFpc0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIG1vZGVsLm1heEltYWdlc1BlckNhbGw7XG4gIH1cbiAgcmV0dXJuIG1vZGVsLm1heEltYWdlc1BlckNhbGwoe1xuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9tcHQocHJvbXB0KSB7XG4gIGlmICh0eXBlb2YgcHJvbXB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgcHJvbXB0LCBmaWxlczogdm9pZCAwLCBtYXNrOiB2b2lkIDAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb21wdDogcHJvbXB0LnRleHQsXG4gICAgZmlsZXM6IHByb21wdC5pbWFnZXMubWFwKHRvSW1hZ2VNb2RlbFYzRmlsZSksXG4gICAgbWFzazogcHJvbXB0Lm1hc2sgPyB0b0ltYWdlTW9kZWxWM0ZpbGUocHJvbXB0Lm1hc2spIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiB0b0ltYWdlTW9kZWxWM0ZpbGUoZGF0YUNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBkYXRhQ29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhQ29udGVudC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVybFwiLFxuICAgICAgdXJsOiBkYXRhQ29udGVudFxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhQ29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhQ29udGVudC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICBjb25zdCB7IG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKGRhdGFDb250ZW50KTtcbiAgICBpZiAoYmFzZTY0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCB1aW50OERhdGEyID0gY29udmVydEJhc2U2NFRvVWludDhBcnJheTQoYmFzZTY0Q29udGVudCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgZGF0YTogdWludDhEYXRhMixcbiAgICAgICAgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlIHx8IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgICAgZGF0YTogdWludDhEYXRhMixcbiAgICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkgfHwgXCJpbWFnZS9wbmdcIlxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdWludDhEYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGRhdGFDb250ZW50KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImZpbGVcIixcbiAgICBkYXRhOiB1aW50OERhdGEsXG4gICAgbWVkaWFUeXBlOiBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgZGF0YTogdWludDhEYXRhLFxuICAgICAgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgfSkgfHwgXCJpbWFnZS9wbmdcIlxuICB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtaW1hZ2UvaW5kZXgudHNcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVJbWFnZSA9IGdlbmVyYXRlSW1hZ2U7XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQge1xuICBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjMsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvZXh0cmFjdC1yZWFzb25pbmctY29udGVudC50c1xuZnVuY3Rpb24gZXh0cmFjdFJlYXNvbmluZ0NvbnRlbnQoY29udGVudCkge1xuICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuZmlsdGVyKFxuICAgIChjb250ZW50MikgPT4gY29udGVudDIudHlwZSA9PT0gXCJyZWFzb25pbmdcIlxuICApO1xuICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAwID8gdm9pZCAwIDogcGFydHMubWFwKChjb250ZW50MikgPT4gY29udGVudDIudGV4dCkuam9pbihcIlxcblwiKTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9vdXRwdXQtc3RyYXRlZ3kudHNcbmltcG9ydCB7XG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjQsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWE0LFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBub1NjaGVtYU91dHB1dFN0cmF0ZWd5ID0ge1xuICB0eXBlOiBcIm5vLXNjaGVtYVwiLFxuICBqc29uU2NoZW1hOiBhc3luYyAoKSA9PiB2b2lkIDAsXG4gIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB7IHBhcnRpYWw6IHZhbHVlLCB0ZXh0RGVsdGEgfSB9O1xuICB9LFxuICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlLCBjb250ZXh0Mikge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICB0ZXh0OiBjb250ZXh0Mi50ZXh0LFxuICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgIH0pXG4gICAgfSA6IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG5vLXNjaGVtYSBtb2RlXCJcbiAgICB9KTtcbiAgfVxufTtcbnZhciBvYmplY3RPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+ICh7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIGpzb25TY2hlbWE6IGFzeW5jICgpID0+IGF3YWl0IHNjaGVtYS5qc29uU2NoZW1hLFxuICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC8vIE5vdGU6IGN1cnJlbnRseSBubyB2YWxpZGF0aW9uIG9mIHBhcnRpYWwgcmVzdWx0czpcbiAgICAgICAgcGFydGlhbDogdmFsdWUsXG4gICAgICAgIHRleHREZWx0YVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICByZXR1cm4gc2FmZVZhbGlkYXRlVHlwZXM0KHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyBhcnJheSBvZiBlbGVtZW50cywgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBhcnJheSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgYXJyYXlzIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgZ3JhbW1hci1ndWlkZWQgZ2VuZXJhdGlvblxuICAgIGpzb25TY2hlbWE6IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0gYXdhaXQgc2NoZW1hLmpzb25TY2hlbWE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkc2NoZW1hOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZWxlbWVudHM6IHsgdHlwZTogXCJhcnJheVwiLCBpdGVtczogaXRlbVNjaGVtYSB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHtcbiAgICAgIHZhbHVlLFxuICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgaXNGaW5hbERlbHRhXG4gICAgfSkge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgY29uc3QgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXM0KHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKGkgPT09IGlucHV0QXJyYXkubGVuZ3RoIC0gMSAmJiAhaXNGaW5hbERlbHRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGlzaGVkRWxlbWVudENvdW50ID0gKF9hMTcgPSBsYXRlc3RPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdE9iamVjdC5sZW5ndGgpICE9IG51bGwgPyBfYTE3IDogMDtcbiAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgaWYgKGlzRmlyc3REZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJbXCI7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaGVkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCIsXCI7XG4gICAgICB9XG4gICAgICB0ZXh0RGVsdGEgKz0gcmVzdWx0QXJyYXkuc2xpY2UocHVibGlzaGVkRWxlbWVudENvdW50KS5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLFwiKTtcbiAgICAgIGlmIChpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiByZXN1bHRBcnJheSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaW5wdXRBcnJheSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczQoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IGlucHV0QXJyYXkgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0ob3JpZ2luYWxTdHJlYW0pIHtcbiAgICAgIGxldCBwdWJsaXNoZWRFbGVtZW50cyA9IDA7XG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgICAgb3JpZ2luYWxTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhcnJheTIgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheTIubGVuZ3RoOyBwdWJsaXNoZWRFbGVtZW50cysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShhcnJheTJbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcbnZhciBlbnVtT3V0cHV0U3RyYXRlZ3kgPSAoZW51bVZhbHVlcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIC8vIHdyYXAgaW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcmVzdWx0LCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGVudW0gdmFsdWUgZGlyZWN0bHk6XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIG9wdGltaXphdGlvbjogdXNlIGVudW1zIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgdG9wLWxldmVsIGVudW1zXG4gICAganNvblNjaGVtYTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0pLFxuICAgIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiAndmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHN0cmluZyBpbiB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICAgIHJldHVybiBlbnVtVmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQgfSA6IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6ICd2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgc3RyaW5nIGluIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVzdWx0O1xuICAgICAgY29uc3QgcG9zc2libGVFbnVtVmFsdWVzID0gZW51bVZhbHVlcy5maWx0ZXIoXG4gICAgICAgIChlbnVtVmFsdWUpID0+IGVudW1WYWx1ZS5zdGFydHNXaXRoKHJlc3VsdClcbiAgICAgICk7XG4gICAgICBpZiAodmFsdWUucmVzdWx0Lmxlbmd0aCA9PT0gMCB8fCBwb3NzaWJsZUVudW1WYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHBvc3NpYmxlRW51bVZhbHVlcy5sZW5ndGggPiAxID8gcmVzdWx0IDogcG9zc2libGVFbnVtVmFsdWVzWzBdLFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjMoe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgc3dpdGNoIChvdXRwdXQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gb2JqZWN0T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWE0KHNjaGVtYSkpO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIGFycmF5T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWE0KHNjaGVtYSkpO1xuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICByZXR1cm4gZW51bU91dHB1dFN0cmF0ZWd5KGVudW1WYWx1ZXMpO1xuICAgIGNhc2UgXCJuby1zY2hlbWFcIjpcbiAgICAgIHJldHVybiBub1NjaGVtYU91dHB1dFN0cmF0ZWd5O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBvdXRwdXQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3BhcnNlLWFuZC12YWxpZGF0ZS1vYmplY3QtcmVzdWx0LnRzXG5pbXBvcnQgeyBKU09OUGFyc2VFcnJvciBhcyBKU09OUGFyc2VFcnJvcjIsIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09ONCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0KHJlc3VsdCwgb3V0cHV0U3RyYXRlZ3ksIGNvbnRleHQyKSB7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjQoeyB0ZXh0OiByZXN1bHQgfSk7XG4gIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAge1xuICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlXG4gICAgfVxuICApO1xuICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0V2l0aFJlcGFpcihyZXN1bHQsIG91dHB1dFN0cmF0ZWd5LCByZXBhaXJUZXh0LCBjb250ZXh0Mikge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0KHJlc3VsdCwgb3V0cHV0U3RyYXRlZ3ksIGNvbnRleHQyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAocmVwYWlyVGV4dCAhPSBudWxsICYmIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgJiYgKEpTT05QYXJzZUVycm9yMi5pc0luc3RhbmNlKGVycm9yLmNhdXNlKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yNS5pc0luc3RhbmNlKGVycm9yLmNhdXNlKSkpIHtcbiAgICAgIGNvbnN0IHJlcGFpcmVkVGV4dCA9IGF3YWl0IHJlcGFpclRleHQoe1xuICAgICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICAgIGVycm9yOiBlcnJvci5jYXVzZVxuICAgICAgfSk7XG4gICAgICBpZiAocmVwYWlyZWRUZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHQoXG4gICAgICAgIHJlcGFpcmVkVGV4dCxcbiAgICAgICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgICAgIGNvbnRleHQyXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3ZhbGlkYXRlLW9iamVjdC1nZW5lcmF0aW9uLWlucHV0LnRzXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gIG91dHB1dCxcbiAgc2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgZW51bVZhbHVlc1xufSkge1xuICBpZiAob3V0cHV0ICE9IG51bGwgJiYgb3V0cHV0ICE9PSBcIm9iamVjdFwiICYmIG91dHB1dCAhPT0gXCJhcnJheVwiICYmIG91dHB1dCAhPT0gXCJlbnVtXCIgJiYgb3V0cHV0ICE9PSBcIm5vLXNjaGVtYVwiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJvdXRwdXRcIixcbiAgICAgIHZhbHVlOiBvdXRwdXQsXG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgb3V0cHV0IHR5cGUuXCJcbiAgICB9KTtcbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm5vLXNjaGVtYVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYURlc2NyaXB0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgZGVzY3JpcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgcmVxdWlyZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiYXJyYXlcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIkVsZW1lbnQgc2NoZW1hIGlzIHJlcXVpcmVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJlbnVtXCIpIHtcbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYURlc2NyaXB0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgZGVzY3JpcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSByZXF1aXJlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGVudW1WYWx1ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzLlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDMgPSBjcmVhdGVJZEdlbmVyYXRvcjMoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbDogbW9kZWxBcmcsXG4gICAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgaGVhZGVycyxcbiAgICBleHBlcmltZW50YWxfcmVwYWlyVGV4dDogcmVwYWlyVGV4dCxcbiAgICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gICAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIF9pbnRlcm5hbDoge1xuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBvcmlnaW5hbEdlbmVyYXRlSWQzLFxuICAgICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgIH0gPSB7fSxcbiAgICAuLi5zZXR0aW5nc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbW9kZWwgPSByZXNvbHZlTGFuZ3VhZ2VNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IGVudW1WYWx1ZXMgPSBcImVudW1cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5lbnVtIDogdm9pZCAwO1xuICBjb25zdCB7XG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBzY2hlbWFOYW1lXG4gIH0gPSBcInNjaGVtYVwiIGluIG9wdGlvbnMgPyBvcHRpb25zIDoge307XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4NihcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIGNvbnN0IGpzb25TY2hlbWEyID0gYXdhaXQgb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSgpO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYWkuc2NoZW1hXCI6IGpzb25TY2hlbWEyICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShqc29uU2NoZW1hMikgfSA6IHZvaWQgMCxcbiAgICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHRyYWNlcixcbiAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgICAgbGV0IHVzYWdlO1xuICAgICAgICBsZXQgd2FybmluZ3M7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHJlcXVlc3Q7XG4gICAgICAgIGxldCByZXN1bHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgICBsZXQgcmVhc29uaW5nO1xuICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBtb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IGNhbGxTZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExOCwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICBzY2hlbWE6IGpzb25TY2hlbWEyLFxuICAgICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9iID0gKF9hMTggPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5pZCkgIT0gbnVsbCA/IF9iIDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZCA9IChfYyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy50aW1lc3RhbXApICE9IG51bGwgPyBfZCA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogKF9nID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogKF9oID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmJvZHlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dDIgPSBleHRyYWN0VGV4dENvbnRlbnQocmVzdWx0Mi5jb250ZW50KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nMiA9IGV4dHJhY3RSZWFzb25pbmdDb250ZW50KHJlc3VsdDIuY29udGVudCk7XG4gICAgICAgICAgICAgIGlmICh0ZXh0MiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYSByZXNwb25zZS5cIixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogYXNMYW5ndWFnZU1vZGVsVXNhZ2UocmVzdWx0Mi51c2FnZSksXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHJlc3VsdDIuZmluaXNoUmVhc29uLnVuaWZpZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gdGV4dDIgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDIucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLm91dHB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Mi5maW5pc2hSZWFzb24udW5pZmllZFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLm91dHB1dFRva2Vucy50b3RhbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0MixcbiAgICAgICAgICAgICAgICBvYmplY3RUZXh0OiB0ZXh0MixcbiAgICAgICAgICAgICAgICByZWFzb25pbmc6IHJlYXNvbmluZzIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEYXRhXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uLnVuaWZpZWQ7XG4gICAgICAgIHVzYWdlID0gYXNMYW5ndWFnZU1vZGVsVXNhZ2UoZ2VuZXJhdGVSZXN1bHQudXNhZ2UpO1xuICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgcmVxdWVzdCA9IChfYTE3ID0gZ2VuZXJhdGVSZXN1bHQucmVxdWVzdCkgIT0gbnVsbCA/IF9hMTcgOiB7fTtcbiAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yZXNwb25zZURhdGE7XG4gICAgICAgIHJlYXNvbmluZyA9IGdlbmVyYXRlUmVzdWx0LnJlYXNvbmluZztcbiAgICAgICAgbG9nV2FybmluZ3Moe1xuICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2JqZWN0MiA9IGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHRXaXRoUmVwYWlyKFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgICByZXBhaXJUZXh0LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb25cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QyKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICByZWFzb25pbmcsXG4gICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyB3cmFwR2F0ZXdheUVycm9yKGVycm9yKTtcbiAgfVxufVxudmFyIERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMucmVhc29uaW5nID0gb3B0aW9ucy5yZWFzb25pbmc7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTE3O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTE3ID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTE3IDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNCxcbiAgRGVsYXllZFByb21pc2UgYXMgRGVsYXllZFByb21pc2UyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2Nvc2luZS1zaW1pbGFyaXR5LnRzXG5mdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwidmVjdG9yMSx2ZWN0b3IyXCIsXG4gICAgICB2YWx1ZTogeyB2ZWN0b3IxTGVuZ3RoOiB2ZWN0b3IxLmxlbmd0aCwgdmVjdG9yMkxlbmd0aDogdmVjdG9yMi5sZW5ndGggfSxcbiAgICAgIG1lc3NhZ2U6IGBWZWN0b3JzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhgXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbiA9IHZlY3RvcjEubGVuZ3RoO1xuICBpZiAobiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBtYWduaXR1ZGVTcXVhcmVkMSA9IDA7XG4gIGxldCBtYWduaXR1ZGVTcXVhcmVkMiA9IDA7XG4gIGxldCBkb3RQcm9kdWN0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZTEgPSB2ZWN0b3IxW2ldO1xuICAgIGNvbnN0IHZhbHVlMiA9IHZlY3RvcjJbaV07XG4gICAgbWFnbml0dWRlU3F1YXJlZDEgKz0gdmFsdWUxICogdmFsdWUxO1xuICAgIG1hZ25pdHVkZVNxdWFyZWQyICs9IHZhbHVlMiAqIHZhbHVlMjtcbiAgICBkb3RQcm9kdWN0ICs9IHZhbHVlMSAqIHZhbHVlMjtcbiAgfVxuICByZXR1cm4gbWFnbml0dWRlU3F1YXJlZDEgPT09IDAgfHwgbWFnbml0dWRlU3F1YXJlZDIgPT09IDAgPyAwIDogZG90UHJvZHVjdCAvIChNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZDEpICogTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQyKSk7XG59XG5cbi8vIHNyYy91dGlsL2RhdGEtdXJsLnRzXG5mdW5jdGlvbiBnZXRUZXh0RnJvbURhdGFVcmwoZGF0YVVybCkge1xuICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICBjb25zdCBtZWRpYVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgaWYgKG1lZGlhVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBVUkwgZm9ybWF0XCIpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKGJhc2U2NENvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjb2RpbmcgZGF0YSBVUkxgKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9pcy1kZWVwLWVxdWFsLWRhdGEudHNcbmZ1bmN0aW9uIGlzRGVlcEVxdWFsRGF0YShvYmoxLCBvYmoyKSB7XG4gIGlmIChvYmoxID09PSBvYmoyKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAob2JqMSA9PSBudWxsIHx8IG9iajIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqMiAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbiAgaWYgKG9iajEuY29uc3RydWN0b3IgIT09IG9iajIuY29uc3RydWN0b3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAob2JqMSBpbnN0YW5jZW9mIERhdGUgJiYgb2JqMiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gb2JqMS5nZXRUaW1lKCkgPT09IG9iajIuZ2V0VGltZSgpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYgKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKG9iajFbaV0sIG9iajJbaV0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgaWYgKCFrZXlzMi5pbmNsdWRlcyhrZXkpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKG9iajFba2V5XSwgb2JqMltrZXldKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWwvc2VyaWFsLWpvYi1leGVjdXRvci50c1xudmFyIFNlcmlhbEpvYkV4ZWN1dG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBwcm9jZXNzUXVldWUoKSB7XG4gICAgaWYgKHRoaXMuaXNQcm9jZXNzaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnF1ZXVlWzBdKCk7XG4gICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgfVxuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcnVuKGpvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZTMsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBqb2IoKTtcbiAgICAgICAgICByZXNvbHZlMygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdm9pZCB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbC9zaW11bGF0ZS1yZWFkYWJsZS1zdHJlYW0udHNcbmltcG9ydCB7IGRlbGF5IGFzIGRlbGF5RnVuY3Rpb24gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gc2ltdWxhdGVSZWFkYWJsZVN0cmVhbSh7XG4gIGNodW5rcyxcbiAgaW5pdGlhbERlbGF5SW5NcyA9IDAsXG4gIGNodW5rRGVsYXlJbk1zID0gMCxcbiAgX2ludGVybmFsXG59KSB7XG4gIHZhciBfYTE3O1xuICBjb25zdCBkZWxheTIgPSAoX2ExNyA9IF9pbnRlcm5hbCA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsLmRlbGF5KSAhPSBudWxsID8gX2ExNyA6IGRlbGF5RnVuY3Rpb247XG4gIGxldCBpbmRleCA9IDA7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgaWYgKGluZGV4IDwgY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCBkZWxheTIoaW5kZXggPT09IDAgPyBpbml0aWFsRGVsYXlJbk1zIDogY2h1bmtEZWxheUluTXMpO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmtzW2luZGV4KytdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQ0ID0gY3JlYXRlSWRHZW5lcmF0b3I0KHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuZnVuY3Rpb24gc3RyZWFtT2JqZWN0KG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG1vZGVsLFxuICAgIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBtYXhSZXRyaWVzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIGhlYWRlcnMsXG4gICAgZXhwZXJpbWVudGFsX3JlcGFpclRleHQ6IHJlcGFpclRleHQsXG4gICAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICAgIGV4cGVyaW1lbnRhbF9kb3dubG9hZDogZG93bmxvYWQyLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBvbkVycm9yID0gKHsgZXJyb3IgfSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfSxcbiAgICBvbkZpbmlzaCxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyID0gb3JpZ2luYWxHZW5lcmF0ZUlkNCxcbiAgICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBub3c6IG5vdzIgPSBub3dcbiAgICB9ID0ge30sXG4gICAgLi4uc2V0dGluZ3NcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGVudW1WYWx1ZXMgPSBcImVudW1cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuZW51bSA/IG9wdGlvbnMuZW51bSA6IHZvaWQgMDtcbiAgY29uc3Qge1xuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgc2NoZW1hTmFtZVxuICB9ID0gXCJzY2hlbWFcIiBpbiBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICByZXBhaXJUZXh0LFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBub3c6IG5vdzJcbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsOiBtb2RlbEFyZyxcbiAgICBoZWFkZXJzLFxuICAgIHRlbGVtZXRyeSxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgcmVwYWlyVGV4dCxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGRvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUsXG4gICAgbm93OiBub3cyXG4gIH0pIHtcbiAgICB0aGlzLl9vYmplY3QgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fdXNhZ2UgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fcHJvdmlkZXJNZXRhZGF0YSA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl93YXJuaW5ncyA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX3Jlc3BvbnNlID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX2ZpbmlzaFJlYXNvbiA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICBjb25zdCBtb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIG1vZGVsLFxuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBvbkVycm9yKHsgZXJyb3I6IHdyYXBHYXRld2F5RXJyb3IoY2h1bmsuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0ucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiB7XG4gICAgICAgICAgICBpbnB1dDogYXN5bmMgKCkgPT4gSlNPTi5zdHJpbmdpZnkoYXdhaXQgb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSgpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLmRlc2NyaXB0aW9uXCI6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGVcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICBmbjogYXN5bmMgKHJvb3RTcGFuKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgICByZXNwb25zZUZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzY2hlbWE6IGF3YWl0IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEoKSxcbiAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgICBkb3dubG9hZDogZG93bmxvYWQyXG4gICAgICAgICAgfSksXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgaW5jbHVkZVJhd0NodW5rczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5kZWx0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICBjYXNlIFwic3RyZWFtLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXN1bHQ6IHsgc3RyZWFtLCByZXNwb25zZSwgcmVxdWVzdCB9LFxuICAgICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShjYWxsT3B0aW9ucy5wcm9tcHQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBjYWxsU2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogY2FsbFNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogY2FsbFNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMikgPT4gKHtcbiAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oY2FsbE9wdGlvbnMpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHNlbGYuX3JlcXVlc3QucmVzb2x2ZShyZXF1ZXN0ICE9IG51bGwgPyByZXF1ZXN0IDoge30pO1xuICAgICAgICBsZXQgd2FybmluZ3M7XG4gICAgICAgIGxldCB1c2FnZSA9IGNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UoKTtcbiAgICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIGxldCBvYmplY3QyO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgICAgICBsZXQgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgbGV0IGZ1bGxSZXNwb25zZSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGF0ZXN0T2JqZWN0SnNvbiA9IHZvaWQgMDtcbiAgICAgICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICAgICAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICAgIGxldCBpc0ZpcnN0RGVsdGEgPSB0cnVlO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKSkucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMTcsIF9iLCBfYztcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJvYmplY3RcIiAmJiBjaHVuay50eXBlID09PSBcInN0cmVhbS1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgd2FybmluZ3MgPSBjaHVuay53YXJuaW5ncztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaXJzdENodW5rID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXBNcztcbiAgICAgICAgICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGEgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogY3VycmVudE9iamVjdEpzb24sIHN0YXRlOiBwYXJzZVN0YXRlIH0gPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKGFjY3VtdWxhdGVkVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRPYmplY3RKc29uICE9PSB2b2lkIDAgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3RKc29uLCBjdXJyZW50T2JqZWN0SnNvbikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZVBhcnRpYWxSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3VycmVudE9iamVjdEpzb24sXG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0RGVsdGEsXG4gICAgICAgICAgICAgICAgICAgIGlzRmluYWxEZWx0YTogcGFyc2VTdGF0ZSA9PT0gXCJzdWNjZXNzZnVsLXBhcnNlXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2VzcyAmJiAhaXNEZWVwRXF1YWxEYXRhKFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbFxuICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3RKc29uID0gY3VycmVudE9iamVjdEpzb247XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbDtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogbGF0ZXN0T2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogdmFsaWRhdGlvblJlc3VsdC52YWx1ZS50ZXh0RGVsdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGZ1bGxSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IChfYTE3ID0gY2h1bmsuaWQpICE9IG51bGwgPyBfYTE3IDogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iIDogZnVsbFJlc3BvbnNlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jIDogZnVsbFJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICBpZiAodGV4dERlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb24udW5pZmllZDtcbiAgICAgICAgICAgICAgICAgIHVzYWdlID0gYXNMYW5ndWFnZU1vZGVsVXNhZ2UoY2h1bmsudXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBmdWxsUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgbG9nV2FybmluZ3Moe1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MgIT0gbnVsbCA/IHdhcm5pbmdzIDogW10sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fdXNhZ2UucmVzb2x2ZSh1c2FnZSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9wcm92aWRlck1ldGFkYXRhLnJlc29sdmUocHJvdmlkZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl93YXJuaW5ncy5yZXNvbHZlKHdhcm5pbmdzKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3Jlc3BvbnNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5mdWxsUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbmlzaFJlYXNvbi5yZXNvbHZlKGZpbmlzaFJlYXNvbiAhPSBudWxsID8gZmluaXNoUmVhc29uIDogXCJvdGhlclwiKTtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDIgPSBhd2FpdCBwYXJzZUFuZFZhbGlkYXRlT2JqZWN0UmVzdWx0V2l0aFJlcGFpcihcbiAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICAgcmVwYWlyVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX29iamVjdC5yZXNvbHZlKG9iamVjdDIpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX29iamVjdC5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFVzYWdlID0gdXNhZ2UgIT0gbnVsbCA/IHVzYWdlIDoge1xuICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogTmFOXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QyKVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiBmdWxsUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiBmdWxsUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiBmdWxsUmVzcG9uc2UudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KHByb3ZpZGVyTWV0YWRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IGZpbmFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogZmluYWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiBmdWxsUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogZnVsbFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IGZpbmFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLm91dHB1dFRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5pbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2Uub3V0cHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG90YWxUb2tlbnNcIjogZmluYWxVc2FnZS50b3RhbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnJlYXNvbmluZ1Rva2Vuc1wiOiBmaW5hbFVzYWdlLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNhY2hlZElucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QyKVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KHByb3ZpZGVyTWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBmaW5hbFVzYWdlLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QyLFxuICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5mdWxsUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBlcnJvcjIgfSk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcm9vdFNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBzdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbSh0cmFuc2Zvcm1lZFN0cmVhbSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbShcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBzdGl0Y2hhYmxlU3RyZWFtLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5vdXRwdXRTdHJhdGVneSA9IG91dHB1dFN0cmF0ZWd5O1xuICB9XG4gIGdldCBvYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdC5wcm9taXNlO1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNhZ2UucHJvbWlzZTtcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJNZXRhZGF0YS5wcm9taXNlO1xuICB9XG4gIGdldCB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fd2FybmluZ3MucHJvbWlzZTtcbiAgfVxuICBnZXQgcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdC5wcm9taXNlO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UucHJvbWlzZTtcbiAgfVxuICBnZXQgZmluaXNoUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hSZWFzb24ucHJvbWlzZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5vYmplY3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGVsZW1lbnRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RyYXRlZ3kuY3JlYXRlRWxlbWVudFN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy5iYXNlU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHRleHRTdHJlYW06IHRoaXMudGV4dFN0cmVhbSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSh7XG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGUtc3BlZWNoLnRzXG5pbXBvcnQgeyB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXg3IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZWQtYXVkaW8tZmlsZS50c1xudmFyIERlZmF1bHRHZW5lcmF0ZWRBdWRpb0ZpbGUgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRHZW5lcmF0ZWRGaWxlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVkaWFUeXBlXG4gIH0pIHtcbiAgICBzdXBlcih7IGRhdGEsIG1lZGlhVHlwZSB9KTtcbiAgICBsZXQgZm9ybWF0ID0gXCJtcDNcIjtcbiAgICBpZiAobWVkaWFUeXBlKSB7XG4gICAgICBjb25zdCBtZWRpYVR5cGVQYXJ0cyA9IG1lZGlhVHlwZS5zcGxpdChcIi9cIik7XG4gICAgICBpZiAobWVkaWFUeXBlUGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmIChtZWRpYVR5cGUgIT09IFwiYXVkaW8vbXBlZ1wiKSB7XG4gICAgICAgICAgZm9ybWF0ID0gbWVkaWFUeXBlUGFydHNbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJBdWRpbyBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBvciBkZXRlcm1pbmFibGUgZnJvbSBtZWRpYSB0eXBlXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtc3BlZWNoL2dlbmVyYXRlLXNwZWVjaC50c1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTcGVlY2goe1xuICBtb2RlbCxcbiAgdGV4dDogdGV4dDIsXG4gIHZvaWNlLFxuICBvdXRwdXRGb3JtYXQsXG4gIGluc3RydWN0aW9ucyxcbiAgc3BlZWQsXG4gIGxhbmd1YWdlLFxuICBwcm92aWRlck9wdGlvbnMgPSB7fSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IHJlc29sdmVkTW9kZWwgPSByZXNvbHZlU3BlZWNoTW9kZWwobW9kZWwpO1xuICBpZiAoIXJlc29sdmVkTW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBjb3VsZCBub3QgYmUgcmVzb2x2ZWRcIik7XG4gIH1cbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4NyhcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IHsgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiByZXNvbHZlZE1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgdGV4dDogdGV4dDIsXG4gICAgICB2b2ljZSxcbiAgICAgIG91dHB1dEZvcm1hdCxcbiAgICAgIGluc3RydWN0aW9ucyxcbiAgICAgIHNwZWVkLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgfSlcbiAgKTtcbiAgaWYgKCFyZXN1bHQuYXVkaW8gfHwgcmVzdWx0LmF1ZGlvLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBOb1NwZWVjaEdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSB9KTtcbiAgfVxuICBsb2dXYXJuaW5ncyh7XG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICBwcm92aWRlcjogcmVzb2x2ZWRNb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbDogcmVzb2x2ZWRNb2RlbC5tb2RlbElkXG4gIH0pO1xuICByZXR1cm4gbmV3IERlZmF1bHRTcGVlY2hSZXN1bHQoe1xuICAgIGF1ZGlvOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEF1ZGlvRmlsZSh7XG4gICAgICBkYXRhOiByZXN1bHQuYXVkaW8sXG4gICAgICBtZWRpYVR5cGU6IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgIH0pKSAhPSBudWxsID8gX2ExNyA6IFwiYXVkaW8vbXAzXCJcbiAgICB9KSxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0sXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgfSk7XG59XG52YXIgRGVmYXVsdFNwZWVjaFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge307XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3BydW5lLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBwcnVuZU1lc3NhZ2VzKHtcbiAgbWVzc2FnZXMsXG4gIHJlYXNvbmluZyA9IFwibm9uZVwiLFxuICB0b29sQ2FsbHMgPSBbXSxcbiAgZW1wdHlNZXNzYWdlcyA9IFwicmVtb3ZlXCJcbn0pIHtcbiAgaWYgKHJlYXNvbmluZyA9PT0gXCJhbGxcIiB8fCByZWFzb25pbmcgPT09IFwiYmVmb3JlLWxhc3QtbWVzc2FnZVwiKSB7XG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UsIG1lc3NhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIiB8fCB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiIHx8IHJlYXNvbmluZyA9PT0gXCJiZWZvcmUtbGFzdC1tZXNzYWdlXCIgJiYgbWVzc2FnZUluZGV4ID09PSBtZXNzYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlICE9PSBcInJlYXNvbmluZ1wiKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBpZiAodG9vbENhbGxzID09PSBcIm5vbmVcIikge1xuICAgIHRvb2xDYWxscyA9IFtdO1xuICB9IGVsc2UgaWYgKHRvb2xDYWxscyA9PT0gXCJhbGxcIikge1xuICAgIHRvb2xDYWxscyA9IFt7IHR5cGU6IFwiYWxsXCIgfV07XG4gIH0gZWxzZSBpZiAodG9vbENhbGxzID09PSBcImJlZm9yZS1sYXN0LW1lc3NhZ2VcIikge1xuICAgIHRvb2xDYWxscyA9IFt7IHR5cGU6IFwiYmVmb3JlLWxhc3QtbWVzc2FnZVwiIH1dO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0b29sQ2FsbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0b29sQ2FsbHMgPSBbeyB0eXBlOiB0b29sQ2FsbHMgfV07XG4gIH1cbiAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiB0b29sQ2FsbHMpIHtcbiAgICBjb25zdCBrZWVwTGFzdE1lc3NhZ2VzQ291bnQgPSB0b29sQ2FsbC50eXBlID09PSBcImFsbFwiID8gdm9pZCAwIDogdG9vbENhbGwudHlwZSA9PT0gXCJiZWZvcmUtbGFzdC1tZXNzYWdlXCIgPyAxIDogTnVtYmVyKFxuICAgICAgdG9vbENhbGwudHlwZS5zbGljZShcImJlZm9yZS1sYXN0LVwiLmxlbmd0aCkuc2xpY2UoMCwgLVwiLW1lc3NhZ2VzXCIubGVuZ3RoKVxuICAgICk7XG4gICAgY29uc3Qga2VwdFRvb2xDYWxsSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBrZXB0QXBwcm92YWxJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGlmIChrZWVwTGFzdE1lc3NhZ2VzQ291bnQgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzLnNsaWNlKC1rZWVwTGFzdE1lc3NhZ2VzQ291bnQpKSB7XG4gICAgICAgIGlmICgobWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiIHx8IG1lc3NhZ2Uucm9sZSA9PT0gXCJ0b29sXCIpICYmIHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKSB7XG4gICAgICAgICAgICAgIGtlcHRUb29sQ2FsbElkcy5hZGQocGFydC50b29sQ2FsbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIpIHtcbiAgICAgICAgICAgICAga2VwdEFwcHJvdmFsSWRzLmFkZChwYXJ0LmFwcHJvdmFsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZSwgbWVzc2FnZUluZGV4KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiICYmIG1lc3NhZ2Uucm9sZSAhPT0gXCJ0b29sXCIgfHwgdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIiB8fCBrZWVwTGFzdE1lc3NhZ2VzQ291bnQgJiYgbWVzc2FnZUluZGV4ID49IG1lc3NhZ2VzLmxlbmd0aCAtIGtlZXBMYXN0TWVzc2FnZXNDb3VudCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvb2xDYWxsSWRUb1Rvb2xOYW1lID0ge307XG4gICAgICBjb25zdCBhcHByb3ZhbElkVG9Ub29sTmFtZSA9IHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcigocGFydCkgPT4ge1xuICAgICAgICAgIGlmIChwYXJ0LnR5cGUgIT09IFwidG9vbC1jYWxsXCIgJiYgcGFydC50eXBlICE9PSBcInRvb2wtcmVzdWx0XCIgJiYgcGFydC50eXBlICE9PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiICYmIHBhcnQudHlwZSAhPT0gXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiKSB7XG4gICAgICAgICAgICB0b29sQ2FsbElkVG9Ub29sTmFtZVtwYXJ0LnRvb2xDYWxsSWRdID0gcGFydC50b29sTmFtZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIikge1xuICAgICAgICAgICAgYXBwcm92YWxJZFRvVG9vbE5hbWVbcGFydC5hcHByb3ZhbElkXSA9IHRvb2xDYWxsSWRUb1Rvb2xOYW1lW3BhcnQudG9vbENhbGxJZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgocGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKSAmJiBrZXB0VG9vbENhbGxJZHMuaGFzKHBhcnQudG9vbENhbGxJZCkgfHwgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSAmJiBrZXB0QXBwcm92YWxJZHMuaGFzKHBhcnQuYXBwcm92YWxJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9vbENhbGwudG9vbHMgIT0gbnVsbCAmJiAhdG9vbENhbGwudG9vbHMuaW5jbHVkZXMoXG4gICAgICAgICAgICBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgPyBwYXJ0LnRvb2xOYW1lIDogYXBwcm92YWxJZFRvVG9vbE5hbWVbcGFydC5hcHByb3ZhbElkXVxuICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGlmIChlbXB0eU1lc3NhZ2VzID09PSBcInJlbW92ZVwiKSB7XG4gICAgbWVzc2FnZXMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudC5sZW5ndGggPiAwKTtcbiAgfVxuICByZXR1cm4gbWVzc2FnZXM7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3Ntb290aC1zdHJlYW0udHNcbmltcG9ydCB7IGRlbGF5IGFzIG9yaWdpbmFsRGVsYXkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgYXMgSW52YWxpZEFyZ3VtZW50RXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBDSFVOS0lOR19SRUdFWFBTID0ge1xuICB3b3JkOiAvXFxTK1xccysvbSxcbiAgbGluZTogL1xcbisvbVxufTtcbmZ1bmN0aW9uIHNtb290aFN0cmVhbSh7XG4gIGRlbGF5SW5NcyA9IDEwLFxuICBjaHVua2luZyA9IFwid29yZFwiLFxuICBfaW50ZXJuYWw6IHsgZGVsYXk6IGRlbGF5MiA9IG9yaWdpbmFsRGVsYXkgfSA9IHt9XG59ID0ge30pIHtcbiAgbGV0IGRldGVjdENodW5rO1xuICBpZiAoY2h1bmtpbmcgIT0gbnVsbCAmJiB0eXBlb2YgY2h1bmtpbmcgPT09IFwib2JqZWN0XCIgJiYgXCJzZWdtZW50XCIgaW4gY2h1bmtpbmcgJiYgdHlwZW9mIGNodW5raW5nLnNlZ21lbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNlZ21lbnRlciA9IGNodW5raW5nO1xuICAgIGRldGVjdENodW5rID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSBzZWdtZW50ZXIuc2VnbWVudChidWZmZXIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIChmaXJzdCA9PSBudWxsID8gdm9pZCAwIDogZmlyc3Quc2VnbWVudCkgfHwgbnVsbDtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVua2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNodW5raW5nKGJ1ZmZlcik7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBub24tZW1wdHkgc3RyaW5nLmApO1xuICAgICAgfVxuICAgICAgaWYgKCFidWZmZXIuc3RhcnRzV2l0aChtYXRjaCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDaHVua2luZyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIG1hdGNoIHRoYXQgaXMgYSBwcmVmaXggb2YgdGhlIGJ1ZmZlci4gUmVjZWl2ZWQ6IFwiJHttYXRjaH1cIiBleHBlY3RlZCB0byBzdGFydCB3aXRoIFwiJHtidWZmZXJ9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaHVua2luZ1JlZ2V4ID0gdHlwZW9mIGNodW5raW5nID09PSBcInN0cmluZ1wiID8gQ0hVTktJTkdfUkVHRVhQU1tjaHVua2luZ10gOiBjaHVua2luZyBpbnN0YW5jZW9mIFJlZ0V4cCA/IGNodW5raW5nIDogdm9pZCAwO1xuICAgIGlmIChjaHVua2luZ1JlZ2V4ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcjIoe1xuICAgICAgICBhcmd1bWVudDogXCJjaHVua2luZ1wiLFxuICAgICAgICBtZXNzYWdlOiBgQ2h1bmtpbmcgbXVzdCBiZSBcIndvcmRcIiwgXCJsaW5lXCIsIGEgUmVnRXhwLCBhbiBJbnRsLlNlZ21lbnRlciwgb3IgYSBDaHVua0RldGVjdG9yIGZ1bmN0aW9uLiBSZWNlaXZlZDogJHtjaHVua2luZ31gXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNodW5raW5nUmVnZXguZXhlYyhidWZmZXIpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaFswXSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgIGxldCBpZCA9IFwiXCI7XG4gICAgbGV0IHR5cGUgPSB2b2lkIDA7XG4gICAgbGV0IHByb3ZpZGVyTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gZmx1c2hCdWZmZXIoY29udHJvbGxlcikge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwICYmIHR5cGUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdGV4dDogYnVmZmVyLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIC4uLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudHlwZSAhPT0gXCJyZWFzb25pbmctZGVsdGFcIikge1xuICAgICAgICAgIGZsdXNoQnVmZmVyKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY2h1bmsudHlwZSAhPT0gdHlwZSB8fCBjaHVuay5pZCAhPT0gaWQpICYmIGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmx1c2hCdWZmZXIoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyICs9IGNodW5rLnRleHQ7XG4gICAgICAgIGlkID0gY2h1bmsuaWQ7XG4gICAgICAgIHR5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICBpZiAoY2h1bmsucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gZGV0ZWN0Q2h1bmsoYnVmZmVyKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGUsIHRleHQ6IG1hdGNoLCBpZCB9KTtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICBhd2FpdCBkZWxheTIoZGVsYXlJbk1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9kZWZhdWx0LWVtYmVkZGluZy1zZXR0aW5ncy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0RW1iZWRkaW5nU2V0dGluZ3NNaWRkbGV3YXJlKHtcbiAgc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHJldHVybiBtZXJnZU9iamVjdHMoc2V0dGluZ3MsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9kZWZhdWx0LXNldHRpbmdzLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUoe1xuICBzZXR0aW5nc1xufSkge1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgdHJhbnNmb3JtUGFyYW1zOiBhc3luYyAoeyBwYXJhbXMgfSkgPT4ge1xuICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhzZXR0aW5ncywgcGFyYW1zKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlL2V4dHJhY3QtanNvbi1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKHRleHQyKSB7XG4gIHJldHVybiB0ZXh0Mi5yZXBsYWNlKC9eYGBgKD86anNvbik/XFxzKlxcbj8vLCBcIlwiKS5yZXBsYWNlKC9cXG4/YGBgXFxzKiQvLCBcIlwiKS50cmltKCk7XG59XG5mdW5jdGlvbiBleHRyYWN0SnNvbk1pZGRsZXdhcmUob3B0aW9ucykge1xuICB2YXIgX2ExNztcbiAgY29uc3QgdHJhbnNmb3JtID0gKF9hMTcgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgIT0gbnVsbCA/IF9hMTcgOiBkZWZhdWx0VHJhbnNmb3JtO1xuICBjb25zdCBoYXNDdXN0b21UcmFuc2Zvcm0gPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSB2b2lkIDA7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICB3cmFwR2VuZXJhdGU6IGFzeW5jICh7IGRvR2VuZXJhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBjb250ZW50LCAuLi5yZXN0IH0gPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZENvbnRlbnQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2goe1xuICAgICAgICAgIC4uLnBhcnQsXG4gICAgICAgICAgdGV4dDogdHJhbnNmb3JtKHBhcnQudGV4dClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjb250ZW50OiB0cmFuc2Zvcm1lZENvbnRlbnQsIC4uLnJlc3QgfTtcbiAgICB9LFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvU3RyZWFtIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgc3RyZWFtLCAuLi5yZXN0IH0gPSBhd2FpdCBkb1N0cmVhbSgpO1xuICAgICAgY29uc3QgdGV4dEJsb2NrcyA9IHt9O1xuICAgICAgY29uc3QgU1VGRklYX0JVRkZFUl9TSVpFID0gMTI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtc3RhcnRcIikge1xuICAgICAgICAgICAgICAgIHRleHRCbG9ja3NbY2h1bmsuaWRdID0ge1xuICAgICAgICAgICAgICAgICAgc3RhcnRFdmVudDogY2h1bmssXG4gICAgICAgICAgICAgICAgICAvLyBDdXN0b20gdHJhbnNmb3JtcyBuZWVkIHRvIGJ1ZmZlciBhbGwgY29udGVudFxuICAgICAgICAgICAgICAgICAgcGhhc2U6IGhhc0N1c3RvbVRyYW5zZm9ybSA/IFwiYnVmZmVyaW5nXCIgOiBcInByZWZpeFwiLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgcHJlZml4U3RyaXBwZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0ZXh0QmxvY2tzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9jay5idWZmZXIgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrLnBoYXNlID09PSBcImJ1ZmZlcmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJwcmVmaXhcIikge1xuICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrLmJ1ZmZlci5sZW5ndGggPiAwICYmICFibG9jay5idWZmZXIuc3RhcnRzV2l0aChcImBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sucGhhc2UgPSBcInN0cmVhbWluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYmxvY2suc3RhcnRFdmVudCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmJ1ZmZlci5zdGFydHNXaXRoKFwiYGBgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jay5idWZmZXIuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhNYXRjaCA9IGJsb2NrLmJ1ZmZlci5tYXRjaCgvXmBgYCg/Ompzb24pP1xccypcXG4vKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZml4TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLmJ1ZmZlciA9IGJsb2NrLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4TWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sucHJlZml4U3RyaXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sucGhhc2UgPSBcInN0cmVhbWluZ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5waGFzZSA9IFwic3RyZWFtaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYmxvY2suc3RhcnRFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmJ1ZmZlci5sZW5ndGggPj0gMyAmJiAhYmxvY2suYnVmZmVyLnN0YXJ0c1dpdGgoXCJgYGBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sucGhhc2UgPSBcInN0cmVhbWluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYmxvY2suc3RhcnRFdmVudCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJzdHJlYW1pbmdcIiAmJiBibG9jay5idWZmZXIubGVuZ3RoID4gU1VGRklYX0JVRkZFUl9TSVpFKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0b1N0cmVhbSA9IGJsb2NrLmJ1ZmZlci5zbGljZSgwLCAtU1VGRklYX0JVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgICAgICAgIGJsb2NrLmJ1ZmZlciA9IGJsb2NrLmJ1ZmZlci5zbGljZSgtU1VGRklYX0JVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhOiB0b1N0cmVhbVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0ZXh0QmxvY2tzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJwcmVmaXhcIiB8fCBibG9jay5waGFzZSA9PT0gXCJidWZmZXJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYmxvY2suc3RhcnRFdmVudCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gYmxvY2suYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrLnBoYXNlID09PSBcImJ1ZmZlcmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHRyYW5zZm9ybShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5wcmVmaXhTdHJpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcucmVwbGFjZSgvXFxuP2BgYFxccyokLywgXCJcIikudHJpbUVuZCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gdHJhbnNmb3JtKHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGV4dEJsb2Nrc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlsL2dldC1wb3RlbnRpYWwtc3RhcnQtaW5kZXgudHNcbmZ1bmN0aW9uIGdldFBvdGVudGlhbFN0YXJ0SW5kZXgodGV4dDIsIHNlYXJjaGVkVGV4dCkge1xuICBpZiAoc2VhcmNoZWRUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRpcmVjdEluZGV4ID0gdGV4dDIuaW5kZXhPZihzZWFyY2hlZFRleHQpO1xuICBpZiAoZGlyZWN0SW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIGRpcmVjdEluZGV4O1xuICB9XG4gIGZvciAobGV0IGkgPSB0ZXh0Mi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN1ZmZpeCA9IHRleHQyLnN1YnN0cmluZyhpKTtcbiAgICBpZiAoc2VhcmNoZWRUZXh0LnN0YXJ0c1dpdGgoc3VmZml4KSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9leHRyYWN0LXJlYXNvbmluZy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVhc29uaW5nTWlkZGxld2FyZSh7XG4gIHRhZ05hbWUsXG4gIHNlcGFyYXRvciA9IFwiXFxuXCIsXG4gIHN0YXJ0V2l0aFJlYXNvbmluZyA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IG9wZW5pbmdUYWcgPSBgPCR7dGFnTmFtZX0+YDtcbiAgY29uc3QgY2xvc2luZ1RhZyA9IGA8LyR7dGFnTmFtZX0+YDtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHdyYXBHZW5lcmF0ZTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIC4uLnJlc3QgfSA9IGF3YWl0IGRvR2VuZXJhdGUoKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQ29udGVudCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0MiA9IHN0YXJ0V2l0aFJlYXNvbmluZyA/IG9wZW5pbmdUYWcgKyBwYXJ0LnRleHQgOiBwYXJ0LnRleHQ7XG4gICAgICAgIGNvbnN0IHJlZ2V4cCA9IG5ldyBSZWdFeHAoYCR7b3BlbmluZ1RhZ30oLio/KSR7Y2xvc2luZ1RhZ31gLCBcImdzXCIpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0ZXh0Mi5tYXRjaEFsbChyZWdleHApKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYXNvbmluZ1RleHQgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoWzFdKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGxldCB0ZXh0V2l0aG91dFJlYXNvbmluZyA9IHRleHQyO1xuICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICBjb25zdCBiZWZvcmVNYXRjaCA9IHRleHRXaXRob3V0UmVhc29uaW5nLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBhZnRlck1hdGNoID0gdGV4dFdpdGhvdXRSZWFzb25pbmcuc2xpY2UoXG4gICAgICAgICAgICBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSBiZWZvcmVNYXRjaCArIChiZWZvcmVNYXRjaC5sZW5ndGggPiAwICYmIGFmdGVyTWF0Y2gubGVuZ3RoID4gMCA/IHNlcGFyYXRvciA6IFwiXCIpICsgYWZ0ZXJNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiByZWFzb25pbmdUZXh0XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogdGV4dFdpdGhvdXRSZWFzb25pbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjb250ZW50OiB0cmFuc2Zvcm1lZENvbnRlbnQsIC4uLnJlc3QgfTtcbiAgICB9LFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvU3RyZWFtIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgc3RyZWFtLCAuLi5yZXN0IH0gPSBhd2FpdCBkb1N0cmVhbSgpO1xuICAgICAgY29uc3QgcmVhc29uaW5nRXh0cmFjdGlvbnMgPSB7fTtcbiAgICAgIGxldCBkZWxheWVkVGV4dFN0YXJ0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZW5kXCIgJiYgZGVsYXllZFRleHRTdGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWxheWVkVGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdFeHRyYWN0aW9uc1tjaHVuay5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ0V4dHJhY3Rpb25zW2NodW5rLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgIGlzRmlyc3RSZWFzb25pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICBpc0ZpcnN0VGV4dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGFmdGVyU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGlzUmVhc29uaW5nOiBzdGFydFdpdGhSZWFzb25pbmcsXG4gICAgICAgICAgICAgICAgICBidWZmZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBpZENvdW50ZXI6IDAsXG4gICAgICAgICAgICAgICAgICB0ZXh0SWQ6IGNodW5rLmlkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVFeHRyYWN0aW9uID0gcmVhc29uaW5nRXh0cmFjdGlvbnNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciArPSBjaHVuay5kZWx0YTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcHVibGlzaCh0ZXh0Mikge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBhY3RpdmVFeHRyYWN0aW9uLmFmdGVyU3dpdGNoICYmIChhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nID8gIWFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZyA6ICFhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RUZXh0KSA/IHNlcGFyYXRvciA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyAmJiAoYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCB8fCBhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RSZWFzb25pbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyfWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHByZWZpeCArIHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBgcmVhc29uaW5nLSR7YWN0aXZlRXh0cmFjdGlvbi5pZENvdW50ZXJ9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxheWVkVGV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRlbGF5ZWRUZXh0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ZWRUZXh0U3RhcnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogcHJlZml4ICsgdGV4dDIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGFjdGl2ZUV4dHJhY3Rpb24udGV4dElkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0UmVhc29uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFnID0gYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA/IGNsb3NpbmdUYWcgOiBvcGVuaW5nVGFnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBnZXRQb3RlbnRpYWxTdGFydEluZGV4KFxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIsXG4gICAgICAgICAgICAgICAgICBuZXh0VGFnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwdWJsaXNoKGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdWJsaXNoKGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKDAsIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZEZ1bGxNYXRjaCA9IHN0YXJ0SW5kZXggKyBuZXh0VGFnLmxlbmd0aCA8PSBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kRnVsbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBgcmVhc29uaW5nLSR7YWN0aXZlRXh0cmFjdGlvbi5pZENvdW50ZXIrK31gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA9ICFhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nO1xuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyID0gYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIuc2xpY2Uoc3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9zaW11bGF0ZS1zdHJlYW1pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlKCkge1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgd3JhcFN0cmVhbTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBsZXQgaWQgPSAwO1xuICAgICAgY29uc3Qgc2ltdWxhdGVkU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmVhbS1zdGFydFwiLFxuICAgICAgICAgICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5nc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIiwgLi4ucmVzdWx0LnJlc3BvbnNlIH0pO1xuICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiByZXN1bHQuY29udGVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LXN0YXJ0XCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1lbmRcIiwgaWQ6IFN0cmluZyhpZCkgfSk7XG4gICAgICAgICAgICAgICAgICBpZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlYXNvbmluZy1lbmRcIiwgaWQ6IFN0cmluZyhpZCkgfSk7XG4gICAgICAgICAgICAgICAgaWQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHJlc3VsdC51c2FnZSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc2ltdWxhdGVkU3RyZWFtLFxuICAgICAgICByZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXNwb25zZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlL2FkZC10b29sLWlucHV0LWV4YW1wbGVzLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGRlZmF1bHRGb3JtYXRFeGFtcGxlKGV4YW1wbGUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGV4YW1wbGUuaW5wdXQpO1xufVxuZnVuY3Rpb24gYWRkVG9vbElucHV0RXhhbXBsZXNNaWRkbGV3YXJlKHtcbiAgcHJlZml4ID0gXCJJbnB1dCBFeGFtcGxlczpcIixcbiAgZm9ybWF0ID0gZGVmYXVsdEZvcm1hdEV4YW1wbGUsXG4gIHJlbW92ZSA9IHRydWVcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgdHJhbnNmb3JtUGFyYW1zOiBhc3luYyAoeyBwYXJhbXMgfSkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAoISgoX2ExNyA9IHBhcmFtcy50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtZWRUb29scyA9IHBhcmFtcy50b29scy5tYXAoKHRvb2wyKSA9PiB7XG4gICAgICAgIHZhciBfYTE4O1xuICAgICAgICBpZiAodG9vbDIudHlwZSAhPT0gXCJmdW5jdGlvblwiIHx8ICEoKF9hMTggPSB0b29sMi5pbnB1dEV4YW1wbGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC5sZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRvb2wyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZEV4YW1wbGVzID0gdG9vbDIuaW5wdXRFeGFtcGxlcy5tYXAoKGV4YW1wbGUsIGluZGV4KSA9PiBmb3JtYXQoZXhhbXBsZSwgaW5kZXgpKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBjb25zdCBleGFtcGxlc1NlY3Rpb24gPSBgJHtwcmVmaXh9XG4ke2Zvcm1hdHRlZEV4YW1wbGVzfWA7XG4gICAgICAgIGNvbnN0IHRvb2xEZXNjcmlwdGlvbiA9IHRvb2wyLmRlc2NyaXB0aW9uID8gYCR7dG9vbDIuZGVzY3JpcHRpb259XG5cbiR7ZXhhbXBsZXNTZWN0aW9ufWAgOiBleGFtcGxlc1NlY3Rpb247XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udG9vbDIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRvb2xEZXNjcmlwdGlvbixcbiAgICAgICAgICBpbnB1dEV4YW1wbGVzOiByZW1vdmUgPyB2b2lkIDAgOiB0b29sMi5pbnB1dEV4YW1wbGVzXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgdG9vbHM6IHRyYW5zZm9ybWVkVG9vbHNcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS93cmFwLWxhbmd1YWdlLW1vZGVsLnRzXG52YXIgd3JhcExhbmd1YWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gWy4uLmFzQXJyYXkobWlkZGxld2FyZUFyZyldLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAoeyBtb2RlbDogd3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlLCBtb2RlbElkLCBwcm92aWRlcklkIH0pO1xuICB9LCBtb2RlbCk7XG59O1xudmFyIGRvV3JhcCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiB7XG4gICAgdHJhbnNmb3JtUGFyYW1zLFxuICAgIHdyYXBHZW5lcmF0ZSxcbiAgICB3cmFwU3RyZWFtLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlU3VwcG9ydGVkVXJsc1xuICB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTE3LCBfYiwgX2M7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSwgbW9kZWwgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHByb3ZpZGVyOiAoX2ExNyA9IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBvdmVycmlkZVByb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVByb3ZpZGVyKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYTE3IDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogKF9iID0gbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG92ZXJyaWRlTW9kZWxJZCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNb2RlbElkKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgc3VwcG9ydGVkVXJsczogKF9jID0gb3ZlcnJpZGVTdXBwb3J0ZWRVcmxzID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVN1cHBvcnRlZFVybHMoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEdlbmVyYXRlID8gd3JhcEdlbmVyYXRlKHtcbiAgICAgICAgZG9HZW5lcmF0ZSxcbiAgICAgICAgZG9TdHJlYW0sXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIGRvU3RyZWFtKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJzdHJlYW1cIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBTdHJlYW0gPyB3cmFwU3RyZWFtKHsgZG9HZW5lcmF0ZSwgZG9TdHJlYW0sIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9TdHJlYW0oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS93cmFwLWVtYmVkZGluZy1tb2RlbC50c1xudmFyIHdyYXBFbWJlZGRpbmdNb2RlbCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlQXJnLFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHJldHVybiBbLi4uYXNBcnJheShtaWRkbGV3YXJlQXJnKV0ucmV2ZXJzZSgpLnJlZHVjZSgod3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlKSA9PiB7XG4gICAgcmV0dXJuIGRvV3JhcDIoeyBtb2RlbDogd3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlLCBtb2RlbElkLCBwcm92aWRlcklkIH0pO1xuICB9LCBtb2RlbCk7XG59O1xudmFyIGRvV3JhcDIgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZToge1xuICAgIHRyYW5zZm9ybVBhcmFtcyxcbiAgICB3cmFwRW1iZWQsXG4gICAgb3ZlcnJpZGVQcm92aWRlcixcbiAgICBvdmVycmlkZU1vZGVsSWQsXG4gICAgb3ZlcnJpZGVNYXhFbWJlZGRpbmdzUGVyQ2FsbCxcbiAgICBvdmVycmlkZVN1cHBvcnRzUGFyYWxsZWxDYWxsc1xuICB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICBhc3luYyBmdW5jdGlvbiBkb1RyYW5zZm9ybSh7XG4gICAgcGFyYW1zXG4gIH0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zID8gYXdhaXQgdHJhbnNmb3JtUGFyYW1zKHsgcGFyYW1zLCBtb2RlbCB9KSA6IHBhcmFtcztcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgcHJvdmlkZXI6IChfYTE3ID0gcHJvdmlkZXJJZCAhPSBudWxsID8gcHJvdmlkZXJJZCA6IG92ZXJyaWRlUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlUHJvdmlkZXIoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9hMTcgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiAoX2IgPSBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogb3ZlcnJpZGVNb2RlbElkID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZU1vZGVsSWQoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9iIDogbW9kZWwubW9kZWxJZCxcbiAgICBtYXhFbWJlZGRpbmdzUGVyQ2FsbDogKF9jID0gb3ZlcnJpZGVNYXhFbWJlZGRpbmdzUGVyQ2FsbCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNYXhFbWJlZGRpbmdzUGVyQ2FsbCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2MgOiBtb2RlbC5tYXhFbWJlZGRpbmdzUGVyQ2FsbCxcbiAgICBzdXBwb3J0c1BhcmFsbGVsQ2FsbHM6IChfZCA9IG92ZXJyaWRlU3VwcG9ydHNQYXJhbGxlbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVN1cHBvcnRzUGFyYWxsZWxDYWxscyh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2QgOiBtb2RlbC5zdXBwb3J0c1BhcmFsbGVsQ2FsbHMsXG4gICAgYXN5bmMgZG9FbWJlZChwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMgfSk7XG4gICAgICBjb25zdCBkb0VtYmVkID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9FbWJlZCh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEVtYmVkID8gd3JhcEVtYmVkKHtcbiAgICAgICAgZG9FbWJlZCxcbiAgICAgICAgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcyxcbiAgICAgICAgbW9kZWxcbiAgICAgIH0pIDogZG9FbWJlZCgpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9taWRkbGV3YXJlL3dyYXAtaW1hZ2UtbW9kZWwudHNcbnZhciB3cmFwSW1hZ2VNb2RlbCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlQXJnLFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHJldHVybiBbLi4uYXNBcnJheShtaWRkbGV3YXJlQXJnKV0ucmV2ZXJzZSgpLnJlZHVjZSgod3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlKSA9PiB7XG4gICAgcmV0dXJuIGRvV3JhcDMoeyBtb2RlbDogd3JhcHBlZE1vZGVsLCBtaWRkbGV3YXJlLCBtb2RlbElkLCBwcm92aWRlcklkIH0pO1xuICB9LCBtb2RlbCk7XG59O1xudmFyIGRvV3JhcDMgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZToge1xuICAgIHRyYW5zZm9ybVBhcmFtcyxcbiAgICB3cmFwR2VuZXJhdGUsXG4gICAgb3ZlcnJpZGVQcm92aWRlcixcbiAgICBvdmVycmlkZU1vZGVsSWQsXG4gICAgb3ZlcnJpZGVNYXhJbWFnZXNQZXJDYWxsXG4gIH0sXG4gIG1vZGVsSWQsXG4gIHByb3ZpZGVySWRcbn0pID0+IHtcbiAgdmFyIF9hMTcsIF9iLCBfYztcbiAgYXN5bmMgZnVuY3Rpb24gZG9UcmFuc2Zvcm0oeyBwYXJhbXMgfSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYXJhbXMgPyBhd2FpdCB0cmFuc2Zvcm1QYXJhbXMoeyBwYXJhbXMsIG1vZGVsIH0pIDogcGFyYW1zO1xuICB9XG4gIGNvbnN0IG1heEltYWdlc1BlckNhbGxSYXcgPSAoX2ExNyA9IG92ZXJyaWRlTWF4SW1hZ2VzUGVyQ2FsbCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNYXhJbWFnZXNQZXJDYWxsKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYTE3IDogbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbDtcbiAgY29uc3QgbWF4SW1hZ2VzUGVyQ2FsbCA9IG1heEltYWdlc1BlckNhbGxSYXcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IG1heEltYWdlc1BlckNhbGxSYXcuYmluZChtb2RlbCkgOiBtYXhJbWFnZXNQZXJDYWxsUmF3O1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgcHJvdmlkZXI6IChfYiA9IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBvdmVycmlkZVByb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVByb3ZpZGVyKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYiA6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IChfYyA9IG1vZGVsSWQgIT0gbnVsbCA/IG1vZGVsSWQgOiBvdmVycmlkZU1vZGVsSWQgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTW9kZWxJZCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2MgOiBtb2RlbC5tb2RlbElkLFxuICAgIG1heEltYWdlc1BlckNhbGwsXG4gICAgYXN5bmMgZG9HZW5lcmF0ZShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMgfSk7XG4gICAgICBjb25zdCBkb0dlbmVyYXRlID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEdlbmVyYXRlID8gd3JhcEdlbmVyYXRlKHtcbiAgICAgICAgZG9HZW5lcmF0ZSxcbiAgICAgICAgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcyxcbiAgICAgICAgbW9kZWxcbiAgICAgIH0pIDogZG9HZW5lcmF0ZSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9tb2RlbC9hcy1wcm92aWRlci12My50c1xuZnVuY3Rpb24gYXNQcm92aWRlclYzKHByb3ZpZGVyKSB7XG4gIGlmIChcInNwZWNpZmljYXRpb25WZXJzaW9uXCIgaW4gcHJvdmlkZXIgJiYgcHJvdmlkZXIuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBjb25zdCB2MlByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBsYW5ndWFnZU1vZGVsOiAobW9kZWxJZCkgPT4gYXNMYW5ndWFnZU1vZGVsVjModjJQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpKSxcbiAgICBlbWJlZGRpbmdNb2RlbDogKG1vZGVsSWQpID0+IGFzRW1iZWRkaW5nTW9kZWxWMyh2MlByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKSksXG4gICAgaW1hZ2VNb2RlbDogKG1vZGVsSWQpID0+IGFzSW1hZ2VNb2RlbFYzKHYyUHJvdmlkZXIuaW1hZ2VNb2RlbChtb2RlbElkKSksXG4gICAgdHJhbnNjcmlwdGlvbk1vZGVsOiB2MlByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbCA/IChtb2RlbElkKSA9PiBhc1RyYW5zY3JpcHRpb25Nb2RlbFYzKHYyUHJvdmlkZXIudHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsSWQpKSA6IHZvaWQgMCxcbiAgICBzcGVlY2hNb2RlbDogdjJQcm92aWRlci5zcGVlY2hNb2RlbCA/IChtb2RlbElkKSA9PiBhc1NwZWVjaE1vZGVsVjModjJQcm92aWRlci5zcGVlY2hNb2RlbChtb2RlbElkKSkgOiB2b2lkIDAsXG4gICAgcmVyYW5raW5nTW9kZWw6IHZvaWQgMFxuICAgIC8vIHYyIHByb3ZpZGVycyBkb24ndCBoYXZlIHJlcmFua2luZyBtb2RlbHNcbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvd3JhcC1wcm92aWRlci50c1xuZnVuY3Rpb24gd3JhcFByb3ZpZGVyKHtcbiAgcHJvdmlkZXIsXG4gIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlLFxuICBpbWFnZU1vZGVsTWlkZGxld2FyZVxufSkge1xuICBjb25zdCBwcm92aWRlclYzID0gYXNQcm92aWRlclYzKHByb3ZpZGVyKTtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIGxhbmd1YWdlTW9kZWw6IChtb2RlbElkKSA9PiB3cmFwTGFuZ3VhZ2VNb2RlbCh7XG4gICAgICBtb2RlbDogcHJvdmlkZXJWMy5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpLFxuICAgICAgbWlkZGxld2FyZTogbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbiAgICB9KSxcbiAgICBlbWJlZGRpbmdNb2RlbDogcHJvdmlkZXJWMy5lbWJlZGRpbmdNb2RlbCxcbiAgICBpbWFnZU1vZGVsOiAobW9kZWxJZCkgPT4ge1xuICAgICAgbGV0IG1vZGVsID0gcHJvdmlkZXJWMy5pbWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgaWYgKGltYWdlTW9kZWxNaWRkbGV3YXJlICE9IG51bGwpIHtcbiAgICAgICAgbW9kZWwgPSB3cmFwSW1hZ2VNb2RlbCh7IG1vZGVsLCBtaWRkbGV3YXJlOiBpbWFnZU1vZGVsTWlkZGxld2FyZSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuICAgIHRyYW5zY3JpcHRpb25Nb2RlbDogcHJvdmlkZXJWMy50cmFuc2NyaXB0aW9uTW9kZWwsXG4gICAgc3BlZWNoTW9kZWw6IHByb3ZpZGVyVjMuc3BlZWNoTW9kZWwsXG4gICAgcmVyYW5raW5nTW9kZWw6IHByb3ZpZGVyVjMucmVyYW5raW5nTW9kZWxcbiAgfTtcbn1cblxuLy8gc3JjL3JlZ2lzdHJ5L2N1c3RvbS1wcm92aWRlci50c1xuaW1wb3J0IHtcbiAgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3VzdG9tUHJvdmlkZXIoe1xuICBsYW5ndWFnZU1vZGVscyxcbiAgZW1iZWRkaW5nTW9kZWxzLFxuICBpbWFnZU1vZGVscyxcbiAgdHJhbnNjcmlwdGlvbk1vZGVscyxcbiAgc3BlZWNoTW9kZWxzLFxuICByZXJhbmtpbmdNb2RlbHMsXG4gIGZhbGxiYWNrUHJvdmlkZXI6IGZhbGxiYWNrUHJvdmlkZXJBcmdcbn0pIHtcbiAgY29uc3QgZmFsbGJhY2tQcm92aWRlciA9IGZhbGxiYWNrUHJvdmlkZXJBcmcgPyBhc1Byb3ZpZGVyVjMoZmFsbGJhY2tQcm92aWRlckFyZykgOiB2b2lkIDA7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBsYW5ndWFnZU1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChsYW5ndWFnZU1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gbGFuZ3VhZ2VNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICBlbWJlZGRpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAoZW1iZWRkaW5nTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBlbWJlZGRpbmdNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGVtYmVkZGluZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmVtYmVkZGluZ01vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImVtYmVkZGluZ01vZGVsXCIgfSk7XG4gICAgfSxcbiAgICBpbWFnZU1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChpbWFnZU1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gaW1hZ2VNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGZhbGxiYWNrUHJvdmlkZXIuaW1hZ2VNb2RlbCkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5pbWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImltYWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAodHJhbnNjcmlwdGlvbk1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gdHJhbnNjcmlwdGlvbk1vZGVscykge1xuICAgICAgICByZXR1cm4gdHJhbnNjcmlwdGlvbk1vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBmYWxsYmFja1Byb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbCkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwidHJhbnNjcmlwdGlvbk1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICBzcGVlY2hNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAoc3BlZWNoTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBzcGVlY2hNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHNwZWVjaE1vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBmYWxsYmFja1Byb3ZpZGVyLnNwZWVjaE1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnNwZWVjaE1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcInNwZWVjaE1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICByZXJhbmtpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAocmVyYW5raW5nTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiByZXJhbmtpbmdNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHJlcmFua2luZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBmYWxsYmFja1Byb3ZpZGVyLnJlcmFua2luZ01vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnJlcmFua2luZ01vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcInJlcmFua2luZ01vZGVsXCIgfSk7XG4gICAgfVxuICB9O1xufVxudmFyIGV4cGVyaW1lbnRhbF9jdXN0b21Qcm92aWRlciA9IGN1c3RvbVByb3ZpZGVyO1xuXG4vLyBzcmMvcmVnaXN0cnkvbm8tc3VjaC1wcm92aWRlci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjEsIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNiA9IFwiQUlfTm9TdWNoUHJvdmlkZXJFcnJvclwiO1xudmFyIG1hcmtlcjE2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNn1gO1xudmFyIHN5bWJvbDE2ID0gU3ltYm9sLmZvcihtYXJrZXIxNik7XG52YXIgX2ExNjtcbnZhciBOb1N1Y2hQcm92aWRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBOb1N1Y2hNb2RlbEVycm9yMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBwcm92aWRlcklkLFxuICAgIGF2YWlsYWJsZVByb3ZpZGVycyxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggcHJvdmlkZXI6ICR7cHJvdmlkZXJJZH0gKGF2YWlsYWJsZSBwcm92aWRlcnM6ICR7YXZhaWxhYmxlUHJvdmlkZXJzLmpvaW4oKX0pYFxuICB9KSB7XG4gICAgc3VwZXIoeyBlcnJvck5hbWU6IG5hbWUxNiwgbW9kZWxJZCwgbW9kZWxUeXBlLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExNl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgdGhpcy5hdmFpbGFibGVQcm92aWRlcnMgPSBhdmFpbGFibGVQcm92aWRlcnM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIxLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTYpO1xuICB9XG59O1xuX2ExNiA9IHN5bWJvbDE2O1xuXG4vLyBzcmMvcmVnaXN0cnkvcHJvdmlkZXItcmVnaXN0cnkudHNcbmltcG9ydCB7XG4gIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnkocHJvdmlkZXJzLCB7XG4gIHNlcGFyYXRvciA9IFwiOlwiLFxuICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZSxcbiAgaW1hZ2VNb2RlbE1pZGRsZXdhcmVcbn0gPSB7fSkge1xuICBjb25zdCByZWdpc3RyeSA9IG5ldyBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSh7XG4gICAgc2VwYXJhdG9yLFxuICAgIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlLFxuICAgIGltYWdlTW9kZWxNaWRkbGV3YXJlXG4gIH0pO1xuICBmb3IgKGNvbnN0IFtpZCwgcHJvdmlkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVycykpIHtcbiAgICByZWdpc3RyeS5yZWdpc3RlclByb3ZpZGVyKHsgaWQsIHByb3ZpZGVyIH0pO1xuICB9XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbnZhciBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSA9IGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnk7XG52YXIgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzZXBhcmF0b3IsXG4gICAgbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUsXG4gICAgaW1hZ2VNb2RlbE1pZGRsZXdhcmVcbiAgfSkge1xuICAgIHRoaXMucHJvdmlkZXJzID0ge307XG4gICAgdGhpcy5zZXBhcmF0b3IgPSBzZXBhcmF0b3I7XG4gICAgdGhpcy5sYW5ndWFnZU1vZGVsTWlkZGxld2FyZSA9IGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlO1xuICAgIHRoaXMuaW1hZ2VNb2RlbE1pZGRsZXdhcmUgPSBpbWFnZU1vZGVsTWlkZGxld2FyZTtcbiAgfVxuICByZWdpc3RlclByb3ZpZGVyKHtcbiAgICBpZCxcbiAgICBwcm92aWRlclxuICB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnNbaWRdID0gcHJvdmlkZXI7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoaWQsIG1vZGVsVHlwZSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIHByb3ZpZGVySWQ6IGlkLFxuICAgICAgICBhdmFpbGFibGVQcm92aWRlcnM6IE9iamVjdC5rZXlzKHRoaXMucHJvdmlkZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBzcGxpdElkKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBpbmRleCA9IGlkLmluZGV4T2YodGhpcy5zZXBhcmF0b3IpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bW9kZWxUeXBlfSBpZCBmb3IgcmVnaXN0cnk6ICR7aWR9IChtdXN0IGJlIGluIHRoZSBmb3JtYXQgXCJwcm92aWRlcklkJHt0aGlzLnNlcGFyYXRvcn1tb2RlbElkXCIpYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbaWQuc2xpY2UoMCwgaW5kZXgpLCBpZC5zbGljZShpbmRleCArIHRoaXMuc2VwYXJhdG9yLmxlbmd0aCldO1xuICB9XG4gIGxhbmd1YWdlTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNywgX2I7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImxhbmd1YWdlTW9kZWxcIik7XG4gICAgbGV0IG1vZGVsID0gKF9iID0gKF9hMTcgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwibGFuZ3VhZ2VNb2RlbFwiKSkubGFuZ3VhZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoXG4gICAgICBfYTE3LFxuICAgICAgbW9kZWxJZFxuICAgICk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYW5ndWFnZU1vZGVsTWlkZGxld2FyZSAhPSBudWxsKSB7XG4gICAgICBtb2RlbCA9IHdyYXBMYW5ndWFnZU1vZGVsKHtcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG1pZGRsZXdhcmU6IHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgZW1iZWRkaW5nTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwiZW1iZWRkaW5nTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwiZW1iZWRkaW5nTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLmVtYmVkZGluZ01vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZTogXCJlbWJlZGRpbmdNb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGltYWdlTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwiaW1hZ2VNb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCwgXCJpbWFnZU1vZGVsXCIpO1xuICAgIGxldCBtb2RlbCA9IChfYTE3ID0gcHJvdmlkZXIuaW1hZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwiaW1hZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbWFnZU1vZGVsTWlkZGxld2FyZSAhPSBudWxsKSB7XG4gICAgICBtb2RlbCA9IHdyYXBJbWFnZU1vZGVsKHtcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG1pZGRsZXdhcmU6IHRoaXMuaW1hZ2VNb2RlbE1pZGRsZXdhcmVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdHJhbnNjcmlwdGlvbk1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInRyYW5zY3JpcHRpb25Nb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCwgXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwidHJhbnNjcmlwdGlvbk1vZGVsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgc3BlZWNoTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwic3BlZWNoTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwic3BlZWNoTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLnNwZWVjaE1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJzcGVlY2hNb2RlbFwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgcmVyYW5raW5nTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwicmVyYW5raW5nTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwicmVyYW5raW5nTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExNyA9IHByb3ZpZGVyLnJlcmFua2luZ01vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJyZXJhbmtpbmdNb2RlbFwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXJhbmsvcmVyYW5rLnRzXG5hc3luYyBmdW5jdGlvbiByZXJhbmsoe1xuICBtb2RlbCxcbiAgZG9jdW1lbnRzLFxuICBxdWVyeSxcbiAgdG9wTixcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0UmVyYW5rUmVzdWx0KHtcbiAgICAgIG9yaWdpbmFsRG9jdW1lbnRzOiBbXSxcbiAgICAgIHJhbmtpbmc6IFtdLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YTogdm9pZCAwLFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBkb2N1bWVudHNUb1NlbmQgPSB0eXBlb2YgZG9jdW1lbnRzWzBdID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBcInRleHRcIiwgdmFsdWVzOiBkb2N1bWVudHMgfSA6IHsgdHlwZTogXCJvYmplY3RcIiwgdmFsdWVzOiBkb2N1bWVudHMgfTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkucmVyYW5rXCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnJlcmFua1wiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLmRvY3VtZW50c1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IGRvY3VtZW50cy5tYXAoKGRvY3VtZW50KSA9PiBKU09OLnN0cmluZ2lmeShkb2N1bWVudCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYjtcbiAgICAgIGNvbnN0IHsgcmFua2luZywgcmVzcG9uc2UsIHByb3ZpZGVyTWV0YWRhdGEsIHdhcm5pbmdzIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgbmFtZTogXCJhaS5yZXJhbmsuZG9SZXJhbmtcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5yZXJhbmsuZG9SZXJhbmtcIixcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgIFwiYWkuZG9jdW1lbnRzXCI6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gZG9jdW1lbnRzLm1hcCgoZG9jdW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGRvY3VtZW50KSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICBmbjogYXN5bmMgKGRvUmVyYW5rU3BhbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvUmVyYW5rKHtcbiAgICAgICAgICAgICAgZG9jdW1lbnRzOiBkb2N1bWVudHNUb1NlbmQsXG4gICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICB0b3BOLFxuICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmtpbmcyID0gbW9kZWxSZXNwb25zZS5yYW5raW5nO1xuICAgICAgICAgICAgZG9SZXJhbmtTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnJhbmtpbmcudHlwZVwiOiBkb2N1bWVudHNUb1NlbmQudHlwZSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmFua2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gcmFua2luZzIubWFwKChyYW5raW5nMykgPT4gSlNPTi5zdHJpbmdpZnkocmFua2luZzMpKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByYW5raW5nOiByYW5raW5nMixcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgICAgd2FybmluZ3M6IG1vZGVsUmVzcG9uc2Uud2FybmluZ3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzICE9IG51bGwgPyB3YXJuaW5ncyA6IFtdLFxuICAgICAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsOiBtb2RlbC5tb2RlbElkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFJlcmFua1Jlc3VsdCh7XG4gICAgICAgIG9yaWdpbmFsRG9jdW1lbnRzOiBkb2N1bWVudHMsXG4gICAgICAgIHJhbmtpbmc6IHJhbmtpbmcubWFwKChyYW5raW5nMikgPT4gKHtcbiAgICAgICAgICBvcmlnaW5hbEluZGV4OiByYW5raW5nMi5pbmRleCxcbiAgICAgICAgICBzY29yZTogcmFua2luZzIucmVsZXZhbmNlU2NvcmUsXG4gICAgICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50c1tyYW5raW5nMi5pbmRleF1cbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIGlkOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaWQsXG4gICAgICAgICAgdGltZXN0YW1wOiAoX2ExNyA9IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS50aW1lc3RhbXApICE9IG51bGwgPyBfYTE3IDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgbW9kZWxJZDogKF9iID0gcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1vZGVsSWQpICE9IG51bGwgPyBfYiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgYm9keTogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmJvZHlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0UmVyYW5rUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcmlnaW5hbERvY3VtZW50cyA9IG9wdGlvbnMub3JpZ2luYWxEb2N1bWVudHM7XG4gICAgdGhpcy5yYW5raW5nID0gb3B0aW9ucy5yYW5raW5nO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgfVxuICBnZXQgcmVyYW5rZWREb2N1bWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFua2luZy5tYXAoKHJhbmtpbmcpID0+IHJhbmtpbmcuZG9jdW1lbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvdHJhbnNjcmliZS90cmFuc2NyaWJlLnRzXG5pbXBvcnQgeyB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXg4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Vycm9yL25vLXRyYW5zY3JpcHQtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyMiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX05vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBcIk5vIHRyYW5zY3JpcHQgZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gc3JjL3RyYW5zY3JpYmUvdHJhbnNjcmliZS50c1xuYXN5bmMgZnVuY3Rpb24gdHJhbnNjcmliZSh7XG4gIG1vZGVsLFxuICBhdWRpbyxcbiAgcHJvdmlkZXJPcHRpb25zID0ge30sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIGNvbnN0IHJlc29sdmVkTW9kZWwgPSByZXNvbHZlVHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsKTtcbiAgaWYgKCFyZXNvbHZlZE1vZGVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgY291bGQgbm90IGJlIHJlc29sdmVkXCIpO1xuICB9XG4gIGNvbnN0IHsgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgIGFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXg4KFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgYXVkaW9EYXRhID0gYXVkaW8gaW5zdGFuY2VvZiBVUkwgPyAoYXdhaXQgZG93bmxvYWQoeyB1cmw6IGF1ZGlvIH0pKS5kYXRhIDogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGF1ZGlvKTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgYXVkaW86IGF1ZGlvRGF0YSxcbiAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgIG1lZGlhVHlwZTogKF9hMTcgPSBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgIGRhdGE6IGF1ZGlvRGF0YSxcbiAgICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkpICE9IG51bGwgPyBfYTE3IDogXCJhdWRpby93YXZcIlxuICAgICAgfSk7XG4gICAgfVxuICApO1xuICBsb2dXYXJuaW5ncyh7XG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICBwcm92aWRlcjogcmVzb2x2ZWRNb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbDogcmVzb2x2ZWRNb2RlbC5tb2RlbElkXG4gIH0pO1xuICBpZiAoIXJlc3VsdC50ZXh0KSB7XG4gICAgdGhyb3cgbmV3IE5vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSB9KTtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0KHtcbiAgICB0ZXh0OiByZXN1bHQudGV4dCxcbiAgICBzZWdtZW50czogcmVzdWx0LnNlZ21lbnRzLFxuICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgZHVyYXRpb25JblNlY29uZHM6IHJlc3VsdC5kdXJhdGlvbkluU2Vjb25kcyxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0sXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgfSk7XG59XG52YXIgRGVmYXVsdFRyYW5zY3JpcHRpb25SZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy5zZWdtZW50cyA9IG9wdGlvbnMuc2VnbWVudHM7XG4gICAgdGhpcy5sYW5ndWFnZSA9IG9wdGlvbnMubGFuZ3VhZ2U7XG4gICAgdGhpcy5kdXJhdGlvbkluU2Vjb25kcyA9IG9wdGlvbnMuZHVyYXRpb25JblNlY29uZHM7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSAoX2ExNyA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB7fTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbmltcG9ydCB7XG4gIHBhcnNlSnNvbkV2ZW50U3RyZWFtLFxuICB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXg5LFxuICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQgYXMgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvcHJvY2Vzcy10ZXh0LXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1RleHRTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uVGV4dFBhcnRcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYXdhaXQgb25UZXh0UGFydCh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gc3JjL3VpL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gIGFwaSxcbiAgcHJvbXB0LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoKClcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIHRyeSB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcih2b2lkIDApO1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBzZXRBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcbiAgICBzZXRDb21wbGV0aW9uKFwiXCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9KSxcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogd2l0aFVzZXJBZ2VudFN1ZmZpeDkoXG4gICAgICAgIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGBhaS1zZGsvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDIoKVxuICAgICAgKSxcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfYTE3ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2ExNyA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgc3dpdGNoIChzdHJlYW1Qcm90b2NvbCkge1xuICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICBhd2FpdCBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgICAgIG9uVGV4dFBhcnQ6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNodW5rO1xuICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgICBzdHJlYW06IHBhcnNlSnNvbkV2ZW50U3RyZWFtKHtcbiAgICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICAgIHNjaGVtYTogdWlNZXNzYWdlQ2h1bmtTY2hlbWFcbiAgICAgICAgICB9KS5waXBlVGhyb3VnaChcbiAgICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0ocGFydCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFydC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBwYXJ0LmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1QYXJ0ID0gcGFydC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtUGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmVhbVBhcnQuZGVsdGE7XG4gICAgICAgICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1QYXJ0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmVhbVBhcnQuZXJyb3JUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBzdHJlYW1Qcm90b2NvbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBwcm90b2NvbDogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG5cbi8vIHNyYy91aS9jaGF0LnRzXG5pbXBvcnQge1xuICBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvY29udmVydC1maWxlLWxpc3QtdG8tZmlsZS11aS1wYXJ0cy50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyhmaWxlcykge1xuICBpZiAoZmlsZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWdsb2JhbFRoaXMuRmlsZUxpc3QgfHwgIShmaWxlcyBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRmlsZUxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZUxpc3QgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFwiKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgQXJyYXkuZnJvbShmaWxlcykubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWU6IG5hbWUxNywgdHlwZSB9ID0gZmlsZTtcbiAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZTMsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgcmVzb2x2ZTMoKF9hMTcgPSByZWFkZXJFdmVudC50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZTogdHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IG5hbWUxNyxcbiAgICAgICAgdXJsOiBkYXRhVXJsXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBwYXJzZUpzb25FdmVudFN0cmVhbSBhcyBwYXJzZUpzb25FdmVudFN0cmVhbTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvaHR0cC1jaGF0LXRyYW5zcG9ydC50c1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplSGVhZGVycyxcbiAgcmVzb2x2ZSBhcyByZXNvbHZlMixcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4MTAsXG4gIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudCBhcyBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgSHR0cENoYXRUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0LFxuICAgIHByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3RcbiAgfSkge1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoMjtcbiAgICB0aGlzLnByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0ID0gcHJlcGFyZVNlbmRNZXNzYWdlc1JlcXVlc3Q7XG4gICAgdGhpcy5wcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0ID0gcHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdDtcbiAgfVxuICBhc3luYyBzZW5kTWVzc2FnZXMoe1xuICAgIGFib3J0U2lnbmFsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlMih0aGlzLmJvZHkpO1xuICAgIGNvbnN0IHJlc29sdmVkSGVhZGVycyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVzb2x2ZWRDcmVkZW50aWFscyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IGJhc2VIZWFkZXJzID0ge1xuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhyZXNvbHZlZEhlYWRlcnMpLFxuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlcXVlc3QgPSBhd2FpdCAoKF9hMTcgPSB0aGlzLnByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgIGJvZHk6IHsgLi4ucmVzb2x2ZWRCb2R5LCAuLi5vcHRpb25zLmJvZHkgfSxcbiAgICAgIGhlYWRlcnM6IGJhc2VIZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGEsXG4gICAgICB0cmlnZ2VyOiBvcHRpb25zLnRyaWdnZXIsXG4gICAgICBtZXNzYWdlSWQ6IG9wdGlvbnMubWVzc2FnZUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IGFwaSA9IChfYiA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmFwaSkgIT0gbnVsbCA/IF9iIDogdGhpcy5hcGk7XG4gICAgY29uc3QgaGVhZGVycyA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSAhPT0gdm9pZCAwID8gbm9ybWFsaXplSGVhZGVycyhwcmVwYXJlZFJlcXVlc3QuaGVhZGVycykgOiBiYXNlSGVhZGVycztcbiAgICBjb25zdCBib2R5ID0gKHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmJvZHkpICE9PSB2b2lkIDAgPyBwcmVwYXJlZFJlcXVlc3QuYm9keSA6IHtcbiAgICAgIC4uLnJlc29sdmVkQm9keSxcbiAgICAgIC4uLm9wdGlvbnMuYm9keSxcbiAgICAgIGlkOiBvcHRpb25zLmNoYXRJZCxcbiAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgICAgdHJpZ2dlcjogb3B0aW9ucy50cmlnZ2VyLFxuICAgICAgbWVzc2FnZUlkOiBvcHRpb25zLm1lc3NhZ2VJZFxuICAgIH07XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSAoX2MgPSBwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5jcmVkZW50aWFscykgIT0gbnVsbCA/IF9jIDogcmVzb2x2ZWRDcmVkZW50aWFscztcbiAgICBjb25zdCBmZXRjaDIgPSAoX2QgPSB0aGlzLmZldGNoKSAhPSBudWxsID8gX2QgOiBnbG9iYWxUaGlzLmZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHdpdGhVc2VyQWdlbnRTdWZmaXgxMChcbiAgICAgICAge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgYGFpLXNkay8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MygpXG4gICAgICApLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbiAgYXN5bmMgcmVjb25uZWN0VG9TdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZXNvbHZlZEJvZHkgPSBhd2FpdCByZXNvbHZlMih0aGlzLmJvZHkpO1xuICAgIGNvbnN0IHJlc29sdmVkSGVhZGVycyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuaGVhZGVycyk7XG4gICAgY29uc3QgcmVzb2x2ZWRDcmVkZW50aWFscyA9IGF3YWl0IHJlc29sdmUyKHRoaXMuY3JlZGVudGlhbHMpO1xuICAgIGNvbnN0IGJhc2VIZWFkZXJzID0ge1xuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhyZXNvbHZlZEhlYWRlcnMpLFxuICAgICAgLi4ubm9ybWFsaXplSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlZFJlcXVlc3QgPSBhd2FpdCAoKF9hMTcgPSB0aGlzLnByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwodGhpcywge1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGlkOiBvcHRpb25zLmNoYXRJZCxcbiAgICAgIGJvZHk6IHsgLi4ucmVzb2x2ZWRCb2R5LCAuLi5vcHRpb25zLmJvZHkgfSxcbiAgICAgIGhlYWRlcnM6IGJhc2VIZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IHJlc29sdmVkQ3JlZGVudGlhbHMsXG4gICAgICByZXF1ZXN0TWV0YWRhdGE6IG9wdGlvbnMubWV0YWRhdGFcbiAgICB9KSk7XG4gICAgY29uc3QgYXBpID0gKF9iID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuYXBpKSAhPSBudWxsID8gX2IgOiBgJHt0aGlzLmFwaX0vJHtvcHRpb25zLmNoYXRJZH0vc3RyZWFtYDtcbiAgICBjb25zdCBoZWFkZXJzID0gKHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMpICE9PSB2b2lkIDAgPyBub3JtYWxpemVIZWFkZXJzKHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSA6IGJhc2VIZWFkZXJzO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gKF9jID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuY3JlZGVudGlhbHMpICE9IG51bGwgPyBfYyA6IHJlc29sdmVkQ3JlZGVudGlhbHM7XG4gICAgY29uc3QgZmV0Y2gyID0gKF9kID0gdGhpcy5mZXRjaCkgIT0gbnVsbCA/IF9kIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHdpdGhVc2VyQWdlbnRTdWZmaXgxMChcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYGFpLXNkay8ke1ZFUlNJT059YCxcbiAgICAgICAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MygpXG4gICAgICApLFxuICAgICAgY3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChfZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9lIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVzcG9uc2VTdHJlYW0ocmVzcG9uc2UuYm9keSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9kZWZhdWx0LWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgRGVmYXVsdENoYXRUcmFuc3BvcnQgPSBjbGFzcyBleHRlbmRzIEh0dHBDaGF0VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHN0cmVhbSkge1xuICAgIHJldHVybiBwYXJzZUpzb25FdmVudFN0cmVhbTIoe1xuICAgICAgc3RyZWFtLFxuICAgICAgc2NoZW1hOiB1aU1lc3NhZ2VDaHVua1NjaGVtYVxuICAgIH0pLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmICghY2h1bmsuc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgY2h1bmsuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NoYXQudHNcbnZhciBBYnN0cmFjdENoYXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRGdW5jMixcbiAgICBpZCA9IGdlbmVyYXRlSWQyKCksXG4gICAgdHJhbnNwb3J0ID0gbmV3IERlZmF1bHRDaGF0VHJhbnNwb3J0KCksXG4gICAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICAgIGRhdGFQYXJ0U2NoZW1hcyxcbiAgICBzdGF0ZSxcbiAgICBvbkVycm9yLFxuICAgIG9uVG9vbENhbGwsXG4gICAgb25GaW5pc2gsXG4gICAgb25EYXRhLFxuICAgIHNlbmRBdXRvbWF0aWNhbGx5V2hlblxuICB9KSB7XG4gICAgdGhpcy5hY3RpdmVSZXNwb25zZSA9IHZvaWQgMDtcbiAgICB0aGlzLmpvYkV4ZWN1dG9yID0gbmV3IFNlcmlhbEpvYkV4ZWN1dG9yKCk7XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBvciByZXBsYWNlcyBhIHVzZXIgbWVzc2FnZSB0byB0aGUgY2hhdCBsaXN0LiBUaGlzIHRyaWdnZXJzIHRoZSBBUEkgY2FsbCB0byBmZXRjaFxuICAgICAqIHRoZSBhc3Npc3RhbnQncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIElmIGEgbWVzc2FnZUlkIGlzIHByb3ZpZGVkLCB0aGUgbWVzc2FnZSB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAqL1xuICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICAgICAgdmFyIF9hMTcsIF9iLCBfYywgX2Q7XG4gICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgICBtZXNzYWdlSWQ6IChfYTE3ID0gdGhpcy5sYXN0TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuaWQsXG4gICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHVpTWVzc2FnZTtcbiAgICAgIGlmIChcInRleHRcIiBpbiBtZXNzYWdlIHx8IFwiZmlsZXNcIiBpbiBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpbGVQYXJ0cyA9IEFycmF5LmlzQXJyYXkobWVzc2FnZS5maWxlcykgPyBtZXNzYWdlLmZpbGVzIDogYXdhaXQgY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyhtZXNzYWdlLmZpbGVzKTtcbiAgICAgICAgdWlNZXNzYWdlID0ge1xuICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAuLi5maWxlUGFydHMsXG4gICAgICAgICAgICAuLi5cInRleHRcIiBpbiBtZXNzYWdlICYmIG1lc3NhZ2UudGV4dCAhPSBudWxsID8gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UudGV4dCB9XSA6IFtdXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdWlNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VJZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IHRoaXMuc3RhdGUubWVzc2FnZXMuZmluZEluZGV4KFxuICAgICAgICAgIChtKSA9PiBtLmlkID09PSBtZXNzYWdlLm1lc3NhZ2VJZFxuICAgICAgICApO1xuICAgICAgICBpZiAobWVzc2FnZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWVzc2FnZSB3aXRoIGlkICR7bWVzc2FnZS5tZXNzYWdlSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1lc3NhZ2VzW21lc3NhZ2VJbmRleF0ucm9sZSAhPT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgbWVzc2FnZSB3aXRoIGlkICR7bWVzc2FnZS5tZXNzYWdlSWR9IGlzIG5vdCBhIHVzZXIgbWVzc2FnZWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUubWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VJbmRleCArIDEpO1xuICAgICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKG1lc3NhZ2VJbmRleCwge1xuICAgICAgICAgIC4uLnVpTWVzc2FnZSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5tZXNzYWdlSWQsXG4gICAgICAgICAgcm9sZTogKF9iID0gdWlNZXNzYWdlLnJvbGUpICE9IG51bGwgPyBfYiA6IFwidXNlclwiLFxuICAgICAgICAgIG1ldGFkYXRhOiBtZXNzYWdlLm1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wdXNoTWVzc2FnZSh7XG4gICAgICAgICAgLi4udWlNZXNzYWdlLFxuICAgICAgICAgIGlkOiAoX2MgPSB1aU1lc3NhZ2UuaWQpICE9IG51bGwgPyBfYyA6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHJvbGU6IChfZCA9IHVpTWVzc2FnZS5yb2xlKSAhPSBudWxsID8gX2QgOiBcInVzZXJcIixcbiAgICAgICAgICBtZXRhZGF0YTogbWVzc2FnZS5tZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZS5tZXNzYWdlSWQsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZSB0aGUgYXNzaXN0YW50IG1lc3NhZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgbWVzc2FnZSBpZC5cbiAgICAgKiBJZiBubyBtZXNzYWdlIGlkIGlzIHByb3ZpZGVkLCB0aGUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZSB3aWxsIGJlIHJlZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIHRoaXMucmVnZW5lcmF0ZSA9IGFzeW5jICh7XG4gICAgICBtZXNzYWdlSWQsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSBtZXNzYWdlSWQgPT0gbnVsbCA/IHRoaXMuc3RhdGUubWVzc2FnZXMubGVuZ3RoIC0gMSA6IHRoaXMuc3RhdGUubWVzc2FnZXMuZmluZEluZGV4KChtZXNzYWdlKSA9PiBtZXNzYWdlLmlkID09PSBtZXNzYWdlSWQpO1xuICAgICAgaWYgKG1lc3NhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtZXNzYWdlICR7bWVzc2FnZUlkfSBub3QgZm91bmRgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUubWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzLnNsaWNlKFxuICAgICAgICAwLFxuICAgICAgICAvLyBpZiB0aGUgbWVzc2FnZSBpcyBhIHVzZXIgbWVzc2FnZSwgd2UgbmVlZCB0byBpbmNsdWRlIGl0IGluIHRoZSByZXF1ZXN0OlxuICAgICAgICB0aGlzLm1lc3NhZ2VzW21lc3NhZ2VJbmRleF0ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiA/IG1lc3NhZ2VJbmRleCA6IG1lc3NhZ2VJbmRleCArIDFcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJyZWdlbmVyYXRlLW1lc3NhZ2VcIixcbiAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gcmVzdW1lIGFuIG9uZ29pbmcgc3RyZWFtaW5nIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIHRoaXMucmVzdW1lU3RyZWFtID0gYXN5bmMgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7IHRyaWdnZXI6IFwicmVzdW1lLXN0cmVhbVwiLCAuLi5vcHRpb25zIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGVycm9yIHN0YXRlIGFuZCBzZXQgdGhlIHN0YXR1cyB0byByZWFkeSBpZiB0aGUgY2hhdCBpcyBpbiBhbiBlcnJvciBzdGF0ZS5cbiAgICAgKi9cbiAgICB0aGlzLmNsZWFyRXJyb3IgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB0aGlzLnN0YXRlLmVycm9yID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh7IHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRUb29sQXBwcm92YWxSZXNwb25zZSA9IGFzeW5jICh7XG4gICAgICBpZCxcbiAgICAgIGFwcHJvdmVkLFxuICAgICAgcmVhc29uXG4gICAgfSkgPT4gdGhpcy5qb2JFeGVjdXRvci5ydW4oYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMTcsIF9iO1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLnN0YXRlLm1lc3NhZ2VzO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IHVwZGF0ZVBhcnQgPSAocGFydCkgPT4gaXNUb29sVUlQYXJ0KHBhcnQpICYmIHBhcnQuc3RhdGUgPT09IFwiYXBwcm92YWwtcmVxdWVzdGVkXCIgJiYgcGFydC5hcHByb3ZhbC5pZCA9PT0gaWQgPyB7XG4gICAgICAgIC4uLnBhcnQsXG4gICAgICAgIHN0YXRlOiBcImFwcHJvdmFsLXJlc3BvbmRlZFwiLFxuICAgICAgICBhcHByb3ZhbDogeyBpZCwgYXBwcm92ZWQsIHJlYXNvbiB9XG4gICAgICB9IDogcGFydDtcbiAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZXMubGVuZ3RoIC0gMSwge1xuICAgICAgICAuLi5sYXN0TWVzc2FnZSxcbiAgICAgICAgcGFydHM6IGxhc3RNZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hY3RpdmVSZXNwb25zZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMubWFwKHVwZGF0ZVBhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiICYmICgoX2ExNyA9IHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIHsgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXMgfSkpKSB7XG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgICBtZXNzYWdlSWQ6IChfYiA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmFkZFRvb2xPdXRwdXQgPSBhc3luYyAoe1xuICAgICAgc3RhdGUgPSBcIm91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgIHRvb2w6IHRvb2wyLFxuICAgICAgdG9vbENhbGxJZCxcbiAgICAgIG91dHB1dCxcbiAgICAgIGVycm9yVGV4dFxuICAgIH0pID0+IHRoaXMuam9iRXhlY3V0b3IucnVuKGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTE3LCBfYjtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcztcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCB1cGRhdGVQYXJ0ID0gKHBhcnQpID0+IGlzVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB7IC4uLnBhcnQsIHN0YXRlLCBvdXRwdXQsIGVycm9yVGV4dCB9IDogcGFydDtcbiAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UobWVzc2FnZXMubGVuZ3RoIC0gMSwge1xuICAgICAgICAuLi5sYXN0TWVzc2FnZSxcbiAgICAgICAgcGFydHM6IGxhc3RNZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hY3RpdmVSZXNwb25zZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UucGFydHMubWFwKHVwZGF0ZVBhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiICYmICgoX2ExNyA9IHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIHsgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXMgfSkpKSB7XG4gICAgICAgIHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgICBtZXNzYWdlSWQ6IChfYiA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGFkZFRvb2xPdXRwdXQgKi9cbiAgICB0aGlzLmFkZFRvb2xSZXN1bHQgPSB0aGlzLmFkZFRvb2xPdXRwdXQ7XG4gICAgLyoqXG4gICAgICogQWJvcnQgdGhlIGN1cnJlbnQgcmVxdWVzdCBpbW1lZGlhdGVseSwga2VlcCB0aGUgZ2VuZXJhdGVkIHRva2VucyBpZiBhbnkuXG4gICAgICovXG4gICAgdGhpcy5zdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwic3RyZWFtaW5nXCIgJiYgdGhpcy5zdGF0dXMgIT09IFwic3VibWl0dGVkXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICgoX2ExNyA9IHRoaXMuYWN0aXZlUmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmFib3J0Q29udHJvbGxlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlc3BvbnNlLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuZ2VuZXJhdGVJZCA9IGdlbmVyYXRlSWQyO1xuICAgIHRoaXMubWVzc2FnZU1ldGFkYXRhU2NoZW1hID0gbWVzc2FnZU1ldGFkYXRhU2NoZW1hO1xuICAgIHRoaXMuZGF0YVBhcnRTY2hlbWFzID0gZGF0YVBhcnRTY2hlbWFzO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgIHRoaXMub25Ub29sQ2FsbCA9IG9uVG9vbENhbGw7XG4gICAgdGhpcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xuICAgIHRoaXMub25EYXRhID0gb25EYXRhO1xuICAgIHRoaXMuc2VuZEF1dG9tYXRpY2FsbHlXaGVuID0gc2VuZEF1dG9tYXRpY2FsbHlXaGVuO1xuICB9XG4gIC8qKlxuICAgKiBIb29rIHN0YXR1czpcbiAgICpcbiAgICogLSBgc3VibWl0dGVkYDogVGhlIG1lc3NhZ2UgaGFzIGJlZW4gc2VudCB0byB0aGUgQVBJIGFuZCB3ZSdyZSBhd2FpdGluZyB0aGUgc3RhcnQgb2YgdGhlIHJlc3BvbnNlIHN0cmVhbS5cbiAgICogLSBgc3RyZWFtaW5nYDogVGhlIHJlc3BvbnNlIGlzIGFjdGl2ZWx5IHN0cmVhbWluZyBpbiBmcm9tIHRoZSBBUEksIHJlY2VpdmluZyBjaHVua3Mgb2YgZGF0YS5cbiAgICogLSBgcmVhZHlgOiBUaGUgZnVsbCByZXNwb25zZSBoYXMgYmVlbiByZWNlaXZlZCBhbmQgcHJvY2Vzc2VkOyBhIG5ldyB1c2VyIG1lc3NhZ2UgY2FuIGJlIHN1Ym1pdHRlZC5cbiAgICogLSBgZXJyb3JgOiBBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIEFQSSByZXF1ZXN0LCBwcmV2ZW50aW5nIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdHVzO1xuICB9XG4gIHNldFN0YXR1cyh7XG4gICAgc3RhdHVzLFxuICAgIGVycm9yXG4gIH0pIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXRlLmVycm9yID0gZXJyb3I7XG4gIH1cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yO1xuICB9XG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5tZXNzYWdlcztcbiAgfVxuICBnZXQgbGFzdE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubWVzc2FnZXNbdGhpcy5zdGF0ZS5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBzZXQgbWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gIH1cbiAgYXN5bmMgbWFrZVJlcXVlc3Qoe1xuICAgIHRyaWdnZXIsXG4gICAgbWV0YWRhdGEsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICAgIG1lc3NhZ2VJZFxuICB9KSB7XG4gICAgdmFyIF9hMTcsIF9iLCBfYywgX2Q7XG4gICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwic3VibWl0dGVkXCIsIGVycm9yOiB2b2lkIDAgfSk7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLmxhc3RNZXNzYWdlO1xuICAgIGxldCBpc0Fib3J0ID0gZmFsc2U7XG4gICAgbGV0IGlzRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVJlc3BvbnNlID0ge1xuICAgICAgICBzdGF0ZTogY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgICAgICAgIGxhc3RNZXNzYWdlOiB0aGlzLnN0YXRlLnNuYXBzaG90KGxhc3RNZXNzYWdlKSxcbiAgICAgICAgICBtZXNzYWdlSWQ6IHRoaXMuZ2VuZXJhdGVJZCgpXG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgfTtcbiAgICAgIGFjdGl2ZVJlc3BvbnNlLmFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgaXNBYm9ydCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UgPSBhY3RpdmVSZXNwb25zZTtcbiAgICAgIGxldCBzdHJlYW07XG4gICAgICBpZiAodHJpZ2dlciA9PT0gXCJyZXN1bWUtc3RyZWFtXCIpIHtcbiAgICAgICAgY29uc3QgcmVjb25uZWN0ID0gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVjb25uZWN0VG9TdHJlYW0oe1xuICAgICAgICAgIGNoYXRJZDogdGhpcy5pZCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZWNvbm5lY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbSA9IHJlY29ubmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRNZXNzYWdlcyh7XG4gICAgICAgICAgY2hhdElkOiB0aGlzLmlkLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzLFxuICAgICAgICAgIGFib3J0U2lnbmFsOiBhY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICB0cmlnZ2VyLFxuICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ1blVwZGF0ZU1lc3NhZ2VKb2IgPSAoam9iKSA9PiAoXG4gICAgICAgIC8vIHNlcmlhbGl6ZSB0aGUgam9iIGV4ZWN1dGlvbiB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnM6XG4gICAgICAgIHRoaXMuam9iRXhlY3V0b3IucnVuKFxuICAgICAgICAgICgpID0+IGpvYih7XG4gICAgICAgICAgICBzdGF0ZTogYWN0aXZlUmVzcG9uc2Uuc3RhdGUsXG4gICAgICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwic3RyZWFtaW5nXCIgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VMYXN0TWVzc2FnZSA9IGFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UuaWQgPT09ICgoX2ExOCA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4LmlkKTtcbiAgICAgICAgICAgICAgaWYgKHJlcGxhY2VMYXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICBhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnB1c2hNZXNzYWdlKGFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGF3YWl0IGNvbnN1bWVTdHJlYW0oe1xuICAgICAgICBzdHJlYW06IHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBvblRvb2xDYWxsOiB0aGlzLm9uVG9vbENhbGwsXG4gICAgICAgICAgb25EYXRhOiB0aGlzLm9uRGF0YSxcbiAgICAgICAgICBtZXNzYWdlTWV0YWRhdGFTY2hlbWE6IHRoaXMubWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICAgICAgICAgIGRhdGFQYXJ0U2NoZW1hczogdGhpcy5kYXRhUGFydFNjaGVtYXMsXG4gICAgICAgICAgcnVuVXBkYXRlTWVzc2FnZUpvYixcbiAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoaXNBYm9ydCB8fCBlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgaXNBYm9ydCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaXNFcnJvciA9IHRydWU7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiZmV0Y2hcIikgfHwgZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIm5ldHdvcmtcIikpKSB7XG4gICAgICAgIGlzRGlzY29ubmVjdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwiZXJyb3JcIiwgZXJyb3I6IGVyciB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgKF9iID0gdGhpcy5vbkZpbmlzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywge1xuICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlczogdGhpcy5zdGF0ZS5tZXNzYWdlcyxcbiAgICAgICAgICBpc0Fib3J0LFxuICAgICAgICAgIGlzRGlzY29ubmVjdCxcbiAgICAgICAgICBpc0Vycm9yLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogKF9hMTcgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5zdGF0ZS5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKCgoX2MgPSB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcywgeyBtZXNzYWdlczogdGhpcy5zdGF0ZS5tZXNzYWdlcyB9KSkgJiYgIWlzRXJyb3IpIHtcbiAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3Qoe1xuICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgIG1lc3NhZ2VJZDogKF9kID0gdGhpcy5sYXN0TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmlkLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdWkvZGlyZWN0LWNoYXQtdHJhbnNwb3J0LnRzXG52YXIgRGlyZWN0Q2hhdFRyYW5zcG9ydCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGFnZW50LFxuICAgIG9wdGlvbnMsXG4gICAgLi4udWlNZXNzYWdlU3RyZWFtT3B0aW9uc1xuICB9KSB7XG4gICAgdGhpcy5hZ2VudCA9IGFnZW50O1xuICAgIHRoaXMuYWdlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnMgPSB1aU1lc3NhZ2VTdHJlYW1PcHRpb25zO1xuICB9XG4gIGFzeW5jIHNlbmRNZXNzYWdlcyh7XG4gICAgbWVzc2FnZXMsXG4gICAgYWJvcnRTaWduYWxcbiAgfSkge1xuICAgIGNvbnN0IHZhbGlkYXRlZE1lc3NhZ2VzID0gYXdhaXQgdmFsaWRhdGVVSU1lc3NhZ2VzKHtcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgdG9vbHM6IHRoaXMuYWdlbnQudG9vbHNcbiAgICB9KTtcbiAgICBjb25zdCBtb2RlbE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTW9kZWxNZXNzYWdlcyh2YWxpZGF0ZWRNZXNzYWdlcywge1xuICAgICAgdG9vbHM6IHRoaXMuYWdlbnQudG9vbHNcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFnZW50LnN0cmVhbSh7XG4gICAgICBwcm9tcHQ6IG1vZGVsTWVzc2FnZXMsXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIC4uLnRoaXMuYWdlbnRPcHRpb25zICE9PSB2b2lkIDAgPyB7IG9wdGlvbnM6IHRoaXMuYWdlbnRPcHRpb25zIH0gOiB7fVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudG9VSU1lc3NhZ2VTdHJlYW0odGhpcy51aU1lc3NhZ2VTdHJlYW1PcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRGlyZWN0IHRyYW5zcG9ydCBkb2VzIG5vdCBzdXBwb3J0IHJlY29ubmVjdGlvbiBzaW5jZSB0aGVyZSBpcyBub1xuICAgKiBwZXJzaXN0ZW50IHNlcnZlci1zaWRlIHN0cmVhbSB0byByZWNvbm5lY3QgdG8uXG4gICAqXG4gICAqIEByZXR1cm5zIEFsd2F5cyByZXR1cm5zIGBudWxsYFxuICAgKi9cbiAgYXN5bmMgcmVjb25uZWN0VG9TdHJlYW0oX29wdGlvbnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2xhc3QtYXNzaXN0YW50LW1lc3NhZ2UtaXMtY29tcGxldGUtd2l0aC1hcHByb3ZhbC1yZXNwb25zZXMudHNcbmZ1bmN0aW9uIGxhc3RBc3Npc3RhbnRNZXNzYWdlSXNDb21wbGV0ZVdpdGhBcHByb3ZhbFJlc3BvbnNlcyh7XG4gIG1lc3NhZ2VzXG59KSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgaWYgKCFtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChtZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGFzdFN0ZXBTdGFydEluZGV4ID0gbWVzc2FnZS5wYXJ0cy5yZWR1Y2UoKGxhc3RJbmRleCwgcGFydCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gcGFydC50eXBlID09PSBcInN0ZXAtc3RhcnRcIiA/IGluZGV4IDogbGFzdEluZGV4O1xuICB9LCAtMSk7XG4gIGNvbnN0IGxhc3RTdGVwVG9vbEludm9jYXRpb25zID0gbWVzc2FnZS5wYXJ0cy5zbGljZShsYXN0U3RlcFN0YXJ0SW5kZXggKyAxKS5maWx0ZXIoaXNUb29sVUlQYXJ0KS5maWx0ZXIoKHBhcnQpID0+ICFwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQpO1xuICByZXR1cm4gKFxuICAgIC8vIGhhcyBhdCBsZWFzdCBvbmUgdG9vbCBhcHByb3ZhbCByZXNwb25zZVxuICAgIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmZpbHRlcigocGFydCkgPT4gcGFydC5zdGF0ZSA9PT0gXCJhcHByb3ZhbC1yZXNwb25kZWRcIikubGVuZ3RoID4gMCAmJiAvLyBhbGwgdG9vbCBhcHByb3ZhbHMgbXVzdCBoYXZlIGEgcmVzcG9uc2VcbiAgICBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucy5ldmVyeShcbiAgICAgIChwYXJ0KSA9PiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiB8fCBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiIHx8IHBhcnQuc3RhdGUgPT09IFwiYXBwcm92YWwtcmVzcG9uZGVkXCJcbiAgICApXG4gICk7XG59XG5cbi8vIHNyYy91aS9sYXN0LWFzc2lzdGFudC1tZXNzYWdlLWlzLWNvbXBsZXRlLXdpdGgtdG9vbC1jYWxscy50c1xuZnVuY3Rpb24gbGFzdEFzc2lzdGFudE1lc3NhZ2VJc0NvbXBsZXRlV2l0aFRvb2xDYWxscyh7XG4gIG1lc3NhZ2VzXG59KSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgaWYgKCFtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChtZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGFzdFN0ZXBTdGFydEluZGV4ID0gbWVzc2FnZS5wYXJ0cy5yZWR1Y2UoKGxhc3RJbmRleCwgcGFydCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gcGFydC50eXBlID09PSBcInN0ZXAtc3RhcnRcIiA/IGluZGV4IDogbGFzdEluZGV4O1xuICB9LCAtMSk7XG4gIGNvbnN0IGxhc3RTdGVwVG9vbEludm9jYXRpb25zID0gbWVzc2FnZS5wYXJ0cy5zbGljZShsYXN0U3RlcFN0YXJ0SW5kZXggKyAxKS5maWx0ZXIoaXNUb29sVUlQYXJ0KS5maWx0ZXIoKHBhcnQpID0+ICFwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQpO1xuICByZXR1cm4gbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMubGVuZ3RoID4gMCAmJiBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucy5ldmVyeShcbiAgICAocGFydCkgPT4gcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIlxuICApO1xufVxuXG4vLyBzcmMvdWkvdHJhbnNmb3JtLXRleHQtdG8tdWktbWVzc2FnZS1zdHJlYW0udHNcbmZ1bmN0aW9uIHRyYW5zZm9ybVRleHRUb1VpTWVzc2FnZVN0cmVhbSh7XG4gIHN0cmVhbVxufSkge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInN0YXJ0XCIgfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwic3RhcnQtc3RlcFwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtc3RhcnRcIiwgaWQ6IFwidGV4dC0xXCIgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgdHJhbnNmb3JtKHBhcnQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIGlkOiBcInRleHQtMVwiLCBkZWx0YTogcGFydCB9KTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1lbmRcIiwgaWQ6IFwidGV4dC0xXCIgfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZmluaXNoLXN0ZXBcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2hcIiB9KTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWkvdGV4dC1zdHJlYW0tY2hhdC10cmFuc3BvcnQudHNcbnZhciBUZXh0U3RyZWFtQ2hhdFRyYW5zcG9ydCA9IGNsYXNzIGV4dGVuZHMgSHR0cENoYXRUcmFuc3BvcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuICBwcm9jZXNzUmVzcG9uc2VTdHJlYW0oc3RyZWFtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVRleHRUb1VpTWVzc2FnZVN0cmVhbSh7XG4gICAgICBzdHJlYW06IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSlcbiAgICB9KTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IxOCBhcyBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEFic3RyYWN0Q2hhdCxcbiAgRGVmYXVsdENoYXRUcmFuc3BvcnQsXG4gIERpcmVjdENoYXRUcmFuc3BvcnQsXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIFRvb2xMb29wQWdlbnQgYXMgRXhwZXJpbWVudGFsX0FnZW50LFxuICBIdHRwQ2hhdFRyYW5zcG9ydCxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWREYXRhQ29udGVudEVycm9yLFxuICBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRTdHJlYW1QYXJ0RXJyb3IsXG4gIEludmFsaWRUb29sQXBwcm92YWxFcnJvcixcbiAgSW52YWxpZFRvb2xJbnB1dEVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb0ltYWdlR2VuZXJhdGVkRXJyb3IsXG4gIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IsXG4gIE5vT3V0cHV0R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIE5vU3VjaFByb3ZpZGVyRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvcixcbiAgb3V0cHV0X2V4cG9ydHMgYXMgT3V0cHV0LFxuICBSZXRyeUVycm9yLFxuICBTZXJpYWxKb2JFeGVjdXRvcixcbiAgVGV4dFN0cmVhbUNoYXRUcmFuc3BvcnQsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFRvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yLFxuICBUb29sQ2FsbFJlcGFpckVycm9yLFxuICBUb29sTG9vcEFnZW50LFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVSU1lc3NhZ2VTdHJlYW1FcnJvcixcbiAgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUyxcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3IsXG4gIGFkZFRvb2xJbnB1dEV4YW1wbGVzTWlkZGxld2FyZSxcbiAgYXNTY2hlbWE1IGFzIGFzU2NoZW1hLFxuICBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGNhbGxDb21wbGV0aW9uQXBpLFxuICBjb25zdW1lU3RyZWFtLFxuICBjb252ZXJ0RmlsZUxpc3RUb0ZpbGVVSVBhcnRzLFxuICBjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzLFxuICBjb3NpbmVTaW1pbGFyaXR5LFxuICBjcmVhdGVBZ2VudFVJU3RyZWFtLFxuICBjcmVhdGVBZ2VudFVJU3RyZWFtUmVzcG9uc2UsXG4gIGNyZWF0ZUdhdGV3YXksXG4gIGNyZWF0ZUlkR2VuZXJhdG9yNSBhcyBjcmVhdGVJZEdlbmVyYXRvcixcbiAgY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgY3JlYXRlVGV4dFN0cmVhbVJlc3BvbnNlLFxuICBjcmVhdGVVSU1lc3NhZ2VTdHJlYW0sXG4gIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlLFxuICBjdXN0b21Qcm92aWRlcixcbiAgZGVmYXVsdEVtYmVkZGluZ1NldHRpbmdzTWlkZGxld2FyZSxcbiAgZGVmYXVsdFNldHRpbmdzTWlkZGxld2FyZSxcbiAgZHluYW1pY1Rvb2wsXG4gIGVtYmVkLFxuICBlbWJlZE1hbnksXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZUltYWdlLFxuICBnZW5lcmF0ZVNwZWVjaCBhcyBleHBlcmltZW50YWxfZ2VuZXJhdGVTcGVlY2gsXG4gIHRyYW5zY3JpYmUgYXMgZXhwZXJpbWVudGFsX3RyYW5zY3JpYmUsXG4gIGV4dHJhY3RKc29uTWlkZGxld2FyZSxcbiAgZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUsXG4gIGdhdGV3YXkyIGFzIGdhdGV3YXksXG4gIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlSW1hZ2UsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGdldFN0YXRpY1Rvb2xOYW1lLFxuICBnZXRUZXh0RnJvbURhdGFVcmwsXG4gIGdldFRvb2xOYW1lLFxuICBnZXRUb29sT3JEeW5hbWljVG9vbE5hbWUsXG4gIGhhc1Rvb2xDYWxsLFxuICBpc0RhdGFVSVBhcnQsXG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAgaXNGaWxlVUlQYXJ0LFxuICBpc1JlYXNvbmluZ1VJUGFydCxcbiAgaXNTdGF0aWNUb29sVUlQYXJ0LFxuICBpc1RleHRVSVBhcnQsXG4gIGlzVG9vbE9yRHluYW1pY1Rvb2xVSVBhcnQsXG4gIGlzVG9vbFVJUGFydCxcbiAganNvblNjaGVtYSxcbiAgbGFzdEFzc2lzdGFudE1lc3NhZ2VJc0NvbXBsZXRlV2l0aEFwcHJvdmFsUmVzcG9uc2VzLFxuICBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoVG9vbENhbGxzLFxuICBtb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHBhcnNlSnNvbkV2ZW50U3RyZWFtMyBhcyBwYXJzZUpzb25FdmVudFN0cmVhbSxcbiAgcGFyc2VQYXJ0aWFsSnNvbixcbiAgcGlwZUFnZW50VUlTdHJlYW1Ub1Jlc3BvbnNlLFxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UsXG4gIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlLFxuICBwcnVuZU1lc3NhZ2VzLFxuICByZWFkVUlNZXNzYWdlU3RyZWFtLFxuICByZXJhbmssXG4gIHNhZmVWYWxpZGF0ZVVJTWVzc2FnZXMsXG4gIHNpbXVsYXRlUmVhZGFibGVTdHJlYW0sXG4gIHNpbXVsYXRlU3RyZWFtaW5nTWlkZGxld2FyZSxcbiAgc21vb3RoU3RyZWFtLFxuICBzdGVwQ291bnRJcyxcbiAgc3RyZWFtT2JqZWN0LFxuICBzdHJlYW1UZXh0LFxuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHRvb2wsXG4gIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVpTWVzc2FnZUNodW5rU2NoZW1hLFxuICB1c2VyTW9kZWxNZXNzYWdlU2NoZW1hLFxuICB2YWxpZGF0ZVVJTWVzc2FnZXMsXG4gIHdyYXBFbWJlZGRpbmdNb2RlbCxcbiAgd3JhcEltYWdlTW9kZWwsXG4gIHdyYXBMYW5ndWFnZU1vZGVsLFxuICB3cmFwUHJvdmlkZXIsXG4gIHpvZFNjaGVtYTMgYXMgem9kU2NoZW1hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZTE3IiwiZ2V0IiwiZW51bWVyYWJsZSIsImNyZWF0ZUdhdGV3YXkiLCJnYXRld2F5IiwiZ2F0ZXdheTIiLCJhc1NjaGVtYSIsImFzU2NoZW1hNSIsImNyZWF0ZUlkR2VuZXJhdG9yIiwiY3JlYXRlSWRHZW5lcmF0b3I1IiwiZHluYW1pY1Rvb2wiLCJnZW5lcmF0ZUlkIiwianNvblNjaGVtYSIsInBhcnNlSnNvbkV2ZW50U3RyZWFtIiwicGFyc2VKc29uRXZlbnRTdHJlYW0zIiwidG9vbCIsInpvZFNjaGVtYSIsInpvZFNjaGVtYTMiLCJnZXRFcnJvck1lc3NhZ2UiLCJnZXRFcnJvck1lc3NhZ2U1Iiwid2l0aFVzZXJBZ2VudFN1ZmZpeCIsIndpdGhVc2VyQWdlbnRTdWZmaXgyIiwiQUlTREtFcnJvciIsIkFJU0RLRXJyb3IxOCIsIkFQSUNhbGxFcnJvciIsIkVtcHR5UmVzcG9uc2VCb2R5RXJyb3IiLCJJbnZhbGlkUHJvbXB0RXJyb3IiLCJJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IiLCJKU09OUGFyc2VFcnJvciIsIkxvYWRBUElLZXlFcnJvciIsIkxvYWRTZXR0aW5nRXJyb3IiLCJOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciIsIk5vU3VjaE1vZGVsRXJyb3IiLCJUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yIiwiVHlwZVZhbGlkYXRpb25FcnJvciIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIiwibmFtZSIsIm1hcmtlciIsInN5bWJvbCIsIlN5bWJvbCIsImZvciIsIl9hIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJjb25zdHJ1Y3RvciIsInBhcmFtZXRlciIsInZhbHVlIiwibWVzc2FnZSIsImlzSW5zdGFuY2UiLCJlcnJvciIsImhhc01hcmtlciIsIkFJU0RLRXJyb3IyIiwibmFtZTIiLCJtYXJrZXIyIiwic3ltYm9sMiIsIl9hMiIsIkludmFsaWRTdHJlYW1QYXJ0RXJyb3IiLCJjaHVuayIsIkFJU0RLRXJyb3IzIiwibmFtZTMiLCJtYXJrZXIzIiwic3ltYm9sMyIsIl9hMyIsIkludmFsaWRUb29sQXBwcm92YWxFcnJvciIsImFwcHJvdmFsSWQiLCJBSVNES0Vycm9yNCIsIm5hbWU0IiwibWFya2VyNCIsInN5bWJvbDQiLCJfYTQiLCJJbnZhbGlkVG9vbElucHV0RXJyb3IiLCJ0b29sSW5wdXQiLCJ0b29sTmFtZSIsImNhdXNlIiwiQUlTREtFcnJvcjUiLCJuYW1lNSIsIm1hcmtlcjUiLCJzeW1ib2w1IiwiX2E1IiwiVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3IiLCJ0b29sQ2FsbElkIiwiQUlTREtFcnJvcjYiLCJuYW1lNiIsIm1hcmtlcjYiLCJzeW1ib2w2IiwiX2E2IiwiTm9JbWFnZUdlbmVyYXRlZEVycm9yIiwicmVzcG9uc2VzIiwiQUlTREtFcnJvcjciLCJuYW1lNyIsIm1hcmtlcjciLCJzeW1ib2w3IiwiX2E3IiwiTm9PYmplY3RHZW5lcmF0ZWRFcnJvciIsInRleHQiLCJ0ZXh0MiIsInJlc3BvbnNlIiwidXNhZ2UiLCJmaW5pc2hSZWFzb24iLCJBSVNES0Vycm9yOCIsIm5hbWU4IiwibWFya2VyOCIsInN5bWJvbDgiLCJfYTgiLCJOb091dHB1dEdlbmVyYXRlZEVycm9yIiwiQUlTREtFcnJvcjkiLCJOb1NwZWVjaEdlbmVyYXRlZEVycm9yIiwib3B0aW9ucyIsIkFJU0RLRXJyb3IxMCIsIm5hbWU5IiwibWFya2VyOSIsInN5bWJvbDkiLCJfYTkiLCJOb1N1Y2hUb29sRXJyb3IiLCJhdmFpbGFibGVUb29scyIsImpvaW4iLCJBSVNES0Vycm9yMTEiLCJnZXRFcnJvck1lc3NhZ2UyIiwibmFtZTEwIiwibWFya2VyMTAiLCJzeW1ib2wxMCIsIl9hMTAiLCJUb29sQ2FsbFJlcGFpckVycm9yIiwib3JpZ2luYWxFcnJvciIsIkFJU0RLRXJyb3IxMiIsIlVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3IiLCJ2ZXJzaW9uIiwicHJvdmlkZXIiLCJtb2RlbElkIiwiQUlTREtFcnJvcjEzIiwibmFtZTExIiwibWFya2VyMTEiLCJzeW1ib2wxMSIsIl9hMTEiLCJVSU1lc3NhZ2VTdHJlYW1FcnJvciIsImNodW5rVHlwZSIsImNodW5rSWQiLCJBSVNES0Vycm9yMTQiLCJuYW1lMTIiLCJtYXJrZXIxMiIsInN5bWJvbDEyIiwiX2ExMiIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udGVudCIsIkFJU0RLRXJyb3IxNSIsIm5hbWUxMyIsIm1hcmtlcjEzIiwic3ltYm9sMTMiLCJfYTEzIiwiSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IiLCJyb2xlIiwiQUlTREtFcnJvcjE2IiwibmFtZTE0IiwibWFya2VyMTQiLCJzeW1ib2wxNCIsIl9hMTQiLCJNZXNzYWdlQ29udmVyc2lvbkVycm9yIiwib3JpZ2luYWxNZXNzYWdlIiwiRG93bmxvYWRFcnJvciIsIkFJU0RLRXJyb3IxNyIsIm5hbWUxNSIsIm1hcmtlcjE1Iiwic3ltYm9sMTUiLCJfYTE1IiwiUmV0cnlFcnJvciIsInJlYXNvbiIsImVycm9ycyIsImxhc3RFcnJvciIsImxlbmd0aCIsImZvcm1hdFdhcm5pbmciLCJ3YXJuaW5nIiwibW9kZWwiLCJwcmVmaXgiLCJ0eXBlIiwiZmVhdHVyZSIsImRldGFpbHMiLCJKU09OIiwic3RyaW5naWZ5IiwiRklSU1RfV0FSTklOR19JTkZPX01FU1NBR0UiLCJoYXNMb2dnZWRCZWZvcmUiLCJsb2dXYXJuaW5ncyIsIndhcm5pbmdzIiwibG9nZ2VyIiwiZ2xvYmFsVGhpcyIsIkFJX1NES19MT0dfV0FSTklOR1MiLCJjb25zb2xlIiwiaW5mbyIsIndhcm4iLCJsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nIiwiYXNFbWJlZGRpbmdNb2RlbFYzIiwic3BlY2lmaWNhdGlvblZlcnNpb24iLCJQcm94eSIsInByb3AiLCJhc0ltYWdlTW9kZWxWMyIsImFzTGFuZ3VhZ2VNb2RlbFYzIiwiYXJncyIsInJlc3VsdCIsImRvR2VuZXJhdGUiLCJjb252ZXJ0VjJGaW5pc2hSZWFzb25Ub1YzIiwiY29udmVydFYyVXNhZ2VUb1YzIiwiZG9TdHJlYW0iLCJzdHJlYW0iLCJjb252ZXJ0VjJTdHJlYW1Ub1YzIiwicGlwZVRocm91Z2giLCJUcmFuc2Zvcm1TdHJlYW0iLCJ0cmFuc2Zvcm0iLCJjb250cm9sbGVyIiwiZW5xdWV1ZSIsInVuaWZpZWQiLCJyYXciLCJpbnB1dFRva2VucyIsInRvdGFsIiwibm9DYWNoZSIsImNhY2hlUmVhZCIsImNhY2hlZElucHV0VG9rZW5zIiwiY2FjaGVXcml0ZSIsIm91dHB1dFRva2VucyIsInJlYXNvbmluZyIsInJlYXNvbmluZ1Rva2VucyIsImFzU3BlZWNoTW9kZWxWMyIsImFzVHJhbnNjcmlwdGlvbk1vZGVsVjMiLCJyZXNvbHZlTGFuZ3VhZ2VNb2RlbCIsInVuc3VwcG9ydGVkTW9kZWwiLCJnZXRHbG9iYWxQcm92aWRlciIsImxhbmd1YWdlTW9kZWwiLCJyZXNvbHZlRW1iZWRkaW5nTW9kZWwiLCJlbWJlZGRpbmdNb2RlbCIsInJlc29sdmVUcmFuc2NyaXB0aW9uTW9kZWwiLCJfYTE3IiwiX2IiLCJ0cmFuc2NyaXB0aW9uTW9kZWwiLCJjYWxsIiwicmVzb2x2ZVNwZWVjaE1vZGVsIiwic3BlZWNoTW9kZWwiLCJyZXNvbHZlSW1hZ2VNb2RlbCIsImltYWdlTW9kZWwiLCJBSV9TREtfREVGQVVMVF9QUk9WSURFUiIsImdldFRvdGFsVGltZW91dE1zIiwidGltZW91dCIsInRvdGFsTXMiLCJnZXRTdGVwVGltZW91dE1zIiwic3RlcE1zIiwiZ2V0Q2h1bmtUaW1lb3V0TXMiLCJjaHVua01zIiwiaXNVcmxTdXBwb3J0ZWQiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IiwiaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzIiwibWVkaWFUeXBlIiwiYnl0ZXNQcmVmaXgiLCJhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXMiLCJzdHJpcElEMyIsImRhdGEiLCJieXRlcyIsImlkM1NpemUiLCJzbGljZSIsInN0cmlwSUQzVGFnc0lmUHJlc2VudCIsImhhc0lkMyIsInN0YXJ0c1dpdGgiLCJkZXRlY3RNZWRpYVR5cGUiLCJzaWduYXR1cmVzIiwicHJvY2Vzc2VkRGF0YSIsInN1YnN0cmluZyIsIk1hdGgiLCJtaW4iLCJzaWduYXR1cmUiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsIkRvd25sb2FkRXJyb3IyIiwiZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50IiwiVkVSU0lPTiIsImRvd25sb2FkIiwidXJsIiwidXJsVGV4dCIsInRvU3RyaW5nIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsImNyZWF0ZURlZmF1bHREb3dubG9hZEZ1bmN0aW9uIiwiZG93bmxvYWQyIiwicmVxdWVzdGVkRG93bmxvYWRzIiwiUHJvbWlzZSIsIm1hcCIsInJlcXVlc3RlZERvd25sb2FkIiwiaXNVcmxTdXBwb3J0ZWRCeU1vZGVsIiwiQUlTREtFcnJvcjE5IiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheTIiLCJjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IiwieiIsInNwbGl0RGF0YVVybCIsImRhdGFVcmwiLCJoZWFkZXIiLCJiYXNlNjRDb250ZW50Iiwic3BsaXQiLCJkYXRhQ29udGVudFNjaGVtYSIsInVuaW9uIiwic3RyaW5nIiwiaW5zdGFuY2VvZiIsIkFycmF5QnVmZmVyIiwiY3VzdG9tIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjNEYXRhQ29udGVudCIsIlVSTCIsInByb3RvY29sIiwiZGF0YVVybE1lZGlhVHlwZSIsImNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nIiwiY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5IiwiYXNBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQiLCJwcm9tcHQiLCJzdXBwb3J0ZWRVcmxzIiwiZG93bmxvYWRlZEFzc2V0cyIsImRvd25sb2FkQXNzZXRzIiwibWVzc2FnZXMiLCJzeXN0ZW0iLCJwcm92aWRlck9wdGlvbnMiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSIsImNvbWJpbmVkTWVzc2FnZXMiLCJwdXNoIiwibGFzdENvbWJpbmVkTWVzc2FnZSIsImF0IiwicGFydCIsImNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydCIsImZpbHRlciIsImZpbGVuYW1lIiwiaW5wdXQiLCJwcm92aWRlckV4ZWN1dGVkIiwib3V0cHV0IiwibWFwVG9vbFJlc3VsdE91dHB1dCIsImFwcHJvdmVkIiwiX2V4aGF1c3RpdmVDaGVjayIsInBsYW5uZWREb3dubG9hZHMiLCJmbGF0IiwiaW1hZ2UiLCJpZ25vcmVkIiwiZG93bmxvYWRlZEZpbGVzIiwiZnJvbUVudHJpZXMiLCJmaWxlIiwib3JpZ2luYWxEYXRhIiwiRXJyb3IiLCJjb252ZXJ0ZWREYXRhIiwiY29udmVydGVkTWVkaWFUeXBlIiwiZG93bmxvYWRlZEZpbGUiLCJpdGVtIiwiZ2V0RXJyb3JNZXNzYWdlMyIsImNyZWF0ZVRvb2xNb2RlbE91dHB1dCIsInRvb2wyIiwiZXJyb3JNb2RlIiwidG9KU09OVmFsdWUiLCJ0b01vZGVsT3V0cHV0IiwicHJlcGFyZUNhbGxTZXR0aW5ncyIsIm1heE91dHB1dFRva2VucyIsInRlbXBlcmF0dXJlIiwidG9wUCIsInRvcEsiLCJwcmVzZW5jZVBlbmFsdHkiLCJmcmVxdWVuY3lQZW5hbHR5Iiwic2VlZCIsInN0b3BTZXF1ZW5jZXMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJpc05vbkVtcHR5T2JqZWN0Iiwib2JqZWN0MiIsImtleXMiLCJwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlIiwidG9vbHMiLCJ0b29sQ2hvaWNlIiwiYWN0aXZlVG9vbHMiLCJmaWx0ZXJlZFRvb2xzIiwiZW50cmllcyIsImluY2x1ZGVzIiwibGFuZ3VhZ2VNb2RlbFRvb2xzIiwidG9vbFR5cGUiLCJkZXNjcmlwdGlvbiIsImlucHV0U2NoZW1hIiwiaW5wdXRFeGFtcGxlcyIsInN0cmljdCIsImlkIiwiZXhoYXVzdGl2ZUNoZWNrIiwiSW52YWxpZFByb21wdEVycm9yMiIsInNhZmVWYWxpZGF0ZVR5cGVzIiwiejYiLCJ6NSIsInozIiwiejIiLCJqc29uVmFsdWVTY2hlbWEiLCJsYXp5IiwibnVsbCIsIm51bWJlciIsImJvb2xlYW4iLCJyZWNvcmQiLCJvcHRpb25hbCIsImFycmF5IiwicHJvdmlkZXJNZXRhZGF0YVNjaGVtYSIsIno0IiwidGV4dFBhcnRTY2hlbWEiLCJvYmplY3QiLCJsaXRlcmFsIiwiaW1hZ2VQYXJ0U2NoZW1hIiwiZmlsZVBhcnRTY2hlbWEiLCJyZWFzb25pbmdQYXJ0U2NoZW1hIiwidG9vbENhbGxQYXJ0U2NoZW1hIiwidW5rbm93biIsIm91dHB1dFNjaGVtYSIsImRpc2NyaW1pbmF0ZWRVbmlvbiIsImZpbGVJZCIsInRvb2xSZXN1bHRQYXJ0U2NoZW1hIiwidG9vbEFwcHJvdmFsUmVxdWVzdFNjaGVtYSIsInRvb2xBcHByb3ZhbFJlc3BvbnNlU2NoZW1hIiwic3lzdGVtTW9kZWxNZXNzYWdlU2NoZW1hIiwidXNlck1vZGVsTWVzc2FnZVNjaGVtYSIsImFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYSIsInRvb2xNb2RlbE1lc3NhZ2VTY2hlbWEiLCJtb2RlbE1lc3NhZ2VTY2hlbWEiLCJzdGFuZGFyZGl6ZVByb21wdCIsInZhbGlkYXRpb25SZXN1bHQiLCJzY2hlbWEiLCJzdWNjZXNzIiwiR2F0ZXdheUF1dGhlbnRpY2F0aW9uRXJyb3IiLCJBSVNES0Vycm9yMjAiLCJ3cmFwR2F0ZXdheUVycm9yIiwiaXNQcm9kdWN0aW9uRW52IiwicHJvY2VzcyIsIm1vcmVJbmZvVVJMIiwiYXNzaWduIiwiYXNzZW1ibGVPcGVyYXRpb25OYW1lIiwib3BlcmF0aW9uSWQiLCJ0ZWxlbWV0cnkiLCJmdW5jdGlvbklkIiwiZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMiLCJzZXR0aW5ncyIsInJlZHVjZSIsImF0dHJpYnV0ZXMiLCJrZXkiLCJ0b3RhbFRpbWVvdXRNcyIsIm1ldGFkYXRhIiwidHJhY2UiLCJub29wVHJhY2VyIiwic3RhcnRTcGFuIiwibm9vcFNwYW4iLCJzdGFydEFjdGl2ZVNwYW4iLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJzcGFuQ29udGV4dCIsIm5vb3BTcGFuQ29udGV4dCIsInNldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZXMiLCJhZGRFdmVudCIsImFkZExpbmsiLCJhZGRMaW5rcyIsInNldFN0YXR1cyIsInVwZGF0ZU5hbWUiLCJlbmQiLCJpc1JlY29yZGluZyIsInJlY29yZEV4Y2VwdGlvbiIsInRyYWNlSWQiLCJzcGFuSWQiLCJ0cmFjZUZsYWdzIiwiZ2V0VHJhY2VyIiwiaXNFbmFibGVkIiwidHJhY2VyIiwiU3BhblN0YXR1c0NvZGUiLCJjb250ZXh0IiwicmVjb3JkU3BhbiIsImZuIiwiZW5kV2hlbkRvbmUiLCJzcGFuIiwiY3R4IiwiYWN0aXZlIiwid2l0aCIsInJlY29yZEVycm9yT25TcGFuIiwic3RhY2siLCJjb2RlIiwiRVJST1IiLCJzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzIiwicmVzdWx0QXR0cmlidXRlcyIsInJlY29yZElucHV0cyIsInJlY29yZE91dHB1dHMiLCJzdHJpbmdpZnlGb3JUZWxlbWV0cnkiLCJhc0xhbmd1YWdlTW9kZWxVc2FnZSIsImlucHV0VG9rZW5EZXRhaWxzIiwibm9DYWNoZVRva2VucyIsImNhY2hlUmVhZFRva2VucyIsImNhY2hlV3JpdGVUb2tlbnMiLCJvdXRwdXRUb2tlbkRldGFpbHMiLCJ0ZXh0VG9rZW5zIiwidG90YWxUb2tlbnMiLCJhZGRUb2tlbkNvdW50cyIsImNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UiLCJhZGRMYW5ndWFnZU1vZGVsVXNhZ2UiLCJ1c2FnZTEiLCJ1c2FnZTIiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaSIsIl9qIiwidG9rZW5Db3VudDEiLCJ0b2tlbkNvdW50MiIsImFkZEltYWdlTW9kZWxVc2FnZSIsIm1lcmdlT2JqZWN0cyIsImJhc2UiLCJvdmVycmlkZXMiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm92ZXJyaWRlc1ZhbHVlIiwiYmFzZVZhbHVlIiwiaXNTb3VyY2VPYmplY3QiLCJEYXRlIiwiUmVnRXhwIiwiaXNUYXJnZXRPYmplY3QiLCJBUElDYWxsRXJyb3IyIiwiZGVsYXkiLCJnZXRFcnJvck1lc3NhZ2U0IiwiaXNBYm9ydEVycm9yIiwiZ2V0UmV0cnlEZWxheUluTXMiLCJleHBvbmVudGlhbEJhY2tvZmZEZWxheSIsInJlc3BvbnNlSGVhZGVycyIsIm1zIiwicmV0cnlBZnRlck1zIiwidGltZW91dE1zIiwicGFyc2VGbG9hdCIsImlzTmFOIiwicmV0cnlBZnRlciIsInRpbWVvdXRTZWNvbmRzIiwicGFyc2UiLCJub3ciLCJyZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZSZXNwZWN0aW5nUmV0cnlIZWFkZXJzIiwibWF4UmV0cmllcyIsImluaXRpYWxEZWxheUluTXMiLCJiYWNrb2ZmRmFjdG9yIiwiYWJvcnRTaWduYWwiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImRlbGF5SW5NcyIsImVycm9yTWVzc2FnZSIsIm5ld0Vycm9ycyIsInRyeU51bWJlciIsImlzUmV0cnlhYmxlIiwicHJlcGFyZVJldHJpZXMiLCJtYXhSZXRyaWVzUmVzdWx0IiwicmV0cnkiLCJjb2xsZWN0VG9vbEFwcHJvdmFscyIsImxhc3RNZXNzYWdlIiwiYXBwcm92ZWRUb29sQXBwcm92YWxzIiwiZGVuaWVkVG9vbEFwcHJvdmFscyIsInRvb2xDYWxsc0J5VG9vbENhbGxJZCIsInRvb2xBcHByb3ZhbFJlcXVlc3RzQnlBcHByb3ZhbElkIiwidG9vbFJlc3VsdHMiLCJhcHByb3ZhbFJlc3BvbnNlcyIsImFwcHJvdmFsUmVzcG9uc2UiLCJhcHByb3ZhbFJlcXVlc3QiLCJ0b29sQ2FsbCIsImFwcHJvdmFsIiwiZXhlY3V0ZVRvb2wiLCJleGVjdXRlVG9vbENhbGwiLCJleHBlcmltZW50YWxfY29udGV4dCIsIm9uUHJlbGltaW5hcnlUb29sUmVzdWx0IiwiZXhlY3V0ZSIsImJpbmQiLCJwcmVsaW1pbmFyeSIsImR5bmFtaWMiLCJwcm92aWRlck1ldGFkYXRhIiwiZXh0cmFjdFRleHRDb250ZW50IiwicGFydHMiLCJjb250ZW50MiIsImNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkzIiwiY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDIiLCJEZWZhdWx0R2VuZXJhdGVkRmlsZSIsImlzVWludDhBcnJheSIsImJhc2U2NERhdGEiLCJ1aW50OEFycmF5RGF0YSIsImJhc2U2NCIsInVpbnQ4QXJyYXkiLCJEZWZhdWx0R2VuZXJhdGVkRmlsZVdpdGhUeXBlIiwiaXNBcHByb3ZhbE5lZWRlZCIsIm5lZWRzQXBwcm92YWwiLCJvdXRwdXRfZXhwb3J0cyIsImNob2ljZSIsImpzb24iLCJUeXBlVmFsaWRhdGlvbkVycm9yMiIsImFzU2NoZW1hMiIsInJlc29sdmUiLCJzYWZlUGFyc2VKU09OIiwic2FmZVBhcnNlSlNPTjIiLCJzYWZlVmFsaWRhdGVUeXBlczIiLCJmaXhKc29uIiwibGFzdFZhbGlkSW5kZXgiLCJsaXRlcmFsU3RhcnQiLCJwcm9jZXNzVmFsdWVTdGFydCIsImNoYXIiLCJpIiwic3dhcFN0YXRlIiwicG9wIiwicHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUiLCJwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlIiwiY3VycmVudFN0YXRlIiwicGFydGlhbExpdGVyYWwiLCJzdGF0ZSIsInBhcnNlUGFydGlhbEpzb24iLCJqc29uVGV4dCIsInJlc3BvbnNlRm9ybWF0IiwicGFyc2VDb21wbGV0ZU91dHB1dCIsInBhcnNlUGFydGlhbE91dHB1dCIsInBhcnRpYWwiLCJjcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtIiwidGhlbiIsImpzb25TY2hlbWEyIiwiY29udGV4dDIiLCJwYXJzZVJlc3VsdCIsImVsZW1lbnQiLCJpbnB1dEVsZW1lbnRTY2hlbWEiLCJlbGVtZW50U2NoZW1hIiwiJHNjaGVtYSIsIml0ZW1TY2hlbWEiLCJwcm9wZXJ0aWVzIiwiZWxlbWVudHMiLCJpdGVtcyIsInJlcXVpcmVkIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJvdXRlclZhbHVlIiwicmF3RWxlbWVudHMiLCJwYXJzZWRFbGVtZW50cyIsInJhd0VsZW1lbnQiLCJwdWJsaXNoZWRFbGVtZW50cyIsInBhcnRpYWxPdXRwdXQiLCJjaG9pY2VPcHRpb25zIiwiZW51bSIsInBvdGVudGlhbE1hdGNoZXMiLCJjaG9pY2VPcHRpb24iLCJhc1NjaGVtYTMiLCJzYWZlUGFyc2VKU09OMyIsInNhZmVWYWxpZGF0ZVR5cGVzMyIsInBhcnNlVG9vbENhbGwiLCJyZXBhaXJUb29sQ2FsbCIsInBhcnNlUHJvdmlkZXJFeGVjdXRlZER5bmFtaWNUb29sQ2FsbCIsImRvUGFyc2VUb29sQ2FsbCIsInJlcGFpcmVkVG9vbENhbGwiLCJyZXBhaXJFcnJvciIsInBhcnNlZElucHV0IiwiaW52YWxpZCIsInRpdGxlIiwidHJpbSIsIkRlZmF1bHRTdGVwUmVzdWx0IiwicmF3RmluaXNoUmVhc29uIiwicmVxdWVzdCIsInJlYXNvbmluZ1RleHQiLCJmaWxlcyIsInNvdXJjZXMiLCJ0b29sQ2FsbHMiLCJzdGF0aWNUb29sQ2FsbHMiLCJkeW5hbWljVG9vbENhbGxzIiwic3RhdGljVG9vbFJlc3VsdHMiLCJ0b29sUmVzdWx0IiwiZHluYW1pY1Rvb2xSZXN1bHRzIiwic3RlcENvdW50SXMiLCJzdGVwQ291bnQiLCJzdGVwcyIsImhhc1Rvb2xDYWxsIiwic29tZSIsImlzU3RvcENvbmRpdGlvbk1ldCIsInN0b3BDb25kaXRpb25zIiwiY29uZGl0aW9uIiwidG9SZXNwb25zZU1lc3NhZ2VzIiwiaW5wdXRDb250ZW50IiwicmVzcG9uc2VNZXNzYWdlcyIsInRvb2xSZXN1bHRDb250ZW50IiwibWVyZ2VBYm9ydFNpZ25hbHMiLCJzaWduYWxzIiwidmFsaWRTaWduYWxzIiwic2lnbmFsIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnRlZCIsImFib3J0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJvcmlnaW5hbEdlbmVyYXRlSWQiLCJzaXplIiwiZ2VuZXJhdGVUZXh0IiwibW9kZWxBcmciLCJtYXhSZXRyaWVzQXJnIiwic3RvcFdoZW4iLCJleHBlcmltZW50YWxfb3V0cHV0IiwiZXhwZXJpbWVudGFsX3RlbGVtZXRyeSIsImV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyIsImV4cGVyaW1lbnRhbF9wcmVwYXJlU3RlcCIsInByZXBhcmVTdGVwIiwiZXhwZXJpbWVudGFsX3JlcGFpclRvb2xDYWxsIiwiZXhwZXJpbWVudGFsX2Rvd25sb2FkIiwiX2ludGVybmFsIiwiZ2VuZXJhdGVJZDIiLCJvblN0ZXBGaW5pc2giLCJvbkZpbmlzaCIsInN0ZXBUaW1lb3V0TXMiLCJzdGVwQWJvcnRDb250cm9sbGVyIiwibWVyZ2VkQWJvcnRTaWduYWwiLCJBYm9ydFNpZ25hbCIsImNhbGxTZXR0aW5ncyIsImhlYWRlcnNXaXRoVXNlckFnZW50IiwiYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMiLCJpbml0aWFsUHJvbXB0IiwiaW5pdGlhbE1lc3NhZ2VzIiwibG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMiLCJ0b29sQXBwcm92YWwiLCJ0b29sT3V0cHV0cyIsImV4ZWN1dGVUb29scyIsInRvb2xDb250ZW50Iiwib3V0cHV0MiIsIm1vZGVsT3V0cHV0Iiwib3BlbmFpIiwicHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMiLCJjYWxsU2V0dGluZ3MyIiwiY3VycmVudE1vZGVsUmVzcG9uc2UiLCJjbGllbnRUb29sQ2FsbHMiLCJjbGllbnRUb29sT3V0cHV0cyIsInBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscyIsIk1hcCIsInN0ZXBUaW1lb3V0SWQiLCJzZXRUaW1lb3V0Iiwic3RlcElucHV0TWVzc2FnZXMiLCJwcmVwYXJlU3RlcFJlc3VsdCIsInN0ZXBOdW1iZXIiLCJzdGVwTW9kZWwiLCJwcm9tcHRNZXNzYWdlcyIsInN0ZXBUb29sQ2hvaWNlIiwic3RlcFRvb2xzIiwiX2ExOCIsInNwYW4yIiwiX2ExOSIsIl9iMiIsIl9jMiIsIl9kMiIsIl9lMiIsIl9mMiIsIl9nMiIsIl9oMiIsInN0ZXBQcm92aWRlck9wdGlvbnMiLCJyZXNwb25zZURhdGEiLCJ0aW1lc3RhbXAiLCJib2R5IiwiYXNUb29sQ2FsbHMiLCJ0b0lTT1N0cmluZyIsInN0ZXBUb29sQ2FsbHMiLCJ0b29sQXBwcm92YWxSZXF1ZXN0cyIsIm9uSW5wdXRBdmFpbGFibGUiLCJpbnZhbGlkVG9vbENhbGxzIiwic3VwcG9ydHNEZWZlcnJlZFJlc3VsdHMiLCJoYXNSZXN1bHRJblJlc3BvbnNlIiwic2V0IiwiZGVsZXRlIiwic3RlcENvbnRlbnQiLCJhc0NvbnRlbnQiLCJ2YWx1ZXMiLCJjdXJyZW50U3RlcFJlc3VsdCIsInN0cnVjdHVyZWRDbG9uZSIsImNsZWFyVGltZW91dCIsImxhc3RTdGVwIiwidG90YWxVc2FnZSIsInRvdGFsVXNhZ2UyIiwic3RlcCIsInJlc29sdmVkT3V0cHV0Iiwib3V0cHV0U3BlY2lmaWNhdGlvbiIsIkRlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQiLCJfb3V0cHV0IiwiZmluYWxTdGVwIiwiY29udGVudFBhcnRzIiwiZmluZCIsInRvb2xDYWxsMiIsImlzRXJyb3IiLCJnZXRFcnJvck1lc3NhZ2U3IiwiVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIiwiY3JlYXRlSWRHZW5lcmF0b3IyIiwiRGVsYXllZFByb21pc2UiLCJpc0Fib3J0RXJyb3IyIiwicHJlcGFyZUhlYWRlcnMiLCJkZWZhdWx0SGVhZGVycyIsIkhlYWRlcnMiLCJoYXMiLCJjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2UiLCJ0ZXh0U3RyZWFtIiwiUmVzcG9uc2UiLCJUZXh0RW5jb2RlclN0cmVhbSIsIndyaXRlVG9TZXJ2ZXJSZXNwb25zZSIsIndyaXRlSGVhZCIsInJlYWRlciIsImdldFJlYWRlciIsInJlYWQiLCJkb25lIiwiY2FuQ29udGludWUiLCJ3cml0ZSIsInJlc29sdmUzIiwicGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlIiwiSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtIiwiZmx1c2giLCJVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTIiwiY29ubmVjdGlvbiIsImNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlIiwiY29uc3VtZVNzZVN0cmVhbSIsInNzZVN0cmVhbSIsInN0cmVhbTEiLCJzdHJlYW0yIiwidGVlIiwiZ2V0UmVzcG9uc2VVSU1lc3NhZ2VJZCIsIm9yaWdpbmFsTWVzc2FnZXMiLCJyZXNwb25zZU1lc3NhZ2VJZCIsInZhbGlkYXRlVHlwZXMiLCJ6NyIsImxhenlTY2hlbWEiLCJ1aU1lc3NhZ2VDaHVua1NjaGVtYSIsInN0cmljdE9iamVjdCIsImRlbHRhIiwiZXJyb3JUZXh0IiwiaW5wdXRUZXh0RGVsdGEiLCJzb3VyY2VJZCIsInRyYW5zaWVudCIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VNZXRhZGF0YSIsImlzRGF0YVVJTWVzc2FnZUNodW5rIiwiaXNEYXRhVUlQYXJ0IiwiaXNUZXh0VUlQYXJ0IiwiaXNGaWxlVUlQYXJ0IiwiaXNSZWFzb25pbmdVSVBhcnQiLCJpc1N0YXRpY1Rvb2xVSVBhcnQiLCJpc0R5bmFtaWNUb29sVUlQYXJ0IiwiaXNUb29sVUlQYXJ0IiwiaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydCIsImdldFN0YXRpY1Rvb2xOYW1lIiwiZ2V0VG9vbE5hbWUiLCJnZXRUb29sT3JEeW5hbWljVG9vbE5hbWUiLCJjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSIsImFjdGl2ZVRleHRQYXJ0cyIsImFjdGl2ZVJlYXNvbmluZ1BhcnRzIiwicGFydGlhbFRvb2xDYWxscyIsInByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0iLCJtZXNzYWdlTWV0YWRhdGFTY2hlbWEiLCJkYXRhUGFydFNjaGVtYXMiLCJydW5VcGRhdGVNZXNzYWdlSm9iIiwib25FcnJvciIsIm9uVG9vbENhbGwiLCJvbkRhdGEiLCJnZXRUb29sSW52b2NhdGlvbiIsInRvb2xJbnZvY2F0aW9ucyIsInRvb2xJbnZvY2F0aW9uIiwiaW52b2NhdGlvbiIsInVwZGF0ZVRvb2xQYXJ0IiwicGFydDIiLCJhbnlPcHRpb25zIiwiYW55UGFydCIsInJhd0lucHV0IiwiY2FsbFByb3ZpZGVyTWV0YWRhdGEiLCJ1cGRhdGVEeW5hbWljVG9vbFBhcnQiLCJ1cGRhdGVNZXNzYWdlTWV0YWRhdGEiLCJtZXJnZWRNZXRhZGF0YSIsInRleHRQYXJ0IiwicmVhc29uaW5nUGFydCIsInBhcnRpYWxUb29sQ2FsbCIsInBhcnRpYWxBcmdzIiwiZGF0YUNodW5rIiwiZXhpc3RpbmdVSVBhcnQiLCJjaHVua0FyZyIsImhhbmRsZVVJTWVzc2FnZVN0cmVhbUZpbmlzaCIsImlzQWJvcnRlZCIsImlkSW5qZWN0ZWRTdHJlYW0iLCJzdGFydENodW5rIiwiam9iIiwiZmluaXNoQ2FsbGVkIiwiY2FsbE9uRmluaXNoIiwiaXNDb250aW51YXRpb24iLCJyZXNwb25zZU1lc3NhZ2UiLCJjYW5jZWwiLCJwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSIsImNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0iLCJzb3VyY2UiLCJhc3luY0l0ZXJhdG9yIiwiZmluaXNoZWQiLCJjbGVhbnVwIiwiY2FuY2VsU3RyZWFtIiwicmVsZWFzZUxvY2siLCJlIiwibmV4dCIsInJldHVybiIsInRocm93IiwiZXJyIiwiY29uc3VtZVN0cmVhbSIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcyIsInJlaiIsImNyZWF0ZVN0aXRjaGFibGVTdHJlYW0iLCJpbm5lclN0cmVhbVJlYWRlcnMiLCJpc0Nsb3NlZCIsIndhaXRGb3JOZXdTdHJlYW0iLCJ0ZXJtaW5hdGUiLCJmb3JFYWNoIiwiY2xvc2UiLCJwcm9jZXNzUHVsbCIsInNoaWZ0IiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXJQYXJhbSIsInB1bGwiLCJhZGRTdHJlYW0iLCJpbm5lclN0cmVhbSIsInBlcmZvcm1hbmNlIiwiZ2V0RXJyb3JNZXNzYWdlNiIsInJ1blRvb2xzVHJhbnNmb3JtYXRpb24iLCJnZW5lcmF0b3JTdHJlYW0iLCJ0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIiLCJ0b29sUmVzdWx0c1N0cmVhbSIsIm91dHN0YW5kaW5nVG9vbFJlc3VsdHMiLCJTZXQiLCJ0b29sSW5wdXRzIiwiY2FuQ2xvc2UiLCJmaW5pc2hDaHVuayIsImF0dGVtcHRDbG9zZSIsImZvcndhcmRTdHJlYW0iLCJ0b29sRXhlY3V0aW9uSWQiLCJhZGQiLCJjYXRjaCIsImZpbmFsbHkiLCJwaXBlVG8iLCJXcml0YWJsZVN0cmVhbSIsIm9yaWdpbmFsR2VuZXJhdGVJZDIiLCJzdHJlYW1UZXh0IiwiZXhwZXJpbWVudGFsX3RyYW5zZm9ybSIsImluY2x1ZGVSYXdDaHVua3MiLCJvbkNodW5rIiwib25BYm9ydCIsIm5vdzIiLCJjaHVua1RpbWVvdXRNcyIsImNodW5rQWJvcnRDb250cm9sbGVyIiwiRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQiLCJ0cmFuc2Zvcm1zIiwiY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtIiwiZmlyc3RUZXh0Q2h1bmtJZCIsInRleHRDaHVuayIsInRleHRQcm92aWRlck1ldGFkYXRhIiwibGFzdFB1Ymxpc2hlZEpzb24iLCJwdWJsaXNoVGV4dENodW5rIiwiY3VycmVudEpzb24iLCJfdG90YWxVc2FnZSIsIl9maW5pc2hSZWFzb24iLCJfcmF3RmluaXNoUmVhc29uIiwiX3N0ZXBzIiwic3RlcEZpbmlzaCIsInJlY29yZGVkQ29udGVudCIsInJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcyIsInJlY29yZGVkRmluaXNoUmVhc29uIiwicmVjb3JkZWRSYXdGaW5pc2hSZWFzb24iLCJyZWNvcmRlZFRvdGFsVXNhZ2UiLCJyZWNvcmRlZFJlcXVlc3QiLCJyZWNvcmRlZFdhcm5pbmdzIiwicmVjb3JkZWRTdGVwcyIsInJvb3RTcGFuIiwiYWN0aXZlVGV4dENvbnRlbnQiLCJhY3RpdmVSZWFzb25pbmdDb250ZW50IiwiZXZlbnRQcm9jZXNzb3IiLCJhY3RpdmVUZXh0IiwiYWN0aXZlUmVhc29uaW5nIiwic3RlcE1lc3NhZ2VzIiwic2VsZiIsInN0aXRjaGFibGVTdHJlYW0iLCJjbG9zZVN0cmVhbSIsInN0b3BTdHJlYW0iLCJiYXNlU3RyZWFtIiwicm9vdFNwYW5BcmciLCJpbml0aWFsUmVzcG9uc2VNZXNzYWdlcyIsImxvY2FsRGVuaWVkVG9vbEFwcHJvdmFscyIsImRlbmllZFByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzIiwidG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyIiwidG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW0iLCJyZXN1bHQyIiwibG9jYWxUb29sQ29udGVudCIsInN0cmVhbVN0ZXAiLCJjdXJyZW50U3RlcCIsImluY2x1ZGVSYXdDaHVua3MyIiwiY2h1bmtUaW1lb3V0SWQiLCJyZXNldENodW5rVGltZW91dCIsImNsZWFyQ2h1bmtUaW1lb3V0IiwiY2xlYXJTdGVwVGltZW91dCIsImRvU3RyZWFtU3BhbiIsInN0YXJ0VGltZXN0YW1wTXMiLCJkb1N0cmVhbVNwYW4yIiwic3RyZWFtV2l0aFRvb2xSZXN1bHRzIiwic3RlcFJlcXVlc3QiLCJzdGVwVG9vbE91dHB1dHMiLCJhY3RpdmVUb29sQ2FsbFRvb2xOYW1lcyIsInN0ZXBGaW5pc2hSZWFzb24iLCJzdGVwUmF3RmluaXNoUmVhc29uIiwic3RlcFVzYWdlIiwic3RlcFByb3ZpZGVyTWV0YWRhdGEiLCJzdGVwRmlyc3RDaHVuayIsInN0ZXBSZXNwb25zZSIsIm1zVG9GaXJzdENodW5rIiwibXNUb0ZpbmlzaCIsIm9uSW5wdXRTdGFydCIsIm9uSW5wdXREZWx0YSIsInN0ZXBUb29sQ2FsbHNKc29uIiwiY29tYmluZWRVc2FnZSIsInRvb2xPdXRwdXQiLCJoYXNSZXN1bHRJblN0ZXAiLCJ0ZWVTdHJlYW0iLCJmdWxsU3RyZWFtIiwiZXhwZXJpbWVudGFsX3BhcnRpYWxPdXRwdXRTdHJlYW0iLCJwYXJ0aWFsT3V0cHV0U3RyZWFtIiwiZWxlbWVudFN0cmVhbSIsImZ1bmN0aW9uYWxpdHkiLCJ0b1VJTWVzc2FnZVN0cmVhbSIsImdlbmVyYXRlTWVzc2FnZUlkIiwic2VuZFJlYXNvbmluZyIsInNlbmRTb3VyY2VzIiwic2VuZFN0YXJ0Iiwic2VuZEZpbmlzaCIsImlzRHluYW1pYyIsIm1lc3NhZ2VNZXRhZGF0YVZhbHVlIiwicGFydFR5cGUiLCJzb3VyY2VUeXBlIiwiaW5pdCIsInRvVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2UiLCJ0b1RleHRTdHJlYW1SZXNwb25zZSIsIlRvb2xMb29wQWdlbnQiLCJwcmVwYXJlQ2FsbCIsImJhc2VDYWxsQXJncyIsInByZXBhcmVkQ2FsbEFyZ3MiLCJpbnN0cnVjdGlvbnMiLCJjYWxsQXJncyIsImdlbmVyYXRlIiwiZ2VuZXJhdGVJZEZ1bmMiLCJnZXRFcnJvck1lc3NhZ2U4IiwiY3JlYXRlVUlNZXNzYWdlU3RyZWFtIiwib25nb2luZ1N0cmVhbVByb21pc2VzIiwiY29udHJvbGxlckFyZyIsInNhZmVFbnF1ZXVlIiwid3JpdGVyIiwibWVyZ2UiLCJzdHJlYW1BcmciLCJ3YWl0Rm9yU3RyZWFtcyIsInJlYWRVSU1lc3NhZ2VTdHJlYW0iLCJ0ZXJtaW5hdGVPbkVycm9yIiwiaGFzRXJyb3JlZCIsIm91dHB1dFN0cmVhbSIsImhhbmRsZUVycm9yIiwiaXNOb25OdWxsYWJsZSIsImNvbnZlcnRUb01vZGVsTWVzc2FnZXMiLCJtb2RlbE1lc3NhZ2VzIiwiaWdub3JlSW5jb21wbGV0ZVRvb2xDYWxscyIsInRleHRQYXJ0cyIsImFjYyIsImNvbnZlcnREYXRhUGFydCIsImJsb2NrIiwicHJvY2Vzc0Jsb2NrIiwiZGF0YVBhcnQiLCJ0b29sUGFydHMiLCJ0b29sUGFydCIsIlR5cGVWYWxpZGF0aW9uRXJyb3IzIiwibGF6eVNjaGVtYTIiLCJ2YWxpZGF0ZVR5cGVzMiIsInpvZFNjaGVtYTIiLCJ6OCIsInVpTWVzc2FnZXNTY2hlbWEiLCJuZXZlciIsIm5vbmVtcHR5Iiwic2FmZVZhbGlkYXRlVUlNZXNzYWdlcyIsIm1ldGFkYXRhU2NoZW1hIiwiZGF0YVNjaGVtYXMiLCJ2YWxpZGF0ZWRNZXNzYWdlcyIsImRhdGFQYXJ0cyIsImRhdGFOYW1lIiwiZGF0YVNjaGVtYSIsInZhbGlkYXRlVUlNZXNzYWdlcyIsImNyZWF0ZUFnZW50VUlTdHJlYW0iLCJhZ2VudCIsInVpTWVzc2FnZXMiLCJ1aU1lc3NhZ2VTdHJlYW1PcHRpb25zIiwiY3JlYXRlQWdlbnRVSVN0cmVhbVJlc3BvbnNlIiwicGlwZUFnZW50VUlTdHJlYW1Ub1Jlc3BvbnNlIiwid2l0aFVzZXJBZ2VudFN1ZmZpeDMiLCJlbWJlZCIsImVtYmVkZGluZyIsImRvRW1iZWRTcGFuIiwibW9kZWxSZXNwb25zZSIsImRvRW1iZWQiLCJlbWJlZGRpbmcyIiwiZW1iZWRkaW5ncyIsInRva2VucyIsIk5hTiIsImVtYmVkZGluZzMiLCJEZWZhdWx0RW1iZWRSZXN1bHQiLCJ3aXRoVXNlckFnZW50U3VmZml4NCIsInNwbGl0QXJyYXkiLCJhcnJheTIiLCJjaHVua1NpemUiLCJlbWJlZE1hbnkiLCJtYXhQYXJhbGxlbENhbGxzIiwiSW5maW5pdHkiLCJtYXhFbWJlZGRpbmdzUGVyQ2FsbCIsInN1cHBvcnRzUGFyYWxsZWxDYWxscyIsImVtYmVkZGluZ3MyIiwid2FybmluZ3MyIiwicHJvdmlkZXJNZXRhZGF0YTIiLCJlbWJlZGRpbmdzMyIsIkRlZmF1bHRFbWJlZE1hbnlSZXN1bHQiLCJ2YWx1ZUNodW5rcyIsInBhcmFsbGVsQ2h1bmtzIiwicGFyYWxsZWxDaHVuayIsInJlc3VsdHMiLCJwcm92aWRlck5hbWUiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5NCIsIndpdGhVc2VyQWdlbnRTdWZmaXg1IiwiZ2VuZXJhdGVJbWFnZSIsInByb21wdEFyZyIsIm4iLCJtYXhJbWFnZXNQZXJDYWxsIiwiYXNwZWN0UmF0aW8iLCJtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQiLCJpbnZva2VNb2RlbE1heEltYWdlc1BlckNhbGwiLCJjYWxsQ291bnQiLCJjZWlsIiwiY2FsbEltYWdlQ291bnRzIiwiZnJvbSIsIl8iLCJyZW1haW5kZXIiLCJjYWxsSW1hZ2VDb3VudCIsIm1hc2siLCJub3JtYWxpemVQcm9tcHQiLCJpbWFnZXMiLCJjdXJyZW50RW50cnkiLCJpbWFnZXNWYWx1ZSIsIkRlZmF1bHRHZW5lcmF0ZUltYWdlUmVzdWx0IiwiaXNGdW5jdGlvbiIsIkZ1bmN0aW9uIiwidG9JbWFnZU1vZGVsVjNGaWxlIiwiZGF0YUNvbnRlbnQiLCJ1aW50OERhdGEyIiwidWludDhEYXRhIiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlSW1hZ2UiLCJjcmVhdGVJZEdlbmVyYXRvcjMiLCJ3aXRoVXNlckFnZW50U3VmZml4NiIsImV4dHJhY3RSZWFzb25pbmdDb250ZW50IiwiaXNKU09OQXJyYXkiLCJpc0pTT05PYmplY3QiLCJUeXBlVmFsaWRhdGlvbkVycm9yNCIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMyIsImFzU2NoZW1hNCIsInNhZmVWYWxpZGF0ZVR5cGVzNCIsIm5vU2NoZW1hT3V0cHV0U3RyYXRlZ3kiLCJ2YWxpZGF0ZVBhcnRpYWxSZXN1bHQiLCJ0ZXh0RGVsdGEiLCJ2YWxpZGF0ZUZpbmFsUmVzdWx0IiwiY3JlYXRlRWxlbWVudFN0cmVhbSIsIm9iamVjdE91dHB1dFN0cmF0ZWd5IiwiYXJyYXlPdXRwdXRTdHJhdGVneSIsImxhdGVzdE9iamVjdCIsImlzRmlyc3REZWx0YSIsImlzRmluYWxEZWx0YSIsImlucHV0QXJyYXkiLCJyZXN1bHRBcnJheSIsInB1Ymxpc2hlZEVsZW1lbnRDb3VudCIsIm9yaWdpbmFsU3RyZWFtIiwiZW51bU91dHB1dFN0cmF0ZWd5IiwiZW51bVZhbHVlcyIsInBvc3NpYmxlRW51bVZhbHVlcyIsImVudW1WYWx1ZSIsImdldE91dHB1dFN0cmF0ZWd5IiwiSlNPTlBhcnNlRXJyb3IyIiwiVHlwZVZhbGlkYXRpb25FcnJvcjUiLCJzYWZlUGFyc2VKU09ONCIsInBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHQiLCJvdXRwdXRTdHJhdGVneSIsInBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHRXaXRoUmVwYWlyIiwicmVwYWlyVGV4dCIsInJlcGFpcmVkVGV4dCIsInZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0Iiwic2NoZW1hTmFtZSIsInNjaGVtYURlc2NyaXB0aW9uIiwib3JpZ2luYWxHZW5lcmF0ZUlkMyIsImdlbmVyYXRlT2JqZWN0IiwiZXhwZXJpbWVudGFsX3JlcGFpclRleHQiLCJjdXJyZW50RGF0ZSIsInJlc3VsdFByb3ZpZGVyTWV0YWRhdGEiLCJzdGFuZGFyZGl6ZWRQcm9tcHQiLCJnZW5lcmF0ZVJlc3VsdCIsInJlYXNvbmluZzIiLCJvYmplY3RUZXh0IiwiRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0IiwidG9Kc29uUmVzcG9uc2UiLCJjcmVhdGVJZEdlbmVyYXRvcjQiLCJEZWxheWVkUHJvbWlzZTIiLCJjb3NpbmVTaW1pbGFyaXR5IiwidmVjdG9yMSIsInZlY3RvcjIiLCJ2ZWN0b3IxTGVuZ3RoIiwidmVjdG9yMkxlbmd0aCIsIm1hZ25pdHVkZVNxdWFyZWQxIiwibWFnbml0dWRlU3F1YXJlZDIiLCJkb3RQcm9kdWN0IiwidmFsdWUxIiwidmFsdWUyIiwic3FydCIsImdldFRleHRGcm9tRGF0YVVybCIsIndpbmRvdyIsImF0b2IiLCJpc0RlZXBFcXVhbERhdGEiLCJvYmoxIiwib2JqMiIsImdldFRpbWUiLCJrZXlzMSIsImtleXMyIiwiU2VyaWFsSm9iRXhlY3V0b3IiLCJxdWV1ZSIsImlzUHJvY2Vzc2luZyIsInByb2Nlc3NRdWV1ZSIsInJ1biIsImRlbGF5RnVuY3Rpb24iLCJzaW11bGF0ZVJlYWRhYmxlU3RyZWFtIiwiY2h1bmtzIiwiY2h1bmtEZWxheUluTXMiLCJkZWxheTIiLCJvcmlnaW5hbEdlbmVyYXRlSWQ0Iiwic3RyZWFtT2JqZWN0IiwiRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCIsIl9vYmplY3QiLCJfdXNhZ2UiLCJfcHJvdmlkZXJNZXRhZGF0YSIsIl93YXJuaW5ncyIsIl9yZXF1ZXN0IiwiX3Jlc3BvbnNlIiwiY2FsbE9wdGlvbnMiLCJ0cmFuc2Zvcm1lciIsImFjY3VtdWxhdGVkVGV4dCIsImZ1bGxSZXNwb25zZSIsImxhdGVzdE9iamVjdEpzb24iLCJpc0ZpcnN0Q2h1bmsiLCJ0cmFuc2Zvcm1lZFN0cmVhbSIsImN1cnJlbnRPYmplY3RKc29uIiwicGFyc2VTdGF0ZSIsImZpbmFsVXNhZ2UiLCJwcm9tcHRUb2tlbnMiLCJjb21wbGV0aW9uVG9rZW5zIiwiZXJyb3IyIiwicGFydGlhbE9iamVjdFN0cmVhbSIsIndpdGhVc2VyQWdlbnRTdWZmaXg3IiwiRGVmYXVsdEdlbmVyYXRlZEF1ZGlvRmlsZSIsImZvcm1hdCIsIm1lZGlhVHlwZVBhcnRzIiwiZ2VuZXJhdGVTcGVlY2giLCJ2b2ljZSIsIm91dHB1dEZvcm1hdCIsInNwZWVkIiwibGFuZ3VhZ2UiLCJyZXNvbHZlZE1vZGVsIiwiYXVkaW8iLCJEZWZhdWx0U3BlZWNoUmVzdWx0IiwicHJ1bmVNZXNzYWdlcyIsImVtcHR5TWVzc2FnZXMiLCJtZXNzYWdlSW5kZXgiLCJrZWVwTGFzdE1lc3NhZ2VzQ291bnQiLCJrZXB0VG9vbENhbGxJZHMiLCJrZXB0QXBwcm92YWxJZHMiLCJ0b29sQ2FsbElkVG9Ub29sTmFtZSIsImFwcHJvdmFsSWRUb1Rvb2xOYW1lIiwib3JpZ2luYWxEZWxheSIsIkludmFsaWRBcmd1bWVudEVycm9yMiIsIkNIVU5LSU5HX1JFR0VYUFMiLCJ3b3JkIiwibGluZSIsInNtb290aFN0cmVhbSIsImNodW5raW5nIiwiZGV0ZWN0Q2h1bmsiLCJzZWdtZW50Iiwic2VnbWVudGVyIiwiYnVmZmVyIiwiaXRlcmF0b3IiLCJmaXJzdCIsIm1hdGNoIiwiY2h1bmtpbmdSZWdleCIsImFyZ3VtZW50IiwiZXhlYyIsImZsdXNoQnVmZmVyIiwiZGVmYXVsdEVtYmVkZGluZ1NldHRpbmdzTWlkZGxld2FyZSIsInRyYW5zZm9ybVBhcmFtcyIsInBhcmFtcyIsImRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUiLCJkZWZhdWx0VHJhbnNmb3JtIiwicmVwbGFjZSIsImV4dHJhY3RKc29uTWlkZGxld2FyZSIsImhhc0N1c3RvbVRyYW5zZm9ybSIsIndyYXBHZW5lcmF0ZSIsInJlc3QiLCJ0cmFuc2Zvcm1lZENvbnRlbnQiLCJ3cmFwU3RyZWFtIiwidGV4dEJsb2NrcyIsIlNVRkZJWF9CVUZGRVJfU0laRSIsInN0YXJ0RXZlbnQiLCJwaGFzZSIsInByZWZpeFN0cmlwcGVkIiwicHJlZml4TWF0Y2giLCJ0b1N0cmVhbSIsInJlbWFpbmluZyIsInRyaW1FbmQiLCJnZXRQb3RlbnRpYWxTdGFydEluZGV4Iiwic2VhcmNoZWRUZXh0IiwiZGlyZWN0SW5kZXgiLCJpbmRleE9mIiwic3VmZml4IiwiZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUiLCJ0YWdOYW1lIiwic2VwYXJhdG9yIiwic3RhcnRXaXRoUmVhc29uaW5nIiwib3BlbmluZ1RhZyIsImNsb3NpbmdUYWciLCJyZWdleHAiLCJtYXRjaGVzIiwibWF0Y2hBbGwiLCJ0ZXh0V2l0aG91dFJlYXNvbmluZyIsImJlZm9yZU1hdGNoIiwiYWZ0ZXJNYXRjaCIsInJlYXNvbmluZ0V4dHJhY3Rpb25zIiwiZGVsYXllZFRleHRTdGFydCIsImlzRmlyc3RSZWFzb25pbmciLCJpc0ZpcnN0VGV4dCIsImFmdGVyU3dpdGNoIiwiaXNSZWFzb25pbmciLCJpZENvdW50ZXIiLCJ0ZXh0SWQiLCJhY3RpdmVFeHRyYWN0aW9uIiwicHVibGlzaCIsIm5leHRUYWciLCJzdGFydEluZGV4IiwiZm91bmRGdWxsTWF0Y2giLCJzaW11bGF0ZVN0cmVhbWluZ01pZGRsZXdhcmUiLCJzaW11bGF0ZWRTdHJlYW0iLCJTdHJpbmciLCJkZWZhdWx0Rm9ybWF0RXhhbXBsZSIsImV4YW1wbGUiLCJhZGRUb29sSW5wdXRFeGFtcGxlc01pZGRsZXdhcmUiLCJyZW1vdmUiLCJ0cmFuc2Zvcm1lZFRvb2xzIiwiZm9ybWF0dGVkRXhhbXBsZXMiLCJleGFtcGxlc1NlY3Rpb24iLCJ0b29sRGVzY3JpcHRpb24iLCJ3cmFwTGFuZ3VhZ2VNb2RlbCIsIm1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlQXJnIiwicHJvdmlkZXJJZCIsInJldmVyc2UiLCJ3cmFwcGVkTW9kZWwiLCJkb1dyYXAiLCJvdmVycmlkZVByb3ZpZGVyIiwib3ZlcnJpZGVNb2RlbElkIiwib3ZlcnJpZGVTdXBwb3J0ZWRVcmxzIiwiZG9UcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1lZFBhcmFtcyIsIndyYXBFbWJlZGRpbmdNb2RlbCIsImRvV3JhcDIiLCJ3cmFwRW1iZWQiLCJvdmVycmlkZU1heEVtYmVkZGluZ3NQZXJDYWxsIiwib3ZlcnJpZGVTdXBwb3J0c1BhcmFsbGVsQ2FsbHMiLCJ3cmFwSW1hZ2VNb2RlbCIsImRvV3JhcDMiLCJvdmVycmlkZU1heEltYWdlc1BlckNhbGwiLCJtYXhJbWFnZXNQZXJDYWxsUmF3IiwiYXNQcm92aWRlclYzIiwidjJQcm92aWRlciIsInRleHRFbWJlZGRpbmdNb2RlbCIsInJlcmFua2luZ01vZGVsIiwid3JhcFByb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUiLCJpbWFnZU1vZGVsTWlkZGxld2FyZSIsInByb3ZpZGVyVjMiLCJOb1N1Y2hNb2RlbEVycm9yMiIsImN1c3RvbVByb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbHMiLCJlbWJlZGRpbmdNb2RlbHMiLCJpbWFnZU1vZGVscyIsInRyYW5zY3JpcHRpb25Nb2RlbHMiLCJzcGVlY2hNb2RlbHMiLCJyZXJhbmtpbmdNb2RlbHMiLCJmYWxsYmFja1Byb3ZpZGVyIiwiZmFsbGJhY2tQcm92aWRlckFyZyIsIm1vZGVsVHlwZSIsImV4cGVyaW1lbnRhbF9jdXN0b21Qcm92aWRlciIsIkFJU0RLRXJyb3IyMSIsIk5vU3VjaE1vZGVsRXJyb3IzIiwibmFtZTE2IiwibWFya2VyMTYiLCJzeW1ib2wxNiIsIl9hMTYiLCJOb1N1Y2hQcm92aWRlckVycm9yIiwiYXZhaWxhYmxlUHJvdmlkZXJzIiwiZXJyb3JOYW1lIiwiTm9TdWNoTW9kZWxFcnJvcjQiLCJjcmVhdGVQcm92aWRlclJlZ2lzdHJ5IiwicHJvdmlkZXJzIiwicmVnaXN0cnkiLCJEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSIsInJlZ2lzdGVyUHJvdmlkZXIiLCJleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSIsImdldFByb3ZpZGVyIiwic3BsaXRJZCIsInJlcmFuayIsImRvY3VtZW50cyIsInF1ZXJ5IiwidG9wTiIsIkRlZmF1bHRSZXJhbmtSZXN1bHQiLCJvcmlnaW5hbERvY3VtZW50cyIsInJhbmtpbmciLCJkb2N1bWVudHNUb1NlbmQiLCJkb2N1bWVudCIsImRvUmVyYW5rU3BhbiIsImRvUmVyYW5rIiwicmFua2luZzIiLCJyYW5raW5nMyIsIm9yaWdpbmFsSW5kZXgiLCJzY29yZSIsInJlbGV2YW5jZVNjb3JlIiwicmVyYW5rZWREb2N1bWVudHMiLCJ3aXRoVXNlckFnZW50U3VmZml4OCIsIkFJU0RLRXJyb3IyMiIsIk5vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yIiwidHJhbnNjcmliZSIsImF1ZGlvRGF0YSIsIkRlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0Iiwic2VnbWVudHMiLCJkdXJhdGlvbkluU2Vjb25kcyIsIndpdGhVc2VyQWdlbnRTdWZmaXg5IiwiZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MiIsInByb2Nlc3NUZXh0U3RyZWFtIiwib25UZXh0UGFydCIsIlRleHREZWNvZGVyU3RyZWFtIiwiZ2V0T3JpZ2luYWxGZXRjaCIsImNhbGxDb21wbGV0aW9uQXBpIiwiYXBpIiwiY3JlZGVudGlhbHMiLCJzdHJlYW1Qcm90b2NvbCIsInNldENvbXBsZXRpb24iLCJzZXRMb2FkaW5nIiwic2V0RXJyb3IiLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJmZXRjaDIiLCJhYm9ydENvbnRyb2xsZXIiLCJtZXRob2QiLCJzdHJlYW1QYXJ0IiwiZ2VuZXJhdGVJZEZ1bmMyIiwiY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyIsIkZpbGVMaXN0IiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlYWRlckV2ZW50Iiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJwYXJzZUpzb25FdmVudFN0cmVhbTIiLCJub3JtYWxpemVIZWFkZXJzIiwicmVzb2x2ZTIiLCJ3aXRoVXNlckFnZW50U3VmZml4MTAiLCJnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQzIiwiSHR0cENoYXRUcmFuc3BvcnQiLCJwcmVwYXJlU2VuZE1lc3NhZ2VzUmVxdWVzdCIsInByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3QiLCJzZW5kTWVzc2FnZXMiLCJyZXNvbHZlZEJvZHkiLCJyZXNvbHZlZEhlYWRlcnMiLCJyZXNvbHZlZENyZWRlbnRpYWxzIiwiYmFzZUhlYWRlcnMiLCJwcmVwYXJlZFJlcXVlc3QiLCJjaGF0SWQiLCJyZXF1ZXN0TWV0YWRhdGEiLCJ0cmlnZ2VyIiwicHJvY2Vzc1Jlc3BvbnNlU3RyZWFtIiwicmVjb25uZWN0VG9TdHJlYW0iLCJEZWZhdWx0Q2hhdFRyYW5zcG9ydCIsIkFic3RyYWN0Q2hhdCIsInRyYW5zcG9ydCIsInNlbmRBdXRvbWF0aWNhbGx5V2hlbiIsImFjdGl2ZVJlc3BvbnNlIiwiam9iRXhlY3V0b3IiLCJzZW5kTWVzc2FnZSIsIm1ha2VSZXF1ZXN0IiwidWlNZXNzYWdlIiwiZmlsZVBhcnRzIiwiZmluZEluZGV4IiwibSIsInJlcGxhY2VNZXNzYWdlIiwicHVzaE1lc3NhZ2UiLCJyZWdlbmVyYXRlIiwicmVzdW1lU3RyZWFtIiwiY2xlYXJFcnJvciIsImFkZFRvb2xBcHByb3ZhbFJlc3BvbnNlIiwidXBkYXRlUGFydCIsImFkZFRvb2xPdXRwdXQiLCJhZGRUb29sUmVzdWx0Iiwic3RvcCIsImlzQWJvcnQiLCJpc0Rpc2Nvbm5lY3QiLCJzbmFwc2hvdCIsInJlY29ubmVjdCIsInJlcGxhY2VMYXN0TWVzc2FnZSIsIlR5cGVFcnJvciIsInRvTG93ZXJDYXNlIiwiRGlyZWN0Q2hhdFRyYW5zcG9ydCIsImFnZW50T3B0aW9ucyIsIl9vcHRpb25zIiwibGFzdEFzc2lzdGFudE1lc3NhZ2VJc0NvbXBsZXRlV2l0aEFwcHJvdmFsUmVzcG9uc2VzIiwibGFzdFN0ZXBTdGFydEluZGV4IiwibGFzdEluZGV4IiwibGFzdFN0ZXBUb29sSW52b2NhdGlvbnMiLCJsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoVG9vbENhbGxzIiwidHJhbnNmb3JtVGV4dFRvVWlNZXNzYWdlU3RyZWFtIiwiVGV4dFN0cmVhbUNoYXRUcmFuc3BvcnQiLCJFeHBlcmltZW50YWxfQWdlbnQiLCJPdXRwdXQiLCJleHBlcmltZW50YWxfZ2VuZXJhdGVTcGVlY2giLCJleHBlcmltZW50YWxfdHJhbnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ai@6.0.39_zod@3.25.76/node_modules/ai/dist/index.mjs\n");

/***/ })

};
;