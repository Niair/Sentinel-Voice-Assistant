"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+lang-python@6.2.1";
exports.ids = ["vendor-chunks/@codemirror+lang-python@6.2.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@codemirror+lang-python@6.2.1/node_modules/@codemirror/lang-python/dist/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@codemirror+lang-python@6.2.1/node_modules/@codemirror/lang-python/dist/index.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   globalCompletion: () => (/* binding */ globalCompletion),\n/* harmony export */   localCompletionSource: () => (/* binding */ localCompletionSource),\n/* harmony export */   python: () => (/* binding */ python),\n/* harmony export */   pythonLanguage: () => (/* binding */ pythonLanguage)\n/* harmony export */ });\n/* harmony import */ var _lezer_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/python */ \"(ssr)/./node_modules/.pnpm/@lezer+python@1.1.18/node_modules/@lezer/python/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/.pnpm/@codemirror+language@6.12.1/node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/./node_modules/.pnpm/@codemirror+autocomplete@6.20.0/node_modules/@codemirror/autocomplete/dist/index.js\");\n\n\n\n\nconst cache = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/ new Set([\n    \"Script\",\n    \"Body\",\n    \"FunctionDefinition\",\n    \"ClassDefinition\",\n    \"LambdaExpression\",\n    \"ForStatement\",\n    \"MatchClause\"\n]);\nfunction defID(type) {\n    return (node, def, outer)=>{\n        if (outer) return false;\n        let id = node.node.getChild(\"VariableName\");\n        if (id) def(id, type);\n        return true;\n    };\n}\nconst gatherCompletions = {\n    FunctionDefinition: /*@__PURE__*/ defID(\"function\"),\n    ClassDefinition: /*@__PURE__*/ defID(\"class\"),\n    ForStatement (node, def, outer) {\n        if (outer) for(let child = node.node.firstChild; child; child = child.nextSibling){\n            if (child.name == \"VariableName\") def(child, \"variable\");\n            else if (child.name == \"in\") break;\n        }\n    },\n    ImportStatement (_node, def) {\n        var _a, _b;\n        let { node } = _node;\n        let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n        for(let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling){\n            if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\") def(ch, isFrom ? \"variable\" : \"namespace\");\n        }\n    },\n    AssignStatement (node, def) {\n        for(let child = node.node.firstChild; child; child = child.nextSibling){\n            if (child.name == \"VariableName\") def(child, \"variable\");\n            else if (child.name == \":\" || child.name == \"AssignOp\") break;\n        }\n    },\n    ParamList (node, def) {\n        for(let prev = null, child = node.node.firstChild; child; child = child.nextSibling){\n            if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name))) def(child, \"variable\");\n            prev = child;\n        }\n    },\n    CapturePattern: /*@__PURE__*/ defID(\"variable\"),\n    AsPattern: /*@__PURE__*/ defID(\"variable\"),\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached) return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({\n            label: name,\n            type\n        });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate((node)=>{\n        if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name)) return false;\n            top = false;\n        } else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"String\",\n    \"FormatString\",\n    \"Comment\",\n    \"PropertyName\"\n];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/ function localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1) return null;\n    let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit) return null;\n    let options = [];\n    for(let pos = inner; pos; pos = pos.parent){\n        if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nconst globals = /*@__PURE__*/ [\n    \"__annotations__\",\n    \"__builtins__\",\n    \"__debug__\",\n    \"__doc__\",\n    \"__import__\",\n    \"__name__\",\n    \"__loader__\",\n    \"__package__\",\n    \"__spec__\",\n    \"False\",\n    \"None\",\n    \"True\"\n].map((n)=>({\n        label: n,\n        type: \"constant\"\n    })).concat(/*@__PURE__*/ [\n    \"ArithmeticError\",\n    \"AssertionError\",\n    \"AttributeError\",\n    \"BaseException\",\n    \"BlockingIOError\",\n    \"BrokenPipeError\",\n    \"BufferError\",\n    \"BytesWarning\",\n    \"ChildProcessError\",\n    \"ConnectionAbortedError\",\n    \"ConnectionError\",\n    \"ConnectionRefusedError\",\n    \"ConnectionResetError\",\n    \"DeprecationWarning\",\n    \"EOFError\",\n    \"Ellipsis\",\n    \"EncodingWarning\",\n    \"EnvironmentError\",\n    \"Exception\",\n    \"FileExistsError\",\n    \"FileNotFoundError\",\n    \"FloatingPointError\",\n    \"FutureWarning\",\n    \"GeneratorExit\",\n    \"IOError\",\n    \"ImportError\",\n    \"ImportWarning\",\n    \"IndentationError\",\n    \"IndexError\",\n    \"InterruptedError\",\n    \"IsADirectoryError\",\n    \"KeyError\",\n    \"KeyboardInterrupt\",\n    \"LookupError\",\n    \"MemoryError\",\n    \"ModuleNotFoundError\",\n    \"NameError\",\n    \"NotADirectoryError\",\n    \"NotImplemented\",\n    \"NotImplementedError\",\n    \"OSError\",\n    \"OverflowError\",\n    \"PendingDeprecationWarning\",\n    \"PermissionError\",\n    \"ProcessLookupError\",\n    \"RecursionError\",\n    \"ReferenceError\",\n    \"ResourceWarning\",\n    \"RuntimeError\",\n    \"RuntimeWarning\",\n    \"StopAsyncIteration\",\n    \"StopIteration\",\n    \"SyntaxError\",\n    \"SyntaxWarning\",\n    \"SystemError\",\n    \"SystemExit\",\n    \"TabError\",\n    \"TimeoutError\",\n    \"TypeError\",\n    \"UnboundLocalError\",\n    \"UnicodeDecodeError\",\n    \"UnicodeEncodeError\",\n    \"UnicodeError\",\n    \"UnicodeTranslateError\",\n    \"UnicodeWarning\",\n    \"UserWarning\",\n    \"ValueError\",\n    \"Warning\",\n    \"ZeroDivisionError\"\n].map((n)=>({\n        label: n,\n        type: \"type\"\n    }))).concat(/*@__PURE__*/ [\n    \"bool\",\n    \"bytearray\",\n    \"bytes\",\n    \"classmethod\",\n    \"complex\",\n    \"float\",\n    \"frozenset\",\n    \"int\",\n    \"list\",\n    \"map\",\n    \"memoryview\",\n    \"object\",\n    \"range\",\n    \"set\",\n    \"staticmethod\",\n    \"str\",\n    \"super\",\n    \"tuple\",\n    \"type\"\n].map((n)=>({\n        label: n,\n        type: \"class\"\n    }))).concat(/*@__PURE__*/ [\n    \"abs\",\n    \"aiter\",\n    \"all\",\n    \"anext\",\n    \"any\",\n    \"ascii\",\n    \"bin\",\n    \"breakpoint\",\n    \"callable\",\n    \"chr\",\n    \"compile\",\n    \"delattr\",\n    \"dict\",\n    \"dir\",\n    \"divmod\",\n    \"enumerate\",\n    \"eval\",\n    \"exec\",\n    \"exit\",\n    \"filter\",\n    \"format\",\n    \"getattr\",\n    \"globals\",\n    \"hasattr\",\n    \"hash\",\n    \"help\",\n    \"hex\",\n    \"id\",\n    \"input\",\n    \"isinstance\",\n    \"issubclass\",\n    \"iter\",\n    \"len\",\n    \"license\",\n    \"locals\",\n    \"max\",\n    \"min\",\n    \"next\",\n    \"oct\",\n    \"open\",\n    \"ord\",\n    \"pow\",\n    \"print\",\n    \"property\",\n    \"quit\",\n    \"repr\",\n    \"reversed\",\n    \"round\",\n    \"setattr\",\n    \"slice\",\n    \"sorted\",\n    \"sum\",\n    \"vars\",\n    \"zip\"\n].map((n)=>({\n        label: n,\n        type: \"function\"\n    })));\nconst snippets = [\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"def ${name}(${params}):\\n\t${}\", {\n        label: \"def\",\n        detail: \"function\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"for ${name} in ${collection}:\\n\t${}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"while ${}:\\n\t${}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"try:\\n\t${}\\nexcept ${error}:\\n\t${}\", {\n        label: \"try\",\n        detail: \"/ except block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"if ${}:\\n\t\\n\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"if ${}:\\n\t${}\\nelse:\\n\t${}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"class ${name}:\\n\tdef __init__(self, ${params}):\\n\t\t\t${}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"import ${module}\", {\n        label: \"import\",\n        detail: \"statement\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"from ${module} import ${names}\", {\n        label: \"from\",\n        detail: \"import\",\n        type: \"keyword\"\n    })\n];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/ const globalCompletion = /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.ifNotIn)(dontComplete, /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.completeFromList)(/*@__PURE__*/ globals.concat(snippets)));\nfunction innerBody(context) {\n    let { node, pos } = context;\n    let lineIndent = context.lineIndent(pos, -1);\n    let found = null;\n    for(;;){\n        let before = node.childBefore(pos);\n        if (!before) {\n            break;\n        } else if (before.name == \"Comment\") {\n            pos = before.from;\n        } else if (before.name == \"Body\" || before.name == \"MatchBody\") {\n            if (context.baseIndentFor(before) + context.unit <= lineIndent) found = before;\n            node = before;\n        } else if (before.name == \"MatchClause\") {\n            node = before;\n        } else if (before.type.is(\"Statement\")) {\n            node = before;\n        } else {\n            break;\n        }\n    }\n    return found;\n}\nfunction indentBody(context, node) {\n    let base = context.baseIndentFor(node);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (/^\\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:|case\\s+[^=:]+:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/ const pythonLanguage = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LRLanguage.define({\n    name: \"python\",\n    parser: /*@__PURE__*/ _lezer_python__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentNodeProp.add({\n                Body: (context)=>{\n                    var _a;\n                    let body = /^\\s*(#|$)/.test(context.textAfter) && innerBody(context) || context.node;\n                    return (_a = indentBody(context, body)) !== null && _a !== void 0 ? _a : context.continue();\n                },\n                MatchBody: (context)=>{\n                    var _a;\n                    let inner = innerBody(context);\n                    return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();\n                },\n                IfStatement: (cx)=>/^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"ForStatement WhileStatement\": (cx)=>/^\\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: (cx)=>/^\\s*(except[ :]|finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                MatchStatement: (cx)=>{\n                    if (/^\\s*case /.test(cx.textAfter)) return cx.baseIndent + cx.unit;\n                    return cx.continue();\n                },\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({\n                    closing: \")\"\n                }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({\n                    closing: \"}\"\n                }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({\n                    closing: \"]\"\n                }),\n                MemberExpression: (cx)=>cx.baseIndent + cx.unit,\n                \"String FormatString\": ()=>null,\n                Script: (context)=>{\n                    var _a;\n                    let inner = innerBody(context);\n                    return (_a = inner && indentBody(context, inner)) !== null && _a !== void 0 ? _a : context.continue();\n                }\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add({\n                \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldInside,\n                Body: (node, state)=>({\n                        from: node.from + 1,\n                        to: node.to - (node.to == state.doc.length ? 0 : 1)\n                    }),\n                \"String FormatString\": (node, state)=>({\n                        from: state.doc.lineAt(node.from).to,\n                        to: node.to\n                    })\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\n                \"(\",\n                \"[\",\n                \"{\",\n                \"'\",\n                '\"',\n                \"'''\",\n                '\"\"\"'\n            ],\n            stringPrefixes: [\n                \"f\",\n                \"fr\",\n                \"rf\",\n                \"r\",\n                \"u\",\n                \"b\",\n                \"br\",\n                \"rb\",\n                \"F\",\n                \"FR\",\n                \"RF\",\n                \"R\",\n                \"U\",\n                \"B\",\n                \"BR\",\n                \"RB\"\n            ]\n        },\n        commentTokens: {\n            line: \"#\"\n        },\n        // Indent logic logic are triggered upon below input patterns\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:|case\\s+[^:]*:?)$/\n    }\n});\n/**\nPython language support.\n*/ function python() {\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport(pythonLanguage, [\n        pythonLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        pythonLanguage.data.of({\n            autocomplete: globalCompletion\n        })\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3IrbGFuZy1weXRob25ANi4yLjEvbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctcHl0aG9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUM7QUFDbUc7QUFDcEY7QUFDa0M7QUFFeEYsTUFBTWEsUUFBUSxXQUFXLEdBQUUsSUFBSUwsc0RBQVdBO0FBQzFDLE1BQU1NLGFBQWEsV0FBVyxHQUFFLElBQUlDLElBQUk7SUFDcEM7SUFBVTtJQUNWO0lBQXNCO0lBQW1CO0lBQ3pDO0lBQWdCO0NBQ25CO0FBQ0QsU0FBU0MsTUFBTUMsSUFBSTtJQUNmLE9BQU8sQ0FBQ0MsTUFBTUMsS0FBS0M7UUFDZixJQUFJQSxPQUNBLE9BQU87UUFDWCxJQUFJQyxLQUFLSCxLQUFLQSxJQUFJLENBQUNJLFFBQVEsQ0FBQztRQUM1QixJQUFJRCxJQUNBRixJQUFJRSxJQUFJSjtRQUNaLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTU0sb0JBQW9CO0lBQ3RCQyxvQkFBb0IsV0FBVyxHQUFFUixNQUFNO0lBQ3ZDUyxpQkFBaUIsV0FBVyxHQUFFVCxNQUFNO0lBQ3BDVSxjQUFhUixJQUFJLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztRQUN6QixJQUFJQSxPQUNBLElBQUssSUFBSU8sUUFBUVQsS0FBS0EsSUFBSSxDQUFDVSxVQUFVLEVBQUVELE9BQU9BLFFBQVFBLE1BQU1FLFdBQVcsQ0FBRTtZQUNyRSxJQUFJRixNQUFNRyxJQUFJLElBQUksZ0JBQ2RYLElBQUlRLE9BQU87aUJBQ1YsSUFBSUEsTUFBTUcsSUFBSSxJQUFJLE1BQ25CO1FBQ1I7SUFDUjtJQUNBQyxpQkFBZ0JDLEtBQUssRUFBRWIsR0FBRztRQUN0QixJQUFJYyxJQUFJQztRQUNSLElBQUksRUFBRWhCLElBQUksRUFBRSxHQUFHYztRQUNmLElBQUlHLFNBQVMsQ0FBQyxDQUFDRixLQUFLZixLQUFLVSxVQUFVLE1BQU0sUUFBUUss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QUFXO3dCQUFFaEIsTUFBTWdCLE1BQU10QixHQUFHLENBQUNrRCxNQUFNLENBQUM3RSxLQUFLaUMsSUFBSSxFQUFFQyxFQUFFO3dCQUFFQSxJQUFJbEMsS0FBS2tDLEVBQUU7b0JBQUM7WUFDakc7U0FDSDtJQUNMO0lBQ0FnRSxjQUFjO1FBQ1ZDLGVBQWU7WUFDWEMsVUFBVTtnQkFBQztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBTzthQUFNO1lBQ2pEQyxnQkFBZ0I7Z0JBQUM7Z0JBQUs7Z0JBQU07Z0JBQU07Z0JBQUs7Z0JBQUs7Z0JBQUs7Z0JBQU07Z0JBQ25EO2dCQUFLO2dCQUFNO2dCQUFNO2dCQUFLO2dCQUFLO2dCQUFLO2dCQUFNO2FBQUs7UUFDbkQ7UUFDQUMsZUFBZTtZQUFFMUIsTUFBTTtRQUFJO1FBQzNCLDZEQUE2RDtRQUM3RDJCLGVBQWU7SUFDbkI7QUFDSjtBQUNBOztBQUVBLEdBQ0EsU0FBU0M7SUFDTCxPQUFPLElBQUluSCxpRUFBZUEsQ0FBQzRGLGdCQUFnQjtRQUN2Q0EsZUFBZXdCLElBQUksQ0FBQ0MsRUFBRSxDQUFDO1lBQUVDLGNBQWM3RDtRQUFzQjtRQUM3RG1DLGVBQWV3QixJQUFJLENBQUNDLEVBQUUsQ0FBQztZQUFFQyxjQUFjMUM7UUFBaUI7S0FDM0Q7QUFDTDtBQUUyRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK2xhbmctcHl0aG9uQDYuMi4xL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLXB5dGhvbi9kaXN0L2luZGV4LmpzPzEyMGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnQGxlemVyL3B5dGhvbic7XG5pbXBvcnQgeyBzeW50YXhUcmVlLCBMUkxhbmd1YWdlLCBpbmRlbnROb2RlUHJvcCwgZGVsaW1pdGVkSW5kZW50LCBmb2xkTm9kZVByb3AsIGZvbGRJbnNpZGUsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IE5vZGVXZWFrTWFwLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgc25pcHBldENvbXBsZXRpb24sIGlmTm90SW4sIGNvbXBsZXRlRnJvbUxpc3QgfSBmcm9tICdAY29kZW1pcnJvci9hdXRvY29tcGxldGUnO1xuXG5jb25zdCBjYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVdlYWtNYXAoKTtcbmNvbnN0IFNjb3BlTm9kZXMgPSAvKkBfX1BVUkVfXyovbmV3IFNldChbXG4gICAgXCJTY3JpcHRcIiwgXCJCb2R5XCIsXG4gICAgXCJGdW5jdGlvbkRlZmluaXRpb25cIiwgXCJDbGFzc0RlZmluaXRpb25cIiwgXCJMYW1iZGFFeHByZXNzaW9uXCIsXG4gICAgXCJGb3JTdGF0ZW1lbnRcIiwgXCJNYXRjaENsYXVzZVwiXG5dKTtcbmZ1bmN0aW9uIGRlZklEKHR5cGUpIHtcbiAgICByZXR1cm4gKG5vZGUsIGRlZiwgb3V0ZXIpID0+IHtcbiAgICAgICAgaWYgKG91dGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaWQgPSBub2RlLm5vZGUuZ2V0Q2hpbGQoXCJWYXJpYWJsZU5hbWVcIik7XG4gICAgICAgIGlmIChpZClcbiAgICAgICAgICAgIGRlZihpZCwgdHlwZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5jb25zdCBnYXRoZXJDb21wbGV0aW9ucyA9IHtcbiAgICBGdW5jdGlvbkRlZmluaXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImZ1bmN0aW9uXCIpLFxuICAgIENsYXNzRGVmaW5pdGlvbjogLypAX19QVVJFX18qL2RlZklEKFwiY2xhc3NcIiksXG4gICAgRm9yU3RhdGVtZW50KG5vZGUsIGRlZiwgb3V0ZXIpIHtcbiAgICAgICAgaWYgKG91dGVyKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLm5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBkZWYoY2hpbGQsIFwidmFyaWFibGVcIik7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubmFtZSA9PSBcImluXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH0sXG4gICAgSW1wb3J0U3RhdGVtZW50KF9ub2RlLCBkZWYpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHsgbm9kZSB9ID0gX25vZGU7XG4gICAgICAgIGxldCBpc0Zyb20gPSAoKF9hID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT0gXCJmcm9tXCI7XG4gICAgICAgIGZvciAobGV0IGNoID0gbm9kZS5nZXRDaGlsZChcImltcG9ydFwiKTsgY2g7IGNoID0gY2gubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaC5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgJiYgKChfYiA9IGNoLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgIT0gXCJhc1wiKVxuICAgICAgICAgICAgICAgIGRlZihjaCwgaXNGcm9tID8gXCJ2YXJpYWJsZVwiIDogXCJuYW1lc3BhY2VcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIEFzc2lnblN0YXRlbWVudChub2RlLCBkZWYpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLm5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgZGVmKGNoaWxkLCBcInZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubmFtZSA9PSBcIjpcIiB8fCBjaGlsZC5uYW1lID09IFwiQXNzaWduT3BcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUGFyYW1MaXN0KG5vZGUsIGRlZikge1xuICAgICAgICBmb3IgKGxldCBwcmV2ID0gbnVsbCwgY2hpbGQgPSBub2RlLm5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgJiYgKCFwcmV2IHx8ICEvXFwqfEFzc2lnbk9wLy50ZXN0KHByZXYubmFtZSkpKVxuICAgICAgICAgICAgICAgIGRlZihjaGlsZCwgXCJ2YXJpYWJsZVwiKTtcbiAgICAgICAgICAgIHByZXYgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQ2FwdHVyZVBhdHRlcm46IC8qQF9fUFVSRV9fKi9kZWZJRChcInZhcmlhYmxlXCIpLFxuICAgIEFzUGF0dGVybjogLypAX19QVVJFX18qL2RlZklEKFwidmFyaWFibGVcIiksXG4gICAgX19wcm90b19fOiBudWxsXG59O1xuZnVuY3Rpb24gZ2V0U2NvcGUoZG9jLCBub2RlKSB7XG4gICAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIGxldCBjb21wbGV0aW9ucyA9IFtdLCB0b3AgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGRlZihub2RlLCB0eXBlKSB7XG4gICAgICAgIGxldCBuYW1lID0gZG9jLnNsaWNlU3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50byk7XG4gICAgICAgIGNvbXBsZXRpb25zLnB1c2goeyBsYWJlbDogbmFtZSwgdHlwZSB9KTtcbiAgICB9XG4gICAgbm9kZS5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cykuaXRlcmF0ZShub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICAgICAgbGV0IGdhdGhlciA9IGdhdGhlckNvbXBsZXRpb25zW25vZGUubmFtZV07XG4gICAgICAgICAgICBpZiAoZ2F0aGVyICYmIGdhdGhlcihub2RlLCBkZWYsIHRvcCkgfHwgIXRvcCAmJiBTY29wZU5vZGVzLmhhcyhub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRvcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudG8gLSBub2RlLmZyb20gPiA4MTkyKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBjYWNoaW5nIGZvciBiaWdnZXIgaW50ZXJuYWwgbm9kZXNcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgZ2V0U2NvcGUoZG9jLCBub2RlLm5vZGUpKVxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goYyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjYWNoZS5zZXQobm9kZSwgY29tcGxldGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cbmNvbnN0IElkZW50aWZpZXIgPSAvXltcXHdcXHhhMS1cXHVmZmZmXVtcXHdcXGRcXHhhMS1cXHVmZmZmXSokLztcbmNvbnN0IGRvbnRDb21wbGV0ZSA9IFtcIlN0cmluZ1wiLCBcIkZvcm1hdFN0cmluZ1wiLCBcIkNvbW1lbnRcIiwgXCJQcm9wZXJ0eU5hbWVcIl07XG4vKipcbkNvbXBsZXRpb24gc291cmNlIHRoYXQgbG9va3MgdXAgbG9jYWxseSBkZWZpbmVkIG5hbWVzIGluXG5QeXRob24gY29kZS5cbiovXG5mdW5jdGlvbiBsb2NhbENvbXBsZXRpb25Tb3VyY2UoY29udGV4dCkge1xuICAgIGxldCBpbm5lciA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7XG4gICAgaWYgKGRvbnRDb21wbGV0ZS5pbmRleE9mKGlubmVyLm5hbWUpID4gLTEpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpc1dvcmQgPSBpbm5lci5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgfHxcbiAgICAgICAgaW5uZXIudG8gLSBpbm5lci5mcm9tIDwgMjAgJiYgSWRlbnRpZmllci50ZXN0KGNvbnRleHQuc3RhdGUuc2xpY2VEb2MoaW5uZXIuZnJvbSwgaW5uZXIudG8pKTtcbiAgICBpZiAoIWlzV29yZCAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBpbm5lcjsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgIGlmIChTY29wZU5vZGVzLmhhcyhwb3MubmFtZSkpXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jb25jYXQoZ2V0U2NvcGUoY29udGV4dC5zdGF0ZS5kb2MsIHBvcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmcm9tOiBpc1dvcmQgPyBpbm5lci5mcm9tIDogY29udGV4dC5wb3MsXG4gICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgfTtcbn1cbmNvbnN0IGdsb2JhbHMgPSAvKkBfX1BVUkVfXyovW1xuICAgIFwiX19hbm5vdGF0aW9uc19fXCIsIFwiX19idWlsdGluc19fXCIsIFwiX19kZWJ1Z19fXCIsIFwiX19kb2NfX1wiLCBcIl9faW1wb3J0X19cIiwgXCJfX25hbWVfX1wiLFxuICAgIFwiX19sb2FkZXJfX1wiLCBcIl9fcGFja2FnZV9fXCIsIFwiX19zcGVjX19cIixcbiAgICBcIkZhbHNlXCIsIFwiTm9uZVwiLCBcIlRydWVcIlxuXS5tYXAobiA9PiAoeyBsYWJlbDogbiwgdHlwZTogXCJjb25zdGFudFwiIH0pKS5jb25jYXQoLypAX19QVVJFX18qL1tcbiAgICBcIkFyaXRobWV0aWNFcnJvclwiLCBcIkFzc2VydGlvbkVycm9yXCIsIFwiQXR0cmlidXRlRXJyb3JcIiwgXCJCYXNlRXhjZXB0aW9uXCIsIFwiQmxvY2tpbmdJT0Vycm9yXCIsXG4gICAgXCJCcm9rZW5QaXBlRXJyb3JcIiwgXCJCdWZmZXJFcnJvclwiLCBcIkJ5dGVzV2FybmluZ1wiLCBcIkNoaWxkUHJvY2Vzc0Vycm9yXCIsIFwiQ29ubmVjdGlvbkFib3J0ZWRFcnJvclwiLFxuICAgIFwiQ29ubmVjdGlvbkVycm9yXCIsIFwiQ29ubmVjdGlvblJlZnVzZWRFcnJvclwiLCBcIkNvbm5lY3Rpb25SZXNldEVycm9yXCIsIFwiRGVwcmVjYXRpb25XYXJuaW5nXCIsXG4gICAgXCJFT0ZFcnJvclwiLCBcIkVsbGlwc2lzXCIsIFwiRW5jb2RpbmdXYXJuaW5nXCIsIFwiRW52aXJvbm1lbnRFcnJvclwiLCBcIkV4Y2VwdGlvblwiLCBcIkZpbGVFeGlzdHNFcnJvclwiLFxuICAgIFwiRmlsZU5vdEZvdW5kRXJyb3JcIiwgXCJGbG9hdGluZ1BvaW50RXJyb3JcIiwgXCJGdXR1cmVXYXJuaW5nXCIsIFwiR2VuZXJhdG9yRXhpdFwiLCBcIklPRXJyb3JcIixcbiAgICBcIkltcG9ydEVycm9yXCIsIFwiSW1wb3J0V2FybmluZ1wiLCBcIkluZGVudGF0aW9uRXJyb3JcIiwgXCJJbmRleEVycm9yXCIsIFwiSW50ZXJydXB0ZWRFcnJvclwiLFxuICAgIFwiSXNBRGlyZWN0b3J5RXJyb3JcIiwgXCJLZXlFcnJvclwiLCBcIktleWJvYXJkSW50ZXJydXB0XCIsIFwiTG9va3VwRXJyb3JcIiwgXCJNZW1vcnlFcnJvclwiLFxuICAgIFwiTW9kdWxlTm90Rm91bmRFcnJvclwiLCBcIk5hbWVFcnJvclwiLCBcIk5vdEFEaXJlY3RvcnlFcnJvclwiLCBcIk5vdEltcGxlbWVudGVkXCIsIFwiTm90SW1wbGVtZW50ZWRFcnJvclwiLFxuICAgIFwiT1NFcnJvclwiLCBcIk92ZXJmbG93RXJyb3JcIiwgXCJQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5nXCIsIFwiUGVybWlzc2lvbkVycm9yXCIsIFwiUHJvY2Vzc0xvb2t1cEVycm9yXCIsXG4gICAgXCJSZWN1cnNpb25FcnJvclwiLCBcIlJlZmVyZW5jZUVycm9yXCIsIFwiUmVzb3VyY2VXYXJuaW5nXCIsIFwiUnVudGltZUVycm9yXCIsIFwiUnVudGltZVdhcm5pbmdcIixcbiAgICBcIlN0b3BBc3luY0l0ZXJhdGlvblwiLCBcIlN0b3BJdGVyYXRpb25cIiwgXCJTeW50YXhFcnJvclwiLCBcIlN5bnRheFdhcm5pbmdcIiwgXCJTeXN0ZW1FcnJvclwiLFxuICAgIFwiU3lzdGVtRXhpdFwiLCBcIlRhYkVycm9yXCIsIFwiVGltZW91dEVycm9yXCIsIFwiVHlwZUVycm9yXCIsIFwiVW5ib3VuZExvY2FsRXJyb3JcIiwgXCJVbmljb2RlRGVjb2RlRXJyb3JcIixcbiAgICBcIlVuaWNvZGVFbmNvZGVFcnJvclwiLCBcIlVuaWNvZGVFcnJvclwiLCBcIlVuaWNvZGVUcmFuc2xhdGVFcnJvclwiLCBcIlVuaWNvZGVXYXJuaW5nXCIsIFwiVXNlcldhcm5pbmdcIixcbiAgICBcIlZhbHVlRXJyb3JcIiwgXCJXYXJuaW5nXCIsIFwiWmVyb0RpdmlzaW9uRXJyb3JcIlxuXS5tYXAobiA9PiAoeyBsYWJlbDogbiwgdHlwZTogXCJ0eXBlXCIgfSkpKS5jb25jYXQoLypAX19QVVJFX18qL1tcbiAgICBcImJvb2xcIiwgXCJieXRlYXJyYXlcIiwgXCJieXRlc1wiLCBcImNsYXNzbWV0aG9kXCIsIFwiY29tcGxleFwiLCBcImZsb2F0XCIsIFwiZnJvemVuc2V0XCIsIFwiaW50XCIsIFwibGlzdFwiLFxuICAgIFwibWFwXCIsIFwibWVtb3J5dmlld1wiLCBcIm9iamVjdFwiLCBcInJhbmdlXCIsIFwic2V0XCIsIFwic3RhdGljbWV0aG9kXCIsIFwic3RyXCIsIFwic3VwZXJcIiwgXCJ0dXBsZVwiLCBcInR5cGVcIlxuXS5tYXAobiA9PiAoeyBsYWJlbDogbiwgdHlwZTogXCJjbGFzc1wiIH0pKSkuY29uY2F0KC8qQF9fUFVSRV9fKi9bXG4gICAgXCJhYnNcIiwgXCJhaXRlclwiLCBcImFsbFwiLCBcImFuZXh0XCIsIFwiYW55XCIsIFwiYXNjaWlcIiwgXCJiaW5cIiwgXCJicmVha3BvaW50XCIsIFwiY2FsbGFibGVcIiwgXCJjaHJcIixcbiAgICBcImNvbXBpbGVcIiwgXCJkZWxhdHRyXCIsIFwiZGljdFwiLCBcImRpclwiLCBcImRpdm1vZFwiLCBcImVudW1lcmF0ZVwiLCBcImV2YWxcIiwgXCJleGVjXCIsIFwiZXhpdFwiLCBcImZpbHRlclwiLFxuICAgIFwiZm9ybWF0XCIsIFwiZ2V0YXR0clwiLCBcImdsb2JhbHNcIiwgXCJoYXNhdHRyXCIsIFwiaGFzaFwiLCBcImhlbHBcIiwgXCJoZXhcIiwgXCJpZFwiLCBcImlucHV0XCIsIFwiaXNpbnN0YW5jZVwiLFxuICAgIFwiaXNzdWJjbGFzc1wiLCBcIml0ZXJcIiwgXCJsZW5cIiwgXCJsaWNlbnNlXCIsIFwibG9jYWxzXCIsIFwibWF4XCIsIFwibWluXCIsIFwibmV4dFwiLCBcIm9jdFwiLCBcIm9wZW5cIixcbiAgICBcIm9yZFwiLCBcInBvd1wiLCBcInByaW50XCIsIFwicHJvcGVydHlcIiwgXCJxdWl0XCIsIFwicmVwclwiLCBcInJldmVyc2VkXCIsIFwicm91bmRcIiwgXCJzZXRhdHRyXCIsIFwic2xpY2VcIixcbiAgICBcInNvcnRlZFwiLCBcInN1bVwiLCBcInZhcnNcIiwgXCJ6aXBcIlxuXS5tYXAobiA9PiAoeyBsYWJlbDogbiwgdHlwZTogXCJmdW5jdGlvblwiIH0pKSk7XG5jb25zdCBzbmlwcGV0cyA9IFtcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJkZWYgJHtuYW1lfSgke3BhcmFtc30pOlxcblxcdCR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImRlZlwiLFxuICAgICAgICBkZXRhaWw6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmb3IgJHtuYW1lfSBpbiAke2NvbGxlY3Rpb259OlxcblxcdCR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImZvclwiLFxuICAgICAgICBkZXRhaWw6IFwibG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcIndoaWxlICR7fTpcXG5cXHQke31cIiwge1xuICAgICAgICBsYWJlbDogXCJ3aGlsZVwiLFxuICAgICAgICBkZXRhaWw6IFwibG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcInRyeTpcXG5cXHQke31cXG5leGNlcHQgJHtlcnJvcn06XFxuXFx0JHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwidHJ5XCIsXG4gICAgICAgIGRldGFpbDogXCIvIGV4Y2VwdCBibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImlmICR7fTpcXG5cXHRcXG5cIiwge1xuICAgICAgICBsYWJlbDogXCJpZlwiLFxuICAgICAgICBkZXRhaWw6IFwiYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpZiAke306XFxuXFx0JHt9XFxuZWxzZTpcXG5cXHQke31cIiwge1xuICAgICAgICBsYWJlbDogXCJpZlwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBlbHNlIGJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiY2xhc3MgJHtuYW1lfTpcXG5cXHRkZWYgX19pbml0X18oc2VsZiwgJHtwYXJhbXN9KTpcXG5cXHRcXHRcXHQke31cIiwge1xuICAgICAgICBsYWJlbDogXCJjbGFzc1wiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImltcG9ydCAke21vZHVsZX1cIiwge1xuICAgICAgICBsYWJlbDogXCJpbXBvcnRcIixcbiAgICAgICAgZGV0YWlsOiBcInN0YXRlbWVudFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImZyb20gJHttb2R1bGV9IGltcG9ydCAke25hbWVzfVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImZyb21cIixcbiAgICAgICAgZGV0YWlsOiBcImltcG9ydFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pXG5dO1xuLyoqXG5BdXRvY29tcGxldGlvbiBmb3IgYnVpbHQtaW4gUHl0aG9uIGdsb2JhbHMgYW5kIGtleXdvcmRzLlxuKi9cbmNvbnN0IGdsb2JhbENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovaWZOb3RJbihkb250Q29tcGxldGUsIC8qQF9fUFVSRV9fKi9jb21wbGV0ZUZyb21MaXN0KC8qQF9fUFVSRV9fKi9nbG9iYWxzLmNvbmNhdChzbmlwcGV0cykpKTtcblxuZnVuY3Rpb24gaW5uZXJCb2R5KGNvbnRleHQpIHtcbiAgICBsZXQgeyBub2RlLCBwb3MgfSA9IGNvbnRleHQ7XG4gICAgbGV0IGxpbmVJbmRlbnQgPSBjb250ZXh0LmxpbmVJbmRlbnQocG9zLCAtMSk7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkQmVmb3JlKHBvcyk7XG4gICAgICAgIGlmICghYmVmb3JlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUubmFtZSA9PSBcIkNvbW1lbnRcIikge1xuICAgICAgICAgICAgcG9zID0gYmVmb3JlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlLm5hbWUgPT0gXCJCb2R5XCIgfHwgYmVmb3JlLm5hbWUgPT0gXCJNYXRjaEJvZHlcIikge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuYmFzZUluZGVudEZvcihiZWZvcmUpICsgY29udGV4dC51bml0IDw9IGxpbmVJbmRlbnQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBiZWZvcmU7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZS5uYW1lID09IFwiTWF0Y2hDbGF1c2VcIikge1xuICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUudHlwZS5pcyhcIlN0YXRlbWVudFwiKSkge1xuICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGluZGVudEJvZHkoY29udGV4dCwgbm9kZSkge1xuICAgIGxldCBiYXNlID0gY29udGV4dC5iYXNlSW5kZW50Rm9yKG5vZGUpO1xuICAgIGxldCBsaW5lID0gY29udGV4dC5saW5lQXQoY29udGV4dC5wb3MsIC0xKSwgdG8gPSBsaW5lLmZyb20gKyBsaW5lLnRleHQubGVuZ3RoO1xuICAgIC8vIERvbid0IGNvbnNpZGVyIGJsYW5rLCBkZWluZGVudGVkIGxpbmVzIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gYmxvY2sgcGFydCBvZiB0aGUgYmxvY2tcbiAgICBpZiAoL15cXHMqKCR8IykvLnRlc3QobGluZS50ZXh0KSAmJlxuICAgICAgICBjb250ZXh0Lm5vZGUudG8gPCB0byArIDEwMCAmJlxuICAgICAgICAhL1xcUy8udGVzdChjb250ZXh0LnN0YXRlLnNsaWNlRG9jKHRvLCBjb250ZXh0Lm5vZGUudG8pKSAmJlxuICAgICAgICBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5wb3MsIC0xKSA8PSBiYXNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBBIG5vcm1hbGx5IGRlaW5kZW50aW5nIGtleXdvcmQgdGhhdCBhcHBlYXJzIGF0IGEgaGlnaGVyXG4gICAgLy8gaW5kZW50YXRpb24gdGhhbiB0aGUgYmxvY2sgc2hvdWxkIHByb2JhYmx5IGJlIGhhbmRsZWQgYnkgdGhlIG5leHRcbiAgICAvLyBsZXZlbFxuICAgIGlmICgvXlxccyooZWxzZTp8ZWxpZiB8ZXhjZXB0IHxmaW5hbGx5OnxjYXNlXFxzK1tePTpdKzopLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKSAmJiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5wb3MsIC0xKSA+IGJhc2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBiYXNlICsgY29udGV4dC51bml0O1xufVxuLyoqXG5BIGxhbmd1YWdlIHByb3ZpZGVyIGJhc2VkIG9uIHRoZSBbTGV6ZXIgUHl0aG9uXG5wYXJzZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZXplci1wYXJzZXIvcHl0aG9uKSwgZXh0ZW5kZWQgd2l0aFxuaGlnaGxpZ2h0aW5nIGFuZCBpbmRlbnRhdGlvbiBpbmZvcm1hdGlvbi5cbiovXG5jb25zdCBweXRob25MYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9MUkxhbmd1YWdlLmRlZmluZSh7XG4gICAgbmFtZTogXCJweXRob25cIixcbiAgICBwYXJzZXI6IC8qQF9fUFVSRV9fKi9wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9pbmRlbnROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIEJvZHk6IGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gL15cXHMqKCN8JCkvLnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpICYmIGlubmVyQm9keShjb250ZXh0KSB8fCBjb250ZXh0Lm5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBpbmRlbnRCb2R5KGNvbnRleHQsIGJvZHkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250ZXh0LmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBNYXRjaEJvZHk6IGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGlubmVyQm9keShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGluZGVudEJvZHkoY29udGV4dCwgaW5uZXIgfHwgY29udGV4dC5ub2RlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgSWZTdGF0ZW1lbnQ6IGN4ID0+IC9eXFxzKihlbHNlOnxlbGlmICkvLnRlc3QoY3gudGV4dEFmdGVyKSA/IGN4LmJhc2VJbmRlbnQgOiBjeC5jb250aW51ZSgpLFxuICAgICAgICAgICAgICAgIFwiRm9yU3RhdGVtZW50IFdoaWxlU3RhdGVtZW50XCI6IGN4ID0+IC9eXFxzKmVsc2U6Ly50ZXN0KGN4LnRleHRBZnRlcikgPyBjeC5iYXNlSW5kZW50IDogY3guY29udGludWUoKSxcbiAgICAgICAgICAgICAgICBUcnlTdGF0ZW1lbnQ6IGN4ID0+IC9eXFxzKihleGNlcHRbIDpdfGZpbmFsbHk6fGVsc2U6KS8udGVzdChjeC50ZXh0QWZ0ZXIpID8gY3guYmFzZUluZGVudCA6IGN4LmNvbnRpbnVlKCksXG4gICAgICAgICAgICAgICAgTWF0Y2hTdGF0ZW1lbnQ6IGN4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eXFxzKmNhc2UgLy50ZXN0KGN4LnRleHRBZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3guYmFzZUluZGVudCArIGN4LnVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjeC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJUdXBsZUV4cHJlc3Npb24gQ29tcHJlaGVuc2lvbkV4cHJlc3Npb24gUGFyYW1MaXN0IEFyZ0xpc3QgUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwiKVwiIH0pLFxuICAgICAgICAgICAgICAgIFwiRGljdGlvbmFyeUV4cHJlc3Npb24gRGljdGlvbmFyeUNvbXByZWhlbnNpb25FeHByZXNzaW9uIFNldEV4cHJlc3Npb24gU2V0Q29tcHJlaGVuc2lvbkV4cHJlc3Npb25cIjogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwifVwiIH0pLFxuICAgICAgICAgICAgICAgIFwiQXJyYXlFeHByZXNzaW9uIEFycmF5Q29tcHJlaGVuc2lvbkV4cHJlc3Npb25cIjogLypAX19QVVJFX18qL2RlbGltaXRlZEluZGVudCh7IGNsb3Npbmc6IFwiXVwiIH0pLFxuICAgICAgICAgICAgICAgIE1lbWJlckV4cHJlc3Npb246IGN4ID0+IGN4LmJhc2VJbmRlbnQgKyBjeC51bml0LFxuICAgICAgICAgICAgICAgIFwiU3RyaW5nIEZvcm1hdFN0cmluZ1wiOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgICAgIFNjcmlwdDogY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gaW5uZXJCb2R5KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gKGlubmVyICYmIGluZGVudEJvZHkoY29udGV4dCwgaW5uZXIpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBcIkFycmF5RXhwcmVzc2lvbiBEaWN0aW9uYXJ5RXhwcmVzc2lvbiBTZXRFeHByZXNzaW9uIFR1cGxlRXhwcmVzc2lvblwiOiBmb2xkSW5zaWRlLFxuICAgICAgICAgICAgICAgIEJvZHk6IChub2RlLCBzdGF0ZSkgPT4gKHsgZnJvbTogbm9kZS5mcm9tICsgMSwgdG86IG5vZGUudG8gLSAobm9kZS50byA9PSBzdGF0ZS5kb2MubGVuZ3RoID8gMCA6IDEpIH0pLFxuICAgICAgICAgICAgICAgIFwiU3RyaW5nIEZvcm1hdFN0cmluZ1wiOiAobm9kZSwgc3RhdGUpID0+ICh7IGZyb206IHN0YXRlLmRvYy5saW5lQXQobm9kZS5mcm9tKS50bywgdG86IG5vZGUudG8gfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgfSksXG4gICAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgICAgIGNsb3NlQnJhY2tldHM6IHtcbiAgICAgICAgICAgIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsIFwiJycnXCIsICdcIlwiXCInXSxcbiAgICAgICAgICAgIHN0cmluZ1ByZWZpeGVzOiBbXCJmXCIsIFwiZnJcIiwgXCJyZlwiLCBcInJcIiwgXCJ1XCIsIFwiYlwiLCBcImJyXCIsIFwicmJcIixcbiAgICAgICAgICAgICAgICBcIkZcIiwgXCJGUlwiLCBcIlJGXCIsIFwiUlwiLCBcIlVcIiwgXCJCXCIsIFwiQlJcIiwgXCJSQlwiXVxuICAgICAgICB9LFxuICAgICAgICBjb21tZW50VG9rZW5zOiB7IGxpbmU6IFwiI1wiIH0sXG4gICAgICAgIC8vIEluZGVudCBsb2dpYyBsb2dpYyBhcmUgdHJpZ2dlcmVkIHVwb24gYmVsb3cgaW5wdXQgcGF0dGVybnNcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqKFtcXH1cXF1cXCldfGVsc2U6fGVsaWYgfGV4Y2VwdCB8ZmluYWxseTp8Y2FzZVxccytbXjpdKjo/KSQvLFxuICAgIH1cbn0pO1xuLyoqXG5QeXRob24gbGFuZ3VhZ2Ugc3VwcG9ydC5cbiovXG5mdW5jdGlvbiBweXRob24oKSB7XG4gICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN1cHBvcnQocHl0aG9uTGFuZ3VhZ2UsIFtcbiAgICAgICAgcHl0aG9uTGFuZ3VhZ2UuZGF0YS5vZih7IGF1dG9jb21wbGV0ZTogbG9jYWxDb21wbGV0aW9uU291cmNlIH0pLFxuICAgICAgICBweXRob25MYW5ndWFnZS5kYXRhLm9mKHsgYXV0b2NvbXBsZXRlOiBnbG9iYWxDb21wbGV0aW9uIH0pLFxuICAgIF0pO1xufVxuXG5leHBvcnQgeyBnbG9iYWxDb21wbGV0aW9uLCBsb2NhbENvbXBsZXRpb25Tb3VyY2UsIHB5dGhvbiwgcHl0aG9uTGFuZ3VhZ2UgfTtcbiJdLCJuYW1lcyI6WyJwYXJzZXIiLCJzeW50YXhUcmVlIiwiTFJMYW5ndWFnZSIsImluZGVudE5vZGVQcm9wIiwiZGVsaW1pdGVkSW5kZW50IiwiZm9sZE5vZGVQcm9wIiwiZm9sZEluc2lkZSIsIkxhbmd1YWdlU3VwcG9ydCIsIk5vZGVXZWFrTWFwIiwiSXRlck1vZGUiLCJzbmlwcGV0Q29tcGxldGlvbiIsImlmTm90SW4iLCJjb21wbGV0ZUZyb21MaXN0IiwiY2FjaGUiLCJTY29wZU5vZGVzIiwiU2V0IiwiZGVmSUQiLCJ0eXBlIiwibm9kZSIsImRlZiIsIm91dGVyIiwiaWQiLCJnZXRDaGlsZCIsImdhdGhlckNvbXBsZXRpb25zIiwiRnVuY3Rpb25EZWZpbml0aW9uIiwiQ2xhc3NEZWZpbml0aW9uIiwiRm9yU3RhdGVtZW50IiwiY2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJuYW1lIiwiSW1wb3J0U3RhdGVtZW50IiwiX25vZGUiLCJfYSIsIl9iIiwiaXNGcm9tIiwiY2giLCJBc3NpZ25TdGF0ZW1lbnQiLCJQYXJhbUxpc3QiLCJwcmV2IiwidGVzdCIsIkNhcHR1cmVQYXR0ZXJuIiwiQXNQYXR0ZXJuIiwiX19wcm90b19fIiwiZ2V0U2NvcGUiLCJkb2MiLCJjYWNoZWQiLCJnZXQiLCJjb21wbGV0aW9ucyIsInRvcCIsInNsaWNlU3RyaW5nIiwiZnJvbSIsInRvIiwicHVzaCIsImxhYmVsIiwiY3Vyc29yIiwiSW5jbHVkZUFub255bW91cyIsIml0ZXJhdGUiLCJnYXRoZXIiLCJoYXMiLCJjIiwic2V0IiwiSWRlbnRpZmllciIsImRvbnRDb21wbGV0ZSIsImxvY2FsQ29tcGxldGlvblNvdXJjZSIsImNvbnRleHQiLCJpbm5lciIsInN0YXRlIiwicmVzb2x2ZUlubmVyIiwicG9zIiwiaW5kZXhPZiIsImlzV29yZCIsInNsaWNlRG9jIiwiZXhwbGljaXQiLCJvcHRpb25zIiwicGFyZW50IiwiY29uY2F0IiwidmFsaWRGb3IiLCJnbG9iYWxzIiwibWFwIiwibiIsInNuaXBwZXRzIiwiZGV0YWlsIiwiZ2xvYmFsQ29tcGxldGlvbiIsImlubmVyQm9keSIsImxpbmVJbmRlbnQiLCJmb3VuZCIsImJlZm9yZSIsImNoaWxkQmVmb3JlIiwiYmFzZUluZGVudEZvciIsInVuaXQiLCJpcyIsImluZGVudEJvZHkiLCJiYXNlIiwibGluZSIsImxpbmVBdCIsInRleHQiLCJsZW5ndGgiLCJ0ZXh0QWZ0ZXIiLCJweXRob25MYW5ndWFnZSIsImRlZmluZSIsImNvbmZpZ3VyZSIsInByb3BzIiwiYWRkIiwiQm9keSIsImJvZHkiLCJjb250aW51ZSIsIk1hdGNoQm9keSIsIklmU3RhdGVtZW50IiwiY3giLCJiYXNlSW5kZW50IiwiVHJ5U3RhdGVtZW50IiwiTWF0Y2hTdGF0ZW1lbnQiLCJjbG9zaW5nIiwiTWVtYmVyRXhwcmVzc2lvbiIsIlNjcmlwdCIsImxhbmd1YWdlRGF0YSIsImNsb3NlQnJhY2tldHMiLCJicmFja2V0cyIsInN0cmluZ1ByZWZpeGVzIiwiY29tbWVudFRva2VucyIsImluZGVudE9uSW5wdXQiLCJweXRob24iLCJkYXRhIiwib2YiLCJhdXRvY29tcGxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@codemirror+lang-python@6.2.1/node_modules/@codemirror/lang-python/dist/index.js\n");

/***/ })

};
;