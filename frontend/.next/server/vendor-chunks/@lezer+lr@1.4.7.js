"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer+lr@1.4.7";
exports.ids = ["vendor-chunks/@lezer+lr@1.4.7"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lezer+lr@1.4.7/node_modules/@lezer/lr/dist/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/@lezer+lr@1.4.7/node_modules/@lezer/lr/dist/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js\");\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/ class Stack {\n    /**\n    @internal\n    */ constructor(/**\n    The parse that this stack is part of @internal\n    */ p, /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */ stack, /**\n    The current parse state @internal\n    */ state, // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */ reducePos, /**\n    The input position up to which this stack has parsed.\n    */ pos, /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */ score, // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */ buffer, // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */ bufferBase, /**\n    @internal\n    */ curContext, /**\n    @internal\n    */ lookAhead = 0, // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */ parent){\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */ toString() {\n        return `[${this.stack.filter((_, i)=>i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */ static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */ get context() {\n        return this.curContext ? this.curContext.context : null;\n    }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */ pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */ reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */ , type = action & 65535 /* Action.ValueMask */ ;\n        let { parser } = this.p;\n        let lookaheadRecord = this.reducePos < this.pos - 25 /* Lookahead.Margin */  && this.setLookAhead(this.pos);\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec) this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - (depth - 1) * 3 - (action & 262144 /* Action.StayFlag */  ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */  && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            } else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || action & 131072 /* Action.RepeatFlag */ ) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */ ) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */ ) {\n            this.state = this.stack[base];\n        } else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while(this.stack.length > base)this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */ storeNode(term, start, end, size = 4, mustSink = false) {\n        if (term == 0 /* Term.Err */  && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */  && cur.buffer[top - 1] > -1) {\n                if (start == end) return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!mustSink || this.pos == end) {\n            this.buffer.push(term, start, end, size);\n        } else {\n            let index = this.buffer.length;\n            if (index > 0 && (this.buffer[index - 4] != 0 /* Term.Err */  || this.buffer[index - 1] < 0)) {\n                let mustMove = false;\n                for(let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4){\n                    if (this.buffer[scan - 1] >= 0) {\n                        mustMove = true;\n                        break;\n                    }\n                }\n                if (mustMove) while(index > 0 && this.buffer[index - 2] > end){\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4) size -= 4;\n                }\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */ shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */ ) {\n            this.pushState(action & 65535 /* Action.ValueMask */ , this.pos);\n        } else if ((action & 262144 /* Action.StayFlag */ ) == 0) {\n            let nextState = action, { parser } = this.p;\n            this.pos = end;\n            // Skipped or zero-length non-tree tokens don't move reducePos\n            if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */ ) && (end > start || type <= parser.maxNode)) this.reducePos = end;\n            this.pushState(nextState, Math.min(start, this.reducePos));\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode) this.buffer.push(type, start, end, 4);\n        } else {\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */ apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */ ) this.reduce(action);\n        else this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */ useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */ );\n        if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */ split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while(off > 0 && parent.buffer[off - 2] > parent.reducePos)off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while(parent && base == parent.bufferBase)parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */ recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode) this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */ , this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */ ;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */ canShift(term) {\n        for(let sim = new SimulatedStack(this);;){\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */ ) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0) return false;\n            if ((action & 65536 /* Action.ReduceFlag */ ) == 0) return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */ recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */ ) return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */  << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */ ) {\n            let best = [];\n            for(let i = 0, s; i < nextStates.length; i += 2){\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */ ) for(let i = 0; best.length < 4 /* Recover.MaxNext */  << 1 && i < nextStates.length; i += 2){\n                let s = nextStates[i + 1];\n                if (!best.some((v, i)=>i & 1 && v == s)) best.push(nextStates[i], s);\n            }\n            nextStates = best;\n        }\n        let result = [];\n        for(let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */ ; i += 2){\n            let s = nextStates[i + 1];\n            if (s == this.state) continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */ , stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */ ;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */ forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */ );\n        if ((reduce & 65536 /* Action.ReduceFlag */ ) == 0) return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */ , term = reduce & 65535 /* Action.ValueMask */ ;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null) return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */ ;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */ findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth)=>{\n            if (seen.includes(state)) return;\n            seen.push(state);\n            return parser.allActions(state, (action)=>{\n                if (action & (262144 /* Action.StayFlag */  | 131072 /* Action.GotoFlag */ )) ;\n                else if (action & 65536 /* Action.ReduceFlag */ ) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */ ) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */ , target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 /* Action.ReduceDepthShift */  | 65536 /* Action.ReduceFlag */  | term;\n                    }\n                } else {\n                    let found = explore(action, depth + 1);\n                    if (found != null) return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */ forceAll() {\n        while(!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */ )){\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */ get deadEnd() {\n        if (this.stack.length != 3) return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */ )] == 65535 /* Seq.End */  && !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */ );\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */ restart() {\n        this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */ sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length) return false;\n        for(let i = 0; i < this.stack.length; i += 3)if (this.stack[i] != other.stack[i]) return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */ get parser() {\n        return this.p.parser;\n    }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */ dialectEnabled(dialectID) {\n        return this.p.parser.dialect.flags[dialectID];\n    }\n    shiftContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */ emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */ emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash) this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */ setLookAhead(lookAhead) {\n        if (lookAhead <= this.lookAhead) return false;\n        this.emitLookAhead();\n        this.lookAhead = lookAhead;\n        return true;\n    }\n    /**\n    @internal\n    */ close() {\n        if (this.curContext && this.curContext.tracker.strict) this.emitContext();\n        if (this.lookAhead > 0) this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context){\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start){\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */ , depth = action >> 19 /* Action.ReduceDepthShift */ ;\n        if (depth == 0) {\n            if (this.stack == this.start.stack) this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        } else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index){\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0) this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0) this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\") return input;\n    let array = null;\n    for(let pos = 0, out = 0; pos < input.length;){\n        let value = 0;\n        for(;;){\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */ ) {\n                value = 65535 /* Encode.BigVal */ ;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */ ) next--;\n            if (next >= 34 /* Encode.Gap1 */ ) next--;\n            let digit = next - 32 /* Encode.Start */ ;\n            if (digit >= 46 /* Encode.Base */ ) {\n                digit -= 46 /* Encode.Base */ ;\n                stop = true;\n            }\n            value += digit;\n            if (stop) break;\n            value *= 46 /* Encode.Base */ ;\n        }\n        if (array) array[out++] = value;\n        else array = new Type(value);\n    }\n    return array;\n}\nclass CachedToken {\n    constructor(){\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/ class InputStream {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ input, /**\n    @internal\n    */ ranges){\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */ this.chunk = \"\";\n        /**\n        @internal\n        */ this.chunkOff = 0;\n        /**\n        Backup chunk\n        */ this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */ this.next = -1;\n        /**\n        @internal\n        */ this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */ resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while(pos < range.from){\n            if (!index) return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while(assoc < 0 ? pos > range.to : pos >= range.to){\n            if (index == this.ranges.length - 1) return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */ clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to) return pos;\n        for (let range of this.ranges)if (range.to > pos) return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsing—when looking forward—or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */ peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        } else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null) return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            } else {\n                let i = this.rangeIndex, range = this.range;\n                while(range.to <= pos)range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */ acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start) throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */ acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        } else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length) return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */ advance(n = 1) {\n        this.chunkOff += n;\n        while(this.pos + n >= this.range.to){\n            if (this.rangeIndex == this.ranges.length - 1) return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */ reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        } else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while(pos < this.range.from)this.range = this.ranges[--this.rangeIndex];\n            while(pos >= this.range.to)this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            } else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */ read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges){\n            if (r.from >= to) break;\n            if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/ class TokenGroup {\n    constructor(data, id){\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/ class LocalTokenGroup {\n    constructor(data, precTable, elseToken){\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for(;;){\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1) break;\n            if (this.elseToken == null) return;\n            if (!atEof) skipped++;\n            if (nextPos == null) break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/ class ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */ constructor(/**\n    @internal\n    */ token, options = {}){\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for(;;){\n        if ((groupMask & data[state]) == 0) break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for(let i = state + 3; i < accEnd; i += 2)if ((data[i + 1] & groupMask) > 0) {\n            let term = data[i];\n            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {\n                input.acceptToken(term);\n                break;\n            }\n        }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ ) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for(; low < high;){\n            let mid = low + high >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from) high = mid;\n            else if (next >= to) low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for(let i = start, next; (next = data[i]) != 65535 /* Seq.End */ ; i++)if (next == term) return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for(;;){\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for(;;){\n            if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */ )) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */ ));\n            if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;\n            if (!cursor.parent()) return side < 0 ? 0 : tree.length;\n        }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet){\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while(this.trees.length){\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        } else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart) return null;\n        while(this.fragment && this.safeTo <= pos)this.nextFragment();\n        if (!this.fragment) return null;\n        for(;;){\n            let last = this.trees.length - 1;\n            if (last < 0) {\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom) return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to) return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) {\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            } else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream){\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map((_)=>new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */ );\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for(let i = 0; i < tokenizers.length; i++){\n            if ((1 << i & mask) == 0) continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback) continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Lookahead.Margin */ ) lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */ ) {\n                let startIndex = actionIndex;\n                if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex) break;\n                }\n            }\n        }\n        while(this.actions.length > actionIndex)this.actions.pop();\n        if (lookAhead) stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken) return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */ ;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for(let i = 0; i < parser.specialized.length; i++)if (parser.specialized[i] == token.value) {\n                let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                    if ((result & 1) == 0 /* Specialize.Specialize */ ) token.value = result >> 1;\n                    else token.extended = result >> 1;\n                    break;\n                }\n            }\n        } else {\n            token.value = 0 /* Term.Err */ ;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for(let i = 0; i < index; i += 3)if (this.actions[i] == action) return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for(let set = 0; set < 2; set++){\n            for(let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ );; i += 3){\n                if (data[i] == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) {\n                        i = pair(data, i + 2);\n                    } else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */ ) index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges){\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [\n            Stack.start(this, parser.top[0], from)\n        ];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */  && stacks.length == 1) {\n            let [s] = stacks;\n            while(s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart){}\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i];\n            for(;;){\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                } else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                } else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose) console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped) console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering) this.recovering = 5 /* Rec.Distance */ ;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose) console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */ ;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b)=>b.score - a.score);\n                while(newStacks.length > maxRemaining)newStacks.pop();\n            }\n            if (newStacks.some((s)=>s.reducePos > pos)) this.recovering--;\n        } else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for(let i = 0; i < newStacks.length - 1; i++){\n                let stack = newStacks[i];\n                for(let j = i + 1; j < newStacks.length; j++){\n                    let other = newStacks[j];\n                    if (stack.sameState(other) || stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */  && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */ ) {\n                        if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {\n                            newStacks.splice(j--, 1);\n                        } else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */ ) {\n                newStacks.sort((a, b)=>b.score - a.score);\n                newStacks.splice(12 /* Rec.MaxStackCount */ , newStacks.length - 12 /* Rec.MaxStackCount */ );\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for(let i = 1; i < newStacks.length; i++)if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for(let cached = this.fragments.nodeAt(start); cached;){\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0) cached = inner;\n                else break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */ );\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */ )})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */ ) {\n            while(stack.stack.length > 6000 /* Rec.CutTo */  && stack.forceReduce()){}\n        }\n        let actions = this.tokens.getActions(stack);\n        for(let i = 0; i < actions.length;){\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */ ) == 0 ? \"shift\" : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */ )}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last) return true;\n            else if (localStack.pos > start) stacks.push(localStack);\n            else split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for(;;){\n            if (!this.advanceStack(stack, null, null)) return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted) continue;\n                restarted = true;\n                stack.restart();\n                if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done) continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for(let j = 0; j < 10 /* Rec.ForceReduceLimit */  && force.forceReduce(); j++){\n                if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done) break;\n                if (verbose) forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)){\n                if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */ ;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            } else if (!finished || finished.score < force.score) {\n                finished = force;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm\n        });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for(let i = 0; i < newStacks.length; i++){\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score) newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled){\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) {\n        return !this.disabled || this.disabled[term] == 0;\n    }\n}\nconst id = (x)=>x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/ class ContextTracker {\n    /**\n    Define a context tracker.\n    */ constructor(spec){\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (()=>0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/ class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */ constructor(spec){\n        super();\n        /**\n        @internal\n        */ this.wrappers = [];\n        if (spec.version != 14 /* File.Version */ ) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */ })`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for(let i = 0; i < spec.repeatNodeCount; i++)nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map((r)=>spec.topRules[r][1]);\n        let nodeProps = [];\n        for(let i = 0; i < nodeNames.length; i++)nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([\n                prop,\n                prop.deserialize(String(value))\n            ]);\n        }\n        if (spec.nodeProps) for (let propSpec of spec.nodeProps){\n            let prop = propSpec[0];\n            if (typeof prop == \"string\") prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n            for(let i = 1; i < propSpec.length;){\n                let next = propSpec[i++];\n                if (next >= 0) {\n                    setProp(next, prop, propSpec[i++]);\n                } else {\n                    let value = propSpec[i + -next];\n                    for(let j = -next; j > 0; j--)setProp(propSpec[i++], prop, value);\n                    i++;\n                }\n            }\n        }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i)=>_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n                name: i >= this.minRepeatTerm ? undefined : name,\n                id: i,\n                props: nodeProps[i],\n                top: topTerms.indexOf(i) > -1,\n                error: i == 0,\n                skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n            })));\n        if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for(let i = 0; i < this.specializerSpecs.length; i++)this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map((value)=>typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */ getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0]) return -1;\n        for(let pos = table[term + 1];;){\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose) return target;\n            for(let end = pos + (groupTag >> 1); pos < end; pos++)if (table[pos] == state) return target;\n            if (last) return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */ hasAction(state, terminal) {\n        let data = this.data;\n        for(let set = 0; set < 2; set++){\n            for(let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ ), next;; i += 3){\n                if ((next = data[i]) == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */ ) return pair(data, i + 2);\n                    else break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */ ) return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */ stateSlot(state, slot) {\n        return this.states[state * 6 /* ParseState.Size */  + slot];\n    }\n    /**\n    @internal\n    */ stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */ ) & flag) > 0;\n    }\n    /**\n    @internal\n    */ validAction(state, action) {\n        return !!this.allActions(state, (a)=>a == action ? true : null);\n    }\n    /**\n    @internal\n    */ allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */ );\n        let result = deflt ? action(deflt) : undefined;\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ ); result == null; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */ nextStates(state) {\n        let result = [];\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ );; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            if ((this.data[i + 2] & 65536 /* Action.ReduceFlag */  >> 16) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i)=>i & 1 && v == value)) result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */ configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers) copy.tokenizers = this.tokenizers.map((t)=>{\n            let found = config.tokenizers.find((r)=>r.from == t);\n            return found ? found.to : t;\n        });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i)=>{\n                let found = config.specializers.find((r)=>r.from == s.external);\n                if (!found) return s;\n                let spec = Object.assign(Object.assign({}, s), {\n                    external: found.to\n                });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker) copy.context = config.contextTracker;\n        if (config.dialect) copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null) copy.strict = config.strict;\n        if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null) copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */ hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */ getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */ get eofTerm() {\n        return this.maxNode + 1;\n    }\n    /**\n    The type of top node produced by the parser.\n    */ get topNode() {\n        return this.nodeSet.types[this.top[1]];\n    }\n    /**\n    @internal\n    */ dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */ parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(()=>false);\n        if (dialect) for (let part of dialect.split(\" \")){\n            let id = values.indexOf(part);\n            if (id >= 0) flags[id] = true;\n        }\n        let disabled = null;\n        for(let i = 0; i < values.length; i++)if (!flags[i]) {\n            for(let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */ ;)(disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n        }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */ static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) {\n    return data[off] | data[off + 1] << 16;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks){\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */ ) && (!best || best.score < stack.score)) best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */  : 0 /* Specialize.Specialize */ ;\n        return (value, stack)=>spec.external(value, stack) << 1 | mask;\n    }\n    return spec.get;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxlemVyK2xyQDEuNC43L25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlHO0FBRXpHOzs7OztBQUtBLEdBQ0EsTUFBTU87SUFDRjs7SUFFQSxHQUNBQyxZQUNBOztJQUVBLEdBQ0FDLENBQUMsRUFDRDs7O0lBR0EsR0FDQUMsS0FBSyxFQUNMOztJQUVBLEdBQ0FDLEtBQUssRUFDTCxnRUFBZ0U7SUFDaEUsaUVBQWlFO0lBQ2pFLGdFQUFnRTtJQUNoRSxhQUFhO0lBQ2I7O0lBRUEsR0FDQUMsU0FBUyxFQUNUOztJQUVBLEdBQ0FDLEdBQUcsRUFDSDs7OztJQUlBLEdBQ0FDLEtBQUssRUFDTCwwREFBMEQ7SUFDMUQsNERBQTREO0lBQzVELHVEQUF1RDtJQUN2RDs7SUFFQSxHQUNBQyxNQUFNLEVBQ04sa0VBQWtFO0lBQ2xFLDJEQUEyRDtJQUMzRCw0REFBNEQ7SUFDNUQsaUVBQWlFO0lBQ2pFLGtCQUFrQjtJQUNsQjs7SUFFQSxHQUNBQyxVQUFVLEVBQ1Y7O0lBRUEsR0FDQUMsVUFBVSxFQUNWOztJQUVBLEdBQ0FDLFlBQVksQ0FBQyxFQUNiLGdFQUFnRTtJQUNoRSwyREFBMkQ7SUFDM0QsNERBQTREO0lBQzVELGdCQUFnQjtJQUNoQjs7SUFFQSxHQUNBQyxNQUFNLENBQUU7UUFDSixJQUFJLENBQUNWLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFNBQVMs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QU9yRSxVQUFVLElBQUswSTtJQUNsRTtJQUNBLE9BQU82SyxLQUFLUixHQUFHO0FBQ25CO0FBRTRGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VudGluZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxlemVyK2xyQDEuNC43L25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcz9iOWZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnNlciwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBUcmVlLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xucGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG50aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YWNrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHAsIFxuICAgIC8qKlxuICAgIEhvbGRzIHN0YXRlLCBpbnB1dCBwb3MsIGJ1ZmZlciBpbmRleCB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGVcbiAgICB0b3Agc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFjaywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZVBvcywgXG4gICAgLyoqXG4gICAgVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3VyQ29udGV4dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gY3VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhY2sncyBjdXJyZW50IFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIpIHZhbHVlLCBpZlxuICAgIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICB0cmFja2VyLlxuICAgICovXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgbGV0IGxvb2thaGVhZFJlY29yZCA9IHRoaXMucmVkdWNlUG9zIDwgdGhpcy5wb3MgLSAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovICYmIHRoaXMuc2V0TG9va0FoZWFkKHRoaXMucG9zKTtcbiAgICAgICAgbGV0IGRQcmVjID0gcGFyc2VyLmR5bmFtaWNQcmVjZWRlbmNlKHR5cGUpO1xuICAgICAgICBpZiAoZFByZWMpXG4gICAgICAgICAgICB0aGlzLnNjb3JlICs9IGRQcmVjO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGFyc2VyLmdldEdvdG8odGhpcy5zdGF0ZSwgdHlwZSwgdHJ1ZSksIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIC8vIFplcm8tZGVwdGggcmVkdWN0aW9ucyBhcmUgYSBzcGVjaWFsIGNhc2XigJR0aGV5IGFkZCBzdHVmZiB0b1xuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgcG9wcGluZyBhbnl0aGluZyBvZmYuXG4gICAgICAgICAgICBpZiAodHlwZSA8IHBhcnNlci5taW5SZXBlYXRUZXJtKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgbG9va2FoZWFkUmVjb3JkID8gOCA6IDQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZWR1Y2VDb250ZXh0KHR5cGUsIHRoaXMucmVkdWNlUG9zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBiYXNlIGluZGV4IGludG8gYHRoaXMuc3RhY2tgLCBjb250ZW50IGFmdGVyIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgZHJvcHBlZC4gTm90ZSB0aGF0IHdpdGggYFN0YXlGbGFnYCByZWR1Y3Rpb25zIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY29uc3VtZSB0d28gZXh0cmEgZnJhbWVzICh0aGUgZHVtbXkgcGFyZW50IG5vZGUgZm9yIHRoZSBza2lwcGVkXG4gICAgICAgIC8vIGV4cHJlc3Npb24gYW5kIHRoZSBzdGF0ZSB0aGF0IHdlJ2xsIGJlIHN0YXlpbmcgaW4sIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBiZSBtb3ZlZCB0byBgdGhpcy5zdGF0ZWApLlxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKChkZXB0aCAtIDEpICogMykgLSAoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLyA/IDYgOiAwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gYmFzZSA/IHRoaXMuc3RhY2tbYmFzZSAtIDJdIDogdGhpcy5wLnJhbmdlc1swXS5mcm9tLCBzaXplID0gdGhpcy5yZWR1Y2VQb3MgLSBzdGFydDtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGtsdWRnZSB0byB0cnkgYW5kIGRldGVjdCBvdmVybHkgZGVlcCBsZWZ0LWFzc29jaWF0aXZlXG4gICAgICAgIC8vIHRyZWVzLCB3aGljaCB3aWxsIG5vdCBpbmNyZWFzZSB0aGUgcGFyc2Ugc3RhY2sgZGVwdGggYW5kIHRodXNcbiAgICAgICAgLy8gd29uJ3QgYmUgY2F1Z2h0IGJ5IHRoZSByZWd1bGFyIHN0YWNrLWRlcHRoIGxpbWl0IGNoZWNrLlxuICAgICAgICBpZiAoc2l6ZSA+PSAyMDAwIC8qIFJlY292ZXIuTWluQmlnUmVkdWN0aW9uICovICYmICEoKF9hID0gdGhpcy5wLnBhcnNlci5ub2RlU2V0LnR5cGVzW3R5cGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNBbm9ueW1vdXMpKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPCBzaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmJpZ1JlZHVjdGlvbkNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmZmVyQmFzZSA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAxXSA6IDAsIGNvdW50ID0gdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoIC0gYnVmZmVyQmFzZTtcbiAgICAgICAgLy8gU3RvcmUgbm9ybWFsIHRlcm1zIG9yIGBSIC0+IFIgUmAgcmVwZWF0IHJlZHVjdGlvbnNcbiAgICAgICAgaWYgKHR5cGUgPCBwYXJzZXIubWluUmVwZWF0VGVybSB8fCAoYWN0aW9uICYgMTMxMDcyIC8qIEFjdGlvbi5SZXBlYXRGbGFnICovKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHBhcnNlci5zdGF0ZUZsYWcodGhpcy5zdGF0ZSwgMSAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqLykgPyB0aGlzLnBvcyA6IHRoaXMucmVkdWNlUG9zO1xuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgc3RhcnQsIHBvcywgY291bnQgKyA0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uICYgMjYyMTQ0IC8qIEFjdGlvbi5TdGF5RmxhZyAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmFzZVN0YXRlSUQgPSB0aGlzLnN0YWNrW2Jhc2UgLSAzXTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBwYXJzZXIuZ2V0R290byhiYXNlU3RhdGVJRCwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gYmFzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgfVxuICAgIC8vIFNoaWZ0IGEgdmFsdWUgaW50byB0aGUgYnVmZmVyXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdG9yZU5vZGUodGVybSwgc3RhcnQsIGVuZCwgc2l6ZSA9IDQsIG11c3RTaW5rID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRlcm0gPT0gMCAvKiBUZXJtLkVyciAqLyAmJlxuICAgICAgICAgICAgKCF0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gPCB0aGlzLmJ1ZmZlci5sZW5ndGggKyB0aGlzLmJ1ZmZlckJhc2UpKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gb21pdC9tZXJnZSBhZGphY2VudCBlcnJvciBub2Rlc1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMsIHRvcCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3AgPT0gMCAmJiBjdXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gY3VyLmJ1ZmZlckJhc2UgLSBjdXIucGFyZW50LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3AgPiAwICYmIGN1ci5idWZmZXJbdG9wIC0gNF0gPT0gMCAvKiBUZXJtLkVyciAqLyAmJiBjdXIuYnVmZmVyW3RvcCAtIDFdID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5idWZmZXJbdG9wIC0gMl0gPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLmJ1ZmZlclt0b3AgLSAyXSA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW11c3RTaW5rIHx8IHRoaXMucG9zID09IGVuZCkgeyAvLyBTaW1wbGUgY2FzZSwganVzdCBhcHBlbmRcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGVybSwgc3RhcnQsIGVuZCwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFRoZXJlIG1heSBiZSBza2lwcGVkIG5vZGVzIHRoYXQgaGF2ZSB0byBiZSBtb3ZlZCBmb3J3YXJkXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwICYmICh0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogVGVybS5FcnIgKi8gfHwgdGhpcy5idWZmZXJbaW5kZXggLSAxXSA8IDApKSB7XG4gICAgICAgICAgICAgICAgbGV0IG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IGluZGV4OyBzY2FuID4gMCAmJiB0aGlzLmJ1ZmZlcltzY2FuIC0gMl0gPiBlbmQ7IHNjYW4gLT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZmZXJbc2NhbiAtIDFdID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtdXN0TW92ZSlcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoaXMgcmVjb3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4XSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT0gNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2hpZnQoYWN0aW9uLCB0eXBlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgLy8gU2tpcHBlZCBvciB6ZXJvLWxlbmd0aCBub24tdHJlZSB0b2tlbnMgZG9uJ3QgbW92ZSByZWR1Y2VQb3NcbiAgICAgICAgICAgIGlmICghcGFyc2VyLnN0YXRlRmxhZyhuZXh0U3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pICYmIChlbmQgPiBzdGFydCB8fCB0eXBlIDw9IHBhcnNlci5tYXhOb2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKG5leHRTdGF0ZSwgTWF0aC5taW4oc3RhcnQsIHRoaXMucmVkdWNlUG9zKSk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAodHlwZSA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godHlwZSwgc3RhcnQsIGVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dFN0YXJ0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHZhbHVlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHRoaXMucG9zIC0gdmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMucCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgdGhpcy5jdXJDb250ZXh0LCB0aGlzLmxvb2tBaGVhZCwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAxOTAgLyogUmVjb3Zlci5EZWxldGUgKi87XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgICovXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHNpbS5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHNpbS5zdGF0ZSwgdGVybSk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIFJlY292ZXIuTWF4SW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLnAucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBiZXN0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZXN0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKHMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5zaGlmdENvbnRleHQobmV4dFN0YXRlc1tpXSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogUmVjb3Zlci5JbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCByZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogUGFyc2VTdGF0ZS5Gb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSByZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gZGVwdGggKiAzO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhY2t1cCA9IHRoaXMuZmluZEZvcmNlZFJlZHVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChiYWNrdXAgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlZHVjZSA9IGJhY2t1cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWNvdmVyLlJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIHNjYW4gdGhyb3VnaCB0aGUgYXV0b21hdG9uIHRvIGZpbmQgc29tZSBraW5kIG9mIHJlZHVjdGlvblxuICAgIHRoYXQgY2FuIGJlIGFwcGxpZWQuIFVzZWQgd2hlbiB0aGUgcmVndWxhciBGb3JjZWRSZWR1Y2UgZmllbGRcbiAgICBpc24ndCBhIHZhbGlkIGFjdGlvbi4gQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kRm9yY2VkUmVkdWN0aW9uKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucCwgc2VlbiA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9IChzdGF0ZSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluY2x1ZGVzKHN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWVuLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5hbGxBY3Rpb25zKHN0YXRlLCAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmICgyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovIHwgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgckRlcHRoID0gKGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgLSBkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSByRGVwdGggKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA+PSAwICYmIHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyRGVwdGggPDwgMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIHwgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gfCB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBleHBsb3JlKGFjdGlvbiwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHBsb3JlKHRoaXMuc3RhdGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlZHVjZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgc29tZWhvdykuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgKi9cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICAqL1xuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJlZHVjZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnBvcywgdGhpcy5wb3MsIC0zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucG9zLCB0aGlzLnBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgIGlmIChsb29rQWhlYWQgPD0gdGhpcy5sb29rQWhlYWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQgJiYgdGhpcy5jdXJDb250ZXh0LnRyYWNrZXIuc3RyaWN0KVxuICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5sb29rQWhlYWQgPiAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2tDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFja2VyLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJhY2tlciA9IHRyYWNrZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRyYWNrZXIuc3RyaWN0ID8gdHJhY2tlci5oYXNoKGNvbnRleHQpIDogMDtcbiAgICB9XG59XG4vLyBVc2VkIHRvIGNoZWFwbHkgcnVuIHNvbWUgcmVkdWN0aW9ucyB0byBzY2FuIGFoZWFkIHdpdGhvdXQgbXV0YXRpbmdcbi8vIGFuIGVudGlyZSBzdGFja1xuY2xhc3MgU2ltdWxhdGVkU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhcnQuc3RhY2s7XG4gICAgICAgIHRoaXMuYmFzZSA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIH1cbiAgICByZWR1Y2UoYWN0aW9uKSB7XG4gICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi87XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UgKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSAtPSAoZGVwdGggLSAxKSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvdG8gPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgdGVybSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBnb3RvO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgZ2l2ZW4gdG8gYFRyZWUuYnVpbGRgIHRvIGJ1aWxkIGEgYnVmZmVyLCBhbmQgZW5jYXBzdWxhdGVzXG4vLyB0aGUgcGFyZW50LXN0YWNrLXdhbGtpbmcgbmVjZXNzYXJ5IHRvIHJlYWQgdGhlIG5vZGVzLlxuY2xhc3MgU3RhY2tCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrLCBwb3MsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBzdGFjay5idWZmZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IDApXG4gICAgICAgICAgICB0aGlzLm1heWJlTmV4dCgpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHN0YWNrLCBwb3MgPSBzdGFjay5idWZmZXJCYXNlICsgc3RhY2suYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQnVmZmVyQ3Vyc29yKHN0YWNrLCBwb3MsIHBvcyAtIHN0YWNrLmJ1ZmZlckJhc2UpO1xuICAgIH1cbiAgICBtYXliZU5leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5zdGFjay5wYXJlbnQ7XG4gICAgICAgIGlmIChuZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBuZXh0LmJ1ZmZlckJhc2U7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV4dDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV4dC5idWZmZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCAtPSA0O1xuICAgICAgICB0aGlzLnBvcyAtPSA0O1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgZm9yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcih0aGlzLnN0YWNrLCB0aGlzLnBvcywgdGhpcy5pbmRleCk7XG4gICAgfVxufVxuXG4vLyBTZWUgbGV6ZXItZ2VuZXJhdG9yL3NyYy9lbmNvZGUudHMgZm9yIGNvbW1lbnRzIGFib3V0IHRoZSBlbmNvZGluZ1xuLy8gdXNlZCBoZXJlXG5mdW5jdGlvbiBkZWNvZGVBcnJheShpbnB1dCwgVHlwZSA9IFVpbnQxNkFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgbGV0IGFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBvdXQgPSAwOyBwb3MgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MrKyksIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IDEyNiAvKiBFbmNvZGUuQmlnVmFsQ29kZSAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gNjU1MzUgLyogRW5jb2RlLkJpZ1ZhbCAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID49IDkyIC8qIEVuY29kZS5HYXAyICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGlmIChuZXh0ID49IDM0IC8qIEVuY29kZS5HYXAxICovKVxuICAgICAgICAgICAgICAgIG5leHQtLTtcbiAgICAgICAgICAgIGxldCBkaWdpdCA9IG5leHQgLSAzMiAvKiBFbmNvZGUuU3RhcnQgKi87XG4gICAgICAgICAgICBpZiAoZGlnaXQgPj0gNDYgLyogRW5jb2RlLkJhc2UgKi8pIHtcbiAgICAgICAgICAgICAgICBkaWdpdCAtPSA0NiAvKiBFbmNvZGUuQmFzZSAqLztcbiAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGRpZ2l0O1xuICAgICAgICAgICAgaWYgKHN0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YWx1ZSAqPSA0NiAvKiBFbmNvZGUuQmFzZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICBhcnJheVtvdXQrK10gPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuY2xhc3MgQ2FjaGVkVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMudmFsdWUgPSAtMTtcbiAgICAgICAgdGhpcy5lbmQgPSAtMTtcbiAgICAgICAgdGhpcy5leHRlbmRlZCA9IC0xO1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IDA7XG4gICAgICAgIHRoaXMubWFzayA9IDA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IDA7XG4gICAgfVxufVxuY29uc3QgbnVsbFRva2VuID0gbmV3IENhY2hlZFRva2VuO1xuLyoqXG5bVG9rZW5pemVyc10oI2xyLkV4dGVybmFsVG9rZW5pemVyKSBpbnRlcmFjdCB3aXRoIHRoZSBpbnB1dFxudGhyb3VnaCB0aGlzIGludGVyZmFjZS4gSXQgcHJlc2VudHMgdGhlIGlucHV0IGFzIGEgc3RyZWFtIG9mXG5jaGFyYWN0ZXJzLCB0cmFja2luZyBsb29rYWhlYWQgYW5kIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZlxuW3Jhbmdlc10oI2NvbW1vbi5QYXJzZXIucGFyc2VecmFuZ2VzKSBmcm9tIHRva2VuaXplciBjb2RlLlxuKi9cbmNsYXNzIElucHV0U3RyZWFtIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBCYWNrdXAgY2h1bmtcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaHVuazIgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rMlBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY2hhcmFjdGVyIGNvZGUgb2YgdGhlIG5leHQgY29kZSB1bml0IGluIHRoZSBpbnB1dCwgb3IgLTFcbiAgICAgICAgd2hlbiB0aGUgc3RyZWFtIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2VuID0gbnVsbFRva2VuO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5lbmQgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU9mZnNldChvZmZzZXQsIGFzc29jKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMucmFuZ2UsIGluZGV4ID0gdGhpcy5yYW5nZUluZGV4O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3MgKyBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChwb3MgPCByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1stLWluZGV4XTtcbiAgICAgICAgICAgIHBvcyAtPSByYW5nZS5mcm9tIC0gbmV4dC50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXNzb2MgPCAwID8gcG9zID4gcmFuZ2UudG8gOiBwb3MgPj0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnJhbmdlc1srK2luZGV4XTtcbiAgICAgICAgICAgIHBvcyArPSBuZXh0LmZyb20gLSByYW5nZS50bztcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsaXBQb3MocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy5yYW5nZS5mcm9tICYmIHBvcyA8IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0aGlzLnJhbmdlcylcbiAgICAgICAgICAgIGlmIChyYW5nZS50byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocG9zLCByYW5nZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgICBgLm5leHRgLCBgLnBlZWsoLTEpYCBnaXZlcyB5b3UgdGhlIHByZXZpb3VzIGNoYXJhY3RlciwgYW5kIHNvXG4gICAgb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGxvb2tpbmcgYXJvdW5kIGR1cmluZyB0b2tlbml6aW5nIGNyZWF0ZXMgZGVwZW5kZW5jaWVzXG4gICAgb24gcG90ZW50aWFsbHkgZmFyLWF3YXkgY29udGVudCwgd2hpY2ggbWF5IHJlZHVjZSB0aGVcbiAgICBlZmZlY3RpdmVuZXNzIGluY3JlbWVudGFsIHBhcnNpbmfigJR3aGVuIGxvb2tpbmcgZm9yd2FyZOKAlG9yIGV2ZW5cbiAgICBjYXVzZSBpbnZhbGlkIHJlcGFyc2VzIHdoZW4gbG9va2luZyBiYWNrd2FyZCBtb3JlIHRoYW4gMjUgY29kZVxuICAgIHVuaXRzLCBzaW5jZSB0aGUgbGlicmFyeSBkb2VzIG5vdCB0cmFjayBsb29rYmVoaW5kLlxuICAgICovXG4gICAgcGVlayhvZmZzZXQpIHtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuY2h1bmtPZmYgKyBvZmZzZXQsIHBvcywgcmVzdWx0O1xuICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVPZmZzZXQob2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHBvcyA9IHJlc29sdmVkO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiBwb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQocG9zIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnJhbmdlSW5kZXgsIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFuZ2UudG8gPD0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMucmFuZ2VzWysraV07XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmlucHV0LmNodW5rKHRoaXMuY2h1bmsyUG9zID0gcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICsgdGhpcy5jaHVuazIubGVuZ3RoID4gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuazIuc2xpY2UoMCwgcmFuZ2UudG8gLSBwb3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZClcbiAgICAgICAgICAgIHRoaXMudG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgICBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbiwgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXQgKHJlbGF0aXZlIHRvXG4gICAgdGhlIHN0cmVhbSBwb3NpdGlvbikgdG8gY2hhbmdlIHRoYXQuXG4gICAgKi9cbiAgICBhY2NlcHRUb2tlbih0b2tlbiwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZW5kID0gZW5kT2Zmc2V0ID8gdGhpcy5yZXNvbHZlT2Zmc2V0KGVuZE9mZnNldCwgLTEpIDogdGhpcy5wb3M7XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPCB0aGlzLnRva2VuLnN0YXJ0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUb2tlbiBlbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWNjZXB0IGEgdG9rZW4gZW5kaW5nIGF0IGEgc3BlY2lmaWMgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBhY2NlcHRUb2tlblRvKHRva2VuLCBlbmRQb3MpIHtcbiAgICAgICAgdGhpcy50b2tlbi52YWx1ZSA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuLmVuZCA9IGVuZFBvcztcbiAgICB9XG4gICAgZ2V0Q2h1bmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmNodW5rMlBvcyAmJiB0aGlzLnBvcyA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBjaHVuaywgY2h1bmtQb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNodW5rID0gdGhpcy5jaHVuazI7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5jaHVuazJQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSBjaHVua1BvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSB0aGlzLnBvcyAtIHRoaXMuY2h1bmtQb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICAgICAgICBsZXQgbmV4dENodW5rID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLnBvcyk7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgKyBuZXh0Q2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IGVuZCA+IHRoaXMucmFuZ2UudG8gPyBuZXh0Q2h1bmsuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IG5leHRDaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5jaHVua09mZiA+PSB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5nZXRDaHVuaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIHN0cmVhbSBmb3J3YXJkIE4gKGRlZmF1bHRzIHRvIDEpIGNvZGUgdW5pdHMuIFJldHVybnNcbiAgICB0aGUgbmV3IHZhbHVlIG9mIFtgbmV4dGBdKCNsci5JbnB1dFN0cmVhbS5uZXh0KS5cbiAgICAqL1xuICAgIGFkdmFuY2UobiA9IDEpIHtcbiAgICAgICAgdGhpcy5jaHVua09mZiArPSBuO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgKyBuID49IHRoaXMucmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlSW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICBuIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmFuZ2UuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZE5leHQoKTtcbiAgICB9XG4gICAgc2V0RG9uZSgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldChwb3MsIHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdG9rZW4uc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB0b2tlbi5sb29rQWhlYWQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi5leHRlbmRlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgIT0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgICAgIGlmIChwb3MgPT0gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLnJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWy0tdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPj0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0aGlzLmNodW5rUG9zICYmIHBvcyA8IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSBwb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVuayA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rUG9zICYmIHRvIDw9IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rLnNsaWNlKGZyb20gLSB0aGlzLmNodW5rUG9zLCB0byAtIHRoaXMuY2h1bmtQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLmNodW5rMlBvcyAmJiB0byA8PSB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rMi5zbGljZShmcm9tIC0gdGhpcy5jaHVuazJQb3MsIHRvIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgICBpZiAoZnJvbSA+PSB0aGlzLnJhbmdlLmZyb20gJiYgdG8gPD0gdGhpcy5yYW5nZS50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LnJlYWQoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChyLnRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5pbnB1dC5yZWFkKE1hdGgubWF4KHIuZnJvbSwgZnJvbSksIE1hdGgubWluKHIudG8sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNsYXNzIFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGlkKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gc3RhY2sucDtcbiAgICAgICAgcmVhZFRva2VuKHRoaXMuZGF0YSwgaW5wdXQsIHN0YWNrLCB0aGlzLmlkLCBwYXJzZXIuZGF0YSwgcGFyc2VyLnRva2VuUHJlY1RhYmxlKTtcbiAgICB9XG59XG5Ub2tlbkdyb3VwLnByb3RvdHlwZS5jb250ZXh0dWFsID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZmFsbGJhY2sgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5leHRlbmQgPSBmYWxzZTtcbi8qKlxuQGhpZGVcbiovXG5jbGFzcyBMb2NhbFRva2VuR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHByZWNUYWJsZSwgZWxzZVRva2VuKSB7XG4gICAgICAgIHRoaXMucHJlY1RhYmxlID0gcHJlY1RhYmxlO1xuICAgICAgICB0aGlzLmVsc2VUb2tlbiA9IGVsc2VUb2tlbjtcbiAgICAgICAgdGhpcy5kYXRhID0gdHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiA/IGRlY29kZUFycmF5KGRhdGEpIDogZGF0YTtcbiAgICB9XG4gICAgdG9rZW4oaW5wdXQsIHN0YWNrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IGlucHV0LnBvcywgc2tpcHBlZCA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEVvZiA9IGlucHV0Lm5leHQgPCAwLCBuZXh0UG9zID0gaW5wdXQucmVzb2x2ZU9mZnNldCgxLCAxKTtcbiAgICAgICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgMCwgdGhpcy5kYXRhLCB0aGlzLnByZWNUYWJsZSk7XG4gICAgICAgICAgICBpZiAoaW5wdXQudG9rZW4udmFsdWUgPiAtMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLmVsc2VUb2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghYXRFb2YpXG4gICAgICAgICAgICAgICAgc2tpcHBlZCsrO1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KG5leHRQb3MsIGlucHV0LnRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgICAgaW5wdXQucmVzZXQoc3RhcnQsIGlucHV0LnRva2VuKTtcbiAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRoaXMuZWxzZVRva2VuLCBza2lwcGVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkxvY2FsVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbmBAZXh0ZXJuYWwgdG9rZW5zYCBkZWNsYXJhdGlvbnMgaW4gdGhlIGdyYW1tYXIgc2hvdWxkIHJlc29sdmUgdG9cbmFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgRXh0ZXJuYWxUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICAgIGdpdmVuIGFuIGlucHV0IHN0cmVhbSwgc2NhbnMgZm9yIHRoZSB0eXBlcyBvZiB0b2tlbnMgaXRcbiAgICByZWNvZ25pemVzIGF0IHRoZSBzdHJlYW0ncyBwb3NpdGlvbiwgYW5kIGNhbGxzXG4gICAgW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICAgIG9uZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuY29udGV4dHVhbCA9ICEhb3B0aW9ucy5jb250ZXh0dWFsO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gISFvcHRpb25zLmZhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4dGVuZCA9ICEhb3B0aW9ucy5leHRlbmQ7XG4gICAgfVxufVxuLy8gVG9rZW5pemVyIGRhdGEgaXMgc3RvcmVkIGEgYmlnIHVpbnQxNiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaFxuLy8gc3RhdGU6XG4vL1xuLy8gIC0gQSBncm91cCBiaXRtYXNrLCBpbmRpY2F0aW5nIHdoYXQgdG9rZW4gZ3JvdXBzIGFyZSByZWFjaGFibGUgZnJvbVxuLy8gICAgdGhpcyBzdGF0ZSwgc28gdGhhdCBwYXRocyB0aGF0IGNhbiBvbmx5IGxlYWQgdG8gdG9rZW5zIG5vdCBpblxuLy8gICAgYW55IG9mIHRoZSBjdXJyZW50IGdyb3VwcyBjYW4gYmUgY3V0IG9mZiBlYXJseS5cbi8vXG4vLyAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3RhdGUncyBzZXF1ZW5jZSBvZiBhY2NlcHRpbmdcbi8vICAgIHRva2Vuc1xuLy9cbi8vICAtIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIHRoZSBzdGF0ZVxuLy9cbi8vICAtIFRoZSBhY2NlcHRpbmcgdG9rZW5zLCBhcyAodG9rZW4gaWQsIGdyb3VwIG1hc2spIHBhaXJzXG4vL1xuLy8gIC0gVGhlIG91dGdvaW5nIGVkZ2VzLCBhcyAoc3RhcnQgY2hhcmFjdGVyLCBlbmQgY2hhcmFjdGVyLCBzdGF0ZVxuLy8gICAgaW5kZXgpIHRyaXBsZXMsIHdpdGggZW5kIGNoYXJhY3RlciBiZWluZyBleGNsdXNpdmVcbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGludGVycHJldHMgdGhhdCBkYXRhLCBydW5uaW5nIHRocm91Z2ggYSBzdHJlYW0gYXNcbi8vIGxvbmcgYXMgbmV3IHN0YXRlcyB3aXRoIHRoZSBhIG1hdGNoaW5nIGdyb3VwIG1hc2sgY2FuIGJlIHJlYWNoZWQsXG4vLyBhbmQgdXBkYXRpbmcgYGlucHV0LnRva2VuYCB3aGVuIGl0IG1hdGNoZXMgYSB0b2tlbi5cbmZ1bmN0aW9uIHJlYWRUb2tlbihkYXRhLCBpbnB1dCwgc3RhY2ssIGdyb3VwLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpIHtcbiAgICBsZXQgc3RhdGUgPSAwLCBncm91cE1hc2sgPSAxIDw8IGdyb3VwLCB7IGRpYWxlY3QgfSA9IHN0YWNrLnAucGFyc2VyO1xuICAgIHNjYW46IGZvciAoOzspIHtcbiAgICAgICAgaWYgKChncm91cE1hc2sgJiBkYXRhW3N0YXRlXSkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgYWNjRW5kID0gZGF0YVtzdGF0ZSArIDFdO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGxlYWQgdG8gYSB0b2tlbiBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICAvLyBBY2NlcHQgdG9rZW5zIGluIHRoaXMgc3RhdGUsIHBvc3NpYmx5IG92ZXJ3cml0aW5nXG4gICAgICAgIC8vIGxvd2VyLXByZWNlZGVuY2UgLyBzaG9ydGVyIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhdGUgKyAzOyBpIDwgYWNjRW5kOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoKGRhdGFbaSArIDFdICYgZ3JvdXBNYXNrKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVybSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpYWxlY3QuYWxsb3dzKHRlcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnB1dC50b2tlbi52YWx1ZSA9PSAtMSB8fCBpbnB1dC50b2tlbi52YWx1ZSA9PSB0ZXJtIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXModGVybSwgaW5wdXQudG9rZW4udmFsdWUsIHByZWNUYWJsZSwgcHJlY09mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmFjY2VwdFRva2VuKHRlcm0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gaW5wdXQubmV4dCwgbG93ID0gMCwgaGlnaCA9IGRhdGFbc3RhdGUgKyAyXTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBFT0ZcbiAgICAgICAgaWYgKGlucHV0Lm5leHQgPCAwICYmIGhpZ2ggPiBsb3cgJiYgZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDNdID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgIHN0YXRlID0gZGF0YVthY2NFbmQgKyBoaWdoICogMyAtIDFdO1xuICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHN0YXRlJ3MgZWRnZXNcbiAgICAgICAgZm9yICg7IGxvdyA8IGhpZ2g7KSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBhY2NFbmQgKyBtaWQgKyAobWlkIDw8IDEpO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkYXRhW2luZGV4XSwgdG8gPSBkYXRhW2luZGV4ICsgMV0gfHwgMHgxMDAwMDtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSB0bylcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldChkYXRhLCBzdGFydCwgdGVybSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgbmV4dDsgKG5leHQgPSBkYXRhW2ldKSAhPSA2NTUzNSAvKiBTZXEuRW5kICovOyBpKyspXG4gICAgICAgIGlmIChuZXh0ID09IHRlcm0pXG4gICAgICAgICAgICByZXR1cm4gaSAtIHN0YXJ0O1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlcyh0b2tlbiwgcHJldiwgdGFibGVEYXRhLCB0YWJsZU9mZnNldCkge1xuICAgIGxldCBpUHJldiA9IGZpbmRPZmZzZXQodGFibGVEYXRhLCB0YWJsZU9mZnNldCwgcHJldik7XG4gICAgcmV0dXJuIGlQcmV2IDwgMCB8fCBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHRva2VuKSA8IGlQcmV2O1xufVxuXG4vLyBFbnZpcm9ubWVudCB2YXJpYWJsZSB1c2VkIHRvIGNvbnRyb2wgY29uc29sZSBvdXRwdXRcbmNvbnN0IHZlcmJvc2UgPSB0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIC9cXGJwYXJzZVxcYi8udGVzdChwcm9jZXNzLmVudi5MT0cpO1xubGV0IHN0YWNrSURzID0gbnVsbDtcbmZ1bmN0aW9uIGN1dEF0KHRyZWUsIHBvcywgc2lkZSkge1xuICAgIGxldCBjdXJzb3IgPSB0cmVlLmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTtcbiAgICBjdXJzb3IubW92ZVRvKHBvcyk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIShzaWRlIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZShwb3MpIDogY3Vyc29yLmNoaWxkQWZ0ZXIocG9zKSkpXG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlIDwgMCA/IGN1cnNvci50byA8IHBvcyA6IGN1cnNvci5mcm9tID4gcG9zKSAmJiAhY3Vyc29yLnR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oY3Vyc29yLnRvIC0gMSwgcG9zIC0gMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKHRyZWUubGVuZ3RoLCBNYXRoLm1heChjdXJzb3IuZnJvbSArIDEsIHBvcyArIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi8pKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gMCA6IHRyZWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMsIG5vZGVTZXQpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5vZGVTZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhZmVGcm9tID0gLTE7XG4gICAgICAgIHRoaXMuc2FmZVRvID0gLTE7XG4gICAgICAgIHRoaXMudHJlZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG4gICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgfVxuICAgIG5leHRGcmFnbWVudCgpIHtcbiAgICAgICAgbGV0IGZyID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuaSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyBudWxsIDogdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdO1xuICAgICAgICBpZiAoZnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZUZyb20gPSBmci5vcGVuU3RhcnQgPyBjdXRBdChmci50cmVlLCBmci5mcm9tICsgZnIub2Zmc2V0LCAxKSAtIGZyLm9mZnNldCA6IGZyLmZyb207XG4gICAgICAgICAgICB0aGlzLnNhZmVUbyA9IGZyLm9wZW5FbmQgPyBjdXRBdChmci50cmVlLCBmci50byArIGZyLm9mZnNldCwgLTEpIC0gZnIub2Zmc2V0IDogZnIudG87XG4gICAgICAgICAgICB3aGlsZSAodGhpcy50cmVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChmci50cmVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucHVzaCgtZnIub2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCgwKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gdGhpcy5zYWZlRnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gMWU5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGBwb3NgIG11c3QgYmUgPj0gYW55IHByZXZpb3VzbHkgZ2l2ZW4gYHBvc2AgZm9yIHRoaXMgY3Vyc29yXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5uZXh0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zYWZlVG8gPD0gcG9zKVxuICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy50cmVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGxhc3QgPCAwKSB7IC8vIEVuZCBvZiB0cmVlXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRyZWVzW2xhc3RdLCBpbmRleCA9IHRoaXMuaW5kZXhbbGFzdF07XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdG9wLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydFtsYXN0XSArIHRvcC5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA8PSB0aGlzLnNhZmVUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IG5leHQucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29rQWhlYWQgfHwgZW5kICsgbG9va0FoZWFkIDwgdGhpcy5mcmFnbWVudC50bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4W2xhc3RdKys7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbmV4dC5sZW5ndGggPj0gTWF0aC5tYXgodGhpcy5zYWZlRnJvbSwgcG9zKSkgeyAvLyBFbnRlciB0aGlzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQgKyBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRva2VuQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IHBhcnNlci50b2tlbml6ZXJzLm1hcChfID0+IG5ldyBDYWNoZWRUb2tlbik7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoc3RhY2spIHtcbiAgICAgICAgbGV0IGFjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1haW4gPSBudWxsO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgdG9rZW5pemVycyB9ID0gcGFyc2VyO1xuICAgICAgICBsZXQgbWFzayA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDMgLyogUGFyc2VTdGF0ZS5Ub2tlbml6ZXJNYXNrICovKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzdGFjay5jdXJDb250ZXh0ID8gc3RhY2suY3VyQ29udGV4dC5oYXNoIDogMDtcbiAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgoMSA8PCBpKSAmIG1hc2spID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdG9rZW5pemVyID0gdG9rZW5pemVyc1tpXSwgdG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmIChtYWluICYmICF0b2tlbml6ZXIuZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmNvbnRleHR1YWwgfHwgdG9rZW4uc3RhcnQgIT0gc3RhY2sucG9zIHx8IHRva2VuLm1hc2sgIT0gbWFzayB8fCB0b2tlbi5jb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNhY2hlZFRva2VuKHRva2VuLCB0b2tlbml6ZXIsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5tYXNrID0gbWFzaztcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi5sb29rQWhlYWQgPiB0b2tlbi5lbmQgKyAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKVxuICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IE1hdGgubWF4KHRva2VuLmxvb2tBaGVhZCwgbG9va0FoZWFkKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSAhPSAwIC8qIFRlcm0uRXJyICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBhY3Rpb25JbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXh0ZW5kZWQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLmV4dGVuZGVkLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25JbmRleCA9IHRoaXMuYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4udmFsdWUsIHRva2VuLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5pemVyLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbmRleCA+IHN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiBhY3Rpb25JbmRleClcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICAgICAgaWYgKGxvb2tBaGVhZClcbiAgICAgICAgICAgIHN0YWNrLnNldExvb2tBaGVhZChsb29rQWhlYWQpO1xuICAgICAgICBpZiAoIW1haW4gJiYgc3RhY2sucG9zID09IHRoaXMuc3RyZWFtLmVuZCkge1xuICAgICAgICAgICAgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbjtcbiAgICAgICAgICAgIG1haW4udmFsdWUgPSBzdGFjay5wLnBhcnNlci5lb2ZUZXJtO1xuICAgICAgICAgICAgbWFpbi5zdGFydCA9IG1haW4uZW5kID0gc3RhY2sucG9zO1xuICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIG1haW4udmFsdWUsIG1haW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBtYWluO1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zO1xuICAgIH1cbiAgICBnZXRNYWluVG9rZW4oc3RhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgICAgICBsZXQgbWFpbiA9IG5ldyBDYWNoZWRUb2tlbiwgeyBwb3MsIHAgfSA9IHN0YWNrO1xuICAgICAgICBtYWluLnN0YXJ0ID0gcG9zO1xuICAgICAgICBtYWluLmVuZCA9IE1hdGgubWluKHBvcyArIDEsIHAuc3RyZWFtLmVuZCk7XG4gICAgICAgIG1haW4udmFsdWUgPSBwb3MgPT0gcC5zdHJlYW0uZW5kID8gcC5wYXJzZXIuZW9mVGVybSA6IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgIHJldHVybiBtYWluO1xuICAgIH1cbiAgICB1cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YWNrLnBvcyk7XG4gICAgICAgIHRva2VuaXplci50b2tlbih0aGlzLnN0cmVhbS5yZXNldChzdGFydCwgdG9rZW4pLCBzdGFjayk7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlci5zcGVjaWFsaXplZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNwZWNpYWxpemVkW2ldID09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZXIuc3BlY2lhbGl6ZXJzW2ldKHRoaXMuc3RyZWFtLnJlYWQodG9rZW4uc3RhcnQsIHRva2VuLmVuZCksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwICYmIHN0YWNrLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKHJlc3VsdCA+PiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgJiAxKSA9PSAwIC8qIFNwZWNpYWxpemUuU3BlY2lhbGl6ZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmV4dGVuZGVkID0gcmVzdWx0ID4+IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gMCAvKiBUZXJtLkVyciAqLztcbiAgICAgICAgICAgIHRva2VuLmVuZCA9IHRoaXMuc3RyZWFtLmNsaXBQb3Moc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXRBY3Rpb24oYWN0aW9uLCB0b2tlbiwgZW5kLCBpbmRleCkge1xuICAgICAgICAvLyBEb24ndCBhZGQgZHVwbGljYXRlIGFjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uc1tpXSA9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuYWN0aW9uc1tpbmRleCsrXSA9IHRva2VuO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSBlbmQ7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkQWN0aW9ucyhzdGFjaywgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHN0YWNrLCB7IHBhcnNlciB9ID0gc3RhY2sucCwgeyBkYXRhIH0gPSBwYXJzZXI7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyc2VyLnN0YXRlU2xvdChzdGF0ZSwgc2V0ID8gMiAvKiBQYXJzZVN0YXRlLlNraXAgKi8gOiAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7OyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gcGFpcihkYXRhLCBpICsgMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMCAmJiBkYXRhW2kgKyAxXSA9PSAyIC8qIFNlcS5PdGhlciAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucHV0QWN0aW9uKHBhaXIoZGF0YSwgaSArIDIpLCB0b2tlbiwgZW5kLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA9PSB0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAxKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMucmVjb3ZlcmluZyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFN0YWNrSUQgPSAweDI2NTQ7IC8vIOKZlCwg4pmVLCDimZYsIOKZlywg4pmYLCDimZksIOKZoCwg4pmhLCDimaIsIOKZoywg4pmkLCDimaUsIOKZpiwg4pmnXG4gICAgICAgIHRoaXMubWluU3RhY2tQb3MgPSAwO1xuICAgICAgICB0aGlzLnJldXNlZCA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEJpZ1JlZHVjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEJpZ1JlZHVjdGlvblNpemUgPSAwO1xuICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBuZXcgSW5wdXRTdHJlYW0oaW5wdXQsIHJhbmdlcyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gbmV3IFRva2VuQ2FjaGUocGFyc2VyLCB0aGlzLnN0cmVhbSk7XG4gICAgICAgIHRoaXMudG9wVGVybSA9IHBhcnNlci50b3BbMV07XG4gICAgICAgIGxldCB7IGZyb20gfSA9IHJhbmdlc1swXTtcbiAgICAgICAgdGhpcy5zdGFja3MgPSBbU3RhY2suc3RhcnQodGhpcywgcGFyc2VyLnRvcFswXSwgZnJvbSldO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGggJiYgdGhpcy5zdHJlYW0uZW5kIC0gZnJvbSA+IHBhcnNlci5idWZmZXJMZW5ndGggKiA0XG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudEN1cnNvcihmcmFnbWVudHMsIHBhcnNlci5ub2RlU2V0KSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblN0YWNrUG9zO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRoZSBwYXJzZXIgZm9yd2FyZC4gVGhpcyB3aWxsIHByb2Nlc3MgYWxsIHBhcnNlIHN0YWNrcyBhdFxuICAgIC8vIGB0aGlzLnBvc2AgYW5kIHRyeSB0byBhZHZhbmNlIHRoZW0gdG8gYSBmdXJ0aGVyIHBvc2l0aW9uLiBJZiBub1xuICAgIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgcGFyc2UgaXMgZmluaXNoZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzeW50YXggdHJlZS4gV2hlblxuICAgIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IHN0YWNrcyA9IHRoaXMuc3RhY2tzLCBwb3MgPSB0aGlzLm1pblN0YWNrUG9zO1xuICAgICAgICAvLyBUaGlzIHdpbGwgaG9sZCBzdGFja3MgYmV5b25kIGBwb3NgLlxuICAgICAgICBsZXQgbmV3U3RhY2tzID0gdGhpcy5zdGFja3MgPSBbXTtcbiAgICAgICAgbGV0IHN0b3BwZWQsIHN0b3BwZWRUb2tlbnM7XG4gICAgICAgIC8vIElmIGEgbGFyZ2UgYW1vdW50IG9mIHJlZHVjdGlvbnMgaGFwcGVuZWQgd2l0aCB0aGUgc2FtZSBzdGFydFxuICAgICAgICAvLyBwb3NpdGlvbiwgZm9yY2UgdGhlIHN0YWNrIG91dCBvZiB0aGF0IHByb2R1Y3Rpb24gaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gYXZvaWQgY3JlYXRpbmcgYSB0cmVlIHRvbyBkZWVwIHRvIHJlY3Vyc2UgdGhyb3VnaC5cbiAgICAgICAgLy8gKFRoaXMgaXMgYW4gdWdseSBrbHVkZ2UsIGJlY2F1c2UgdW5mb3J0dW5hdGVseSB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdHJhaWdodGZvcndhcmQsIGNoZWFwIHdheSB0byBjaGVjayBmb3IgdGhpcyBoYXBwZW5pbmcsIGR1ZSB0b1xuICAgICAgICAvLyB0aGUgaGlzdG9yeSBvZiByZWR1Y3Rpb25zIG9ubHkgYmVpbmcgYXZhaWxhYmxlIGluIGFuXG4gICAgICAgIC8vIGV4cGVuc2l2ZS10by1hY2Nlc3MgZm9ybWF0IGluIHRoZSBzdGFjayBidWZmZXJzLilcbiAgICAgICAgaWYgKHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPiAzMDAgLyogUmVjLk1heExlZnRBc3NvY2lhdGl2ZVJlZHVjdGlvbkNvdW50ICovICYmIHN0YWNrcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbGV0IFtzXSA9IHN0YWNrcztcbiAgICAgICAgICAgIHdoaWxlIChzLmZvcmNlUmVkdWNlKCkgJiYgcy5zdGFjay5sZW5ndGggJiYgcy5zdGFja1tzLnN0YWNrLmxlbmd0aCAtIDJdID49IHRoaXMubGFzdEJpZ1JlZHVjdGlvblN0YXJ0KSB7IH1cbiAgICAgICAgICAgIHRoaXMuYmlnUmVkdWN0aW9uQ291bnQgPSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBLZWVwIGFkdmFuY2luZyBhbnkgc3RhY2tzIGF0IGBwb3NgIHVudGlsIHRoZXkgZWl0aGVyIG1vdmVcbiAgICAgICAgLy8gZm9yd2FyZCBvciBjYW4ndCBiZSBhZHZhbmNlZC4gR2F0aGVyIHN0YWNrcyB0aGF0IGNhbid0IGJlXG4gICAgICAgIC8vIGFkdmFuY2VkIGZ1cnRoZXIgaW4gYHN0b3BwZWRgLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLm1haW5Ub2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLnBvcyA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKHN0YWNrLCBuZXdTdGFja3MsIHN0YWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9rID0gdGhpcy50b2tlbnMuZ2V0TWFpblRva2VuKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZFRva2Vucy5wdXNoKHRvay52YWx1ZSwgdG9rLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbmV3U3RhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gc3RvcHBlZCAmJiBmaW5kRmluaXNoZWQoc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaW5pc2ggd2l0aCBcIiArIHRoaXMuc3RhY2tJRChmaW5pc2hlZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSAmJiBzdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyAodGhpcy50b2tlbnMubWFpblRva2VuID8gdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpIDogXCJub25lXCIpKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJObyBwYXJzZSBhdCBcIiArIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb3ZlcmluZylcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSA1IC8qIFJlYy5EaXN0YW5jZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nICYmIHN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RvcHBlZFswXS5wb3MgPiB0aGlzLnN0b3BwZWRBdCA/IHN0b3BwZWRbMF1cbiAgICAgICAgICAgICAgICA6IHRoaXMucnVuUmVjb3Zlcnkoc3RvcHBlZCwgc3RvcHBlZFRva2VucywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvcmNlLWZpbmlzaCBcIiArIHRoaXMuc3RhY2tJRChmaW5pc2hlZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWNrVG9UcmVlKGZpbmlzaGVkLmZvcmNlQWxsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtYXhSZW1haW5pbmcgPSB0aGlzLnJlY292ZXJpbmcgPT0gMSA/IDEgOiB0aGlzLnJlY292ZXJpbmcgKiAzIC8qIFJlYy5NYXhSZW1haW5pbmdQZXJTdGVwICovO1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiBtYXhSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGFja3Muc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFja3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzLnNvbWUocyA9PiBzLnJlZHVjZVBvcyA+IHBvcykpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFBydW5lIHN0YWNrcyB0aGF0IGFyZSBpbiB0aGUgc2FtZSBzdGF0ZSwgb3IgdGhhdCBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIHJ1bm5pbmcgd2l0aG91dCBzcGxpdHRpbmcgZm9yIGEgd2hpbGUsIHRvIGF2b2lkIGdldHRpbmcgc3R1Y2tcbiAgICAgICAgICAgIC8vIHdpdGggbXVsdGlwbGUgc3VjY2Vzc2Z1bCBzdGFja3MgcnVubmluZyBlbmRsZXNzbHkgb24uXG4gICAgICAgICAgICBvdXRlcjogZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdTdGFja3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gbmV3U3RhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5ld1N0YWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBuZXdTdGFja3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5zYW1lU3RhdGUob3RoZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5idWZmZXIubGVuZ3RoID4gNTAwIC8qIFJlYy5NaW5CdWZmZXJMZW5ndGhQcnVuZSAqLyAmJiBvdGhlci5idWZmZXIubGVuZ3RoID4gNTAwIC8qIFJlYy5NaW5CdWZmZXJMZW5ndGhQcnVuZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoc3RhY2suc2NvcmUgLSBvdGhlci5zY29yZSkgfHwgKHN0YWNrLmJ1ZmZlci5sZW5ndGggLSBvdGhlci5idWZmZXIubGVuZ3RoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLykge1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZSgxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLywgbmV3U3RhY2tzLmxlbmd0aCAtIDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gODQwMCAvKiBSZWMuQ3V0RGVwdGggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5zdGFjay5sZW5ndGggPiA2MDAwIC8qIFJlYy5DdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxldCBtYWluID0gdGhpcy50b2tlbnMubWFpblRva2VuO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIG1haW4gPyBtYWluLnN0YXJ0IDogbG9jYWxTdGFjay5wb3MsIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxMCAvKiBSZWMuRm9yY2VSZWR1Y2VMaW1pdCAqLyAmJiBmb3JjZS5mb3JjZVJlZHVjZSgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmVuZCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBmb3JjZS5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gZm9yY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrKSB7XG4gICAgICAgIHN0YWNrLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBUcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIGxlbmd0aDogc3RhY2sucG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuY29uc3QgaWQgPSB4ID0+IHg7XG4vKipcbkNvbnRleHQgdHJhY2tlcnMgYXJlIHVzZWQgdG8gdHJhY2sgc3RhdGVmdWwgY29udGV4dCAoc3VjaCBhc1xuaW5kZW50YXRpb24gaW4gdGhlIFB5dGhvbiBncmFtbWFyLCBvciBwYXJlbnQgZWxlbWVudHMgaW4gdGhlIFhNTFxuZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuZ3JhbW1hciBmaWxlIGFzIGBAY29udGV4dCBleHBvcnROYW1lIGZyb20gXCJtb2R1bGVcImAuXG5cbkNvbnRleHQgdmFsdWVzIHNob3VsZCBiZSBpbW11dGFibGUsIGFuZCBjYW4gYmUgdXBkYXRlZCAocmVwbGFjZWQpXG5vbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cblxuVGhlIGV4cG9ydCB1c2VkIGluIGEgYEBjb250ZXh0YCBkZWNsYXJhdGlvbiBzaG91bGQgYmUgb2YgdGhpc1xudHlwZS5cbiovXG5jbGFzcyBDb250ZXh0VHJhY2tlciB7XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgY29udGV4dCB0cmFja2VyLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vKipcbkhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkIGJ5XG5gbGV6ZXItZ2VuZXJhdG9yYCwgYW5kIHByb3ZpZGVzIFttZXRob2RzXSgjY29tbW9uLlBhcnNlcikgdG8gcGFyc2VcbmNvbnRlbnQgd2l0aC5cbiovXG5jbGFzcyBMUlBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwcGVycyA9IFtdO1xuICAgICAgICBpZiAoc3BlYy52ZXJzaW9uICE9IDE0IC8qIEZpbGUuVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxNCAvKiBGaWxlLlZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IE5vZGVQcm9wW3Byb3BdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcFNwZWMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHByb3BTcGVjW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AobmV4dCwgcHJvcCwgcHJvcFNwZWNbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wU3BlY1tpICsgLW5leHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC1uZXh0OyBqID4gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AocHJvcFNwZWNbaSsrXSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVTZXQgPSBuZXcgTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGlmIChzcGVjLnByb3BTb3VyY2VzKVxuICAgICAgICAgICAgdGhpcy5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5zcGVjLnByb3BTb3VyY2VzKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gc3BlYy5jb250ZXh0O1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVyU3BlY3MgPSBzcGVjLnNwZWNpYWxpemVkIHx8IFtdO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVkID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZWRbaV0gPSB0aGlzLnNwZWNpYWxpemVyU3BlY3NbaV0udGVybTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKGdldFNwZWNpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlcywgVWludDMyQXJyYXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlRGF0YSk7XG4gICAgICAgIHRoaXMuZ290byA9IGRlY29kZUFycmF5KHNwZWMuZ290byk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB3IG9mIHRoaXMud3JhcHBlcnMpXG4gICAgICAgICAgICBwYXJzZSA9IHcocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogU2VxLk90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIFRlcm0uRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVTbG90KHN0YXRlLCBzbG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1soc3RhdGUgKiA2IC8qIFBhcnNlU3RhdGUuU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZUZsYWcoc3RhdGUsIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBQYXJzZVN0YXRlLkZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYWxsQWN0aW9ucyhzdGF0ZSwgYSA9PiBhID09IGFjdGlvbiA/IHRydWUgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbGxBY3Rpb25zKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlZmx0ID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGRlZmx0ID8gYWN0aW9uKGRlZmx0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7IHJlc3VsdCA9PSBudWxsOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBhY3Rpb24ocGFpcih0aGlzLmRhdGEsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmRhdGFbaSArIDJdICYgKDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIGdpdmVuIHNldHRpbmdzIG1vZGlmaWVkLiBTZXR0aW5ncyBub3QgcHJvdmlkZWQgaW4gYGNvbmZpZ2AgYXJlXG4gICAga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgKi9cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zcGVjaWFsaXplcnMpIHtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJTcGVjcyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoKHMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcuc3BlY2lhbGl6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gcy5leHRlcm5hbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgbGV0IHNwZWMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHMpLCB7IGV4dGVybmFsOiBmb3VuZC50byB9KTtcbiAgICAgICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyc1tpXSA9IGdldFNwZWNpYWxpemVyKHNwZWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgYW55IFtwYXJzZSB3cmFwcGVyc10oI2xyLlBhcnNlckNvbmZpZy53cmFwKVxuICAgIGFyZSByZWdpc3RlcmVkIGZvciB0aGlzIHBhcnNlci5cbiAgICAqL1xuICAgIGhhc1dyYXBwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlcm0uIFRoaXMgd2lsbCBvbmx5XG4gICAgd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIHN0b3JlZC5cbiAgICAqL1xuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICB0eXBlcy4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7IHJldHVybiB0aGlzLm5vZGVTZXQudHlwZXNbdGhpcy50b3BbMV1dOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzspXG4gICAgICAgICAgICAgICAgICAgIChkaXNhYmxlZCB8fCAoZGlzYWJsZWQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heFRlcm0gKyAxKSkpW2lkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGlhbGVjdChkaWFsZWN0LCBmbGFncywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IuIE5vdCBhdmFpbGFibGUgdG9cbiAgICB1c2VyIGNvZGUuIEBoaWRlXG4gICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovKSAmJlxuICAgICAgICAgICAgKCFiZXN0IHx8IGJlc3Quc2NvcmUgPCBzdGFjay5zY29yZSkpXG4gICAgICAgICAgICBiZXN0ID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lhbGl6ZXIoc3BlYykge1xuICAgIGlmIChzcGVjLmV4dGVybmFsKSB7XG4gICAgICAgIGxldCBtYXNrID0gc3BlYy5leHRlbmQgPyAxIC8qIFNwZWNpYWxpemUuRXh0ZW5kICovIDogMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi87XG4gICAgICAgIHJldHVybiAodmFsdWUsIHN0YWNrKSA9PiAoc3BlYy5leHRlcm5hbCh2YWx1ZSwgc3RhY2spIDw8IDEpIHwgbWFzaztcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMuZ2V0O1xufVxuXG5leHBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIElucHV0U3RyZWFtLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwLCBTdGFjayB9O1xuIl0sIm5hbWVzIjpbIlBhcnNlciIsIk5vZGVQcm9wIiwiTm9kZVNldCIsIk5vZGVUeXBlIiwiRGVmYXVsdEJ1ZmZlckxlbmd0aCIsIlRyZWUiLCJJdGVyTW9kZSIsIlN0YWNrIiwiY29uc3RydWN0b3IiLCJwIiwic3RhY2siLCJzdGF0ZSIsInJlZHVjZVBvcyIsInBvcyIsInNjb3JlIiwiYnVmZmVyIiwiYnVmZmVyQmFzZSIsImN1ckNvbnRleHQiLCJsb29rQWhlYWQiLCJwYXJlbnQiLCJ0b1N0cmluZyIsImZpbHRlciIsIl8iLCJpIiwiY29uY2F0Iiwic3RhcnQiLCJjeCIsInBhcnNlciIsImNvbnRleHQiLCJTdGFja0NvbnRleHQiLCJwdXNoU3RhdGUiLCJwdXNoIiwibGVuZ3RoIiwicmVkdWNlIiwiYWN0aW9uIiwiX2EiLCJkZXB0aCIsInR5cGUiLCJsb29rYWhlYWRSZWNvcmQiLCJzZXRMb29rQWhlYWQiLCJkUHJlYyIsImR5bmFtaWNQcmVjZWRlbmNlIiwiZ2V0R290byIsIm1pblJlcGVhdFRlcm0iLCJzdG9yZU5vZGUiLCJyZWR1Y2VDb250ZXh0IiwiYmFzZSIsInJhbmdlcyIsImZyb20iLCJzaXplIiwibm9kZVNldCIsInR5cGVzIiwiaXNBbm9ueW1vdXMiLCJsYXN0QmlnUmVkdWN0aW9uU3RhcnQiLCJiaWdSZWR1Y3Rpb25Db3VudCIsImxhc3RCaWdSZWR1Y3Rpb25TaXplIiwiY291bnQiLCJzdGF0ZUZsYWciLCJiYXNlU3RhdGVJRCIsInBvcCIsInRlcm0iLCJlbmQiLCJtdXN0U2luayIsImN1ciIsInRvcCIsImluZGV4IiwibXVzdE1vdmUiLCJzY2FuIiwic2hpZnQiLCJuZXh0U3RhdGUiLCJtYXhOb2RlIiwiTWF0aCIsIm1pbiIsInNoaWZ0Q29udGV4dCIsImFwcGx5IiwibmV4dCIsIm5leHRTdGFydCIsIm5leHRFbmQiLCJ1c2VOb2RlIiwidmFsdWUiLCJyZXVzZWQiLCJ1cGRhdGVDb250ZXh0IiwidHJhY2tlciIsInJldXNlIiwic3RyZWFtIiwicmVzZXQiLCJzcGxpdCIsIm9mZiIsInNsaWNlIiwicmVjb3ZlckJ5RGVsZXRlIiwiaXNOb2RlIiwiY2FuU2hpZnQiLCJzaW0iLCJTaW11bGF0ZWRTdGFjayIsInN0YXRlU2xvdCIsImhhc0FjdGlvbiIsInJlY292ZXJCeUluc2VydCIsIm5leHRTdGF0ZXMiLCJiZXN0IiwicyIsInNvbWUiLCJ2IiwicmVzdWx0IiwiZm9yY2VSZWR1Y2UiLCJ2YWxpZEFjdGlvbiIsInRhcmdldCIsImJhY2t1cCIsImZpbmRGb3JjZWRSZWR1Y3Rpb24iLCJzZWVuIiwiZXhwbG9yZSIsImluY2x1ZGVzIiwiYWxsQWN0aW9ucyIsInJEZXB0aCIsImZvdW5kIiwiZm9yY2VBbGwiLCJkZWFkRW5kIiwiZGF0YSIsInJlc3RhcnQiLCJzYW1lU3RhdGUiLCJvdGhlciIsImRpYWxlY3RFbmFibGVkIiwiZGlhbGVjdElEIiwiZGlhbGVjdCIsImZsYWdzIiwiZW1pdENvbnRleHQiLCJsYXN0IiwiaGFzaCIsImVtaXRMb29rQWhlYWQiLCJuZXdDeCIsImNsb3NlIiwic3RyaWN0IiwiZ290byIsIlN0YWNrQnVmZmVyQ3Vyc29yIiwibWF5YmVOZXh0IiwiY3JlYXRlIiwiaWQiLCJmb3JrIiwiZGVjb2RlQXJyYXkiLCJpbnB1dCIsIlR5cGUiLCJVaW50MTZBcnJheSIsImFycmF5Iiwib3V0IiwiY2hhckNvZGVBdCIsInN0b3AiLCJkaWdpdCIsIkNhY2hlZFRva2VuIiwiZXh0ZW5kZWQiLCJtYXNrIiwibnVsbFRva2VuIiwiSW5wdXRTdHJlYW0iLCJjaHVuayIsImNodW5rT2ZmIiwiY2h1bmsyIiwiY2h1bmsyUG9zIiwidG9rZW4iLCJyYW5nZUluZGV4IiwiY2h1bmtQb3MiLCJyYW5nZSIsInRvIiwicmVhZE5leHQiLCJyZXNvbHZlT2Zmc2V0Iiwib2Zmc2V0IiwiYXNzb2MiLCJjbGlwUG9zIiwibWF4IiwicGVlayIsImlkeCIsInJlc29sdmVkIiwiYWNjZXB0VG9rZW4iLCJlbmRPZmZzZXQiLCJSYW5nZUVycm9yIiwiYWNjZXB0VG9rZW5UbyIsImVuZFBvcyIsImdldENodW5rIiwibmV4dENodW5rIiwiYWR2YW5jZSIsIm4iLCJzZXREb25lIiwicmVhZCIsInIiLCJUb2tlbkdyb3VwIiwicmVhZFRva2VuIiwidG9rZW5QcmVjVGFibGUiLCJwcm90b3R5cGUiLCJjb250ZXh0dWFsIiwiZmFsbGJhY2siLCJleHRlbmQiLCJMb2NhbFRva2VuR3JvdXAiLCJwcmVjVGFibGUiLCJlbHNlVG9rZW4iLCJza2lwcGVkIiwiYXRFb2YiLCJuZXh0UG9zIiwiRXh0ZXJuYWxUb2tlbml6ZXIiLCJvcHRpb25zIiwiZ3JvdXAiLCJwcmVjT2Zmc2V0IiwiZ3JvdXBNYXNrIiwiYWNjRW5kIiwiYWxsb3dzIiwib3ZlcnJpZGVzIiwibG93IiwiaGlnaCIsIm1pZCIsImZpbmRPZmZzZXQiLCJwcmV2IiwidGFibGVEYXRhIiwidGFibGVPZmZzZXQiLCJpUHJldiIsInZlcmJvc2UiLCJwcm9jZXNzIiwiZW52IiwidGVzdCIsIkxPRyIsInN0YWNrSURzIiwiY3V0QXQiLCJ0cmVlIiwic2lkZSIsImN1cnNvciIsIkluY2x1ZGVBbm9ueW1vdXMiLCJtb3ZlVG8iLCJjaGlsZEJlZm9yZSIsImNoaWxkQWZ0ZXIiLCJpc0Vycm9yIiwicHJldlNpYmxpbmciLCJuZXh0U2libGluZyIsIkZyYWdtZW50Q3Vyc29yIiwiZnJhZ21lbnRzIiwiZnJhZ21lbnQiLCJzYWZlRnJvbSIsInNhZmVUbyIsInRyZWVzIiwibmV4dEZyYWdtZW50IiwiZnIiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwibm9kZUF0IiwiY2hpbGRyZW4iLCJwb3NpdGlvbnMiLCJwcm9wIiwiVG9rZW5DYWNoZSIsInRva2VucyIsIm1haW5Ub2tlbiIsImFjdGlvbnMiLCJ0b2tlbml6ZXJzIiwibWFwIiwiZ2V0QWN0aW9ucyIsImFjdGlvbkluZGV4IiwibWFpbiIsInRva2VuaXplciIsInVwZGF0ZUNhY2hlZFRva2VuIiwic3RhcnRJbmRleCIsImFkZEFjdGlvbnMiLCJlb2ZUZXJtIiwiZ2V0TWFpblRva2VuIiwic3BlY2lhbGl6ZWQiLCJzcGVjaWFsaXplcnMiLCJwdXRBY3Rpb24iLCJzZXQiLCJwYWlyIiwiUGFyc2UiLCJyZWNvdmVyaW5nIiwibmV4dFN0YWNrSUQiLCJtaW5TdGFja1BvcyIsInN0b3BwZWRBdCIsInRvcFRlcm0iLCJzdGFja3MiLCJidWZmZXJMZW5ndGgiLCJwYXJzZWRQb3MiLCJuZXdTdGFja3MiLCJzdG9wcGVkIiwic3RvcHBlZFRva2VucyIsImFkdmFuY2VTdGFjayIsInRvayIsImZpbmlzaGVkIiwiZmluZEZpbmlzaGVkIiwiY29uc29sZSIsImxvZyIsInN0YWNrSUQiLCJzdGFja1RvVHJlZSIsImdldE5hbWUiLCJTeW50YXhFcnJvciIsInJ1blJlY292ZXJ5IiwibWF4UmVtYWluaW5nIiwic29ydCIsImEiLCJiIiwib3V0ZXIiLCJqIiwic3BsaWNlIiwic3RvcEF0Iiwic3RyaWN0Q3giLCJjeEhhc2giLCJjYWNoZWQiLCJtYXRjaCIsImNvbnRleHRIYXNoIiwiaW5uZXIiLCJkZWZhdWx0UmVkdWNlIiwibG9jYWxTdGFjayIsImFkdmFuY2VGdWxseSIsInB1c2hTdGFja0RlZHVwIiwicmVzdGFydGVkIiwidG9rZW5FbmQiLCJkb25lIiwiZm9yY2UiLCJmb3JjZUJhc2UiLCJpbnNlcnQiLCJidWlsZCIsInRvcElEIiwibWF4QnVmZmVyTGVuZ3RoIiwibWluUmVwZWF0VHlwZSIsIldlYWtNYXAiLCJnZXQiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiRGlhbGVjdCIsInNvdXJjZSIsImRpc2FibGVkIiwieCIsIkNvbnRleHRUcmFja2VyIiwic3BlYyIsIkxSUGFyc2VyIiwid3JhcHBlcnMiLCJ2ZXJzaW9uIiwibm9kZU5hbWVzIiwicmVwZWF0Tm9kZUNvdW50IiwidG9wVGVybXMiLCJPYmplY3QiLCJrZXlzIiwidG9wUnVsZXMiLCJub2RlUHJvcHMiLCJzZXRQcm9wIiwibm9kZUlEIiwiZGVzZXJpYWxpemUiLCJwcm9wU3BlYyIsIm5hbWUiLCJkZWZpbmUiLCJ1bmRlZmluZWQiLCJwcm9wcyIsImluZGV4T2YiLCJlcnJvciIsInNraXBwZWROb2RlcyIsInByb3BTb3VyY2VzIiwidG9rZW5BcnJheSIsInRva2VuRGF0YSIsInNwZWNpYWxpemVyU3BlY3MiLCJnZXRTcGVjaWFsaXplciIsInN0YXRlcyIsIlVpbnQzMkFycmF5Iiwic3RhdGVEYXRhIiwibWF4VGVybSIsImRpYWxlY3RzIiwiZHluYW1pY1ByZWNlZGVuY2VzIiwidG9rZW5QcmVjIiwidGVybU5hbWVzIiwicGFyc2VEaWFsZWN0IiwiY3JlYXRlUGFyc2UiLCJwYXJzZSIsInciLCJsb29zZSIsInRhYmxlIiwiZ3JvdXBUYWciLCJ0ZXJtaW5hbCIsInNsb3QiLCJmbGFnIiwiZGVmbHQiLCJjb25maWd1cmUiLCJjb25maWciLCJjb3B5IiwiYXNzaWduIiwiaW5mbyIsInQiLCJmaW5kIiwiZXh0ZXJuYWwiLCJjb250ZXh0VHJhY2tlciIsIndyYXAiLCJoYXNXcmFwcGVycyIsInRvcE5vZGUiLCJwcmVjIiwidmFsdWVzIiwicGFydCIsIlVpbnQ4QXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lezer+lr@1.4.7/node_modules/@lezer/lr/dist/index.js\n");

/***/ })

};
;