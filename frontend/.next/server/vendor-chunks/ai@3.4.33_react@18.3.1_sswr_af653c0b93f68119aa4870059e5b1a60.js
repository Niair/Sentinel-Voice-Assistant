"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60";
exports.ids = ["vendor-chunks/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60/node_modules/ai/dist/index.mjs":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60/node_modules/ai/dist/index.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LlamaIndexAdapter: () => (/* binding */ llamaindex_adapter_exports),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData2),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.jsonSchema),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parseStreamPart),\n/* harmony export */   processDataProtocolResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(ssr)/./node_modules/.pnpm/@ai-sdk+ui-utils@0.0.50_zod@3.25.76/node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(ssr)/./node_modules/.pnpm/@ai-sdk+provider-utils@1.0.22_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_@opentelemetry+_95d5a05ac7ec0d735f17a907e734f3d8/node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventsource-parser */ \"(ssr)/./node_modules/.pnpm/eventsource-parser@1.1.2/node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name11 in all)__defProp(target, name11, {\n        get: all[name11],\n        enumerable: true\n    });\n};\n// streams/index.ts\n\n\n// core/index.ts\n\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name,\n            message\n        });\n        this[_a] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isRetryError(error) {\n        return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            reason: this.reason,\n            lastError: this.lastError,\n            errors: this.errors\n        };\n    }\n};\n_a = symbol;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({ operationId, telemetry }) {\n    return {\n        // standardized operation and resource name:\n        \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n        \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n        // detailed, AI SDK specific data:\n        \"ai.operationId\": operationId,\n        \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n    };\n}\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {\n    var _a11;\n    return {\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // settings:\n        ...Object.entries(settings).reduce((attributes, [key, value])=>{\n            attributes[`ai.settings.${key}`] = value;\n            return attributes;\n        }, {}),\n        // add metadata as attributes:\n        ...Object.entries((_a11 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a11 : {}).reduce((attributes, [key, value])=>{\n            attributes[`ai.telemetry.metadata.${key}`] = value;\n            return attributes;\n        }, {}),\n        // request headers\n        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{\n            if (value !== void 0) {\n                attributes[`ai.request.headers.${key}`] = value;\n            }\n            return attributes;\n        }, {})\n    };\n}\n// core/telemetry/get-tracer.ts\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n    startSpan () {\n        return noopSpan;\n    },\n    startActiveSpan (name11, arg1, arg2, arg3) {\n        if (typeof arg1 === \"function\") {\n            return arg1(noopSpan);\n        }\n        if (typeof arg2 === \"function\") {\n            return arg2(noopSpan);\n        }\n        if (typeof arg3 === \"function\") {\n            return arg3(noopSpan);\n        }\n    }\n};\nvar noopSpan = {\n    spanContext () {\n        return noopSpanContext;\n    },\n    setAttribute () {\n        return this;\n    },\n    setAttributes () {\n        return this;\n    },\n    addEvent () {\n        return this;\n    },\n    addLink () {\n        return this;\n    },\n    addLinks () {\n        return this;\n    },\n    setStatus () {\n        return this;\n    },\n    updateName () {\n        return this;\n    },\n    end () {\n        return this;\n    },\n    isRecording () {\n        return false;\n    },\n    recordException () {\n        return this;\n    }\n};\nvar noopSpanContext = {\n    traceId: \"\",\n    spanId: \"\",\n    traceFlags: 0\n};\n// core/telemetry/get-tracer.ts\nfunction getTracer({ isEnabled = false, tracer } = {}) {\n    if (!isEnabled) {\n        return noopTracer;\n    }\n    if (tracer) {\n        return tracer;\n    }\n    return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.trace.getTracer(\"ai\");\n}\n// core/telemetry/record-span.ts\n\nfunction recordSpan({ name: name11, tracer, attributes, fn, endWhenDone = true }) {\n    return tracer.startActiveSpan(name11, {\n        attributes\n    }, async (span)=>{\n        try {\n            const result = await fn(span);\n            if (endWhenDone) {\n                span.end();\n            }\n            return result;\n        } catch (error) {\n            try {\n                if (error instanceof Error) {\n                    span.recordException({\n                        name: error.name,\n                        message: error.message,\n                        stack: error.stack\n                    });\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR,\n                        message: error.message\n                    });\n                } else {\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR\n                    });\n                }\n            } finally{\n                span.end();\n            }\n            throw error;\n        }\n    });\n}\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({ telemetry, attributes }) {\n    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n        return {};\n    }\n    return Object.entries(attributes).reduce((attributes2, [key, value])=>{\n        if (value === void 0) {\n            return attributes2;\n        }\n        if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n                return attributes2;\n            }\n            const result = value.input();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n                return attributes2;\n            }\n            const result = value.output();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        return {\n            ...attributes2,\n            [key]: value\n        };\n    }, {});\n}\n// core/embed/embed.ts\nasync function embed({ model, value, maxRetries, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embed\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embed\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.value\": {\n                    input: ()=>JSON.stringify(value)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const { embedding, usage, rawResponse } = await retry(()=>// nested spans to align with the embedMany telemetry data:\n                recordSpan({\n                    name: \"ai.embed.doEmbed\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.embed.doEmbed\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.values\": {\n                                input: ()=>[\n                                        JSON.stringify(value)\n                                    ]\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doEmbedSpan)=>{\n                        var _a11;\n                        const modelResponse = await model.doEmbed({\n                            values: [\n                                value\n                            ],\n                            abortSignal,\n                            headers\n                        });\n                        const embedding2 = modelResponse.embeddings[0];\n                        const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                            tokens: NaN\n                        };\n                        doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.embeddings\": {\n                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))\n                                },\n                                \"ai.usage.tokens\": usage2.tokens\n                            }\n                        }));\n                        return {\n                            embedding: embedding2,\n                            usage: usage2,\n                            rawResponse: modelResponse.rawResponse\n                        };\n                    }\n                }));\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embedding\": {\n                        output: ()=>JSON.stringify(embedding)\n                    },\n                    \"ai.usage.tokens\": usage.tokens\n                }\n            }));\n            return new DefaultEmbedResult({\n                value,\n                embedding,\n                usage,\n                rawResponse\n            });\n        }\n    });\n}\nvar DefaultEmbedResult = class {\n    constructor(options){\n        this.value = options.value;\n        this.embedding = options.embedding;\n        this.usage = options.usage;\n        this.rawResponse = options.rawResponse;\n    }\n};\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n    if (chunkSize <= 0) {\n        throw new Error(\"chunkSize must be greater than 0\");\n    }\n    const result = [];\n    for(let i = 0; i < array.length; i += chunkSize){\n        result.push(array.slice(i, i + chunkSize));\n    }\n    return result;\n}\n// core/embed/embed-many.ts\nasync function embedMany({ model, values, maxRetries, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embedMany\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embedMany\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                    input: ()=>values.map((value)=>JSON.stringify(value))\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n            if (maxEmbeddingsPerCall == null) {\n                const { embeddings: embeddings2, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>values.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a11;\n                            const modelResponse = await model.doEmbed({\n                                values,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings3 = modelResponse.embeddings;\n                            const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings3,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                span.setAttributes(selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.embeddings\": {\n                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                    }\n                }));\n                return new DefaultEmbedManyResult({\n                    values,\n                    embeddings: embeddings2,\n                    usage\n                });\n            }\n            const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n            const embeddings = [];\n            let tokens = 0;\n            for (const chunk of valueChunks){\n                const { embeddings: responseEmbeddings, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>chunk.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a11;\n                            const modelResponse = await model.doEmbed({\n                                values: chunk,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings2 = modelResponse.embeddings;\n                            const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings2,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                embeddings.push(...responseEmbeddings);\n                tokens += usage.tokens;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embeddings\": {\n                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": tokens\n                }\n            }));\n            return new DefaultEmbedManyResult({\n                values,\n                embeddings,\n                usage: {\n                    tokens\n                }\n            });\n        }\n    });\n}\nvar DefaultEmbedManyResult = class {\n    constructor(options){\n        this.values = options.values;\n        this.embeddings = options.embeddings;\n        this.usage = options.usage;\n    }\n};\n// core/generate-object/generate-object.ts\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name: name2,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isDownloadError(error) {\n        return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            statusCode: this.statusCode,\n            statusText: this.statusText,\n            cause: this.cause\n        };\n    }\n};\n_a2 = symbol2;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a11;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a11 = response.headers.get(\"content-type\")) != null ? _a11 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a3] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidDataContentError(error) {\n        return error instanceof Error && error.name === name3 && error.content != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            cause: this.cause,\n            content: this.content\n        };\n    }\n};\n_a3 = symbol3;\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    zod__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](Uint8Array),\n    zod__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](ArrayBuffer),\n    zod__WEBPACK_IMPORTED_MODULE_3__.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a11, _b;\n        return (_b = (_a11 = globalThis.Buffer) == null ? void 0 : _a11.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n    try {\n        return new TextDecoder().decode(uint8Array);\n    } catch (error) {\n        throw new Error(\"Error decoding Uint8Array to text\");\n    }\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name4,\n            message\n        });\n        this[_a4] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n_a4 = symbol4;\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mimeType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mimeType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, modelSupportsUrl = ()=>false, downloadImplementation = download }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);\n    return [\n        ...prompt.system != null ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))\n    ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\").map((part)=>{\n                        const { experimental_providerMetadata, ...rest } = part;\n                        return {\n                            ...rest,\n                            providerMetadata: experimental_providerMetadata\n                        };\n                    }),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            content: part.experimental_content,\n                            isError: part.isError,\n                            providerMetadata: part.experimental_providerMetadata\n                        })),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").filter((part)=>!(part.type === \"image\" && modelSupportsImageUrls === true)).map((part)=>part.type === \"image\" ? part.image : part.data).map((part)=>// support string urls:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL).filter((url)=>!modelSupportsUrl(url));\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerMetadata: part.experimental_providerMetadata\n        };\n    }\n    let mimeType = part.mimeType;\n    let data;\n    let content;\n    let normalizedData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            data = part.image;\n            break;\n        case \"file\":\n            data = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    try {\n        content = typeof data === \"string\" ? new URL(data) : data;\n    } catch (error) {\n        content = data;\n    }\n    if (content instanceof URL) {\n        if (content.protocol === \"data:\") {\n            const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());\n            if (dataUrlMimeType == null || base64Content == null) {\n                throw new Error(`Invalid data URL format in part ${type}`);\n            }\n            mimeType = dataUrlMimeType;\n            normalizedData = convertDataContentToUint8Array(base64Content);\n        } else {\n            const downloadedFile = downloadedAssets[content.toString()];\n            if (downloadedFile) {\n                normalizedData = downloadedFile.data;\n                mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n            } else {\n                normalizedData = content;\n            }\n        }\n    } else {\n        normalizedData = convertDataContentToUint8Array(content);\n    }\n    switch(type){\n        case \"image\":\n            if (mimeType == null && normalizedData instanceof Uint8Array) {\n                mimeType = detectImageMimeType(normalizedData);\n            }\n            return {\n                type: \"image\",\n                image: normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n        case \"file\":\n            if (mimeType == null) {\n                throw new Error(`Mime type is missing for file part`);\n            }\n            return {\n                type: \"file\",\n                data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n    }\n}\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name: name5,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a5] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidArgumentError(error) {\n        return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            parameter: this.parameter,\n            value: this.value\n        };\n    }\n};\n_a5 = symbol5;\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/prompt/standardize-prompt.ts\n\n\n\n// core/prompt/message.ts\n\n// core/types/provider-metadata.ts\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_3__.lazy(()=>zod__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__[\"null\"](),\n        zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.number(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.boolean(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.record(zod__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema),\n        zod__WEBPACK_IMPORTED_MODULE_3__.array(jsonValueSchema)\n    ]));\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_3__.record(zod__WEBPACK_IMPORTED_MODULE_3__.string(), zod__WEBPACK_IMPORTED_MODULE_3__.record(zod__WEBPACK_IMPORTED_MODULE_3__.string(), jsonValueSchema));\n// core/prompt/content-part.ts\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.union([\n    zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n        text: zod__WEBPACK_IMPORTED_MODULE_3__.string()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_3__.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n        data: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n        mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional()\n    })\n]));\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"image\"),\n    image: zod__WEBPACK_IMPORTED_MODULE_3__.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.string().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"file\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_3__.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_3__[\"instanceof\"](URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_3__.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_3__.unknown(),\n    content: toolResultContentSchema.optional(),\n    isError: zod__WEBPACK_IMPORTED_MODULE_3__.boolean().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"user\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"assistant\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.array(zod__WEBPACK_IMPORTED_MODULE_3__.union([\n            textPartSchema,\n            toolCallPartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.literal(\"tool\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.array(toolResultPartSchema),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.union([\n    coreSystemMessageSchema,\n    coreUserMessageSchema,\n    coreAssistantMessageSchema,\n    coreToolMessageSchema\n]);\n// core/prompt/detect-prompt-type.ts\nfunction detectPromptType(prompt) {\n    if (!Array.isArray(prompt)) {\n        return \"other\";\n    }\n    if (prompt.length === 0) {\n        return \"messages\";\n    }\n    const characteristics = prompt.map(detectSingleMessageCharacteristics);\n    if (characteristics.some((c)=>c === \"has-ui-specific-parts\")) {\n        return \"ui-messages\";\n    } else if (characteristics.every((c)=>c === \"has-core-specific-parts\" || c === \"message\")) {\n        return \"messages\";\n    } else {\n        return \"other\";\n    }\n}\nfunction detectSingleMessageCharacteristics(message) {\n    if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n    message.role === \"data\" || // UI-only role\n    \"toolInvocations\" in message || // UI-specific field\n    \"experimental_attachments\" in message)) {\n        return \"has-ui-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n    \"experimental_providerMetadata\" in message)) {\n        return \"has-core-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\n        \"system\",\n        \"user\",\n        \"assistant\",\n        \"tool\"\n    ].includes(message.role)) {\n        return \"message\";\n    } else {\n        return \"other\";\n    }\n}\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n    var _a11, _b, _c;\n    const parts = [];\n    for (const attachment of attachments){\n        let url;\n        try {\n            url = new URL(attachment.url);\n        } catch (error) {\n            throw new Error(`Invalid URL: ${attachment.url}`);\n        }\n        switch(url.protocol){\n            case \"http:\":\n            case \"https:\":\n                {\n                    if ((_a11 = attachment.contentType) == null ? void 0 : _a11.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: url\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: url,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            case \"data:\":\n                {\n                    let header;\n                    let base64Content;\n                    let mimeType;\n                    try {\n                        [header, base64Content] = attachment.url.split(\",\");\n                        mimeType = header.split(\";\")[0].split(\":\")[1];\n                    } catch (error) {\n                        throw new Error(`Error processing data URL: ${attachment.url}`);\n                    }\n                    if (mimeType == null || base64Content == null) {\n                        throw new Error(`Invalid data URL format: ${attachment.url}`);\n                    }\n                    if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content)\n                        });\n                    } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n                        parts.push({\n                            type: \"text\",\n                            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: base64Content,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                }\n        }\n    }\n    return parts;\n}\n// core/prompt/message-conversion-error.ts\n\nvar name6 = \"AI_MessageConversionError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name6,\n            message\n        });\n        this[_a6] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n    var _a11;\n    const tools = (_a11 = options == null ? void 0 : options.tools) != null ? _a11 : {};\n    const coreMessages = [];\n    for (const message of messages){\n        const { role, content, toolInvocations, experimental_attachments } = message;\n        switch(role){\n            case \"system\":\n                {\n                    coreMessages.push({\n                        role: \"system\",\n                        content\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    coreMessages.push({\n                        role: \"user\",\n                        content: experimental_attachments ? [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...attachmentsToParts(experimental_attachments)\n                        ] : content\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (toolInvocations == null) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                        break;\n                    }\n                    coreMessages.push({\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...toolInvocations.map(({ toolCallId, toolName, args })=>({\n                                    type: \"tool-call\",\n                                    toolCallId,\n                                    toolName,\n                                    args\n                                }))\n                        ]\n                    });\n                    coreMessages.push({\n                        role: \"tool\",\n                        content: toolInvocations.map((toolInvocation)=>{\n                            if (!(\"result\" in toolInvocation)) {\n                                throw new MessageConversionError({\n                                    originalMessage: message,\n                                    message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                });\n                            }\n                            const { toolCallId, toolName, result } = toolInvocation;\n                            const tool2 = tools[toolName];\n                            return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result: tool2.experimental_toToolResultContent(result),\n                                experimental_content: tool2.experimental_toToolResultContent(result)\n                            } : {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result\n                            };\n                        })\n                    });\n                    break;\n                }\n            case \"function\":\n            case \"data\":\n            case \"tool\":\n                {\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return coreMessages;\n}\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({ prompt, tools }) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string\"\n        });\n    }\n    if (prompt.prompt != null) {\n        if (typeof prompt.prompt !== \"string\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"prompt must be a string\"\n            });\n        }\n        return {\n            type: \"prompt\",\n            system: prompt.system,\n            messages: [\n                {\n                    role: \"user\",\n                    content: prompt.prompt\n                }\n            ]\n        };\n    }\n    if (prompt.messages != null) {\n        const promptType = detectPromptType(prompt.messages);\n        if (promptType === \"other\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\"\n            });\n        }\n        const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n            tools\n        }) : prompt.messages;\n        const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n            value: messages,\n            schema: zod__WEBPACK_IMPORTED_MODULE_3__.array(coreMessageSchema)\n        });\n        if (!validationResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\",\n                cause: validationResult.error\n            });\n        }\n        return {\n            type: \"messages\",\n            messages,\n            system: prompt.system\n        };\n    }\n    throw new Error(\"unreachable\");\n}\n// core/types/usage.ts\nfunction calculateLanguageModelUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, { contentType, dataStreamVersion }) {\n    var _a11;\n    const headers = new Headers((_a11 = init == null ? void 0 : init.headers) != null ? _a11 : {});\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", contentType);\n    }\n    if (dataStreamVersion !== void 0) {\n        headers.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n    }\n    return headers;\n}\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({ prompt, schema, schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0, schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX }) {\n    return [\n        prompt != null && prompt.length > 0 ? prompt : void 0,\n        prompt != null && prompt.length > 0 ? \"\" : void 0,\n        // add a newline if prompt is not null\n        schemaPrefix,\n        schema != null ? JSON.stringify(schema) : void 0,\n        schemaSuffix\n    ].filter((line)=>line != null).join(\"\\n\");\n}\n// core/generate-object/no-object-generated-error.ts\n\nvar name7 = \"AI_NoObjectGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    // used in isInstance\n    constructor({ message = \"No object generated.\" } = {}){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isNoObjectGeneratedError(error) {\n        return error instanceof Error && error.name === name7;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            cause: this.cause,\n            message: this.message,\n            stack: this.stack\n        };\n    }\n};\n_a7 = symbol7;\n// core/generate-object/output-strategy.ts\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n    const transformedStream = source.pipeThrough(new TransformStream(transformer));\n    transformedStream[Symbol.asyncIterator] = ()=>{\n        const reader = transformedStream.getReader();\n        return {\n            async next () {\n                const { done, value } = await reader.read();\n                return done ? {\n                    done: true,\n                    value: void 0\n                } : {\n                    done: false,\n                    value\n                };\n            }\n        };\n    };\n    return transformedStream;\n}\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n    type: \"no-schema\",\n    jsonSchema: void 0,\n    validatePartialResult ({ value, textDelta }) {\n        return {\n            success: true,\n            value: {\n                partial: value,\n                textDelta\n            }\n        };\n    },\n    validateFinalResult (value) {\n        return value === void 0 ? {\n            success: false,\n            error: new NoObjectGeneratedError()\n        } : {\n            success: true,\n            value\n        };\n    },\n    createElementStream () {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n            functionality: \"element streams in no-schema mode\"\n        });\n    }\n};\nvar objectOutputStrategy = (schema)=>({\n        type: \"object\",\n        jsonSchema: schema.jsonSchema,\n        validatePartialResult ({ value, textDelta }) {\n            return {\n                success: true,\n                value: {\n                    // Note: currently no validation of partial results:\n                    partial: value,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                value,\n                schema\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in object mode\"\n            });\n        }\n    });\nvar arrayOutputStrategy = (schema)=>{\n    const { $schema, ...itemSchema } = schema.jsonSchema;\n    return {\n        type: \"enum\",\n        // wrap in object that contains array of elements, since most LLMs will not\n        // be able to generate an array directly:\n        // possible future optimization: use arrays directly when model supports grammar-guided generation\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                elements: {\n                    type: \"array\",\n                    items: itemSchema\n                }\n            },\n            required: [\n                \"elements\"\n            ],\n            additionalProperties: false\n        },\n        validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {\n            var _a11;\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            const resultArray = [];\n            for(let i = 0; i < inputArray.length; i++){\n                const element = inputArray[i];\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (i === inputArray.length - 1 && !isFinalDelta) {\n                    continue;\n                }\n                if (!result.success) {\n                    return result;\n                }\n                resultArray.push(result.value);\n            }\n            const publishedElementCount = (_a11 = latestObject == null ? void 0 : latestObject.length) != null ? _a11 : 0;\n            let textDelta = \"\";\n            if (isFirstDelta) {\n                textDelta += \"[\";\n            }\n            if (publishedElementCount > 0) {\n                textDelta += \",\";\n            }\n            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(\",\");\n            if (isFinalDelta) {\n                textDelta += \"]\";\n            }\n            return {\n                success: true,\n                value: {\n                    partial: resultArray,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            for (const element of inputArray){\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (!result.success) {\n                    return result;\n                }\n            }\n            return {\n                success: true,\n                value: inputArray\n            };\n        },\n        createElementStream (originalStream) {\n            let publishedElements = 0;\n            return createAsyncIterableStream(originalStream, {\n                transform (chunk, controller) {\n                    switch(chunk.type){\n                        case \"object\":\n                            {\n                                const array = chunk.object;\n                                for(; publishedElements < array.length; publishedElements++){\n                                    controller.enqueue(array[publishedElements]);\n                                }\n                                break;\n                            }\n                        case \"text-delta\":\n                        case \"finish\":\n                            break;\n                        case \"error\":\n                            controller.error(chunk.error);\n                            break;\n                        default:\n                            {\n                                const _exhaustiveCheck = chunk;\n                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                            }\n                    }\n                }\n            });\n        }\n    };\n};\nvar enumOutputStrategy = (enumValues)=>{\n    return {\n        type: \"enum\",\n        // wrap in object that contains result, since most LLMs will not\n        // be able to generate an enum value directly:\n        // possible future optimization: use enums directly when model supports top-level enums\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"string\",\n                    enum: enumValues\n                }\n            },\n            required: [\n                \"result\"\n            ],\n            additionalProperties: false\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            return enumValues.includes(result) ? {\n                success: true,\n                value: result\n            } : {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                    value,\n                    cause: \"value must be a string in the enum\"\n                })\n            };\n        },\n        validatePartialResult () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"partial results in enum mode\"\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in enum mode\"\n            });\n        }\n    };\n};\nfunction getOutputStrategy({ output, schema, enumValues }) {\n    switch(output){\n        case \"object\":\n            return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(schema));\n        case \"array\":\n            return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(schema));\n        case \"enum\":\n            return enumOutputStrategy(enumValues);\n        case \"no-schema\":\n            return noSchemaOutputStrategy;\n        default:\n            {\n                const _exhaustiveCheck = output;\n                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n            }\n    }\n}\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({ output, mode, schema, schemaName, schemaDescription, enumValues }) {\n    if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n        throw new InvalidArgumentError({\n            parameter: \"output\",\n            value: output,\n            message: \"Invalid output type.\"\n        });\n    }\n    if (output === \"no-schema\") {\n        if (mode === \"auto\" || mode === \"tool\") {\n            throw new InvalidArgumentError({\n                parameter: \"mode\",\n                value: mode,\n                message: 'Mode must be \"json\" for no-schema output.'\n            });\n        }\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for no-schema output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for no-schema output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for no-schema output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for no-schema output.\"\n            });\n        }\n    }\n    if (output === \"object\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is required for object output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for object output.\"\n            });\n        }\n    }\n    if (output === \"array\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Element schema is required for array output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for array output.\"\n            });\n        }\n    }\n    if (output === \"enum\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for enum output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for enum output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for enum output.\"\n            });\n        }\n        if (enumValues == null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are required for enum output.\"\n            });\n        }\n        for (const value of enumValues){\n            if (typeof value !== \"string\") {\n                throw new InvalidArgumentError({\n                    parameter: \"enumValues\",\n                    value,\n                    message: \"Enum values must be strings.\"\n                });\n            }\n        }\n    }\n}\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function generateObject({ model, enum: enumValues, // rename bc enum is reserved by typescript\nschema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, _internal: { generateId: generateId3 = originalGenerateId, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a11, _b;\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let result;\n            let finishReason;\n            let usage;\n            let warnings;\n            let rawResponse;\n            let response;\n            let request;\n            let logprobs;\n            let resultProviderMetadata;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>standardizedPrompt.type\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a12, _b2, _c, _d, _e, _f;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-json\",\n                                            schema: outputStrategy.jsonSchema,\n                                            name: schemaName,\n                                            description: schemaDescription\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat: standardizedPrompt.type,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    if (result2.text === void 0) {\n                                        throw new NoObjectGeneratedError();\n                                    }\n                                    const responseData = {\n                                        id: (_b2 = (_a12 = result2.response) == null ? void 0 : _a12.id) != null ? _b2 : generateId3(),\n                                        timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                                        modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                                    };\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // deprecated:\n                                            \"ai.finishReason\": result2.finishReason,\n                                            \"ai.result.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText: result2.text,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_a11 = generateResult.request) != null ? _a11 : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const inputFormat = standardizedPrompt.type;\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>inputFormat\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a12, _b2, _c, _d, _e, _f, _g, _h;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-tool\",\n                                            tool: {\n                                                type: \"function\",\n                                                name: schemaName != null ? schemaName : \"json\",\n                                                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                                parameters: outputStrategy.jsonSchema\n                                            }\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    const objectText = (_b2 = (_a12 = result2.toolCalls) == null ? void 0 : _a12[0]) == null ? void 0 : _b2.args;\n                                    if (objectText === void 0) {\n                                        throw new NoObjectGeneratedError();\n                                    }\n                                    const responseData = {\n                                        id: (_d = (_c = result2.response) == null ? void 0 : _c.id) != null ? _d : generateId3(),\n                                        timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                                        modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                                    };\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // deprecated:\n                                            \"ai.finishReason\": result2.finishReason,\n                                            \"ai.result.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_b = generateResult.request) != null ? _b : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n                text: result\n            });\n            if (!parseResult.success) {\n                throw parseResult.error;\n            }\n            const validationResult = outputStrategy.validateFinalResult(parseResult.value);\n            if (!validationResult.success) {\n                throw validationResult.error;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": finishReason,\n                    \"ai.response.object\": {\n                        output: ()=>JSON.stringify(validationResult.value)\n                    },\n                    \"ai.usage.promptTokens\": usage.promptTokens,\n                    \"ai.usage.completionTokens\": usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": finishReason,\n                    \"ai.result.object\": {\n                        output: ()=>JSON.stringify(validationResult.value)\n                    }\n                }\n            }));\n            return new DefaultGenerateObjectResult({\n                object: validationResult.value,\n                finishReason,\n                usage: calculateLanguageModelUsage(usage),\n                warnings,\n                request,\n                response: {\n                    ...response,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                },\n                logprobs,\n                providerMetadata: resultProviderMetadata\n            });\n        }\n    });\n}\nvar DefaultGenerateObjectResult = class {\n    constructor(options){\n        this.object = options.object;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.response = options.response;\n        this.request = options.request;\n        this.rawResponse = {\n            headers: options.response.headers\n        };\n        this.logprobs = options.logprobs;\n    }\n    toJsonResponse(init) {\n        var _a11;\n        return new Response(JSON.stringify(this.object), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"application/json; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_generateObject = generateObject;\n// core/generate-object/stream-object.ts\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n    constructor(){\n        this.status = {\n            type: \"pending\"\n        };\n        this._resolve = void 0;\n        this._reject = void 0;\n    }\n    get value() {\n        if (this.promise) {\n            return this.promise;\n        }\n        this.promise = new Promise((resolve, reject)=>{\n            if (this.status.type === \"resolved\") {\n                resolve(this.status.value);\n            } else if (this.status.type === \"rejected\") {\n                reject(this.status.error);\n            }\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        return this.promise;\n    }\n    resolve(value) {\n        var _a11;\n        this.status = {\n            type: \"resolved\",\n            value\n        };\n        if (this.promise) {\n            (_a11 = this._resolve) == null ? void 0 : _a11.call(this, value);\n        }\n    }\n    reject(error) {\n        var _a11;\n        this.status = {\n            type: \"rejected\",\n            error\n        };\n        if (this.promise) {\n            (_a11 = this._reject) == null ? void 0 : _a11.call(this, error);\n        }\n    }\n};\n// core/util/now.ts\nfunction now() {\n    var _a11, _b;\n    return (_b = (_a11 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a11.now()) != null ? _b : Date.now();\n}\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(init, { contentType, dataStreamVersion }) {\n    const headers = {};\n    if ((init == null ? void 0 : init.headers) != null) {\n        for (const [key, value] of Object.entries(init.headers)){\n            headers[key] = value;\n        }\n    }\n    if (headers[\"Content-Type\"] == null) {\n        headers[\"Content-Type\"] = contentType;\n    }\n    if (dataStreamVersion !== void 0) {\n        headers[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n    }\n    return headers;\n}\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({ response, status, statusText, headers, stream }) {\n    response.writeHead(status != null ? status : 200, statusText, headers);\n    const reader = stream.getReader();\n    const read = async ()=>{\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                response.write(value);\n            }\n        } catch (error) {\n            throw error;\n        } finally{\n            response.end();\n        }\n    };\n    read();\n}\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function streamObject({ model, schema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, onFinish, _internal: { generateId: generateId3 = originalGenerateId2, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    return recordSpan({\n        name: \"ai.streamObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.streamObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        endWhenDone: false,\n        fn: async (rootSpan)=>{\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let callOptions;\n            let transformer;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        callOptions = {\n                            mode: {\n                                type: \"object-json\",\n                                schema: outputStrategy.jsonSchema,\n                                name: schemaName,\n                                description: schemaDescription\n                            },\n                            ...prepareCallSettings(settings),\n                            inputFormat: standardizedPrompt.type,\n                            prompt: await convertToLanguageModelPrompt({\n                                prompt: standardizedPrompt,\n                                modelSupportsImageUrls: model.supportsImageUrls,\n                                modelSupportsUrl: model.supportsUrl\n                            }),\n                            providerMetadata,\n                            abortSignal,\n                            headers\n                        };\n                        transformer = {\n                            transform: (chunk, controller)=>{\n                                switch(chunk.type){\n                                    case \"text-delta\":\n                                        controller.enqueue(chunk.textDelta);\n                                        break;\n                                    case \"response-metadata\":\n                                    case \"finish\":\n                                    case \"error\":\n                                        controller.enqueue(chunk);\n                                        break;\n                                }\n                            }\n                        };\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        callOptions = {\n                            mode: {\n                                type: \"object-tool\",\n                                tool: {\n                                    type: \"function\",\n                                    name: schemaName != null ? schemaName : \"json\",\n                                    description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                    parameters: outputStrategy.jsonSchema\n                                }\n                            },\n                            ...prepareCallSettings(settings),\n                            inputFormat: standardizedPrompt.type,\n                            prompt: await convertToLanguageModelPrompt({\n                                prompt: standardizedPrompt,\n                                modelSupportsImageUrls: model.supportsImageUrls,\n                                modelSupportsUrl: model.supportsUrl\n                            }),\n                            providerMetadata,\n                            abortSignal,\n                            headers\n                        };\n                        transformer = {\n                            transform (chunk, controller) {\n                                switch(chunk.type){\n                                    case \"tool-call-delta\":\n                                        controller.enqueue(chunk.argsTextDelta);\n                                        break;\n                                    case \"response-metadata\":\n                                    case \"finish\":\n                                    case \"error\":\n                                        controller.enqueue(chunk);\n                                        break;\n                                }\n                            }\n                        };\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                    name: \"ai.streamObject.doStream\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.streamObject.doStream\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            \"ai.prompt.format\": {\n                                input: ()=>callOptions.inputFormat\n                            },\n                            \"ai.prompt.messages\": {\n                                input: ()=>JSON.stringify(callOptions.prompt)\n                            },\n                            \"ai.settings.mode\": mode,\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.system\": model.provider,\n                            \"gen_ai.request.model\": model.modelId,\n                            \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                            \"gen_ai.request.max_tokens\": settings.maxTokens,\n                            \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                            \"gen_ai.request.temperature\": settings.temperature,\n                            \"gen_ai.request.top_k\": settings.topK,\n                            \"gen_ai.request.top_p\": settings.topP\n                        }\n                    }),\n                    tracer,\n                    endWhenDone: false,\n                    fn: async (doStreamSpan2)=>({\n                            startTimestampMs: now2(),\n                            doStreamSpan: doStreamSpan2,\n                            result: await model.doStream(callOptions)\n                        })\n                }));\n            return new DefaultStreamObjectResult({\n                outputStrategy,\n                stream: stream.pipeThrough(new TransformStream(transformer)),\n                warnings,\n                rawResponse,\n                request: request != null ? request : {},\n                onFinish,\n                rootSpan,\n                doStreamSpan,\n                telemetry,\n                startTimestampMs,\n                modelId: model.modelId,\n                now: now2,\n                currentDate,\n                generateId: generateId3\n            });\n        }\n    });\n}\nvar DefaultStreamObjectResult = class {\n    constructor({ stream, warnings, rawResponse, request, outputStrategy, onFinish, rootSpan, doStreamSpan, telemetry, startTimestampMs, modelId, now: now2, currentDate, generateId: generateId3 }){\n        this.warnings = warnings;\n        this.rawResponse = rawResponse;\n        this.outputStrategy = outputStrategy;\n        this.request = Promise.resolve(request);\n        this.objectPromise = new DelayedPromise();\n        const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n        this.usage = usagePromise;\n        const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n        this.response = responsePromise;\n        const { resolve: resolveProviderMetadata, promise: providerMetadataPromise } = createResolvablePromise();\n        this.experimental_providerMetadata = providerMetadataPromise;\n        let usage;\n        let finishReason;\n        let providerMetadata;\n        let object;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let response = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const self = this;\n        this.originalStream = stream.pipeThrough(new TransformStream({\n            async transform (chunk, controller) {\n                var _a11, _b, _c;\n                if (isFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    isFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                        \"ai.stream.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                        \"ai.stream.msToFirstChunk\": msToFirstChunk\n                    });\n                }\n                if (typeof chunk === \"string\") {\n                    accumulatedText += chunk;\n                    textDelta += chunk;\n                    const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parsePartialJson)(accumulatedText);\n                    if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n                        const validationResult = outputStrategy.validatePartialResult({\n                            value: currentObjectJson,\n                            textDelta,\n                            latestObject,\n                            isFirstDelta,\n                            isFinalDelta: parseState === \"successful-parse\"\n                        });\n                        if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.isDeepEqualData)(latestObject, validationResult.value.partial)) {\n                            latestObjectJson = currentObjectJson;\n                            latestObject = validationResult.value.partial;\n                            controller.enqueue({\n                                type: \"object\",\n                                object: latestObject\n                            });\n                            controller.enqueue({\n                                type: \"text-delta\",\n                                textDelta: validationResult.value.textDelta\n                            });\n                            textDelta = \"\";\n                            isFirstDelta = false;\n                        }\n                    }\n                    return;\n                }\n                switch(chunk.type){\n                    case \"response-metadata\":\n                        {\n                            response = {\n                                id: (_a11 = chunk.id) != null ? _a11 : response.id,\n                                timestamp: (_b = chunk.timestamp) != null ? _b : response.timestamp,\n                                modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n                            };\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (textDelta !== \"\") {\n                                controller.enqueue({\n                                    type: \"text-delta\",\n                                    textDelta\n                                });\n                            }\n                            finishReason = chunk.finishReason;\n                            usage = calculateLanguageModelUsage(chunk.usage);\n                            providerMetadata = chunk.providerMetadata;\n                            controller.enqueue({\n                                ...chunk,\n                                usage,\n                                response\n                            });\n                            resolveUsage(usage);\n                            resolveProviderMetadata(providerMetadata);\n                            resolveResponse({\n                                ...response,\n                                headers: rawResponse == null ? void 0 : rawResponse.headers\n                            });\n                            const validationResult = outputStrategy.validateFinalResult(latestObjectJson);\n                            if (validationResult.success) {\n                                object = validationResult.value;\n                                self.objectPromise.resolve(object);\n                            } else {\n                                error = validationResult.error;\n                                self.objectPromise.reject(error);\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            controller.enqueue(chunk);\n                            break;\n                        }\n                }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush (controller) {\n                try {\n                    const finalUsage = usage != null ? usage : {\n                        promptTokens: NaN,\n                        completionTokens: NaN,\n                        totalTokens: NaN\n                    };\n                    doStreamSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.response.finishReason\": finishReason,\n                            \"ai.response.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            \"ai.response.id\": response.id,\n                            \"ai.response.model\": response.modelId,\n                            \"ai.response.timestamp\": response.timestamp.toISOString(),\n                            \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                            \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                            // deprecated\n                            \"ai.finishReason\": finishReason,\n                            \"ai.result.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.response.finish_reasons\": [\n                                finishReason\n                            ],\n                            \"gen_ai.response.id\": response.id,\n                            \"gen_ai.response.model\": response.modelId,\n                            \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                            \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                        }\n                    }));\n                    doStreamSpan.end();\n                    rootSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                            \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                            \"ai.response.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            // deprecated\n                            \"ai.result.object\": {\n                                output: ()=>JSON.stringify(object)\n                            }\n                        }\n                    }));\n                    await (onFinish == null ? void 0 : onFinish({\n                        usage: finalUsage,\n                        object,\n                        error,\n                        rawResponse,\n                        response: {\n                            ...response,\n                            headers: rawResponse == null ? void 0 : rawResponse.headers\n                        },\n                        warnings,\n                        experimental_providerMetadata: providerMetadata\n                    }));\n                } catch (error2) {\n                    controller.error(error2);\n                } finally{\n                    rootSpan.end();\n                }\n            }\n        }));\n    }\n    get object() {\n        return this.objectPromise.value;\n    }\n    get partialObjectStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"object\":\n                        controller.enqueue(chunk.object);\n                        break;\n                    case \"text-delta\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n    }\n    get elementStream() {\n        return this.outputStrategy.createElementStream(this.originalStream);\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"text-delta\":\n                        controller.enqueue(chunk.textDelta);\n                        break;\n                    case \"object\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a11;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_streamObject = streamObject;\n// core/generate-text/generate-text.ts\n\n// errors/index.ts\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name8 = \"AI_InvalidToolArgumentsError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}` }){\n        super({\n            name: name8,\n            message,\n            cause\n        });\n        this[_a8] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidToolArgumentsError(error) {\n        return error instanceof Error && error.name === name8 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            toolName: this.toolName,\n            toolArgs: this.toolArgs\n        };\n    }\n};\n_a8 = symbol8;\n// errors/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name9,\n            message\n        });\n        this[_a9] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchToolError(error) {\n        return error instanceof Error && error.name === name9 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            toolName: this.toolName,\n            availableTools: this.availableTools\n        };\n    }\n};\n_a9 = symbol9;\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name11])=>activeTools.includes(name11)) : Object.entries(tools);\n    return {\n        tools: filteredTools.map(([name11, tool2])=>{\n            const toolType = tool2.type;\n            switch(toolType){\n                case void 0:\n                case \"function\":\n                    return {\n                        type: \"function\",\n                        name: name11,\n                        description: tool2.description,\n                        parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(tool2.parameters).jsonSchema\n                    };\n                case \"provider-defined\":\n                    return {\n                        type: \"provider-defined\",\n                        name: name11,\n                        id: tool2.id,\n                        args: tool2.args\n                    };\n                default:\n                    {\n                        const exhaustiveCheck = toolType;\n                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                    }\n            }\n        }),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/util/split-on-last-whitespace.ts\nvar lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\nfunction splitOnLastWhitespace(text) {\n    const match = text.match(lastWhitespaceRegexp);\n    return match ? {\n        prefix: match[1],\n        whitespace: match[2],\n        suffix: match[3]\n    } : void 0;\n}\n// core/util/remove-text-after-last-whitespace.ts\nfunction removeTextAfterLastWhitespace(text) {\n    const match = splitOnLastWhitespace(text);\n    return match ? match.prefix + match.whitespace : text;\n}\n// core/generate-text/parse-tool-call.ts\n\n\nfunction parseToolCall({ toolCall, tools }) {\n    const toolName = toolCall.toolName;\n    if (tools == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName\n        });\n    }\n    const tool2 = tools[toolName];\n    if (tool2 == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName,\n            availableTools: Object.keys(tools)\n        });\n    }\n    const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(tool2.parameters);\n    const parseResult = toolCall.args.trim() === \"\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n        value: {},\n        schema\n    }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n        text: toolCall.args,\n        schema\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolArgumentsError({\n            toolName,\n            toolArgs: toolCall.args,\n            cause: parseResult.error\n        });\n    }\n    return {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        args: parseResult.value\n    };\n}\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({ text = \"\", tools, toolCalls, toolResults }) {\n    const responseMessages = [];\n    responseMessages.push({\n        role: \"assistant\",\n        content: [\n            {\n                type: \"text\",\n                text\n            },\n            ...toolCalls\n        ]\n    });\n    if (toolResults.length > 0) {\n        responseMessages.push({\n            role: \"tool\",\n            content: toolResults.map((toolResult)=>{\n                const tool2 = tools[toolResult.toolName];\n                return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: tool2.experimental_toToolResultContent(toolResult.result),\n                    experimental_content: tool2.experimental_toToolResultContent(toolResult.result)\n                } : {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: toolResult.result\n                };\n            })\n        });\n    }\n    return responseMessages;\n}\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function generateText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxAutomaticRoundtrips = 0, maxToolRoundtrips = maxAutomaticRoundtrips, maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1, experimental_continuationSteps, experimental_continueSteps: continueSteps = experimental_continuationSteps != null ? experimental_continuationSteps : false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_activeTools: activeTools, _internal: { generateId: generateId3 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, onStepFinish, ...settings }) {\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a11, _b, _c, _d, _e, _f;\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const mode = {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice,\n                    activeTools\n                })\n            };\n            const callSettings = prepareCallSettings(settings);\n            let currentModelResponse;\n            let currentToolCalls = [];\n            let currentToolResults = [];\n            let stepCount = 0;\n            const responseMessages = [];\n            let text = \"\";\n            const steps = [];\n            const usage = {\n                completionTokens: 0,\n                promptTokens: 0,\n                totalTokens: 0\n            };\n            let stepType = \"initial\";\n            do {\n                if (stepCount === 1) {\n                    initialPrompt.type = \"messages\";\n                }\n                const promptFormat = stepCount === 0 ? initialPrompt.type : \"messages\";\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: [\n                            ...initialPrompt.messages,\n                            ...responseMessages\n                        ]\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: model.supportsUrl\n                });\n                currentModelResponse = await retry(()=>recordSpan({\n                        name: \"ai.generateText.doGenerate\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.generateText.doGenerate\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a12;\n                                        return (_a12 = mode.tools) == null ? void 0 : _a12.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        fn: async (span2)=>{\n                            var _a12, _b2, _c2, _d2, _e2, _f2;\n                            const result = await model.doGenerate({\n                                mode,\n                                ...callSettings,\n                                inputFormat: promptFormat,\n                                prompt: promptMessages,\n                                providerMetadata,\n                                abortSignal,\n                                headers\n                            });\n                            const responseData = {\n                                id: (_b2 = (_a12 = result.response) == null ? void 0 : _a12.id) != null ? _b2 : generateId3(),\n                                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : model.modelId\n                            };\n                            span2.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": result.finishReason,\n                                    \"ai.response.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.response.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    \"ai.response.id\": responseData.id,\n                                    \"ai.response.model\": responseData.modelId,\n                                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                                    // deprecated:\n                                    \"ai.finishReason\": result.finishReason,\n                                    \"ai.result.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.result.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        result.finishReason\n                                    ],\n                                    \"gen_ai.response.id\": responseData.id,\n                                    \"gen_ai.response.model\": responseData.modelId,\n                                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                                }\n                            }));\n                            return {\n                                ...result,\n                                response: responseData\n                            };\n                        }\n                    }));\n                currentToolCalls = ((_a11 = currentModelResponse.toolCalls) != null ? _a11 : []).map((modelToolCall)=>parseToolCall({\n                        toolCall: modelToolCall,\n                        tools\n                    }));\n                currentToolResults = tools == null ? [] : await executeTools({\n                    toolCalls: currentToolCalls,\n                    tools,\n                    tracer,\n                    telemetry,\n                    abortSignal\n                });\n                const currentUsage = calculateLanguageModelUsage(currentModelResponse.usage);\n                usage.completionTokens += currentUsage.completionTokens;\n                usage.promptTokens += currentUsage.promptTokens;\n                usage.totalTokens += currentUsage.totalTokens;\n                let nextStepType = \"done\";\n                if (++stepCount < maxSteps) {\n                    if (continueSteps && currentModelResponse.finishReason === \"length\" && // only use continue when there are no tool calls:\n                    currentToolCalls.length === 0) {\n                        nextStepType = \"continue\";\n                    } else if (// there are tool calls:\n                    currentToolCalls.length > 0 && // all current tool calls have results:\n                    currentToolResults.length === currentToolCalls.length) {\n                        nextStepType = \"tool-result\";\n                    }\n                }\n                const originalText = (_b = currentModelResponse.text) != null ? _b : \"\";\n                const stepTextLeadingWhitespaceTrimmed = stepType === \"continue\" && // only for continue steps\n                text.trimEnd() !== text ? originalText.trimStart() : originalText;\n                const stepText = nextStepType === \"continue\" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;\n                text = nextStepType === \"continue\" || stepType === \"continue\" ? text + stepText : stepText;\n                if (stepType === \"continue\") {\n                    const lastMessage = responseMessages[responseMessages.length - 1];\n                    if (typeof lastMessage.content === \"string\") {\n                        lastMessage.content += stepText;\n                    } else {\n                        lastMessage.content.push({\n                            text: stepText,\n                            type: \"text\"\n                        });\n                    }\n                } else {\n                    responseMessages.push(...toResponseMessages({\n                        text,\n                        tools: tools != null ? tools : {},\n                        toolCalls: currentToolCalls,\n                        toolResults: currentToolResults\n                    }));\n                }\n                const currentStepResult = {\n                    stepType,\n                    text: stepText,\n                    toolCalls: currentToolCalls,\n                    toolResults: currentToolResults,\n                    finishReason: currentModelResponse.finishReason,\n                    usage: currentUsage,\n                    warnings: currentModelResponse.warnings,\n                    logprobs: currentModelResponse.logprobs,\n                    request: (_c = currentModelResponse.request) != null ? _c : {},\n                    response: {\n                        ...currentModelResponse.response,\n                        headers: (_d = currentModelResponse.rawResponse) == null ? void 0 : _d.headers,\n                        // deep clone msgs to avoid mutating past messages in multi-step:\n                        messages: JSON.parse(JSON.stringify(responseMessages))\n                    },\n                    experimental_providerMetadata: currentModelResponse.providerMetadata,\n                    isContinued: nextStepType === \"continue\"\n                };\n                steps.push(currentStepResult);\n                await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                stepType = nextStepType;\n            }while (stepType !== \"done\");\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": currentModelResponse.finishReason,\n                    \"ai.response.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.response.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    },\n                    \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n                    \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": currentModelResponse.finishReason,\n                    \"ai.result.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.result.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    }\n                }\n            }));\n            return new DefaultGenerateTextResult({\n                text,\n                toolCalls: currentToolCalls,\n                toolResults: currentToolResults,\n                finishReason: currentModelResponse.finishReason,\n                usage,\n                warnings: currentModelResponse.warnings,\n                request: (_e = currentModelResponse.request) != null ? _e : {},\n                response: {\n                    ...currentModelResponse.response,\n                    headers: (_f = currentModelResponse.rawResponse) == null ? void 0 : _f.headers,\n                    messages: responseMessages\n                },\n                logprobs: currentModelResponse.logprobs,\n                responseMessages,\n                steps,\n                providerMetadata: currentModelResponse.providerMetadata\n            });\n        }\n    });\n}\nasync function executeTools({ toolCalls, tools, tracer, telemetry, abortSignal }) {\n    const toolResults = await Promise.all(toolCalls.map(async (toolCall)=>{\n        const tool2 = tools[toolCall.toolName];\n        if ((tool2 == null ? void 0 : tool2.execute) == null) {\n            return void 0;\n        }\n        const result = await recordSpan({\n            name: \"ai.toolCall\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.toolCall\",\n                        telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                        output: ()=>JSON.stringify(toolCall.args)\n                    }\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                const result2 = await tool2.execute(toolCall.args, {\n                    abortSignal\n                });\n                try {\n                    span.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.toolCall.result\": {\n                                output: ()=>JSON.stringify(result2)\n                            }\n                        }\n                    }));\n                } catch (ignored) {}\n                return result2;\n            }\n        });\n        return {\n            toolCallId: toolCall.toolCallId,\n            toolName: toolCall.toolName,\n            args: toolCall.args,\n            result\n        };\n    }));\n    return toolResults.filter((result)=>result != null);\n}\nvar DefaultGenerateTextResult = class {\n    constructor(options){\n        this.text = options.text;\n        this.toolCalls = options.toolCalls;\n        this.toolResults = options.toolResults;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.request = options.request;\n        this.response = options.response;\n        this.responseMessages = options.responseMessages;\n        this.roundtrips = options.steps;\n        this.steps = options.steps;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.rawResponse = {\n            headers: options.response.headers\n        };\n        this.logprobs = options.logprobs;\n    }\n};\nvar experimental_generateText = generateText;\n// core/generate-text/stream-text.ts\n\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n    let innerStreamReaders = [];\n    let controller = null;\n    let isClosed = false;\n    const processPull = async ()=>{\n        if (isClosed && innerStreamReaders.length === 0) {\n            controller == null ? void 0 : controller.close();\n            return;\n        }\n        if (innerStreamReaders.length === 0) {\n            return;\n        }\n        try {\n            const { value, done } = await innerStreamReaders[0].read();\n            if (done) {\n                innerStreamReaders.shift();\n                if (innerStreamReaders.length > 0) {\n                    await processPull();\n                } else if (isClosed) {\n                    controller == null ? void 0 : controller.close();\n                }\n            } else {\n                controller == null ? void 0 : controller.enqueue(value);\n            }\n        } catch (error) {\n            controller == null ? void 0 : controller.error(error);\n            innerStreamReaders.shift();\n            if (isClosed && innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n    return {\n        stream: new ReadableStream({\n            start (controllerParam) {\n                controller = controllerParam;\n            },\n            pull: processPull,\n            async cancel () {\n                for (const reader of innerStreamReaders){\n                    await reader.cancel();\n                }\n                innerStreamReaders = [];\n                isClosed = true;\n            }\n        }),\n        addStream: (innerStream)=>{\n            if (isClosed) {\n                throw new Error(\"Cannot add inner stream: outer stream is closed\");\n            }\n            innerStreamReaders.push(innerStream.getReader());\n        },\n        close: ()=>{\n            isClosed = true;\n            if (innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n}\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n    const reader1 = stream1.getReader();\n    const reader2 = stream2.getReader();\n    let lastRead1 = void 0;\n    let lastRead2 = void 0;\n    let stream1Done = false;\n    let stream2Done = false;\n    async function readStream1(controller) {\n        try {\n            if (lastRead1 == null) {\n                lastRead1 = reader1.read();\n            }\n            const result = await lastRead1;\n            lastRead1 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    async function readStream2(controller) {\n        try {\n            if (lastRead2 == null) {\n                lastRead2 = reader2.read();\n            }\n            const result = await lastRead2;\n            lastRead2 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    return new ReadableStream({\n        async pull (controller) {\n            try {\n                if (stream1Done) {\n                    await readStream2(controller);\n                    return;\n                }\n                if (stream2Done) {\n                    await readStream1(controller);\n                    return;\n                }\n                if (lastRead1 == null) {\n                    lastRead1 = reader1.read();\n                }\n                if (lastRead2 == null) {\n                    lastRead2 = reader2.read();\n                }\n                const { result, reader } = await Promise.race([\n                    lastRead1.then((result2)=>({\n                            result: result2,\n                            reader: reader1\n                        })),\n                    lastRead2.then((result2)=>({\n                            result: result2,\n                            reader: reader2\n                        }))\n                ]);\n                if (!result.done) {\n                    controller.enqueue(result.value);\n                }\n                if (reader === reader1) {\n                    lastRead1 = void 0;\n                    if (result.done) {\n                        await readStream2(controller);\n                        stream1Done = true;\n                    }\n                } else {\n                    lastRead2 = void 0;\n                    if (result.done) {\n                        stream2Done = true;\n                        await readStream1(controller);\n                    }\n                }\n            } catch (error) {\n                controller.error(error);\n            }\n        },\n        cancel () {\n            reader1.cancel();\n            reader2.cancel();\n        }\n    });\n}\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({ tools, generatorStream, toolCallStreaming, tracer, telemetry, abortSignal }) {\n    let toolResultsStreamController = null;\n    const toolResultsStream = new ReadableStream({\n        start (controller) {\n            toolResultsStreamController = controller;\n        }\n    });\n    const activeToolCalls = {};\n    const outstandingToolResults = /* @__PURE__ */ new Set();\n    let canClose = false;\n    let finishChunk = void 0;\n    function attemptClose() {\n        if (canClose && outstandingToolResults.size === 0) {\n            if (finishChunk != null) {\n                toolResultsStreamController.enqueue(finishChunk);\n            }\n            toolResultsStreamController.close();\n        }\n    }\n    const forwardStream = new TransformStream({\n        transform (chunk, controller) {\n            const chunkType = chunk.type;\n            switch(chunkType){\n                case \"text-delta\":\n                case \"response-metadata\":\n                case \"error\":\n                    {\n                        controller.enqueue(chunk);\n                        break;\n                    }\n                case \"tool-call-delta\":\n                    {\n                        if (toolCallStreaming) {\n                            if (!activeToolCalls[chunk.toolCallId]) {\n                                controller.enqueue({\n                                    type: \"tool-call-streaming-start\",\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName\n                                });\n                                activeToolCalls[chunk.toolCallId] = true;\n                            }\n                            controller.enqueue({\n                                type: \"tool-call-delta\",\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                argsTextDelta: chunk.argsTextDelta\n                            });\n                        }\n                        break;\n                    }\n                case \"tool-call\":\n                    {\n                        const toolName = chunk.toolName;\n                        if (tools == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new NoSuchToolError({\n                                    toolName: chunk.toolName\n                                })\n                            });\n                            break;\n                        }\n                        const tool2 = tools[toolName];\n                        if (tool2 == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new NoSuchToolError({\n                                    toolName: chunk.toolName,\n                                    availableTools: Object.keys(tools)\n                                })\n                            });\n                            break;\n                        }\n                        try {\n                            const toolCall = parseToolCall({\n                                toolCall: chunk,\n                                tools\n                            });\n                            controller.enqueue(toolCall);\n                            if (tool2.execute != null) {\n                                const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId)();\n                                outstandingToolResults.add(toolExecutionId);\n                                recordSpan({\n                                    name: \"ai.toolCall\",\n                                    attributes: selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            ...assembleOperationName({\n                                                operationId: \"ai.toolCall\",\n                                                telemetry\n                                            }),\n                                            \"ai.toolCall.name\": toolCall.toolName,\n                                            \"ai.toolCall.id\": toolCall.toolCallId,\n                                            \"ai.toolCall.args\": {\n                                                output: ()=>JSON.stringify(toolCall.args)\n                                            }\n                                        }\n                                    }),\n                                    tracer,\n                                    fn: async (span)=>tool2.execute(toolCall.args, {\n                                            abortSignal\n                                        }).then((result)=>{\n                                            toolResultsStreamController.enqueue({\n                                                ...toolCall,\n                                                type: \"tool-result\",\n                                                result\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                            try {\n                                                span.setAttributes(selectTelemetryAttributes({\n                                                    telemetry,\n                                                    attributes: {\n                                                        \"ai.toolCall.result\": {\n                                                            output: ()=>JSON.stringify(result)\n                                                        }\n                                                    }\n                                                }));\n                                            } catch (ignored) {}\n                                        }, (error)=>{\n                                            toolResultsStreamController.enqueue({\n                                                type: \"error\",\n                                                error\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                        })\n                                });\n                            }\n                        } catch (error) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error\n                            });\n                        }\n                        break;\n                    }\n                case \"finish\":\n                    {\n                        finishChunk = {\n                            type: \"finish\",\n                            finishReason: chunk.finishReason,\n                            logprobs: chunk.logprobs,\n                            usage: calculateLanguageModelUsage(chunk.usage),\n                            experimental_providerMetadata: chunk.providerMetadata\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = chunkType;\n                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        flush () {\n            canClose = true;\n            attemptClose();\n        }\n    });\n    return new ReadableStream({\n        async start (controller) {\n            return Promise.all([\n                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {}\n                })),\n                toolResultsStream.pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    }\n                }))\n            ]);\n        }\n    });\n}\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxToolRoundtrips = 0, maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1, experimental_continueSteps: continueSteps = false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_toolCallStreaming: toolCallStreaming = false, experimental_activeTools: activeTools, onChunk, onFinish, onStepFinish, _internal: { now: now2 = now, generateId: generateId3 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    return recordSpan({\n        name: \"ai.streamText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.streamText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        endWhenDone: false,\n        fn: async (rootSpan)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const startStep = async ({ responseMessages })=>{\n                const promptFormat = responseMessages.length === 0 ? initialPrompt.type : \"messages\";\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: [\n                            ...initialPrompt.messages,\n                            ...responseMessages\n                        ]\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: model.supportsUrl\n                });\n                const mode = {\n                    type: \"regular\",\n                    ...prepareToolsAndToolChoice({\n                        tools,\n                        toolChoice,\n                        activeTools\n                    })\n                };\n                const { result: { stream: stream2, warnings: warnings2, rawResponse: rawResponse2, request: request2 }, doStreamSpan: doStreamSpan2, startTimestampMs: startTimestampMs2 } = await retry(()=>recordSpan({\n                        name: \"ai.streamText.doStream\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.streamText.doStream\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a11;\n                                        return (_a11 = mode.tools) == null ? void 0 : _a11.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        endWhenDone: false,\n                        fn: async (doStreamSpan3)=>({\n                                startTimestampMs: now2(),\n                                // get before the call\n                                doStreamSpan: doStreamSpan3,\n                                result: await model.doStream({\n                                    mode,\n                                    ...prepareCallSettings(settings),\n                                    inputFormat: promptFormat,\n                                    prompt: promptMessages,\n                                    providerMetadata,\n                                    abortSignal,\n                                    headers\n                                })\n                            })\n                    }));\n                return {\n                    result: {\n                        stream: runToolsTransformation({\n                            tools,\n                            generatorStream: stream2,\n                            toolCallStreaming,\n                            tracer,\n                            telemetry,\n                            abortSignal\n                        }),\n                        warnings: warnings2,\n                        request: request2 != null ? request2 : {},\n                        rawResponse: rawResponse2\n                    },\n                    doStreamSpan: doStreamSpan2,\n                    startTimestampMs: startTimestampMs2\n                };\n            };\n            const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await startStep({\n                responseMessages: []\n            });\n            return new DefaultStreamTextResult({\n                stream,\n                warnings,\n                rawResponse,\n                request,\n                onChunk,\n                onFinish,\n                onStepFinish,\n                rootSpan,\n                doStreamSpan,\n                telemetry,\n                startTimestampMs,\n                maxSteps,\n                continueSteps,\n                startStep,\n                modelId: model.modelId,\n                now: now2,\n                currentDate,\n                generateId: generateId3,\n                tools\n            });\n        }\n    });\n}\nvar DefaultStreamTextResult = class {\n    constructor({ stream, warnings, rawResponse, request, onChunk, onFinish, onStepFinish, rootSpan, doStreamSpan, telemetry, startTimestampMs, maxSteps, continueSteps, startStep, modelId, now: now2, currentDate, generateId: generateId3, tools }){\n        this.warnings = warnings;\n        this.rawResponse = rawResponse;\n        const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n        this.usage = usagePromise;\n        const { resolve: resolveFinishReason, promise: finishReasonPromise } = createResolvablePromise();\n        this.finishReason = finishReasonPromise;\n        const { resolve: resolveText, promise: textPromise } = createResolvablePromise();\n        this.text = textPromise;\n        const { resolve: resolveToolCalls, promise: toolCallsPromise } = createResolvablePromise();\n        this.toolCalls = toolCallsPromise;\n        const { resolve: resolveToolResults, promise: toolResultsPromise } = createResolvablePromise();\n        this.toolResults = toolResultsPromise;\n        const { resolve: resolveSteps, promise: stepsPromise } = createResolvablePromise();\n        this.steps = stepsPromise;\n        const { resolve: resolveProviderMetadata, promise: providerMetadataPromise } = createResolvablePromise();\n        this.experimental_providerMetadata = providerMetadataPromise;\n        const { resolve: resolveRequest, promise: requestPromise } = createResolvablePromise();\n        this.request = requestPromise;\n        const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n        this.response = responsePromise;\n        const { resolve: resolveResponseMessages, promise: responseMessagesPromise } = createResolvablePromise();\n        this.responseMessages = responseMessagesPromise;\n        const { stream: stitchableStream, addStream, close: closeStitchableStream } = createStitchableStream();\n        this.originalStream = stitchableStream;\n        const stepResults = [];\n        const self = this;\n        function addStepStream({ stream: stream2, startTimestamp, doStreamSpan: doStreamSpan2, currentStep, responseMessages, usage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0\n        }, stepType, previousStepText = \"\", stepRequest, hasLeadingWhitespace }) {\n            const stepToolCalls = [];\n            const stepToolResults = [];\n            let stepFinishReason = \"unknown\";\n            let stepUsage = {\n                promptTokens: 0,\n                completionTokens: 0,\n                totalTokens: 0\n            };\n            let stepProviderMetadata;\n            let stepFirstChunk = true;\n            let stepText = \"\";\n            let fullStepText = stepType === \"continue\" ? previousStepText : \"\";\n            let stepLogProbs;\n            let stepResponse = {\n                id: generateId3(),\n                timestamp: currentDate(),\n                modelId\n            };\n            let chunkBuffer = \"\";\n            let chunkTextPublished = false;\n            let inWhitespacePrefix = true;\n            let hasWhitespaceSuffix = false;\n            async function publishTextChunk({ controller, chunk }) {\n                controller.enqueue(chunk);\n                stepText += chunk.textDelta;\n                fullStepText += chunk.textDelta;\n                chunkTextPublished = true;\n                hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n                await (onChunk == null ? void 0 : onChunk({\n                    chunk\n                }));\n            }\n            addStream(stream2.pipeThrough(new TransformStream({\n                async transform (chunk, controller) {\n                    var _a11, _b, _c;\n                    if (stepFirstChunk) {\n                        const msToFirstChunk = now2() - startTimestamp;\n                        stepFirstChunk = false;\n                        doStreamSpan2.addEvent(\"ai.stream.firstChunk\", {\n                            \"ai.response.msToFirstChunk\": msToFirstChunk,\n                            // deprecated:\n                            \"ai.stream.msToFirstChunk\": msToFirstChunk\n                        });\n                        doStreamSpan2.setAttributes({\n                            \"ai.response.msToFirstChunk\": msToFirstChunk,\n                            // deprecated:\n                            \"ai.stream.msToFirstChunk\": msToFirstChunk\n                        });\n                    }\n                    if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                        return;\n                    }\n                    const chunkType = chunk.type;\n                    switch(chunkType){\n                        case \"text-delta\":\n                            {\n                                if (continueSteps) {\n                                    const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;\n                                    if (trimmedChunkText.length === 0) {\n                                        break;\n                                    }\n                                    inWhitespacePrefix = false;\n                                    chunkBuffer += trimmedChunkText;\n                                    const split = splitOnLastWhitespace(chunkBuffer);\n                                    if (split != null) {\n                                        chunkBuffer = split.suffix;\n                                        await publishTextChunk({\n                                            controller,\n                                            chunk: {\n                                                type: \"text-delta\",\n                                                textDelta: split.prefix + split.whitespace\n                                            }\n                                        });\n                                    }\n                                } else {\n                                    await publishTextChunk({\n                                        controller,\n                                        chunk\n                                    });\n                                }\n                                break;\n                            }\n                        case \"tool-call\":\n                            {\n                                controller.enqueue(chunk);\n                                stepToolCalls.push(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"tool-result\":\n                            {\n                                controller.enqueue(chunk);\n                                stepToolResults.push(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"response-metadata\":\n                            {\n                                stepResponse = {\n                                    id: (_a11 = chunk.id) != null ? _a11 : stepResponse.id,\n                                    timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                                    modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                                };\n                                break;\n                            }\n                        case \"finish\":\n                            {\n                                stepUsage = chunk.usage;\n                                stepFinishReason = chunk.finishReason;\n                                stepProviderMetadata = chunk.experimental_providerMetadata;\n                                stepLogProbs = chunk.logprobs;\n                                const msToFinish = now2() - startTimestamp;\n                                doStreamSpan2.addEvent(\"ai.stream.finish\");\n                                doStreamSpan2.setAttributes({\n                                    \"ai.response.msToFinish\": msToFinish,\n                                    \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                                });\n                                break;\n                            }\n                        case \"tool-call-streaming-start\":\n                        case \"tool-call-delta\":\n                            {\n                                controller.enqueue(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"error\":\n                            {\n                                controller.enqueue(chunk);\n                                stepFinishReason = \"error\";\n                                break;\n                            }\n                        default:\n                            {\n                                const exhaustiveCheck = chunkType;\n                                throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                            }\n                    }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush (controller) {\n                    var _a11;\n                    const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                    let nextStepType = \"done\";\n                    if (currentStep + 1 < maxSteps) {\n                        if (continueSteps && stepFinishReason === \"length\" && // only use continue when there are no tool calls:\n                        stepToolCalls.length === 0) {\n                            nextStepType = \"continue\";\n                        } else if (// there are tool calls:\n                        stepToolCalls.length > 0 && // all current tool calls have results:\n                        stepToolResults.length === stepToolCalls.length) {\n                            nextStepType = \"tool-result\";\n                        }\n                    }\n                    if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== \"continue\" || // when the next step is a regular step, publish the buffer\n                    stepType === \"continue\" && !chunkTextPublished)) {\n                        await publishTextChunk({\n                            controller,\n                            chunk: {\n                                type: \"text-delta\",\n                                textDelta: chunkBuffer\n                            }\n                        });\n                        chunkBuffer = \"\";\n                    }\n                    try {\n                        doStreamSpan2.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.response.finishReason\": stepFinishReason,\n                                \"ai.response.text\": {\n                                    output: ()=>stepText\n                                },\n                                \"ai.response.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                \"ai.response.id\": stepResponse.id,\n                                \"ai.response.model\": stepResponse.modelId,\n                                \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                                \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                                \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                                // deprecated\n                                \"ai.finishReason\": stepFinishReason,\n                                \"ai.result.text\": {\n                                    output: ()=>stepText\n                                },\n                                \"ai.result.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.response.finish_reasons\": [\n                                    stepFinishReason\n                                ],\n                                \"gen_ai.response.id\": stepResponse.id,\n                                \"gen_ai.response.model\": stepResponse.modelId,\n                                \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                                \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                            }\n                        }));\n                    } catch (error) {} finally{\n                        doStreamSpan2.end();\n                    }\n                    controller.enqueue({\n                        type: \"step-finish\",\n                        finishReason: stepFinishReason,\n                        usage: stepUsage,\n                        experimental_providerMetadata: stepProviderMetadata,\n                        logprobs: stepLogProbs,\n                        response: {\n                            ...stepResponse\n                        },\n                        isContinued: nextStepType === \"continue\"\n                    });\n                    if (stepType === \"continue\") {\n                        const lastMessage = responseMessages[responseMessages.length - 1];\n                        if (typeof lastMessage.content === \"string\") {\n                            lastMessage.content += stepText;\n                        } else {\n                            lastMessage.content.push({\n                                text: stepText,\n                                type: \"text\"\n                            });\n                        }\n                    } else {\n                        responseMessages.push(...toResponseMessages({\n                            text: stepText,\n                            tools: tools != null ? tools : {},\n                            toolCalls: stepToolCalls,\n                            toolResults: stepToolResults\n                        }));\n                    }\n                    const currentStepResult = {\n                        stepType,\n                        text: stepText,\n                        toolCalls: stepToolCalls,\n                        toolResults: stepToolResults,\n                        finishReason: stepFinishReason,\n                        usage: stepUsage,\n                        warnings: self.warnings,\n                        logprobs: stepLogProbs,\n                        request: stepRequest,\n                        rawResponse: self.rawResponse,\n                        response: {\n                            ...stepResponse,\n                            headers: (_a11 = self.rawResponse) == null ? void 0 : _a11.headers,\n                            // deep clone msgs to avoid mutating past messages in multi-step:\n                            messages: JSON.parse(JSON.stringify(responseMessages))\n                        },\n                        experimental_providerMetadata: stepProviderMetadata,\n                        isContinued: nextStepType === \"continue\"\n                    };\n                    stepResults.push(currentStepResult);\n                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    const combinedUsage = {\n                        promptTokens: usage.promptTokens + stepUsage.promptTokens,\n                        completionTokens: usage.completionTokens + stepUsage.completionTokens,\n                        totalTokens: usage.totalTokens + stepUsage.totalTokens\n                    };\n                    if (nextStepType !== \"done\") {\n                        const { result, doStreamSpan: doStreamSpan3, startTimestampMs: startTimestamp2 } = await startStep({\n                            responseMessages\n                        });\n                        self.warnings = result.warnings;\n                        self.rawResponse = result.rawResponse;\n                        addStepStream({\n                            stream: result.stream,\n                            startTimestamp: startTimestamp2,\n                            doStreamSpan: doStreamSpan3,\n                            currentStep: currentStep + 1,\n                            responseMessages,\n                            usage: combinedUsage,\n                            stepType: nextStepType,\n                            previousStepText: fullStepText,\n                            stepRequest: result.request,\n                            hasLeadingWhitespace: hasWhitespaceSuffix\n                        });\n                        return;\n                    }\n                    try {\n                        controller.enqueue({\n                            type: \"finish\",\n                            finishReason: stepFinishReason,\n                            usage: combinedUsage,\n                            experimental_providerMetadata: stepProviderMetadata,\n                            logprobs: stepLogProbs,\n                            response: {\n                                ...stepResponse\n                            }\n                        });\n                        closeStitchableStream();\n                        rootSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.response.finishReason\": stepFinishReason,\n                                \"ai.response.text\": {\n                                    output: ()=>fullStepText\n                                },\n                                \"ai.response.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                \"ai.usage.promptTokens\": combinedUsage.promptTokens,\n                                \"ai.usage.completionTokens\": combinedUsage.completionTokens,\n                                // deprecated\n                                \"ai.finishReason\": stepFinishReason,\n                                \"ai.result.text\": {\n                                    output: ()=>fullStepText\n                                },\n                                \"ai.result.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                }\n                            }\n                        }));\n                        resolveUsage(combinedUsage);\n                        resolveFinishReason(stepFinishReason);\n                        resolveText(fullStepText);\n                        resolveToolCalls(stepToolCalls);\n                        resolveProviderMetadata(stepProviderMetadata);\n                        resolveToolResults(stepToolResults);\n                        resolveRequest(stepRequest);\n                        resolveResponse({\n                            ...stepResponse,\n                            headers: rawResponse == null ? void 0 : rawResponse.headers,\n                            messages: responseMessages\n                        });\n                        resolveSteps(stepResults);\n                        resolveResponseMessages(responseMessages);\n                        await (onFinish == null ? void 0 : onFinish({\n                            finishReason: stepFinishReason,\n                            logprobs: stepLogProbs,\n                            usage: combinedUsage,\n                            text: fullStepText,\n                            toolCalls: stepToolCalls,\n                            // The tool results are inferred as a never[] type, because they are\n                            // optional and the execute method with an inferred result type is\n                            // optional as well. Therefore we need to cast the toolResults to any.\n                            // The type exposed to the users will be correctly inferred.\n                            toolResults: stepToolResults,\n                            request: stepRequest,\n                            rawResponse,\n                            response: {\n                                ...stepResponse,\n                                headers: rawResponse == null ? void 0 : rawResponse.headers,\n                                messages: responseMessages\n                            },\n                            warnings,\n                            experimental_providerMetadata: stepProviderMetadata,\n                            steps: stepResults,\n                            responseMessages\n                        }));\n                    } catch (error) {\n                        controller.error(error);\n                    } finally{\n                        rootSpan.end();\n                    }\n                }\n            })));\n        }\n        addStepStream({\n            stream,\n            startTimestamp: startTimestampMs,\n            doStreamSpan,\n            currentStep: 0,\n            responseMessages: [],\n            usage: void 0,\n            stepType: \"initial\",\n            stepRequest: request,\n            hasLeadingWhitespace: false\n        });\n    }\n    /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */ teeStream() {\n        const [stream1, stream2] = this.originalStream.tee();\n        this.originalStream = stream2;\n        return stream1;\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.teeStream(), {\n            transform (chunk, controller) {\n                if (chunk.type === \"text-delta\") {\n                    controller.enqueue(chunk.textDelta);\n                } else if (chunk.type === \"error\") {\n                    controller.error(chunk.error);\n                }\n            }\n        });\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.teeStream(), {\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    toAIStream(callbacks = {}) {\n        return this.toDataStreamInternal({\n            callbacks\n        });\n    }\n    toDataStreamInternal({ callbacks = {}, getErrorMessage: getErrorMessage3 = ()=>\"\", // mask error messages for safety by default\n    sendUsage = true } = {}) {\n        let aggregatedResponse = \"\";\n        const callbackTransformer = new TransformStream({\n            async start () {\n                if (callbacks.onStart) await callbacks.onStart();\n            },\n            async transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"text-delta\") {\n                    const textDelta = chunk.textDelta;\n                    aggregatedResponse += textDelta;\n                    if (callbacks.onToken) await callbacks.onToken(textDelta);\n                    if (callbacks.onText) await callbacks.onText(textDelta);\n                }\n            },\n            async flush () {\n                if (callbacks.onCompletion) await callbacks.onCompletion(aggregatedResponse);\n                if (callbacks.onFinal) await callbacks.onFinal(aggregatedResponse);\n            }\n        });\n        const streamPartsTransformer = new TransformStream({\n            transform: async (chunk, controller)=>{\n                const chunkType = chunk.type;\n                switch(chunkType){\n                    case \"text-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", chunk.textDelta));\n                            break;\n                        }\n                    case \"tool-call-streaming-start\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_streaming_start\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName\n                            }));\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_delta\", {\n                                toolCallId: chunk.toolCallId,\n                                argsTextDelta: chunk.argsTextDelta\n                            }));\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                args: chunk.args\n                            }));\n                            break;\n                        }\n                    case \"tool-result\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_result\", {\n                                toolCallId: chunk.toolCallId,\n                                result: chunk.result\n                            }));\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", getErrorMessage3(chunk.error)));\n                            break;\n                        }\n                    case \"step-finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"finish_step\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0,\n                                isContinued: chunk.isContinued\n                            }));\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"finish_message\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0\n                            }));\n                            break;\n                        }\n                    default:\n                        {\n                            const exhaustiveCheck = chunkType;\n                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n        return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer).pipeThrough(new TextEncoderStream());\n    }\n    pipeAIStreamToResponse(response, init) {\n        return this.pipeDataStreamToResponse(response, init);\n    }\n    pipeDataStreamToResponse(response, options) {\n        const init = options == null ? void 0 : \"init\" in options ? options.init : {\n            headers: \"headers\" in options ? options.headers : void 0,\n            status: \"status\" in options ? options.status : void 0,\n            statusText: \"statusText\" in options ? options.statusText : void 0\n        };\n        const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n        const getErrorMessage3 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n        const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            }),\n            stream: this.toDataStream({\n                data,\n                getErrorMessage: getErrorMessage3,\n                sendUsage\n            })\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toAIStreamResponse(options) {\n        return this.toDataStreamResponse(options);\n    }\n    toDataStream(options) {\n        const stream = this.toDataStreamInternal({\n            getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n            sendUsage: options == null ? void 0 : options.sendUsage\n        });\n        return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n    }\n    toDataStreamResponse(options) {\n        var _a11;\n        const init = options == null ? void 0 : \"init\" in options ? options.init : {\n            headers: \"headers\" in options ? options.headers : void 0,\n            status: \"status\" in options ? options.status : void 0,\n            statusText: \"statusText\" in options ? options.statusText : void 0\n        };\n        const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n        const getErrorMessage3 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n        const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n        return new Response(this.toDataStream({\n            data,\n            getErrorMessage: getErrorMessage3,\n            sendUsage\n        }), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            })\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a11;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_streamText = streamText;\n// core/middleware/wrap-language-model.ts\nvar experimental_wrapLanguageModel = ({ model, middleware: { transformParams, wrapGenerate, wrapStream }, modelId, providerId })=>{\n    async function doTransform({ params, type }) {\n        return transformParams ? await transformParams({\n            params,\n            type\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v1\",\n        provider: providerId != null ? providerId : model.provider,\n        modelId: modelId != null ? modelId : model.modelId,\n        defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n        supportsImageUrls: model.supportsImageUrls,\n        supportsUrl: model.supportsUrl,\n        supportsStructuredOutputs: model.supportsStructuredOutputs,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"generate\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        },\n        async doStream (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"stream\"\n            });\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapStream ? wrapStream({\n                doStream,\n                params: transformedParams,\n                model\n            }) : doStream();\n        }\n    };\n};\n// core/registry/custom-provider.ts\n\nfunction experimental_customProvider({ languageModels, textEmbeddingModels, fallbackProvider }) {\n    return {\n        languageModel (modelId) {\n            if (languageModels != null && modelId in languageModels) {\n                return languageModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.languageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"languageModel\"\n            });\n        },\n        textEmbeddingModel (modelId) {\n            if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n                return textEmbeddingModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.textEmbeddingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n    };\n}\n// core/registry/no-such-provider-error.ts\n\nvar name10 = \"AI_NoSuchProviderError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){\n        super({\n            errorName: name10,\n            modelId,\n            modelType,\n            message\n        });\n        this[_a10] = true;\n        this.providerId = providerId;\n        this.availableProviders = availableProviders;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchProviderError(error) {\n        return error instanceof Error && error.name === name10 && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            modelId: this.modelId,\n            modelType: this.modelType,\n            providerId: this.providerId,\n            availableProviders: this.availableProviders\n        };\n    }\n};\n_a10 = symbol10;\n// core/registry/provider-registry.ts\n\nfunction experimental_createProviderRegistry(providers) {\n    const registry = new DefaultProviderRegistry();\n    for (const [id, provider] of Object.entries(providers)){\n        registry.registerProvider({\n            id,\n            provider\n        });\n    }\n    return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n    constructor(){\n        this.providers = {};\n    }\n    registerProvider({ id, provider }) {\n        this.providers[id] = provider;\n    }\n    getProvider(id) {\n        const provider = this.providers[id];\n        if (provider == null) {\n            throw new NoSuchProviderError({\n                modelId: id,\n                modelType: \"languageModel\",\n                providerId: id,\n                availableProviders: Object.keys(this.providers)\n            });\n        }\n        return provider;\n    }\n    splitId(id, modelType) {\n        const index = id.indexOf(\":\");\n        if (index === -1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType,\n                message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId:modelId\")`\n            });\n        }\n        return [\n            id.slice(0, index),\n            id.slice(index + 1)\n        ];\n    }\n    languageModel(id) {\n        var _a11, _b;\n        const [providerId, modelId] = this.splitId(id, \"languageModel\");\n        const model = (_b = (_a11 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a11, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"languageModel\"\n            });\n        }\n        return model;\n    }\n    textEmbeddingModel(id) {\n        var _a11, _b, _c;\n        const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n        const provider = this.getProvider(providerId);\n        const model = (_c = (_a11 = provider.textEmbeddingModel) == null ? void 0 : _a11.call(provider, modelId)) != null ? _c : \"textEmbedding\" in provider ? (_b = provider.textEmbedding) == null ? void 0 : _b.call(provider, modelId) : void 0;\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n        return model;\n    }\n    /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */ textEmbedding(id) {\n        return this.textEmbeddingModel(id);\n    }\n};\n// core/tool/tool.ts\nfunction tool(tool2) {\n    return tool2;\n}\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n    if (vector1.length !== vector2.length) {\n        throw new Error(`Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`);\n    }\n    return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n    return vector1.reduce((accumulator, value, index)=>accumulator + value * vector2[index], 0);\n}\nfunction magnitude(vector) {\n    return Math.sqrt(dotProduct(vector, vector));\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_5__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a11;\n            await ((_a11 = it.return) == null ? void 0 : _a11.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// streams/stream-data.ts\nvar StreamData2 = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        this.isClosed = false;\n        this.warningTimeout = null;\n        const self = this;\n        this.stream = new ReadableStream({\n            start: async (controller)=>{\n                self.controller = controller;\n                if (true) {\n                    self.warningTimeout = setTimeout(()=>{\n                        console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                    }, HANGING_STREAM_WARNING_TIME_MS);\n                }\n            },\n            pull: (controller)=>{},\n            cancel: (reason)=>{\n                this.isClosed = true;\n            }\n        });\n    }\n    async close() {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.close();\n        this.isClosed = true;\n        if (this.warningTimeout) {\n            clearTimeout(this.warningTimeout);\n        }\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data\", [\n            value\n        ])));\n    }\n    appendMessageAnnotation(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"message_annotations\", [\n            value\n        ])));\n    }\n};\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\nvar experimental_StreamData = class extends StreamData2 {\n};\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n    let previous = \"\";\n    return (data)=>{\n        const json = JSON.parse(data);\n        if (\"error\" in json) {\n            throw new Error(`${json.error.type}: ${json.error.message}`);\n        }\n        if (!(\"completion\" in json)) {\n            return;\n        }\n        const text = json.completion;\n        if (!previous || text.length > previous.length && text.startsWith(previous)) {\n            const delta = text.slice(previous.length);\n            previous = text;\n            return delta;\n        }\n        return text;\n    };\n}\nasync function* streamable(stream) {\n    for await (const chunk of stream){\n        if (\"completion\" in chunk) {\n            const text = chunk.completion;\n            if (text) yield text;\n        } else if (\"delta\" in chunk) {\n            const { delta } = chunk;\n            if (\"text\" in delta) {\n                const text = delta.text;\n                if (text) yield text;\n            }\n        }\n    }\n}\nfunction AnthropicStream(res, cb) {\n    if (Symbol.asyncIterator in res) {\n        return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n    } else {\n        return AIStream(res, parseAnthropicStream(), cb).pipeThrough(createStreamDataTransformer());\n    }\n}\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n    const stream = new ReadableStream({\n        async start (controller) {\n            var _a11;\n            const textEncoder = new TextEncoder();\n            const sendMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", message)));\n            };\n            const sendDataMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data_message\", message)));\n            };\n            const sendError = (errorMessage)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", errorMessage)));\n            };\n            const forwardStream = async (stream2)=>{\n                var _a12, _b;\n                let result = void 0;\n                for await (const value of stream2){\n                    switch(value.event){\n                        case \"thread.message.created\":\n                            {\n                                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", {\n                                    id: value.data.id,\n                                    role: \"assistant\",\n                                    content: [\n                                        {\n                                            type: \"text\",\n                                            text: {\n                                                value: \"\"\n                                            }\n                                        }\n                                    ]\n                                })));\n                                break;\n                            }\n                        case \"thread.message.delta\":\n                            {\n                                const content = (_a12 = value.data.delta.content) == null ? void 0 : _a12[0];\n                                if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                                    controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", content.text.value)));\n                                }\n                                break;\n                            }\n                        case \"thread.run.completed\":\n                        case \"thread.run.requires_action\":\n                            {\n                                result = value.data;\n                                break;\n                            }\n                    }\n                }\n                return result;\n            };\n            controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_control_data\", {\n                threadId,\n                messageId\n            })));\n            try {\n                await process2({\n                    threadId,\n                    messageId,\n                    sendMessage,\n                    sendDataMessage,\n                    forwardStream\n                });\n            } catch (error) {\n                sendError((_a11 = error.message) != null ? _a11 : `${error}`);\n            } finally{\n                controller.close();\n            }\n        },\n        pull (controller) {},\n        cancel () {}\n    });\n    return new Response(stream, {\n        status: 200,\n        headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\"\n        }\n    });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n    var _a11, _b;\n    const decoder = new TextDecoder();\n    for await (const chunk of (_a11 = response.body) != null ? _a11 : []){\n        const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n        if (bytes != null) {\n            const chunkText = decoder.decode(bytes);\n            const chunkJSON = JSON.parse(chunkText);\n            const delta = extractTextDeltaFromChunk(chunkJSON);\n            if (delta != null) {\n                yield delta;\n            }\n        }\n    }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>{\n        var _a11;\n        return (_a11 = chunk.delta) == null ? void 0 : _a11.text;\n    });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n    return readableFromAsyncIterable(asDeltaIterable(response, extractTextDeltaFromChunk)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n    for (const line of lines){\n        const { text, is_finished } = JSON.parse(line);\n        if (!is_finished) {\n            controller.enqueue(text);\n        }\n    }\n}\nasync function readAndProcessLines(reader, controller) {\n    let segment = \"\";\n    while(true){\n        const { value: chunk, done } = await reader.read();\n        if (done) {\n            break;\n        }\n        segment += utf8Decoder.decode(chunk, {\n            stream: true\n        });\n        const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n        segment = linesArray.pop() || \"\";\n        await processLines(linesArray, controller);\n    }\n    if (segment) {\n        const linesArray = [\n            segment\n        ];\n        await processLines(linesArray, controller);\n    }\n    controller.close();\n}\nfunction createParser2(res) {\n    var _a11;\n    const reader = (_a11 = res.body) == null ? void 0 : _a11.getReader();\n    return new ReadableStream({\n        async start (controller) {\n            if (!reader) {\n                controller.close();\n                return;\n            }\n            await readAndProcessLines(reader, controller);\n        }\n    });\n}\nasync function* streamable2(stream) {\n    for await (const chunk of stream){\n        if (chunk.eventType === \"text-generation\") {\n            const text = chunk.text;\n            if (text) yield text;\n        }\n    }\n}\nfunction CohereStream(reader, callbacks) {\n    if (Symbol.asyncIterator in reader) {\n        return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n    } else {\n        return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n    }\n}\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n    var _a11, _b, _c;\n    for await (const chunk of response.stream){\n        const parts = (_c = (_b = (_a11 = chunk.candidates) == null ? void 0 : _a11[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n        if (parts === void 0) {\n            continue;\n        }\n        const firstPart = parts[0];\n        if (typeof firstPart.text === \"string\") {\n            yield firstPart.text;\n        }\n    }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n    return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a11, _b;\n            const { value, done } = await res.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_b = (_a11 = value.token) == null ? void 0 : _a11.text) != null ? _b : \"\");\n            if (!text) return;\n            if (value.generated_text != null && value.generated_text.length > 0) {\n                return;\n            }\n            if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n                return;\n            }\n            controller.enqueue(text);\n        }\n    });\n}\nfunction HuggingFaceStream(res, callbacks) {\n    return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n    if (!res.body) {\n        throw new Error(\"Response body is null\");\n    }\n    let chat_session_id = \"\";\n    let records_cited;\n    const inkeepEventParser = (data, options)=>{\n        var _a11, _b;\n        const { event } = options;\n        if (event === \"records_cited\") {\n            records_cited = JSON.parse(data);\n            (_a11 = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a11.call(callbacks, records_cited);\n        }\n        if (event === \"message_chunk\") {\n            const inkeepMessageChunk = JSON.parse(data);\n            chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n            return inkeepMessageChunk.content_chunk;\n        }\n        return;\n    };\n    let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n    passThroughCallbacks = {\n        ...passThroughCallbacks,\n        onFinal: (completion)=>{\n            var _a11;\n            const inkeepOnFinalMetadata = {\n                chat_session_id,\n                records_cited\n            };\n            (_a11 = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a11.call(callbacks, completion, inkeepOnFinalMetadata);\n        }\n    };\n    return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(createStreamDataTransformer());\n}\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n    toAIStream: ()=>toAIStream,\n    toDataStream: ()=>toDataStream,\n    toDataStreamResponse: ()=>toDataStreamResponse\n});\nfunction toAIStream(stream, callbacks) {\n    return toDataStream(stream, callbacks);\n}\nfunction toDataStream(stream, callbacks) {\n    return stream.pipeThrough(new TransformStream({\n        transform: async (value, controller)=>{\n            var _a11;\n            if (typeof value === \"string\") {\n                controller.enqueue(value);\n                return;\n            }\n            if (\"event\" in value) {\n                if (value.event === \"on_chat_model_stream\") {\n                    forwardAIMessageChunk((_a11 = value.data) == null ? void 0 : _a11.chunk, controller);\n                }\n                return;\n            }\n            forwardAIMessageChunk(value, controller);\n        }\n    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse(stream, options) {\n    var _a11;\n    const dataStream = toDataStream(stream, options == null ? void 0 : options.callbacks);\n    const data = options == null ? void 0 : options.data;\n    const init = options == null ? void 0 : options.init;\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n    if (typeof chunk.content === \"string\") {\n        controller.enqueue(chunk.content);\n    } else {\n        const content = chunk.content;\n        for (const item of content){\n            if (item.type === \"text\") {\n                controller.enqueue(item.text);\n            }\n        }\n    }\n}\n// streams/llamaindex-adapter.ts\nvar llamaindex_adapter_exports = {};\n__export(llamaindex_adapter_exports, {\n    toDataStream: ()=>toDataStream2,\n    toDataStreamResponse: ()=>toDataStreamResponse2\n});\nfunction toDataStream2(stream, callbacks) {\n    return toReadableStream(stream).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse2(stream, options = {}) {\n    var _a11;\n    const { init, data, callbacks } = options;\n    const dataStream = toDataStream2(stream, callbacks);\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction toReadableStream(res) {\n    const it = res[Symbol.asyncIterator]();\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a11;\n            const { value, done } = await it.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_a11 = value.delta) != null ? _a11 : \"\");\n            if (text) {\n                controller.enqueue(text);\n            }\n        }\n    });\n}\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const runs = /* @__PURE__ */ new Set();\n    const handleError = async (e, runId)=>{\n        runs.delete(runId);\n        await writer.ready;\n        await writer.abort(e);\n    };\n    const handleStart = async (runId)=>{\n        runs.add(runId);\n    };\n    const handleEnd = async (runId)=>{\n        runs.delete(runId);\n        if (runs.size === 0) {\n            await writer.ready;\n            await writer.close();\n        }\n    };\n    return {\n        stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n        writer,\n        handlers: {\n            handleLLMNewToken: async (token)=>{\n                await writer.ready;\n                await writer.write(token);\n            },\n            handleLLMStart: async (_llm, _prompts, runId)=>{\n                handleStart(runId);\n            },\n            handleLLMEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleLLMError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleChainStart: async (_chain, _inputs, runId)=>{\n                handleStart(runId);\n            },\n            handleChainEnd: async (_outputs, runId)=>{\n                await handleEnd(runId);\n            },\n            handleChainError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleToolStart: async (_tool, _input, runId)=>{\n                handleStart(runId);\n            },\n            handleToolEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleToolError: async (e, runId)=>{\n                await handleError(e, runId);\n            }\n        }\n    };\n}\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n    var _a11, _b;\n    for await (const chunk of stream){\n        const content = (_b = (_a11 = chunk.choices[0]) == null ? void 0 : _a11.delta) == null ? void 0 : _b.content;\n        if (content === void 0 || content === \"\") {\n            continue;\n        }\n        yield content;\n    }\n}\nfunction MistralStream(response, callbacks) {\n    const stream = readableFromAsyncIterable(streamable4(response));\n    return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a11, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a11 = choice.delta) == null ? void 0 : _a11.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a11, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a11 = json.choices[0]) == null ? void 0 : _a11.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool2 of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool2.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool2.function.name,\n                                    arguments: JSON.parse(tool2.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n    var _a11;\n    const url = (_a11 = res.urls) == null ? void 0 : _a11.stream;\n    if (!url) {\n        if (res.error) throw new Error(res.error);\n        else throw new Error(\"Missing stream URL in Replicate response\");\n    }\n    const eventStream = await fetch(url, {\n        method: \"GET\",\n        headers: {\n            Accept: \"text/event-stream\",\n            ...options == null ? void 0 : options.headers\n        }\n    });\n    return AIStream(eventStream, void 0, cb).pipeThrough(createStreamDataTransformer());\n}\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n    var _a11;\n    response.writeHead((_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200, {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n    });\n    let processedStream = res;\n    if (data) {\n        processedStream = mergeStreams(data.stream, res);\n    }\n    const reader = processedStream.getReader();\n    function read() {\n        reader.read().then(({ done, value })=>{\n            if (done) {\n                response.end();\n                return;\n            }\n            response.write(value);\n            read();\n        });\n    }\n    read();\n}\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n    constructor(res, init, data){\n        let processedStream = res;\n        if (data) {\n            processedStream = mergeStreams(data.stream, res);\n        }\n        super(processedStream, {\n            ...init,\n            status: 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlAMy40LjMzX3JlYWN0QDE4LjMuMV9zc3dyX2FmNjUzYzBiOTNmNjgxMTlhYTQ4NzAwNTllNWIxYTYwL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsVUFBVUQsSUFDakJMLFVBQVVJLFFBQVFFLFFBQVE7UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxPQUFPO1FBQUVFLFlBQVk7SUFBSztBQUNuRTtBQUVBLG1CQUFtQjtBQU1PO0FBQzRDO0FBRXRFLGdCQUFnQjtBQUM4QjtBQUU5Qyx5Q0FBeUM7QUFDTztBQUN1QjtBQUV2RSxnQkFBZ0I7QUFDaEIsZUFBZVcsTUFBTUMsU0FBUztJQUM1QixPQUFPQSxjQUFjLEtBQUssSUFBSUMsUUFBUUMsT0FBTyxLQUFLLElBQUlELFFBQVEsQ0FBQ0MsVUFBWUMsV0FBV0QsU0FBU0Y7QUFDakc7QUFFQSxzQkFBc0I7QUFDd0I7QUFDOUMsSUFBSUssT0FBTztBQUNYLElBQUlDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRUQsS0FBSyxDQUFDO0FBQ3RDLElBQUlFLFNBQVNDLE9BQU9DLEdBQUcsQ0FBQ0g7QUFDeEIsSUFBSUk7QUFDSixJQUFJQyxhQUFhLGNBQWNQLHdEQUFVQTtJQUN2Q1EsWUFBWSxFQUNWQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTkMsTUFBTSxFQUNQLENBQUU7UUFDRCxLQUFLLENBQUM7WUFBRVY7WUFBTVE7UUFBUTtRQUN0QixJQUFJLENBQUNILEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0ksTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtR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NThCLDhEQUFjQTtBQUNoQyxJQUFJNjhCLFNBQVM3OEIsOERBQWNBO0FBMkV6QixDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2FpQDMuNC4zM19yZWFjdEAxOC4zLjFfc3N3cl9hZjY1M2MwYjkzZjY4MTE5YWE0ODcwMDU5ZTViMWE2MC9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanM/NzA0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUxMSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZTExLCB7IGdldDogYWxsW25hbWUxMV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzdHJlYW1zL2luZGV4LnRzXG5pbXBvcnQge1xuICBmb3JtYXRTdHJlYW1QYXJ0LFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHJlYWREYXRhU3RyZWFtLFxuICBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2Vcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEltcGwgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL2luZGV4LnRzXG5pbXBvcnQgeyBqc29uU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHV0aWwvZGVsYXkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncykge1xuICByZXR1cm4gZGVsYXlJbk1zID09PSB2b2lkIDAgPyBQcm9taXNlLnJlc29sdmUoKSA6IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuXG4vLyB1dGlsL3JldHJ5LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9SZXRyeUVycm9yXCI7XG52YXIgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG52YXIgX2E7XG52YXIgUmV0cnlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1JldHJ5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lICYmIHR5cGVvZiBlcnJvci5yZWFzb24gPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShlcnJvci5lcnJvcnMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgcmVhc29uOiB0aGlzLnJlYXNvbixcbiAgICAgIGxhc3RFcnJvcjogdGhpcy5sYXN0RXJyb3IsXG4gICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzXG4gICAgfTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xuXG4vLyB1dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xudmFyIHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMlxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSk7XG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogXCJtYXhSZXRyaWVzRXhjZWVkZWRcIixcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBBUElDYWxsRXJyb3IuaXNBUElDYWxsRXJyb3IoZXJyb3IpICYmIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBhd2FpdCBkZWxheShkZWxheUluTXMpO1xuICAgICAgcmV0dXJuIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGYsXG4gICAgICAgIHsgbWF4UmV0cmllcywgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLCBiYWNrb2ZmRmFjdG9yIH0sXG4gICAgICAgIG5ld0Vycm9yc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRyeU51bWJlciA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiBcImVycm9yTm90UmV0cnlhYmxlXCIsXG4gICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2Fzc2VtYmxlLW9wZXJhdGlvbi1uYW1lLnRzXG5mdW5jdGlvbiBhc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICBvcGVyYXRpb25JZCxcbiAgdGVsZW1ldHJ5XG59KSB7XG4gIHJldHVybiB7XG4gICAgLy8gc3RhbmRhcmRpemVkIG9wZXJhdGlvbiBhbmQgcmVzb3VyY2UgbmFtZTpcbiAgICBcIm9wZXJhdGlvbi5uYW1lXCI6IGAke29wZXJhdGlvbklkfSR7KHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQpICE9IG51bGwgPyBgICR7dGVsZW1ldHJ5LmZ1bmN0aW9uSWR9YCA6IFwiXCJ9YCxcbiAgICBcInJlc291cmNlLm5hbWVcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCxcbiAgICAvLyBkZXRhaWxlZCwgQUkgU0RLIHNwZWNpZmljIGRhdGE6XG4gICAgXCJhaS5vcGVyYXRpb25JZFwiOiBvcGVyYXRpb25JZCxcbiAgICBcImFpLnRlbGVtZXRyeS5mdW5jdGlvbklkXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWRcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMTE7XG4gIHJldHVybiB7XG4gICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgLy8gc2V0dGluZ3M6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBhdHRyaWJ1dGVzW2BhaS5zZXR0aW5ncy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pLFxuICAgIC8vIGFkZCBtZXRhZGF0YSBhcyBhdHRyaWJ1dGVzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKChfYTExID0gdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkubWV0YWRhdGEpICE9IG51bGwgPyBfYTExIDoge30pLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkudGVsZW1ldHJ5Lm1ldGFkYXRhLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICAvLyByZXF1ZXN0IGhlYWRlcnNcbiAgICAuLi5PYmplY3QuZW50cmllcyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS5yZXF1ZXN0LmhlYWRlcnMuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KVxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcblxuLy8gY29yZS90ZWxlbWV0cnkvbm9vcC10cmFjZXIudHNcbnZhciBub29wVHJhY2VyID0ge1xuICBzdGFydFNwYW4oKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuO1xuICB9LFxuICBzdGFydEFjdGl2ZVNwYW4obmFtZTExLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcxKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmcyKG5vb3BTcGFuKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhcmczKG5vb3BTcGFuKTtcbiAgICB9XG4gIH1cbn07XG52YXIgbm9vcFNwYW4gPSB7XG4gIHNwYW5Db250ZXh0KCkge1xuICAgIHJldHVybiBub29wU3BhbkNvbnRleHQ7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZExpbmtzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHVwZGF0ZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaXNSZWNvcmRpbmcoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICByZWNvcmRFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgbm9vcFNwYW5Db250ZXh0ID0ge1xuICB0cmFjZUlkOiBcIlwiLFxuICBzcGFuSWQ6IFwiXCIsXG4gIHRyYWNlRmxhZ3M6IDBcbn07XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmZ1bmN0aW9uIGdldFRyYWNlcih7XG4gIGlzRW5hYmxlZCA9IGZhbHNlLFxuICB0cmFjZXJcbn0gPSB7fSkge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybiBub29wVHJhY2VyO1xuICB9XG4gIGlmICh0cmFjZXIpIHtcbiAgICByZXR1cm4gdHJhY2VyO1xuICB9XG4gIHJldHVybiB0cmFjZS5nZXRUcmFjZXIoXCJhaVwiKTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvcmVjb3JkLXNwYW4udHNcbmltcG9ydCB7IFNwYW5TdGF0dXNDb2RlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuZnVuY3Rpb24gcmVjb3JkU3Bhbih7XG4gIG5hbWU6IG5hbWUxMSxcbiAgdHJhY2VyLFxuICBhdHRyaWJ1dGVzLFxuICBmbixcbiAgZW5kV2hlbkRvbmUgPSB0cnVlXG59KSB7XG4gIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUxMSwgeyBhdHRyaWJ1dGVzIH0sIGFzeW5jIChzcGFuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKHNwYW4pO1xuICAgICAgaWYgKGVuZFdoZW5Eb25lKSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L3NlbGVjdC10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIHRlbGVtZXRyeSxcbiAgYXR0cmlidXRlc1xufSkge1xuICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmlzRW5hYmxlZCkgIT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLnJlZHVjZSgoYXR0cmlidXRlczIsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJpbnB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZElucHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLmlucHV0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB2b2lkIDAgPyBhdHRyaWJ1dGVzMiA6IHsgLi4uYXR0cmlidXRlczIsIFtrZXldOiByZXN1bHQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcIm91dHB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5vdXRwdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRPdXRwdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUub3V0cHV0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB2b2lkIDAgPyBhdHRyaWJ1dGVzMiA6IHsgLi4uYXR0cmlidXRlczIsIFtrZXldOiByZXN1bHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uYXR0cmlidXRlczIsIFtrZXldOiB2YWx1ZSB9O1xuICB9LCB7fSk7XG59XG5cbi8vIGNvcmUvZW1iZWQvZW1iZWQudHNcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkKHtcbiAgbW9kZWwsXG4gIHZhbHVlLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkXCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkXCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIFwiYWkudmFsdWVcIjogeyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCB7IGVtYmVkZGluZywgdXNhZ2UsIHJhd1Jlc3BvbnNlIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gKFxuICAgICAgICAgIC8vIG5lc3RlZCBzcGFucyB0byBhbGlnbiB3aXRoIHRoZSBlbWJlZE1hbnkgdGVsZW1ldHJ5IGRhdGE6XG4gICAgICAgICAgcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWQuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHsgaW5wdXQ6ICgpID0+IFtKU09OLnN0cmluZ2lmeSh2YWx1ZSldIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTExO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbdmFsdWVdLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZzIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3NbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTExID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTEgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3MubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVtYmVkZGluZzMpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZzMpXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmc6IGVtYmVkZGluZzIsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHVzYWdlMixcbiAgICAgICAgICAgICAgICByYXdSZXNwb25zZTogbW9kZWxSZXNwb25zZS5yYXdSZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ1wiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkUmVzdWx0KHsgdmFsdWUsIGVtYmVkZGluZywgdXNhZ2UsIHJhd1Jlc3BvbnNlIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdGhpcy5lbWJlZGRpbmcgPSBvcHRpb25zLmVtYmVkZGluZztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gb3B0aW9ucy5yYXdSZXNwb25zZTtcbiAgfVxufTtcblxuLy8gY29yZS91dGlsL3NwbGl0LWFycmF5LnRzXG5mdW5jdGlvbiBzcGxpdEFycmF5KGFycmF5LCBjaHVua1NpemUpIHtcbiAgaWYgKGNodW5rU2l6ZSA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IGNodW5rU2l6ZSkge1xuICAgIHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGksIGkgKyBjaHVua1NpemUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBjb3JlL2VtYmVkL2VtYmVkLW1hbnkudHNcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkTWFueSh7XG4gIG1vZGVsLFxuICB2YWx1ZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueVwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IG1heEVtYmVkZGluZ3NQZXJDYWxsID0gbW9kZWwubWF4RW1iZWRkaW5nc1BlckNhbGw7XG4gICAgICBpZiAobWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSB9ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMyA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTEgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExMSA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsIHVzYWdlOiB1c2FnZTIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoeyB2YWx1ZXMsIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlQ2h1bmtzID0gc3BsaXRBcnJheSh2YWx1ZXMsIG1heEVtYmVkZGluZ3NQZXJDYWxsKTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSBbXTtcbiAgICAgIGxldCB0b2tlbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiB2YWx1ZUNodW5rcykge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IHJlc3BvbnNlRW1iZWRkaW5ncywgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogY2h1bmssXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTExID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTEgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbWJlZGRpbmdzLnB1c2goLi4ucmVzcG9uc2VFbWJlZGRpbmdzKTtcbiAgICAgICAgdG9rZW5zICs9IHVzYWdlLnRva2VucztcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB0b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRNYW55UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBvcHRpb25zLmVtYmVkZGluZ3M7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IsIHNhZmVQYXJzZUpTT04gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyB1dGlsL2Rvd25sb2FkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMiA9IFwiQUlfRG93bmxvYWRFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTJ9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgRG93bmxvYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gY2F1c2UgPT0gbnVsbCA/IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke3N0YXR1c0NvZGV9ICR7c3RhdHVzVGV4dH1gIDogYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7Y2F1c2V9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNEb3dubG9hZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTIgJiYgdHlwZW9mIGVycm9yLnVybCA9PT0gXCJzdHJpbmdcIiAmJiAoZXJyb3Iuc3RhdHVzQ29kZSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5zdGF0dXNDb2RlID09PSBcIm51bWJlclwiKSAmJiAoZXJyb3Iuc3RhdHVzVGV4dCA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZVxuICAgIH07XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyB1dGlsL2Rvd25sb2FkLnRzXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZCh7XG4gIHVybCxcbiAgZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoXG59KSB7XG4gIHZhciBfYTExO1xuICBjb25zdCB1cmxUZXh0ID0gdXJsLnRvU3RyaW5nKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGxlbWVudGF0aW9uKHVybFRleHQpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHtcbiAgICAgICAgdXJsOiB1cmxUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSksXG4gICAgICBtaW1lVHlwZTogKF9hMTEgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgIT0gbnVsbCA/IF9hMTEgOiB2b2lkIDBcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChEb3dubG9hZEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IoeyB1cmw6IHVybFRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlLnRzXG52YXIgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiBcImltYWdlL2dpZlwiLCBieXRlczogWzcxLCA3MywgNzBdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsIGJ5dGVzOiBbMTM3LCA4MCwgNzgsIDcxXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL2pwZWdcIiwgYnl0ZXM6IFsyNTUsIDIxNl0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS93ZWJwXCIsIGJ5dGVzOiBbODIsIDczLCA3MCwgNzBdIH1cbl07XG5mdW5jdGlvbiBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlKSB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoaW1hZ2UubGVuZ3RoID49IGJ5dGVzLmxlbmd0aCAmJiBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSkpIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvcHJvbXB0L2ludmFsaWQtZGF0YS1jb250ZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZERhdGFDb250ZW50RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEludmFsaWREYXRhQ29udGVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRhIGNvbnRlbnQuIEV4cGVjdGVkIGEgYmFzZTY0IHN0cmluZywgVWludDhBcnJheSwgQXJyYXlCdWZmZXIsIG9yIEJ1ZmZlciwgYnV0IGdvdCAke3R5cGVvZiBjb250ZW50fS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjMuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUzICYmIGVycm9yLmNvbnRlbnQgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnRcbiAgICB9O1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xudmFyIGRhdGFDb250ZW50U2NoZW1hID0gei51bmlvbihbXG4gIHouc3RyaW5nKCksXG4gIHouaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgei5pbnN0YW5jZW9mKEFycmF5QnVmZmVyKSxcbiAgei5jdXN0b20oXG4gICAgLy8gQnVmZmVyIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gc29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBDbG91ZEZsYXJlOlxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hMTEsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYTExID0gZ2xvYmFsVGhpcy5CdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmlzQnVmZmVyKHZhbHVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG4gICAgfSxcbiAgICB7IG1lc3NhZ2U6IFwiTXVzdCBiZSBhIEJ1ZmZlclwiIH1cbiAgKVxuXSk7XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIG1lZGlhLlwiLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvVGV4dCh1aW50OEFycmF5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50OEFycmF5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBkZWNvZGluZyBVaW50OEFycmF5IHRvIHRleHRcIik7XG4gIH1cbn1cblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1tZXNzYWdlLXJvbGUtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJvbGUsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIG1lc3NhZ2Ugcm9sZTogJyR7cm9sZX0nLiBNdXN0IGJlIG9uZSBvZjogXCJzeXN0ZW1cIiwgXCJ1c2VyXCIsIFwiYXNzaXN0YW50XCIsIFwidG9vbFwiLmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNCAmJiB0eXBlb2YgZXJyb3Iucm9sZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcm9sZTogdGhpcy5yb2xlXG4gICAgfTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG5cbi8vIGNvcmUvcHJvbXB0L3NwbGl0LWRhdGEtdXJsLnRzXG5mdW5jdGlvbiBzcGxpdERhdGFVcmwoZGF0YVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbWVUeXBlOiBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXSxcbiAgICAgIGJhc2U2NENvbnRlbnRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBtaW1lVHlwZTogdm9pZCAwLFxuICAgICAgYmFzZTY0Q29udGVudDogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyA9IHRydWUsXG4gIG1vZGVsU3VwcG9ydHNVcmwgPSAoKSA9PiBmYWxzZSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiA9IGRvd25sb2FkXG59KSB7XG4gIGNvbnN0IGRvd25sb2FkZWRBc3NldHMgPSBhd2FpdCBkb3dubG9hZEFzc2V0cyhcbiAgICBwcm9tcHQubWVzc2FnZXMsXG4gICAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbixcbiAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgIG1vZGVsU3VwcG9ydHNVcmxcbiAgKTtcbiAgcmV0dXJuIFtcbiAgICAuLi5wcm9tcHQuc3lzdGVtICE9IG51bGwgPyBbeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH1dIDogW10sXG4gICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcChcbiAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKVxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgc3dpdGNoIChyb2xlKSB7XG4gICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIlxuICAgICAgICApLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsIC4uLnJlc3QgfSA9IHBhcnQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgY29udGVudDogcGFydC5leHBlcmltZW50YWxfY29udGVudCxcbiAgICAgICAgICBpc0Vycm9yOiBwYXJ0LmlzRXJyb3IsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlUm9sZUVycm9yKHsgcm9sZTogX2V4aGF1c3RpdmVDaGVjayB9KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkQXNzZXRzKG1lc3NhZ2VzLCBkb3dubG9hZEltcGxlbWVudGF0aW9uLCBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzLCBtb2RlbFN1cHBvcnRzVXJsKSB7XG4gIGNvbnN0IHVybHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiXG4gICkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiAhKHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiICYmIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPT09IHRydWUpXG4gICkubWFwKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IHBhcnQuaW1hZ2UgOiBwYXJ0LmRhdGEpLm1hcChcbiAgICAocGFydCkgPT4gKFxuICAgICAgLy8gc3VwcG9ydCBzdHJpbmcgdXJsczpcbiAgICAgIHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiICYmIChwYXJ0LnN0YXJ0c1dpdGgoXCJodHRwOlwiKSB8fCBwYXJ0LnN0YXJ0c1dpdGgoXCJodHRwczpcIikpID8gbmV3IFVSTChwYXJ0KSA6IHBhcnRcbiAgICApXG4gICkuZmlsdGVyKChpbWFnZSkgPT4gaW1hZ2UgaW5zdGFuY2VvZiBVUkwpLmZpbHRlcigodXJsKSA9PiAhbW9kZWxTdXBwb3J0c1VybCh1cmwpKTtcbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVybHMubWFwKGFzeW5jICh1cmwpID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiBhd2FpdCBkb3dubG9hZEltcGxlbWVudGF0aW9uKHsgdXJsIH0pXG4gICAgfSkpXG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEltYWdlcy5tYXAoKHsgdXJsLCBkYXRhIH0pID0+IFt1cmwudG9TdHJpbmcoKSwgZGF0YV0pXG4gICk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykge1xuICBpZiAocGFydC50eXBlID09PSBcInRleHRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICB9O1xuICB9XG4gIGxldCBtaW1lVHlwZSA9IHBhcnQubWltZVR5cGU7XG4gIGxldCBkYXRhO1xuICBsZXQgY29udGVudDtcbiAgbGV0IG5vcm1hbGl6ZWREYXRhO1xuICBjb25zdCB0eXBlID0gcGFydC50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGRhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIGRhdGEgPSBwYXJ0LmRhdGE7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnRlbnQgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoZGF0YSkgOiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnRlbnQgPSBkYXRhO1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgaWYgKGNvbnRlbnQucHJvdG9jb2wgPT09IFwiZGF0YTpcIikge1xuICAgICAgY29uc3QgeyBtaW1lVHlwZTogZGF0YVVybE1pbWVUeXBlLCBiYXNlNjRDb250ZW50IH0gPSBzcGxpdERhdGFVcmwoXG4gICAgICAgIGNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgKTtcbiAgICAgIGlmIChkYXRhVXJsTWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCBpbiBwYXJ0ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIG1pbWVUeXBlID0gZGF0YVVybE1pbWVUeXBlO1xuICAgICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRvd25sb2FkZWRGaWxlID0gZG93bmxvYWRlZEFzc2V0c1tjb250ZW50LnRvU3RyaW5nKCldO1xuICAgICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgICAgbWltZVR5cGUgIT0gbnVsbCA/IG1pbWVUeXBlIDogbWltZVR5cGUgPSBkb3dubG9hZGVkRmlsZS5taW1lVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCAmJiBub3JtYWxpemVkRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbWltZVR5cGUgPSBkZXRlY3RJbWFnZU1pbWVUeXBlKG5vcm1hbGl6ZWREYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgaW1hZ2U6IG5vcm1hbGl6ZWREYXRhLFxuICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaW1lIHR5cGUgaXMgbWlzc2luZyBmb3IgZmlsZSBwYXJ0YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgZGF0YTogbm9ybWFsaXplZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcobm9ybWFsaXplZERhdGEpIDogbm9ybWFsaXplZERhdGEsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICB9XG59XG5cbi8vIGVycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNSA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU1fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTUsXG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyfTogJHttZXNzYWdlfWBcbiAgICB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRBcmd1bWVudEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTUgJiYgdHlwZW9mIGVycm9yLnBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IudmFsdWUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHBhcmFtZXRlcjogdGhpcy5wYXJhbWV0ZXIsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbn07XG5fYTUgPSBzeW1ib2w1O1xuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICB0b3BLLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHN0b3BTZXF1ZW5jZXMsXG4gIHNlZWQsXG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcEsgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BLXCIsXG4gICAgICAgIHZhbHVlOiB0b3BLLFxuICAgICAgICBtZXNzYWdlOiBcInRvcEsgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImZyZXF1ZW5jeVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwiZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2VlZFwiLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogXCJzZWVkIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSAhPSBudWxsID8gdGVtcGVyYXR1cmUgOiAwLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzOiBzdG9wU2VxdWVuY2VzICE9IG51bGwgJiYgc3RvcFNlcXVlbmNlcy5sZW5ndGggPiAwID8gc3RvcFNlcXVlbmNlcyA6IHZvaWQgMCxcbiAgICBzZWVkLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgIT0gbnVsbCA/IG1heFJldHJpZXMgOiAyXG4gIH07XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejcgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L21lc3NhZ2UudHNcbmltcG9ydCB7IHogYXMgejYgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbmltcG9ydCB7IHogYXMgejMgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdHlwZXMvanNvbi12YWx1ZS50c1xuaW1wb3J0IHsgeiBhcyB6MiB9IGZyb20gXCJ6b2RcIjtcbnZhciBqc29uVmFsdWVTY2hlbWEgPSB6Mi5sYXp5KFxuICAoKSA9PiB6Mi51bmlvbihbXG4gICAgejIubnVsbCgpLFxuICAgIHoyLnN0cmluZygpLFxuICAgIHoyLm51bWJlcigpLFxuICAgIHoyLmJvb2xlYW4oKSxcbiAgICB6Mi5yZWNvcmQoejIuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSksXG4gICAgejIuYXJyYXkoanNvblZhbHVlU2NoZW1hKVxuICBdKVxuKTtcblxuLy8gY29yZS90eXBlcy9wcm92aWRlci1tZXRhZGF0YS50c1xudmFyIHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgPSB6My5yZWNvcmQoXG4gIHozLnN0cmluZygpLFxuICB6My5yZWNvcmQoejMuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSlcbik7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnRlbnQtcGFydC50c1xuaW1wb3J0IHsgeiBhcyB6NSB9IGZyb20gXCJ6b2RcIjtcblxuLy8gY29yZS9wcm9tcHQvdG9vbC1yZXN1bHQtY29udGVudC50c1xuaW1wb3J0IHsgeiBhcyB6NCB9IGZyb20gXCJ6b2RcIjtcbnZhciB0b29sUmVzdWx0Q29udGVudFNjaGVtYSA9IHo0LmFycmF5KFxuICB6NC51bmlvbihbXG4gICAgejQub2JqZWN0KHsgdHlwZTogejQubGl0ZXJhbChcInRleHRcIiksIHRleHQ6IHo0LnN0cmluZygpIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgIG1pbWVUeXBlOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgfSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnRlbnQtcGFydC50c1xudmFyIHRleHRQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRleHRcIiksXG4gIHRleHQ6IHo1LnN0cmluZygpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBpbWFnZVBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwiaW1hZ2VcIiksXG4gIGltYWdlOiB6NS51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo1Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBtaW1lVHlwZTogejUuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgZmlsZVBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwiZmlsZVwiKSxcbiAgZGF0YTogejUudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NS5pbnN0YW5jZW9mKFVSTCldKSxcbiAgbWltZVR5cGU6IHo1LnN0cmluZygpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciB0b29sQ2FsbFBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwidG9vbC1jYWxsXCIpLFxuICB0b29sQ2FsbElkOiB6NS5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo1LnN0cmluZygpLFxuICBhcmdzOiB6NS51bmtub3duKClcbn0pO1xudmFyIHRvb2xSZXN1bHRQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRvb2wtcmVzdWx0XCIpLFxuICB0b29sQ2FsbElkOiB6NS5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo1LnN0cmluZygpLFxuICByZXN1bHQ6IHo1LnVua25vd24oKSxcbiAgY29udGVudDogdG9vbFJlc3VsdENvbnRlbnRTY2hlbWEub3B0aW9uYWwoKSxcbiAgaXNFcnJvcjogejUuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG52YXIgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwic3lzdGVtXCIpLFxuICBjb250ZW50OiB6Ni5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVVzZXJNZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcInVzZXJcIiksXG4gIGNvbnRlbnQ6IHo2LnVuaW9uKFtcbiAgICB6Ni5zdHJpbmcoKSxcbiAgICB6Ni5hcnJheSh6Ni51bmlvbihbdGV4dFBhcnRTY2hlbWEsIGltYWdlUGFydFNjaGVtYSwgZmlsZVBhcnRTY2hlbWFdKSlcbiAgXSksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcImFzc2lzdGFudFwiKSxcbiAgY29udGVudDogejYudW5pb24oW1xuICAgIHo2LnN0cmluZygpLFxuICAgIHo2LmFycmF5KHo2LnVuaW9uKFt0ZXh0UGFydFNjaGVtYSwgdG9vbENhbGxQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlVG9vbE1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwidG9vbFwiKSxcbiAgY29udGVudDogejYuYXJyYXkodG9vbFJlc3VsdFBhcnRTY2hlbWEpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlTWVzc2FnZVNjaGVtYSA9IHo2LnVuaW9uKFtcbiAgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSxcbiAgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVUb29sTWVzc2FnZVNjaGVtYVxuXSk7XG5cbi8vIGNvcmUvcHJvbXB0L2RldGVjdC1wcm9tcHQtdHlwZS50c1xuZnVuY3Rpb24gZGV0ZWN0UHJvbXB0VHlwZShwcm9tcHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb21wdCkpIHtcbiAgICByZXR1cm4gXCJvdGhlclwiO1xuICB9XG4gIGlmIChwcm9tcHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwibWVzc2FnZXNcIjtcbiAgfVxuICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBwcm9tcHQubWFwKGRldGVjdFNpbmdsZU1lc3NhZ2VDaGFyYWN0ZXJpc3RpY3MpO1xuICBpZiAoY2hhcmFjdGVyaXN0aWNzLnNvbWUoKGMpID0+IGMgPT09IFwiaGFzLXVpLXNwZWNpZmljLXBhcnRzXCIpKSB7XG4gICAgcmV0dXJuIFwidWktbWVzc2FnZXNcIjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXJpc3RpY3MuZXZlcnkoXG4gICAgKGMpID0+IGMgPT09IFwiaGFzLWNvcmUtc3BlY2lmaWMtcGFydHNcIiB8fCBjID09PSBcIm1lc3NhZ2VcIlxuICApKSB7XG4gICAgcmV0dXJuIFwibWVzc2FnZXNcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvdGhlclwiO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgKG1lc3NhZ2Uucm9sZSA9PT0gXCJmdW5jdGlvblwiIHx8IC8vIFVJLW9ubHkgcm9sZVxuICBtZXNzYWdlLnJvbGUgPT09IFwiZGF0YVwiIHx8IC8vIFVJLW9ubHkgcm9sZVxuICBcInRvb2xJbnZvY2F0aW9uc1wiIGluIG1lc3NhZ2UgfHwgLy8gVUktc3BlY2lmaWMgZmllbGRcbiAgXCJleHBlcmltZW50YWxfYXR0YWNobWVudHNcIiBpbiBtZXNzYWdlKSkge1xuICAgIHJldHVybiBcImhhcy11aS1zcGVjaWZpYy1wYXJ0c1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbnRlbnQpIHx8IC8vIENvcmUgbWVzc2FnZXMgY2FuIGhhdmUgYXJyYXkgY29udGVudFxuICBcImV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXCIgaW4gbWVzc2FnZSkpIHtcbiAgICByZXR1cm4gXCJoYXMtY29yZS1zcGVjaWZpYy1wYXJ0c1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiICYmIG1lc3NhZ2UgIT09IG51bGwgJiYgXCJyb2xlXCIgaW4gbWVzc2FnZSAmJiBcImNvbnRlbnRcIiBpbiBtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiYgW1wic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIl0uaW5jbHVkZXMobWVzc2FnZS5yb2xlKSkge1xuICAgIHJldHVybiBcIm1lc3NhZ2VcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvdGhlclwiO1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2F0dGFjaG1lbnRzLXRvLXBhcnRzLnRzXG5mdW5jdGlvbiBhdHRhY2htZW50c1RvUGFydHMoYXR0YWNobWVudHMpIHtcbiAgdmFyIF9hMTEsIF9iLCBfYztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgbGV0IHVybDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChhdHRhY2htZW50LnVybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgIGNhc2UgXCJodHRwczpcIjoge1xuICAgICAgICBpZiAoKF9hMTEgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6IFwiaW1hZ2VcIiwgaW1hZ2U6IHVybCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJZiB0aGUgYXR0YWNobWVudCBpcyBub3QgYW4gaW1hZ2UsIGl0IG11c3Qgc3BlY2lmeSBhIGNvbnRlbnQgdHlwZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhOlwiOiB7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIGxldCBiYXNlNjRDb250ZW50O1xuICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBhdHRhY2htZW50LnVybC5zcGxpdChcIixcIik7XG4gICAgICAgICAgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2MgPSBhdHRhY2htZW50LmNvbnRlbnRUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnZlcnRVaW50OEFycmF5VG9UZXh0KFxuICAgICAgICAgICAgICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWF0dGFjaG1lbnQuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgXCJJZiB0aGUgYXR0YWNobWVudCBpcyBub3QgYW4gaW1hZ2Ugb3IgdGV4dCwgaXQgbXVzdCBzcGVjaWZ5IGEgY29udGVudCB0eXBlXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICBkYXRhOiBiYXNlNjRDb250ZW50LFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L21lc3NhZ2UtY29udmVyc2lvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTYgPSBcIkFJX01lc3NhZ2VDb252ZXJzaW9uRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2O1xudmFyIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG9yaWdpbmFsTWVzc2FnZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU2LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjYuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gIHZhciBfYTExO1xuICBjb25zdCB0b29scyA9IChfYTExID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b29scykgIT0gbnVsbCA/IF9hMTEgOiB7fTtcbiAgY29uc3QgY29yZU1lc3NhZ2VzID0gW107XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgIGNvbnN0IHsgcm9sZSwgY29udGVudCwgdG9vbEludm9jYXRpb25zLCBleHBlcmltZW50YWxfYXR0YWNobWVudHMgfSA9IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBleHBlcmltZW50YWxfYXR0YWNobWVudHMgPyBbXG4gICAgICAgICAgICB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAuLi5hdHRhY2htZW50c1RvUGFydHMoZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzKVxuICAgICAgICAgIF0gOiBjb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBpZiAodG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwiYXNzaXN0YW50XCIsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4udG9vbEludm9jYXRpb25zLm1hcChcbiAgICAgICAgICAgICAgKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICBjb250ZW50OiB0b29sSW52b2NhdGlvbnMubWFwKCh0b29sSW52b2NhdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKCEoXCJyZXN1bHRcIiBpbiB0b29sSW52b2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRvb2xJbnZvY2F0aW9uIG11c3QgaGF2ZSBhIHJlc3VsdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0b29sSW52b2NhdGlvbilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCByZXN1bHQgfSA9IHRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudCkgIT0gbnVsbCA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgcmVzdWx0OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQocmVzdWx0KVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcmVNZXNzYWdlcztcbn1cblxuLy8gY29yZS9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0LnRzXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZVByb21wdCh7XG4gIHByb21wdCxcbiAgdG9vbHNcbn0pIHtcbiAgaWYgKHByb21wdC5wcm9tcHQgPT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZVwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnN5c3RlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJzeXN0ZW0gbXVzdCBiZSBhIHN0cmluZ1wiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJvbXB0LnByb21wdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogXCJwcm9tcHQgbXVzdCBiZSBhIHN0cmluZ1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicHJvbXB0XCIsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogcHJvbXB0LnByb21wdFxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuICBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBjb25zdCBwcm9tcHRUeXBlID0gZGV0ZWN0UHJvbXB0VHlwZShwcm9tcHQubWVzc2FnZXMpO1xuICAgIGlmIChwcm9tcHRUeXBlID09PSBcIm90aGVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZSBvciBVSU1lc3NhZ2VcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gcHJvbXB0VHlwZSA9PT0gXCJ1aS1tZXNzYWdlc1wiID8gY29udmVydFRvQ29yZU1lc3NhZ2VzKHByb21wdC5tZXNzYWdlcywge1xuICAgICAgdG9vbHNcbiAgICB9KSA6IHByb21wdC5tZXNzYWdlcztcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgICAgdmFsdWU6IG1lc3NhZ2VzLFxuICAgICAgc2NoZW1hOiB6Ny5hcnJheShjb3JlTWVzc2FnZVNjaGVtYSlcbiAgICB9KTtcbiAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogXCJtZXNzYWdlcyBtdXN0IGJlIGFuIGFycmF5IG9mIENvcmVNZXNzYWdlIG9yIFVJTWVzc2FnZVwiLFxuICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1lc3NhZ2VzXCIsXG4gICAgICBtZXNzYWdlcyxcbiAgICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwidW5yZWFjaGFibGVcIik7XG59XG5cbi8vIGNvcmUvdHlwZXMvdXNhZ2UudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSkge1xuICByZXR1cm4ge1xuICAgIHByb21wdFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgIGNvbXBsZXRpb25Ub2tlbnM6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgdG90YWxUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyArIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL3ByZXBhcmUtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gIGNvbnRlbnRUeXBlLFxuICBkYXRhU3RyZWFtVmVyc2lvblxufSkge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKSAhPSBudWxsID8gX2ExMSA6IHt9KTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgfVxuICBpZiAoZGF0YVN0cmVhbVZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnMuc2V0KFwiWC1WZXJjZWwtQUktRGF0YS1TdHJlYW1cIiwgZGF0YVN0cmVhbVZlcnNpb24pO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9pbmplY3QtanNvbi1pbnN0cnVjdGlvbi50c1xudmFyIERFRkFVTFRfU0NIRU1BX1BSRUZJWCA9IFwiSlNPTiBzY2hlbWE6XCI7XG52YXIgREVGQVVMVF9TQ0hFTUFfU1VGRklYID0gXCJZb3UgTVVTVCBhbnN3ZXIgd2l0aCBhIEpTT04gb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgSlNPTiBzY2hlbWEgYWJvdmUuXCI7XG52YXIgREVGQVVMVF9HRU5FUklDX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggSlNPTi5cIjtcbmZ1bmN0aW9uIGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gIHByb21wdCxcbiAgc2NoZW1hLFxuICBzY2hlbWFQcmVmaXggPSBzY2hlbWEgIT0gbnVsbCA/IERFRkFVTFRfU0NIRU1BX1BSRUZJWCA6IHZvaWQgMCxcbiAgc2NoZW1hU3VmZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9TVUZGSVggOiBERUZBVUxUX0dFTkVSSUNfU1VGRklYXG59KSB7XG4gIHJldHVybiBbXG4gICAgcHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lmxlbmd0aCA+IDAgPyBwcm9tcHQgOiB2b2lkIDAsXG4gICAgcHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lmxlbmd0aCA+IDAgPyBcIlwiIDogdm9pZCAwLFxuICAgIC8vIGFkZCBhIG5ld2xpbmUgaWYgcHJvbXB0IGlzIG5vdCBudWxsXG4gICAgc2NoZW1hUHJlZml4LFxuICAgIHNjaGVtYSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSA6IHZvaWQgMCxcbiAgICBzY2hlbWFTdWZmaXhcbiAgXS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT0gbnVsbCkuam9pbihcIlxcblwiKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvbm8tb2JqZWN0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTcgPSBcIkFJX05vT2JqZWN0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I3IHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjcuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc05vT2JqZWN0R2VuZXJhdGVkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNztcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICB9O1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG5pbXBvcnQge1xuICBpc0pTT05BcnJheSxcbiAgaXNKU09OT2JqZWN0LFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2FzeW5jLWl0ZXJhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShzb3VyY2UsIHRyYW5zZm9ybWVyKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gc291cmNlLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpXG4gICk7XG4gIHRyYW5zZm9ybWVkU3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSB0cmFuc2Zvcm1lZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkU3RyZWFtO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9vdXRwdXQtc3RyYXRlZ3kudHNcbnZhciBub1NjaGVtYU91dHB1dFN0cmF0ZWd5ID0ge1xuICB0eXBlOiBcIm5vLXNjaGVtYVwiLFxuICBqc29uU2NoZW1hOiB2b2lkIDAsXG4gIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB7IHBhcnRpYWw6IHZhbHVlLCB0ZXh0RGVsdGEgfSB9O1xuICB9LFxuICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IoKSB9IDogeyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBuby1zY2hlbWEgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn07XG52YXIgb2JqZWN0T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBqc29uU2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYSxcbiAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgIHBhcnRpYWw6IHZhbHVlLFxuICAgICAgICB0ZXh0RGVsdGFcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBzY2hlbWEuanNvblNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIGxhdGVzdE9iamVjdCwgaXNGaXJzdERlbHRhLCBpc0ZpbmFsRGVsdGEgfSkge1xuICAgICAgdmFyIF9hMTE7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBjb25zdCByZXN1bHRBcnJheSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoaSA9PT0gaW5wdXRBcnJheS5sZW5ndGggLSAxICYmICFpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaXNoZWRFbGVtZW50Q291bnQgPSAoX2ExMSA9IGxhdGVzdE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0T2JqZWN0Lmxlbmd0aCkgIT0gbnVsbCA/IF9hMTEgOiAwO1xuICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICBpZiAoaXNGaXJzdERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIltcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaXNoZWRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHRleHREZWx0YSArPSByZXN1bHRBcnJheS5zbGljZShwdWJsaXNoZWRFbGVtZW50Q291bnQpLm1hcCgoZWxlbWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCkpLmpvaW4oXCIsXCIpO1xuICAgICAgaWYgKGlzRmluYWxEZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHJlc3VsdEFycmF5LFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGlucHV0QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiBpbnB1dEFycmF5IH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKG9yaWdpbmFsU3RyZWFtKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0ob3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgIGZvciAoOyBwdWJsaXNoZWRFbGVtZW50cyA8IGFycmF5Lmxlbmd0aDsgcHVibGlzaGVkRWxlbWVudHMrKykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShhcnJheVtwdWJsaXNoZWRFbGVtZW50c10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBlbnVtT3V0cHV0U3RyYXRlZ3kgPSAoZW51bVZhbHVlcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIC8vIHdyYXAgaW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcmVzdWx0LCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGVudW0gdmFsdWUgZGlyZWN0bHk6XG4gICAgLy8gcG9zc2libGUgZnV0dXJlIG9wdGltaXphdGlvbjogdXNlIGVudW1zIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgdG9wLWxldmVsIGVudW1zXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJlc3VsdDogeyB0eXBlOiBcInN0cmluZ1wiLCBlbnVtOiBlbnVtVmFsdWVzIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wicmVzdWx0XCJdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgfSxcbiAgICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiAndmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHN0cmluZyBpbiB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICAgIHJldHVybiBlbnVtVmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQgfSA6IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZW51bVwiXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJwYXJ0aWFsIHJlc3VsdHMgaW4gZW51bSBtb2RlXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0T3V0cHV0U3RyYXRlZ3koe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgZW51bVZhbHVlc1xufSkge1xuICBzd2l0Y2ggKG91dHB1dCkge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBvYmplY3RPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiBhcnJheU91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hKHNjaGVtYSkpO1xuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICByZXR1cm4gZW51bU91dHB1dFN0cmF0ZWd5KGVudW1WYWx1ZXMpO1xuICAgIGNhc2UgXCJuby1zY2hlbWFcIjpcbiAgICAgIHJldHVybiBub1NjaGVtYU91dHB1dFN0cmF0ZWd5O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBvdXRwdXQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC92YWxpZGF0ZS1vYmplY3QtZ2VuZXJhdGlvbi1pbnB1dC50c1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICBvdXRwdXQsXG4gIG1vZGUsXG4gIHNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgaWYgKG91dHB1dCAhPSBudWxsICYmIG91dHB1dCAhPT0gXCJvYmplY3RcIiAmJiBvdXRwdXQgIT09IFwiYXJyYXlcIiAmJiBvdXRwdXQgIT09IFwiZW51bVwiICYmIG91dHB1dCAhPT0gXCJuby1zY2hlbWFcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwib3V0cHV0XCIsXG4gICAgICB2YWx1ZTogb3V0cHV0LFxuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG91dHB1dCB0eXBlLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJuby1zY2hlbWFcIikge1xuICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09PSBcInRvb2xcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1vZGVcIixcbiAgICAgICAgdmFsdWU6IG1vZGUsXG4gICAgICAgIG1lc3NhZ2U6ICdNb2RlIG11c3QgYmUgXCJqc29uXCIgZm9yIG5vLXNjaGVtYSBvdXRwdXQuJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIHJlcXVpcmVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJFbGVtZW50IHNjaGVtYSBpcyByZXF1aXJlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiZW51bVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgcmVxdWlyZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBlbnVtVmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIG11c3QgYmUgc3RyaW5ncy5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3IoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU9iamVjdCh7XG4gIG1vZGVsLFxuICBlbnVtOiBlbnVtVmFsdWVzLFxuICAvLyByZW5hbWUgYmMgZW51bSBpcyByZXNlcnZlZCBieSB0eXBlc2NyaXB0XG4gIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBtb2RlLFxuICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBtb2RlLFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zY2hlbWFcIjogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSAhPSBudWxsID8geyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSkgfSA6IHZvaWQgMCxcbiAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExMSwgX2I7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgIGxldCB1c2FnZTtcbiAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgIGxldCByYXdSZXNwb25zZTtcbiAgICAgIGxldCByZXNwb25zZTtcbiAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgbGV0IGxvZ3Byb2JzO1xuICAgICAgbGV0IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICBzeXN0ZW06IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgPT0gbnVsbCA/IGluamVjdEpzb25JbnN0cnVjdGlvbih7IHByb21wdDogc3lzdGVtIH0pIDogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHN5c3RlbSA6IGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gICAgICAgICAgICAgICAgcHJvbXB0OiBzeXN0ZW0sXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogbW9kZWwuc3VwcG9ydHNVcmxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RhbmRhcmRpemVkUHJvbXB0LnR5cGVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTEyLCBfYjIsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtanNvblwiLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Mi50ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTIgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi5pZCkgIT0gbnVsbCA/IF9iMiA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZCA9IChfYyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy50aW1lc3RhbXApICE9IG51bGwgPyBfZCA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2YgPSAoX2UgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UubW9kZWxJZCkgIT0gbnVsbCA/IF9mIDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gcmVzdWx0Mi50ZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gcmVzdWx0Mi50ZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQyLmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLnByb21wdF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuY29tcGxldGlvbl90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0OiByZXN1bHQyLnRleHQsIHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICByZXF1ZXN0ID0gKF9hMTEgPSBnZW5lcmF0ZVJlc3VsdC5yZXF1ZXN0KSAhPSBudWxsID8gX2ExMSA6IHt9O1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gc3RhbmRhcmRpemVkUHJvbXB0LnR5cGU7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGlucHV0Rm9ybWF0XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExMiwgX2IyLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUgIT0gbnVsbCA/IHNjaGVtYU5hbWUgOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCA/IHNjaGVtYURlc2NyaXB0aW9uIDogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0LFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RUZXh0ID0gKF9iMiA9IChfYTEyID0gcmVzdWx0Mi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdFRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IChfZCA9IChfYyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5pZCkgIT0gbnVsbCA/IF9kIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9mIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfaCA9IChfZyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tb2RlbElkKSAhPSBudWxsID8gX2ggOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiBvYmplY3RUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gb2JqZWN0VGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0Mi5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdDIsIG9iamVjdFRleHQsIHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICByZXF1ZXN0ID0gKF9iID0gZ2VuZXJhdGVSZXN1bHQucmVxdWVzdCkgIT0gbnVsbCA/IF9iIDoge307XG4gICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yZXNwb25zZURhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHsgdGV4dDogcmVzdWx0IH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IHBhcnNlUmVzdWx0LmVycm9yO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQoXG4gICAgICAgIHBhcnNlUmVzdWx0LnZhbHVlXG4gICAgICApO1xuICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgdmFsaWRhdGlvblJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uUmVzdWx0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsaWRhdGlvblJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgICAgICBvYmplY3Q6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUsXG4gICAgICAgIGZpbmlzaFJlYXNvbixcbiAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHRQcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMucmVxdWVzdCA9IG9wdGlvbnMucmVxdWVzdDtcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0ge1xuICAgICAgaGVhZGVyczogb3B0aW9ucy5yZXNwb25zZS5oZWFkZXJzXG4gICAgfTtcbiAgICB0aGlzLmxvZ3Byb2JzID0gb3B0aW9ucy5sb2dwcm9icztcbiAgfVxuICB0b0pzb25SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMTE7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh0aGlzLm9iamVjdCksIHtcbiAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU9iamVjdCA9IGdlbmVyYXRlT2JqZWN0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBwYXJzZVBhcnRpYWxKc29uXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZS50c1xuZnVuY3Rpb24gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKSB7XG4gIGxldCByZXNvbHZlO1xuICBsZXQgcmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3RcbiAgfTtcbn1cblxuLy8gdXRpbC9kZWxheWVkLXByb21pc2UudHNcbnZhciBEZWxheWVkUHJvbWlzZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicGVuZGluZ1wiIH07XG4gICAgdGhpcy5fcmVzb2x2ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZWplY3QgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlc29sdmVkXCIpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLnN0YXR1cy52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICByZWplY3QodGhpcy5zdGF0dXMuZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgfVxuICByZXNvbHZlKHZhbHVlKSB7XG4gICAgdmFyIF9hMTE7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicmVzb2x2ZWRcIiwgdmFsdWUgfTtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAoX2ExMSA9IHRoaXMuX3Jlc29sdmUpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZWplY3QoZXJyb3IpIHtcbiAgICB2YXIgX2ExMTtcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZWplY3RlZFwiLCBlcnJvciB9O1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIChfYTExID0gdGhpcy5fcmVqZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9ub3cudHNcbmZ1bmN0aW9uIG5vdygpIHtcbiAgdmFyIF9hMTEsIF9iO1xuICByZXR1cm4gKF9iID0gKF9hMTEgPSBnbG9iYWxUaGlzID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5ub3coKSkgIT0gbnVsbCA/IF9iIDogRGF0ZS5ub3coKTtcbn1cblxuLy8gY29yZS91dGlsL3ByZXBhcmUtb3V0Z29pbmctaHR0cC1oZWFkZXJzLnRzXG5mdW5jdGlvbiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0LCB7XG4gIGNvbnRlbnRUeXBlLFxuICBkYXRhU3RyZWFtVmVyc2lvblxufSkge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmICgoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKSAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5pdC5oZWFkZXJzKSkge1xuICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGlmIChoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09IG51bGwpIHtcbiAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gY29udGVudFR5cGU7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW1wiWC1WZXJjZWwtQUktRGF0YS1TdHJlYW1cIl0gPSBkYXRhU3RyZWFtVmVyc2lvbjtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gY29yZS91dGlsL3dyaXRlLXRvLXNlcnZlci1yZXNwb25zZS50c1xuZnVuY3Rpb24gd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgc3RyZWFtXG59KSB7XG4gIHJlc3BvbnNlLndyaXRlSGVhZChzdGF0dXMgIT0gbnVsbCA/IHN0YXR1cyA6IDIwMCwgc3RhdHVzVGV4dCwgaGVhZGVycyk7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgIH1cbiAgfTtcbiAgcmVhZCgpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMiA9IGNyZWF0ZUlkR2VuZXJhdG9yMih7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgb25GaW5pc2gsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMixcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgIG5vdzogbm93MiA9IG5vd1xuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgbW9kZSxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb25cbiAgfSk7XG4gIGNvbnN0IG91dHB1dFN0cmF0ZWd5ID0gZ2V0T3V0cHV0U3RyYXRlZ3koeyBvdXRwdXQsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmIChvdXRwdXRTdHJhdGVneS50eXBlID09PSBcIm5vLXNjaGVtYVwiICYmIG1vZGUgPT09IHZvaWQgMCkge1xuICAgIG1vZGUgPSBcImpzb25cIjtcbiAgfVxuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zY2hlbWFcIjogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSAhPSBudWxsID8geyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSkgfSA6IHZvaWQgMCxcbiAgICAgICAgXCJhaS5zY2hlbWEubmFtZVwiOiBzY2hlbWFOYW1lLFxuICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGVcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxsT3B0aW9ucztcbiAgICAgIGxldCB0cmFuc2Zvcm1lcjtcbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIFwianNvblwiOiB7XG4gICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgIHN5c3RlbTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSA9PSBudWxsID8gaW5qZWN0SnNvbkluc3RydWN0aW9uKHsgcHJvbXB0OiBzeXN0ZW0gfSkgOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzID8gc3lzdGVtIDogaW5qZWN0SnNvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWFcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogbW9kZWwuc3VwcG9ydHNVcmxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgIH07XG4gICAgICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lICE9IG51bGwgPyBzY2hlbWFOYW1lIDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICBpbnB1dEZvcm1hdDogc3RhbmRhcmRpemVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5hcmdzVGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZXN1bHQ6IHsgc3RyZWFtLCB3YXJuaW5ncywgcmF3UmVzcG9uc2UsIHJlcXVlc3QgfSxcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gY2FsbE9wdGlvbnMuaW5wdXRGb3JtYXRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjYWxsT3B0aW9ucy5wcm9tcHQpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhUb2tlbnMsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+ICh7XG4gICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKGNhbGxPcHRpb25zKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpKSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0ICE9IG51bGwgPyByZXF1ZXN0IDoge30sXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICByb290U3BhbixcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgIG5vdzogbm93MixcbiAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgcmVxdWVzdCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBvbkZpbmlzaCxcbiAgICByb290U3BhbixcbiAgICBkb1N0cmVhbVNwYW4sXG4gICAgdGVsZW1ldHJ5LFxuICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgbW9kZWxJZCxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDNcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gICAgdGhpcy5vdXRwdXRTdHJhdGVneSA9IG91dHB1dFN0cmF0ZWd5O1xuICAgIHRoaXMucmVxdWVzdCA9IFByb21pc2UucmVzb2x2ZShyZXF1ZXN0KTtcbiAgICB0aGlzLm9iamVjdFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVVc2FnZSwgcHJvbWlzZTogdXNhZ2VQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVzcG9uc2UsIHByb21pc2U6IHJlc3BvbnNlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVQcm92aWRlck1ldGFkYXRhLFxuICAgICAgcHJvbWlzZTogcHJvdmlkZXJNZXRhZGF0YVByb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YVByb21pc2U7XG4gICAgbGV0IHVzYWdlO1xuICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgbGV0IG9iamVjdDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgaWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICBtb2RlbElkXG4gICAgfTtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0SnNvbiA9IHZvaWQgMDtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgIGxldCBpc0ZpcnN0RGVsdGEgPSB0cnVlO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYztcbiAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLCBzdGF0ZTogcGFyc2VTdGF0ZSB9ID0gcGFyc2VQYXJ0aWFsSnNvbihhY2N1bXVsYXRlZFRleHQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRPYmplY3RKc29uICE9PSB2b2lkIDAgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3RKc29uLCBjdXJyZW50T2JqZWN0SnNvbikpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRPYmplY3RKc29uLFxuICAgICAgICAgICAgICAgIHRleHREZWx0YSxcbiAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhLFxuICAgICAgICAgICAgICAgIGlzRmluYWxEZWx0YTogcGFyc2VTdGF0ZSA9PT0gXCJzdWNjZXNzZnVsLXBhcnNlXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3QsIHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbCkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3RKc29uID0gY3VycmVudE9iamVjdEpzb247XG4gICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUudGV4dERlbHRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpc0ZpcnN0RGVsdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2ExMSA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExMSA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiByZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jIDogcmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICBpZiAodGV4dERlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHREZWx0YSB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgIHVzYWdlID0gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKTtcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IC4uLmNodW5rLCB1c2FnZSwgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgICAgIHJlc29sdmVVc2FnZSh1c2FnZSk7XG4gICAgICAgICAgICAgIHJlc29sdmVQcm92aWRlck1ldGFkYXRhKHByb3ZpZGVyTWV0YWRhdGEpO1xuICAgICAgICAgICAgICByZXNvbHZlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVGaW5hbFJlc3VsdChsYXRlc3RPYmplY3RKc29uKTtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlc29sdmUob2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgc2VsZi5vYmplY3RQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgIHByb21wdFRva2VuczogTmFOLFxuICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvYmplY3QpIH0sXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiBmaW5hbFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yMik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGdldCBvYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLm9iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZWxlbWVudFN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRTdHJhdGVneS5jcmVhdGVFbGVtZW50U3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0pO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSksXG4gICAgICBzdHJlYW06IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMTE7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgICBzdGF0dXM6IChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfc3RyZWFtT2JqZWN0ID0gc3RyZWFtT2JqZWN0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gZXJyb3JzL2luZGV4LnRzXG5pbXBvcnQge1xuICBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMCxcbiAgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gZXJyb3JzL2ludmFsaWQtdG9vbC1hcmd1bWVudHMtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjgsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOCA9IFwiQUlfSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbEFyZ3MsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UyKFxuICAgICAgY2F1c2VcbiAgICApfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gICAgdGhpcy50b29sQXJncyA9IHRvb2xBcmdzO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOCAmJiB0eXBlb2YgZXJyb3IudG9vbE5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnRvb2xBcmdzID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRoaXMudG9vbEFyZ3NcbiAgICB9O1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gZXJyb3JzL25vLXN1Y2gtdG9vbC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTkgPSBcIkFJX05vU3VjaFRvb2xFcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTl9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG52YXIgTm9TdWNoVG9vbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sTmFtZSxcbiAgICBhdmFpbGFibGVUb29scyA9IHZvaWQgMCxcbiAgICBtZXNzYWdlID0gYE1vZGVsIHRyaWVkIHRvIGNhbGwgdW5hdmFpbGFibGUgdG9vbCAnJHt0b29sTmFtZX0nLiAke2F2YWlsYWJsZVRvb2xzID09PSB2b2lkIDAgPyBcIk5vIHRvb2xzIGFyZSBhdmFpbGFibGUuXCIgOiBgQXZhaWxhYmxlIHRvb2xzOiAke2F2YWlsYWJsZVRvb2xzLmpvaW4oXCIsIFwiKX0uYH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E5XSA9IHRydWU7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICAgIHRoaXMuYXZhaWxhYmxlVG9vbHMgPSBhdmFpbGFibGVUb29scztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yOS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjkpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaFRvb2xFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU5ICYmIFwidG9vbE5hbWVcIiBpbiBlcnJvciAmJiBlcnJvci50b29sTmFtZSAhPSB2b2lkIDAgJiYgdHlwZW9mIGVycm9yLm5hbWUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHRvb2xOYW1lOiB0aGlzLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IHRoaXMuYXZhaWxhYmxlVG9vbHNcbiAgICB9O1xuICB9XG59O1xuX2E5ID0gc3ltYm9sOTtcblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hMiB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPiAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBhY3RpdmVUb29sc1xufSkge1xuICBpZiAoIWlzTm9uRW1wdHlPYmplY3QodG9vbHMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xzOiB2b2lkIDAsXG4gICAgICB0b29sQ2hvaWNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IGZpbHRlcmVkVG9vbHMgPSBhY3RpdmVUb29scyAhPSBudWxsID8gT2JqZWN0LmVudHJpZXModG9vbHMpLmZpbHRlcihcbiAgICAoW25hbWUxMV0pID0+IGFjdGl2ZVRvb2xzLmluY2x1ZGVzKG5hbWUxMSlcbiAgKSA6IE9iamVjdC5lbnRyaWVzKHRvb2xzKTtcbiAgcmV0dXJuIHtcbiAgICB0b29sczogZmlsdGVyZWRUb29scy5tYXAoKFtuYW1lMTEsIHRvb2wyXSkgPT4ge1xuICAgICAgY29uc3QgdG9vbFR5cGUgPSB0b29sMi50eXBlO1xuICAgICAgc3dpdGNoICh0b29sVHlwZSkge1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUxMSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sMi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGFzU2NoZW1hMih0b29sMi5wYXJhbWV0ZXJzKS5qc29uU2NoZW1hXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInByb3ZpZGVyLWRlZmluZWRcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJwcm92aWRlci1kZWZpbmVkXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lMTEsXG4gICAgICAgICAgICBpZDogdG9vbDIuaWQsXG4gICAgICAgICAgICBhcmdzOiB0b29sMi5hcmdzXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHRvb2xUeXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdG9vbCB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRvb2xDaG9pY2U6IHRvb2xDaG9pY2UgPT0gbnVsbCA/IHsgdHlwZTogXCJhdXRvXCIgfSA6IHR5cGVvZiB0b29sQ2hvaWNlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiB0b29sQ2hvaWNlIH0gOiB7IHR5cGU6IFwidG9vbFwiLCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSB9XG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9zcGxpdC1vbi1sYXN0LXdoaXRlc3BhY2UudHNcbnZhciBsYXN0V2hpdGVzcGFjZVJlZ2V4cCA9IC9eKFtcXHNcXFNdKj8pKFxccyspKFxcUyopJC87XG5mdW5jdGlvbiBzcGxpdE9uTGFzdFdoaXRlc3BhY2UodGV4dCkge1xuICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2gobGFzdFdoaXRlc3BhY2VSZWdleHApO1xuICByZXR1cm4gbWF0Y2ggPyB7IHByZWZpeDogbWF0Y2hbMV0sIHdoaXRlc3BhY2U6IG1hdGNoWzJdLCBzdWZmaXg6IG1hdGNoWzNdIH0gOiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvdXRpbC9yZW1vdmUtdGV4dC1hZnRlci1sYXN0LXdoaXRlc3BhY2UudHNcbmZ1bmN0aW9uIHJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlKHRleHQpIHtcbiAgY29uc3QgbWF0Y2ggPSBzcGxpdE9uTGFzdFdoaXRlc3BhY2UodGV4dCk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLnByZWZpeCArIG1hdGNoLndoaXRlc3BhY2UgOiB0ZXh0O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcGFyc2UtdG9vbC1jYWxsLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yLCBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgYXNTY2hlbWEgYXMgYXNTY2hlbWEzIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lIH0pO1xuICB9XG4gIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNjaGVtYSA9IGFzU2NoZW1hMyh0b29sMi5wYXJhbWV0ZXJzKTtcbiAgY29uc3QgcGFyc2VSZXN1bHQgPSB0b29sQ2FsbC5hcmdzLnRyaW0oKSA9PT0gXCJcIiA/IHNhZmVWYWxpZGF0ZVR5cGVzMyh7IHZhbHVlOiB7fSwgc2NoZW1hIH0pIDogc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiB0b29sQ2FsbC5hcmdzLCBzY2hlbWEgfSk7XG4gIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgIHRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRvb2xDYWxsLmFyZ3MsXG4gICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZSxcbiAgICBhcmdzOiBwYXJzZVJlc3VsdC52YWx1ZVxuICB9O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvdG8tcmVzcG9uc2UtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gIHRleHQgPSBcIlwiLFxuICB0b29scyxcbiAgdG9vbENhbGxzLFxuICB0b29sUmVzdWx0c1xufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dCB9LCAuLi50b29sQ2FsbHNdXG4gIH0pO1xuICBpZiAodG9vbFJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgIGNvbnRlbnQ6IHRvb2xSZXN1bHRzLm1hcCgodG9vbFJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xSZXN1bHQudG9vbE5hbWVdO1xuICAgICAgICByZXR1cm4gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudCkgIT0gbnVsbCA/IHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogdG9vbFJlc3VsdC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sUmVzdWx0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQodG9vbFJlc3VsdC5yZXN1bHQpLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZW50OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChcbiAgICAgICAgICAgIHRvb2xSZXN1bHQucmVzdWx0XG4gICAgICAgICAgKVxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiB0b29sUmVzdWx0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHRvb2xSZXN1bHQudG9vbE5hbWUsXG4gICAgICAgICAgcmVzdWx0OiB0b29sUmVzdWx0LnJlc3VsdFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlcztcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQzID0gY3JlYXRlSWRHZW5lcmF0b3IzKHsgcHJlZml4OiBcImFpdHh0XCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBtYXhBdXRvbWF0aWNSb3VuZHRyaXBzID0gMCxcbiAgbWF4VG9vbFJvdW5kdHJpcHMgPSBtYXhBdXRvbWF0aWNSb3VuZHRyaXBzLFxuICBtYXhTdGVwcyA9IG1heFRvb2xSb3VuZHRyaXBzICE9IG51bGwgPyBtYXhUb29sUm91bmR0cmlwcyArIDEgOiAxLFxuICBleHBlcmltZW50YWxfY29udGludWF0aW9uU3RlcHMsXG4gIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBjb250aW51ZVN0ZXBzID0gZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzICE9IG51bGwgPyBleHBlcmltZW50YWxfY29udGludWF0aW9uU3RlcHMgOiBmYWxzZSxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzOiBhY3RpdmVUb29scyxcbiAgX2ludGVybmFsOiB7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgfSA9IHt9LFxuICBvblN0ZXBGaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGlmIChtYXhTdGVwcyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm1heFN0ZXBzXCIsXG4gICAgICB2YWx1ZTogbWF4U3RlcHMsXG4gICAgICBtZXNzYWdlOiBcIm1heFN0ZXBzIG11c3QgYmUgYXQgbGVhc3QgMVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgdG9vbHNcbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tYXhTdGVwc1wiOiBtYXhTdGVwc1xuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIHZhciBfYTExLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCBtb2RlID0ge1xuICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlLCBhY3RpdmVUb29scyB9KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgbGV0IGN1cnJlbnRNb2RlbFJlc3BvbnNlO1xuICAgICAgbGV0IGN1cnJlbnRUb29sQ2FsbHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50VG9vbFJlc3VsdHMgPSBbXTtcbiAgICAgIGxldCBzdGVwQ291bnQgPSAwO1xuICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgbGV0IHRleHQgPSBcIlwiO1xuICAgICAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgICAgIGNvbnN0IHVzYWdlID0ge1xuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICB9O1xuICAgICAgbGV0IHN0ZXBUeXBlID0gXCJpbml0aWFsXCI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzdGVwQ291bnQgPT09IDEpIHtcbiAgICAgICAgICBpbml0aWFsUHJvbXB0LnR5cGUgPSBcIm1lc3NhZ2VzXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbXB0Rm9ybWF0ID0gc3RlcENvdW50ID09PSAwID8gaW5pdGlhbFByb21wdC50eXBlIDogXCJtZXNzYWdlc1wiO1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgdHlwZTogcHJvbXB0Rm9ybWF0LFxuICAgICAgICAgICAgc3lzdGVtOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBbLi4uaW5pdGlhbFByb21wdC5tZXNzYWdlcywgLi4ucmVzcG9uc2VNZXNzYWdlc11cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHsgaW5wdXQ6ICgpID0+IHByb21wdEZvcm1hdCB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hMTI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2ExMiA9IG1vZGUudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLm1hcCgodG9vbDIpID0+IEpTT04uc3RyaW5naWZ5KHRvb2wyKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sQ2hvaWNlXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBtb2RlLnRvb2xDaG9pY2UgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KG1vZGUudG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBzZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTIsIF9iMiwgX2MyLCBfZDIsIF9lMiwgX2YyO1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdDogcHJvbXB0Rm9ybWF0LFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IChfYjIgPSAoX2ExMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kMiA9IChfYzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYzIudGltZXN0YW1wKSAhPSBudWxsID8gX2QyIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2YyID0gKF9lMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lMi5tb2RlbElkKSAhPSBudWxsID8gX2YyIDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gcmVzdWx0LnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnRvb2xDYWxscylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJlc3VsdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShyZXN1bHQudG9vbENhbGxzKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbENhbGxzID0gKChfYTExID0gY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKSAhPSBudWxsID8gX2ExMSA6IFtdKS5tYXAoXG4gICAgICAgICAgKG1vZGVsVG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoeyB0b29sQ2FsbDogbW9kZWxUb29sQ2FsbCwgdG9vbHMgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzID0gdG9vbHMgPT0gbnVsbCA/IFtdIDogYXdhaXQgZXhlY3V0ZVRvb2xzKHtcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VycmVudFVzYWdlID0gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKFxuICAgICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlXG4gICAgICAgICk7XG4gICAgICAgIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgKz0gY3VycmVudFVzYWdlLmNvbXBsZXRpb25Ub2tlbnM7XG4gICAgICAgIHVzYWdlLnByb21wdFRva2VucyArPSBjdXJyZW50VXNhZ2UucHJvbXB0VG9rZW5zO1xuICAgICAgICB1c2FnZS50b3RhbFRva2VucyArPSBjdXJyZW50VXNhZ2UudG90YWxUb2tlbnM7XG4gICAgICAgIGxldCBuZXh0U3RlcFR5cGUgPSBcImRvbmVcIjtcbiAgICAgICAgaWYgKCsrc3RlcENvdW50IDwgbWF4U3RlcHMpIHtcbiAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24gPT09IFwibGVuZ3RoXCIgJiYgLy8gb25seSB1c2UgY29udGludWUgd2hlbiB0aGVyZSBhcmUgbm8gdG9vbCBjYWxsczpcbiAgICAgICAgICBjdXJyZW50VG9vbENhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJjb250aW51ZVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgICAgIGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoID4gMCAmJiAvLyBhbGwgY3VycmVudCB0b29sIGNhbGxzIGhhdmUgcmVzdWx0czpcbiAgICAgICAgICAgIGN1cnJlbnRUb29sUmVzdWx0cy5sZW5ndGggPT09IGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcInRvb2wtcmVzdWx0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVGV4dCA9IChfYiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHN0ZXBUZXh0TGVhZGluZ1doaXRlc3BhY2VUcmltbWVkID0gc3RlcFR5cGUgPT09IFwiY29udGludWVcIiAmJiAvLyBvbmx5IGZvciBjb250aW51ZSBzdGVwc1xuICAgICAgICB0ZXh0LnRyaW1FbmQoKSAhPT0gdGV4dCA/IG9yaWdpbmFsVGV4dC50cmltU3RhcnQoKSA6IG9yaWdpbmFsVGV4dDtcbiAgICAgICAgY29uc3Qgc3RlcFRleHQgPSBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIiA/IHJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlKHN0ZXBUZXh0TGVhZGluZ1doaXRlc3BhY2VUcmltbWVkKSA6IHN0ZXBUZXh0TGVhZGluZ1doaXRlc3BhY2VUcmltbWVkO1xuICAgICAgICB0ZXh0ID0gbmV4dFN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgfHwgc3RlcFR5cGUgPT09IFwiY29udGludWVcIiA/IHRleHQgKyBzdGVwVGV4dCA6IHN0ZXBUZXh0O1xuICAgICAgICBpZiAoc3RlcFR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gcmVzcG9uc2VNZXNzYWdlc1tyZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmICh0eXBlb2YgbGFzdE1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudCArPSBzdGVwVGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgLi4udG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgdG9vbHM6IHRvb2xzICE9IG51bGwgPyB0b29scyA6IHt9LFxuICAgICAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U3RlcFJlc3VsdCA9IHtcbiAgICAgICAgICBzdGVwVHlwZSxcbiAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0cyxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICB1c2FnZTogY3VycmVudFVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzOiBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgICAgcmVxdWVzdDogKF9jID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmVxdWVzdCkgIT0gbnVsbCA/IF9jIDoge30sXG4gICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgICAgaGVhZGVyczogKF9kID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5oZWFkZXJzLFxuICAgICAgICAgICAgLy8gZGVlcCBjbG9uZSBtc2dzIHRvIGF2b2lkIG11dGF0aW5nIHBhc3QgbWVzc2FnZXMgaW4gbXVsdGktc3RlcDpcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZXMpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgaXNDb250aW51ZWQ6IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiXG4gICAgICAgIH07XG4gICAgICAgIHN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgc3RlcFR5cGUgPSBuZXh0U3RlcFR5cGU7XG4gICAgICB9IHdoaWxlIChzdGVwVHlwZSAhPT0gXCJkb25lXCIpO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCh7XG4gICAgICAgIHRleHQsXG4gICAgICAgIHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscyxcbiAgICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0cyxcbiAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlLFxuICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgIHJlcXVlc3Q6IChfZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfZSA6IHt9LFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgIGhlYWRlcnM6IChfZiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2YuaGVhZGVycyxcbiAgICAgICAgICBtZXNzYWdlczogcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgIHN0ZXBzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChhc3luYyAodG9vbENhbGwpID0+IHtcbiAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhlY3V0ZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLm5hbWVcIjogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICBcImFpLnRvb2xDYWxsLmFyZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxsLmFyZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgdHJhY2VyLFxuICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzLCB7IGFib3J0U2lnbmFsIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLnJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0MilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICByZXN1bHRcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIHRvb2xSZXN1bHRzLmZpbHRlcihcbiAgICAocmVzdWx0KSA9PiByZXN1bHQgIT0gbnVsbFxuICApO1xufVxudmFyIERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy50b29sQ2FsbHMgPSBvcHRpb25zLnRvb2xDYWxscztcbiAgICB0aGlzLnRvb2xSZXN1bHRzID0gb3B0aW9ucy50b29sUmVzdWx0cztcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVxdWVzdCA9IG9wdGlvbnMucmVxdWVzdDtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJlc3BvbnNlTWVzc2FnZXMgPSBvcHRpb25zLnJlc3BvbnNlTWVzc2FnZXM7XG4gICAgdGhpcy5yb3VuZHRyaXBzID0gb3B0aW9ucy5zdGVwcztcbiAgICB0aGlzLnN0ZXBzID0gb3B0aW9ucy5zdGVwcztcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSB7XG4gICAgICBoZWFkZXJzOiBvcHRpb25zLnJlc3BvbnNlLmhlYWRlcnNcbiAgICB9O1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVRleHQgPSBnZW5lcmF0ZVRleHQ7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2NyZWF0ZS1zdGl0Y2hhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpIHtcbiAgbGV0IGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICBsZXQgY29udHJvbGxlciA9IG51bGw7XG4gIGxldCBpc0Nsb3NlZCA9IGZhbHNlO1xuICBjb25zdCBwcm9jZXNzUHVsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaW5uZXJTdHJlYW1SZWFkZXJzWzBdLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhd2FpdCBwcm9jZXNzUHVsbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgaWYgKGlzQ2xvc2VkICYmIGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydChjb250cm9sbGVyUGFyYW0pIHtcbiAgICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJQYXJhbTtcbiAgICAgIH0sXG4gICAgICBwdWxsOiBwcm9jZXNzUHVsbCxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgaW5uZXJTdHJlYW1SZWFkZXJzKSB7XG4gICAgICAgICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICAgICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSksXG4gICAgYWRkU3RyZWFtOiAoaW5uZXJTdHJlYW0pID0+IHtcbiAgICAgIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGlubmVyIHN0cmVhbTogb3V0ZXIgc3RyZWFtIGlzIGNsb3NlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5wdXNoKGlubmVyU3RyZWFtLmdldFJlYWRlcigpKTtcbiAgICB9LFxuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvbWVyZ2Utc3RyZWFtcy50c1xuZnVuY3Rpb24gbWVyZ2VTdHJlYW1zKHN0cmVhbTEsIHN0cmVhbTIpIHtcbiAgY29uc3QgcmVhZGVyMSA9IHN0cmVhbTEuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHJlYWRlcjIgPSBzdHJlYW0yLmdldFJlYWRlcigpO1xuICBsZXQgbGFzdFJlYWQxID0gdm9pZCAwO1xuICBsZXQgbGFzdFJlYWQyID0gdm9pZCAwO1xuICBsZXQgc3RyZWFtMURvbmUgPSBmYWxzZTtcbiAgbGV0IHN0cmVhbTJEb25lID0gZmFsc2U7XG4gIGFzeW5jIGZ1bmN0aW9uIHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGxhc3RSZWFkMSA9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZWFkMSA9IHJlYWRlcjEucmVhZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGFzdFJlYWQxO1xuICAgICAgbGFzdFJlYWQxID0gdm9pZCAwO1xuICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGxhc3RSZWFkMiA9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZWFkMiA9IHJlYWRlcjIucmVhZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGFzdFJlYWQyO1xuICAgICAgbGFzdFJlYWQyID0gdm9pZCAwO1xuICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN0cmVhbTFEb25lKSB7XG4gICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTIoY29udHJvbGxlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0yRG9uZSkge1xuICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFJlYWQxID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0UmVhZDEgPSByZWFkZXIxLnJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFJlYWQyID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0UmVhZDIgPSByZWFkZXIyLnJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHJlc3VsdCwgcmVhZGVyIH0gPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgIGxhc3RSZWFkMS50aGVuKChyZXN1bHQyKSA9PiAoeyByZXN1bHQ6IHJlc3VsdDIsIHJlYWRlcjogcmVhZGVyMSB9KSksXG4gICAgICAgICAgbGFzdFJlYWQyLnRoZW4oKHJlc3VsdDIpID0+ICh7IHJlc3VsdDogcmVzdWx0MiwgcmVhZGVyOiByZWFkZXIyIH0pKVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkZXIgPT09IHJlYWRlcjEpIHtcbiAgICAgICAgICBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMihjb250cm9sbGVyKTtcbiAgICAgICAgICAgIHN0cmVhbTFEb25lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFJlYWQyID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgc3RyZWFtMkRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTEoY29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICAgIHJlYWRlcjEuY2FuY2VsKCk7XG4gICAgICByZWFkZXIyLmNhbmNlbCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9ydW4tdG9vbHMtdHJhbnNmb3JtYXRpb24udHNcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuZnVuY3Rpb24gcnVuVG9vbHNUcmFuc2Zvcm1hdGlvbih7XG4gIHRvb2xzLFxuICBnZW5lcmF0b3JTdHJlYW0sXG4gIHRvb2xDYWxsU3RyZWFtaW5nLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgYWJvcnRTaWduYWxcbn0pIHtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZVRvb2xDYWxscyA9IHt9O1xuICBjb25zdCBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGxldCBmaW5pc2hDaHVuayA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gYXR0ZW1wdENsb3NlKCkge1xuICAgIGlmIChjYW5DbG9zZSAmJiBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLnNpemUgPT09IDApIHtcbiAgICAgIGlmIChmaW5pc2hDaHVuayAhPSBudWxsKSB7XG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKGZpbmlzaENodW5rKTtcbiAgICAgIH1cbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICBpZiAodG9vbENhbGxTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGlmICghYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFjdGl2ZVRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1kZWx0YVwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IGNodW5rLmFyZ3NUZXh0RGVsdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29sc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgaWYgKHRvb2wyLmV4ZWN1dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uSWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5hcmdzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4gdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzLCB7IGFib3J0U2lnbmFsIH0pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICBmaW5pc2hDaHVuayA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjaHVuay5sb2dwcm9icyxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UoY2h1bmsudXNhZ2UpLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goKSB7XG4gICAgICBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZW5lcmF0b3JTdHJlYW0ucGlwZVRocm91Z2goZm9yd2FyZFN0cmVhbSkucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDQgPSBjcmVhdGVJZEdlbmVyYXRvcjQoeyBwcmVmaXg6IFwiYWl0eHRcIiwgc2l6ZTogMjQgfSk7XG5hc3luYyBmdW5jdGlvbiBzdHJlYW1UZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBtYXhUb29sUm91bmR0cmlwcyA9IDAsXG4gIG1heFN0ZXBzID0gbWF4VG9vbFJvdW5kdHJpcHMgIT0gbnVsbCA/IG1heFRvb2xSb3VuZHRyaXBzICsgMSA6IDEsXG4gIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBjb250aW51ZVN0ZXBzID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIGV4cGVyaW1lbnRhbF90b29sQ2FsbFN0cmVhbWluZzogdG9vbENhbGxTdHJlYW1pbmcgPSBmYWxzZSxcbiAgZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzOiBhY3RpdmVUb29scyxcbiAgb25DaHVuayxcbiAgb25GaW5pc2gsXG4gIG9uU3RlcEZpbmlzaCxcbiAgX2ludGVybmFsOiB7XG4gICAgbm93OiBub3cyID0gbm93LFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkNCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgaWYgKG1heFN0ZXBzIDwgMSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwibWF4U3RlcHNcIixcbiAgICAgIHZhbHVlOiBtYXhTdGVwcyxcbiAgICAgIG1lc3NhZ2U6IFwibWF4U3RlcHMgbXVzdCBiZSBhdCBsZWFzdCAxXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5zZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgY29uc3QgaW5pdGlhbFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgdG9vbHNcbiAgfSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnN0cmVhbVRleHRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXCJhaS5zZXR0aW5ncy5tYXhTdGVwc1wiOiBtYXhTdGVwc1xuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3Qgc3RhcnRTdGVwID0gYXN5bmMgKHtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9tcHRGb3JtYXQgPSByZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCA9PT0gMCA/IGluaXRpYWxQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIjtcbiAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgIHN5c3RlbTogaW5pdGlhbFByb21wdC5zeXN0ZW0sXG4gICAgICAgICAgICBtZXNzYWdlczogWy4uLmluaXRpYWxQcm9tcHQubWVzc2FnZXMsIC4uLnJlc3BvbnNlTWVzc2FnZXNdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UsIGFjdGl2ZVRvb2xzIH0pXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXN1bHQ6IHsgc3RyZWFtOiBzdHJlYW0yLCB3YXJuaW5nczogd2FybmluZ3MyLCByYXdSZXNwb25zZTogcmF3UmVzcG9uc2UyLCByZXF1ZXN0OiByZXF1ZXN0MiB9LFxuICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBzdGFydFRpbWVzdGFtcE1zMlxuICAgICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBwcm9tcHRGb3JtYXRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2ExMSA9IG1vZGUudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLm1hcCgodG9vbDIpID0+IEpTT04uc3RyaW5naWZ5KHRvb2wyKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sQ2hvaWNlXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBtb2RlLnRvb2xDaG9pY2UgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KG1vZGUudG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5zdG9wX3NlcXVlbmNlc1wiOiBzZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMykgPT4gKHtcbiAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICAvLyBnZXQgYmVmb3JlIHRoZSBjYWxsXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMyxcbiAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdDogcHJvbXB0Rm9ybWF0LFxuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBzdHJlYW06IHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW0yLFxuICAgICAgICAgICAgICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5nczIsXG4gICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0MiAhPSBudWxsID8gcmVxdWVzdDIgOiB7fSxcbiAgICAgICAgICAgIHJhd1Jlc3BvbnNlOiByYXdSZXNwb25zZTJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBzdGFydFRpbWVzdGFtcE1zMlxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVzdWx0OiB7IHN0cmVhbSwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgfSA9IGF3YWl0IHN0YXJ0U3RlcCh7IHJlc3BvbnNlTWVzc2FnZXM6IFtdIH0pO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCh7XG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgd2FybmluZ3MsXG4gICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBvbkNodW5rLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25TdGVwRmluaXNoLFxuICAgICAgICByb290U3BhbixcbiAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICAgIG1heFN0ZXBzLFxuICAgICAgICBjb250aW51ZVN0ZXBzLFxuICAgICAgICBzdGFydFN0ZXAsXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgIG5vdzogbm93MixcbiAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgICAgICB0b29sc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0cmVhbSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZSxcbiAgICByZXF1ZXN0LFxuICAgIG9uQ2h1bmssXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIHJvb3RTcGFuLFxuICAgIGRvU3RyZWFtU3BhbixcbiAgICB0ZWxlbWV0cnksXG4gICAgc3RhcnRUaW1lc3RhbXBNcyxcbiAgICBtYXhTdGVwcyxcbiAgICBjb250aW51ZVN0ZXBzLFxuICAgIHN0YXJ0U3RlcCxcbiAgICBtb2RlbElkLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICB0b29sc1xuICB9KSB7XG4gICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSByYXdSZXNwb25zZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVVc2FnZSwgcHJvbWlzZTogdXNhZ2VQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlRmluaXNoUmVhc29uLCBwcm9taXNlOiBmaW5pc2hSZWFzb25Qcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gZmluaXNoUmVhc29uUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUZXh0LCBwcm9taXNlOiB0ZXh0UHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0UHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUb29sQ2FsbHMsIHByb21pc2U6IHRvb2xDYWxsc1Byb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50b29sQ2FsbHMgPSB0b29sQ2FsbHNQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZVRvb2xSZXN1bHRzLCBwcm9taXNlOiB0b29sUmVzdWx0c1Byb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50b29sUmVzdWx0cyA9IHRvb2xSZXN1bHRzUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVTdGVwcywgcHJvbWlzZTogc3RlcHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMuc3RlcHMgPSBzdGVwc1Byb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVzb2x2ZTogcmVzb2x2ZVByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICBwcm9taXNlOiBwcm92aWRlck1ldGFkYXRhUHJvbWlzZVxuICAgIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBwcm92aWRlck1ldGFkYXRhUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVSZXF1ZXN0LCBwcm9taXNlOiByZXF1ZXN0UHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0UHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVSZXNwb25zZSwgcHJvbWlzZTogcmVzcG9uc2VQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZVByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVzb2x2ZTogcmVzb2x2ZVJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICBwcm9taXNlOiByZXNwb25zZU1lc3NhZ2VzUHJvbWlzZVxuICAgIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMucmVzcG9uc2VNZXNzYWdlcyA9IHJlc3BvbnNlTWVzc2FnZXNQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0cmVhbTogc3RpdGNoYWJsZVN0cmVhbSxcbiAgICAgIGFkZFN0cmVhbSxcbiAgICAgIGNsb3NlOiBjbG9zZVN0aXRjaGFibGVTdHJlYW1cbiAgICB9ID0gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtO1xuICAgIGNvbnN0IHN0ZXBSZXN1bHRzID0gW107XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gYWRkU3RlcFN0cmVhbSh7XG4gICAgICBzdHJlYW06IHN0cmVhbTIsXG4gICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgcmVzcG9uc2VNZXNzYWdlcyxcbiAgICAgIHVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICB9LFxuICAgICAgc3RlcFR5cGUsXG4gICAgICBwcmV2aW91c1N0ZXBUZXh0ID0gXCJcIixcbiAgICAgIHN0ZXBSZXF1ZXN0LFxuICAgICAgaGFzTGVhZGluZ1doaXRlc3BhY2VcbiAgICB9KSB7XG4gICAgICBjb25zdCBzdGVwVG9vbENhbGxzID0gW107XG4gICAgICBjb25zdCBzdGVwVG9vbFJlc3VsdHMgPSBbXTtcbiAgICAgIGxldCBzdGVwRmluaXNoUmVhc29uID0gXCJ1bmtub3duXCI7XG4gICAgICBsZXQgc3RlcFVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICB9O1xuICAgICAgbGV0IHN0ZXBQcm92aWRlck1ldGFkYXRhO1xuICAgICAgbGV0IHN0ZXBGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgIGxldCBzdGVwVGV4dCA9IFwiXCI7XG4gICAgICBsZXQgZnVsbFN0ZXBUZXh0ID0gc3RlcFR5cGUgPT09IFwiY29udGludWVcIiA/IHByZXZpb3VzU3RlcFRleHQgOiBcIlwiO1xuICAgICAgbGV0IHN0ZXBMb2dQcm9icztcbiAgICAgIGxldCBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgIG1vZGVsSWRcbiAgICAgIH07XG4gICAgICBsZXQgY2h1bmtCdWZmZXIgPSBcIlwiO1xuICAgICAgbGV0IGNodW5rVGV4dFB1Ymxpc2hlZCA9IGZhbHNlO1xuICAgICAgbGV0IGluV2hpdGVzcGFjZVByZWZpeCA9IHRydWU7XG4gICAgICBsZXQgaGFzV2hpdGVzcGFjZVN1ZmZpeCA9IGZhbHNlO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgIGNodW5rXG4gICAgICB9KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIHN0ZXBUZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgZnVsbFN0ZXBUZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgY2h1bmtUZXh0UHVibGlzaGVkID0gdHJ1ZTtcbiAgICAgICAgaGFzV2hpdGVzcGFjZVN1ZmZpeCA9IGNodW5rLnRleHREZWx0YS50cmltRW5kKCkgIT09IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuayB9KSk7XG4gICAgICB9XG4gICAgICBhZGRTdHJlYW0oXG4gICAgICAgIHN0cmVhbTIucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYztcbiAgICAgICAgICAgICAgaWYgKHN0ZXBGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBzdGVwRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmssXG4gICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIgJiYgY2h1bmsudGV4dERlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlmIChjb250aW51ZVN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRDaHVua1RleHQgPSBpbldoaXRlc3BhY2VQcmVmaXggJiYgaGFzTGVhZGluZ1doaXRlc3BhY2UgPyBjaHVuay50ZXh0RGVsdGEudHJpbVN0YXJ0KCkgOiBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmltbWVkQ2h1bmtUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluV2hpdGVzcGFjZVByZWZpeCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjaHVua0J1ZmZlciArPSB0cmltbWVkQ2h1bmtUZXh0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdCA9IHNwbGl0T25MYXN0V2hpdGVzcGFjZShjaHVua0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgPSBzcGxpdC5zdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogc3BsaXQucHJlZml4ICsgc3BsaXQud2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciwgY2h1bmsgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgc3RlcFRvb2xSZXN1bHRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuayB9KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIHN0ZXBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IChfYTExID0gY2h1bmsuaWQpICE9IG51bGwgPyBfYTExIDogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iIDogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jIDogc3RlcFJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICBzdGVwVXNhZ2UgPSBjaHVuay51c2FnZTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICBzdGVwUHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgc3RlcExvZ1Byb2JzID0gY2h1bmsubG9ncHJvYnM7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmluaXNoID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpbmlzaFwiKTtcbiAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpbmlzaFwiOiBtc1RvRmluaXNoLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmF2Z0NvbXBsZXRpb25Ub2tlbnNQZXJTZWNvbmRcIjogMWUzICogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgLyBtc1RvRmluaXNoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB2YXIgX2ExMTtcbiAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxsc0pzb24gPSBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgbGV0IG5leHRTdGVwVHlwZSA9IFwiZG9uZVwiO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFN0ZXAgKyAxIDwgbWF4U3RlcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBzdGVwRmluaXNoUmVhc29uID09PSBcImxlbmd0aFwiICYmIC8vIG9ubHkgdXNlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIG5vIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICAgICAgICBzdGVwVG9vbFJlc3VsdHMubGVuZ3RoID09PSBzdGVwVG9vbENhbGxzLmxlbmd0aFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJ0b29sLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBjaHVua0J1ZmZlci5sZW5ndGggPiAwICYmIChuZXh0U3RlcFR5cGUgIT09IFwiY29udGludWVcIiB8fCAvLyB3aGVuIHRoZSBuZXh0IHN0ZXAgaXMgYSByZWd1bGFyIHN0ZXAsIHB1Ymxpc2ggdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICBzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiICYmICFjaHVua1RleHRQdWJsaXNoZWQpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogY2h1bmtCdWZmZXJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaHVua0J1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogc3RlcFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gc3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtzdGVwRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1maW5pc2hcIixcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0NvbnRpbnVlZDogbmV4dFN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSByZXNwb25zZU1lc3NhZ2VzW3Jlc3BvbnNlTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0TWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZS5jb250ZW50ICs9IHN0ZXBUZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZS5jb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAuLi50b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHRvb2xzICE9IG51bGwgPyB0b29scyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IHN0ZXBUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBzdGVwVG9vbFJlc3VsdHNcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3RlcFJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdGVwVHlwZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IHN0ZXBUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHN0ZXBUb29sUmVzdWx0cyxcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHN0ZXBVc2FnZSxcbiAgICAgICAgICAgICAgICB3YXJuaW5nczogc2VsZi53YXJuaW5ncyxcbiAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJhd1Jlc3BvbnNlOiBzZWxmLnJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiAoX2ExMSA9IHNlbGYucmF3UmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAvLyBkZWVwIGNsb25lIG1zZ3MgdG8gYXZvaWQgbXV0YXRpbmcgcGFzdCBtZXNzYWdlcyBpbiBtdWx0aS1zdGVwOlxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2VNZXNzYWdlcykpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgaXNDb250aW51ZWQ6IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN0ZXBSZXN1bHRzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRVc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyArIHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogdXNhZ2UuY29tcGxldGlvblRva2VucyArIHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiB1c2FnZS50b3RhbFRva2VucyArIHN0ZXBVc2FnZS50b3RhbFRva2Vuc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAobmV4dFN0ZXBUeXBlICE9PSBcImRvbmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMyxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IHN0YXJ0VGltZXN0YW1wMlxuICAgICAgICAgICAgICAgIH0gPSBhd2FpdCBzdGFydFN0ZXAoeyByZXNwb25zZU1lc3NhZ2VzIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYud2FybmluZ3MgPSByZXN1bHQud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgc2VsZi5yYXdSZXNwb25zZSA9IHJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBhZGRTdGVwU3RyZWFtKHtcbiAgICAgICAgICAgICAgICAgIHN0cmVhbTogcmVzdWx0LnN0cmVhbSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wOiBzdGFydFRpbWVzdGFtcDIsXG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjMsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogY3VycmVudFN0ZXAgKyAxLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlLFxuICAgICAgICAgICAgICAgICAgc3RlcFR5cGU6IG5leHRTdGVwVHlwZSxcbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3RlcFRleHQ6IGZ1bGxTdGVwVGV4dCxcbiAgICAgICAgICAgICAgICAgIHN0ZXBSZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgIGhhc0xlYWRpbmdXaGl0ZXNwYWNlOiBoYXNXaGl0ZXNwYWNlU3VmZml4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbG9zZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBmdWxsU3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHN0ZXBUb29sQ2FsbHNKc29uXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjb21iaW5lZFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY29tYmluZWRVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IGZ1bGxTdGVwVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHN0ZXBUb29sQ2FsbHNKc29uXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVVzYWdlKGNvbWJpbmVkVXNhZ2UpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaW5pc2hSZWFzb24oc3RlcEZpbmlzaFJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRleHQoZnVsbFN0ZXBUZXh0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlVG9vbENhbGxzKHN0ZXBUb29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm92aWRlck1ldGFkYXRhKHN0ZXBQcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlVG9vbFJlc3VsdHMoc3RlcFRvb2xSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUmVxdWVzdChzdGVwUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlU3RlcHMoc3RlcFJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVSZXNwb25zZU1lc3NhZ2VzKHJlc3BvbnNlTWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlLFxuICAgICAgICAgICAgICAgICAgdGV4dDogZnVsbFN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgICAgLy8gVGhlIHRvb2wgcmVzdWx0cyBhcmUgaW5mZXJyZWQgYXMgYSBuZXZlcltdIHR5cGUsIGJlY2F1c2UgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIGFuZCB0aGUgZXhlY3V0ZSBtZXRob2Qgd2l0aCBhbiBpbmZlcnJlZCByZXN1bHQgdHlwZSBpc1xuICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYXMgd2VsbC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gY2FzdCB0aGUgdG9vbFJlc3VsdHMgdG8gYW55LlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIHR5cGUgZXhwb3NlZCB0byB0aGUgdXNlcnMgd2lsbCBiZSBjb3JyZWN0bHkgaW5mZXJyZWQuXG4gICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcFRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdDogc3RlcFJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmF3UmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhd1Jlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiByZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBzdGVwczogc3RlcFJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgYWRkU3RlcFN0cmVhbSh7XG4gICAgICBzdHJlYW0sXG4gICAgICBzdGFydFRpbWVzdGFtcDogc3RhcnRUaW1lc3RhbXBNcyxcbiAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgcmVzcG9uc2VNZXNzYWdlczogW10sXG4gICAgICB1c2FnZTogdm9pZCAwLFxuICAgICAgc3RlcFR5cGU6IFwiaW5pdGlhbFwiLFxuICAgICAgc3RlcFJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICBoYXNMZWFkaW5nV2hpdGVzcGFjZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgU3BsaXQgb3V0IGEgbmV3IHN0cmVhbSBmcm9tIHRoZSBvcmlnaW5hbCBzdHJlYW0uXG4gIFRoZSBvcmlnaW5hbCBzdHJlYW0gaXMgcmVwbGFjZWQgdG8gYWxsb3cgZm9yIGZ1cnRoZXIgc3BsaXR0aW5nLFxuICBzaW5jZSB3ZSBkbyBub3Qga25vdyBob3cgbWFueSB0aW1lcyB0aGUgc3RyZWFtIHdpbGwgYmUgc3BsaXQuXG4gIFxuICBOb3RlOiB0aGlzIGxlYWRzIHRvIGJ1ZmZlcmluZyB0aGUgc3RyZWFtIGNvbnRlbnQgb24gdGhlIHNlcnZlci5cbiAgSG93ZXZlciwgdGhlIExMTSByZXN1bHRzIGFyZSBleHBlY3RlZCB0byBiZSBzbWFsbCBlbm91Z2ggdG8gbm90IGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgdGVlU3RyZWFtKCkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHRoaXMub3JpZ2luYWxTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbTI7XG4gICAgcmV0dXJuIHN0cmVhbTE7XG4gIH1cbiAgZ2V0IHRleHRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNodW5rLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdG9BSVN0cmVhbShjYWxsYmFja3MgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnRvRGF0YVN0cmVhbUludGVybmFsKHsgY2FsbGJhY2tzIH0pO1xuICB9XG4gIHRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICBjYWxsYmFja3MgPSB7fSxcbiAgICBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTMgPSAoKSA9PiBcIlwiLFxuICAgIC8vIG1hc2sgZXJyb3IgbWVzc2FnZXMgZm9yIHNhZmV0eSBieSBkZWZhdWx0XG4gICAgc2VuZFVzYWdlID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgICBjb25zdCBjYWxsYmFja1RyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IHRleHREZWx0YSA9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gdGV4dERlbHRhO1xuICAgICAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKHRleHREZWx0YSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQpXG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KHRleHREZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwpXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdHJlYW1QYXJ0c1RyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBjaHVuay50ZXh0RGVsdGEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfY2FsbF9kZWx0YVwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBjaHVuay5hcmdzVGV4dERlbHRhXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9jYWxsXCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBjaHVuay5hcmdzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX3Jlc3VsdFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGNodW5rLnJlc3VsdFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgZ2V0RXJyb3JNZXNzYWdlMyhjaHVuay5lcnJvcikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJzdGVwLWZpbmlzaFwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJmaW5pc2hfc3RlcFwiLCB7XG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHNlbmRVc2FnZSA/IHtcbiAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogY2h1bmsudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaXNDb250aW51ZWQ6IGNodW5rLmlzQ29udGludWVkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZmluaXNoX21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzZW5kVXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5mdWxsU3RyZWFtLnBpcGVUaHJvdWdoKGNhbGxiYWNrVHJhbnNmb3JtZXIpLnBpcGVUaHJvdWdoKHN0cmVhbVBhcnRzVHJhbnNmb3JtZXIpLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKTtcbiAgfVxuICBwaXBlQUlTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KTtcbiAgfVxuICBwaXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJpbml0XCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaW5pdCA6IHtcbiAgICAgIGhlYWRlcnM6IFwiaGVhZGVyc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmhlYWRlcnMgOiB2b2lkIDAsXG4gICAgICBzdGF0dXM6IFwic3RhdHVzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzIDogdm9pZCAwLFxuICAgICAgc3RhdHVzVGV4dDogXCJzdGF0dXNUZXh0XCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6IHZvaWQgMFxuICAgIH07XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiZGF0YVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmRhdGEgOiB2b2lkIDA7XG4gICAgY29uc3QgZ2V0RXJyb3JNZXNzYWdlMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiZ2V0RXJyb3JNZXNzYWdlXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2V0RXJyb3JNZXNzYWdlIDogdm9pZCAwO1xuICAgIGNvbnN0IHNlbmRVc2FnZSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwic2VuZFVzYWdlXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VuZFVzYWdlIDogdm9pZCAwO1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgfSksXG4gICAgICBzdHJlYW06IHRoaXMudG9EYXRhU3RyZWFtKHsgZGF0YSwgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2UzLCBzZW5kVXNhZ2UgfSlcbiAgICB9KTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXM6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbiAgdG9BSVN0cmVhbVJlc3BvbnNlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50b0RhdGFTdHJlYW1SZXNwb25zZShvcHRpb25zKTtcbiAgfVxuICB0b0RhdGFTdHJlYW0ob3B0aW9ucykge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMudG9EYXRhU3RyZWFtSW50ZXJuYWwoe1xuICAgICAgZ2V0RXJyb3JNZXNzYWdlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldEVycm9yTWVzc2FnZSxcbiAgICAgIHNlbmRVc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZW5kVXNhZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgPyBtZXJnZVN0cmVhbXMob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhLnN0cmVhbSwgc3RyZWFtKSA6IHN0cmVhbTtcbiAgfVxuICB0b0RhdGFTdHJlYW1SZXNwb25zZShvcHRpb25zKSB7XG4gICAgdmFyIF9hMTE7XG4gICAgY29uc3QgaW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiaW5pdFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmluaXQgOiB7XG4gICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogdm9pZCAwLFxuICAgICAgc3RhdHVzOiBcInN0YXR1c1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1c1RleHQ6IFwic3RhdHVzVGV4dFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImRhdGFcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kYXRhIDogdm9pZCAwO1xuICAgIGNvbnN0IGdldEVycm9yTWVzc2FnZTMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImdldEVycm9yTWVzc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmdldEVycm9yTWVzc2FnZSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZW5kVXNhZ2UgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcInNlbmRVc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlbmRVc2FnZSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgdGhpcy50b0RhdGFTdHJlYW0oeyBkYXRhLCBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTMsIHNlbmRVc2FnZSB9KSxcbiAgICAgIHtcbiAgICAgICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTExO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX3N0cmVhbVRleHQgPSBzdHJlYW1UZXh0O1xuXG4vLyBjb3JlL21pZGRsZXdhcmUvd3JhcC1sYW5ndWFnZS1tb2RlbC50c1xudmFyIGV4cGVyaW1lbnRhbF93cmFwTGFuZ3VhZ2VNb2RlbCA9ICh7XG4gIG1vZGVsLFxuICBtaWRkbGV3YXJlOiB7IHRyYW5zZm9ybVBhcmFtcywgd3JhcEdlbmVyYXRlLCB3cmFwU3RyZWFtIH0sXG4gIG1vZGVsSWQsXG4gIHByb3ZpZGVySWRcbn0pID0+IHtcbiAgYXN5bmMgZnVuY3Rpb24gZG9UcmFuc2Zvcm0oe1xuICAgIHBhcmFtcyxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zID8gYXdhaXQgdHJhbnNmb3JtUGFyYW1zKHsgcGFyYW1zLCB0eXBlIH0pIDogcGFyYW1zO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjFcIixcbiAgICBwcm92aWRlcjogcHJvdmlkZXJJZCAhPSBudWxsID8gcHJvdmlkZXJJZCA6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsSWQgIT0gbnVsbCA/IG1vZGVsSWQgOiBtb2RlbC5tb2RlbElkLFxuICAgIGRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTogbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlLFxuICAgIHN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICBzdXBwb3J0c1VybDogbW9kZWwuc3VwcG9ydHNVcmwsXG4gICAgc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0czogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7IGRvR2VuZXJhdGUsIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9HZW5lcmF0ZSgpO1xuICAgIH0sXG4gICAgYXN5bmMgZG9TdHJlYW0ocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zLCB0eXBlOiBcInN0cmVhbVwiIH0pO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcFN0cmVhbSA/IHdyYXBTdHJlYW0oeyBkb1N0cmVhbSwgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcywgbW9kZWwgfSkgOiBkb1N0cmVhbSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIGNvcmUvcmVnaXN0cnkvY3VzdG9tLXByb3ZpZGVyLnRzXG5pbXBvcnQgeyBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9jdXN0b21Qcm92aWRlcih7XG4gIGxhbmd1YWdlTW9kZWxzLFxuICB0ZXh0RW1iZWRkaW5nTW9kZWxzLFxuICBmYWxsYmFja1Byb3ZpZGVyXG59KSB7XG4gIHJldHVybiB7XG4gICAgbGFuZ3VhZ2VNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAobGFuZ3VhZ2VNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIGxhbmd1YWdlTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmxhbmd1YWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgdGV4dEVtYmVkZGluZ01vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmICh0ZXh0RW1iZWRkaW5nTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiB0ZXh0RW1iZWRkaW5nTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiB0ZXh0RW1iZWRkaW5nTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIudGV4dEVtYmVkZGluZ01vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcInRleHRFbWJlZGRpbmdNb2RlbFwiIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gY29yZS9yZWdpc3RyeS9uby1zdWNoLXByb3ZpZGVyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMSwgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTEwID0gXCJBSV9Ob1N1Y2hQcm92aWRlckVycm9yXCI7XG52YXIgbWFya2VyMTAgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xudmFyIE5vU3VjaFByb3ZpZGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIE5vU3VjaE1vZGVsRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIHByb3ZpZGVySWQsXG4gICAgYXZhaWxhYmxlUHJvdmlkZXJzLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCBwcm92aWRlcjogJHtwcm92aWRlcklkfSAoYXZhaWxhYmxlIHByb3ZpZGVyczogJHthdmFpbGFibGVQcm92aWRlcnMuam9pbigpfSlgXG4gIH0pIHtcbiAgICBzdXBlcih7IGVycm9yTmFtZTogbmFtZTEwLCBtb2RlbElkLCBtb2RlbFR5cGUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICB0aGlzLmF2YWlsYWJsZVByb3ZpZGVycyA9IGF2YWlsYWJsZVByb3ZpZGVycztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTEuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzTm9TdWNoUHJvdmlkZXJFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMCAmJiB0eXBlb2YgZXJyb3IucHJvdmlkZXJJZCA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KGVycm9yLmF2YWlsYWJsZVByb3ZpZGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsVHlwZTogdGhpcy5tb2RlbFR5cGUsXG4gICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsXG4gICAgICBhdmFpbGFibGVQcm92aWRlcnM6IHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzXG4gICAgfTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gY29yZS9yZWdpc3RyeS9wcm92aWRlci1yZWdpc3RyeS50c1xuaW1wb3J0IHsgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeShwcm92aWRlcnMpIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoKTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgZXhwZXJpbWVudGFsX2NyZWF0ZU1vZGVsUmVnaXN0cnkgPSBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeTtcbnZhciBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcm92aWRlcnMgPSB7fTtcbiAgfVxuICByZWdpc3RlclByb3ZpZGVyKHtcbiAgICBpZCxcbiAgICBwcm92aWRlclxuICB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnNbaWRdID0gcHJvdmlkZXI7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoaWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW2lkXTtcbiAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaFByb3ZpZGVyRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIixcbiAgICAgICAgcHJvdmlkZXJJZDogaWQsXG4gICAgICAgIGF2YWlsYWJsZVByb3ZpZGVyczogT2JqZWN0LmtleXModGhpcy5wcm92aWRlcnMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xuICB9XG4gIHNwbGl0SWQoaWQsIG1vZGVsVHlwZSkge1xuICAgIGNvbnN0IGluZGV4ID0gaWQuaW5kZXhPZihcIjpcIik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZSxcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgJHttb2RlbFR5cGV9IGlkIGZvciByZWdpc3RyeTogJHtpZH0gKG11c3QgYmUgaW4gdGhlIGZvcm1hdCBcInByb3ZpZGVySWQ6bW9kZWxJZFwiKWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyAxKV07XG4gIH1cbiAgbGFuZ3VhZ2VNb2RlbChpZCkge1xuICAgIHZhciBfYTExLCBfYjtcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwibGFuZ3VhZ2VNb2RlbFwiKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYiA9IChfYTExID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKSkubGFuZ3VhZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2ExMSwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGV4dEVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTEsIF9iLCBfYztcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwidGV4dEVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYyA9IChfYTExID0gcHJvdmlkZXIudGV4dEVtYmVkZGluZ01vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKSkgIT0gbnVsbCA/IF9jIDogXCJ0ZXh0RW1iZWRkaW5nXCIgaW4gcHJvdmlkZXIgPyAoX2IgPSBwcm92aWRlci50ZXh0RW1iZWRkaW5nKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChwcm92aWRlciwgbW9kZWxJZCkgOiB2b2lkIDA7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgdGV4dEVtYmVkZGluZ01vZGVsYCBpbnN0ZWFkLlxuICAgKi9cbiAgdGV4dEVtYmVkZGluZyhpZCkge1xuICAgIHJldHVybiB0aGlzLnRleHRFbWJlZGRpbmdNb2RlbChpZCk7XG4gIH1cbn07XG5cbi8vIGNvcmUvdG9vbC90b29sLnRzXG5mdW5jdGlvbiB0b29sKHRvb2wyKSB7XG4gIHJldHVybiB0b29sMjtcbn1cblxuLy8gY29yZS91dGlsL2Nvc2luZS1zaW1pbGFyaXR5LnRzXG5mdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBWZWN0b3JzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggKHZlY3RvcjE6ICR7dmVjdG9yMS5sZW5ndGh9IGVsZW1lbnRzLCB2ZWN0b3IyOiAke3ZlY3RvcjIubGVuZ3RofSBlbGVtZW50cylgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSAvIChtYWduaXR1ZGUodmVjdG9yMSkgKiBtYWduaXR1ZGUodmVjdG9yMikpO1xufVxuZnVuY3Rpb24gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIHJldHVybiB2ZWN0b3IxLnJlZHVjZShcbiAgICAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCkgPT4gYWNjdW11bGF0b3IgKyB2YWx1ZSAqIHZlY3RvcjJbaW5kZXhdLFxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hZ25pdHVkZSh2ZWN0b3IpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkb3RQcm9kdWN0KHZlY3RvciwgdmVjdG9yKSk7XG59XG5cbi8vIHN0cmVhbXMvYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVQYXJzZXJcbn0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlclwiO1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpIHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCAmJiBldmVudC50eXBlID09PSBcImV2ZW50XCIgJiYgZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIiB8fCAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICBldmVudC5ldmVudCA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlciA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhLCB7XG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudFxuICAgICAgICAgICAgfSkgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpKTtcbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBjb250ZW50O1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbihjb250ZW50KTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0ICYmIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHJldHVybiBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbFwiIGluIGNhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCkge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG4gIHJldHVybiAodGV4dCkgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuZnVuY3Rpb24gQUlTdHJlYW0ocmVzcG9uc2UsIGN1c3RvbVBhcnNlciwgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgdmFyIF9hMTE7XG4gICAgICBhd2FpdCAoKF9hMTEgPSBpdC5yZXR1cm4pID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNhbGwoaXQsIHJlYXNvbikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbmltcG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2NvbnN0YW50cy50c1xudmFyIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyA9IDE1ICogMWUzO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG52YXIgU3RyZWFtRGF0YTIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMud2FybmluZ1RpbWVvdXQgPSBudWxsO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgIHNlbGYud2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LCBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHVsbDogKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IChyZWFzb24pID0+IHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5jbG9zZSgpO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLndhcm5pbmdUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53YXJuaW5nVGltZW91dCk7XG4gICAgfVxuICB9XG4gIGFwcGVuZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJkYXRhXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQyKFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCBbdmFsdWVdKSlcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQyKFwidGV4dFwiLCBtZXNzYWdlKSkpO1xuICAgIH1cbiAgfSk7XG59XG52YXIgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgPSBjbGFzcyBleHRlbmRzIFN0cmVhbURhdGEyIHtcbn07XG5cbi8vIHN0cmVhbXMvYW50aHJvcGljLXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VBbnRocm9waWNTdHJlYW0oKSB7XG4gIGxldCBwcmV2aW91cyA9IFwiXCI7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGlmIChcImVycm9yXCIgaW4ganNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2pzb24uZXJyb3IudHlwZX06ICR7anNvbi5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBpZiAoIShcImNvbXBsZXRpb25cIiBpbiBqc29uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0ganNvbi5jb21wbGV0aW9uO1xuICAgIGlmICghcHJldmlvdXMgfHwgdGV4dC5sZW5ndGggPiBwcmV2aW91cy5sZW5ndGggJiYgdGV4dC5zdGFydHNXaXRoKHByZXZpb3VzKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSB0ZXh0LnNsaWNlKHByZXZpb3VzLmxlbmd0aCk7XG4gICAgICBwcmV2aW91cyA9IHRleHQ7XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwiY29tcGxldGlvblwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsuY29tcGxldGlvbjtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH0gZWxzZSBpZiAoXCJkZWx0YVwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB7IGRlbHRhIH0gPSBjaHVuaztcbiAgICAgIGlmIChcInRleHRcIiBpbiBkZWx0YSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZGVsdGEudGV4dDtcbiAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFudGhyb3BpY1N0cmVhbShyZXMsIGNiKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBSVN0cmVhbShyZXMsIHBhcnNlQW50aHJvcGljU3RyZWFtKCksIGNiKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2Fzc2lzdGFudC1yZXNwb25zZS50c1xuaW1wb3J0IHtcbiAgZm9ybWF0U3RyZWFtUGFydCBhcyBmb3JtYXRTdHJlYW1QYXJ0M1xufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuZnVuY3Rpb24gQXNzaXN0YW50UmVzcG9uc2UoeyB0aHJlYWRJZCwgbWVzc2FnZUlkIH0sIHByb2Nlc3MyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hMTE7XG4gICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgY29uc3Qgc2VuZE1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiYXNzaXN0YW50X21lc3NhZ2VcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZERhdGFNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJlcnJvclwiLCBlcnJvck1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBhc3luYyAoc3RyZWFtMikgPT4ge1xuICAgICAgICB2YXIgX2ExMiwgX2I7XG4gICAgICAgIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtMikge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5jcmVhdGVkXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQzKFwiYXNzaXN0YW50X21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHsgdmFsdWU6IFwiXCIgfSB9XVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYTEyID0gdmFsdWUuZGF0YS5kZWx0YS5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ExMlswXTtcbiAgICAgICAgICAgICAgaWYgKChjb250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50LnR5cGUpID09PSBcInRleHRcIiAmJiAoKF9iID0gY29udGVudC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQzKFwidGV4dFwiLCBjb250ZW50LnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLmNvbXBsZXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsIHtcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3MyKHtcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgc2VuZERhdGFNZXNzYWdlLFxuICAgICAgICAgIGZvcndhcmRTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZW5kRXJyb3IoKF9hMTEgPSBlcnJvci5tZXNzYWdlKSAhPSBudWxsID8gX2ExMSA6IGAke2Vycm9yfWApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHVsbChjb250cm9sbGVyKSB7XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcbiAgICBzdGF0dXM6IDIwMCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfSk7XG59XG52YXIgZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlID0gQXNzaXN0YW50UmVzcG9uc2U7XG5cbi8vIHN0cmVhbXMvYXdzLWJlZHJvY2stc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogYXNEZWx0YUl0ZXJhYmxlKHJlc3BvbnNlLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHZhciBfYTExLCBfYjtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIChfYTExID0gcmVzcG9uc2UuYm9keSkgIT0gbnVsbCA/IF9hMTEgOiBbXSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKF9iID0gY2h1bmsuY2h1bmspID09IG51bGwgPyB2b2lkIDAgOiBfYi5ieXRlcztcbiAgICBpZiAoYnl0ZXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmtUZXh0ID0gZGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgY29uc3QgY2h1bmtKU09OID0gSlNPTi5wYXJzZShjaHVua1RleHQpO1xuICAgICAgY29uc3QgZGVsdGEgPSBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKGNodW5rSlNPTik7XG4gICAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCBkZWx0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tBbnRocm9waWNNZXNzYWdlc1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4ge1xuICAgIHZhciBfYTExO1xuICAgIHJldHVybiAoX2ExMSA9IGNodW5rLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS50ZXh0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmNvbXBsZXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0NvaGVyZVN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IGNodW5rLnRleHQpO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0xsYW1hMlN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuZ2VuZXJhdGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoXG4gICAgYXNEZWx0YUl0ZXJhYmxlKHJlc3BvbnNlLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKVxuICApLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9jb2hlcmUtc3RyZWFtLnRzXG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NMaW5lcyhsaW5lcywgY29udHJvbGxlcikge1xuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBjb25zdCB7IHRleHQsIGlzX2ZpbmlzaGVkIH0gPSBKU09OLnBhcnNlKGxpbmUpO1xuICAgIGlmICghaXNfZmluaXNoZWQpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKSB7XG4gIGxldCBzZWdtZW50ID0gXCJcIjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlOiBjaHVuaywgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gdXRmOERlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICBjb25zdCBsaW5lc0FycmF5ID0gc2VnbWVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvZyk7XG4gICAgc2VnbWVudCA9IGxpbmVzQXJyYXkucG9wKCkgfHwgXCJcIjtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHNlZ21lbnQpIHtcbiAgICBjb25zdCBsaW5lc0FycmF5ID0gW3NlZ21lbnRdO1xuICAgIGF3YWl0IHByb2Nlc3NMaW5lcyhsaW5lc0FycmF5LCBjb250cm9sbGVyKTtcbiAgfVxuICBjb250cm9sbGVyLmNsb3NlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIyKHJlcykge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgcmVhZGVyID0gKF9hMTEgPSByZXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuZ2V0UmVhZGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVhZEFuZFByb2Nlc3NMaW5lcyhyZWFkZXIsIGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTIoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKGNodW5rLmV2ZW50VHlwZSA9PT0gXCJ0ZXh0LWdlbmVyYXRpb25cIikge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rLnRleHQ7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIENvaGVyZVN0cmVhbShyZWFkZXIsIGNhbGxiYWNrcykge1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVhZGVyKSB7XG4gICAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTIocmVhZGVyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVQYXJzZXIyKHJlYWRlcikucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvZ29vZ2xlLWdlbmVyYXRpdmUtYWktc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTMocmVzcG9uc2UpIHtcbiAgdmFyIF9hMTEsIF9iLCBfYztcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZS5zdHJlYW0pIHtcbiAgICBjb25zdCBwYXJ0cyA9IChfYyA9IChfYiA9IChfYTExID0gY2h1bmsuY2FuZGlkYXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTFbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MucGFydHM7XG4gICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICBpZiAodHlwZW9mIGZpcnN0UGFydC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB5aWVsZCBmaXJzdFBhcnQudGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbShyZXNwb25zZSwgY2IpIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTMocmVzcG9uc2UpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9odWdnaW5nZmFjZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjMocmVzKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExMSwgX2I7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZXMubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKF9iID0gKF9hMTEgPSB2YWx1ZS50b2tlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEudGV4dCkgIT0gbnVsbCA/IF9iIDogXCJcIik7XG4gICAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZS5nZW5lcmF0ZWRfdGV4dCAhPSBudWxsICYmIHZhbHVlLmdlbmVyYXRlZF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgPT09IFwiPC9zPlwiIHx8IHRleHQgPT09IFwiPHxlbmRvZnRleHR8PlwiIHx8IHRleHQgPT09IFwiPHxlbmR8PlwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSHVnZ2luZ0ZhY2VTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcnNlcjMocmVzKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvaW5rZWVwLXN0cmVhbS50c1xuZnVuY3Rpb24gSW5rZWVwU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBib2R5IGlzIG51bGxcIik7XG4gIH1cbiAgbGV0IGNoYXRfc2Vzc2lvbl9pZCA9IFwiXCI7XG4gIGxldCByZWNvcmRzX2NpdGVkO1xuICBjb25zdCBpbmtlZXBFdmVudFBhcnNlciA9IChkYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hMTEsIF9iO1xuICAgIGNvbnN0IHsgZXZlbnQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50ID09PSBcInJlY29yZHNfY2l0ZWRcIikge1xuICAgICAgcmVjb3Jkc19jaXRlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAoX2ExMSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUmVjb3Jkc0NpdGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKGNhbGxiYWNrcywgcmVjb3Jkc19jaXRlZCk7XG4gICAgfVxuICAgIGlmIChldmVudCA9PT0gXCJtZXNzYWdlX2NodW5rXCIpIHtcbiAgICAgIGNvbnN0IGlua2VlcE1lc3NhZ2VDaHVuayA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICBjaGF0X3Nlc3Npb25faWQgPSAoX2IgPSBpbmtlZXBNZXNzYWdlQ2h1bmsuY2hhdF9zZXNzaW9uX2lkKSAhPSBudWxsID8gX2IgOiBjaGF0X3Nlc3Npb25faWQ7XG4gICAgICByZXR1cm4gaW5rZWVwTWVzc2FnZUNodW5rLmNvbnRlbnRfY2h1bms7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcbiAgbGV0IHsgb25SZWNvcmRzQ2l0ZWQsIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzIH0gPSBjYWxsYmFja3MgfHwge307XG4gIHBhc3NUaHJvdWdoQ2FsbGJhY2tzID0ge1xuICAgIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzLFxuICAgIG9uRmluYWw6IChjb21wbGV0aW9uKSA9PiB7XG4gICAgICB2YXIgX2ExMTtcbiAgICAgIGNvbnN0IGlua2VlcE9uRmluYWxNZXRhZGF0YSA9IHtcbiAgICAgICAgY2hhdF9zZXNzaW9uX2lkLFxuICAgICAgICByZWNvcmRzX2NpdGVkXG4gICAgICB9O1xuICAgICAgKF9hMTEgPSBjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkZpbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKGNhbGxiYWNrcywgY29tcGxldGlvbiwgaW5rZWVwT25GaW5hbE1ldGFkYXRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBSVN0cmVhbShyZXMsIGlua2VlcEV2ZW50UGFyc2VyLCBwYXNzVGhyb3VnaENhbGxiYWNrcykucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tYWRhcHRlci50c1xudmFyIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMsIHtcbiAgdG9BSVN0cmVhbTogKCkgPT4gdG9BSVN0cmVhbSxcbiAgdG9EYXRhU3RyZWFtOiAoKSA9PiB0b0RhdGFTdHJlYW0sXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZVxufSk7XG5mdW5jdGlvbiB0b0FJU3RyZWFtKHN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiB0b0RhdGFTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtKHN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jICh2YWx1ZSwgY29udHJvbGxlcikgPT4ge1xuICAgICAgICB2YXIgX2ExMTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImV2ZW50XCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUuZXZlbnQgPT09IFwib25fY2hhdF9tb2RlbF9zdHJlYW1cIikge1xuICAgICAgICAgICAgZm9yd2FyZEFJTWVzc2FnZUNodW5rKFxuICAgICAgICAgICAgICAoX2ExMSA9IHZhbHVlLmRhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmNodW5rLFxuICAgICAgICAgICAgICBjb250cm9sbGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZEFJTWVzc2FnZUNodW5rKHZhbHVlLCBjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9KVxuICApLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cbmZ1bmN0aW9uIHRvRGF0YVN0cmVhbVJlc3BvbnNlKHN0cmVhbSwgb3B0aW9ucykge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgZGF0YVN0cmVhbSA9IHRvRGF0YVN0cmVhbShzdHJlYW0sIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FsbGJhY2tzKTtcbiAgY29uc3QgZGF0YSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YTtcbiAgY29uc3QgaW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdDtcbiAgY29uc3QgcmVzcG9uc2VTdHJlYW0gPSBkYXRhID8gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCBkYXRhU3RyZWFtKSA6IGRhdGFTdHJlYW07XG4gIHJldHVybiBuZXcgUmVzcG9uc2UocmVzcG9uc2VTdHJlYW0sIHtcbiAgICBzdGF0dXM6IChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLFxuICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICB9KVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZvcndhcmRBSU1lc3NhZ2VDaHVuayhjaHVuaywgY29udHJvbGxlcikge1xuICBpZiAodHlwZW9mIGNodW5rLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29udGVudCA9IGNodW5rLmNvbnRlbnQ7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbnRlbnQpIHtcbiAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShpdGVtLnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBzdHJlYW1zL2xsYW1haW5kZXgtYWRhcHRlci50c1xudmFyIGxsYW1haW5kZXhfYWRhcHRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cywge1xuICB0b0RhdGFTdHJlYW06ICgpID0+IHRvRGF0YVN0cmVhbTIsXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZTJcbn0pO1xuZnVuY3Rpb24gdG9EYXRhU3RyZWFtMihzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gdG9SZWFkYWJsZVN0cmVhbShzdHJlYW0pLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cbmZ1bmN0aW9uIHRvRGF0YVN0cmVhbVJlc3BvbnNlMihzdHJlYW0sIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgeyBpbml0LCBkYXRhLCBjYWxsYmFja3MgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRhdGFTdHJlYW0gPSB0b0RhdGFTdHJlYW0yKHN0cmVhbSwgY2FsbGJhY2tzKTtcbiAgY29uc3QgcmVzcG9uc2VTdHJlYW0gPSBkYXRhID8gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCBkYXRhU3RyZWFtKSA6IGRhdGFTdHJlYW07XG4gIHJldHVybiBuZXcgUmVzcG9uc2UocmVzcG9uc2VTdHJlYW0sIHtcbiAgICBzdGF0dXM6IChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLFxuICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICB9KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRvUmVhZGFibGVTdHJlYW0ocmVzKSB7XG4gIGNvbnN0IGl0ID0gcmVzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hMTE7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbSgoX2ExMSA9IHZhbHVlLmRlbHRhKSAhPSBudWxsID8gX2ExMSA6IFwiXCIpO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLXN0cmVhbS50c1xuZnVuY3Rpb24gTGFuZ0NoYWluU3RyZWFtKGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgY29uc3QgcnVucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICBhd2FpdCB3cml0ZXIuYWJvcnQoZSk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVN0YXJ0ID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5hZGQocnVuSWQpO1xuICB9O1xuICBjb25zdCBoYW5kbGVFbmQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgaWYgKHJ1bnMuc2l6ZSA9PT0gMCkge1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogc3RyZWFtLnJlYWRhYmxlLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKSxcbiAgICB3cml0ZXIsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGhhbmRsZUxMTU5ld1Rva2VuOiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUodG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTVN0YXJ0OiBhc3luYyAoX2xsbSwgX3Byb21wdHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluU3RhcnQ6IGFzeW5jIChfY2hhaW4sIF9pbnB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVuZDogYXN5bmMgKF9vdXRwdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbFN0YXJ0OiBhc3luYyAoX3Rvb2wsIF9pbnB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvbWlzdHJhbC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNChzdHJlYW0pIHtcbiAgdmFyIF9hMTEsIF9iO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2IgPSAoX2ExMSA9IGNodW5rLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwIHx8IGNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBjb250ZW50O1xuICB9XG59XG5mdW5jdGlvbiBNaXN0cmFsU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNChyZXNwb25zZSkpO1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDRcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHBhcnNlT3BlbkFJU3RyZWFtKCkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIChkYXRhKSA9PiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU1KHN0cmVhbSkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwicHJvbXB0RmlsdGVyUmVzdWx0c1wiIGluIGNodW5rKSB7XG4gICAgICBjaHVuayA9IHtcbiAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICBjcmVhdGVkOiBjaHVuay5jcmVhdGVkLmdldERhdGUoKSxcbiAgICAgICAgb2JqZWN0OiBjaHVuay5vYmplY3QsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBtb2RlbDogY2h1bmsubW9kZWwsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBjaG9pY2VzOiBjaHVuay5jaG9pY2VzLm1hcCgoY2hvaWNlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IChfYTExID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jb250ZW50LFxuICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiAoX2IgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICAgIHJvbGU6IChfYyA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJvbGUsXG4gICAgICAgICAgICAgIHRvb2xfY2FsbHM6ICgoX2UgPSAoX2QgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5sZW5ndGgpID8gKF9nID0gKF9mID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2YudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cubWFwKCh0b29sQ2FsbCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlXG4gICAgICAgICAgICAgIH0pKSA6IHZvaWQgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBpbmRleDogY2hvaWNlLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCkge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gIHJldHVybiAoanNvbikgPT4ge1xuICAgIHZhciBfYTExLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX28sIF9wLCBfcSwgX3I7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSAoX2ExMSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuZGVsdGE7XG4gICAgICBpZiAoKF9iID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfZSA9IChfZCA9IChfYyA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfY1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2UubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGRlbHRhLnRvb2xfY2FsbHNbMF07XG4gICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYHtcInRvb2xfY2FsbHNcIjpbIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2YgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBgXCJ9fSwge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZyA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2cubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX2ggPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2guYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfaSA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaS5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfbCA9IChfayA9IChfaiA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfalswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2wuYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfbyA9IChfbiA9IChfbSA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX28uYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKCgoX3AgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcC5maW5pc2hfcmVhc29uKSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIgfHwgKChfcSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9xLmZpbmlzaF9yZWFzb24pID09PSBcInN0b3BcIikpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fSdcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoX3IgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfci5maW5pc2hfcmVhc29uKSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fV19J1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oXG4gICAgICBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikgJiYganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgPyBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA6IGlzQ29tcGxldGlvbihqc29uKSA/IGpzb24uY2hvaWNlc1swXS50ZXh0IDogXCJcIlxuICAgICk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG4gIGZ1bmN0aW9uIGNsZWFudXBBcmd1bWVudHMoYXJndW1lbnRDaHVuaykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxmL2csIFwiXFxcXGZcIik7XG4gICAgcmV0dXJuIGAke2VzY2FwZWRQYXJ0aWFsSnNvbn1gO1xuICB9XG59XG52YXIgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgXCJpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXNcIlxuKTtcbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJkZWx0YVwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGlvbihkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJ0ZXh0XCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gT3BlbkFJU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IGNiID0gY2FsbGJhY2tzO1xuICBsZXQgc3RyZWFtO1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgLi4uY2JcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAuLi5jYixcbiAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jYlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNhbGxiYWNrcykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlcyA9IGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID0gaXNGaXJzdENodW5rICYmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fCBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaXNGaXJzdENodW5rICYmIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICBsZXQgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sMiBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sMi5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sMi5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sX2NhbGxfaWQsIGZ1bmN0aW9uX25hbWUsIHRvb2xfY2FsbF9yZXN1bHQgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2VJbmRleCA9PT0gMCA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsczogcGF5bG9hZC50b29sX2NhbGxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVzdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6XCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gXCJmdW5jdGlvbl9jYWxsXCIgOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQ0KFwidGV4dFwiLCBmdW5jdGlvblJlc3BvbnNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uU3RhcnQ6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB2b2lkIDA7XG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9yZXBsaWNhdGUtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBSZXBsaWNhdGVTdHJlYW0ocmVzLCBjYiwgb3B0aW9ucykge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgdXJsID0gKF9hMTEgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuc3RyZWFtO1xuICBpZiAoIXVybCkge1xuICAgIGlmIChyZXMuZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHN0cmVhbSBVUkwgaW4gUmVwbGljYXRlIHJlc3BvbnNlXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50U3RyZWFtID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIEFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEFJU3RyZWFtKGV2ZW50U3RyZWFtLCB2b2lkIDAsIGNiKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gc3RyZWFtVG9SZXNwb25zZShyZXMsIHJlc3BvbnNlLCBpbml0LCBkYXRhKSB7XG4gIHZhciBfYTExO1xuICByZXNwb25zZS53cml0ZUhlYWQoKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsIHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgfSk7XG4gIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gIGlmIChkYXRhKSB7XG4gICAgcHJvY2Vzc2VkU3RyZWFtID0gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCByZXMpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHByb2Nlc3NlZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgIHJlYWQoKTtcbiAgICB9KTtcbiAgfVxuICByZWFkKCk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXRleHQtcmVzcG9uc2UudHNcbnZhciBTdHJlYW1pbmdUZXh0UmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocmVzLCBpbml0LCBkYXRhKSB7XG4gICAgbGV0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcztcbiAgICBpZiAoZGF0YSkge1xuICAgICAgcHJvY2Vzc2VkU3RyZWFtID0gbWVyZ2VTdHJlYW1zKGRhdGEuc3RyZWFtLCByZXMpO1xuICAgIH1cbiAgICBzdXBlcihwcm9jZXNzZWRTdHJlYW0sIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHN0cmVhbXMvaW5kZXgudHNcbnZhciBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRJbXBsO1xudmFyIG5hbm9pZCA9IGdlbmVyYXRlSWRJbXBsO1xuZXhwb3J0IHtcbiAgQUlTREtFcnJvcjEwIGFzIEFJU0RLRXJyb3IsXG4gIEFJU3RyZWFtLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtLFxuICBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtLFxuICBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtLFxuICBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtLFxuICBBV1NCZWRyb2NrU3RyZWFtLFxuICBBbnRocm9waWNTdHJlYW0sXG4gIEFzc2lzdGFudFJlc3BvbnNlLFxuICBDb2hlcmVTdHJlYW0sXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbSxcbiAgSHVnZ2luZ0ZhY2VTdHJlYW0sXG4gIElua2VlcFN0cmVhbSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWREYXRhQ29udGVudEVycm9yLFxuICBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yMiBhcyBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgYXMgTGFuZ0NoYWluQWRhcHRlcixcbiAgTGFuZ0NoYWluU3RyZWFtLFxuICBsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyBhcyBMbGFtYUluZGV4QWRhcHRlcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBNZXNzYWdlQ29udmVyc2lvbkVycm9yLFxuICBNaXN0cmFsU3RyZWFtLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgTm9TdWNoUHJvdmlkZXJFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yLFxuICBPcGVuQUlTdHJlYW0sXG4gIFJlcGxpY2F0ZVN0cmVhbSxcbiAgUmV0cnlFcnJvcixcbiAgU3RyZWFtRGF0YTIgYXMgU3RyZWFtRGF0YSxcbiAgU3RyZWFtaW5nVGV4dFJlc3BvbnNlLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yMiBhcyBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyxcbiAgY29zaW5lU2ltaWxhcml0eSxcbiAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcixcbiAgZW1iZWQsXG4gIGVtYmVkTWFueSxcbiAgZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfU3RyZWFtRGF0YSxcbiAgZXhwZXJpbWVudGFsX2NyZWF0ZU1vZGVsUmVnaXN0cnksXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbVRleHQsXG4gIGV4cGVyaW1lbnRhbF93cmFwTGFuZ3VhZ2VNb2RlbCxcbiAgZm9ybWF0U3RyZWFtUGFydCxcbiAgZ2VuZXJhdGVJZDIgYXMgZ2VuZXJhdGVJZCxcbiAgZ2VuZXJhdGVPYmplY3QsXG4gIGdlbmVyYXRlVGV4dCxcbiAganNvblNjaGVtYSxcbiAgbmFub2lkLFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSxcbiAgcmVhZERhdGFTdHJlYW0sXG4gIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUsXG4gIHN0cmVhbU9iamVjdCxcbiAgc3RyZWFtVGV4dCxcbiAgc3RyZWFtVG9SZXNwb25zZSxcbiAgdG9vbCxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lMTEiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZm9ybWF0U3RyZWFtUGFydCIsInBhcnNlU3RyZWFtUGFydCIsInJlYWREYXRhU3RyZWFtIiwicHJvY2Vzc0RhdGFQcm90b2NvbFJlc3BvbnNlIiwiZ2VuZXJhdGVJZCIsImdlbmVyYXRlSWRJbXBsIiwianNvblNjaGVtYSIsIkFQSUNhbGxFcnJvciIsImdldEVycm9yTWVzc2FnZSIsImlzQWJvcnRFcnJvciIsImRlbGF5IiwiZGVsYXlJbk1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiQUlTREtFcnJvciIsIm5hbWUiLCJtYXJrZXIiLCJzeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJfYSIsIlJldHJ5RXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJyZWFzb24iLCJlcnJvcnMiLCJsYXN0RXJyb3IiLCJsZW5ndGgiLCJpc0luc3RhbmNlIiwiZXJyb3IiLCJoYXNNYXJrZXIiLCJpc1JldHJ5RXJyb3IiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsInRvSlNPTiIsInJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsIm1heFJldHJpZXMiLCJpbml0aWFsRGVsYXlJbk1zIiwiYmFja29mZkZhY3RvciIsImYiLCJfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiZXJyb3JNZXNzYWdlIiwibmV3RXJyb3JzIiwidHJ5TnVtYmVyIiwiaXNBUElDYWxsRXJyb3IiLCJpc1JldHJ5YWJsZSIsImFzc2VtYmxlT3BlcmF0aW9uTmFtZSIsIm9wZXJhdGlvbklkIiwidGVsZW1ldHJ5IiwiZnVuY3Rpb25JZCIsImdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzIiwibW9kZWwiLCJzZXR0aW5ncyIsImhlYWRlcnMiLCJfYTExIiwicHJvdmlkZXIiLCJtb2RlbElkIiwiZW50cmllcyIsInJlZHVjZSIsImF0dHJpYnV0ZXMiLCJrZXkiLCJ2YWx1ZSIsIm1ldGFkYXRhIiwidHJhY2UiLCJub29wVHJhY2VyIiwic3RhcnRTcGFuIiwibm9vcFNwYW4iLCJzdGFydEFjdGl2ZVNwYW4iLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJzcGFuQ29udGV4dCIsIm5vb3BTcGFuQ29udGV4dCIsInNldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZXMiLCJhZGRFdmVudCIsImFkZExpbmsiLCJhZGRMaW5rcyIsInNldFN0YXR1cyIsInVwZGF0ZU5hbWUiLCJlbmQiLCJpc1JlY29yZGluZyIsInJlY29yZEV4Y2VwdGlvbiIsInRyYWNlSWQiLCJzcGFuSWQiLCJ0cmFjZUZsYWdzIiwiZ2V0VHJhY2VyIiwiaXNFbmFibGVkIiwidHJhY2VyIiwiU3BhblN0YXR1c0NvZGUiLCJyZWNvcmRTcGFuIiwiZm4iLCJlbmRXaGVuRG9uZSIsInNwYW4iLCJyZXN1bHQiLCJzdGFjayIsImNvZGUiLCJFUlJPUiIsInNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzMiIsImlucHV0IiwicmVjb3JkSW5wdXRzIiwib3V0cHV0IiwicmVjb3JkT3V0cHV0cyIsImVtYmVkIiwiYWJvcnRTaWduYWwiLCJleHBlcmltZW50YWxfdGVsZW1ldHJ5IiwiYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMiLCJKU09OIiwic3RyaW5naWZ5IiwicmV0cnkiLCJlbWJlZGRpbmciLCJ1c2FnZSIsInJhd1Jlc3BvbnNlIiwiZG9FbWJlZFNwYW4iLCJtb2RlbFJlc3BvbnNlIiwiZG9FbWJlZCIsInZhbHVlcyIsImVtYmVkZGluZzIiLCJlbWJlZGRpbmdzIiwidXNhZ2UyIiwidG9rZW5zIiwiTmFOIiwibWFwIiwiZW1iZWRkaW5nMyIsIkRlZmF1bHRFbWJlZFJlc3VsdCIsIm9wdGlvbnMiLCJzcGxpdEFycmF5IiwiYXJyYXkiLCJjaHVua1NpemUiLCJpIiwicHVzaCIsInNsaWNlIiwiZW1iZWRNYW55IiwibWF4RW1iZWRkaW5nc1BlckNhbGwiLCJlbWJlZGRpbmdzMiIsImVtYmVkZGluZ3MzIiwiRGVmYXVsdEVtYmVkTWFueVJlc3VsdCIsInZhbHVlQ2h1bmtzIiwiY2h1bmsiLCJyZXNwb25zZUVtYmVkZGluZ3MiLCJjcmVhdGVJZEdlbmVyYXRvciIsInNhZmVQYXJzZUpTT04iLCJBSVNES0Vycm9yMiIsIm5hbWUyIiwibWFya2VyMiIsInN5bWJvbDIiLCJfYTIiLCJEb3dubG9hZEVycm9yIiwidXJsIiwic3RhdHVzQ29kZSIsInN0YXR1c1RleHQiLCJjYXVzZSIsImlzRG93bmxvYWRFcnJvciIsImRvd25sb2FkIiwiZmV0Y2hJbXBsZW1lbnRhdGlvbiIsImZldGNoIiwidXJsVGV4dCIsInRvU3RyaW5nIiwicmVzcG9uc2UiLCJvayIsInN0YXR1cyIsImRhdGEiLCJVaW50OEFycmF5IiwiYXJyYXlCdWZmZXIiLCJtaW1lVHlwZSIsIm1pbWVUeXBlU2lnbmF0dXJlcyIsImJ5dGVzIiwiZGV0ZWN0SW1hZ2VNaW1lVHlwZSIsImltYWdlIiwiZXZlcnkiLCJieXRlIiwiaW5kZXgiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IiwiY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCIsIkFJU0RLRXJyb3IzIiwibmFtZTMiLCJtYXJrZXIzIiwic3ltYm9sMyIsIl9hMyIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udGVudCIsImlzSW52YWxpZERhdGFDb250ZW50RXJyb3IiLCJ6IiwiZGF0YUNvbnRlbnRTY2hlbWEiLCJ1bmlvbiIsInN0cmluZyIsImluc3RhbmNlb2YiLCJBcnJheUJ1ZmZlciIsImN1c3RvbSIsIl9iIiwiZ2xvYmFsVGhpcyIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmciLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJjb252ZXJ0VWludDhBcnJheVRvVGV4dCIsInVpbnQ4QXJyYXkiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsIkFJU0RLRXJyb3I0IiwibmFtZTQiLCJtYXJrZXI0Iiwic3ltYm9sNCIsIl9hNCIsIkludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwicm9sZSIsImlzSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IiLCJzcGxpdERhdGFVcmwiLCJkYXRhVXJsIiwiaGVhZGVyIiwiYmFzZTY0Q29udGVudCIsInNwbGl0IiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCIsInByb21wdCIsIm1vZGVsU3VwcG9ydHNJbWFnZVVybHMiLCJtb2RlbFN1cHBvcnRzVXJsIiwiZG93bmxvYWRJbXBsZW1lbnRhdGlvbiIsImRvd25sb2FkZWRBc3NldHMiLCJkb3dubG9hZEFzc2V0cyIsIm1lc3NhZ2VzIiwic3lzdGVtIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UiLCJwcm92aWRlck1ldGFkYXRhIiwiZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEiLCJ0eXBlIiwidGV4dCIsInBhcnQiLCJjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQiLCJmaWx0ZXIiLCJyZXN0IiwidG9vbENhbGxJZCIsInRvb2xOYW1lIiwiZXhwZXJpbWVudGFsX2NvbnRlbnQiLCJpc0Vycm9yIiwiX2V4aGF1c3RpdmVDaGVjayIsInVybHMiLCJmbGF0Iiwic3RhcnRzV2l0aCIsIlVSTCIsImRvd25sb2FkZWRJbWFnZXMiLCJmcm9tRW50cmllcyIsIm5vcm1hbGl6ZWREYXRhIiwicHJvdG9jb2wiLCJkYXRhVXJsTWltZVR5cGUiLCJkb3dubG9hZGVkRmlsZSIsIkFJU0RLRXJyb3I1IiwibmFtZTUiLCJtYXJrZXI1Iiwic3ltYm9sNSIsIl9hNSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicGFyYW1ldGVyIiwiaXNJbnZhbGlkQXJndW1lbnRFcnJvciIsInByZXBhcmVDYWxsU2V0dGluZ3MiLCJtYXhUb2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInRvcFAiLCJ0b3BLIiwicHJlc2VuY2VQZW5hbHR5IiwiZnJlcXVlbmN5UGVuYWx0eSIsInN0b3BTZXF1ZW5jZXMiLCJzZWVkIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiSW52YWxpZFByb21wdEVycm9yIiwic2FmZVZhbGlkYXRlVHlwZXMiLCJ6NyIsIno2IiwiejMiLCJ6MiIsImpzb25WYWx1ZVNjaGVtYSIsImxhenkiLCJudWxsIiwibnVtYmVyIiwiYm9vbGVhbiIsInJlY29yZCIsInByb3ZpZGVyTWV0YWRhdGFTY2hlbWEiLCJ6NSIsIno0IiwidG9vbFJlc3VsdENvbnRlbnRTY2hlbWEiLCJvYmplY3QiLCJsaXRlcmFsIiwib3B0aW9uYWwiLCJ0ZXh0UGFydFNjaGVtYSIsImltYWdlUGFydFNjaGVtYSIsImZpbGVQYXJ0U2NoZW1hIiwidG9vbENhbGxQYXJ0U2NoZW1hIiwiYXJncyIsInVua25vd24iLCJ0b29sUmVzdWx0UGFydFNjaGVtYSIsImNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hIiwiY29yZVVzZXJNZXNzYWdlU2NoZW1hIiwiY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEiLCJjb3JlVG9vbE1lc3NhZ2VTY2hlbWEiLCJjb3JlTWVzc2FnZVNjaGVtYSIsImRldGVjdFByb21wdFR5cGUiLCJjaGFyYWN0ZXJpc3RpY3MiLCJkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzIiwic29tZSIsImMiLCJpbmNsdWRlcyIsImF0dGFjaG1lbnRzVG9QYXJ0cyIsImF0dGFjaG1lbnRzIiwiX2MiLCJwYXJ0cyIsImF0dGFjaG1lbnQiLCJjb250ZW50VHlwZSIsIkFJU0RLRXJyb3I2IiwibmFtZTYiLCJtYXJrZXI2Iiwic3ltYm9sNiIsIl9hNiIsIk1lc3NhZ2VDb252ZXJzaW9uRXJyb3IiLCJvcmlnaW5hbE1lc3NhZ2UiLCJjb252ZXJ0VG9Db3JlTWVzc2FnZXMiLCJ0b29scyIsImNvcmVNZXNzYWdlcyIsInRvb2xJbnZvY2F0aW9ucyIsImV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyIsInRvb2xJbnZvY2F0aW9uIiwidG9vbDIiLCJleHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudCIsInN0YW5kYXJkaXplUHJvbXB0IiwicHJvbXB0VHlwZSIsInZhbGlkYXRpb25SZXN1bHQiLCJzY2hlbWEiLCJzdWNjZXNzIiwiY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlIiwicHJvbXB0VG9rZW5zIiwiY29tcGxldGlvblRva2VucyIsInRvdGFsVG9rZW5zIiwicHJlcGFyZVJlc3BvbnNlSGVhZGVycyIsImluaXQiLCJkYXRhU3RyZWFtVmVyc2lvbiIsIkhlYWRlcnMiLCJoYXMiLCJzZXQiLCJERUZBVUxUX1NDSEVNQV9QUkVGSVgiLCJERUZBVUxUX1NDSEVNQV9TVUZGSVgiLCJERUZBVUxUX0dFTkVSSUNfU1VGRklYIiwiaW5qZWN0SnNvbkluc3RydWN0aW9uIiwic2NoZW1hUHJlZml4Iiwic2NoZW1hU3VmZml4IiwibGluZSIsImpvaW4iLCJBSVNES0Vycm9yNyIsIm5hbWU3IiwibWFya2VyNyIsInN5bWJvbDciLCJfYTciLCJOb09iamVjdEdlbmVyYXRlZEVycm9yIiwiaXNOb09iamVjdEdlbmVyYXRlZEVycm9yIiwiaXNKU09OQXJyYXkiLCJpc0pTT05PYmplY3QiLCJUeXBlVmFsaWRhdGlvbkVycm9yIiwiVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IiLCJzYWZlVmFsaWRhdGVUeXBlczIiLCJhc1NjaGVtYSIsImNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0iLCJzb3VyY2UiLCJ0cmFuc2Zvcm1lciIsInRyYW5zZm9ybWVkU3RyZWFtIiwicGlwZVRocm91Z2giLCJUcmFuc2Zvcm1TdHJlYW0iLCJhc3luY0l0ZXJhdG9yIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwibmV4dCIsImRvbmUiLCJyZWFkIiwibm9TY2hlbWFPdXRwdXRTdHJhdGVneSIsInZhbGlkYXRlUGFydGlhbFJlc3VsdCIsInRleHREZWx0YSIsInBhcnRpYWwiLCJ2YWxpZGF0ZUZpbmFsUmVzdWx0IiwiY3JlYXRlRWxlbWVudFN0cmVhbSIsImZ1bmN0aW9uYWxpdHkiLCJvYmplY3RPdXRwdXRTdHJhdGVneSIsImFycmF5T3V0cHV0U3RyYXRlZ3kiLCIkc2NoZW1hIiwiaXRlbVNjaGVtYSIsInByb3BlcnRpZXMiLCJlbGVtZW50cyIsIml0ZW1zIiwicmVxdWlyZWQiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsImxhdGVzdE9iamVjdCIsImlzRmlyc3REZWx0YSIsImlzRmluYWxEZWx0YSIsImlucHV0QXJyYXkiLCJyZXN1bHRBcnJheSIsImVsZW1lbnQiLCJwdWJsaXNoZWRFbGVtZW50Q291bnQiLCJvcmlnaW5hbFN0cmVhbSIsInB1Ymxpc2hlZEVsZW1lbnRzIiwidHJhbnNmb3JtIiwiY29udHJvbGxlciIsImVucXVldWUiLCJlbnVtT3V0cHV0U3RyYXRlZ3kiLCJlbnVtVmFsdWVzIiwiZW51bSIsImdldE91dHB1dFN0cmF0ZWd5IiwidmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQiLCJtb2RlIiwic2NoZW1hTmFtZSIsInNjaGVtYURlc2NyaXB0aW9uIiwib3JpZ2luYWxHZW5lcmF0ZUlkIiwicHJlZml4Iiwic2l6ZSIsImdlbmVyYXRlT2JqZWN0IiwiaW5wdXRTY2hlbWEiLCJfaW50ZXJuYWwiLCJnZW5lcmF0ZUlkMyIsImN1cnJlbnREYXRlIiwiRGF0ZSIsIm91dHB1dFN0cmF0ZWd5IiwiZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlIiwiZmluaXNoUmVhc29uIiwid2FybmluZ3MiLCJyZXF1ZXN0IiwibG9ncHJvYnMiLCJyZXN1bHRQcm92aWRlck1ldGFkYXRhIiwic3RhbmRhcmRpemVkUHJvbXB0Iiwic3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyIsInByb21wdE1lc3NhZ2VzIiwic3VwcG9ydHNJbWFnZVVybHMiLCJzdXBwb3J0c1VybCIsImdlbmVyYXRlUmVzdWx0Iiwic3BhbjIiLCJfYTEyIiwiX2IyIiwiX2QiLCJfZSIsIl9mIiwicmVzdWx0MiIsImRvR2VuZXJhdGUiLCJkZXNjcmlwdGlvbiIsImlucHV0Rm9ybWF0IiwicmVzcG9uc2VEYXRhIiwiaWQiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsIm9iamVjdFRleHQiLCJfZyIsIl9oIiwidG9vbCIsInBhcmFtZXRlcnMiLCJ0b29sQ2FsbHMiLCJwYXJzZVJlc3VsdCIsIkRlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCIsInRvSnNvblJlc3BvbnNlIiwiUmVzcG9uc2UiLCJleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QiLCJjcmVhdGVJZEdlbmVyYXRvcjIiLCJpc0RlZXBFcXVhbERhdGEiLCJwYXJzZVBhcnRpYWxKc29uIiwiY3JlYXRlUmVzb2x2YWJsZVByb21pc2UiLCJyZWplY3QiLCJwcm9taXNlIiwicmVzIiwicmVqIiwiRGVsYXllZFByb21pc2UiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJjYWxsIiwibm93IiwicGVyZm9ybWFuY2UiLCJwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyIsIndyaXRlVG9TZXJ2ZXJSZXNwb25zZSIsInN0cmVhbSIsIndyaXRlSGVhZCIsIndyaXRlIiwib3JpZ2luYWxHZW5lcmF0ZUlkMiIsInN0cmVhbU9iamVjdCIsIm9uRmluaXNoIiwibm93MiIsInJvb3RTcGFuIiwiY2FsbE9wdGlvbnMiLCJhcmdzVGV4dERlbHRhIiwiZG9TdHJlYW1TcGFuIiwic3RhcnRUaW1lc3RhbXBNcyIsImRvU3RyZWFtU3BhbjIiLCJkb1N0cmVhbSIsIkRlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQiLCJvYmplY3RQcm9taXNlIiwicmVzb2x2ZVVzYWdlIiwidXNhZ2VQcm9taXNlIiwicmVzb2x2ZVJlc3BvbnNlIiwicmVzcG9uc2VQcm9taXNlIiwicmVzb2x2ZVByb3ZpZGVyTWV0YWRhdGEiLCJwcm92aWRlck1ldGFkYXRhUHJvbWlzZSIsImFjY3VtdWxhdGVkVGV4dCIsImxhdGVzdE9iamVjdEpzb24iLCJpc0ZpcnN0Q2h1bmsiLCJzZWxmIiwibXNUb0ZpcnN0Q2h1bmsiLCJjdXJyZW50T2JqZWN0SnNvbiIsInN0YXRlIiwicGFyc2VTdGF0ZSIsImZsdXNoIiwiZmluYWxVc2FnZSIsImVycm9yMiIsInBhcnRpYWxPYmplY3RTdHJlYW0iLCJlbGVtZW50U3RyZWFtIiwidGV4dFN0cmVhbSIsImZ1bGxTdHJlYW0iLCJwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UiLCJUZXh0RW5jb2RlclN0cmVhbSIsInRvVGV4dFN0cmVhbVJlc3BvbnNlIiwiZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCIsImNyZWF0ZUlkR2VuZXJhdG9yMyIsIkFJU0RLRXJyb3IxMCIsIkFQSUNhbGxFcnJvcjIiLCJFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiSW52YWxpZFByb21wdEVycm9yMiIsIkludmFsaWRSZXNwb25zZURhdGFFcnJvciIsIkpTT05QYXJzZUVycm9yIiwiTG9hZEFQSUtleUVycm9yIiwiTm9Db250ZW50R2VuZXJhdGVkRXJyb3IiLCJOb1N1Y2hNb2RlbEVycm9yIiwiVHlwZVZhbGlkYXRpb25FcnJvcjIiLCJVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIiLCJBSVNES0Vycm9yOCIsImdldEVycm9yTWVzc2FnZTIiLCJuYW1lOCIsIm1hcmtlcjgiLCJzeW1ib2w4IiwiX2E4IiwiSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsInRvb2xBcmdzIiwiaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIiwiQUlTREtFcnJvcjkiLCJuYW1lOSIsIm1hcmtlcjkiLCJzeW1ib2w5IiwiX2E5IiwiTm9TdWNoVG9vbEVycm9yIiwiYXZhaWxhYmxlVG9vbHMiLCJpc05vU3VjaFRvb2xFcnJvciIsImFzU2NoZW1hMiIsImlzTm9uRW1wdHlPYmplY3QiLCJrZXlzIiwicHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSIsInRvb2xDaG9pY2UiLCJhY3RpdmVUb29scyIsImZpbHRlcmVkVG9vbHMiLCJ0b29sVHlwZSIsImV4aGF1c3RpdmVDaGVjayIsImxhc3RXaGl0ZXNwYWNlUmVnZXhwIiwic3BsaXRPbkxhc3RXaGl0ZXNwYWNlIiwibWF0Y2giLCJ3aGl0ZXNwYWNlIiwic3VmZml4IiwicmVtb3ZlVGV4dEFmdGVyTGFzdFdoaXRlc3BhY2UiLCJzYWZlUGFyc2VKU09OMiIsInNhZmVWYWxpZGF0ZVR5cGVzMyIsImFzU2NoZW1hMyIsInBhcnNlVG9vbENhbGwiLCJ0b29sQ2FsbCIsInRyaW0iLCJ0b1Jlc3BvbnNlTWVzc2FnZXMiLCJ0b29sUmVzdWx0cyIsInJlc3BvbnNlTWVzc2FnZXMiLCJ0b29sUmVzdWx0Iiwib3JpZ2luYWxHZW5lcmF0ZUlkMyIsImdlbmVyYXRlVGV4dCIsIm1heEF1dG9tYXRpY1JvdW5kdHJpcHMiLCJtYXhUb29sUm91bmR0cmlwcyIsIm1heFN0ZXBzIiwiZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzIiwiZXhwZXJpbWVudGFsX2NvbnRpbnVlU3RlcHMiLCJjb250aW51ZVN0ZXBzIiwiZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzIiwib25TdGVwRmluaXNoIiwiaW5pdGlhbFByb21wdCIsImNhbGxTZXR0aW5ncyIsImN1cnJlbnRNb2RlbFJlc3BvbnNlIiwiY3VycmVudFRvb2xDYWxscyIsImN1cnJlbnRUb29sUmVzdWx0cyIsInN0ZXBDb3VudCIsInN0ZXBzIiwic3RlcFR5cGUiLCJwcm9tcHRGb3JtYXQiLCJfYzIiLCJfZDIiLCJfZTIiLCJfZjIiLCJtb2RlbFRvb2xDYWxsIiwiZXhlY3V0ZVRvb2xzIiwiY3VycmVudFVzYWdlIiwibmV4dFN0ZXBUeXBlIiwib3JpZ2luYWxUZXh0Iiwic3RlcFRleHRMZWFkaW5nV2hpdGVzcGFjZVRyaW1tZWQiLCJ0cmltRW5kIiwidHJpbVN0YXJ0Iiwic3RlcFRleHQiLCJsYXN0TWVzc2FnZSIsImN1cnJlbnRTdGVwUmVzdWx0IiwicGFyc2UiLCJpc0NvbnRpbnVlZCIsIkRlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQiLCJleGVjdXRlIiwiaWdub3JlZCIsInJvdW5kdHJpcHMiLCJleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0IiwiY3JlYXRlSWRHZW5lcmF0b3I0IiwiY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSIsImlubmVyU3RyZWFtUmVhZGVycyIsImlzQ2xvc2VkIiwicHJvY2Vzc1B1bGwiLCJjbG9zZSIsInNoaWZ0IiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXJQYXJhbSIsInB1bGwiLCJjYW5jZWwiLCJhZGRTdHJlYW0iLCJpbm5lclN0cmVhbSIsIm1lcmdlU3RyZWFtcyIsInN0cmVhbTEiLCJzdHJlYW0yIiwicmVhZGVyMSIsInJlYWRlcjIiLCJsYXN0UmVhZDEiLCJsYXN0UmVhZDIiLCJzdHJlYW0xRG9uZSIsInN0cmVhbTJEb25lIiwicmVhZFN0cmVhbTEiLCJyZWFkU3RyZWFtMiIsInJhY2UiLCJ0aGVuIiwicnVuVG9vbHNUcmFuc2Zvcm1hdGlvbiIsImdlbmVyYXRvclN0cmVhbSIsInRvb2xDYWxsU3RyZWFtaW5nIiwidG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyIiwidG9vbFJlc3VsdHNTdHJlYW0iLCJhY3RpdmVUb29sQ2FsbHMiLCJvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzIiwiU2V0IiwiY2FuQ2xvc2UiLCJmaW5pc2hDaHVuayIsImF0dGVtcHRDbG9zZSIsImZvcndhcmRTdHJlYW0iLCJjaHVua1R5cGUiLCJ0b29sRXhlY3V0aW9uSWQiLCJhZGQiLCJkZWxldGUiLCJwaXBlVG8iLCJXcml0YWJsZVN0cmVhbSIsIm9yaWdpbmFsR2VuZXJhdGVJZDQiLCJzdHJlYW1UZXh0IiwiZXhwZXJpbWVudGFsX3Rvb2xDYWxsU3RyZWFtaW5nIiwib25DaHVuayIsInN0YXJ0U3RlcCIsIndhcm5pbmdzMiIsInJhd1Jlc3BvbnNlMiIsInJlcXVlc3QyIiwic3RhcnRUaW1lc3RhbXBNczIiLCJkb1N0cmVhbVNwYW4zIiwiRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQiLCJyZXNvbHZlRmluaXNoUmVhc29uIiwiZmluaXNoUmVhc29uUHJvbWlzZSIsInJlc29sdmVUZXh0IiwidGV4dFByb21pc2UiLCJyZXNvbHZlVG9vbENhbGxzIiwidG9vbENhbGxzUHJvbWlzZSIsInJlc29sdmVUb29sUmVzdWx0cyIsInRvb2xSZXN1bHRzUHJvbWlzZSIsInJlc29sdmVTdGVwcyIsInN0ZXBzUHJvbWlzZSIsInJlc29sdmVSZXF1ZXN0IiwicmVxdWVzdFByb21pc2UiLCJyZXNvbHZlUmVzcG9uc2VNZXNzYWdlcyIsInJlc3BvbnNlTWVzc2FnZXNQcm9taXNlIiwic3RpdGNoYWJsZVN0cmVhbSIsImNsb3NlU3RpdGNoYWJsZVN0cmVhbSIsInN0ZXBSZXN1bHRzIiwiYWRkU3RlcFN0cmVhbSIsInN0YXJ0VGltZXN0YW1wIiwiY3VycmVudFN0ZXAiLCJwcmV2aW91c1N0ZXBUZXh0Iiwic3RlcFJlcXVlc3QiLCJoYXNMZWFkaW5nV2hpdGVzcGFjZSIsInN0ZXBUb29sQ2FsbHMiLCJzdGVwVG9vbFJlc3VsdHMiLCJzdGVwRmluaXNoUmVhc29uIiwic3RlcFVzYWdlIiwic3RlcFByb3ZpZGVyTWV0YWRhdGEiLCJzdGVwRmlyc3RDaHVuayIsImZ1bGxTdGVwVGV4dCIsInN0ZXBMb2dQcm9icyIsInN0ZXBSZXNwb25zZSIsImNodW5rQnVmZmVyIiwiY2h1bmtUZXh0UHVibGlzaGVkIiwiaW5XaGl0ZXNwYWNlUHJlZml4IiwiaGFzV2hpdGVzcGFjZVN1ZmZpeCIsInB1Ymxpc2hUZXh0Q2h1bmsiLCJ0cmltbWVkQ2h1bmtUZXh0IiwibXNUb0ZpbmlzaCIsInN0ZXBUb29sQ2FsbHNKc29uIiwiY29tYmluZWRVc2FnZSIsInN0YXJ0VGltZXN0YW1wMiIsInRlZVN0cmVhbSIsInRlZSIsInRvQUlTdHJlYW0iLCJjYWxsYmFja3MiLCJ0b0RhdGFTdHJlYW1JbnRlcm5hbCIsImdldEVycm9yTWVzc2FnZTMiLCJzZW5kVXNhZ2UiLCJhZ2dyZWdhdGVkUmVzcG9uc2UiLCJjYWxsYmFja1RyYW5zZm9ybWVyIiwib25TdGFydCIsIm9uVG9rZW4iLCJvblRleHQiLCJvbkNvbXBsZXRpb24iLCJvbkZpbmFsIiwic3RyZWFtUGFydHNUcmFuc2Zvcm1lciIsInBpcGVBSVN0cmVhbVRvUmVzcG9uc2UiLCJwaXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UiLCJ0b0RhdGFTdHJlYW0iLCJ0b0FJU3RyZWFtUmVzcG9uc2UiLCJ0b0RhdGFTdHJlYW1SZXNwb25zZSIsImV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0IiwiZXhwZXJpbWVudGFsX3dyYXBMYW5ndWFnZU1vZGVsIiwibWlkZGxld2FyZSIsInRyYW5zZm9ybVBhcmFtcyIsIndyYXBHZW5lcmF0ZSIsIndyYXBTdHJlYW0iLCJwcm92aWRlcklkIiwiZG9UcmFuc2Zvcm0iLCJwYXJhbXMiLCJzcGVjaWZpY2F0aW9uVmVyc2lvbiIsInRyYW5zZm9ybWVkUGFyYW1zIiwiTm9TdWNoTW9kZWxFcnJvcjIiLCJleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIiLCJsYW5ndWFnZU1vZGVscyIsInRleHRFbWJlZGRpbmdNb2RlbHMiLCJmYWxsYmFja1Byb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbCIsIm1vZGVsVHlwZSIsInRleHRFbWJlZGRpbmdNb2RlbCIsIkFJU0RLRXJyb3IxMSIsIk5vU3VjaE1vZGVsRXJyb3IzIiwibmFtZTEwIiwibWFya2VyMTAiLCJzeW1ib2wxMCIsIl9hMTAiLCJOb1N1Y2hQcm92aWRlckVycm9yIiwiYXZhaWxhYmxlUHJvdmlkZXJzIiwiZXJyb3JOYW1lIiwiaXNOb1N1Y2hQcm92aWRlckVycm9yIiwiTm9TdWNoTW9kZWxFcnJvcjQiLCJleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSIsInByb3ZpZGVycyIsInJlZ2lzdHJ5IiwiRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkiLCJyZWdpc3RlclByb3ZpZGVyIiwiZXhwZXJpbWVudGFsX2NyZWF0ZU1vZGVsUmVnaXN0cnkiLCJnZXRQcm92aWRlciIsInNwbGl0SWQiLCJpbmRleE9mIiwidGV4dEVtYmVkZGluZyIsImNvc2luZVNpbWlsYXJpdHkiLCJ2ZWN0b3IxIiwidmVjdG9yMiIsImRvdFByb2R1Y3QiLCJtYWduaXR1ZGUiLCJhY2N1bXVsYXRvciIsInZlY3RvciIsIk1hdGgiLCJzcXJ0IiwiY3JlYXRlUGFyc2VyIiwiY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lciIsImN1c3RvbVBhcnNlciIsInRleHREZWNvZGVyIiwiZXZlbnRTb3VyY2VQYXJzZXIiLCJldmVudCIsInRlcm1pbmF0ZSIsInBhcnNlZE1lc3NhZ2UiLCJmZWVkIiwiY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIiLCJjYiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJpc09wZW5BSUNhbGxiYWNrcyIsImlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIiwidHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIiLCJpc1N0cmVhbVN0YXJ0IiwiQUlTdHJlYW0iLCJib2R5IiwiZXJyb3JUZXh0IiwicmVzcG9uc2VCb2R5U3RyZWFtIiwiY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSIsInJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUiLCJpdGVyYWJsZSIsIml0IiwicmV0dXJuIiwiZm9ybWF0U3RyZWFtUGFydDIiLCJIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMiLCJTdHJlYW1EYXRhMiIsImVuY29kZXIiLCJ3YXJuaW5nVGltZW91dCIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsImNsZWFyVGltZW91dCIsImFwcGVuZCIsImFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uIiwiY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyIiwiZGVjb2RlciIsImV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhIiwicGFyc2VBbnRocm9waWNTdHJlYW0iLCJwcmV2aW91cyIsImpzb24iLCJjb21wbGV0aW9uIiwiZGVsdGEiLCJzdHJlYW1hYmxlIiwiQW50aHJvcGljU3RyZWFtIiwiZm9ybWF0U3RyZWFtUGFydDMiLCJBc3Npc3RhbnRSZXNwb25zZSIsInRocmVhZElkIiwibWVzc2FnZUlkIiwicHJvY2VzczIiLCJzZW5kTWVzc2FnZSIsInNlbmREYXRhTWVzc2FnZSIsInNlbmRFcnJvciIsImV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSIsImFzRGVsdGFJdGVyYWJsZSIsImV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmsiLCJjaHVua1RleHQiLCJjaHVua0pTT04iLCJBV1NCZWRyb2NrQW50aHJvcGljTWVzc2FnZXNTdHJlYW0iLCJBV1NCZWRyb2NrU3RyZWFtIiwiQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbSIsIkFXU0JlZHJvY2tDb2hlcmVTdHJlYW0iLCJBV1NCZWRyb2NrTGxhbWEyU3RyZWFtIiwiZ2VuZXJhdGlvbiIsInV0ZjhEZWNvZGVyIiwicHJvY2Vzc0xpbmVzIiwibGluZXMiLCJpc19maW5pc2hlZCIsInJlYWRBbmRQcm9jZXNzTGluZXMiLCJzZWdtZW50IiwibGluZXNBcnJheSIsInBvcCIsImNyZWF0ZVBhcnNlcjIiLCJzdHJlYW1hYmxlMiIsImV2ZW50VHlwZSIsIkNvaGVyZVN0cmVhbSIsInN0cmVhbWFibGUzIiwiY2FuZGlkYXRlcyIsImZpcnN0UGFydCIsIkdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbSIsImNyZWF0ZVBhcnNlcjMiLCJ0cmltU3RhcnRPZlN0cmVhbSIsInRva2VuIiwiZ2VuZXJhdGVkX3RleHQiLCJIdWdnaW5nRmFjZVN0cmVhbSIsIklua2VlcFN0cmVhbSIsImNoYXRfc2Vzc2lvbl9pZCIsInJlY29yZHNfY2l0ZWQiLCJpbmtlZXBFdmVudFBhcnNlciIsIm9uUmVjb3Jkc0NpdGVkIiwiaW5rZWVwTWVzc2FnZUNodW5rIiwiY29udGVudF9jaHVuayIsInBhc3NUaHJvdWdoQ2FsbGJhY2tzIiwiaW5rZWVwT25GaW5hbE1ldGFkYXRhIiwibGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyIsImZvcndhcmRBSU1lc3NhZ2VDaHVuayIsImRhdGFTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsIml0ZW0iLCJsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyIsInRvRGF0YVN0cmVhbTIiLCJ0b0RhdGFTdHJlYW1SZXNwb25zZTIiLCJ0b1JlYWRhYmxlU3RyZWFtIiwiTGFuZ0NoYWluU3RyZWFtIiwid3JpdGVyIiwid3JpdGFibGUiLCJnZXRXcml0ZXIiLCJydW5zIiwiaGFuZGxlRXJyb3IiLCJlIiwicnVuSWQiLCJyZWFkeSIsImFib3J0IiwiaGFuZGxlU3RhcnQiLCJoYW5kbGVFbmQiLCJyZWFkYWJsZSIsImhhbmRsZXJzIiwiaGFuZGxlTExNTmV3VG9rZW4iLCJoYW5kbGVMTE1TdGFydCIsIl9sbG0iLCJfcHJvbXB0cyIsImhhbmRsZUxMTUVuZCIsIl9vdXRwdXQiLCJoYW5kbGVMTE1FcnJvciIsImhhbmRsZUNoYWluU3RhcnQiLCJfY2hhaW4iLCJfaW5wdXRzIiwiaGFuZGxlQ2hhaW5FbmQiLCJfb3V0cHV0cyIsImhhbmRsZUNoYWluRXJyb3IiLCJoYW5kbGVUb29sU3RhcnQiLCJfdG9vbCIsIl9pbnB1dCIsImhhbmRsZVRvb2xFbmQiLCJoYW5kbGVUb29sRXJyb3IiLCJzdHJlYW1hYmxlNCIsImNob2ljZXMiLCJNaXN0cmFsU3RyZWFtIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiZm9ybWF0U3RyZWFtUGFydDQiLCJwYXJzZU9wZW5BSVN0cmVhbSIsImV4dHJhY3QiLCJjaHVua1RvVGV4dCIsInN0cmVhbWFibGU1IiwiY3JlYXRlZCIsImdldERhdGUiLCJjaG9pY2UiLCJmdW5jdGlvbl9jYWxsIiwiZnVuY3Rpb25DYWxsIiwidG9vbF9jYWxscyIsImZ1bmN0aW9uIiwiZmluaXNoX3JlYXNvbiIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsIl9pIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbiIsIl9vIiwiX3AiLCJfcSIsIl9yIiwiaXNDaGF0Q29tcGxldGlvbkNodW5rIiwiaXNUZXh0IiwiYXJndW1lbnRzIiwiY2xlYW51cEFyZ3VtZW50cyIsImlzQ29tcGxldGlvbiIsImFyZ3VtZW50Q2h1bmsiLCJlc2NhcGVkUGFydGlhbEpzb24iLCJyZXBsYWNlIiwiX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCIsIk9wZW5BSVN0cmVhbSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwiZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInBheWxvYWQiLCJuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJhcmd1bWVudHNQYXlsb2FkIiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsInRjIiwiZmlsdGVyZWRDYWxsYmFja3MiLCJvcGVuQUlTdHJlYW0iLCJSZXBsaWNhdGVTdHJlYW0iLCJldmVudFN0cmVhbSIsIm1ldGhvZCIsIkFjY2VwdCIsInN0cmVhbVRvUmVzcG9uc2UiLCJwcm9jZXNzZWRTdHJlYW0iLCJTdHJlYW1pbmdUZXh0UmVzcG9uc2UiLCJnZW5lcmF0ZUlkMiIsIm5hbm9pZCIsIkxhbmdDaGFpbkFkYXB0ZXIiLCJMbGFtYUluZGV4QWRhcHRlciIsIlN0cmVhbURhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60/node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/.pnpm/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60/node_modules/ai/dist/index.mjs":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60/node_modules/ai/dist/index.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LlamaIndexAdapter: () => (/* binding */ llamaindex_adapter_exports),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData2),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.jsonSchema),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parseStreamPart),\n/* harmony export */   processDataProtocolResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(action-browser)/./node_modules/.pnpm/@ai-sdk+ui-utils@0.0.50_zod@3.25.76/node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/.pnpm/@ai-sdk+provider-utils@1.0.22_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @opentelemetry/api */ \"(action-browser)/./node_modules/.pnpm/next@14.1.0_@opentelemetry+_95d5a05ac7ec0d735f17a907e734f3d8/node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventsource-parser */ \"(action-browser)/./node_modules/.pnpm/eventsource-parser@1.1.2/node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name11 in all)__defProp(target, name11, {\n        get: all[name11],\n        enumerable: true\n    });\n};\n// streams/index.ts\n\n\n// core/index.ts\n\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name,\n            message\n        });\n        this[_a] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isRetryError(error) {\n        return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            reason: this.reason,\n            lastError: this.lastError,\n            errors: this.errors\n        };\n    }\n};\n_a = symbol;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({ operationId, telemetry }) {\n    return {\n        // standardized operation and resource name:\n        \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n        \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n        // detailed, AI SDK specific data:\n        \"ai.operationId\": operationId,\n        \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n    };\n}\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {\n    var _a11;\n    return {\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // settings:\n        ...Object.entries(settings).reduce((attributes, [key, value])=>{\n            attributes[`ai.settings.${key}`] = value;\n            return attributes;\n        }, {}),\n        // add metadata as attributes:\n        ...Object.entries((_a11 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a11 : {}).reduce((attributes, [key, value])=>{\n            attributes[`ai.telemetry.metadata.${key}`] = value;\n            return attributes;\n        }, {}),\n        // request headers\n        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{\n            if (value !== void 0) {\n                attributes[`ai.request.headers.${key}`] = value;\n            }\n            return attributes;\n        }, {})\n    };\n}\n// core/telemetry/get-tracer.ts\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n    startSpan () {\n        return noopSpan;\n    },\n    startActiveSpan (name11, arg1, arg2, arg3) {\n        if (typeof arg1 === \"function\") {\n            return arg1(noopSpan);\n        }\n        if (typeof arg2 === \"function\") {\n            return arg2(noopSpan);\n        }\n        if (typeof arg3 === \"function\") {\n            return arg3(noopSpan);\n        }\n    }\n};\nvar noopSpan = {\n    spanContext () {\n        return noopSpanContext;\n    },\n    setAttribute () {\n        return this;\n    },\n    setAttributes () {\n        return this;\n    },\n    addEvent () {\n        return this;\n    },\n    addLink () {\n        return this;\n    },\n    addLinks () {\n        return this;\n    },\n    setStatus () {\n        return this;\n    },\n    updateName () {\n        return this;\n    },\n    end () {\n        return this;\n    },\n    isRecording () {\n        return false;\n    },\n    recordException () {\n        return this;\n    }\n};\nvar noopSpanContext = {\n    traceId: \"\",\n    spanId: \"\",\n    traceFlags: 0\n};\n// core/telemetry/get-tracer.ts\nfunction getTracer({ isEnabled = false, tracer } = {}) {\n    if (!isEnabled) {\n        return noopTracer;\n    }\n    if (tracer) {\n        return tracer;\n    }\n    return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.trace.getTracer(\"ai\");\n}\n// core/telemetry/record-span.ts\n\nfunction recordSpan({ name: name11, tracer, attributes, fn, endWhenDone = true }) {\n    return tracer.startActiveSpan(name11, {\n        attributes\n    }, async (span)=>{\n        try {\n            const result = await fn(span);\n            if (endWhenDone) {\n                span.end();\n            }\n            return result;\n        } catch (error) {\n            try {\n                if (error instanceof Error) {\n                    span.recordException({\n                        name: error.name,\n                        message: error.message,\n                        stack: error.stack\n                    });\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR,\n                        message: error.message\n                    });\n                } else {\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR\n                    });\n                }\n            } finally{\n                span.end();\n            }\n            throw error;\n        }\n    });\n}\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({ telemetry, attributes }) {\n    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n        return {};\n    }\n    return Object.entries(attributes).reduce((attributes2, [key, value])=>{\n        if (value === void 0) {\n            return attributes2;\n        }\n        if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n                return attributes2;\n            }\n            const result = value.input();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n                return attributes2;\n            }\n            const result = value.output();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        return {\n            ...attributes2,\n            [key]: value\n        };\n    }, {});\n}\n// core/embed/embed.ts\nasync function embed({ model, value, maxRetries, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embed\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embed\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.value\": {\n                    input: ()=>JSON.stringify(value)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const { embedding, usage, rawResponse } = await retry(()=>// nested spans to align with the embedMany telemetry data:\n                recordSpan({\n                    name: \"ai.embed.doEmbed\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.embed.doEmbed\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.values\": {\n                                input: ()=>[\n                                        JSON.stringify(value)\n                                    ]\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doEmbedSpan)=>{\n                        var _a11;\n                        const modelResponse = await model.doEmbed({\n                            values: [\n                                value\n                            ],\n                            abortSignal,\n                            headers\n                        });\n                        const embedding2 = modelResponse.embeddings[0];\n                        const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                            tokens: NaN\n                        };\n                        doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.embeddings\": {\n                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))\n                                },\n                                \"ai.usage.tokens\": usage2.tokens\n                            }\n                        }));\n                        return {\n                            embedding: embedding2,\n                            usage: usage2,\n                            rawResponse: modelResponse.rawResponse\n                        };\n                    }\n                }));\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embedding\": {\n                        output: ()=>JSON.stringify(embedding)\n                    },\n                    \"ai.usage.tokens\": usage.tokens\n                }\n            }));\n            return new DefaultEmbedResult({\n                value,\n                embedding,\n                usage,\n                rawResponse\n            });\n        }\n    });\n}\nvar DefaultEmbedResult = class {\n    constructor(options){\n        this.value = options.value;\n        this.embedding = options.embedding;\n        this.usage = options.usage;\n        this.rawResponse = options.rawResponse;\n    }\n};\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n    if (chunkSize <= 0) {\n        throw new Error(\"chunkSize must be greater than 0\");\n    }\n    const result = [];\n    for(let i = 0; i < array.length; i += chunkSize){\n        result.push(array.slice(i, i + chunkSize));\n    }\n    return result;\n}\n// core/embed/embed-many.ts\nasync function embedMany({ model, values, maxRetries, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embedMany\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embedMany\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                    input: ()=>values.map((value)=>JSON.stringify(value))\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n            if (maxEmbeddingsPerCall == null) {\n                const { embeddings: embeddings2, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>values.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a11;\n                            const modelResponse = await model.doEmbed({\n                                values,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings3 = modelResponse.embeddings;\n                            const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings3,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                span.setAttributes(selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.embeddings\": {\n                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                    }\n                }));\n                return new DefaultEmbedManyResult({\n                    values,\n                    embeddings: embeddings2,\n                    usage\n                });\n            }\n            const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n            const embeddings = [];\n            let tokens = 0;\n            for (const chunk of valueChunks){\n                const { embeddings: responseEmbeddings, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>chunk.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a11;\n                            const modelResponse = await model.doEmbed({\n                                values: chunk,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings2 = modelResponse.embeddings;\n                            const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings2,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                embeddings.push(...responseEmbeddings);\n                tokens += usage.tokens;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embeddings\": {\n                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": tokens\n                }\n            }));\n            return new DefaultEmbedManyResult({\n                values,\n                embeddings,\n                usage: {\n                    tokens\n                }\n            });\n        }\n    });\n}\nvar DefaultEmbedManyResult = class {\n    constructor(options){\n        this.values = options.values;\n        this.embeddings = options.embeddings;\n        this.usage = options.usage;\n    }\n};\n// core/generate-object/generate-object.ts\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name: name2,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isDownloadError(error) {\n        return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            statusCode: this.statusCode,\n            statusText: this.statusText,\n            cause: this.cause\n        };\n    }\n};\n_a2 = symbol2;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a11;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a11 = response.headers.get(\"content-type\")) != null ? _a11 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a3] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidDataContentError(error) {\n        return error instanceof Error && error.name === name3 && error.content != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            cause: this.cause,\n            content: this.content\n        };\n    }\n};\n_a3 = symbol3;\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(Uint8Array),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(ArrayBuffer),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a11, _b;\n        return (_b = (_a11 = globalThis.Buffer) == null ? void 0 : _a11.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n    try {\n        return new TextDecoder().decode(uint8Array);\n    } catch (error) {\n        throw new Error(\"Error decoding Uint8Array to text\");\n    }\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name4,\n            message\n        });\n        this[_a4] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n_a4 = symbol4;\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mimeType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mimeType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, modelSupportsUrl = ()=>false, downloadImplementation = download }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);\n    return [\n        ...prompt.system != null ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))\n    ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\").map((part)=>{\n                        const { experimental_providerMetadata, ...rest } = part;\n                        return {\n                            ...rest,\n                            providerMetadata: experimental_providerMetadata\n                        };\n                    }),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            content: part.experimental_content,\n                            isError: part.isError,\n                            providerMetadata: part.experimental_providerMetadata\n                        })),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").filter((part)=>!(part.type === \"image\" && modelSupportsImageUrls === true)).map((part)=>part.type === \"image\" ? part.image : part.data).map((part)=>// support string urls:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL).filter((url)=>!modelSupportsUrl(url));\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerMetadata: part.experimental_providerMetadata\n        };\n    }\n    let mimeType = part.mimeType;\n    let data;\n    let content;\n    let normalizedData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            data = part.image;\n            break;\n        case \"file\":\n            data = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    try {\n        content = typeof data === \"string\" ? new URL(data) : data;\n    } catch (error) {\n        content = data;\n    }\n    if (content instanceof URL) {\n        if (content.protocol === \"data:\") {\n            const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());\n            if (dataUrlMimeType == null || base64Content == null) {\n                throw new Error(`Invalid data URL format in part ${type}`);\n            }\n            mimeType = dataUrlMimeType;\n            normalizedData = convertDataContentToUint8Array(base64Content);\n        } else {\n            const downloadedFile = downloadedAssets[content.toString()];\n            if (downloadedFile) {\n                normalizedData = downloadedFile.data;\n                mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n            } else {\n                normalizedData = content;\n            }\n        }\n    } else {\n        normalizedData = convertDataContentToUint8Array(content);\n    }\n    switch(type){\n        case \"image\":\n            if (mimeType == null && normalizedData instanceof Uint8Array) {\n                mimeType = detectImageMimeType(normalizedData);\n            }\n            return {\n                type: \"image\",\n                image: normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n        case \"file\":\n            if (mimeType == null) {\n                throw new Error(`Mime type is missing for file part`);\n            }\n            return {\n                type: \"file\",\n                data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n    }\n}\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name: name5,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a5] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidArgumentError(error) {\n        return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            parameter: this.parameter,\n            value: this.value\n        };\n    }\n};\n_a5 = symbol5;\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/prompt/standardize-prompt.ts\n\n\n\n// core/prompt/message.ts\n\n// core/types/provider-metadata.ts\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.lazy(()=>zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.null(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.number(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.record(zod__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.array(jsonValueSchema)\n    ]));\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.record(zod__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod__WEBPACK_IMPORTED_MODULE_3__.z.record(zod__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema));\n// core/prompt/content-part.ts\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.array(zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n        text: zod__WEBPACK_IMPORTED_MODULE_3__.z.string()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image\"),\n        data: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n    })\n]));\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image\"),\n    image: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_3__.z.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n    content: toolResultContentSchema.optional(),\n    isError: zod__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"user\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.array(zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"assistant\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.array(zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            textPartSchema,\n            toolCallPartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.array(toolResultPartSchema),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    coreSystemMessageSchema,\n    coreUserMessageSchema,\n    coreAssistantMessageSchema,\n    coreToolMessageSchema\n]);\n// core/prompt/detect-prompt-type.ts\nfunction detectPromptType(prompt) {\n    if (!Array.isArray(prompt)) {\n        return \"other\";\n    }\n    if (prompt.length === 0) {\n        return \"messages\";\n    }\n    const characteristics = prompt.map(detectSingleMessageCharacteristics);\n    if (characteristics.some((c)=>c === \"has-ui-specific-parts\")) {\n        return \"ui-messages\";\n    } else if (characteristics.every((c)=>c === \"has-core-specific-parts\" || c === \"message\")) {\n        return \"messages\";\n    } else {\n        return \"other\";\n    }\n}\nfunction detectSingleMessageCharacteristics(message) {\n    if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n    message.role === \"data\" || // UI-only role\n    \"toolInvocations\" in message || // UI-specific field\n    \"experimental_attachments\" in message)) {\n        return \"has-ui-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n    \"experimental_providerMetadata\" in message)) {\n        return \"has-core-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\n        \"system\",\n        \"user\",\n        \"assistant\",\n        \"tool\"\n    ].includes(message.role)) {\n        return \"message\";\n    } else {\n        return \"other\";\n    }\n}\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n    var _a11, _b, _c;\n    const parts = [];\n    for (const attachment of attachments){\n        let url;\n        try {\n            url = new URL(attachment.url);\n        } catch (error) {\n            throw new Error(`Invalid URL: ${attachment.url}`);\n        }\n        switch(url.protocol){\n            case \"http:\":\n            case \"https:\":\n                {\n                    if ((_a11 = attachment.contentType) == null ? void 0 : _a11.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: url\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: url,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            case \"data:\":\n                {\n                    let header;\n                    let base64Content;\n                    let mimeType;\n                    try {\n                        [header, base64Content] = attachment.url.split(\",\");\n                        mimeType = header.split(\";\")[0].split(\":\")[1];\n                    } catch (error) {\n                        throw new Error(`Error processing data URL: ${attachment.url}`);\n                    }\n                    if (mimeType == null || base64Content == null) {\n                        throw new Error(`Invalid data URL format: ${attachment.url}`);\n                    }\n                    if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content)\n                        });\n                    } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n                        parts.push({\n                            type: \"text\",\n                            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: base64Content,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                }\n        }\n    }\n    return parts;\n}\n// core/prompt/message-conversion-error.ts\n\nvar name6 = \"AI_MessageConversionError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name6,\n            message\n        });\n        this[_a6] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n    var _a11;\n    const tools = (_a11 = options == null ? void 0 : options.tools) != null ? _a11 : {};\n    const coreMessages = [];\n    for (const message of messages){\n        const { role, content, toolInvocations, experimental_attachments } = message;\n        switch(role){\n            case \"system\":\n                {\n                    coreMessages.push({\n                        role: \"system\",\n                        content\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    coreMessages.push({\n                        role: \"user\",\n                        content: experimental_attachments ? [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...attachmentsToParts(experimental_attachments)\n                        ] : content\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (toolInvocations == null) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                        break;\n                    }\n                    coreMessages.push({\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...toolInvocations.map(({ toolCallId, toolName, args })=>({\n                                    type: \"tool-call\",\n                                    toolCallId,\n                                    toolName,\n                                    args\n                                }))\n                        ]\n                    });\n                    coreMessages.push({\n                        role: \"tool\",\n                        content: toolInvocations.map((toolInvocation)=>{\n                            if (!(\"result\" in toolInvocation)) {\n                                throw new MessageConversionError({\n                                    originalMessage: message,\n                                    message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                });\n                            }\n                            const { toolCallId, toolName, result } = toolInvocation;\n                            const tool2 = tools[toolName];\n                            return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result: tool2.experimental_toToolResultContent(result),\n                                experimental_content: tool2.experimental_toToolResultContent(result)\n                            } : {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result\n                            };\n                        })\n                    });\n                    break;\n                }\n            case \"function\":\n            case \"data\":\n            case \"tool\":\n                {\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return coreMessages;\n}\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({ prompt, tools }) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string\"\n        });\n    }\n    if (prompt.prompt != null) {\n        if (typeof prompt.prompt !== \"string\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"prompt must be a string\"\n            });\n        }\n        return {\n            type: \"prompt\",\n            system: prompt.system,\n            messages: [\n                {\n                    role: \"user\",\n                    content: prompt.prompt\n                }\n            ]\n        };\n    }\n    if (prompt.messages != null) {\n        const promptType = detectPromptType(prompt.messages);\n        if (promptType === \"other\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\"\n            });\n        }\n        const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n            tools\n        }) : prompt.messages;\n        const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n            value: messages,\n            schema: zod__WEBPACK_IMPORTED_MODULE_3__.z.array(coreMessageSchema)\n        });\n        if (!validationResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\",\n                cause: validationResult.error\n            });\n        }\n        return {\n            type: \"messages\",\n            messages,\n            system: prompt.system\n        };\n    }\n    throw new Error(\"unreachable\");\n}\n// core/types/usage.ts\nfunction calculateLanguageModelUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, { contentType, dataStreamVersion }) {\n    var _a11;\n    const headers = new Headers((_a11 = init == null ? void 0 : init.headers) != null ? _a11 : {});\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", contentType);\n    }\n    if (dataStreamVersion !== void 0) {\n        headers.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n    }\n    return headers;\n}\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({ prompt, schema, schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0, schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX }) {\n    return [\n        prompt != null && prompt.length > 0 ? prompt : void 0,\n        prompt != null && prompt.length > 0 ? \"\" : void 0,\n        // add a newline if prompt is not null\n        schemaPrefix,\n        schema != null ? JSON.stringify(schema) : void 0,\n        schemaSuffix\n    ].filter((line)=>line != null).join(\"\\n\");\n}\n// core/generate-object/no-object-generated-error.ts\n\nvar name7 = \"AI_NoObjectGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    // used in isInstance\n    constructor({ message = \"No object generated.\" } = {}){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isNoObjectGeneratedError(error) {\n        return error instanceof Error && error.name === name7;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            cause: this.cause,\n            message: this.message,\n            stack: this.stack\n        };\n    }\n};\n_a7 = symbol7;\n// core/generate-object/output-strategy.ts\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n    const transformedStream = source.pipeThrough(new TransformStream(transformer));\n    transformedStream[Symbol.asyncIterator] = ()=>{\n        const reader = transformedStream.getReader();\n        return {\n            async next () {\n                const { done, value } = await reader.read();\n                return done ? {\n                    done: true,\n                    value: void 0\n                } : {\n                    done: false,\n                    value\n                };\n            }\n        };\n    };\n    return transformedStream;\n}\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n    type: \"no-schema\",\n    jsonSchema: void 0,\n    validatePartialResult ({ value, textDelta }) {\n        return {\n            success: true,\n            value: {\n                partial: value,\n                textDelta\n            }\n        };\n    },\n    validateFinalResult (value) {\n        return value === void 0 ? {\n            success: false,\n            error: new NoObjectGeneratedError()\n        } : {\n            success: true,\n            value\n        };\n    },\n    createElementStream () {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n            functionality: \"element streams in no-schema mode\"\n        });\n    }\n};\nvar objectOutputStrategy = (schema)=>({\n        type: \"object\",\n        jsonSchema: schema.jsonSchema,\n        validatePartialResult ({ value, textDelta }) {\n            return {\n                success: true,\n                value: {\n                    // Note: currently no validation of partial results:\n                    partial: value,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                value,\n                schema\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in object mode\"\n            });\n        }\n    });\nvar arrayOutputStrategy = (schema)=>{\n    const { $schema, ...itemSchema } = schema.jsonSchema;\n    return {\n        type: \"enum\",\n        // wrap in object that contains array of elements, since most LLMs will not\n        // be able to generate an array directly:\n        // possible future optimization: use arrays directly when model supports grammar-guided generation\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                elements: {\n                    type: \"array\",\n                    items: itemSchema\n                }\n            },\n            required: [\n                \"elements\"\n            ],\n            additionalProperties: false\n        },\n        validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {\n            var _a11;\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            const resultArray = [];\n            for(let i = 0; i < inputArray.length; i++){\n                const element = inputArray[i];\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (i === inputArray.length - 1 && !isFinalDelta) {\n                    continue;\n                }\n                if (!result.success) {\n                    return result;\n                }\n                resultArray.push(result.value);\n            }\n            const publishedElementCount = (_a11 = latestObject == null ? void 0 : latestObject.length) != null ? _a11 : 0;\n            let textDelta = \"\";\n            if (isFirstDelta) {\n                textDelta += \"[\";\n            }\n            if (publishedElementCount > 0) {\n                textDelta += \",\";\n            }\n            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(\",\");\n            if (isFinalDelta) {\n                textDelta += \"]\";\n            }\n            return {\n                success: true,\n                value: {\n                    partial: resultArray,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            for (const element of inputArray){\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (!result.success) {\n                    return result;\n                }\n            }\n            return {\n                success: true,\n                value: inputArray\n            };\n        },\n        createElementStream (originalStream) {\n            let publishedElements = 0;\n            return createAsyncIterableStream(originalStream, {\n                transform (chunk, controller) {\n                    switch(chunk.type){\n                        case \"object\":\n                            {\n                                const array = chunk.object;\n                                for(; publishedElements < array.length; publishedElements++){\n                                    controller.enqueue(array[publishedElements]);\n                                }\n                                break;\n                            }\n                        case \"text-delta\":\n                        case \"finish\":\n                            break;\n                        case \"error\":\n                            controller.error(chunk.error);\n                            break;\n                        default:\n                            {\n                                const _exhaustiveCheck = chunk;\n                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                            }\n                    }\n                }\n            });\n        }\n    };\n};\nvar enumOutputStrategy = (enumValues)=>{\n    return {\n        type: \"enum\",\n        // wrap in object that contains result, since most LLMs will not\n        // be able to generate an enum value directly:\n        // possible future optimization: use enums directly when model supports top-level enums\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"string\",\n                    enum: enumValues\n                }\n            },\n            required: [\n                \"result\"\n            ],\n            additionalProperties: false\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            return enumValues.includes(result) ? {\n                success: true,\n                value: result\n            } : {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                    value,\n                    cause: \"value must be a string in the enum\"\n                })\n            };\n        },\n        validatePartialResult () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"partial results in enum mode\"\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in enum mode\"\n            });\n        }\n    };\n};\nfunction getOutputStrategy({ output, schema, enumValues }) {\n    switch(output){\n        case \"object\":\n            return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(schema));\n        case \"array\":\n            return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(schema));\n        case \"enum\":\n            return enumOutputStrategy(enumValues);\n        case \"no-schema\":\n            return noSchemaOutputStrategy;\n        default:\n            {\n                const _exhaustiveCheck = output;\n                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n            }\n    }\n}\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({ output, mode, schema, schemaName, schemaDescription, enumValues }) {\n    if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n        throw new InvalidArgumentError({\n            parameter: \"output\",\n            value: output,\n            message: \"Invalid output type.\"\n        });\n    }\n    if (output === \"no-schema\") {\n        if (mode === \"auto\" || mode === \"tool\") {\n            throw new InvalidArgumentError({\n                parameter: \"mode\",\n                value: mode,\n                message: 'Mode must be \"json\" for no-schema output.'\n            });\n        }\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for no-schema output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for no-schema output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for no-schema output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for no-schema output.\"\n            });\n        }\n    }\n    if (output === \"object\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is required for object output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for object output.\"\n            });\n        }\n    }\n    if (output === \"array\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Element schema is required for array output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for array output.\"\n            });\n        }\n    }\n    if (output === \"enum\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for enum output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for enum output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for enum output.\"\n            });\n        }\n        if (enumValues == null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are required for enum output.\"\n            });\n        }\n        for (const value of enumValues){\n            if (typeof value !== \"string\") {\n                throw new InvalidArgumentError({\n                    parameter: \"enumValues\",\n                    value,\n                    message: \"Enum values must be strings.\"\n                });\n            }\n        }\n    }\n}\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function generateObject({ model, enum: enumValues, // rename bc enum is reserved by typescript\nschema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, _internal: { generateId: generateId3 = originalGenerateId, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a11, _b;\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let result;\n            let finishReason;\n            let usage;\n            let warnings;\n            let rawResponse;\n            let response;\n            let request;\n            let logprobs;\n            let resultProviderMetadata;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>standardizedPrompt.type\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a12, _b2, _c, _d, _e, _f;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-json\",\n                                            schema: outputStrategy.jsonSchema,\n                                            name: schemaName,\n                                            description: schemaDescription\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat: standardizedPrompt.type,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    if (result2.text === void 0) {\n                                        throw new NoObjectGeneratedError();\n                                    }\n                                    const responseData = {\n                                        id: (_b2 = (_a12 = result2.response) == null ? void 0 : _a12.id) != null ? _b2 : generateId3(),\n                                        timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                                        modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                                    };\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // deprecated:\n                                            \"ai.finishReason\": result2.finishReason,\n                                            \"ai.result.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText: result2.text,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_a11 = generateResult.request) != null ? _a11 : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const inputFormat = standardizedPrompt.type;\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>inputFormat\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a12, _b2, _c, _d, _e, _f, _g, _h;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-tool\",\n                                            tool: {\n                                                type: \"function\",\n                                                name: schemaName != null ? schemaName : \"json\",\n                                                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                                parameters: outputStrategy.jsonSchema\n                                            }\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    const objectText = (_b2 = (_a12 = result2.toolCalls) == null ? void 0 : _a12[0]) == null ? void 0 : _b2.args;\n                                    if (objectText === void 0) {\n                                        throw new NoObjectGeneratedError();\n                                    }\n                                    const responseData = {\n                                        id: (_d = (_c = result2.response) == null ? void 0 : _c.id) != null ? _d : generateId3(),\n                                        timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                                        modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                                    };\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // deprecated:\n                                            \"ai.finishReason\": result2.finishReason,\n                                            \"ai.result.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_b = generateResult.request) != null ? _b : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n                text: result\n            });\n            if (!parseResult.success) {\n                throw parseResult.error;\n            }\n            const validationResult = outputStrategy.validateFinalResult(parseResult.value);\n            if (!validationResult.success) {\n                throw validationResult.error;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": finishReason,\n                    \"ai.response.object\": {\n                        output: ()=>JSON.stringify(validationResult.value)\n                    },\n                    \"ai.usage.promptTokens\": usage.promptTokens,\n                    \"ai.usage.completionTokens\": usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": finishReason,\n                    \"ai.result.object\": {\n                        output: ()=>JSON.stringify(validationResult.value)\n                    }\n                }\n            }));\n            return new DefaultGenerateObjectResult({\n                object: validationResult.value,\n                finishReason,\n                usage: calculateLanguageModelUsage(usage),\n                warnings,\n                request,\n                response: {\n                    ...response,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                },\n                logprobs,\n                providerMetadata: resultProviderMetadata\n            });\n        }\n    });\n}\nvar DefaultGenerateObjectResult = class {\n    constructor(options){\n        this.object = options.object;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.response = options.response;\n        this.request = options.request;\n        this.rawResponse = {\n            headers: options.response.headers\n        };\n        this.logprobs = options.logprobs;\n    }\n    toJsonResponse(init) {\n        var _a11;\n        return new Response(JSON.stringify(this.object), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"application/json; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_generateObject = generateObject;\n// core/generate-object/stream-object.ts\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n    constructor(){\n        this.status = {\n            type: \"pending\"\n        };\n        this._resolve = void 0;\n        this._reject = void 0;\n    }\n    get value() {\n        if (this.promise) {\n            return this.promise;\n        }\n        this.promise = new Promise((resolve, reject)=>{\n            if (this.status.type === \"resolved\") {\n                resolve(this.status.value);\n            } else if (this.status.type === \"rejected\") {\n                reject(this.status.error);\n            }\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        return this.promise;\n    }\n    resolve(value) {\n        var _a11;\n        this.status = {\n            type: \"resolved\",\n            value\n        };\n        if (this.promise) {\n            (_a11 = this._resolve) == null ? void 0 : _a11.call(this, value);\n        }\n    }\n    reject(error) {\n        var _a11;\n        this.status = {\n            type: \"rejected\",\n            error\n        };\n        if (this.promise) {\n            (_a11 = this._reject) == null ? void 0 : _a11.call(this, error);\n        }\n    }\n};\n// core/util/now.ts\nfunction now() {\n    var _a11, _b;\n    return (_b = (_a11 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a11.now()) != null ? _b : Date.now();\n}\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(init, { contentType, dataStreamVersion }) {\n    const headers = {};\n    if ((init == null ? void 0 : init.headers) != null) {\n        for (const [key, value] of Object.entries(init.headers)){\n            headers[key] = value;\n        }\n    }\n    if (headers[\"Content-Type\"] == null) {\n        headers[\"Content-Type\"] = contentType;\n    }\n    if (dataStreamVersion !== void 0) {\n        headers[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n    }\n    return headers;\n}\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({ response, status, statusText, headers, stream }) {\n    response.writeHead(status != null ? status : 200, statusText, headers);\n    const reader = stream.getReader();\n    const read = async ()=>{\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                response.write(value);\n            }\n        } catch (error) {\n            throw error;\n        } finally{\n            response.end();\n        }\n    };\n    read();\n}\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function streamObject({ model, schema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, onFinish, _internal: { generateId: generateId3 = originalGenerateId2, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    return recordSpan({\n        name: \"ai.streamObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.streamObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        endWhenDone: false,\n        fn: async (rootSpan)=>{\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let callOptions;\n            let transformer;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        callOptions = {\n                            mode: {\n                                type: \"object-json\",\n                                schema: outputStrategy.jsonSchema,\n                                name: schemaName,\n                                description: schemaDescription\n                            },\n                            ...prepareCallSettings(settings),\n                            inputFormat: standardizedPrompt.type,\n                            prompt: await convertToLanguageModelPrompt({\n                                prompt: standardizedPrompt,\n                                modelSupportsImageUrls: model.supportsImageUrls,\n                                modelSupportsUrl: model.supportsUrl\n                            }),\n                            providerMetadata,\n                            abortSignal,\n                            headers\n                        };\n                        transformer = {\n                            transform: (chunk, controller)=>{\n                                switch(chunk.type){\n                                    case \"text-delta\":\n                                        controller.enqueue(chunk.textDelta);\n                                        break;\n                                    case \"response-metadata\":\n                                    case \"finish\":\n                                    case \"error\":\n                                        controller.enqueue(chunk);\n                                        break;\n                                }\n                            }\n                        };\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        callOptions = {\n                            mode: {\n                                type: \"object-tool\",\n                                tool: {\n                                    type: \"function\",\n                                    name: schemaName != null ? schemaName : \"json\",\n                                    description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                    parameters: outputStrategy.jsonSchema\n                                }\n                            },\n                            ...prepareCallSettings(settings),\n                            inputFormat: standardizedPrompt.type,\n                            prompt: await convertToLanguageModelPrompt({\n                                prompt: standardizedPrompt,\n                                modelSupportsImageUrls: model.supportsImageUrls,\n                                modelSupportsUrl: model.supportsUrl\n                            }),\n                            providerMetadata,\n                            abortSignal,\n                            headers\n                        };\n                        transformer = {\n                            transform (chunk, controller) {\n                                switch(chunk.type){\n                                    case \"tool-call-delta\":\n                                        controller.enqueue(chunk.argsTextDelta);\n                                        break;\n                                    case \"response-metadata\":\n                                    case \"finish\":\n                                    case \"error\":\n                                        controller.enqueue(chunk);\n                                        break;\n                                }\n                            }\n                        };\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                    name: \"ai.streamObject.doStream\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.streamObject.doStream\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            \"ai.prompt.format\": {\n                                input: ()=>callOptions.inputFormat\n                            },\n                            \"ai.prompt.messages\": {\n                                input: ()=>JSON.stringify(callOptions.prompt)\n                            },\n                            \"ai.settings.mode\": mode,\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.system\": model.provider,\n                            \"gen_ai.request.model\": model.modelId,\n                            \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                            \"gen_ai.request.max_tokens\": settings.maxTokens,\n                            \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                            \"gen_ai.request.temperature\": settings.temperature,\n                            \"gen_ai.request.top_k\": settings.topK,\n                            \"gen_ai.request.top_p\": settings.topP\n                        }\n                    }),\n                    tracer,\n                    endWhenDone: false,\n                    fn: async (doStreamSpan2)=>({\n                            startTimestampMs: now2(),\n                            doStreamSpan: doStreamSpan2,\n                            result: await model.doStream(callOptions)\n                        })\n                }));\n            return new DefaultStreamObjectResult({\n                outputStrategy,\n                stream: stream.pipeThrough(new TransformStream(transformer)),\n                warnings,\n                rawResponse,\n                request: request != null ? request : {},\n                onFinish,\n                rootSpan,\n                doStreamSpan,\n                telemetry,\n                startTimestampMs,\n                modelId: model.modelId,\n                now: now2,\n                currentDate,\n                generateId: generateId3\n            });\n        }\n    });\n}\nvar DefaultStreamObjectResult = class {\n    constructor({ stream, warnings, rawResponse, request, outputStrategy, onFinish, rootSpan, doStreamSpan, telemetry, startTimestampMs, modelId, now: now2, currentDate, generateId: generateId3 }){\n        this.warnings = warnings;\n        this.rawResponse = rawResponse;\n        this.outputStrategy = outputStrategy;\n        this.request = Promise.resolve(request);\n        this.objectPromise = new DelayedPromise();\n        const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n        this.usage = usagePromise;\n        const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n        this.response = responsePromise;\n        const { resolve: resolveProviderMetadata, promise: providerMetadataPromise } = createResolvablePromise();\n        this.experimental_providerMetadata = providerMetadataPromise;\n        let usage;\n        let finishReason;\n        let providerMetadata;\n        let object;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let response = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const self = this;\n        this.originalStream = stream.pipeThrough(new TransformStream({\n            async transform (chunk, controller) {\n                var _a11, _b, _c;\n                if (isFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    isFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                        \"ai.stream.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                        \"ai.stream.msToFirstChunk\": msToFirstChunk\n                    });\n                }\n                if (typeof chunk === \"string\") {\n                    accumulatedText += chunk;\n                    textDelta += chunk;\n                    const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parsePartialJson)(accumulatedText);\n                    if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n                        const validationResult = outputStrategy.validatePartialResult({\n                            value: currentObjectJson,\n                            textDelta,\n                            latestObject,\n                            isFirstDelta,\n                            isFinalDelta: parseState === \"successful-parse\"\n                        });\n                        if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.isDeepEqualData)(latestObject, validationResult.value.partial)) {\n                            latestObjectJson = currentObjectJson;\n                            latestObject = validationResult.value.partial;\n                            controller.enqueue({\n                                type: \"object\",\n                                object: latestObject\n                            });\n                            controller.enqueue({\n                                type: \"text-delta\",\n                                textDelta: validationResult.value.textDelta\n                            });\n                            textDelta = \"\";\n                            isFirstDelta = false;\n                        }\n                    }\n                    return;\n                }\n                switch(chunk.type){\n                    case \"response-metadata\":\n                        {\n                            response = {\n                                id: (_a11 = chunk.id) != null ? _a11 : response.id,\n                                timestamp: (_b = chunk.timestamp) != null ? _b : response.timestamp,\n                                modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n                            };\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (textDelta !== \"\") {\n                                controller.enqueue({\n                                    type: \"text-delta\",\n                                    textDelta\n                                });\n                            }\n                            finishReason = chunk.finishReason;\n                            usage = calculateLanguageModelUsage(chunk.usage);\n                            providerMetadata = chunk.providerMetadata;\n                            controller.enqueue({\n                                ...chunk,\n                                usage,\n                                response\n                            });\n                            resolveUsage(usage);\n                            resolveProviderMetadata(providerMetadata);\n                            resolveResponse({\n                                ...response,\n                                headers: rawResponse == null ? void 0 : rawResponse.headers\n                            });\n                            const validationResult = outputStrategy.validateFinalResult(latestObjectJson);\n                            if (validationResult.success) {\n                                object = validationResult.value;\n                                self.objectPromise.resolve(object);\n                            } else {\n                                error = validationResult.error;\n                                self.objectPromise.reject(error);\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            controller.enqueue(chunk);\n                            break;\n                        }\n                }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush (controller) {\n                try {\n                    const finalUsage = usage != null ? usage : {\n                        promptTokens: NaN,\n                        completionTokens: NaN,\n                        totalTokens: NaN\n                    };\n                    doStreamSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.response.finishReason\": finishReason,\n                            \"ai.response.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            \"ai.response.id\": response.id,\n                            \"ai.response.model\": response.modelId,\n                            \"ai.response.timestamp\": response.timestamp.toISOString(),\n                            \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                            \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                            // deprecated\n                            \"ai.finishReason\": finishReason,\n                            \"ai.result.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.response.finish_reasons\": [\n                                finishReason\n                            ],\n                            \"gen_ai.response.id\": response.id,\n                            \"gen_ai.response.model\": response.modelId,\n                            \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                            \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                        }\n                    }));\n                    doStreamSpan.end();\n                    rootSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                            \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                            \"ai.response.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            // deprecated\n                            \"ai.result.object\": {\n                                output: ()=>JSON.stringify(object)\n                            }\n                        }\n                    }));\n                    await (onFinish == null ? void 0 : onFinish({\n                        usage: finalUsage,\n                        object,\n                        error,\n                        rawResponse,\n                        response: {\n                            ...response,\n                            headers: rawResponse == null ? void 0 : rawResponse.headers\n                        },\n                        warnings,\n                        experimental_providerMetadata: providerMetadata\n                    }));\n                } catch (error2) {\n                    controller.error(error2);\n                } finally{\n                    rootSpan.end();\n                }\n            }\n        }));\n    }\n    get object() {\n        return this.objectPromise.value;\n    }\n    get partialObjectStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"object\":\n                        controller.enqueue(chunk.object);\n                        break;\n                    case \"text-delta\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n    }\n    get elementStream() {\n        return this.outputStrategy.createElementStream(this.originalStream);\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"text-delta\":\n                        controller.enqueue(chunk.textDelta);\n                        break;\n                    case \"object\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a11;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_streamObject = streamObject;\n// core/generate-text/generate-text.ts\n\n// errors/index.ts\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name8 = \"AI_InvalidToolArgumentsError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}` }){\n        super({\n            name: name8,\n            message,\n            cause\n        });\n        this[_a8] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidToolArgumentsError(error) {\n        return error instanceof Error && error.name === name8 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            toolName: this.toolName,\n            toolArgs: this.toolArgs\n        };\n    }\n};\n_a8 = symbol8;\n// errors/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name9,\n            message\n        });\n        this[_a9] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchToolError(error) {\n        return error instanceof Error && error.name === name9 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            toolName: this.toolName,\n            availableTools: this.availableTools\n        };\n    }\n};\n_a9 = symbol9;\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name11])=>activeTools.includes(name11)) : Object.entries(tools);\n    return {\n        tools: filteredTools.map(([name11, tool2])=>{\n            const toolType = tool2.type;\n            switch(toolType){\n                case void 0:\n                case \"function\":\n                    return {\n                        type: \"function\",\n                        name: name11,\n                        description: tool2.description,\n                        parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(tool2.parameters).jsonSchema\n                    };\n                case \"provider-defined\":\n                    return {\n                        type: \"provider-defined\",\n                        name: name11,\n                        id: tool2.id,\n                        args: tool2.args\n                    };\n                default:\n                    {\n                        const exhaustiveCheck = toolType;\n                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                    }\n            }\n        }),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/util/split-on-last-whitespace.ts\nvar lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\nfunction splitOnLastWhitespace(text) {\n    const match = text.match(lastWhitespaceRegexp);\n    return match ? {\n        prefix: match[1],\n        whitespace: match[2],\n        suffix: match[3]\n    } : void 0;\n}\n// core/util/remove-text-after-last-whitespace.ts\nfunction removeTextAfterLastWhitespace(text) {\n    const match = splitOnLastWhitespace(text);\n    return match ? match.prefix + match.whitespace : text;\n}\n// core/generate-text/parse-tool-call.ts\n\n\nfunction parseToolCall({ toolCall, tools }) {\n    const toolName = toolCall.toolName;\n    if (tools == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName\n        });\n    }\n    const tool2 = tools[toolName];\n    if (tool2 == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName,\n            availableTools: Object.keys(tools)\n        });\n    }\n    const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(tool2.parameters);\n    const parseResult = toolCall.args.trim() === \"\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n        value: {},\n        schema\n    }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n        text: toolCall.args,\n        schema\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolArgumentsError({\n            toolName,\n            toolArgs: toolCall.args,\n            cause: parseResult.error\n        });\n    }\n    return {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        args: parseResult.value\n    };\n}\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({ text = \"\", tools, toolCalls, toolResults }) {\n    const responseMessages = [];\n    responseMessages.push({\n        role: \"assistant\",\n        content: [\n            {\n                type: \"text\",\n                text\n            },\n            ...toolCalls\n        ]\n    });\n    if (toolResults.length > 0) {\n        responseMessages.push({\n            role: \"tool\",\n            content: toolResults.map((toolResult)=>{\n                const tool2 = tools[toolResult.toolName];\n                return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: tool2.experimental_toToolResultContent(toolResult.result),\n                    experimental_content: tool2.experimental_toToolResultContent(toolResult.result)\n                } : {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: toolResult.result\n                };\n            })\n        });\n    }\n    return responseMessages;\n}\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function generateText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxAutomaticRoundtrips = 0, maxToolRoundtrips = maxAutomaticRoundtrips, maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1, experimental_continuationSteps, experimental_continueSteps: continueSteps = experimental_continuationSteps != null ? experimental_continuationSteps : false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_activeTools: activeTools, _internal: { generateId: generateId3 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, onStepFinish, ...settings }) {\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a11, _b, _c, _d, _e, _f;\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const mode = {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice,\n                    activeTools\n                })\n            };\n            const callSettings = prepareCallSettings(settings);\n            let currentModelResponse;\n            let currentToolCalls = [];\n            let currentToolResults = [];\n            let stepCount = 0;\n            const responseMessages = [];\n            let text = \"\";\n            const steps = [];\n            const usage = {\n                completionTokens: 0,\n                promptTokens: 0,\n                totalTokens: 0\n            };\n            let stepType = \"initial\";\n            do {\n                if (stepCount === 1) {\n                    initialPrompt.type = \"messages\";\n                }\n                const promptFormat = stepCount === 0 ? initialPrompt.type : \"messages\";\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: [\n                            ...initialPrompt.messages,\n                            ...responseMessages\n                        ]\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: model.supportsUrl\n                });\n                currentModelResponse = await retry(()=>recordSpan({\n                        name: \"ai.generateText.doGenerate\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.generateText.doGenerate\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a12;\n                                        return (_a12 = mode.tools) == null ? void 0 : _a12.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        fn: async (span2)=>{\n                            var _a12, _b2, _c2, _d2, _e2, _f2;\n                            const result = await model.doGenerate({\n                                mode,\n                                ...callSettings,\n                                inputFormat: promptFormat,\n                                prompt: promptMessages,\n                                providerMetadata,\n                                abortSignal,\n                                headers\n                            });\n                            const responseData = {\n                                id: (_b2 = (_a12 = result.response) == null ? void 0 : _a12.id) != null ? _b2 : generateId3(),\n                                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : model.modelId\n                            };\n                            span2.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": result.finishReason,\n                                    \"ai.response.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.response.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    \"ai.response.id\": responseData.id,\n                                    \"ai.response.model\": responseData.modelId,\n                                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                                    // deprecated:\n                                    \"ai.finishReason\": result.finishReason,\n                                    \"ai.result.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.result.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        result.finishReason\n                                    ],\n                                    \"gen_ai.response.id\": responseData.id,\n                                    \"gen_ai.response.model\": responseData.modelId,\n                                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                                }\n                            }));\n                            return {\n                                ...result,\n                                response: responseData\n                            };\n                        }\n                    }));\n                currentToolCalls = ((_a11 = currentModelResponse.toolCalls) != null ? _a11 : []).map((modelToolCall)=>parseToolCall({\n                        toolCall: modelToolCall,\n                        tools\n                    }));\n                currentToolResults = tools == null ? [] : await executeTools({\n                    toolCalls: currentToolCalls,\n                    tools,\n                    tracer,\n                    telemetry,\n                    abortSignal\n                });\n                const currentUsage = calculateLanguageModelUsage(currentModelResponse.usage);\n                usage.completionTokens += currentUsage.completionTokens;\n                usage.promptTokens += currentUsage.promptTokens;\n                usage.totalTokens += currentUsage.totalTokens;\n                let nextStepType = \"done\";\n                if (++stepCount < maxSteps) {\n                    if (continueSteps && currentModelResponse.finishReason === \"length\" && // only use continue when there are no tool calls:\n                    currentToolCalls.length === 0) {\n                        nextStepType = \"continue\";\n                    } else if (// there are tool calls:\n                    currentToolCalls.length > 0 && // all current tool calls have results:\n                    currentToolResults.length === currentToolCalls.length) {\n                        nextStepType = \"tool-result\";\n                    }\n                }\n                const originalText = (_b = currentModelResponse.text) != null ? _b : \"\";\n                const stepTextLeadingWhitespaceTrimmed = stepType === \"continue\" && // only for continue steps\n                text.trimEnd() !== text ? originalText.trimStart() : originalText;\n                const stepText = nextStepType === \"continue\" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;\n                text = nextStepType === \"continue\" || stepType === \"continue\" ? text + stepText : stepText;\n                if (stepType === \"continue\") {\n                    const lastMessage = responseMessages[responseMessages.length - 1];\n                    if (typeof lastMessage.content === \"string\") {\n                        lastMessage.content += stepText;\n                    } else {\n                        lastMessage.content.push({\n                            text: stepText,\n                            type: \"text\"\n                        });\n                    }\n                } else {\n                    responseMessages.push(...toResponseMessages({\n                        text,\n                        tools: tools != null ? tools : {},\n                        toolCalls: currentToolCalls,\n                        toolResults: currentToolResults\n                    }));\n                }\n                const currentStepResult = {\n                    stepType,\n                    text: stepText,\n                    toolCalls: currentToolCalls,\n                    toolResults: currentToolResults,\n                    finishReason: currentModelResponse.finishReason,\n                    usage: currentUsage,\n                    warnings: currentModelResponse.warnings,\n                    logprobs: currentModelResponse.logprobs,\n                    request: (_c = currentModelResponse.request) != null ? _c : {},\n                    response: {\n                        ...currentModelResponse.response,\n                        headers: (_d = currentModelResponse.rawResponse) == null ? void 0 : _d.headers,\n                        // deep clone msgs to avoid mutating past messages in multi-step:\n                        messages: JSON.parse(JSON.stringify(responseMessages))\n                    },\n                    experimental_providerMetadata: currentModelResponse.providerMetadata,\n                    isContinued: nextStepType === \"continue\"\n                };\n                steps.push(currentStepResult);\n                await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                stepType = nextStepType;\n            }while (stepType !== \"done\");\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": currentModelResponse.finishReason,\n                    \"ai.response.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.response.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    },\n                    \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n                    \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": currentModelResponse.finishReason,\n                    \"ai.result.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.result.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    }\n                }\n            }));\n            return new DefaultGenerateTextResult({\n                text,\n                toolCalls: currentToolCalls,\n                toolResults: currentToolResults,\n                finishReason: currentModelResponse.finishReason,\n                usage,\n                warnings: currentModelResponse.warnings,\n                request: (_e = currentModelResponse.request) != null ? _e : {},\n                response: {\n                    ...currentModelResponse.response,\n                    headers: (_f = currentModelResponse.rawResponse) == null ? void 0 : _f.headers,\n                    messages: responseMessages\n                },\n                logprobs: currentModelResponse.logprobs,\n                responseMessages,\n                steps,\n                providerMetadata: currentModelResponse.providerMetadata\n            });\n        }\n    });\n}\nasync function executeTools({ toolCalls, tools, tracer, telemetry, abortSignal }) {\n    const toolResults = await Promise.all(toolCalls.map(async (toolCall)=>{\n        const tool2 = tools[toolCall.toolName];\n        if ((tool2 == null ? void 0 : tool2.execute) == null) {\n            return void 0;\n        }\n        const result = await recordSpan({\n            name: \"ai.toolCall\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.toolCall\",\n                        telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                        output: ()=>JSON.stringify(toolCall.args)\n                    }\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                const result2 = await tool2.execute(toolCall.args, {\n                    abortSignal\n                });\n                try {\n                    span.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.toolCall.result\": {\n                                output: ()=>JSON.stringify(result2)\n                            }\n                        }\n                    }));\n                } catch (ignored) {}\n                return result2;\n            }\n        });\n        return {\n            toolCallId: toolCall.toolCallId,\n            toolName: toolCall.toolName,\n            args: toolCall.args,\n            result\n        };\n    }));\n    return toolResults.filter((result)=>result != null);\n}\nvar DefaultGenerateTextResult = class {\n    constructor(options){\n        this.text = options.text;\n        this.toolCalls = options.toolCalls;\n        this.toolResults = options.toolResults;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.request = options.request;\n        this.response = options.response;\n        this.responseMessages = options.responseMessages;\n        this.roundtrips = options.steps;\n        this.steps = options.steps;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.rawResponse = {\n            headers: options.response.headers\n        };\n        this.logprobs = options.logprobs;\n    }\n};\nvar experimental_generateText = generateText;\n// core/generate-text/stream-text.ts\n\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n    let innerStreamReaders = [];\n    let controller = null;\n    let isClosed = false;\n    const processPull = async ()=>{\n        if (isClosed && innerStreamReaders.length === 0) {\n            controller == null ? void 0 : controller.close();\n            return;\n        }\n        if (innerStreamReaders.length === 0) {\n            return;\n        }\n        try {\n            const { value, done } = await innerStreamReaders[0].read();\n            if (done) {\n                innerStreamReaders.shift();\n                if (innerStreamReaders.length > 0) {\n                    await processPull();\n                } else if (isClosed) {\n                    controller == null ? void 0 : controller.close();\n                }\n            } else {\n                controller == null ? void 0 : controller.enqueue(value);\n            }\n        } catch (error) {\n            controller == null ? void 0 : controller.error(error);\n            innerStreamReaders.shift();\n            if (isClosed && innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n    return {\n        stream: new ReadableStream({\n            start (controllerParam) {\n                controller = controllerParam;\n            },\n            pull: processPull,\n            async cancel () {\n                for (const reader of innerStreamReaders){\n                    await reader.cancel();\n                }\n                innerStreamReaders = [];\n                isClosed = true;\n            }\n        }),\n        addStream: (innerStream)=>{\n            if (isClosed) {\n                throw new Error(\"Cannot add inner stream: outer stream is closed\");\n            }\n            innerStreamReaders.push(innerStream.getReader());\n        },\n        close: ()=>{\n            isClosed = true;\n            if (innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n}\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n    const reader1 = stream1.getReader();\n    const reader2 = stream2.getReader();\n    let lastRead1 = void 0;\n    let lastRead2 = void 0;\n    let stream1Done = false;\n    let stream2Done = false;\n    async function readStream1(controller) {\n        try {\n            if (lastRead1 == null) {\n                lastRead1 = reader1.read();\n            }\n            const result = await lastRead1;\n            lastRead1 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    async function readStream2(controller) {\n        try {\n            if (lastRead2 == null) {\n                lastRead2 = reader2.read();\n            }\n            const result = await lastRead2;\n            lastRead2 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    return new ReadableStream({\n        async pull (controller) {\n            try {\n                if (stream1Done) {\n                    await readStream2(controller);\n                    return;\n                }\n                if (stream2Done) {\n                    await readStream1(controller);\n                    return;\n                }\n                if (lastRead1 == null) {\n                    lastRead1 = reader1.read();\n                }\n                if (lastRead2 == null) {\n                    lastRead2 = reader2.read();\n                }\n                const { result, reader } = await Promise.race([\n                    lastRead1.then((result2)=>({\n                            result: result2,\n                            reader: reader1\n                        })),\n                    lastRead2.then((result2)=>({\n                            result: result2,\n                            reader: reader2\n                        }))\n                ]);\n                if (!result.done) {\n                    controller.enqueue(result.value);\n                }\n                if (reader === reader1) {\n                    lastRead1 = void 0;\n                    if (result.done) {\n                        await readStream2(controller);\n                        stream1Done = true;\n                    }\n                } else {\n                    lastRead2 = void 0;\n                    if (result.done) {\n                        stream2Done = true;\n                        await readStream1(controller);\n                    }\n                }\n            } catch (error) {\n                controller.error(error);\n            }\n        },\n        cancel () {\n            reader1.cancel();\n            reader2.cancel();\n        }\n    });\n}\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({ tools, generatorStream, toolCallStreaming, tracer, telemetry, abortSignal }) {\n    let toolResultsStreamController = null;\n    const toolResultsStream = new ReadableStream({\n        start (controller) {\n            toolResultsStreamController = controller;\n        }\n    });\n    const activeToolCalls = {};\n    const outstandingToolResults = /* @__PURE__ */ new Set();\n    let canClose = false;\n    let finishChunk = void 0;\n    function attemptClose() {\n        if (canClose && outstandingToolResults.size === 0) {\n            if (finishChunk != null) {\n                toolResultsStreamController.enqueue(finishChunk);\n            }\n            toolResultsStreamController.close();\n        }\n    }\n    const forwardStream = new TransformStream({\n        transform (chunk, controller) {\n            const chunkType = chunk.type;\n            switch(chunkType){\n                case \"text-delta\":\n                case \"response-metadata\":\n                case \"error\":\n                    {\n                        controller.enqueue(chunk);\n                        break;\n                    }\n                case \"tool-call-delta\":\n                    {\n                        if (toolCallStreaming) {\n                            if (!activeToolCalls[chunk.toolCallId]) {\n                                controller.enqueue({\n                                    type: \"tool-call-streaming-start\",\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName\n                                });\n                                activeToolCalls[chunk.toolCallId] = true;\n                            }\n                            controller.enqueue({\n                                type: \"tool-call-delta\",\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                argsTextDelta: chunk.argsTextDelta\n                            });\n                        }\n                        break;\n                    }\n                case \"tool-call\":\n                    {\n                        const toolName = chunk.toolName;\n                        if (tools == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new NoSuchToolError({\n                                    toolName: chunk.toolName\n                                })\n                            });\n                            break;\n                        }\n                        const tool2 = tools[toolName];\n                        if (tool2 == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new NoSuchToolError({\n                                    toolName: chunk.toolName,\n                                    availableTools: Object.keys(tools)\n                                })\n                            });\n                            break;\n                        }\n                        try {\n                            const toolCall = parseToolCall({\n                                toolCall: chunk,\n                                tools\n                            });\n                            controller.enqueue(toolCall);\n                            if (tool2.execute != null) {\n                                const toolExecutionId = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.generateId)();\n                                outstandingToolResults.add(toolExecutionId);\n                                recordSpan({\n                                    name: \"ai.toolCall\",\n                                    attributes: selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            ...assembleOperationName({\n                                                operationId: \"ai.toolCall\",\n                                                telemetry\n                                            }),\n                                            \"ai.toolCall.name\": toolCall.toolName,\n                                            \"ai.toolCall.id\": toolCall.toolCallId,\n                                            \"ai.toolCall.args\": {\n                                                output: ()=>JSON.stringify(toolCall.args)\n                                            }\n                                        }\n                                    }),\n                                    tracer,\n                                    fn: async (span)=>tool2.execute(toolCall.args, {\n                                            abortSignal\n                                        }).then((result)=>{\n                                            toolResultsStreamController.enqueue({\n                                                ...toolCall,\n                                                type: \"tool-result\",\n                                                result\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                            try {\n                                                span.setAttributes(selectTelemetryAttributes({\n                                                    telemetry,\n                                                    attributes: {\n                                                        \"ai.toolCall.result\": {\n                                                            output: ()=>JSON.stringify(result)\n                                                        }\n                                                    }\n                                                }));\n                                            } catch (ignored) {}\n                                        }, (error)=>{\n                                            toolResultsStreamController.enqueue({\n                                                type: \"error\",\n                                                error\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                        })\n                                });\n                            }\n                        } catch (error) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error\n                            });\n                        }\n                        break;\n                    }\n                case \"finish\":\n                    {\n                        finishChunk = {\n                            type: \"finish\",\n                            finishReason: chunk.finishReason,\n                            logprobs: chunk.logprobs,\n                            usage: calculateLanguageModelUsage(chunk.usage),\n                            experimental_providerMetadata: chunk.providerMetadata\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = chunkType;\n                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        flush () {\n            canClose = true;\n            attemptClose();\n        }\n    });\n    return new ReadableStream({\n        async start (controller) {\n            return Promise.all([\n                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {}\n                })),\n                toolResultsStream.pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    }\n                }))\n            ]);\n        }\n    });\n}\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxToolRoundtrips = 0, maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1, experimental_continueSteps: continueSteps = false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_toolCallStreaming: toolCallStreaming = false, experimental_activeTools: activeTools, onChunk, onFinish, onStepFinish, _internal: { now: now2 = now, generateId: generateId3 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    return recordSpan({\n        name: \"ai.streamText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.streamText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        endWhenDone: false,\n        fn: async (rootSpan)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const startStep = async ({ responseMessages })=>{\n                const promptFormat = responseMessages.length === 0 ? initialPrompt.type : \"messages\";\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: [\n                            ...initialPrompt.messages,\n                            ...responseMessages\n                        ]\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: model.supportsUrl\n                });\n                const mode = {\n                    type: \"regular\",\n                    ...prepareToolsAndToolChoice({\n                        tools,\n                        toolChoice,\n                        activeTools\n                    })\n                };\n                const { result: { stream: stream2, warnings: warnings2, rawResponse: rawResponse2, request: request2 }, doStreamSpan: doStreamSpan2, startTimestampMs: startTimestampMs2 } = await retry(()=>recordSpan({\n                        name: \"ai.streamText.doStream\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.streamText.doStream\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a11;\n                                        return (_a11 = mode.tools) == null ? void 0 : _a11.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        endWhenDone: false,\n                        fn: async (doStreamSpan3)=>({\n                                startTimestampMs: now2(),\n                                // get before the call\n                                doStreamSpan: doStreamSpan3,\n                                result: await model.doStream({\n                                    mode,\n                                    ...prepareCallSettings(settings),\n                                    inputFormat: promptFormat,\n                                    prompt: promptMessages,\n                                    providerMetadata,\n                                    abortSignal,\n                                    headers\n                                })\n                            })\n                    }));\n                return {\n                    result: {\n                        stream: runToolsTransformation({\n                            tools,\n                            generatorStream: stream2,\n                            toolCallStreaming,\n                            tracer,\n                            telemetry,\n                            abortSignal\n                        }),\n                        warnings: warnings2,\n                        request: request2 != null ? request2 : {},\n                        rawResponse: rawResponse2\n                    },\n                    doStreamSpan: doStreamSpan2,\n                    startTimestampMs: startTimestampMs2\n                };\n            };\n            const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await startStep({\n                responseMessages: []\n            });\n            return new DefaultStreamTextResult({\n                stream,\n                warnings,\n                rawResponse,\n                request,\n                onChunk,\n                onFinish,\n                onStepFinish,\n                rootSpan,\n                doStreamSpan,\n                telemetry,\n                startTimestampMs,\n                maxSteps,\n                continueSteps,\n                startStep,\n                modelId: model.modelId,\n                now: now2,\n                currentDate,\n                generateId: generateId3,\n                tools\n            });\n        }\n    });\n}\nvar DefaultStreamTextResult = class {\n    constructor({ stream, warnings, rawResponse, request, onChunk, onFinish, onStepFinish, rootSpan, doStreamSpan, telemetry, startTimestampMs, maxSteps, continueSteps, startStep, modelId, now: now2, currentDate, generateId: generateId3, tools }){\n        this.warnings = warnings;\n        this.rawResponse = rawResponse;\n        const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n        this.usage = usagePromise;\n        const { resolve: resolveFinishReason, promise: finishReasonPromise } = createResolvablePromise();\n        this.finishReason = finishReasonPromise;\n        const { resolve: resolveText, promise: textPromise } = createResolvablePromise();\n        this.text = textPromise;\n        const { resolve: resolveToolCalls, promise: toolCallsPromise } = createResolvablePromise();\n        this.toolCalls = toolCallsPromise;\n        const { resolve: resolveToolResults, promise: toolResultsPromise } = createResolvablePromise();\n        this.toolResults = toolResultsPromise;\n        const { resolve: resolveSteps, promise: stepsPromise } = createResolvablePromise();\n        this.steps = stepsPromise;\n        const { resolve: resolveProviderMetadata, promise: providerMetadataPromise } = createResolvablePromise();\n        this.experimental_providerMetadata = providerMetadataPromise;\n        const { resolve: resolveRequest, promise: requestPromise } = createResolvablePromise();\n        this.request = requestPromise;\n        const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n        this.response = responsePromise;\n        const { resolve: resolveResponseMessages, promise: responseMessagesPromise } = createResolvablePromise();\n        this.responseMessages = responseMessagesPromise;\n        const { stream: stitchableStream, addStream, close: closeStitchableStream } = createStitchableStream();\n        this.originalStream = stitchableStream;\n        const stepResults = [];\n        const self = this;\n        function addStepStream({ stream: stream2, startTimestamp, doStreamSpan: doStreamSpan2, currentStep, responseMessages, usage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0\n        }, stepType, previousStepText = \"\", stepRequest, hasLeadingWhitespace }) {\n            const stepToolCalls = [];\n            const stepToolResults = [];\n            let stepFinishReason = \"unknown\";\n            let stepUsage = {\n                promptTokens: 0,\n                completionTokens: 0,\n                totalTokens: 0\n            };\n            let stepProviderMetadata;\n            let stepFirstChunk = true;\n            let stepText = \"\";\n            let fullStepText = stepType === \"continue\" ? previousStepText : \"\";\n            let stepLogProbs;\n            let stepResponse = {\n                id: generateId3(),\n                timestamp: currentDate(),\n                modelId\n            };\n            let chunkBuffer = \"\";\n            let chunkTextPublished = false;\n            let inWhitespacePrefix = true;\n            let hasWhitespaceSuffix = false;\n            async function publishTextChunk({ controller, chunk }) {\n                controller.enqueue(chunk);\n                stepText += chunk.textDelta;\n                fullStepText += chunk.textDelta;\n                chunkTextPublished = true;\n                hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n                await (onChunk == null ? void 0 : onChunk({\n                    chunk\n                }));\n            }\n            addStream(stream2.pipeThrough(new TransformStream({\n                async transform (chunk, controller) {\n                    var _a11, _b, _c;\n                    if (stepFirstChunk) {\n                        const msToFirstChunk = now2() - startTimestamp;\n                        stepFirstChunk = false;\n                        doStreamSpan2.addEvent(\"ai.stream.firstChunk\", {\n                            \"ai.response.msToFirstChunk\": msToFirstChunk,\n                            // deprecated:\n                            \"ai.stream.msToFirstChunk\": msToFirstChunk\n                        });\n                        doStreamSpan2.setAttributes({\n                            \"ai.response.msToFirstChunk\": msToFirstChunk,\n                            // deprecated:\n                            \"ai.stream.msToFirstChunk\": msToFirstChunk\n                        });\n                    }\n                    if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                        return;\n                    }\n                    const chunkType = chunk.type;\n                    switch(chunkType){\n                        case \"text-delta\":\n                            {\n                                if (continueSteps) {\n                                    const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;\n                                    if (trimmedChunkText.length === 0) {\n                                        break;\n                                    }\n                                    inWhitespacePrefix = false;\n                                    chunkBuffer += trimmedChunkText;\n                                    const split = splitOnLastWhitespace(chunkBuffer);\n                                    if (split != null) {\n                                        chunkBuffer = split.suffix;\n                                        await publishTextChunk({\n                                            controller,\n                                            chunk: {\n                                                type: \"text-delta\",\n                                                textDelta: split.prefix + split.whitespace\n                                            }\n                                        });\n                                    }\n                                } else {\n                                    await publishTextChunk({\n                                        controller,\n                                        chunk\n                                    });\n                                }\n                                break;\n                            }\n                        case \"tool-call\":\n                            {\n                                controller.enqueue(chunk);\n                                stepToolCalls.push(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"tool-result\":\n                            {\n                                controller.enqueue(chunk);\n                                stepToolResults.push(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"response-metadata\":\n                            {\n                                stepResponse = {\n                                    id: (_a11 = chunk.id) != null ? _a11 : stepResponse.id,\n                                    timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                                    modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                                };\n                                break;\n                            }\n                        case \"finish\":\n                            {\n                                stepUsage = chunk.usage;\n                                stepFinishReason = chunk.finishReason;\n                                stepProviderMetadata = chunk.experimental_providerMetadata;\n                                stepLogProbs = chunk.logprobs;\n                                const msToFinish = now2() - startTimestamp;\n                                doStreamSpan2.addEvent(\"ai.stream.finish\");\n                                doStreamSpan2.setAttributes({\n                                    \"ai.response.msToFinish\": msToFinish,\n                                    \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                                });\n                                break;\n                            }\n                        case \"tool-call-streaming-start\":\n                        case \"tool-call-delta\":\n                            {\n                                controller.enqueue(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"error\":\n                            {\n                                controller.enqueue(chunk);\n                                stepFinishReason = \"error\";\n                                break;\n                            }\n                        default:\n                            {\n                                const exhaustiveCheck = chunkType;\n                                throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                            }\n                    }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush (controller) {\n                    var _a11;\n                    const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                    let nextStepType = \"done\";\n                    if (currentStep + 1 < maxSteps) {\n                        if (continueSteps && stepFinishReason === \"length\" && // only use continue when there are no tool calls:\n                        stepToolCalls.length === 0) {\n                            nextStepType = \"continue\";\n                        } else if (// there are tool calls:\n                        stepToolCalls.length > 0 && // all current tool calls have results:\n                        stepToolResults.length === stepToolCalls.length) {\n                            nextStepType = \"tool-result\";\n                        }\n                    }\n                    if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== \"continue\" || // when the next step is a regular step, publish the buffer\n                    stepType === \"continue\" && !chunkTextPublished)) {\n                        await publishTextChunk({\n                            controller,\n                            chunk: {\n                                type: \"text-delta\",\n                                textDelta: chunkBuffer\n                            }\n                        });\n                        chunkBuffer = \"\";\n                    }\n                    try {\n                        doStreamSpan2.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.response.finishReason\": stepFinishReason,\n                                \"ai.response.text\": {\n                                    output: ()=>stepText\n                                },\n                                \"ai.response.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                \"ai.response.id\": stepResponse.id,\n                                \"ai.response.model\": stepResponse.modelId,\n                                \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                                \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                                \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                                // deprecated\n                                \"ai.finishReason\": stepFinishReason,\n                                \"ai.result.text\": {\n                                    output: ()=>stepText\n                                },\n                                \"ai.result.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.response.finish_reasons\": [\n                                    stepFinishReason\n                                ],\n                                \"gen_ai.response.id\": stepResponse.id,\n                                \"gen_ai.response.model\": stepResponse.modelId,\n                                \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                                \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                            }\n                        }));\n                    } catch (error) {} finally{\n                        doStreamSpan2.end();\n                    }\n                    controller.enqueue({\n                        type: \"step-finish\",\n                        finishReason: stepFinishReason,\n                        usage: stepUsage,\n                        experimental_providerMetadata: stepProviderMetadata,\n                        logprobs: stepLogProbs,\n                        response: {\n                            ...stepResponse\n                        },\n                        isContinued: nextStepType === \"continue\"\n                    });\n                    if (stepType === \"continue\") {\n                        const lastMessage = responseMessages[responseMessages.length - 1];\n                        if (typeof lastMessage.content === \"string\") {\n                            lastMessage.content += stepText;\n                        } else {\n                            lastMessage.content.push({\n                                text: stepText,\n                                type: \"text\"\n                            });\n                        }\n                    } else {\n                        responseMessages.push(...toResponseMessages({\n                            text: stepText,\n                            tools: tools != null ? tools : {},\n                            toolCalls: stepToolCalls,\n                            toolResults: stepToolResults\n                        }));\n                    }\n                    const currentStepResult = {\n                        stepType,\n                        text: stepText,\n                        toolCalls: stepToolCalls,\n                        toolResults: stepToolResults,\n                        finishReason: stepFinishReason,\n                        usage: stepUsage,\n                        warnings: self.warnings,\n                        logprobs: stepLogProbs,\n                        request: stepRequest,\n                        rawResponse: self.rawResponse,\n                        response: {\n                            ...stepResponse,\n                            headers: (_a11 = self.rawResponse) == null ? void 0 : _a11.headers,\n                            // deep clone msgs to avoid mutating past messages in multi-step:\n                            messages: JSON.parse(JSON.stringify(responseMessages))\n                        },\n                        experimental_providerMetadata: stepProviderMetadata,\n                        isContinued: nextStepType === \"continue\"\n                    };\n                    stepResults.push(currentStepResult);\n                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    const combinedUsage = {\n                        promptTokens: usage.promptTokens + stepUsage.promptTokens,\n                        completionTokens: usage.completionTokens + stepUsage.completionTokens,\n                        totalTokens: usage.totalTokens + stepUsage.totalTokens\n                    };\n                    if (nextStepType !== \"done\") {\n                        const { result, doStreamSpan: doStreamSpan3, startTimestampMs: startTimestamp2 } = await startStep({\n                            responseMessages\n                        });\n                        self.warnings = result.warnings;\n                        self.rawResponse = result.rawResponse;\n                        addStepStream({\n                            stream: result.stream,\n                            startTimestamp: startTimestamp2,\n                            doStreamSpan: doStreamSpan3,\n                            currentStep: currentStep + 1,\n                            responseMessages,\n                            usage: combinedUsage,\n                            stepType: nextStepType,\n                            previousStepText: fullStepText,\n                            stepRequest: result.request,\n                            hasLeadingWhitespace: hasWhitespaceSuffix\n                        });\n                        return;\n                    }\n                    try {\n                        controller.enqueue({\n                            type: \"finish\",\n                            finishReason: stepFinishReason,\n                            usage: combinedUsage,\n                            experimental_providerMetadata: stepProviderMetadata,\n                            logprobs: stepLogProbs,\n                            response: {\n                                ...stepResponse\n                            }\n                        });\n                        closeStitchableStream();\n                        rootSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.response.finishReason\": stepFinishReason,\n                                \"ai.response.text\": {\n                                    output: ()=>fullStepText\n                                },\n                                \"ai.response.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                \"ai.usage.promptTokens\": combinedUsage.promptTokens,\n                                \"ai.usage.completionTokens\": combinedUsage.completionTokens,\n                                // deprecated\n                                \"ai.finishReason\": stepFinishReason,\n                                \"ai.result.text\": {\n                                    output: ()=>fullStepText\n                                },\n                                \"ai.result.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                }\n                            }\n                        }));\n                        resolveUsage(combinedUsage);\n                        resolveFinishReason(stepFinishReason);\n                        resolveText(fullStepText);\n                        resolveToolCalls(stepToolCalls);\n                        resolveProviderMetadata(stepProviderMetadata);\n                        resolveToolResults(stepToolResults);\n                        resolveRequest(stepRequest);\n                        resolveResponse({\n                            ...stepResponse,\n                            headers: rawResponse == null ? void 0 : rawResponse.headers,\n                            messages: responseMessages\n                        });\n                        resolveSteps(stepResults);\n                        resolveResponseMessages(responseMessages);\n                        await (onFinish == null ? void 0 : onFinish({\n                            finishReason: stepFinishReason,\n                            logprobs: stepLogProbs,\n                            usage: combinedUsage,\n                            text: fullStepText,\n                            toolCalls: stepToolCalls,\n                            // The tool results are inferred as a never[] type, because they are\n                            // optional and the execute method with an inferred result type is\n                            // optional as well. Therefore we need to cast the toolResults to any.\n                            // The type exposed to the users will be correctly inferred.\n                            toolResults: stepToolResults,\n                            request: stepRequest,\n                            rawResponse,\n                            response: {\n                                ...stepResponse,\n                                headers: rawResponse == null ? void 0 : rawResponse.headers,\n                                messages: responseMessages\n                            },\n                            warnings,\n                            experimental_providerMetadata: stepProviderMetadata,\n                            steps: stepResults,\n                            responseMessages\n                        }));\n                    } catch (error) {\n                        controller.error(error);\n                    } finally{\n                        rootSpan.end();\n                    }\n                }\n            })));\n        }\n        addStepStream({\n            stream,\n            startTimestamp: startTimestampMs,\n            doStreamSpan,\n            currentStep: 0,\n            responseMessages: [],\n            usage: void 0,\n            stepType: \"initial\",\n            stepRequest: request,\n            hasLeadingWhitespace: false\n        });\n    }\n    /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */ teeStream() {\n        const [stream1, stream2] = this.originalStream.tee();\n        this.originalStream = stream2;\n        return stream1;\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.teeStream(), {\n            transform (chunk, controller) {\n                if (chunk.type === \"text-delta\") {\n                    controller.enqueue(chunk.textDelta);\n                } else if (chunk.type === \"error\") {\n                    controller.error(chunk.error);\n                }\n            }\n        });\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.teeStream(), {\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    toAIStream(callbacks = {}) {\n        return this.toDataStreamInternal({\n            callbacks\n        });\n    }\n    toDataStreamInternal({ callbacks = {}, getErrorMessage: getErrorMessage3 = ()=>\"\", // mask error messages for safety by default\n    sendUsage = true } = {}) {\n        let aggregatedResponse = \"\";\n        const callbackTransformer = new TransformStream({\n            async start () {\n                if (callbacks.onStart) await callbacks.onStart();\n            },\n            async transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"text-delta\") {\n                    const textDelta = chunk.textDelta;\n                    aggregatedResponse += textDelta;\n                    if (callbacks.onToken) await callbacks.onToken(textDelta);\n                    if (callbacks.onText) await callbacks.onText(textDelta);\n                }\n            },\n            async flush () {\n                if (callbacks.onCompletion) await callbacks.onCompletion(aggregatedResponse);\n                if (callbacks.onFinal) await callbacks.onFinal(aggregatedResponse);\n            }\n        });\n        const streamPartsTransformer = new TransformStream({\n            transform: async (chunk, controller)=>{\n                const chunkType = chunk.type;\n                switch(chunkType){\n                    case \"text-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", chunk.textDelta));\n                            break;\n                        }\n                    case \"tool-call-streaming-start\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_streaming_start\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName\n                            }));\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_delta\", {\n                                toolCallId: chunk.toolCallId,\n                                argsTextDelta: chunk.argsTextDelta\n                            }));\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                args: chunk.args\n                            }));\n                            break;\n                        }\n                    case \"tool-result\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_result\", {\n                                toolCallId: chunk.toolCallId,\n                                result: chunk.result\n                            }));\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", getErrorMessage3(chunk.error)));\n                            break;\n                        }\n                    case \"step-finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"finish_step\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0,\n                                isContinued: chunk.isContinued\n                            }));\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"finish_message\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0\n                            }));\n                            break;\n                        }\n                    default:\n                        {\n                            const exhaustiveCheck = chunkType;\n                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n        return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer).pipeThrough(new TextEncoderStream());\n    }\n    pipeAIStreamToResponse(response, init) {\n        return this.pipeDataStreamToResponse(response, init);\n    }\n    pipeDataStreamToResponse(response, options) {\n        const init = options == null ? void 0 : \"init\" in options ? options.init : {\n            headers: \"headers\" in options ? options.headers : void 0,\n            status: \"status\" in options ? options.status : void 0,\n            statusText: \"statusText\" in options ? options.statusText : void 0\n        };\n        const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n        const getErrorMessage3 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n        const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            }),\n            stream: this.toDataStream({\n                data,\n                getErrorMessage: getErrorMessage3,\n                sendUsage\n            })\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toAIStreamResponse(options) {\n        return this.toDataStreamResponse(options);\n    }\n    toDataStream(options) {\n        const stream = this.toDataStreamInternal({\n            getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n            sendUsage: options == null ? void 0 : options.sendUsage\n        });\n        return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n    }\n    toDataStreamResponse(options) {\n        var _a11;\n        const init = options == null ? void 0 : \"init\" in options ? options.init : {\n            headers: \"headers\" in options ? options.headers : void 0,\n            status: \"status\" in options ? options.status : void 0,\n            statusText: \"statusText\" in options ? options.statusText : void 0\n        };\n        const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n        const getErrorMessage3 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n        const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n        return new Response(this.toDataStream({\n            data,\n            getErrorMessage: getErrorMessage3,\n            sendUsage\n        }), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            })\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a11;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_streamText = streamText;\n// core/middleware/wrap-language-model.ts\nvar experimental_wrapLanguageModel = ({ model, middleware: { transformParams, wrapGenerate, wrapStream }, modelId, providerId })=>{\n    async function doTransform({ params, type }) {\n        return transformParams ? await transformParams({\n            params,\n            type\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v1\",\n        provider: providerId != null ? providerId : model.provider,\n        modelId: modelId != null ? modelId : model.modelId,\n        defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n        supportsImageUrls: model.supportsImageUrls,\n        supportsUrl: model.supportsUrl,\n        supportsStructuredOutputs: model.supportsStructuredOutputs,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"generate\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        },\n        async doStream (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"stream\"\n            });\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapStream ? wrapStream({\n                doStream,\n                params: transformedParams,\n                model\n            }) : doStream();\n        }\n    };\n};\n// core/registry/custom-provider.ts\n\nfunction experimental_customProvider({ languageModels, textEmbeddingModels, fallbackProvider }) {\n    return {\n        languageModel (modelId) {\n            if (languageModels != null && modelId in languageModels) {\n                return languageModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.languageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"languageModel\"\n            });\n        },\n        textEmbeddingModel (modelId) {\n            if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n                return textEmbeddingModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.textEmbeddingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n    };\n}\n// core/registry/no-such-provider-error.ts\n\nvar name10 = \"AI_NoSuchProviderError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){\n        super({\n            errorName: name10,\n            modelId,\n            modelType,\n            message\n        });\n        this[_a10] = true;\n        this.providerId = providerId;\n        this.availableProviders = availableProviders;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchProviderError(error) {\n        return error instanceof Error && error.name === name10 && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            modelId: this.modelId,\n            modelType: this.modelType,\n            providerId: this.providerId,\n            availableProviders: this.availableProviders\n        };\n    }\n};\n_a10 = symbol10;\n// core/registry/provider-registry.ts\n\nfunction experimental_createProviderRegistry(providers) {\n    const registry = new DefaultProviderRegistry();\n    for (const [id, provider] of Object.entries(providers)){\n        registry.registerProvider({\n            id,\n            provider\n        });\n    }\n    return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n    constructor(){\n        this.providers = {};\n    }\n    registerProvider({ id, provider }) {\n        this.providers[id] = provider;\n    }\n    getProvider(id) {\n        const provider = this.providers[id];\n        if (provider == null) {\n            throw new NoSuchProviderError({\n                modelId: id,\n                modelType: \"languageModel\",\n                providerId: id,\n                availableProviders: Object.keys(this.providers)\n            });\n        }\n        return provider;\n    }\n    splitId(id, modelType) {\n        const index = id.indexOf(\":\");\n        if (index === -1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType,\n                message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId:modelId\")`\n            });\n        }\n        return [\n            id.slice(0, index),\n            id.slice(index + 1)\n        ];\n    }\n    languageModel(id) {\n        var _a11, _b;\n        const [providerId, modelId] = this.splitId(id, \"languageModel\");\n        const model = (_b = (_a11 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a11, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"languageModel\"\n            });\n        }\n        return model;\n    }\n    textEmbeddingModel(id) {\n        var _a11, _b, _c;\n        const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n        const provider = this.getProvider(providerId);\n        const model = (_c = (_a11 = provider.textEmbeddingModel) == null ? void 0 : _a11.call(provider, modelId)) != null ? _c : \"textEmbedding\" in provider ? (_b = provider.textEmbedding) == null ? void 0 : _b.call(provider, modelId) : void 0;\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n        return model;\n    }\n    /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */ textEmbedding(id) {\n        return this.textEmbeddingModel(id);\n    }\n};\n// core/tool/tool.ts\nfunction tool(tool2) {\n    return tool2;\n}\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n    if (vector1.length !== vector2.length) {\n        throw new Error(`Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`);\n    }\n    return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n    return vector1.reduce((accumulator, value, index)=>accumulator + value * vector2[index], 0);\n}\nfunction magnitude(vector) {\n    return Math.sqrt(dotProduct(vector, vector));\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_5__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a11;\n            await ((_a11 = it.return) == null ? void 0 : _a11.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// streams/stream-data.ts\nvar StreamData2 = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        this.isClosed = false;\n        this.warningTimeout = null;\n        const self = this;\n        this.stream = new ReadableStream({\n            start: async (controller)=>{\n                self.controller = controller;\n                if (true) {\n                    self.warningTimeout = setTimeout(()=>{\n                        console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                    }, HANGING_STREAM_WARNING_TIME_MS);\n                }\n            },\n            pull: (controller)=>{},\n            cancel: (reason)=>{\n                this.isClosed = true;\n            }\n        });\n    }\n    async close() {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.close();\n        this.isClosed = true;\n        if (this.warningTimeout) {\n            clearTimeout(this.warningTimeout);\n        }\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data\", [\n            value\n        ])));\n    }\n    appendMessageAnnotation(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"message_annotations\", [\n            value\n        ])));\n    }\n};\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\nvar experimental_StreamData = class extends StreamData2 {\n};\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n    let previous = \"\";\n    return (data)=>{\n        const json = JSON.parse(data);\n        if (\"error\" in json) {\n            throw new Error(`${json.error.type}: ${json.error.message}`);\n        }\n        if (!(\"completion\" in json)) {\n            return;\n        }\n        const text = json.completion;\n        if (!previous || text.length > previous.length && text.startsWith(previous)) {\n            const delta = text.slice(previous.length);\n            previous = text;\n            return delta;\n        }\n        return text;\n    };\n}\nasync function* streamable(stream) {\n    for await (const chunk of stream){\n        if (\"completion\" in chunk) {\n            const text = chunk.completion;\n            if (text) yield text;\n        } else if (\"delta\" in chunk) {\n            const { delta } = chunk;\n            if (\"text\" in delta) {\n                const text = delta.text;\n                if (text) yield text;\n            }\n        }\n    }\n}\nfunction AnthropicStream(res, cb) {\n    if (Symbol.asyncIterator in res) {\n        return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n    } else {\n        return AIStream(res, parseAnthropicStream(), cb).pipeThrough(createStreamDataTransformer());\n    }\n}\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n    const stream = new ReadableStream({\n        async start (controller) {\n            var _a11;\n            const textEncoder = new TextEncoder();\n            const sendMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", message)));\n            };\n            const sendDataMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data_message\", message)));\n            };\n            const sendError = (errorMessage)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", errorMessage)));\n            };\n            const forwardStream = async (stream2)=>{\n                var _a12, _b;\n                let result = void 0;\n                for await (const value of stream2){\n                    switch(value.event){\n                        case \"thread.message.created\":\n                            {\n                                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", {\n                                    id: value.data.id,\n                                    role: \"assistant\",\n                                    content: [\n                                        {\n                                            type: \"text\",\n                                            text: {\n                                                value: \"\"\n                                            }\n                                        }\n                                    ]\n                                })));\n                                break;\n                            }\n                        case \"thread.message.delta\":\n                            {\n                                const content = (_a12 = value.data.delta.content) == null ? void 0 : _a12[0];\n                                if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                                    controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", content.text.value)));\n                                }\n                                break;\n                            }\n                        case \"thread.run.completed\":\n                        case \"thread.run.requires_action\":\n                            {\n                                result = value.data;\n                                break;\n                            }\n                    }\n                }\n                return result;\n            };\n            controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_control_data\", {\n                threadId,\n                messageId\n            })));\n            try {\n                await process2({\n                    threadId,\n                    messageId,\n                    sendMessage,\n                    sendDataMessage,\n                    forwardStream\n                });\n            } catch (error) {\n                sendError((_a11 = error.message) != null ? _a11 : `${error}`);\n            } finally{\n                controller.close();\n            }\n        },\n        pull (controller) {},\n        cancel () {}\n    });\n    return new Response(stream, {\n        status: 200,\n        headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\"\n        }\n    });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n    var _a11, _b;\n    const decoder = new TextDecoder();\n    for await (const chunk of (_a11 = response.body) != null ? _a11 : []){\n        const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n        if (bytes != null) {\n            const chunkText = decoder.decode(bytes);\n            const chunkJSON = JSON.parse(chunkText);\n            const delta = extractTextDeltaFromChunk(chunkJSON);\n            if (delta != null) {\n                yield delta;\n            }\n        }\n    }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>{\n        var _a11;\n        return (_a11 = chunk.delta) == null ? void 0 : _a11.text;\n    });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n    return readableFromAsyncIterable(asDeltaIterable(response, extractTextDeltaFromChunk)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n    for (const line of lines){\n        const { text, is_finished } = JSON.parse(line);\n        if (!is_finished) {\n            controller.enqueue(text);\n        }\n    }\n}\nasync function readAndProcessLines(reader, controller) {\n    let segment = \"\";\n    while(true){\n        const { value: chunk, done } = await reader.read();\n        if (done) {\n            break;\n        }\n        segment += utf8Decoder.decode(chunk, {\n            stream: true\n        });\n        const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n        segment = linesArray.pop() || \"\";\n        await processLines(linesArray, controller);\n    }\n    if (segment) {\n        const linesArray = [\n            segment\n        ];\n        await processLines(linesArray, controller);\n    }\n    controller.close();\n}\nfunction createParser2(res) {\n    var _a11;\n    const reader = (_a11 = res.body) == null ? void 0 : _a11.getReader();\n    return new ReadableStream({\n        async start (controller) {\n            if (!reader) {\n                controller.close();\n                return;\n            }\n            await readAndProcessLines(reader, controller);\n        }\n    });\n}\nasync function* streamable2(stream) {\n    for await (const chunk of stream){\n        if (chunk.eventType === \"text-generation\") {\n            const text = chunk.text;\n            if (text) yield text;\n        }\n    }\n}\nfunction CohereStream(reader, callbacks) {\n    if (Symbol.asyncIterator in reader) {\n        return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n    } else {\n        return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n    }\n}\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n    var _a11, _b, _c;\n    for await (const chunk of response.stream){\n        const parts = (_c = (_b = (_a11 = chunk.candidates) == null ? void 0 : _a11[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n        if (parts === void 0) {\n            continue;\n        }\n        const firstPart = parts[0];\n        if (typeof firstPart.text === \"string\") {\n            yield firstPart.text;\n        }\n    }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n    return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a11, _b;\n            const { value, done } = await res.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_b = (_a11 = value.token) == null ? void 0 : _a11.text) != null ? _b : \"\");\n            if (!text) return;\n            if (value.generated_text != null && value.generated_text.length > 0) {\n                return;\n            }\n            if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n                return;\n            }\n            controller.enqueue(text);\n        }\n    });\n}\nfunction HuggingFaceStream(res, callbacks) {\n    return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n    if (!res.body) {\n        throw new Error(\"Response body is null\");\n    }\n    let chat_session_id = \"\";\n    let records_cited;\n    const inkeepEventParser = (data, options)=>{\n        var _a11, _b;\n        const { event } = options;\n        if (event === \"records_cited\") {\n            records_cited = JSON.parse(data);\n            (_a11 = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a11.call(callbacks, records_cited);\n        }\n        if (event === \"message_chunk\") {\n            const inkeepMessageChunk = JSON.parse(data);\n            chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n            return inkeepMessageChunk.content_chunk;\n        }\n        return;\n    };\n    let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n    passThroughCallbacks = {\n        ...passThroughCallbacks,\n        onFinal: (completion)=>{\n            var _a11;\n            const inkeepOnFinalMetadata = {\n                chat_session_id,\n                records_cited\n            };\n            (_a11 = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a11.call(callbacks, completion, inkeepOnFinalMetadata);\n        }\n    };\n    return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(createStreamDataTransformer());\n}\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n    toAIStream: ()=>toAIStream,\n    toDataStream: ()=>toDataStream,\n    toDataStreamResponse: ()=>toDataStreamResponse\n});\nfunction toAIStream(stream, callbacks) {\n    return toDataStream(stream, callbacks);\n}\nfunction toDataStream(stream, callbacks) {\n    return stream.pipeThrough(new TransformStream({\n        transform: async (value, controller)=>{\n            var _a11;\n            if (typeof value === \"string\") {\n                controller.enqueue(value);\n                return;\n            }\n            if (\"event\" in value) {\n                if (value.event === \"on_chat_model_stream\") {\n                    forwardAIMessageChunk((_a11 = value.data) == null ? void 0 : _a11.chunk, controller);\n                }\n                return;\n            }\n            forwardAIMessageChunk(value, controller);\n        }\n    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse(stream, options) {\n    var _a11;\n    const dataStream = toDataStream(stream, options == null ? void 0 : options.callbacks);\n    const data = options == null ? void 0 : options.data;\n    const init = options == null ? void 0 : options.init;\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n    if (typeof chunk.content === \"string\") {\n        controller.enqueue(chunk.content);\n    } else {\n        const content = chunk.content;\n        for (const item of content){\n            if (item.type === \"text\") {\n                controller.enqueue(item.text);\n            }\n        }\n    }\n}\n// streams/llamaindex-adapter.ts\nvar llamaindex_adapter_exports = {};\n__export(llamaindex_adapter_exports, {\n    toDataStream: ()=>toDataStream2,\n    toDataStreamResponse: ()=>toDataStreamResponse2\n});\nfunction toDataStream2(stream, callbacks) {\n    return toReadableStream(stream).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse2(stream, options = {}) {\n    var _a11;\n    const { init, data, callbacks } = options;\n    const dataStream = toDataStream2(stream, callbacks);\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction toReadableStream(res) {\n    const it = res[Symbol.asyncIterator]();\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a11;\n            const { value, done } = await it.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_a11 = value.delta) != null ? _a11 : \"\");\n            if (text) {\n                controller.enqueue(text);\n            }\n        }\n    });\n}\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const runs = /* @__PURE__ */ new Set();\n    const handleError = async (e, runId)=>{\n        runs.delete(runId);\n        await writer.ready;\n        await writer.abort(e);\n    };\n    const handleStart = async (runId)=>{\n        runs.add(runId);\n    };\n    const handleEnd = async (runId)=>{\n        runs.delete(runId);\n        if (runs.size === 0) {\n            await writer.ready;\n            await writer.close();\n        }\n    };\n    return {\n        stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n        writer,\n        handlers: {\n            handleLLMNewToken: async (token)=>{\n                await writer.ready;\n                await writer.write(token);\n            },\n            handleLLMStart: async (_llm, _prompts, runId)=>{\n                handleStart(runId);\n            },\n            handleLLMEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleLLMError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleChainStart: async (_chain, _inputs, runId)=>{\n                handleStart(runId);\n            },\n            handleChainEnd: async (_outputs, runId)=>{\n                await handleEnd(runId);\n            },\n            handleChainError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleToolStart: async (_tool, _input, runId)=>{\n                handleStart(runId);\n            },\n            handleToolEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleToolError: async (e, runId)=>{\n                await handleError(e, runId);\n            }\n        }\n    };\n}\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n    var _a11, _b;\n    for await (const chunk of stream){\n        const content = (_b = (_a11 = chunk.choices[0]) == null ? void 0 : _a11.delta) == null ? void 0 : _b.content;\n        if (content === void 0 || content === \"\") {\n            continue;\n        }\n        yield content;\n    }\n}\nfunction MistralStream(response, callbacks) {\n    const stream = readableFromAsyncIterable(streamable4(response));\n    return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a11, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a11 = choice.delta) == null ? void 0 : _a11.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a11, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a11 = json.choices[0]) == null ? void 0 : _a11.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool2 of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool2.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool2.function.name,\n                                    arguments: JSON.parse(tool2.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n    var _a11;\n    const url = (_a11 = res.urls) == null ? void 0 : _a11.stream;\n    if (!url) {\n        if (res.error) throw new Error(res.error);\n        else throw new Error(\"Missing stream URL in Replicate response\");\n    }\n    const eventStream = await fetch(url, {\n        method: \"GET\",\n        headers: {\n            Accept: \"text/event-stream\",\n            ...options == null ? void 0 : options.headers\n        }\n    });\n    return AIStream(eventStream, void 0, cb).pipeThrough(createStreamDataTransformer());\n}\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n    var _a11;\n    response.writeHead((_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200, {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n    });\n    let processedStream = res;\n    if (data) {\n        processedStream = mergeStreams(data.stream, res);\n    }\n    const reader = processedStream.getReader();\n    function read() {\n        reader.read().then(({ done, value })=>{\n            if (done) {\n                response.end();\n                return;\n            }\n            response.write(value);\n            read();\n        });\n    }\n    read();\n}\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n    constructor(res, init, data){\n        let processedStream = res;\n        if (data) {\n            processedStream = mergeStreams(data.stream, res);\n        }\n        super(processedStream, {\n            ...init,\n            status: 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9haUAzLjQuMzNfcmVhY3RAMTguMy4xX3Nzd3JfYWY2NTNjMGI5M2Y2ODExOWFhNDg3MDA1OWU1YjFhNjAvbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxVQUFVRCxJQUNqQkwsVUFBVUksUUFBUUUsUUFBUTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLE9BQU87UUFBRUUsWUFBWTtJQUFLO0FBQ25FO0FBRUEsbUJBQW1CO0FBTU87QUFDNEM7QUFFdEUsZ0JBQWdCO0FBQzhCO0FBRTlDLHlDQUF5QztBQUNPO0FBQ3VCO0FBRXZFLGdCQUFnQjtBQUNoQixlQUFlVyxNQUFNQyxTQUFTO0lBQzVCLE9BQU9BLGNBQWMsS0FBSyxJQUFJQyxRQUFRQyxPQUFPLEtBQUssSUFBSUQsUUFBUSxDQUFDQyxVQUFZQyxXQUFXRCxTQUFTRjtBQUNqRztBQUVBLHNCQUFzQjtBQUN3QjtBQUM5QyxJQUFJSyxPQUFPO0FBQ1gsSUFBSUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFRCxLQUFLLENBQUM7QUFDdEMsSUFBSUUsU0FBU0MsT0FBT0MsR0FBRyxDQUFDSDtBQUN4QixJQUFJSTtBQUNKLElBQUlDLGFBQWEsY0FBY1Asd0RBQVVBO0lBQ3ZDUSxZQUFZLEVBQ1ZDLE9BQU8sRUFDUEMsTUFBTSxFQUNOQyxNQUFNLEVBQ1AsQ0FBRTtRQUNELEtBQUssQ0FBQztZQUFFVjtZQUFNUTtRQUFRO1FBQ3RCLElBQUksQ0FBQ0gsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDSSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxN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LElBQUk0cEIsY0FBYzU4Qiw4REFBY0E7QUFDaEMsSUFBSTY4QixTQUFTNzhCLDhEQUFjQTtBQTJFekIsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9haUAzLjQuMzNfcmVhY3RAMTguMy4xX3Nzd3JfYWY2NTNjMGI5M2Y2ODExOWFhNDg3MDA1OWU1YjFhNjAvbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzPzcwNDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lMTEgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUxMSwgeyBnZXQ6IGFsbFtuYW1lMTFdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3RyZWFtcy9pbmRleC50c1xuaW1wb3J0IHtcbiAgZm9ybWF0U3RyZWFtUGFydCxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICByZWFkRGF0YVN0cmVhbSxcbiAgcHJvY2Vzc0RhdGFQcm90b2NvbFJlc3BvbnNlXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRJbXBsIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9pbmRleC50c1xuaW1wb3J0IHsganNvblNjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyB1dGlsL2RlbGF5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXMpIHtcbiAgcmV0dXJuIGRlbGF5SW5NcyA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheUluTXMpKTtcbn1cblxuLy8gdXRpbC9yZXRyeS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZSA9IFwiQUlfUmV0cnlFcnJvclwiO1xudmFyIG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIFJldHJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNSZXRyeUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZSAmJiB0eXBlb2YgZXJyb3IucmVhc29uID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZXJyb3IuZXJyb3JzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHJlYXNvbjogdGhpcy5yZWFzb24sXG4gICAgICBsYXN0RXJyb3I6IHRoaXMubGFzdEVycm9yLFxuICAgICAgZXJyb3JzOiB0aGlzLmVycm9yc1xuICAgIH07XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbnZhciByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPSAoe1xuICBtYXhSZXRyaWVzID0gMixcbiAgaW5pdGlhbERlbGF5SW5NcyA9IDJlMyxcbiAgYmFja29mZkZhY3RvciA9IDJcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0pO1xuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSwgZXJyb3JzID0gW10pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9hc3NlbWJsZS1vcGVyYXRpb24tbmFtZS50c1xuZnVuY3Rpb24gYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgb3BlcmF0aW9uSWQsXG4gIHRlbGVtZXRyeVxufSkge1xuICByZXR1cm4ge1xuICAgIC8vIHN0YW5kYXJkaXplZCBvcGVyYXRpb24gYW5kIHJlc291cmNlIG5hbWU6XG4gICAgXCJvcGVyYXRpb24ubmFtZVwiOiBgJHtvcGVyYXRpb25JZH0keyh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkKSAhPSBudWxsID8gYCAke3RlbGVtZXRyeS5mdW5jdGlvbklkfWAgOiBcIlwifWAsXG4gICAgXCJyZXNvdXJjZS5uYW1lXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gZGV0YWlsZWQsIEFJIFNESyBzcGVjaWZpYyBkYXRhOlxuICAgIFwiYWkub3BlcmF0aW9uSWRcIjogb3BlcmF0aW9uSWQsXG4gICAgXCJhaS50ZWxlbWV0cnkuZnVuY3Rpb25JZFwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC1iYXNlLXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIG1vZGVsLFxuICBzZXR0aW5ncyxcbiAgdGVsZW1ldHJ5LFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTExO1xuICByZXR1cm4ge1xuICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgXCJhaS5tb2RlbC5pZFwiOiBtb2RlbC5tb2RlbElkLFxuICAgIC8vIHNldHRpbmdzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKHNldHRpbmdzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgYXR0cmlidXRlc1tgYWkuc2V0dGluZ3MuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KSxcbiAgICAvLyBhZGQgbWV0YWRhdGEgYXMgYXR0cmlidXRlczpcbiAgICAuLi5PYmplY3QuZW50cmllcygoX2ExMSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5Lm1ldGFkYXRhKSAhPSBudWxsID8gX2ExMSA6IHt9KS5yZWR1Y2UoXG4gICAgICAoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnRlbGVtZXRyeS5tZXRhZGF0YS4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICksXG4gICAgLy8gcmVxdWVzdCBoZWFkZXJzXG4gICAgLi4uT2JqZWN0LmVudHJpZXMoaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9KS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkucmVxdWVzdC5oZWFkZXJzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L25vb3AtdHJhY2VyLnRzXG52YXIgbm9vcFRyYWNlciA9IHtcbiAgc3RhcnRTcGFuKCkge1xuICAgIHJldHVybiBub29wU3BhbjtcbiAgfSxcbiAgc3RhcnRBY3RpdmVTcGFuKG5hbWUxMSwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMShub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMihub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMyhub29wU3Bhbik7XG4gICAgfVxuICB9XG59O1xudmFyIG5vb3BTcGFuID0ge1xuICBzcGFuQ29udGV4dCgpIHtcbiAgICByZXR1cm4gbm9vcFNwYW5Db250ZXh0O1xuICB9LFxuICBzZXRBdHRyaWJ1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0U3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB1cGRhdGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcmVjb3JkRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIG5vb3BTcGFuQ29udGV4dCA9IHtcbiAgdHJhY2VJZDogXCJcIixcbiAgc3BhbklkOiBcIlwiLFxuICB0cmFjZUZsYWdzOiAwXG59O1xuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5mdW5jdGlvbiBnZXRUcmFjZXIoe1xuICBpc0VuYWJsZWQgPSBmYWxzZSxcbiAgdHJhY2VyXG59ID0ge30pIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbm9vcFRyYWNlcjtcbiAgfVxuICBpZiAodHJhY2VyKSB7XG4gICAgcmV0dXJuIHRyYWNlcjtcbiAgfVxuICByZXR1cm4gdHJhY2UuZ2V0VHJhY2VyKFwiYWlcIik7XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L3JlY29yZC1zcGFuLnRzXG5pbXBvcnQgeyBTcGFuU3RhdHVzQ29kZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcbmZ1bmN0aW9uIHJlY29yZFNwYW4oe1xuICBuYW1lOiBuYW1lMTEsXG4gIHRyYWNlcixcbiAgYXR0cmlidXRlcyxcbiAgZm4sXG4gIGVuZFdoZW5Eb25lID0gdHJ1ZVxufSkge1xuICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihuYW1lMTEsIHsgYXR0cmlidXRlcyB9LCBhc3luYyAoc3BhbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbihzcGFuKTtcbiAgICAgIGlmIChlbmRXaGVuRG9uZSkge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbih7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9zZWxlY3QtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICB0ZWxlbWV0cnksXG4gIGF0dHJpYnV0ZXNcbn0pIHtcbiAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMyLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRJbnB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5pbnB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUub3V0cHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkT3V0cHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLm91dHB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogdmFsdWUgfTtcbiAgfSwge30pO1xufVxuXG4vLyBjb3JlL2VtYmVkL2VtYmVkLnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsLFxuICB2YWx1ZSxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmcyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMSA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTExIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmczKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmczKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBlbWJlZGRpbmcyLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZFJlc3VsdCh7IHZhbHVlLCBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC1tYW55LnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZE1hbnkoe1xuICBtb2RlbCxcbiAgdmFsdWVzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkTWFueVwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnlcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTExID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTEgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MzLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHsgdmFsdWVzLCBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBsZXQgdG9rZW5zID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdmFsdWVDaHVua3MpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiByZXNwb25zZUVtYmVkZGluZ3MsIHVzYWdlIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjaHVuay5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNodW5rLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMSA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTExIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2U6IHVzYWdlMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3BvbnNlRW1iZWRkaW5ncyk7XG4gICAgICAgIHRva2VucyArPSB1c2FnZS50b2tlbnM7XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZW1iZWRkaW5ncyxcbiAgICAgICAgdXNhZ2U6IHsgdG9rZW5zIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gb3B0aW9ucy5lbWJlZGRpbmdzO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yLCBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gdXRpbC9kb3dubG9hZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTIgPSBcIkFJX0Rvd25sb2FkRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIERvd25sb2FkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGNhdXNlID09IG51bGwgPyBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtzdGF0dXNDb2RlfSAke3N0YXR1c1RleHR9YCA6IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke2NhdXNlfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzRG93bmxvYWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUyICYmIHR5cGVvZiBlcnJvci51cmwgPT09IFwic3RyaW5nXCIgJiYgKGVycm9yLnN0YXR1c0NvZGUgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzQ29kZSA9PT0gXCJudW1iZXJcIikgJiYgKGVycm9yLnN0YXR1c1RleHQgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2VcbiAgICB9O1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gdXRpbC9kb3dubG9hZC50c1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoe1xuICB1cmwsXG4gIGZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaFxufSkge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsZW1lbnRhdGlvbih1cmxUZXh0KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWltZVR5cGU6IChfYTExID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpICE9IG51bGwgPyBfYTExIDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cblxuLy8gY29yZS91dGlsL2RldGVjdC1pbWFnZS1taW1ldHlwZS50c1xudmFyIG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9naWZcIiwgYnl0ZXM6IFs3MSwgNzMsIDcwXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3BuZ1wiLCBieXRlczogWzEzNywgODAsIDc4LCA3MV0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9qcGVnXCIsIGJ5dGVzOiBbMjU1LCAyMTZdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2Uvd2VicFwiLCBieXRlczogWzgyLCA3MywgNzAsIDcwXSB9XG5dO1xuZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZSkge1xuICBmb3IgKGNvbnN0IHsgYnl0ZXMsIG1pbWVUeXBlIH0gb2YgbWltZVR5cGVTaWduYXR1cmVzKSB7XG4gICAgaWYgKGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiYgYnl0ZXMuZXZlcnkoKGJ5dGUsIGluZGV4KSA9PiBpbWFnZVtpbmRleF0gPT09IGJ5dGUpKSB7XG4gICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWREYXRhQ29udGVudEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGVudCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0YSBjb250ZW50LiBFeHBlY3RlZCBhIGJhc2U2NCBzdHJpbmcsIFVpbnQ4QXJyYXksIEFycmF5QnVmZmVyLCBvciBCdWZmZXIsIGJ1dCBnb3QgJHt0eXBlb2YgY29udGVudH0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZERhdGFDb250ZW50RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMyAmJiBlcnJvci5jb250ZW50ICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgfTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbnZhciBkYXRhQ29udGVudFNjaGVtYSA9IHoudW5pb24oW1xuICB6LnN0cmluZygpLFxuICB6Lmluc3RhbmNlb2YoVWludDhBcnJheSksXG4gIHouaW5zdGFuY2VvZihBcnJheUJ1ZmZlciksXG4gIHouY3VzdG9tKFxuICAgIC8vIEJ1ZmZlciBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIHNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQ2xvdWRGbGFyZTpcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIHZhciBfYTExLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2ExMSA9IGdsb2JhbFRoaXMuQnVmZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5pc0J1ZmZlcih2YWx1ZSkpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIH0sXG4gICAgeyBtZXNzYWdlOiBcIk11c3QgYmUgYSBCdWZmZXJcIiB9XG4gIClcbl0pO1xuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgZGF0YSBjb250ZW50LiBDb250ZW50IHN0cmluZyBpcyBub3QgYSBiYXNlNjQtZW5jb2RlZCBtZWRpYS5cIixcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb1RleHQodWludDhBcnJheSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhBcnJheSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZGVjb2RpbmcgVWludDhBcnJheSB0byB0ZXh0XCIpO1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNCA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRNZXNzYWdlUm9sZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjQpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgdHlwZW9mIGVycm9yLnJvbGUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHJvbGU6IHRoaXMucm9sZVxuICAgIH07XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBjb3JlL3Byb21wdC9zcGxpdC1kYXRhLXVybC50c1xuZnVuY3Rpb24gc3BsaXREYXRhVXJsKGRhdGFVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW1lVHlwZTogaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV0sXG4gICAgICBiYXNlNjRDb250ZW50XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWltZVR5cGU6IHZvaWQgMCxcbiAgICAgIGJhc2U2NENvbnRlbnQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPSB0cnVlLFxuICBtb2RlbFN1cHBvcnRzVXJsID0gKCkgPT4gZmFsc2UsXG4gIGRvd25sb2FkSW1wbGVtZW50YXRpb24gPSBkb3dubG9hZFxufSkge1xuICBjb25zdCBkb3dubG9hZGVkQXNzZXRzID0gYXdhaXQgZG93bmxvYWRBc3NldHMoXG4gICAgcHJvbXB0Lm1lc3NhZ2VzLFxuICAgIGRvd25sb2FkSW1wbGVtZW50YXRpb24sXG4gICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyxcbiAgICBtb2RlbFN1cHBvcnRzVXJsXG4gICk7XG4gIHJldHVybiBbXG4gICAgLi4ucHJvbXB0LnN5c3RlbSAhPSBudWxsID8gW3sgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9XSA6IFtdLFxuICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoXG4gICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cylcbiAgICApXG4gIF07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+IGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChwYXJ0LCBkb3dubG9hZGVkQXNzZXRzKSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0czpcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCJcbiAgICAgICAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLCAuLi5yZXN0IH0gPSBwYXJ0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgIGNvbnRlbnQ6IHBhcnQuZXhwZXJpbWVudGFsX2NvbnRlbnQsXG4gICAgICAgICAgaXNFcnJvcjogcGFydC5pc0Vycm9yLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiwgbW9kZWxTdXBwb3J0c0ltYWdlVXJscywgbW9kZWxTdXBwb3J0c1VybCkge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgPT09IFwidXNlclwiKS5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudCkuZmlsdGVyKFxuICAgIChjb250ZW50KSA9PiBBcnJheS5pc0FycmF5KGNvbnRlbnQpXG4gICkuZmxhdCgpLmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICApLmZpbHRlcihcbiAgICAocGFydCkgPT4gIShwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiAmJiBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID09PSB0cnVlKVxuICApLm1hcCgocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhKS5tYXAoXG4gICAgKHBhcnQpID0+IChcbiAgICAgIC8vIHN1cHBvcnQgc3RyaW5nIHVybHM6XG4gICAgICB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAocGFydC5zdGFydHNXaXRoKFwiaHR0cDpcIikgfHwgcGFydC5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSA/IG5ldyBVUkwocGFydCkgOiBwYXJ0XG4gICAgKVxuICApLmZpbHRlcigoaW1hZ2UpID0+IGltYWdlIGluc3RhbmNlb2YgVVJMKS5maWx0ZXIoKHVybCkgPT4gIW1vZGVsU3VwcG9ydHNVcmwodXJsKSk7XG4gIGNvbnN0IGRvd25sb2FkZWRJbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB1cmxzLm1hcChhc3luYyAodXJsKSA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YTogYXdhaXQgZG93bmxvYWRJbXBsZW1lbnRhdGlvbih7IHVybCB9KVxuICAgIH0pKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRJbWFnZXMubWFwKCh7IHVybCwgZGF0YSB9KSA9PiBbdXJsLnRvU3RyaW5nKCksIGRhdGFdKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgfTtcbiAgfVxuICBsZXQgbWltZVR5cGUgPSBwYXJ0Lm1pbWVUeXBlO1xuICBsZXQgZGF0YTtcbiAgbGV0IGNvbnRlbnQ7XG4gIGxldCBub3JtYWxpemVkRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBkYXRhID0gcGFydC5pbWFnZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICBkYXRhID0gcGFydC5kYXRhO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb250ZW50ID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBuZXcgVVJMKGRhdGEpIDogZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZW50ID0gZGF0YTtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIGlmIChjb250ZW50LnByb3RvY29sID09PSBcImRhdGE6XCIpIHtcbiAgICAgIGNvbnN0IHsgbWltZVR5cGU6IGRhdGFVcmxNaW1lVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgICBjb250ZW50LnRvU3RyaW5nKClcbiAgICAgICk7XG4gICAgICBpZiAoZGF0YVVybE1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQgaW4gcGFydCAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICBtaW1lVHlwZSA9IGRhdGFVcmxNaW1lVHlwZTtcbiAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkb3dubG9hZGVkRmlsZSA9IGRvd25sb2FkZWRBc3NldHNbY29udGVudC50b1N0cmluZygpXTtcbiAgICAgIGlmIChkb3dubG9hZGVkRmlsZSkge1xuICAgICAgICBub3JtYWxpemVkRGF0YSA9IGRvd25sb2FkZWRGaWxlLmRhdGE7XG4gICAgICAgIG1pbWVUeXBlICE9IG51bGwgPyBtaW1lVHlwZSA6IG1pbWVUeXBlID0gZG93bmxvYWRlZEZpbGUubWltZVR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkRGF0YSA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWREYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgJiYgbm9ybWFsaXplZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIG1pbWVUeXBlID0gZGV0ZWN0SW1hZ2VNaW1lVHlwZShub3JtYWxpemVkRGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgIGltYWdlOiBub3JtYWxpemVkRGF0YSxcbiAgICAgICAgbWltZVR5cGUsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWltZSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIGRhdGE6IG5vcm1hbGl6ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKG5vcm1hbGl6ZWREYXRhKSA6IG5vcm1hbGl6ZWREYXRhLFxuICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgfVxufVxuXG4vLyBlcnJvcnMvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyYW1ldGVyLFxuICAgIHZhbHVlLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU1LFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gXG4gICAgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkQXJndW1lbnRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIHR5cGVvZiBlcnJvci5wYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnZhbHVlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwYXJhbWV0ZXI6IHRoaXMucGFyYW1ldGVyLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzdG9wU2VxdWVuY2VzLFxuICBzZWVkLFxuICBtYXhSZXRyaWVzXG59KSB7XG4gIGlmIChtYXhUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczogc3RvcFNlcXVlbmNlcyAhPSBudWxsICYmIHN0b3BTZXF1ZW5jZXMubGVuZ3RoID4gMCA/IHN0b3BTZXF1ZW5jZXMgOiB2b2lkIDAsXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMlxuICB9O1xufVxuXG4vLyBjb3JlL3Byb21wdC9zdGFuZGFyZGl6ZS1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlVmFsaWRhdGVUeXBlcyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo3IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL2pzb24tdmFsdWUudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG52YXIganNvblZhbHVlU2NoZW1hID0gejIubGF6eShcbiAgKCkgPT4gejIudW5pb24oW1xuICAgIHoyLm51bGwoKSxcbiAgICB6Mi5zdHJpbmcoKSxcbiAgICB6Mi5udW1iZXIoKSxcbiAgICB6Mi5ib29sZWFuKCksXG4gICAgejIucmVjb3JkKHoyLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbnZhciBwcm92aWRlck1ldGFkYXRhU2NoZW1hID0gejMucmVjb3JkKFxuICB6My5zdHJpbmcoKSxcbiAgejMucmVjb3JkKHozLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L3Rvb2wtcmVzdWx0LWNvbnRlbnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kXCI7XG52YXIgdG9vbFJlc3VsdENvbnRlbnRTY2hlbWEgPSB6NC5hcnJheShcbiAgejQudW5pb24oW1xuICAgIHo0Lm9iamVjdCh7IHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLCB0ZXh0OiB6NC5zdHJpbmcoKSB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlXCIpLFxuICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICBtaW1lVHlwZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gIF0pXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgaW1hZ2VQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImltYWdlXCIpLFxuICBpbWFnZTogejUudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NS5pbnN0YW5jZW9mKFVSTCldKSxcbiAgbWltZVR5cGU6IHo1LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGZpbGVQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImZpbGVcIiksXG4gIGRhdGE6IHo1LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejUuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6NS5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgYXJnczogejUudW5rbm93bigpXG59KTtcbnZhciB0b29sUmVzdWx0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0b29sLXJlc3VsdFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgcmVzdWx0OiB6NS51bmtub3duKCksXG4gIGNvbnRlbnQ6IHRvb2xSZXN1bHRDb250ZW50U2NoZW1hLm9wdGlvbmFsKCksXG4gIGlzRXJyb3I6IHo1LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS50c1xudmFyIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcInN5c3RlbVwiKSxcbiAgY29udGVudDogejYuc3RyaW5nKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6Ni51bmlvbihbXG4gICAgejYuc3RyaW5nKCksXG4gICAgejYuYXJyYXkoejYudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJhc3Npc3RhbnRcIiksXG4gIGNvbnRlbnQ6IHo2LnVuaW9uKFtcbiAgICB6Ni5zdHJpbmcoKSxcbiAgICB6Ni5hcnJheSh6Ni51bmlvbihbdGV4dFBhcnRTY2hlbWEsIHRvb2xDYWxsUGFydFNjaGVtYV0pKVxuICBdKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVRvb2xNZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcInRvb2xcIiksXG4gIGNvbnRlbnQ6IHo2LmFycmF5KHRvb2xSZXN1bHRQYXJ0U2NoZW1hKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZU1lc3NhZ2VTY2hlbWEgPSB6Ni51bmlvbihbXG4gIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hLFxuICBjb3JlVXNlck1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlVG9vbE1lc3NhZ2VTY2hlbWFcbl0pO1xuXG4vLyBjb3JlL3Byb21wdC9kZXRlY3QtcHJvbXB0LXR5cGUudHNcbmZ1bmN0aW9uIGRldGVjdFByb21wdFR5cGUocHJvbXB0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9tcHQpKSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxuICBpZiAocHJvbXB0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIm1lc3NhZ2VzXCI7XG4gIH1cbiAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gcHJvbXB0Lm1hcChkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKTtcbiAgaWYgKGNoYXJhY3RlcmlzdGljcy5zb21lKChjKSA9PiBjID09PSBcImhhcy11aS1zcGVjaWZpYy1wYXJ0c1wiKSkge1xuICAgIHJldHVybiBcInVpLW1lc3NhZ2VzXCI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyaXN0aWNzLmV2ZXJ5KFxuICAgIChjKSA9PiBjID09PSBcImhhcy1jb3JlLXNwZWNpZmljLXBhcnRzXCIgfHwgYyA9PT0gXCJtZXNzYWdlXCJcbiAgKSkge1xuICAgIHJldHVybiBcIm1lc3NhZ2VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZWN0U2luZ2xlTWVzc2FnZUNoYXJhY3RlcmlzdGljcyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIChtZXNzYWdlLnJvbGUgPT09IFwiZnVuY3Rpb25cIiB8fCAvLyBVSS1vbmx5IHJvbGVcbiAgbWVzc2FnZS5yb2xlID09PSBcImRhdGFcIiB8fCAvLyBVSS1vbmx5IHJvbGVcbiAgXCJ0b29sSW52b2NhdGlvbnNcIiBpbiBtZXNzYWdlIHx8IC8vIFVJLXNwZWNpZmljIGZpZWxkXG4gIFwiZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzXCIgaW4gbWVzc2FnZSkpIHtcbiAgICByZXR1cm4gXCJoYXMtdWktc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwiY29udGVudFwiIGluIG1lc3NhZ2UgJiYgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSB8fCAvLyBDb3JlIG1lc3NhZ2VzIGNhbiBoYXZlIGFycmF5IGNvbnRlbnRcbiAgXCJleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVwiIGluIG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFwiaGFzLWNvcmUtc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwicm9sZVwiIGluIG1lc3NhZ2UgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiICYmIFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCJdLmluY2x1ZGVzKG1lc3NhZ2Uucm9sZSkpIHtcbiAgICByZXR1cm4gXCJtZXNzYWdlXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9hdHRhY2htZW50cy10by1wYXJ0cy50c1xuZnVuY3Rpb24gYXR0YWNobWVudHNUb1BhcnRzKGF0dGFjaG1lbnRzKSB7XG4gIHZhciBfYTExLCBfYiwgX2M7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3QgYXR0YWNobWVudCBvZiBhdHRhY2htZW50cykge1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoYXR0YWNobWVudC51cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgIH1cbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgY2FzZSBcImh0dHA6XCI6XG4gICAgICBjYXNlIFwiaHR0cHM6XCI6IHtcbiAgICAgICAgaWYgKChfYTExID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiBcImltYWdlXCIsIGltYWdlOiB1cmwgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFhdHRhY2htZW50LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlLCBpdCBtdXN0IHNwZWNpZnkgYSBjb250ZW50IHR5cGVcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICBsZXQgYmFzZTY0Q29udGVudDtcbiAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gYXR0YWNobWVudC51cmwuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgIG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQ6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYiA9IGF0dGFjaG1lbnQuY29udGVudFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICBpbWFnZTogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKF9jID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBjb252ZXJ0VWludDhBcnJheVRvVGV4dChcbiAgICAgICAgICAgICAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFhdHRhY2htZW50LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlIG9yIHRleHQsIGl0IG11c3Qgc3BlY2lmeSBhIGNvbnRlbnQgdHlwZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZGF0YTogYmFzZTY0Q29udGVudCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVVJMIHByb3RvY29sOiAke3VybC5wcm90b2NvbH1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjYgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU2ID0gXCJBSV9NZXNzYWdlQ29udmVyc2lvbkVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBNZXNzYWdlQ29udmVyc2lvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2UsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWNvcmUtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucykge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgdG9vbHMgPSAoX2ExMSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpICE9IG51bGwgPyBfYTExIDoge307XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBjb25zdCB7IHJvbGUsIGNvbnRlbnQsIHRvb2xJbnZvY2F0aW9ucywgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzIH0gPSBtZXNzYWdlO1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzID8gW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cylcbiAgICAgICAgICBdIDogY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICh7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBhcmdzIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgY29udGVudDogdG9vbEludm9jYXRpb25zLm1hcCgodG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmICghKFwicmVzdWx0XCIgaW4gdG9vbEludm9jYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUb29sSW52b2NhdGlvbiBtdXN0IGhhdmUgYSByZXN1bHQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodG9vbEludm9jYXRpb24pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgcmVzdWx0IH0gPSB0b29sSW52b2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIHJlc3VsdDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQocmVzdWx0KSxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRlbnQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHJlc3VsdClcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3JlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQoe1xuICBwcm9tcHQsXG4gIHRvb2xzXG59KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByb21wdC5wcm9tcHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG11c3QgYmUgYSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByb21wdFwiLFxuICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHByb21wdC5wcm9tcHRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgaWYgKHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbXB0VHlwZSA9IGRldGVjdFByb21wdFR5cGUocHJvbXB0Lm1lc3NhZ2VzKTtcbiAgICBpZiAocHJvbXB0VHlwZSA9PT0gXCJvdGhlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXkgb2YgQ29yZU1lc3NhZ2Ugb3IgVUlNZXNzYWdlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHByb21wdFR5cGUgPT09IFwidWktbWVzc2FnZXNcIiA/IGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhwcm9tcHQubWVzc2FnZXMsIHtcbiAgICAgIHRvb2xzXG4gICAgfSkgOiBwcm9tcHQubWVzc2FnZXM7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogejcuYXJyYXkoY29yZU1lc3NhZ2VTY2hlbWEpXG4gICAgfSk7XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZSBvciBVSU1lc3NhZ2VcIixcbiAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xufVxuXG4vLyBjb3JlL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyB1c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgIT0gbnVsbCA/IF9hMTEgOiB7fSk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzLnNldChcIlgtVmVyY2VsLUFJLURhdGEtU3RyZWFtXCIsIGRhdGFTdHJlYW1WZXJzaW9uKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24taW5zdHJ1Y3Rpb24udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xudmFyIERFRkFVTFRfR0VORVJJQ19TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIEpTT04uXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICBwcm9tcHQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9QUkVGSVggOiB2b2lkIDAsXG4gIHNjaGVtYVN1ZmZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfU1VGRklYIDogREVGQVVMVF9HRU5FUklDX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gcHJvbXB0IDogdm9pZCAwLFxuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gXCJcIiA6IHZvaWQgMCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHByb21wdCBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHNjaGVtYSkgOiB2b2lkIDAsXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L25vLW9iamVjdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU3ID0gXCJBSV9Ob09iamVjdEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBOb09iamVjdEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNyB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIk5vIG9iamVjdCBnZW5lcmF0ZWQuXCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I3Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNOb09iamVjdEdlbmVyYXRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTc7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlLCB0cmFuc2Zvcm1lcikge1xuICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKVxuICApO1xuICB0cmFuc2Zvcm1lZFN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gdHJhbnNmb3JtZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH0gOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1lZFN0cmVhbTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG52YXIgbm9TY2hlbWFPdXRwdXRTdHJhdGVneSA9IHtcbiAgdHlwZTogXCJuby1zY2hlbWFcIixcbiAganNvblNjaGVtYTogdm9pZCAwLFxuICB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogeyBwYXJ0aWFsOiB2YWx1ZSwgdGV4dERlbHRhIH0gfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCkgfSA6IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gbm8tc2NoZW1hIG1vZGVcIlxuICAgIH0pO1xuICB9XG59O1xudmFyIG9iamVjdE91dHB1dFN0cmF0ZWd5ID0gKHNjaGVtYSkgPT4gKHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAganNvblNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWEsXG4gIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICBwYXJ0aWFsOiB2YWx1ZSxcbiAgICAgICAgdGV4dERlbHRhXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBvYmplY3QgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn0pO1xudmFyIGFycmF5T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiB7XG4gIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0gc2NoZW1hLmpzb25TY2hlbWE7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyBhcnJheSBvZiBlbGVtZW50cywgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBhcnJheSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgYXJyYXlzIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgZ3JhbW1hci1ndWlkZWQgZ2VuZXJhdGlvblxuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBlbGVtZW50czogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiBpdGVtU2NoZW1hIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wiZWxlbWVudHNcIl0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCBsYXRlc3RPYmplY3QsIGlzRmlyc3REZWx0YSwgaXNGaW5hbERlbHRhIH0pIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgY29uc3QgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKGkgPT09IGlucHV0QXJyYXkubGVuZ3RoIC0gMSAmJiAhaXNGaW5hbERlbHRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGlzaGVkRWxlbWVudENvdW50ID0gKF9hMTEgPSBsYXRlc3RPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdE9iamVjdC5sZW5ndGgpICE9IG51bGwgPyBfYTExIDogMDtcbiAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgaWYgKGlzRmlyc3REZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJbXCI7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaGVkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCIsXCI7XG4gICAgICB9XG4gICAgICB0ZXh0RGVsdGEgKz0gcmVzdWx0QXJyYXkuc2xpY2UocHVibGlzaGVkRWxlbWVudENvdW50KS5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLFwiKTtcbiAgICAgIGlmIChpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiByZXN1bHRBcnJheSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBlbGVtZW50c1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSB2YWx1ZS5lbGVtZW50cztcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpbnB1dEFycmF5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlOiBlbGVtZW50LCBzY2hlbWEgfSk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogaW5wdXRBcnJheSB9O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbShvcmlnaW5hbFN0cmVhbSkge1xuICAgICAgbGV0IHB1Ymxpc2hlZEVsZW1lbnRzID0gMDtcbiAgICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKG9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gY2h1bmsub2JqZWN0O1xuICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheS5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXJyYXlbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW51bU91dHB1dFN0cmF0ZWd5ID0gKGVudW1WYWx1ZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJlc3VsdCwgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBlbnVtIHZhbHVlIGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBlbnVtcyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIHRvcC1sZXZlbCBlbnVtc1xuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwicGFydGlhbCByZXN1bHRzIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgc3dpdGNoIChvdXRwdXQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gb2JqZWN0T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWEoc2NoZW1hKSk7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYXJyYXlPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvdmFsaWRhdGUtb2JqZWN0LWdlbmVyYXRpb24taW5wdXQudHNcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgb3V0cHV0LFxuICBtb2RlLFxuICBzY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIGlmIChvdXRwdXQgIT0gbnVsbCAmJiBvdXRwdXQgIT09IFwib2JqZWN0XCIgJiYgb3V0cHV0ICE9PSBcImFycmF5XCIgJiYgb3V0cHV0ICE9PSBcImVudW1cIiAmJiBvdXRwdXQgIT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm91dHB1dFwiLFxuICAgICAgdmFsdWU6IG91dHB1dCxcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBvdXRwdXQgdHlwZS5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChvdXRwdXQgPT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtb2RlXCIsXG4gICAgICAgIHZhbHVlOiBtb2RlLFxuICAgICAgICBtZXNzYWdlOiAnTW9kZSBtdXN0IGJlIFwianNvblwiIGZvciBuby1zY2hlbWEgb3V0cHV0LidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyByZXF1aXJlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiRWxlbWVudCBzY2hlbWEgaXMgcmVxdWlyZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImVudW1cIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIHJlcXVpcmVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZW51bVZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qoe1xuICBtb2RlbCxcbiAgZW51bTogZW51bVZhbHVlcyxcbiAgLy8gcmVuYW1lIGJjIGVudW0gaXMgcmVzZXJ2ZWQgYnkgdHlwZXNjcmlwdFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgX2ludGVybmFsOiB7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgbW9kZSxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgaWYgKG91dHB1dFN0cmF0ZWd5LnR5cGUgPT09IFwibm8tc2NoZW1hXCIgJiYgbW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgbW9kZSA9IFwianNvblwiO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2NoZW1hXCI6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgIT0gbnVsbCA/IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEpIH0gOiB2b2lkIDAsXG4gICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGUsXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTEsIF9iO1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgICAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICBsZXQgdXNhZ2U7XG4gICAgICBsZXQgd2FybmluZ3M7XG4gICAgICBsZXQgcmF3UmVzcG9uc2U7XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBsZXQgcmVxdWVzdDtcbiAgICAgIGxldCBsb2dwcm9icztcbiAgICAgIGxldCByZXN1bHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgc3lzdGVtOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hID09IG51bGwgPyBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oeyBwcm9tcHQ6IHN5c3RlbSB9KSA6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3lzdGVtLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0YW5kYXJkaXplZFByb21wdC50eXBlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExMiwgX2IyLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIudGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9iMiA9IChfYTEyID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QgPSAoX2MgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MudGltZXN0YW1wKSAhPSBudWxsID8gX2QgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0Mi5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dDogcmVzdWx0Mi50ZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVxdWVzdCA9IChfYTExID0gZ2VuZXJhdGVSZXN1bHQucmVxdWVzdCkgIT0gbnVsbCA/IF9hMTEgOiB7fTtcbiAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJlc3BvbnNlRGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogbW9kZWwuc3VwcG9ydHNVcmxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpbnB1dEZvcm1hdCA9IHN0YW5kYXJkaXplZFByb21wdC50eXBlO1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBpbnB1dEZvcm1hdFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTIsIF9iMiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lICE9IG51bGwgPyBzY2hlbWFOYW1lIDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0VGV4dCA9IChfYjIgPSAoX2ExMiA9IHJlc3VsdDIudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMlswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5hcmdzO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RUZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2QgPSAoX2MgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaWQpICE9IG51bGwgPyBfZCA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZiA9IChfZSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS50aW1lc3RhbXApICE9IG51bGwgPyBfZiA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2ggPSAoX2cgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2cubW9kZWxJZCkgIT0gbnVsbCA/IF9oIDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gb2JqZWN0VGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IG9iamVjdFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVxdWVzdCA9IChfYiA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfYiA6IHt9O1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IHJlc3VsdCB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBwYXJzZVJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZUZpbmFsUmVzdWx0KFxuICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZVxuICAgICAgKTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsaWRhdGlvblJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbGlkYXRpb25SZXN1bHQudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgb2JqZWN0OiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHtcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMucmVzcG9uc2UuaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTExO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QgPSBnZW5lcmF0ZU9iamVjdDtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7XG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAgcGFyc2VQYXJ0aWFsSnNvblxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIHV0aWwvZGVsYXllZC1wcm9taXNlLnRzXG52YXIgRGVsYXllZFByb21pc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInBlbmRpbmdcIiB9O1xuICAgIHRoaXMuX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVqZWN0ID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5zdGF0dXMudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgcmVqZWN0KHRoaXMuc3RhdHVzLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gIH1cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHZhciBfYTExO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlc29sdmVkXCIsIHZhbHVlIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTEgPSB0aGlzLl9yZXNvbHZlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVqZWN0KGVycm9yKSB7XG4gICAgdmFyIF9hMTE7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicmVqZWN0ZWRcIiwgZXJyb3IgfTtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAoX2ExMSA9IHRoaXMuX3JlamVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvbm93LnRzXG5mdW5jdGlvbiBub3coKSB7XG4gIHZhciBfYTExLCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYTExID0gZ2xvYmFsVGhpcyA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEubm93KCkpICE9IG51bGwgPyBfYiA6IERhdGUubm93KCk7XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLW91dGdvaW5nLWh0dHAtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgIT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGluaXQuaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PSBudWxsKSB7XG4gICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IGNvbnRlbnRUeXBlO1xuICB9XG4gIGlmIChkYXRhU3RyZWFtVmVyc2lvbiAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1tcIlgtVmVyY2VsLUFJLURhdGEtU3RyZWFtXCJdID0gZGF0YVN0cmVhbVZlcnNpb247XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIGNvcmUvdXRpbC93cml0ZS10by1zZXJ2ZXItcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbVxufSkge1xuICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsIHN0YXR1c1RleHQsIGhlYWRlcnMpO1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNwb25zZS5lbmQoKTtcbiAgICB9XG4gIH07XG4gIHJlYWQoKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjIoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5hc3luYyBmdW5jdGlvbiBzdHJlYW1PYmplY3Qoe1xuICBtb2RlbCxcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIG1vZGUsXG4gIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIG9uRmluaXNoLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICBub3c6IG5vdzIgPSBub3dcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIG1vZGUsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHsgb3V0cHV0LCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2NoZW1hXCI6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgIT0gbnVsbCA/IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEpIH0gOiB2b2lkIDAsXG4gICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGUsXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICBmbjogYXN5bmMgKHJvb3RTcGFuKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU7XG4gICAgICB9XG4gICAgICBsZXQgY2FsbE9wdGlvbnM7XG4gICAgICBsZXQgdHJhbnNmb3JtZXI7XG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICBzeXN0ZW06IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgPT0gbnVsbCA/IGluamVjdEpzb25JbnN0cnVjdGlvbih7IHByb21wdDogc3lzdGVtIH0pIDogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHN5c3RlbSA6IGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gICAgICAgICAgICAgICAgcHJvbXB0OiBzeXN0ZW0sXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC1qc29uXCIsXG4gICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICBpbnB1dEZvcm1hdDogc3RhbmRhcmRpemVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSAhPSBudWxsID8gc2NoZW1hTmFtZSA6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsID8gc2NoZW1hRGVzY3JpcHRpb24gOiBcIlJlc3BvbmQgd2l0aCBhIEpTT04gb2JqZWN0LlwiLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuYXJnc1RleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVzdWx0OiB7IHN0cmVhbSwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNhbGxPcHRpb25zLmlucHV0Rm9ybWF0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY2FsbE9wdGlvbnMucHJvbXB0KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucylcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCh7XG4gICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICBzdHJlYW06IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9LFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgcm9vdFNwYW4sXG4gICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICBub3c6IG5vdzIsXG4gICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkM1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc3RyZWFtLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlLFxuICAgIHJlcXVlc3QsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgb25GaW5pc2gsXG4gICAgcm9vdFNwYW4sXG4gICAgZG9TdHJlYW1TcGFuLFxuICAgIHRlbGVtZXRyeSxcbiAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgIG1vZGVsSWQsXG4gICAgbm93OiBub3cyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgICB0aGlzLnJlcXVlc3QgPSBQcm9taXNlLnJlc29sdmUocmVxdWVzdCk7XG4gICAgdGhpcy5vYmplY3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZVJlc3BvbnNlLCBwcm9taXNlOiByZXNwb25zZVByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlUHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICByZXNvbHZlOiByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIHByb21pc2U6IHByb3ZpZGVyTWV0YWRhdGFQcm9taXNlXG4gICAgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IHByb3ZpZGVyTWV0YWRhdGFQcm9taXNlO1xuICAgIGxldCB1c2FnZTtcbiAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgIGxldCBvYmplY3Q7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgbW9kZWxJZFxuICAgIH07XG4gICAgbGV0IGxhdGVzdE9iamVjdEpzb24gPSB2b2lkIDA7XG4gICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgICBsZXQgaXNGaXJzdERlbHRhID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIHZhciBfYTExLCBfYiwgX2M7XG4gICAgICAgICAgaWYgKGlzRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRleHQgKz0gY2h1bms7XG4gICAgICAgICAgICB0ZXh0RGVsdGEgKz0gY2h1bms7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50T2JqZWN0SnNvbiAhPT0gdm9pZCAwICYmICFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0SnNvbiwgY3VycmVudE9iamVjdEpzb24pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZVBhcnRpYWxSZXN1bHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGEsXG4gICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICBpc0ZpbmFsRGVsdGE6IHBhcnNlU3RhdGUgPT09IFwic3VjY2Vzc2Z1bC1wYXJzZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnBhcnRpYWwpKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0SnNvbiA9IGN1cnJlbnRPYmplY3RKc29uO1xuICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbDtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogbGF0ZXN0T2JqZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9hMTEgPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTEgOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iIDogcmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHRleHREZWx0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGEgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICB1c2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSk7XG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyAuLi5jaHVuaywgdXNhZ2UsIHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICByZXNvbHZlVXNhZ2UodXNhZ2UpO1xuICAgICAgICAgICAgICByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQobGF0ZXN0T2JqZWN0SnNvbik7XG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0UHJvbWlzZS5yZXNvbHZlKG9iamVjdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSB2YWxpZGF0aW9uUmVzdWx0LmVycm9yO1xuICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0UHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbFVzYWdlID0gdXNhZ2UgIT0gbnVsbCA/IHVzYWdlIDoge1xuICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgICB0b3RhbFRva2VuczogTmFOXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGZpbmFsVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KSB9LFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdClcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdCkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgdXNhZ2U6IGZpbmFsVXNhZ2UsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcjIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBnZXQgb2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5vYmplY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGVsZW1lbnRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RyYXRlZ3kuY3JlYXRlRWxlbWVudFN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtKTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXM6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTExO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCA9IHN0cmVhbU9iamVjdDtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGVycm9ycy9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsXG4gIEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIGVycm9ycy9pbnZhbGlkLXRvb2wtYXJndW1lbnRzLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I4LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTggPSBcIkFJX0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I4IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xBcmdzLFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBhcmd1bWVudHMgZm9yIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlMihcbiAgICAgIGNhdXNlXG4gICAgKX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjguaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTggJiYgdHlwZW9mIGVycm9yLnRvb2xOYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci50b29sQXJncyA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0aGlzLnRvb2xBcmdzXG4gICAgfTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIGVycm9ycy9uby1zdWNoLXRvb2wtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU5ID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIE5vU3VjaFRvb2xFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB2b2lkIDAsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHthdmFpbGFibGVUb29scyA9PT0gdm9pZCAwID8gXCJObyB0b29scyBhcmUgYXZhaWxhYmxlLlwiIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKFwiLCBcIil9LmB9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZVRvb2xzID0gYXZhaWxhYmxlVG9vbHM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hUb29sRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOSAmJiBcInRvb2xOYW1lXCIgaW4gZXJyb3IgJiYgZXJyb3IudG9vbE5hbWUgIT0gdm9pZCAwICYmIHR5cGVvZiBlcnJvci5uYW1lID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiB0aGlzLmF2YWlsYWJsZVRvb2xzXG4gICAgfTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyBhc1NjaGVtYSBhcyBhc1NjaGVtYTIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50c1xuZnVuY3Rpb24gaXNOb25FbXB0eU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID4gMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmZ1bmN0aW9uIHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgYWN0aXZlVG9vbHNcbn0pIHtcbiAgaWYgKCFpc05vbkVtcHR5T2JqZWN0KHRvb2xzKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogdm9pZCAwLFxuICAgICAgdG9vbENob2ljZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBmaWx0ZXJlZFRvb2xzID0gYWN0aXZlVG9vbHMgIT0gbnVsbCA/IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5maWx0ZXIoXG4gICAgKFtuYW1lMTFdKSA9PiBhY3RpdmVUb29scy5pbmNsdWRlcyhuYW1lMTEpXG4gICkgOiBPYmplY3QuZW50cmllcyh0b29scyk7XG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGZpbHRlcmVkVG9vbHMubWFwKChbbmFtZTExLCB0b29sMl0pID0+IHtcbiAgICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbDIudHlwZTtcbiAgICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lMTEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBhc1NjaGVtYTIodG9vbDIucGFyYW1ldGVycykuanNvblNjaGVtYVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwcm92aWRlci1kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvdmlkZXItZGVmaW5lZFwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgYXJnczogdG9vbDIuYXJnc1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0b29sVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRvb2wgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0b29sQ2hvaWNlOiB0b29sQ2hvaWNlID09IG51bGwgPyB7IHR5cGU6IFwiYXV0b1wiIH0gOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogdG9vbENob2ljZSB9IDogeyB0eXBlOiBcInRvb2xcIiwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgfVxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvc3BsaXQtb24tbGFzdC13aGl0ZXNwYWNlLnRzXG52YXIgbGFzdFdoaXRlc3BhY2VSZWdleHAgPSAvXihbXFxzXFxTXSo/KShcXHMrKShcXFMqKSQvO1xuZnVuY3Rpb24gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQpIHtcbiAgY29uc3QgbWF0Y2ggPSB0ZXh0Lm1hdGNoKGxhc3RXaGl0ZXNwYWNlUmVnZXhwKTtcbiAgcmV0dXJuIG1hdGNoID8geyBwcmVmaXg6IG1hdGNoWzFdLCB3aGl0ZXNwYWNlOiBtYXRjaFsyXSwgc3VmZml4OiBtYXRjaFszXSB9IDogdm9pZCAwO1xufVxuXG4vLyBjb3JlL3V0aWwvcmVtb3ZlLXRleHQtYWZ0ZXItbGFzdC13aGl0ZXNwYWNlLnRzXG5mdW5jdGlvbiByZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZSh0ZXh0KSB7XG4gIGNvbnN0IG1hdGNoID0gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5wcmVmaXggKyBtYXRjaC53aGl0ZXNwYWNlIDogdGV4dDtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3BhcnNlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiwgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hMyB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xOYW1lID0gdG9vbENhbGwudG9vbE5hbWU7XG4gIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSB9KTtcbiAgfVxuICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTModG9vbDIucGFyYW1ldGVycyk7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gdG9vbENhbGwuYXJncy50cmltKCkgPT09IFwiXCIgPyBzYWZlVmFsaWRhdGVUeXBlczMoeyB2YWx1ZToge30sIHNjaGVtYSB9KSA6IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogdG9vbENhbGwuYXJncywgc2NoZW1hIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICB0b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWUsXG4gICAgYXJnczogcGFyc2VSZXN1bHQudmFsdWVcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3RvLXJlc3BvbnNlLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICB0ZXh0ID0gXCJcIixcbiAgdG9vbHMsXG4gIHRvb2xDYWxscyxcbiAgdG9vbFJlc3VsdHNcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQgfSwgLi4udG9vbENhbGxzXVxuICB9KTtcbiAgaWYgKHRvb2xSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0cy5tYXAoKHRvb2xSZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sUmVzdWx0LnRvb2xOYW1lXTtcbiAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xSZXN1bHQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHRvb2xSZXN1bHQucmVzdWx0KSxcbiAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQoXG4gICAgICAgICAgICB0b29sUmVzdWx0LnJlc3VsdFxuICAgICAgICAgIClcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogdG9vbFJlc3VsdC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sUmVzdWx0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogdG9vbFJlc3VsdC5yZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMyA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7IHByZWZpeDogXCJhaXR4dFwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgbWF4QXV0b21hdGljUm91bmR0cmlwcyA9IDAsXG4gIG1heFRvb2xSb3VuZHRyaXBzID0gbWF4QXV0b21hdGljUm91bmR0cmlwcyxcbiAgbWF4U3RlcHMgPSBtYXhUb29sUm91bmR0cmlwcyAhPSBudWxsID8gbWF4VG9vbFJvdW5kdHJpcHMgKyAxIDogMSxcbiAgZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzLFxuICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogY29udGludWVTdGVwcyA9IGV4cGVyaW1lbnRhbF9jb250aW51YXRpb25TdGVwcyAhPSBudWxsID8gZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzIDogZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgb25TdGVwRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBpZiAobWF4U3RlcHMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJtYXhTdGVwc1wiLFxuICAgICAgdmFsdWU6IG1heFN0ZXBzLFxuICAgICAgbWVzc2FnZTogXCJtYXhTdGVwcyBtdXN0IGJlIGF0IGxlYXN0IDFcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgIHRvb2xzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExMSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSwgYWN0aXZlVG9vbHMgfSlcbiAgICAgIH07XG4gICAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgIGxldCBjdXJyZW50VG9vbENhbGxzID0gW107XG4gICAgICBsZXQgY3VycmVudFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgc3RlcENvdW50ID0gMDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgIGNvbnN0IHN0ZXBzID0gW107XG4gICAgICBjb25zdCB1c2FnZSA9IHtcbiAgICAgICAgY29tcGxldGlvblRva2VuczogMCxcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfTtcbiAgICAgIGxldCBzdGVwVHlwZSA9IFwiaW5pdGlhbFwiO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc3RlcENvdW50ID09PSAxKSB7XG4gICAgICAgICAgaW5pdGlhbFByb21wdC50eXBlID0gXCJtZXNzYWdlc1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21wdEZvcm1hdCA9IHN0ZXBDb3VudCA9PT0gMCA/IGluaXRpYWxQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIjtcbiAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgIHN5c3RlbTogaW5pdGlhbFByb21wdC5zeXN0ZW0sXG4gICAgICAgICAgICBtZXNzYWdlczogWy4uLmluaXRpYWxQcm9tcHQubWVzc2FnZXMsIC4uLnJlc3BvbnNlTWVzc2FnZXNdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7IGlucHV0OiAoKSA9PiBwcm9tcHRGb3JtYXQgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTEyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMTIgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogc2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTEyLCBfYjIsIF9jMiwgX2QyLCBfZTIsIF9mMjtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZDIgPSAoX2MyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kMiA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mMiA9IChfZTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZTIubW9kZWxJZCkgIT0gbnVsbCA/IF9mMiA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJlc3VsdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdC50b29sQ2FsbHMpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiByZXN1bHQudGV4dFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnRvb2xDYWxscylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0LmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCByZXNwb25zZTogcmVzcG9uc2VEYXRhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xDYWxscyA9ICgoX2ExMSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9hMTEgOiBbXSkubWFwKFxuICAgICAgICAgIChtb2RlbFRvb2xDYWxsKSA9PiBwYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IG1vZGVsVG9vbENhbGwsIHRvb2xzIH0pXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnRUb29sUmVzdWx0cyA9IHRvb2xzID09IG51bGwgPyBbXSA6IGF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZVxuICAgICAgICApO1xuICAgICAgICB1c2FnZS5jb21wbGV0aW9uVG9rZW5zICs9IGN1cnJlbnRVc2FnZS5jb21wbGV0aW9uVG9rZW5zO1xuICAgICAgICB1c2FnZS5wcm9tcHRUb2tlbnMgKz0gY3VycmVudFVzYWdlLnByb21wdFRva2VucztcbiAgICAgICAgdXNhZ2UudG90YWxUb2tlbnMgKz0gY3VycmVudFVzYWdlLnRvdGFsVG9rZW5zO1xuICAgICAgICBsZXQgbmV4dFN0ZXBUeXBlID0gXCJkb25lXCI7XG4gICAgICAgIGlmICgrK3N0ZXBDb3VudCA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uID09PSBcImxlbmd0aFwiICYmIC8vIG9ubHkgdXNlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIG5vIHRvb2wgY2FsbHM6XG4gICAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwiY29udGludWVcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICBjdXJyZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICBjdXJyZW50VG9vbFJlc3VsdHMubGVuZ3RoID09PSBjdXJyZW50VG9vbENhbGxzLmxlbmd0aFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJ0b29sLXJlc3VsdFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSAoX2IgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICAgICAgICBjb25zdCBzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCA9IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgJiYgLy8gb25seSBmb3IgY29udGludWUgc3RlcHNcbiAgICAgICAgdGV4dC50cmltRW5kKCkgIT09IHRleHQgPyBvcmlnaW5hbFRleHQudHJpbVN0YXJ0KCkgOiBvcmlnaW5hbFRleHQ7XG4gICAgICAgIGNvbnN0IHN0ZXBUZXh0ID0gbmV4dFN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyByZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZShzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCkgOiBzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZDtcbiAgICAgICAgdGV4dCA9IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiIHx8IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyB0ZXh0ICsgc3RlcFRleHQgOiBzdGVwVGV4dDtcbiAgICAgICAgaWYgKHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHJlc3BvbnNlTWVzc2FnZXNbcmVzcG9uc2VNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RNZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQgKz0gc3RlcFRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fSxcbiAgICAgICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSB7XG4gICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICAgIHJlcXVlc3Q6IChfYyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfYyA6IHt9LFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IChfZCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuaGVhZGVycyxcbiAgICAgICAgICAgIC8vIGRlZXAgY2xvbmUgbXNncyB0byBhdm9pZCBtdXRhdGluZyBwYXN0IG1lc3NhZ2VzIGluIG11bHRpLXN0ZXA6XG4gICAgICAgICAgICBtZXNzYWdlczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNwb25zZU1lc3NhZ2VzKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICB9O1xuICAgICAgICBzdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgIHN0ZXBUeXBlID0gbmV4dFN0ZXBUeXBlO1xuICAgICAgfSB3aGlsZSAoc3RlcFR5cGUgIT09IFwiZG9uZVwiKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgICAgICB0ZXh0LFxuICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICByZXF1ZXN0OiAoX2UgPSBjdXJyZW50TW9kZWxSZXNwb25zZS5yZXF1ZXN0KSAhPSBudWxsID8gX2UgOiB7fSxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiAoX2YgPSBjdXJyZW50TW9kZWxSZXNwb25zZS5yYXdSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmhlYWRlcnMsXG4gICAgICAgICAgbWVzc2FnZXM6IHJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgfSxcbiAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICByZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICBzdGVwcyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY3VycmVudE1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29scyh7XG4gIHRvb2xDYWxscyxcbiAgdG9vbHMsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5LFxuICBhYm9ydFNpZ25hbFxufSkge1xuICBjb25zdCB0b29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoYXN5bmMgKHRvb2xDYWxsKSA9PiB7XG4gICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgIGlmICgodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFNwYW4oe1xuICAgICAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5pZFwiOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5hcmdzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHRyYWNlcixcbiAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRvb2wyLmV4ZWN1dGUodG9vbENhbGwuYXJncywgeyBhYm9ydFNpZ25hbCB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdDIpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgcmVzdWx0XG4gICAgICB9O1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgKHJlc3VsdCkgPT4gcmVzdWx0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMudG9vbENhbGxzID0gb3B0aW9ucy50b29sQ2FsbHM7XG4gICAgdGhpcy50b29sUmVzdWx0cyA9IG9wdGlvbnMudG9vbFJlc3VsdHM7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgdGhpcy5yZXNwb25zZU1lc3NhZ2VzID0gb3B0aW9ucy5yZXNwb25zZU1lc3NhZ2VzO1xuICAgIHRoaXMucm91bmR0cmlwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5zdGVwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0ge1xuICAgICAgaGVhZGVyczogb3B0aW9ucy5yZXNwb25zZS5oZWFkZXJzXG4gICAgfTtcbiAgICB0aGlzLmxvZ3Byb2JzID0gb3B0aW9ucy5sb2dwcm9icztcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0ID0gZ2VuZXJhdGVUZXh0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9jcmVhdGUtc3RpdGNoYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKSB7XG4gIGxldCBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcbiAgY29uc3QgcHJvY2Vzc1B1bGwgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2xvc2VkICYmIGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGlubmVyU3RyZWFtUmVhZGVyc1swXS5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc1B1bGwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlclBhcmFtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgICB9LFxuICAgICAgcHVsbDogcHJvY2Vzc1B1bGwsXG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIGlubmVyU3RyZWFtUmVhZGVycykge1xuICAgICAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGFkZFN0cmVhbTogKGlubmVyU3RyZWFtKSA9PiB7XG4gICAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpbm5lciBzdHJlYW06IG91dGVyIHN0cmVhbSBpcyBjbG9zZWRcIik7XG4gICAgICB9XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMucHVzaChpbm5lclN0cmVhbS5nZXRSZWFkZXIoKSk7XG4gICAgfSxcbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL21lcmdlLXN0cmVhbXMudHNcbmZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhzdHJlYW0xLCBzdHJlYW0yKSB7XG4gIGNvbnN0IHJlYWRlcjEgPSBzdHJlYW0xLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkZXIyID0gc3RyZWFtMi5nZXRSZWFkZXIoKTtcbiAgbGV0IGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgbGV0IHN0cmVhbTFEb25lID0gZmFsc2U7XG4gIGxldCBzdHJlYW0yRG9uZSA9IGZhbHNlO1xuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMShjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDEgPSByZWFkZXIxLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMTtcbiAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMihjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDIgPSByZWFkZXIyLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMjtcbiAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdHJlYW0xRG9uZSkge1xuICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtMkRvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMiA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXN1bHQsIHJlYWRlciB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBsYXN0UmVhZDEudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjEgfSkpLFxuICAgICAgICAgIGxhc3RSZWFkMi50aGVuKChyZXN1bHQyKSA9PiAoeyByZXN1bHQ6IHJlc3VsdDIsIHJlYWRlcjogcmVhZGVyMiB9KSlcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGVyID09PSByZWFkZXIxKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTIoY29udHJvbGxlcik7XG4gICAgICAgICAgICBzdHJlYW0xRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN0cmVhbTJEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZWFkZXIxLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyMi5jYW5jZWwoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGxldCB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICBjb25zdCB0b29sUmVzdWx0c1N0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBhY3RpdmVUb29sQ2FsbHMgPSB7fTtcbiAgY29uc3Qgb3V0c3RhbmRpbmdUb29sUmVzdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBjYW5DbG9zZSA9IGZhbHNlO1xuICBsZXQgZmluaXNoQ2h1bmsgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGF0dGVtcHRDbG9zZSgpIHtcbiAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoZmluaXNoQ2h1bmsgIT0gbnVsbCkge1xuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShmaW5pc2hDaHVuayk7XG4gICAgICB9XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtZGVsdGFcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBjaHVuay5hcmdzVGV4dERlbHRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsOiBjaHVuayxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRvb2xDYWxsKTtcbiAgICAgICAgICAgIGlmICh0b29sMi5leGVjdXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvbklkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmFkZCh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5pZFwiOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmFyZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodG9vbENhbGwuYXJncylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHRvb2wyLmV4ZWN1dGUodG9vbENhbGwuYXJncywgeyBhYm9ydFNpZ25hbCB9KS50aGVuKFxuICAgICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwucmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgZmluaXNoQ2h1bmsgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBsb2dwcm9iczogY2h1bmsubG9ncHJvYnMsXG4gICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQ0ID0gY3JlYXRlSWRHZW5lcmF0b3I0KHsgcHJlZml4OiBcImFpdHh0XCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgbWF4VG9vbFJvdW5kdHJpcHMgPSAwLFxuICBtYXhTdGVwcyA9IG1heFRvb2xSb3VuZHRyaXBzICE9IG51bGwgPyBtYXhUb29sUm91bmR0cmlwcyArIDEgOiAxLFxuICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogY29udGludWVTdGVwcyA9IGZhbHNlLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhLFxuICBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmc6IHRvb2xDYWxsU3RyZWFtaW5nID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIG9uQ2h1bmssXG4gIG9uRmluaXNoLFxuICBvblN0ZXBGaW5pc2gsXG4gIF9pbnRlcm5hbDoge1xuICAgIG5vdzogbm93MiA9IG5vdyxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDQsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGlmIChtYXhTdGVwcyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm1heFN0ZXBzXCIsXG4gICAgICB2YWx1ZTogbWF4U3RlcHMsXG4gICAgICBtZXNzYWdlOiBcIm1heFN0ZXBzIG11c3QgYmUgYXQgbGVhc3QgMVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgIHRvb2xzXG4gIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0U3RlcCA9IGFzeW5jICh7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXNcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvbXB0Rm9ybWF0ID0gcmVzcG9uc2VNZXNzYWdlcy5sZW5ndGggPT09IDAgPyBpbml0aWFsUHJvbXB0LnR5cGUgOiBcIm1lc3NhZ2VzXCI7XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICB0eXBlOiBwcm9tcHRGb3JtYXQsXG4gICAgICAgICAgICBzeXN0ZW06IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLCAuLi5yZXNwb25zZU1lc3NhZ2VzXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogbW9kZWwuc3VwcG9ydHNVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlLCBhY3RpdmVUb29scyB9KVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbTogc3RyZWFtMiwgd2FybmluZ3M6IHdhcm5pbmdzMiwgcmF3UmVzcG9uc2U6IHJhd1Jlc3BvbnNlMiwgcmVxdWVzdDogcmVxdWVzdDIgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXBNczJcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gcHJvbXB0Rm9ybWF0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTExO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMTEgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogc2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjMpID0+ICh7XG4gICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjMsXG4gICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oe1xuICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgc3RyZWFtOiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MyLFxuICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdDIgIT0gbnVsbCA/IHJlcXVlc3QyIDoge30sXG4gICAgICAgICAgICByYXdSZXNwb25zZTogcmF3UmVzcG9uc2UyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXBNczJcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSwgcmVxdWVzdCB9LFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgIH0gPSBhd2FpdCBzdGFydFN0ZXAoeyByZXNwb25zZU1lc3NhZ2VzOiBbXSB9KTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQoe1xuICAgICAgICBzdHJlYW0sXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgb25DaHVuayxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG9uU3RlcEZpbmlzaCxcbiAgICAgICAgcm9vdFNwYW4sXG4gICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgICAgICBtYXhTdGVwcyxcbiAgICAgICAgY29udGludWVTdGVwcyxcbiAgICAgICAgc3RhcnRTdGVwLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICBub3c6IG5vdzIsXG4gICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICAgICAgdG9vbHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgcmVxdWVzdCxcbiAgICBvbkNodW5rLFxuICAgIG9uRmluaXNoLFxuICAgIG9uU3RlcEZpbmlzaCxcbiAgICByb290U3BhbixcbiAgICBkb1N0cmVhbVNwYW4sXG4gICAgdGVsZW1ldHJ5LFxuICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgbWF4U3RlcHMsXG4gICAgY29udGludWVTdGVwcyxcbiAgICBzdGFydFN0ZXAsXG4gICAgbW9kZWxJZCxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgdG9vbHNcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZUZpbmlzaFJlYXNvbiwgcHJvbWlzZTogZmluaXNoUmVhc29uUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvblByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVGV4dCwgcHJvbWlzZTogdGV4dFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50ZXh0ID0gdGV4dFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVG9vbENhbGxzLCBwcm9taXNlOiB0b29sQ2FsbHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbENhbGxzID0gdG9vbENhbGxzUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUb29sUmVzdWx0cywgcHJvbWlzZTogdG9vbFJlc3VsdHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSB0b29sUmVzdWx0c1Byb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlU3RlcHMsIHByb21pc2U6IHN0ZXBzUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnN0ZXBzID0gc3RlcHNQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVQcm92aWRlck1ldGFkYXRhLFxuICAgICAgcHJvbWlzZTogcHJvdmlkZXJNZXRhZGF0YVByb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVxdWVzdCwgcHJvbWlzZTogcmVxdWVzdFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVzcG9uc2UsIHByb21pc2U6IHJlc3BvbnNlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVSZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgcHJvbWlzZTogcmVzcG9uc2VNZXNzYWdlc1Byb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlTWVzc2FnZXMgPSByZXNwb25zZU1lc3NhZ2VzUHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICBzdHJlYW06IHN0aXRjaGFibGVTdHJlYW0sXG4gICAgICBhZGRTdHJlYW0sXG4gICAgICBjbG9zZTogY2xvc2VTdGl0Y2hhYmxlU3RyZWFtXG4gICAgfSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbTtcbiAgICBjb25zdCBzdGVwUmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGFkZFN0ZXBTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBzdHJlYW0yLFxuICAgICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICBjdXJyZW50U3RlcCxcbiAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICB1c2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfSxcbiAgICAgIHN0ZXBUeXBlLFxuICAgICAgcHJldmlvdXNTdGVwVGV4dCA9IFwiXCIsXG4gICAgICBzdGVwUmVxdWVzdCxcbiAgICAgIGhhc0xlYWRpbmdXaGl0ZXNwYWNlXG4gICAgfSkge1xuICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IFtdO1xuICAgICAgY29uc3Qgc3RlcFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgc3RlcEZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICAgICAgbGV0IHN0ZXBVc2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfTtcbiAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIGxldCBzdGVwRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICBsZXQgc3RlcFRleHQgPSBcIlwiO1xuICAgICAgbGV0IGZ1bGxTdGVwVGV4dCA9IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyBwcmV2aW91c1N0ZXBUZXh0IDogXCJcIjtcbiAgICAgIGxldCBzdGVwTG9nUHJvYnM7XG4gICAgICBsZXQgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICBtb2RlbElkXG4gICAgICB9O1xuICAgICAgbGV0IGNodW5rQnVmZmVyID0gXCJcIjtcbiAgICAgIGxldCBjaHVua1RleHRQdWJsaXNoZWQgPSBmYWxzZTtcbiAgICAgIGxldCBpbldoaXRlc3BhY2VQcmVmaXggPSB0cnVlO1xuICAgICAgbGV0IGhhc1doaXRlc3BhY2VTdWZmaXggPSBmYWxzZTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICBjaHVua1xuICAgICAgfSkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBzdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGZ1bGxTdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGNodW5rVGV4dFB1Ymxpc2hlZCA9IHRydWU7XG4gICAgICAgIGhhc1doaXRlc3BhY2VTdWZmaXggPSBjaHVuay50ZXh0RGVsdGEudHJpbUVuZCgpICE9PSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgfVxuICAgICAgYWRkU3RyZWFtKFxuICAgICAgICBzdHJlYW0yLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHZhciBfYTExLCBfYiwgX2M7XG4gICAgICAgICAgICAgIGlmIChzdGVwRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaXJzdENodW5rID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgc3RlcEZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVuayxcbiAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiICYmIGNodW5rLnRleHREZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkQ2h1bmtUZXh0ID0gaW5XaGl0ZXNwYWNlUHJlZml4ICYmIGhhc0xlYWRpbmdXaGl0ZXNwYWNlID8gY2h1bmsudGV4dERlbHRhLnRyaW1TdGFydCgpIDogY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpbW1lZENodW5rVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbldoaXRlc3BhY2VQcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgKz0gdHJpbW1lZENodW5rVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdE9uTGFzdFdoaXRlc3BhY2UoY2h1bmtCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNodW5rQnVmZmVyID0gc3BsaXQuc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHNwbGl0LnByZWZpeCArIHNwbGl0LndoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIsIGNodW5rIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sUmVzdWx0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExMSA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExMSA6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYiA6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHN0ZXBSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgICAgc3RlcFByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBMb2dQcm9icyA9IGNodW5rLmxvZ3Byb2JzO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpbmlzaCA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaW5pc2hcIjogbXNUb0ZpbmlzaCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5hdmdDb21wbGV0aW9uVG9rZW5zUGVyU2Vjb25kXCI6IDFlMyAqIHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zIC8gbXNUb0ZpbmlzaFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHNKc29uID0gc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGxldCBuZXh0U3RlcFR5cGUgPSBcImRvbmVcIjtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGVwICsgMSA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgc3RlcEZpbmlzaFJlYXNvbiA9PT0gXCJsZW5ndGhcIiAmJiAvLyBvbmx5IHVzZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBubyB0b29sIGNhbGxzOlxuICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSB0b29sIGNhbGxzOlxuICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICAgICAgICAgICAgc3RlcFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gc3RlcFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwidG9vbC1yZXN1bHRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgY2h1bmtCdWZmZXIubGVuZ3RoID4gMCAmJiAobmV4dFN0ZXBUeXBlICE9PSBcImNvbnRpbnVlXCIgfHwgLy8gd2hlbiB0aGUgbmV4dCBzdGVwIGlzIGEgcmVndWxhciBzdGVwLCBwdWJsaXNoIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgc3RlcFR5cGUgPT09IFwiY29udGludWVcIiAmJiAhY2h1bmtUZXh0UHVibGlzaGVkKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IGNodW5rQnVmZmVyXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBzdGVwVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbc3RlcEZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHN0ZXBSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzdGVwVXNhZ2UsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNDb250aW51ZWQ6IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoc3RlcFR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gcmVzcG9uc2VNZXNzYWdlc1tyZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdE1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudCArPSBzdGVwVGV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgLi4udG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcFRvb2xSZXN1bHRzXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBzdGVwVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzdGVwVXNhZ2UsXG4gICAgICAgICAgICAgICAgd2FybmluZ3M6IHNlbGYud2FybmluZ3MsXG4gICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICByYXdSZXNwb25zZTogc2VsZi5yYXdSZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyczogKF9hMTEgPSBzZWxmLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgLy8gZGVlcCBjbG9uZSBtc2dzIHRvIGF2b2lkIG11dGF0aW5nIHBhc3QgbWVzc2FnZXMgaW4gbXVsdGktc3RlcDpcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZXMpKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGVwUmVzdWx0cy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkVXNhZ2UgPSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyBzdGVwVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgKyBzdGVwVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogdXNhZ2UudG90YWxUb2tlbnMgKyBzdGVwVXNhZ2UudG90YWxUb2tlbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKG5leHRTdGVwVHlwZSAhPT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjMsXG4gICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBzdGFydFRpbWVzdGFtcDJcbiAgICAgICAgICAgICAgICB9ID0gYXdhaXQgc3RhcnRTdGVwKHsgcmVzcG9uc2VNZXNzYWdlcyB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLndhcm5pbmdzID0gcmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgICAgICAgIHNlbGYucmF3UmVzcG9uc2UgPSByZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgYWRkU3RlcFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgICBzdHJlYW06IHJlc3VsdC5zdHJlYW0sXG4gICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcDogc3RhcnRUaW1lc3RhbXAyLFxuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4zLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGN1cnJlbnRTdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIHN0ZXBUeXBlOiBuZXh0U3RlcFR5cGUsXG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1N0ZXBUZXh0OiBmdWxsU3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICBzdGVwUmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBoYXNMZWFkaW5nV2hpdGVzcGFjZTogaGFzV2hpdGVzcGFjZVN1ZmZpeFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNvbWJpbmVkVXNhZ2UsXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvc2VTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gZnVsbFN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY29tYmluZWRVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGNvbWJpbmVkVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBmdWxsU3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc29sdmVVc2FnZShjb21iaW5lZFVzYWdlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlRmluaXNoUmVhc29uKHN0ZXBGaW5pc2hSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVUZXh0KGZ1bGxTdGVwVGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRvb2xDYWxscyhzdGVwVG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YShzdGVwUHJvdmlkZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRvb2xSZXN1bHRzKHN0ZXBUb29sUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVJlcXVlc3Qoc3RlcFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiByZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVN0ZXBzKHN0ZXBSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUmVzcG9uc2VNZXNzYWdlcyhyZXNwb25zZU1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGZ1bGxTdGVwVGV4dCxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsczogc3RlcFRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSB0b29sIHJlc3VsdHMgYXJlIGluZmVycmVkIGFzIGEgbmV2ZXJbXSB0eXBlLCBiZWNhdXNlIHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCBhbmQgdGhlIGV4ZWN1dGUgbWV0aG9kIHdpdGggYW4gaW5mZXJyZWQgcmVzdWx0IHR5cGUgaXNcbiAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIGFzIHdlbGwuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGNhc3QgdGhlIHRvb2xSZXN1bHRzIHRvIGFueS5cbiAgICAgICAgICAgICAgICAgIC8vIFRoZSB0eXBlIGV4cG9zZWQgdG8gdGhlIHVzZXJzIHdpbGwgYmUgY29ycmVjdGx5IGluZmVycmVkLlxuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHN0ZXBUb29sUmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgc3RlcHM6IHN0ZXBSZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGFkZFN0ZXBTdHJlYW0oe1xuICAgICAgc3RyZWFtLFxuICAgICAgc3RhcnRUaW1lc3RhbXA6IHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICBjdXJyZW50U3RlcDogMCxcbiAgICAgIHJlc3BvbnNlTWVzc2FnZXM6IFtdLFxuICAgICAgdXNhZ2U6IHZvaWQgMCxcbiAgICAgIHN0ZXBUeXBlOiBcImluaXRpYWxcIixcbiAgICAgIHN0ZXBSZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgaGFzTGVhZGluZ1doaXRlc3BhY2U6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLm9yaWdpbmFsU3RyZWFtLnRlZSgpO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0yO1xuICAgIHJldHVybiBzdHJlYW0xO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRvQUlTdHJlYW0oY2FsbGJhY2tzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy50b0RhdGFTdHJlYW1JbnRlcm5hbCh7IGNhbGxiYWNrcyB9KTtcbiAgfVxuICB0b0RhdGFTdHJlYW1JbnRlcm5hbCh7XG4gICAgY2FsbGJhY2tzID0ge30sXG4gICAgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2UzID0gKCkgPT4gXCJcIixcbiAgICAvLyBtYXNrIGVycm9yIG1lc3NhZ2VzIGZvciBzYWZldHkgYnkgZGVmYXVsdFxuICAgIHNlbmRVc2FnZSA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gICAgY29uc3QgY2FsbGJhY2tUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0RGVsdGEgPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IHRleHREZWx0YTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbih0ZXh0RGVsdGEpO1xuICAgICAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0KVxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dCh0ZXh0RGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsKVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RyZWFtUGFydHNUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgY2h1bmsudGV4dERlbHRhKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxfZGVsdGFcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfY2FsbFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnczogY2h1bmsuYXJnc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9yZXN1bHRcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBjaHVuay5yZXN1bHRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImVycm9yXCIsIGdldEVycm9yTWVzc2FnZTMoY2h1bmsuZXJyb3IpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3RlcC1maW5pc2hcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZmluaXNoX3N0ZXBcIiwge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzZW5kVXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBjaHVuay5pc0NvbnRpbnVlZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImZpbmlzaF9tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICB1c2FnZTogc2VuZFVzYWdlID8ge1xuICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChjYWxsYmFja1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChzdHJlYW1QYXJ0c1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG4gIH1cbiAgcGlwZUFJU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCk7XG4gIH1cbiAgcGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiaW5pdFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmluaXQgOiB7XG4gICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogdm9pZCAwLFxuICAgICAgc3RhdHVzOiBcInN0YXR1c1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1c1RleHQ6IFwic3RhdHVzVGV4dFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImRhdGFcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kYXRhIDogdm9pZCAwO1xuICAgIGNvbnN0IGdldEVycm9yTWVzc2FnZTMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImdldEVycm9yTWVzc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmdldEVycm9yTWVzc2FnZSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZW5kVXNhZ2UgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcInNlbmRVc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlbmRVc2FnZSA6IHZvaWQgMDtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXM6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRvRGF0YVN0cmVhbSh7IGRhdGEsIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlMywgc2VuZFVzYWdlIH0pXG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHVzOiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIHRvQUlTdHJlYW1SZXNwb25zZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucyk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICAgIGdldEVycm9yTWVzc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UsXG4gICAgICBzZW5kVXNhZ2U6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VuZFVzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpID8gbWVyZ2VTdHJlYW1zKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YS5zdHJlYW0sIHN0cmVhbSkgOiBzdHJlYW07XG4gIH1cbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucykge1xuICAgIHZhciBfYTExO1xuICAgIGNvbnN0IGluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImluaXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pbml0IDoge1xuICAgICAgaGVhZGVyczogXCJoZWFkZXJzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaGVhZGVycyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1czogXCJzdGF0dXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiB2b2lkIDAsXG4gICAgICBzdGF0dXNUZXh0OiBcInN0YXR1c1RleHRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJkYXRhXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcbiAgICBjb25zdCBnZXRFcnJvck1lc3NhZ2UzID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJnZXRFcnJvck1lc3NhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VuZFVzYWdlID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJzZW5kVXNhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zZW5kVXNhZ2UgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIHRoaXMudG9EYXRhU3RyZWFtKHsgZGF0YSwgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2UzLCBzZW5kVXNhZ2UgfSksXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExMTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0ID0gc3RyZWFtVGV4dDtcblxuLy8gY29yZS9taWRkbGV3YXJlL3dyYXAtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciBleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogeyB0cmFuc2Zvcm1QYXJhbXMsIHdyYXBHZW5lcmF0ZSwgd3JhcFN0cmVhbSB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSB9KSA6IHBhcmFtcztcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYxXCIsXG4gICAgcHJvdmlkZXI6IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogbW9kZWwubW9kZWxJZCxcbiAgICBkZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU6IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSxcbiAgICBzdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgc3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsLFxuICAgIHN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHM6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMsXG4gICAgYXN5bmMgZG9HZW5lcmF0ZShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwiZ2VuZXJhdGVcIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIHJldHVybiB3cmFwR2VuZXJhdGUgPyB3cmFwR2VuZXJhdGUoeyBkb0dlbmVyYXRlLCBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLCBtb2RlbCB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIGRvU3RyZWFtKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJzdHJlYW1cIiB9KTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBTdHJlYW0gPyB3cmFwU3RyZWFtKHsgZG9TdHJlYW0sIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9TdHJlYW0oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L2N1c3RvbS1wcm92aWRlci50c1xuaW1wb3J0IHsgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIoe1xuICBsYW5ndWFnZU1vZGVscyxcbiAgdGV4dEVtYmVkZGluZ01vZGVscyxcbiAgZmFsbGJhY2tQcm92aWRlclxufSkge1xuICByZXR1cm4ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGxhbmd1YWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBsYW5ndWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gdGV4dEVtYmVkZGluZ01vZGVscykge1xuICAgICAgICByZXR1cm4gdGV4dEVtYmVkZGluZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIiB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvcmVnaXN0cnkvbm8tc3VjaC1wcm92aWRlci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTEsIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMCA9IFwiQUlfTm9TdWNoUHJvdmlkZXJFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb1N1Y2hQcm92aWRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBOb1N1Y2hNb2RlbEVycm9yMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBwcm92aWRlcklkLFxuICAgIGF2YWlsYWJsZVByb3ZpZGVycyxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggcHJvdmlkZXI6ICR7cHJvdmlkZXJJZH0gKGF2YWlsYWJsZSBwcm92aWRlcnM6ICR7YXZhaWxhYmxlUHJvdmlkZXJzLmpvaW4oKX0pYFxuICB9KSB7XG4gICAgc3VwZXIoeyBlcnJvck5hbWU6IG5hbWUxMCwgbW9kZWxJZCwgbW9kZWxUeXBlLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgdGhpcy5hdmFpbGFibGVQcm92aWRlcnMgPSBhdmFpbGFibGVQcm92aWRlcnM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjExLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaFByb3ZpZGVyRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTAgJiYgdHlwZW9mIGVycm9yLnByb3ZpZGVySWQgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShlcnJvci5hdmFpbGFibGVQcm92aWRlcnMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtb2RlbFR5cGU6IHRoaXMubW9kZWxUeXBlLFxuICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiB0aGlzLmF2YWlsYWJsZVByb3ZpZGVyc1xuICAgIH07XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIGNvcmUvcmVnaXN0cnkvcHJvdmlkZXItcmVnaXN0cnkudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkocHJvdmlkZXJzKSB7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gbmV3IERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5KCk7XG4gIGZvciAoY29uc3QgW2lkLCBwcm92aWRlcl0gb2YgT2JqZWN0LmVudHJpZXMocHJvdmlkZXJzKSkge1xuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyUHJvdmlkZXIoeyBpZCwgcHJvdmlkZXIgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufVxudmFyIGV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5ID0gZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnk7XG52YXIgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvdmlkZXJzID0ge307XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcih7XG4gICAgaWQsXG4gICAgcHJvdmlkZXJcbiAgfSkge1xuICAgIHRoaXMucHJvdmlkZXJzW2lkXSA9IHByb3ZpZGVyO1xuICB9XG4gIGdldFByb3ZpZGVyKGlkKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyc1tpZF07XG4gICAgaWYgKHByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hQcm92aWRlckVycm9yKHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIsXG4gICAgICAgIHByb3ZpZGVySWQ6IGlkLFxuICAgICAgICBhdmFpbGFibGVQcm92aWRlcnM6IE9iamVjdC5rZXlzKHRoaXMucHJvdmlkZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBzcGxpdElkKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBpbmRleCA9IGlkLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bW9kZWxUeXBlfSBpZCBmb3IgcmVnaXN0cnk6ICR7aWR9IChtdXN0IGJlIGluIHRoZSBmb3JtYXQgXCJwcm92aWRlcklkOm1vZGVsSWRcIilgXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtpZC5zbGljZSgwLCBpbmRleCksIGlkLnNsaWNlKGluZGV4ICsgMSldO1xuICB9XG4gIGxhbmd1YWdlTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExMSwgX2I7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImxhbmd1YWdlTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2IgPSAoX2ExMSA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCkpLmxhbmd1YWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMTEsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRleHRFbWJlZGRpbmdNb2RlbChpZCkge1xuICAgIHZhciBfYTExLCBfYiwgX2M7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInRleHRFbWJlZGRpbmdNb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCk7XG4gICAgY29uc3QgbW9kZWwgPSAoX2MgPSAoX2ExMSA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChwcm92aWRlciwgbW9kZWxJZCkpICE9IG51bGwgPyBfYyA6IFwidGV4dEVtYmVkZGluZ1wiIGluIHByb3ZpZGVyID8gKF9iID0gcHJvdmlkZXIudGV4dEVtYmVkZGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpIDogdm9pZCAwO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRleHRFbWJlZGRpbmdNb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHRleHRFbWJlZGRpbmdNb2RlbGAgaW5zdGVhZC5cbiAgICovXG4gIHRleHRFbWJlZGRpbmcoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0RW1iZWRkaW5nTW9kZWwoaWQpO1xuICB9XG59O1xuXG4vLyBjb3JlL3Rvb2wvdG9vbC50c1xuZnVuY3Rpb24gdG9vbCh0b29sMikge1xuICByZXR1cm4gdG9vbDI7XG59XG5cbi8vIGNvcmUvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoICh2ZWN0b3IxOiAke3ZlY3RvcjEubGVuZ3RofSBlbGVtZW50cywgdmVjdG9yMjogJHt2ZWN0b3IyLmxlbmd0aH0gZWxlbWVudHMpYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvdFByb2R1Y3QodmVjdG9yMSwgdmVjdG9yMikgLyAobWFnbml0dWRlKHZlY3RvcjEpICogbWFnbml0dWRlKHZlY3RvcjIpKTtcbn1cbmZ1bmN0aW9uIGRvdFByb2R1Y3QodmVjdG9yMSwgdmVjdG9yMikge1xuICByZXR1cm4gdmVjdG9yMS5yZWR1Y2UoXG4gICAgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgpID0+IGFjY3VtdWxhdG9yICsgdmFsdWUgKiB2ZWN0b3IyW2luZGV4XSxcbiAgICAwXG4gICk7XG59XG5mdW5jdGlvbiBtYWduaXR1ZGUodmVjdG9yKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZG90UHJvZHVjdCh2ZWN0b3IsIHZlY3RvcikpO1xufVxuXG4vLyBzdHJlYW1zL2FpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJldmVudFwiICYmIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIgfHwgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgZXZlbnQuZXZlbnQgPT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXIgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICAgIH0pIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICByZXR1cm4gXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGxcIiBpbiBjYWxsYmFja3M7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQpID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFJU3RyZWFtKHJlc3BvbnNlLCBjdXN0b21QYXJzZXIsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihcIlJlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgYXdhaXQgKChfYTExID0gaXQucmV0dXJuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKGl0LCByZWFzb24pKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG5pbXBvcnQgeyBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQyIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gdXRpbC9jb25zdGFudHMudHNcbnZhciBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMgPSAxNSAqIDFlMztcblxuLy8gc3RyZWFtcy9zdHJlYW0tZGF0YS50c1xudmFyIFN0cmVhbURhdGEyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLndhcm5pbmdUaW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLnN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogYXN5bmMgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICBzZWxmLndhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHB1bGw6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAocmVhc29uKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy53YXJuaW5nVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FybmluZ1RpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBhcHBlbmQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQyKFwiZGF0YVwiLCBbdmFsdWVdKSlcbiAgICApO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcInRleHRcIiwgbWVzc2FnZSkpKTtcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW1EYXRhMiB7XG59O1xuXG4vLyBzdHJlYW1zL2FudGhyb3BpYy1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlQW50aHJvcGljU3RyZWFtKCkge1xuICBsZXQgcHJldmlvdXMgPSBcIlwiO1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBpZiAoXCJlcnJvclwiIGluIGpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtqc29uLmVycm9yLnR5cGV9OiAke2pzb24uZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKCEoXCJjb21wbGV0aW9uXCIgaW4ganNvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGpzb24uY29tcGxldGlvbjtcbiAgICBpZiAoIXByZXZpb3VzIHx8IHRleHQubGVuZ3RoID4gcHJldmlvdXMubGVuZ3RoICYmIHRleHQuc3RhcnRzV2l0aChwcmV2aW91cykpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gdGV4dC5zbGljZShwcmV2aW91cy5sZW5ndGgpO1xuICAgICAgcHJldmlvdXMgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcImNvbXBsZXRpb25cIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rLmNvbXBsZXRpb247XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICB9IGVsc2UgaWYgKFwiZGVsdGFcIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgeyBkZWx0YSB9ID0gY2h1bms7XG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gZGVsdGEpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRlbHRhLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgIHlpZWxkIHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBbnRocm9waWNTdHJlYW0ocmVzLCBjYikge1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQUlTdHJlYW0ocmVzLCBwYXJzZUFudGhyb3BpY1N0cmVhbSgpLCBjYikucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9hc3Npc3RhbnQtcmVzcG9uc2UudHNcbmltcG9ydCB7XG4gIGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDNcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIEFzc2lzdGFudFJlc3BvbnNlKHsgdGhyZWFkSWQsIG1lc3NhZ2VJZCB9LCBwcm9jZXNzMikge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImFzc2lzdGFudF9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmREYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJkYXRhX21lc3NhZ2VcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZEVycm9yID0gKGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiZXJyb3JcIiwgZXJyb3JNZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmb3J3YXJkU3RyZWFtID0gYXN5bmMgKHN0cmVhbTIpID0+IHtcbiAgICAgICAgdmFyIF9hMTIsIF9iO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHN0cmVhbTIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuY3JlYXRlZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0MyhcImFzc2lzdGFudF9tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiB7IHZhbHVlOiBcIlwiIH0gfV1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoX2ExMiA9IHZhbHVlLmRhdGEuZGVsdGEuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTJbMF07XG4gICAgICAgICAgICAgIGlmICgoY29udGVudCA9PSBudWxsID8gdm9pZCAwIDogY29udGVudC50eXBlKSA9PT0gXCJ0ZXh0XCIgJiYgKChfYiA9IGNvbnRlbnQudGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZhbHVlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0MyhcInRleHRcIiwgY29udGVudC50ZXh0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5jb21wbGV0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvblwiOiB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQzKFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLCB7XG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9jZXNzMih7XG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICAgIHNlbmREYXRhTWVzc2FnZSxcbiAgICAgICAgICBmb3J3YXJkU3RyZWFtXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VuZEVycm9yKChfYTExID0gZXJyb3IubWVzc2FnZSkgIT0gbnVsbCA/IF9hMTEgOiBgJHtlcnJvcn1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1bGwoY29udHJvbGxlcikge1xuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG4gICAgc3RhdHVzOiAyMDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSA9IEFzc2lzdGFudFJlc3BvbnNlO1xuXG4vLyBzdHJlYW1zL2F3cy1iZWRyb2NrLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICB2YXIgX2ExMSwgX2I7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiAoX2ExMSA9IHJlc3BvbnNlLmJvZHkpICE9IG51bGwgPyBfYTExIDogW10pIHtcbiAgICBjb25zdCBieXRlcyA9IChfYiA9IGNodW5rLmNodW5rKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYnl0ZXM7XG4gICAgaWYgKGJ5dGVzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rVGV4dCA9IGRlY29kZXIuZGVjb2RlKGJ5dGVzKTtcbiAgICAgIGNvbnN0IGNodW5rSlNPTiA9IEpTT04ucGFyc2UoY2h1bmtUZXh0KTtcbiAgICAgIGNvbnN0IGRlbHRhID0gZXh0cmFjdFRleHREZWx0YUZyb21DaHVuayhjaHVua0pTT04pO1xuICAgICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgeWllbGQgZGVsdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljTWVzc2FnZXNTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IHtcbiAgICB2YXIgX2ExMTtcbiAgICByZXR1cm4gKF9hMTEgPSBjaHVuay5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEudGV4dDtcbiAgfSk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5jb21wbGV0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tDb2hlcmVTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rID09IG51bGwgPyB2b2lkIDAgOiBjaHVuay50ZXh0KTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmdlbmVyYXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKFxuICAgIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaylcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMihyZXMpIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHJlYWRlciA9IChfYTExID0gcmVzLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUyKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChjaHVuay5ldmVudFR5cGUgPT09IFwidGV4dC1nZW5lcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay50ZXh0O1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBDb2hlcmVTdHJlYW0ocmVhZGVyLCBjYWxsYmFja3MpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlYWRlcikge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUyKHJlYWRlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlUGFyc2VyMihyZWFkZXIpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2dvb2dsZS1nZW5lcmF0aXZlLWFpLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUzKHJlc3BvbnNlKSB7XG4gIHZhciBfYTExLCBfYiwgX2M7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2Uuc3RyZWFtKSB7XG4gICAgY29uc3QgcGFydHMgPSAoX2MgPSAoX2IgPSAoX2ExMSA9IGNodW5rLmNhbmRpZGF0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTExWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnBhcnRzO1xuICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHNbMF07XG4gICAgaWYgKHR5cGVvZiBmaXJzdFBhcnQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgeWllbGQgZmlyc3RQYXJ0LnRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0ocmVzcG9uc2UsIGNiKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUzKHJlc3BvbnNlKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvaHVnZ2luZ2ZhY2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIzKHJlcykge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hMTEsIF9iO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVzLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYiA9IChfYTExID0gdmFsdWUudG9rZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYTExLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIpO1xuICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodmFsdWUuZ2VuZXJhdGVkX3RleHQgIT0gbnVsbCAmJiB2YWx1ZS5nZW5lcmF0ZWRfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ID09PSBcIjwvcz5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kb2Z0ZXh0fD5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kfD5cIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEh1Z2dpbmdGYWNlU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBjcmVhdGVQYXJzZXIzKHJlcykucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2lua2VlcC1zdHJlYW0udHNcbmZ1bmN0aW9uIElua2VlcFN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2UgYm9keSBpcyBudWxsXCIpO1xuICB9XG4gIGxldCBjaGF0X3Nlc3Npb25faWQgPSBcIlwiO1xuICBsZXQgcmVjb3Jkc19jaXRlZDtcbiAgY29uc3QgaW5rZWVwRXZlbnRQYXJzZXIgPSAoZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfYTExLCBfYjtcbiAgICBjb25zdCB7IGV2ZW50IH0gPSBvcHRpb25zO1xuICAgIGlmIChldmVudCA9PT0gXCJyZWNvcmRzX2NpdGVkXCIpIHtcbiAgICAgIHJlY29yZHNfY2l0ZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgKF9hMTEgPSBjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblJlY29yZHNDaXRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChjYWxsYmFja3MsIHJlY29yZHNfY2l0ZWQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgPT09IFwibWVzc2FnZV9jaHVua1wiKSB7XG4gICAgICBjb25zdCBpbmtlZXBNZXNzYWdlQ2h1bmsgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgY2hhdF9zZXNzaW9uX2lkID0gKF9iID0gaW5rZWVwTWVzc2FnZUNodW5rLmNoYXRfc2Vzc2lvbl9pZCkgIT0gbnVsbCA/IF9iIDogY2hhdF9zZXNzaW9uX2lkO1xuICAgICAgcmV0dXJuIGlua2VlcE1lc3NhZ2VDaHVuay5jb250ZW50X2NodW5rO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG4gIGxldCB7IG9uUmVjb3Jkc0NpdGVkLCAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyB9ID0gY2FsbGJhY2tzIHx8IHt9O1xuICBwYXNzVGhyb3VnaENhbGxiYWNrcyA9IHtcbiAgICAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyxcbiAgICBvbkZpbmFsOiAoY29tcGxldGlvbikgPT4ge1xuICAgICAgdmFyIF9hMTE7XG4gICAgICBjb25zdCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEgPSB7XG4gICAgICAgIGNoYXRfc2Vzc2lvbl9pZCxcbiAgICAgICAgcmVjb3Jkc19jaXRlZFxuICAgICAgfTtcbiAgICAgIChfYTExID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25GaW5hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChjYWxsYmFja3MsIGNvbXBsZXRpb24sIGlua2VlcE9uRmluYWxNZXRhZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQUlTdHJlYW0ocmVzLCBpbmtlZXBFdmVudFBhcnNlciwgcGFzc1Rocm91Z2hDYWxsYmFja3MpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLWFkYXB0ZXIudHNcbnZhciBsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzLCB7XG4gIHRvQUlTdHJlYW06ICgpID0+IHRvQUlTdHJlYW0sXG4gIHRvRGF0YVN0cmVhbTogKCkgPT4gdG9EYXRhU3RyZWFtLFxuICB0b0RhdGFTdHJlYW1SZXNwb25zZTogKCkgPT4gdG9EYXRhU3RyZWFtUmVzcG9uc2Vcbn0pO1xuZnVuY3Rpb24gdG9BSVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gdG9EYXRhU3RyZWFtKHN0cmVhbSwgY2FsbGJhY2tzKTtcbn1cbmZ1bmN0aW9uIHRvRGF0YVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAodmFsdWUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJldmVudFwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmV2ZW50ID09PSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayhcbiAgICAgICAgICAgICAgKF9hMTEgPSB2YWx1ZS5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jaHVuayxcbiAgICAgICAgICAgICAgY29udHJvbGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayh2YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IGRhdGFTdHJlYW0gPSB0b0RhdGFTdHJlYW0oc3RyZWFtLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNhbGxiYWNrcyk7XG4gIGNvbnN0IGRhdGEgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGE7XG4gIGNvbnN0IGluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmluaXQ7XG4gIGNvbnN0IHJlc3BvbnNlU3RyZWFtID0gZGF0YSA/IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgZGF0YVN0cmVhbSkgOiBkYXRhU3RyZWFtO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlU3RyZWFtLCB7XG4gICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjaHVuay5jb250ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb250ZW50KSB7XG4gICAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoaXRlbS50ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9sbGFtYWluZGV4LWFkYXB0ZXIudHNcbnZhciBsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMsIHtcbiAgdG9EYXRhU3RyZWFtOiAoKSA9PiB0b0RhdGFTdHJlYW0yLFxuICB0b0RhdGFTdHJlYW1SZXNwb25zZTogKCkgPT4gdG9EYXRhU3RyZWFtUmVzcG9uc2UyXG59KTtcbmZ1bmN0aW9uIHRvRGF0YVN0cmVhbTIoc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvUmVhZGFibGVTdHJlYW0oc3RyZWFtKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZTIoc3RyZWFtLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHsgaW5pdCwgZGF0YSwgY2FsbGJhY2tzIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtMihzdHJlYW0sIGNhbGxiYWNrcyk7XG4gIGNvbnN0IHJlc3BvbnNlU3RyZWFtID0gZGF0YSA/IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgZGF0YVN0cmVhbSkgOiBkYXRhU3RyZWFtO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlU3RyZWFtLCB7XG4gICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1JlYWRhYmxlU3RyZWFtKHJlcykge1xuICBjb25zdCBpdCA9IHJlc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKF9hMTEgPSB2YWx1ZS5kZWx0YSkgIT0gbnVsbCA/IF9hMTEgOiBcIlwiKTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1zdHJlYW0udHNcbmZ1bmN0aW9uIExhbmdDaGFpblN0cmVhbShjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gIGNvbnN0IHJ1bnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgYXdhaXQgd3JpdGVyLmFib3J0KGUpO1xuICB9O1xuICBjb25zdCBoYW5kbGVTdGFydCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuYWRkKHJ1bklkKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlRW5kID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGlmIChydW5zLnNpemUgPT09IDApIHtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IHN0cmVhbS5yZWFkYWJsZS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSksXG4gICAgd3JpdGVyLFxuICAgIGhhbmRsZXJzOiB7XG4gICAgICBoYW5kbGVMTE1OZXdUb2tlbjogYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1TdGFydDogYXN5bmMgKF9sbG0sIF9wcm9tcHRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpblN0YXJ0OiBhc3luYyAoX2NoYWluLCBfaW5wdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FbmQ6IGFzeW5jIChfb3V0cHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xTdGFydDogYXN5bmMgKF90b29sLCBfaW5wdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBzdHJlYW1zL21pc3RyYWwtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTQoc3RyZWFtKSB7XG4gIHZhciBfYTExLCBfYjtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hMTEgPSBjaHVuay5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCB8fCBjb250ZW50ID09PSBcIlwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgeWllbGQgY29udGVudDtcbiAgfVxufVxuZnVuY3Rpb24gTWlzdHJhbFN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTQocmVzcG9uc2UpKTtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvb3BlbmFpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlQ2h1bmtEZWNvZGVyLFxuICBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQ0XG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiAoZGF0YSkgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNShzdHJlYW0pIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcInByb21wdEZpbHRlclJlc3VsdHNcIiBpbiBjaHVuaykge1xuICAgICAgY2h1bmsgPSB7XG4gICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgY3JlYXRlZDogY2h1bmsuY3JlYXRlZC5nZXREYXRlKCksXG4gICAgICAgIG9iamVjdDogY2h1bmsub2JqZWN0LFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgbW9kZWw6IGNodW5rLm1vZGVsLFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgY2hvaWNlczogY2h1bmsuY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTExLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgICBjb250ZW50OiAoX2ExMSA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY29udGVudCxcbiAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogKF9iID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgICByb2xlOiAoX2MgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yb2xlLFxuICAgICAgICAgICAgICB0b29sX2NhbGxzOiAoKF9lID0gKF9kID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2QudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2UubGVuZ3RoKSA/IChfZyA9IChfZiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwudHlwZVxuICAgICAgICAgICAgICB9KSkgOiB2b2lkIDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uOiBjaG9pY2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgaW5kZXg6IGNob2ljZS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gZXh0cmFjdChjaHVuayk7XG4gICAgaWYgKHRleHQpXG4gICAgICB5aWVsZCB0ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBjaHVua1RvVGV4dCgpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luO1xuICByZXR1cm4gKGpzb24pID0+IHtcbiAgICB2YXIgX2ExMSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yO1xuICAgIGlmIChpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gKF9hMTEgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmRlbHRhO1xuICAgICAgaWYgKChfYiA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHtkZWx0YS5mdW5jdGlvbl9jYWxsLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2UgPSAoX2QgPSAoX2MgPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9vbENhbGwgPSBkZWx0YS50b29sX2NhbGxzWzBdO1xuICAgICAgICBpZiAodG9vbENhbGwuaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGB7XCJ0b29sX2NhbGxzXCI6WyB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9mID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZi5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYFwifX0sIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2cgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKF9oID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX2kgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2wgPSAoX2sgPSAoX2ogPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2pbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfay5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9sLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX28gPSAoX24gPSAoX20gPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX21bMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9vLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoKF9wID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3AuZmluaXNoX3JlYXNvbikgPT09IFwiZnVuY3Rpb25fY2FsbFwiIHx8ICgoX3EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcS5maW5pc2hfcmVhc29uKSA9PT0gXCJzdG9wXCIpKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX0nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKF9yID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3IuZmluaXNoX3JlYXNvbikgPT09IFwidG9vbF9jYWxsc1wiKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50ID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgOiBpc0NvbXBsZXRpb24oanNvbikgPyBqc29uLmNob2ljZXNbMF0udGV4dCA6IFwiXCJcbiAgICApO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bmspIHtcbiAgICBsZXQgZXNjYXBlZFBhcnRpYWxKc29uID0gYXJndW1lbnRDaHVuay5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXFwvL2csIFwiXFxcXC9cIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcZi9nLCBcIlxcXFxmXCIpO1xuICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgfVxufVxudmFyIF9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wgPSBTeW1ib2woXG4gIFwiaW50ZXJuYWxfb3BlbmFpX2ZuX21lc3NhZ2VzXCJcbik7XG5mdW5jdGlvbiBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwiZGVsdGFcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwidGV4dFwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIE9wZW5BSVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBjb25zdCBjYiA9IGNhbGxiYWNrcztcbiAgbGV0IHN0cmVhbTtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTUocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgICB9IDoge1xuICAgICAgICAgIC4uLmNiXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgLi4uY2IsXG4gICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY2JcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYWxsYmFja3MpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9IGlzRmlyc3RDaHVuayAmJiAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHwgbWVzc2FnZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpO1xuICAgICAgaWYgKHNob3VsZEhhbmRsZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQ0KFwidGV4dFwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1BheWxvYWRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBheWxvYWQuZnVuY3Rpb25fY2FsbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSB7XG4gICAgICAgICAgICAgIHRvb2xzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbDIgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbDIuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wyLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04ucGFyc2UodG9vbDIuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpZiBpdCdzIHRoZSBmaXJzdCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlSW5kZXggPT09IDAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Yy5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX3Jlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOlwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0NChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/IFwiZnVuY3Rpb25fY2FsbFwiIDogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0NChcInRleHRcIiwgZnVuY3Rpb25SZXNwb25zZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gZnVuY3Rpb25SZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdm9pZCAwO1xuICAgICAgICAgIGNvbnN0IG9wZW5BSVN0cmVhbSA9IE9wZW5BSVN0cmVhbShmdW5jdGlvblJlc3BvbnNlLCB7XG4gICAgICAgICAgICAuLi5maWx0ZXJlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXTogbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvcmVwbGljYXRlLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gUmVwbGljYXRlU3RyZWFtKHJlcywgY2IsIG9wdGlvbnMpIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHVybCA9IChfYTExID0gcmVzLnVybHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLnN0cmVhbTtcbiAgaWYgKCF1cmwpIHtcbiAgICBpZiAocmVzLmVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5lcnJvcik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzdHJlYW0gVVJMIGluIFJlcGxpY2F0ZSByZXNwb25zZVwiKTtcbiAgfVxuICBjb25zdCBldmVudFN0cmVhbSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBBSVN0cmVhbShldmVudFN0cmVhbSwgdm9pZCAwLCBjYikucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHN0cmVhbVRvUmVzcG9uc2UocmVzLCByZXNwb25zZSwgaW5pdCwgZGF0YSkge1xuICB2YXIgX2ExMTtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLCB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gIH0pO1xuICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICBpZiAoZGF0YSkge1xuICAgIHByb2Nlc3NlZFN0cmVhbSA9IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgcmVzKTtcbiAgfVxuICBjb25zdCByZWFkZXIgPSBwcm9jZXNzZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICByZWFkKCk7XG4gICAgfSk7XG4gIH1cbiAgcmVhZCgpO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbWluZy10ZXh0LXJlc3BvbnNlLnRzXG52YXIgU3RyZWFtaW5nVGV4dFJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBSZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yKHJlcywgaW5pdCwgZGF0YSkge1xuICAgIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHByb2Nlc3NlZFN0cmVhbSA9IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgcmVzKTtcbiAgICB9XG4gICAgc3VwZXIocHJvY2Vzc2VkU3RyZWFtLCB7XG4gICAgICAuLi5pbml0LFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzdHJlYW1zL2luZGV4LnRzXG52YXIgZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkSW1wbDtcbnZhciBuYW5vaWQgPSBnZW5lcmF0ZUlkSW1wbDtcbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IxMCBhcyBBSVNES0Vycm9yLFxuICBBSVN0cmVhbSxcbiAgQVBJQ2FsbEVycm9yMiBhcyBBUElDYWxsRXJyb3IsXG4gIEFXU0JlZHJvY2tBbnRocm9waWNNZXNzYWdlc1N0cmVhbSxcbiAgQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbSxcbiAgQVdTQmVkcm9ja0NvaGVyZVN0cmVhbSxcbiAgQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSxcbiAgQVdTQmVkcm9ja1N0cmVhbSxcbiAgQW50aHJvcGljU3RyZWFtLFxuICBBc3Npc3RhbnRSZXNwb25zZSxcbiAgQ29oZXJlU3RyZWFtLFxuICBEb3dubG9hZEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0sXG4gIEh1Z2dpbmdGYWNlU3RyZWFtLFxuICBJbmtlZXBTdHJlYW0sXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcjIgYXMgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzIGFzIExhbmdDaGFpbkFkYXB0ZXIsXG4gIExhbmdDaGFpblN0cmVhbSxcbiAgbGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMgYXMgTGxhbWFJbmRleEFkYXB0ZXIsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTWVzc2FnZUNvbnZlcnNpb25FcnJvcixcbiAgTWlzdHJhbFN0cmVhbSxcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIE5vU3VjaFByb3ZpZGVyRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvcixcbiAgT3BlbkFJU3RyZWFtLFxuICBSZXBsaWNhdGVTdHJlYW0sXG4gIFJldHJ5RXJyb3IsXG4gIFN0cmVhbURhdGEyIGFzIFN0cmVhbURhdGEsXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcjIgYXMgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBjb252ZXJ0VG9Db3JlTWVzc2FnZXMsXG4gIGNvc2luZVNpbWlsYXJpdHksXG4gIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyLFxuICBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyLFxuICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIsXG4gIGVtYmVkLFxuICBlbWJlZE1hbnksXG4gIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEsXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVRleHQsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0LFxuICBleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQyIGFzIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGpzb25TY2hlbWEsXG4gIG5hbm9pZCxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2UsXG4gIHJlYWREYXRhU3RyZWFtLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHN0cmVhbVRvUmVzcG9uc2UsXG4gIHRvb2wsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZTExIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZvcm1hdFN0cmVhbVBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJyZWFkRGF0YVN0cmVhbSIsInByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSIsImdlbmVyYXRlSWQiLCJnZW5lcmF0ZUlkSW1wbCIsImpzb25TY2hlbWEiLCJBUElDYWxsRXJyb3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJpc0Fib3J0RXJyb3IiLCJkZWxheSIsImRlbGF5SW5NcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkFJU0RLRXJyb3IiLCJuYW1lIiwibWFya2VyIiwic3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiX2EiLCJSZXRyeUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwicmVhc29uIiwiZXJyb3JzIiwibGFzdEVycm9yIiwibGVuZ3RoIiwiaXNJbnN0YW5jZSIsImVycm9yIiwiaGFzTWFya2VyIiwiaXNSZXRyeUVycm9yIiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJ0b0pTT04iLCJyZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJtYXhSZXRyaWVzIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9yTWVzc2FnZSIsIm5ld0Vycm9ycyIsInRyeU51bWJlciIsImlzQVBJQ2FsbEVycm9yIiwiaXNSZXRyeWFibGUiLCJhc3NlbWJsZU9wZXJhdGlvbk5hbWUiLCJvcGVyYXRpb25JZCIsInRlbGVtZXRyeSIsImZ1bmN0aW9uSWQiLCJnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyIsIm1vZGVsIiwic2V0dGluZ3MiLCJoZWFkZXJzIiwiX2ExMSIsInByb3ZpZGVyIiwibW9kZWxJZCIsImVudHJpZXMiLCJyZWR1Y2UiLCJhdHRyaWJ1dGVzIiwia2V5IiwidmFsdWUiLCJtZXRhZGF0YSIsInRyYWNlIiwibm9vcFRyYWNlciIsInN0YXJ0U3BhbiIsIm5vb3BTcGFuIiwic3RhcnRBY3RpdmVTcGFuIiwiYXJnMSIsImFyZzIiLCJhcmczIiwic3BhbkNvbnRleHQiLCJub29wU3BhbkNvbnRleHQiLCJzZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVzIiwiYWRkRXZlbnQiLCJhZGRMaW5rIiwiYWRkTGlua3MiLCJzZXRTdGF0dXMiLCJ1cGRhdGVOYW1lIiwiZW5kIiwiaXNSZWNvcmRpbmciLCJyZWNvcmRFeGNlcHRpb24iLCJ0cmFjZUlkIiwic3BhbklkIiwidHJhY2VGbGFncyIsImdldFRyYWNlciIsImlzRW5hYmxlZCIsInRyYWNlciIsIlNwYW5TdGF0dXNDb2RlIiwicmVjb3JkU3BhbiIsImZuIiwiZW5kV2hlbkRvbmUiLCJzcGFuIiwicmVzdWx0Iiwic3RhY2siLCJjb2RlIiwiRVJST1IiLCJzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzIiwiYXR0cmlidXRlczIiLCJpbnB1dCIsInJlY29yZElucHV0cyIsIm91dHB1dCIsInJlY29yZE91dHB1dHMiLCJlbWJlZCIsImFib3J0U2lnbmFsIiwiZXhwZXJpbWVudGFsX3RlbGVtZXRyeSIsImJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInJldHJ5IiwiZW1iZWRkaW5nIiwidXNhZ2UiLCJyYXdSZXNwb25zZSIsImRvRW1iZWRTcGFuIiwibW9kZWxSZXNwb25zZSIsImRvRW1iZWQiLCJ2YWx1ZXMiLCJlbWJlZGRpbmcyIiwiZW1iZWRkaW5ncyIsInVzYWdlMiIsInRva2VucyIsIk5hTiIsIm1hcCIsImVtYmVkZGluZzMiLCJEZWZhdWx0RW1iZWRSZXN1bHQiLCJvcHRpb25zIiwic3BsaXRBcnJheSIsImFycmF5IiwiY2h1bmtTaXplIiwiaSIsInB1c2giLCJzbGljZSIsImVtYmVkTWFueSIsIm1heEVtYmVkZGluZ3NQZXJDYWxsIiwiZW1iZWRkaW5nczIiLCJlbWJlZGRpbmdzMyIsIkRlZmF1bHRFbWJlZE1hbnlSZXN1bHQiLCJ2YWx1ZUNodW5rcyIsImNodW5rIiwicmVzcG9uc2VFbWJlZGRpbmdzIiwiY3JlYXRlSWRHZW5lcmF0b3IiLCJzYWZlUGFyc2VKU09OIiwiQUlTREtFcnJvcjIiLCJuYW1lMiIsIm1hcmtlcjIiLCJzeW1ib2wyIiwiX2EyIiwiRG93bmxvYWRFcnJvciIsInVybCIsInN0YXR1c0NvZGUiLCJzdGF0dXNUZXh0IiwiY2F1c2UiLCJpc0Rvd25sb2FkRXJyb3IiLCJkb3dubG9hZCIsImZldGNoSW1wbGVtZW50YXRpb24iLCJmZXRjaCIsInVybFRleHQiLCJ0b1N0cmluZyIsInJlc3BvbnNlIiwib2siLCJzdGF0dXMiLCJkYXRhIiwiVWludDhBcnJheSIsImFycmF5QnVmZmVyIiwibWltZVR5cGUiLCJtaW1lVHlwZVNpZ25hdHVyZXMiLCJieXRlcyIsImRldGVjdEltYWdlTWltZVR5cGUiLCJpbWFnZSIsImV2ZXJ5IiwiYnl0ZSIsImluZGV4IiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJBSVNES0Vycm9yMyIsIm5hbWUzIiwibWFya2VyMyIsInN5bWJvbDMiLCJfYTMiLCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciIsImNvbnRlbnQiLCJpc0ludmFsaWREYXRhQ29udGVudEVycm9yIiwieiIsImRhdGFDb250ZW50U2NoZW1hIiwidW5pb24iLCJzdHJpbmciLCJpbnN0YW5jZW9mIiwiQXJyYXlCdWZmZXIiLCJjdXN0b20iLCJfYiIsImdsb2JhbFRoaXMiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nIiwiY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5IiwiY29udmVydFVpbnQ4QXJyYXlUb1RleHQiLCJ1aW50OEFycmF5IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJBSVNES0Vycm9yNCIsIm5hbWU0IiwibWFya2VyNCIsInN5bWJvbDQiLCJfYTQiLCJJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciIsInJvbGUiLCJpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwic3BsaXREYXRhVXJsIiwiZGF0YVVybCIsImhlYWRlciIsImJhc2U2NENvbnRlbnQiLCJzcGxpdCIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQiLCJwcm9tcHQiLCJtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzIiwibW9kZWxTdXBwb3J0c1VybCIsImRvd25sb2FkSW1wbGVtZW50YXRpb24iLCJkb3dubG9hZGVkQXNzZXRzIiwiZG93bmxvYWRBc3NldHMiLCJtZXNzYWdlcyIsInN5c3RlbSIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlIiwicHJvdmlkZXJNZXRhZGF0YSIsImV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhIiwidHlwZSIsInRleHQiLCJwYXJ0IiwiY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0IiwiZmlsdGVyIiwicmVzdCIsInRvb2xDYWxsSWQiLCJ0b29sTmFtZSIsImV4cGVyaW1lbnRhbF9jb250ZW50IiwiaXNFcnJvciIsIl9leGhhdXN0aXZlQ2hlY2siLCJ1cmxzIiwiZmxhdCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJkb3dubG9hZGVkSW1hZ2VzIiwiZnJvbUVudHJpZXMiLCJub3JtYWxpemVkRGF0YSIsInByb3RvY29sIiwiZGF0YVVybE1pbWVUeXBlIiwiZG93bmxvYWRlZEZpbGUiLCJBSVNES0Vycm9yNSIsIm5hbWU1IiwibWFya2VyNSIsInN5bWJvbDUiLCJfYTUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInBhcmFtZXRlciIsImlzSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJwcmVwYXJlQ2FsbFNldHRpbmdzIiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJ0b3BQIiwidG9wSyIsInByZXNlbmNlUGVuYWx0eSIsImZyZXF1ZW5jeVBlbmFsdHkiLCJzdG9wU2VxdWVuY2VzIiwic2VlZCIsIk51bWJlciIsImlzSW50ZWdlciIsIkludmFsaWRQcm9tcHRFcnJvciIsInNhZmVWYWxpZGF0ZVR5cGVzIiwiejciLCJ6NiIsInozIiwiejIiLCJqc29uVmFsdWVTY2hlbWEiLCJsYXp5IiwibnVsbCIsIm51bWJlciIsImJvb2xlYW4iLCJyZWNvcmQiLCJwcm92aWRlck1ldGFkYXRhU2NoZW1hIiwiejUiLCJ6NCIsInRvb2xSZXN1bHRDb250ZW50U2NoZW1hIiwib2JqZWN0IiwibGl0ZXJhbCIsIm9wdGlvbmFsIiwidGV4dFBhcnRTY2hlbWEiLCJpbWFnZVBhcnRTY2hlbWEiLCJmaWxlUGFydFNjaGVtYSIsInRvb2xDYWxsUGFydFNjaGVtYSIsImFyZ3MiLCJ1bmtub3duIiwidG9vbFJlc3VsdFBhcnRTY2hlbWEiLCJjb3JlU3lzdGVtTWVzc2FnZVNjaGVtYSIsImNvcmVVc2VyTWVzc2FnZVNjaGVtYSIsImNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hIiwiY29yZVRvb2xNZXNzYWdlU2NoZW1hIiwiY29yZU1lc3NhZ2VTY2hlbWEiLCJkZXRlY3RQcm9tcHRUeXBlIiwiY2hhcmFjdGVyaXN0aWNzIiwiZGV0ZWN0U2luZ2xlTWVzc2FnZUNoYXJhY3RlcmlzdGljcyIsInNvbWUiLCJjIiwiaW5jbHVkZXMiLCJhdHRhY2htZW50c1RvUGFydHMiLCJhdHRhY2htZW50cyIsIl9jIiwicGFydHMiLCJhdHRhY2htZW50IiwiY29udGVudFR5cGUiLCJBSVNES0Vycm9yNiIsIm5hbWU2IiwibWFya2VyNiIsInN5bWJvbDYiLCJfYTYiLCJNZXNzYWdlQ29udmVyc2lvbkVycm9yIiwib3JpZ2luYWxNZXNzYWdlIiwiY29udmVydFRvQ29yZU1lc3NhZ2VzIiwidG9vbHMiLCJjb3JlTWVzc2FnZXMiLCJ0b29sSW52b2NhdGlvbnMiLCJleHBlcmltZW50YWxfYXR0YWNobWVudHMiLCJ0b29sSW52b2NhdGlvbiIsInRvb2wyIiwiZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQiLCJzdGFuZGFyZGl6ZVByb21wdCIsInByb21wdFR5cGUiLCJ2YWxpZGF0aW9uUmVzdWx0Iiwic2NoZW1hIiwic3VjY2VzcyIsImNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSIsInByb21wdFRva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJ0b3RhbFRva2VucyIsInByZXBhcmVSZXNwb25zZUhlYWRlcnMiLCJpbml0IiwiZGF0YVN0cmVhbVZlcnNpb24iLCJIZWFkZXJzIiwiaGFzIiwic2V0IiwiREVGQVVMVF9TQ0hFTUFfUFJFRklYIiwiREVGQVVMVF9TQ0hFTUFfU1VGRklYIiwiREVGQVVMVF9HRU5FUklDX1NVRkZJWCIsImluamVjdEpzb25JbnN0cnVjdGlvbiIsInNjaGVtYVByZWZpeCIsInNjaGVtYVN1ZmZpeCIsImxpbmUiLCJqb2luIiwiQUlTREtFcnJvcjciLCJuYW1lNyIsIm1hcmtlcjciLCJzeW1ib2w3IiwiX2E3IiwiTm9PYmplY3RHZW5lcmF0ZWRFcnJvciIsImlzTm9PYmplY3RHZW5lcmF0ZWRFcnJvciIsImlzSlNPTkFycmF5IiwiaXNKU09OT2JqZWN0IiwiVHlwZVZhbGlkYXRpb25FcnJvciIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIiwic2FmZVZhbGlkYXRlVHlwZXMyIiwiYXNTY2hlbWEiLCJjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtIiwic291cmNlIiwidHJhbnNmb3JtZXIiLCJ0cmFuc2Zvcm1lZFN0cmVhbSIsInBpcGVUaHJvdWdoIiwiVHJhbnNmb3JtU3RyZWFtIiwiYXN5bmNJdGVyYXRvciIsInJlYWRlciIsImdldFJlYWRlciIsIm5leHQiLCJkb25lIiwicmVhZCIsIm5vU2NoZW1hT3V0cHV0U3RyYXRlZ3kiLCJ2YWxpZGF0ZVBhcnRpYWxSZXN1bHQiLCJ0ZXh0RGVsdGEiLCJwYXJ0aWFsIiwidmFsaWRhdGVGaW5hbFJlc3VsdCIsImNyZWF0ZUVsZW1lbnRTdHJlYW0iLCJmdW5jdGlvbmFsaXR5Iiwib2JqZWN0T3V0cHV0U3RyYXRlZ3kiLCJhcnJheU91dHB1dFN0cmF0ZWd5IiwiJHNjaGVtYSIsIml0ZW1TY2hlbWEiLCJwcm9wZXJ0aWVzIiwiZWxlbWVudHMiLCJpdGVtcyIsInJlcXVpcmVkIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJsYXRlc3RPYmplY3QiLCJpc0ZpcnN0RGVsdGEiLCJpc0ZpbmFsRGVsdGEiLCJpbnB1dEFycmF5IiwicmVzdWx0QXJyYXkiLCJlbGVtZW50IiwicHVibGlzaGVkRWxlbWVudENvdW50Iiwib3JpZ2luYWxTdHJlYW0iLCJwdWJsaXNoZWRFbGVtZW50cyIsInRyYW5zZm9ybSIsImNvbnRyb2xsZXIiLCJlbnF1ZXVlIiwiZW51bU91dHB1dFN0cmF0ZWd5IiwiZW51bVZhbHVlcyIsImVudW0iLCJnZXRPdXRwdXRTdHJhdGVneSIsInZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0IiwibW9kZSIsInNjaGVtYU5hbWUiLCJzY2hlbWFEZXNjcmlwdGlvbiIsIm9yaWdpbmFsR2VuZXJhdGVJZCIsInByZWZpeCIsInNpemUiLCJnZW5lcmF0ZU9iamVjdCIsImlucHV0U2NoZW1hIiwiX2ludGVybmFsIiwiZ2VuZXJhdGVJZDMiLCJjdXJyZW50RGF0ZSIsIkRhdGUiLCJvdXRwdXRTdHJhdGVneSIsImRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSIsImZpbmlzaFJlYXNvbiIsIndhcm5pbmdzIiwicmVxdWVzdCIsImxvZ3Byb2JzIiwicmVzdWx0UHJvdmlkZXJNZXRhZGF0YSIsInN0YW5kYXJkaXplZFByb21wdCIsInN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMiLCJwcm9tcHRNZXNzYWdlcyIsInN1cHBvcnRzSW1hZ2VVcmxzIiwic3VwcG9ydHNVcmwiLCJnZW5lcmF0ZVJlc3VsdCIsInNwYW4yIiwiX2ExMiIsIl9iMiIsIl9kIiwiX2UiLCJfZiIsInJlc3VsdDIiLCJkb0dlbmVyYXRlIiwiZGVzY3JpcHRpb24iLCJpbnB1dEZvcm1hdCIsInJlc3BvbnNlRGF0YSIsImlkIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJvYmplY3RUZXh0IiwiX2ciLCJfaCIsInRvb2wiLCJwYXJhbWV0ZXJzIiwidG9vbENhbGxzIiwicGFyc2VSZXN1bHQiLCJEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQiLCJ0b0pzb25SZXNwb25zZSIsIlJlc3BvbnNlIiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0IiwiY3JlYXRlSWRHZW5lcmF0b3IyIiwiaXNEZWVwRXF1YWxEYXRhIiwicGFyc2VQYXJ0aWFsSnNvbiIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcyIsInJlaiIsIkRlbGF5ZWRQcm9taXNlIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiY2FsbCIsIm5vdyIsInBlcmZvcm1hbmNlIiwicHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJ3cml0ZVRvU2VydmVyUmVzcG9uc2UiLCJzdHJlYW0iLCJ3cml0ZUhlYWQiLCJ3cml0ZSIsIm9yaWdpbmFsR2VuZXJhdGVJZDIiLCJzdHJlYW1PYmplY3QiLCJvbkZpbmlzaCIsIm5vdzIiLCJyb290U3BhbiIsImNhbGxPcHRpb25zIiwiYXJnc1RleHREZWx0YSIsImRvU3RyZWFtU3BhbiIsInN0YXJ0VGltZXN0YW1wTXMiLCJkb1N0cmVhbVNwYW4yIiwiZG9TdHJlYW0iLCJEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0Iiwib2JqZWN0UHJvbWlzZSIsInJlc29sdmVVc2FnZSIsInVzYWdlUHJvbWlzZSIsInJlc29sdmVSZXNwb25zZSIsInJlc3BvbnNlUHJvbWlzZSIsInJlc29sdmVQcm92aWRlck1ldGFkYXRhIiwicHJvdmlkZXJNZXRhZGF0YVByb21pc2UiLCJhY2N1bXVsYXRlZFRleHQiLCJsYXRlc3RPYmplY3RKc29uIiwiaXNGaXJzdENodW5rIiwic2VsZiIsIm1zVG9GaXJzdENodW5rIiwiY3VycmVudE9iamVjdEpzb24iLCJzdGF0ZSIsInBhcnNlU3RhdGUiLCJmbHVzaCIsImZpbmFsVXNhZ2UiLCJlcnJvcjIiLCJwYXJ0aWFsT2JqZWN0U3RyZWFtIiwiZWxlbWVudFN0cmVhbSIsInRleHRTdHJlYW0iLCJmdWxsU3RyZWFtIiwicGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlIiwiVGV4dEVuY29kZXJTdHJlYW0iLCJ0b1RleHRTdHJlYW1SZXNwb25zZSIsImV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QiLCJjcmVhdGVJZEdlbmVyYXRvcjMiLCJBSVNES0Vycm9yMTAiLCJBUElDYWxsRXJyb3IyIiwiRW1wdHlSZXNwb25zZUJvZHlFcnJvciIsIkludmFsaWRQcm9tcHRFcnJvcjIiLCJJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IiLCJKU09OUGFyc2VFcnJvciIsIkxvYWRBUElLZXlFcnJvciIsIk5vQ29udGVudEdlbmVyYXRlZEVycm9yIiwiTm9TdWNoTW9kZWxFcnJvciIsIlR5cGVWYWxpZGF0aW9uRXJyb3IyIiwiVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIiwiQUlTREtFcnJvcjgiLCJnZXRFcnJvck1lc3NhZ2UyIiwibmFtZTgiLCJtYXJrZXI4Iiwic3ltYm9sOCIsIl9hOCIsIkludmFsaWRUb29sQXJndW1lbnRzRXJyb3IiLCJ0b29sQXJncyIsImlzSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsIkFJU0RLRXJyb3I5IiwibmFtZTkiLCJtYXJrZXI5Iiwic3ltYm9sOSIsIl9hOSIsIk5vU3VjaFRvb2xFcnJvciIsImF2YWlsYWJsZVRvb2xzIiwiaXNOb1N1Y2hUb29sRXJyb3IiLCJhc1NjaGVtYTIiLCJpc05vbkVtcHR5T2JqZWN0Iiwia2V5cyIsInByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UiLCJ0b29sQ2hvaWNlIiwiYWN0aXZlVG9vbHMiLCJmaWx0ZXJlZFRvb2xzIiwidG9vbFR5cGUiLCJleGhhdXN0aXZlQ2hlY2siLCJsYXN0V2hpdGVzcGFjZVJlZ2V4cCIsInNwbGl0T25MYXN0V2hpdGVzcGFjZSIsIm1hdGNoIiwid2hpdGVzcGFjZSIsInN1ZmZpeCIsInJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlIiwic2FmZVBhcnNlSlNPTjIiLCJzYWZlVmFsaWRhdGVUeXBlczMiLCJhc1NjaGVtYTMiLCJwYXJzZVRvb2xDYWxsIiwidG9vbENhbGwiLCJ0cmltIiwidG9SZXNwb25zZU1lc3NhZ2VzIiwidG9vbFJlc3VsdHMiLCJyZXNwb25zZU1lc3NhZ2VzIiwidG9vbFJlc3VsdCIsIm9yaWdpbmFsR2VuZXJhdGVJZDMiLCJnZW5lcmF0ZVRleHQiLCJtYXhBdXRvbWF0aWNSb3VuZHRyaXBzIiwibWF4VG9vbFJvdW5kdHJpcHMiLCJtYXhTdGVwcyIsImV4cGVyaW1lbnRhbF9jb250aW51YXRpb25TdGVwcyIsImV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzIiwiY29udGludWVTdGVwcyIsImV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyIsIm9uU3RlcEZpbmlzaCIsImluaXRpYWxQcm9tcHQiLCJjYWxsU2V0dGluZ3MiLCJjdXJyZW50TW9kZWxSZXNwb25zZSIsImN1cnJlbnRUb29sQ2FsbHMiLCJjdXJyZW50VG9vbFJlc3VsdHMiLCJzdGVwQ291bnQiLCJzdGVwcyIsInN0ZXBUeXBlIiwicHJvbXB0Rm9ybWF0IiwiX2MyIiwiX2QyIiwiX2UyIiwiX2YyIiwibW9kZWxUb29sQ2FsbCIsImV4ZWN1dGVUb29scyIsImN1cnJlbnRVc2FnZSIsIm5leHRTdGVwVHlwZSIsIm9yaWdpbmFsVGV4dCIsInN0ZXBUZXh0TGVhZGluZ1doaXRlc3BhY2VUcmltbWVkIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInN0ZXBUZXh0IiwibGFzdE1lc3NhZ2UiLCJjdXJyZW50U3RlcFJlc3VsdCIsInBhcnNlIiwiaXNDb250aW51ZWQiLCJEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0IiwiZXhlY3V0ZSIsImlnbm9yZWQiLCJyb3VuZHRyaXBzIiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCIsImNyZWF0ZUlkR2VuZXJhdG9yNCIsImNyZWF0ZVN0aXRjaGFibGVTdHJlYW0iLCJpbm5lclN0cmVhbVJlYWRlcnMiLCJpc0Nsb3NlZCIsInByb2Nlc3NQdWxsIiwiY2xvc2UiLCJzaGlmdCIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyUGFyYW0iLCJwdWxsIiwiY2FuY2VsIiwiYWRkU3RyZWFtIiwiaW5uZXJTdHJlYW0iLCJtZXJnZVN0cmVhbXMiLCJzdHJlYW0xIiwic3RyZWFtMiIsInJlYWRlcjEiLCJyZWFkZXIyIiwibGFzdFJlYWQxIiwibGFzdFJlYWQyIiwic3RyZWFtMURvbmUiLCJzdHJlYW0yRG9uZSIsInJlYWRTdHJlYW0xIiwicmVhZFN0cmVhbTIiLCJyYWNlIiwidGhlbiIsInJ1blRvb2xzVHJhbnNmb3JtYXRpb24iLCJnZW5lcmF0b3JTdHJlYW0iLCJ0b29sQ2FsbFN0cmVhbWluZyIsInRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciIsInRvb2xSZXN1bHRzU3RyZWFtIiwiYWN0aXZlVG9vbENhbGxzIiwib3V0c3RhbmRpbmdUb29sUmVzdWx0cyIsIlNldCIsImNhbkNsb3NlIiwiZmluaXNoQ2h1bmsiLCJhdHRlbXB0Q2xvc2UiLCJmb3J3YXJkU3RyZWFtIiwiY2h1bmtUeXBlIiwidG9vbEV4ZWN1dGlvbklkIiwiYWRkIiwiZGVsZXRlIiwicGlwZVRvIiwiV3JpdGFibGVTdHJlYW0iLCJvcmlnaW5hbEdlbmVyYXRlSWQ0Iiwic3RyZWFtVGV4dCIsImV4cGVyaW1lbnRhbF90b29sQ2FsbFN0cmVhbWluZyIsIm9uQ2h1bmsiLCJzdGFydFN0ZXAiLCJ3YXJuaW5nczIiLCJyYXdSZXNwb25zZTIiLCJyZXF1ZXN0MiIsInN0YXJ0VGltZXN0YW1wTXMyIiwiZG9TdHJlYW1TcGFuMyIsIkRlZmF1bHRTdHJlYW1UZXh0UmVzdWx0IiwicmVzb2x2ZUZpbmlzaFJlYXNvbiIsImZpbmlzaFJlYXNvblByb21pc2UiLCJyZXNvbHZlVGV4dCIsInRleHRQcm9taXNlIiwicmVzb2x2ZVRvb2xDYWxscyIsInRvb2xDYWxsc1Byb21pc2UiLCJyZXNvbHZlVG9vbFJlc3VsdHMiLCJ0b29sUmVzdWx0c1Byb21pc2UiLCJyZXNvbHZlU3RlcHMiLCJzdGVwc1Byb21pc2UiLCJyZXNvbHZlUmVxdWVzdCIsInJlcXVlc3RQcm9taXNlIiwicmVzb2x2ZVJlc3BvbnNlTWVzc2FnZXMiLCJyZXNwb25zZU1lc3NhZ2VzUHJvbWlzZSIsInN0aXRjaGFibGVTdHJlYW0iLCJjbG9zZVN0aXRjaGFibGVTdHJlYW0iLCJzdGVwUmVzdWx0cyIsImFkZFN0ZXBTdHJlYW0iLCJzdGFydFRpbWVzdGFtcCIsImN1cnJlbnRTdGVwIiwicHJldmlvdXNTdGVwVGV4dCIsInN0ZXBSZXF1ZXN0IiwiaGFzTGVhZGluZ1doaXRlc3BhY2UiLCJzdGVwVG9vbENhbGxzIiwic3RlcFRvb2xSZXN1bHRzIiwic3RlcEZpbmlzaFJlYXNvbiIsInN0ZXBVc2FnZSIsInN0ZXBQcm92aWRlck1ldGFkYXRhIiwic3RlcEZpcnN0Q2h1bmsiLCJmdWxsU3RlcFRleHQiLCJzdGVwTG9nUHJvYnMiLCJzdGVwUmVzcG9uc2UiLCJjaHVua0J1ZmZlciIsImNodW5rVGV4dFB1Ymxpc2hlZCIsImluV2hpdGVzcGFjZVByZWZpeCIsImhhc1doaXRlc3BhY2VTdWZmaXgiLCJwdWJsaXNoVGV4dENodW5rIiwidHJpbW1lZENodW5rVGV4dCIsIm1zVG9GaW5pc2giLCJzdGVwVG9vbENhbGxzSnNvbiIsImNvbWJpbmVkVXNhZ2UiLCJzdGFydFRpbWVzdGFtcDIiLCJ0ZWVTdHJlYW0iLCJ0ZWUiLCJ0b0FJU3RyZWFtIiwiY2FsbGJhY2tzIiwidG9EYXRhU3RyZWFtSW50ZXJuYWwiLCJnZXRFcnJvck1lc3NhZ2UzIiwic2VuZFVzYWdlIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tUcmFuc2Zvcm1lciIsIm9uU3RhcnQiLCJvblRva2VuIiwib25UZXh0Iiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInN0cmVhbVBhcnRzVHJhbnNmb3JtZXIiLCJwaXBlQUlTdHJlYW1Ub1Jlc3BvbnNlIiwicGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlIiwidG9EYXRhU3RyZWFtIiwidG9BSVN0cmVhbVJlc3BvbnNlIiwidG9EYXRhU3RyZWFtUmVzcG9uc2UiLCJleHBlcmltZW50YWxfc3RyZWFtVGV4dCIsImV4cGVyaW1lbnRhbF93cmFwTGFuZ3VhZ2VNb2RlbCIsIm1pZGRsZXdhcmUiLCJ0cmFuc2Zvcm1QYXJhbXMiLCJ3cmFwR2VuZXJhdGUiLCJ3cmFwU3RyZWFtIiwicHJvdmlkZXJJZCIsImRvVHJhbnNmb3JtIiwicGFyYW1zIiwic3BlY2lmaWNhdGlvblZlcnNpb24iLCJ0cmFuc2Zvcm1lZFBhcmFtcyIsIk5vU3VjaE1vZGVsRXJyb3IyIiwiZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbHMiLCJ0ZXh0RW1iZWRkaW5nTW9kZWxzIiwiZmFsbGJhY2tQcm92aWRlciIsImxhbmd1YWdlTW9kZWwiLCJtb2RlbFR5cGUiLCJ0ZXh0RW1iZWRkaW5nTW9kZWwiLCJBSVNES0Vycm9yMTEiLCJOb1N1Y2hNb2RlbEVycm9yMyIsIm5hbWUxMCIsIm1hcmtlcjEwIiwic3ltYm9sMTAiLCJfYTEwIiwiTm9TdWNoUHJvdmlkZXJFcnJvciIsImF2YWlsYWJsZVByb3ZpZGVycyIsImVycm9yTmFtZSIsImlzTm9TdWNoUHJvdmlkZXJFcnJvciIsIk5vU3VjaE1vZGVsRXJyb3I0IiwiZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkiLCJwcm92aWRlcnMiLCJyZWdpc3RyeSIsIkRlZmF1bHRQcm92aWRlclJlZ2lzdHJ5IiwicmVnaXN0ZXJQcm92aWRlciIsImV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5IiwiZ2V0UHJvdmlkZXIiLCJzcGxpdElkIiwiaW5kZXhPZiIsInRleHRFbWJlZGRpbmciLCJjb3NpbmVTaW1pbGFyaXR5IiwidmVjdG9yMSIsInZlY3RvcjIiLCJkb3RQcm9kdWN0IiwibWFnbml0dWRlIiwiYWNjdW11bGF0b3IiLCJ2ZWN0b3IiLCJNYXRoIiwic3FydCIsImNyZWF0ZVBhcnNlciIsImNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIiLCJjdXN0b21QYXJzZXIiLCJ0ZXh0RGVjb2RlciIsImV2ZW50U291cmNlUGFyc2VyIiwiZXZlbnQiLCJ0ZXJtaW5hdGUiLCJwYXJzZWRNZXNzYWdlIiwiZmVlZCIsImNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyIiwiY2IiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiaXNPcGVuQUlDYWxsYmFja3MiLCJpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsIkFJU3RyZWFtIiwiYm9keSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJyZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlIiwiaXRlcmFibGUiLCJpdCIsInJldHVybiIsImZvcm1hdFN0cmVhbVBhcnQyIiwiSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TIiwiU3RyZWFtRGF0YTIiLCJlbmNvZGVyIiwid2FybmluZ1RpbWVvdXQiLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJjbGVhclRpbWVvdXQiLCJhcHBlbmQiLCJhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbiIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImRlY29kZXIiLCJleHBlcmltZW50YWxfU3RyZWFtRGF0YSIsInBhcnNlQW50aHJvcGljU3RyZWFtIiwicHJldmlvdXMiLCJqc29uIiwiY29tcGxldGlvbiIsImRlbHRhIiwic3RyZWFtYWJsZSIsIkFudGhyb3BpY1N0cmVhbSIsImZvcm1hdFN0cmVhbVBhcnQzIiwiQXNzaXN0YW50UmVzcG9uc2UiLCJ0aHJlYWRJZCIsIm1lc3NhZ2VJZCIsInByb2Nlc3MyIiwic2VuZE1lc3NhZ2UiLCJzZW5kRGF0YU1lc3NhZ2UiLCJzZW5kRXJyb3IiLCJleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UiLCJhc0RlbHRhSXRlcmFibGUiLCJleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rIiwiY2h1bmtUZXh0IiwiY2h1bmtKU09OIiwiQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtIiwiQVdTQmVkcm9ja1N0cmVhbSIsIkFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0iLCJBV1NCZWRyb2NrQ29oZXJlU3RyZWFtIiwiQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSIsImdlbmVyYXRpb24iLCJ1dGY4RGVjb2RlciIsInByb2Nlc3NMaW5lcyIsImxpbmVzIiwiaXNfZmluaXNoZWQiLCJyZWFkQW5kUHJvY2Vzc0xpbmVzIiwic2VnbWVudCIsImxpbmVzQXJyYXkiLCJwb3AiLCJjcmVhdGVQYXJzZXIyIiwic3RyZWFtYWJsZTIiLCJldmVudFR5cGUiLCJDb2hlcmVTdHJlYW0iLCJzdHJlYW1hYmxlMyIsImNhbmRpZGF0ZXMiLCJmaXJzdFBhcnQiLCJHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0iLCJjcmVhdGVQYXJzZXIzIiwidHJpbVN0YXJ0T2ZTdHJlYW0iLCJ0b2tlbiIsImdlbmVyYXRlZF90ZXh0IiwiSHVnZ2luZ0ZhY2VTdHJlYW0iLCJJbmtlZXBTdHJlYW0iLCJjaGF0X3Nlc3Npb25faWQiLCJyZWNvcmRzX2NpdGVkIiwiaW5rZWVwRXZlbnRQYXJzZXIiLCJvblJlY29yZHNDaXRlZCIsImlua2VlcE1lc3NhZ2VDaHVuayIsImNvbnRlbnRfY2h1bmsiLCJwYXNzVGhyb3VnaENhbGxiYWNrcyIsImlua2VlcE9uRmluYWxNZXRhZGF0YSIsImxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMiLCJmb3J3YXJkQUlNZXNzYWdlQ2h1bmsiLCJkYXRhU3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJpdGVtIiwibGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMiLCJ0b0RhdGFTdHJlYW0yIiwidG9EYXRhU3RyZWFtUmVzcG9uc2UyIiwidG9SZWFkYWJsZVN0cmVhbSIsIkxhbmdDaGFpblN0cmVhbSIsIndyaXRlciIsIndyaXRhYmxlIiwiZ2V0V3JpdGVyIiwicnVucyIsImhhbmRsZUVycm9yIiwiZSIsInJ1bklkIiwicmVhZHkiLCJhYm9ydCIsImhhbmRsZVN0YXJ0IiwiaGFuZGxlRW5kIiwicmVhZGFibGUiLCJoYW5kbGVycyIsImhhbmRsZUxMTU5ld1Rva2VuIiwiaGFuZGxlTExNU3RhcnQiLCJfbGxtIiwiX3Byb21wdHMiLCJoYW5kbGVMTE1FbmQiLCJfb3V0cHV0IiwiaGFuZGxlTExNRXJyb3IiLCJoYW5kbGVDaGFpblN0YXJ0IiwiX2NoYWluIiwiX2lucHV0cyIsImhhbmRsZUNoYWluRW5kIiwiX291dHB1dHMiLCJoYW5kbGVDaGFpbkVycm9yIiwiaGFuZGxlVG9vbFN0YXJ0IiwiX3Rvb2wiLCJfaW5wdXQiLCJoYW5kbGVUb29sRW5kIiwiaGFuZGxlVG9vbEVycm9yIiwic3RyZWFtYWJsZTQiLCJjaG9pY2VzIiwiTWlzdHJhbFN0cmVhbSIsImNyZWF0ZUNodW5rRGVjb2RlciIsImZvcm1hdFN0cmVhbVBhcnQ0IiwicGFyc2VPcGVuQUlTdHJlYW0iLCJleHRyYWN0IiwiY2h1bmtUb1RleHQiLCJzdHJlYW1hYmxlNSIsImNyZWF0ZWQiLCJnZXREYXRlIiwiY2hvaWNlIiwiZnVuY3Rpb25fY2FsbCIsImZ1bmN0aW9uQ2FsbCIsInRvb2xfY2FsbHMiLCJmdW5jdGlvbiIsImZpbmlzaF9yZWFzb24iLCJpc0Z1bmN0aW9uU3RyZWFtaW5nSW4iLCJfaSIsIl9qIiwiX2siLCJfbCIsIl9tIiwiX24iLCJfbyIsIl9wIiwiX3EiLCJfciIsImlzQ2hhdENvbXBsZXRpb25DaHVuayIsImlzVGV4dCIsImFyZ3VtZW50cyIsImNsZWFudXBBcmd1bWVudHMiLCJpc0NvbXBsZXRpb24iLCJhcmd1bWVudENodW5rIiwiZXNjYXBlZFBhcnRpYWxKc29uIiwicmVwbGFjZSIsIl9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wiLCJPcGVuQUlTdHJlYW0iLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCIsImZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UiLCJmdW5jdGlvbkNhbGxNZXNzYWdlcyIsInNob3VsZEhhbmRsZUFzRnVuY3Rpb24iLCJwYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwiYXJndW1lbnRzUGF5bG9hZCIsImZ1bmMiLCJyZXNwb25zZUluZGV4IiwidG9vbF9jYWxsX2lkIiwiZnVuY3Rpb25fbmFtZSIsInRvb2xfY2FsbF9yZXN1bHQiLCJ0YyIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiUmVwbGljYXRlU3RyZWFtIiwiZXZlbnRTdHJlYW0iLCJtZXRob2QiLCJBY2NlcHQiLCJzdHJlYW1Ub1Jlc3BvbnNlIiwicHJvY2Vzc2VkU3RyZWFtIiwiU3RyZWFtaW5nVGV4dFJlc3BvbnNlIiwiZ2VuZXJhdGVJZDIiLCJuYW5vaWQiLCJMYW5nQ2hhaW5BZGFwdGVyIiwiTGxhbWFJbmRleEFkYXB0ZXIiLCJTdHJlYW1EYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/ai@3.4.33_react@18.3.1_sswr_af653c0b93f68119aa4870059e5b1a60/node_modules/ai/dist/index.mjs\n");

/***/ })

};
;