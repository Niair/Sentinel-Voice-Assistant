"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-model@1.25.4";
exports.ids = ["vendor-chunks/prosemirror-model@1.25.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* binding */ ContentMatch),\n/* harmony export */   DOMParser: () => (/* binding */ DOMParser),\n/* harmony export */   DOMSerializer: () => (/* binding */ DOMSerializer),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkType: () => (/* binding */ MarkType),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodeRange: () => (/* binding */ NodeRange),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   ReplaceError: () => (/* binding */ ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* binding */ ResolvedPos),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Slice: () => (/* binding */ Slice)\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ \"(ssr)/./node_modules/.pnpm/orderedmap@2.1.1/node_modules/orderedmap/dist/index.js\");\n\nfunction findDiffStart(a, b, pos) {\n    for(let i = 0;; i++){\n        if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n        let childA = a.child(i), childB = b.child(i);\n        if (childA == childB) {\n            pos += childA.nodeSize;\n            continue;\n        }\n        if (!childA.sameMarkup(childB)) return pos;\n        if (childA.isText && childA.text != childB.text) {\n            for(let j = 0; childA.text[j] == childB.text[j]; j++)pos++;\n            return pos;\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffStart(childA.content, childB.content, pos + 1);\n            if (inner != null) return inner;\n        }\n        pos += childA.nodeSize;\n    }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n    for(let iA = a.childCount, iB = b.childCount;;){\n        if (iA == 0 || iB == 0) return iA == iB ? null : {\n            a: posA,\n            b: posB\n        };\n        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n        if (childA == childB) {\n            posA -= size;\n            posB -= size;\n            continue;\n        }\n        if (!childA.sameMarkup(childB)) return {\n            a: posA,\n            b: posB\n        };\n        if (childA.isText && childA.text != childB.text) {\n            let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n            while(same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]){\n                same++;\n                posA--;\n                posB--;\n            }\n            return {\n                a: posA,\n                b: posB\n            };\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n            if (inner) return inner;\n        }\n        posA -= size;\n        posB -= size;\n    }\n}\n/**\nA fragment represents a node's collection of child nodes.\n\nLike nodes, fragments are persistent data structures, and you\nshould not mutate them or their content. Rather, you create new\ninstances whenever needed. The API tries to make this easy.\n*/ class Fragment {\n    /**\n    @internal\n    */ constructor(/**\n    The child nodes in this fragment.\n    */ content, size){\n        this.content = content;\n        this.size = size || 0;\n        if (size == null) for(let i = 0; i < content.length; i++)this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn't descend\n    into a node when the callback returns `false`.\n    */ nodesBetween(from, to, f, nodeStart = 0, parent) {\n        for(let i = 0, pos = 0; pos < to; i++){\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n                let start = pos + 1;\n                child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n            }\n            pos = end;\n        }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */ descendants(f) {\n        this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */ textBetween(from, to, blockSeparator, leafText) {\n        let text = \"\", first = true;\n        this.nodesBetween(from, to, (node, pos)=>{\n            let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n            if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n                if (first) first = false;\n                else text += blockSeparator;\n            }\n            text += nodeText;\n        }, 0);\n        return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */ append(other) {\n        if (!other.size) return this;\n        if (!this.size) return other;\n        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n        if (last.isText && last.sameMarkup(first)) {\n            content[content.length - 1] = last.withText(last.text + first.text);\n            i = 1;\n        }\n        for(; i < other.content.length; i++)content.push(other.content[i]);\n        return new Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */ cut(from, to = this.size) {\n        if (from == 0 && to == this.size) return this;\n        let result = [], size = 0;\n        if (to > from) for(let i = 0, pos = 0; pos < to; i++){\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from) {\n                if (pos < from || end > to) {\n                    if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n                    else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n                }\n                result.push(child);\n                size += child.nodeSize;\n            }\n            pos = end;\n        }\n        return new Fragment(result, size);\n    }\n    /**\n    @internal\n    */ cutByIndex(from, to) {\n        if (from == to) return Fragment.empty;\n        if (from == 0 && to == this.content.length) return this;\n        return new Fragment(this.content.slice(from, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */ replaceChild(index, node) {\n        let current = this.content[index];\n        if (current == node) return this;\n        let copy = this.content.slice();\n        let size = this.size + node.nodeSize - current.nodeSize;\n        copy[index] = node;\n        return new Fragment(copy, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */ addToStart(node) {\n        return new Fragment([\n            node\n        ].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */ addToEnd(node) {\n        return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */ eq(other) {\n        if (this.content.length != other.content.length) return false;\n        for(let i = 0; i < this.content.length; i++)if (!this.content[i].eq(other.content[i])) return false;\n        return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */ get firstChild() {\n        return this.content.length ? this.content[0] : null;\n    }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */ get lastChild() {\n        return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n    /**\n    The number of child nodes in this fragment.\n    */ get childCount() {\n        return this.content.length;\n    }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */ child(index) {\n        let found = this.content[index];\n        if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n        return found;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */ maybeChild(index) {\n        return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */ forEach(f) {\n        for(let i = 0, p = 0; i < this.content.length; i++){\n            let child = this.content[i];\n            f(child, p, i);\n            p += child.nodeSize;\n        }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */ findDiffStart(other, pos = 0) {\n        return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */ findDiffEnd(other, pos = this.size, otherPos = other.size) {\n        return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. @internal\n    */ findIndex(pos) {\n        if (pos == 0) return retIndex(0, pos);\n        if (pos == this.size) return retIndex(this.content.length, pos);\n        if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n        for(let i = 0, curPos = 0;; i++){\n            let cur = this.child(i), end = curPos + cur.nodeSize;\n            if (end >= pos) {\n                if (end == pos) return retIndex(i + 1, end);\n                return retIndex(i, curPos);\n            }\n            curPos = end;\n        }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */ toString() {\n        return \"<\" + this.toStringInner() + \">\";\n    }\n    /**\n    @internal\n    */ toStringInner() {\n        return this.content.join(\", \");\n    }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */ toJSON() {\n        return this.content.length ? this.content.map((n)=>n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */ static fromJSON(schema, value) {\n        if (!value) return Fragment.empty;\n        if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n        return new Fragment(value.map(schema.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */ static fromArray(array) {\n        if (!array.length) return Fragment.empty;\n        let joined, size = 0;\n        for(let i = 0; i < array.length; i++){\n            let node = array[i];\n            size += node.nodeSize;\n            if (i && node.isText && array[i - 1].sameMarkup(node)) {\n                if (!joined) joined = array.slice(0, i);\n                joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n            } else if (joined) {\n                joined.push(node);\n            }\n        }\n        return new Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */ static from(nodes) {\n        if (!nodes) return Fragment.empty;\n        if (nodes instanceof Fragment) return nodes;\n        if (Array.isArray(nodes)) return this.fromArray(nodes);\n        if (nodes.attrs) return new Fragment([\n            nodes\n        ], nodes.nodeSize);\n        throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n}\n/**\nAn empty fragment. Intended to be reused whenever a node doesn't\ncontain anything (rather than allocating a new empty fragment for\neach leaf node).\n*/ Fragment.empty = new Fragment([], 0);\nconst found = {\n    index: 0,\n    offset: 0\n};\nfunction retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n}\nfunction compareDeep(a, b) {\n    if (a === b) return true;\n    if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\")) return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array) return false;\n    if (array) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++)if (!compareDeep(a[i], b[i])) return false;\n    } else {\n        for(let p in a)if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n        for(let p in b)if (!(p in a)) return false;\n    }\n    return true;\n}\n/**\nA mark is a piece of information that can be attached to a node,\nsuch as it being emphasized, in code font, or a link. It has a\ntype and optionally a set of attributes that provide further\ninformation (such as the target of the link). Marks are created\nthrough a `Schema`, which controls which types exist and which\nattributes they have.\n*/ class Mark {\n    /**\n    @internal\n    */ constructor(/**\n    The type of this mark.\n    */ type, /**\n    The attributes associated with this mark.\n    */ attrs){\n        this.type = type;\n        this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */ addToSet(set) {\n        let copy, placed = false;\n        for(let i = 0; i < set.length; i++){\n            let other = set[i];\n            if (this.eq(other)) return set;\n            if (this.type.excludes(other.type)) {\n                if (!copy) copy = set.slice(0, i);\n            } else if (other.type.excludes(this.type)) {\n                return set;\n            } else {\n                if (!placed && other.type.rank > this.type.rank) {\n                    if (!copy) copy = set.slice(0, i);\n                    copy.push(this);\n                    placed = true;\n                }\n                if (copy) copy.push(other);\n            }\n        }\n        if (!copy) copy = set.slice();\n        if (!placed) copy.push(this);\n        return copy;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */ removeFromSet(set) {\n        for(let i = 0; i < set.length; i++)if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n        return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */ isInSet(set) {\n        for(let i = 0; i < set.length; i++)if (this.eq(set[i])) return true;\n        return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */ eq(other) {\n        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */ toJSON() {\n        let obj = {\n            type: this.type.name\n        };\n        for(let _ in this.attrs){\n            obj.attrs = this.attrs;\n            break;\n        }\n        return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */ static fromJSON(schema, json) {\n        if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\");\n        let type = schema.marks[json.type];\n        if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`);\n        let mark = type.create(json.attrs);\n        type.checkAttrs(mark.attrs);\n        return mark;\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */ static sameSet(a, b) {\n        if (a == b) return true;\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++)if (!a[i].eq(b[i])) return false;\n        return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */ static setFrom(marks) {\n        if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;\n        if (marks instanceof Mark) return [\n            marks\n        ];\n        let copy = marks.slice();\n        copy.sort((a, b)=>a.type.rank - b.type.rank);\n        return copy;\n    }\n}\n/**\nThe empty set of marks.\n*/ Mark.none = [];\n/**\nError type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when\ngiven an invalid replacement.\n*/ class ReplaceError extends Error {\n}\n/*\nReplaceError = function(this: any, message: string) {\n  let err = Error.call(this, message)\n  ;(err as any).__proto__ = ReplaceError.prototype\n  return err\n} as any\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n*/ /**\nA slice represents a piece cut out of a larger document. It\nstores not only a fragment, but also the depth up to which nodes on\nboth side are ‘open’ (cut through).\n*/ class Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can't be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema's content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */ constructor(/**\n    The slice's content.\n    */ content, /**\n    The open depth at the start of the fragment.\n    */ openStart, /**\n    The open depth at the end.\n    */ openEnd){\n        this.content = content;\n        this.openStart = openStart;\n        this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */ get size() {\n        return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */ insertAt(pos, fragment) {\n        let content = insertInto(this.content, pos + this.openStart, fragment);\n        return content && new Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */ removeBetween(from, to) {\n        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */ eq(other) {\n        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */ toJSON() {\n        if (!this.content.size) return null;\n        let json = {\n            content: this.content.toJSON()\n        };\n        if (this.openStart > 0) json.openStart = this.openStart;\n        if (this.openEnd > 0) json.openEnd = this.openEnd;\n        return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */ static fromJSON(schema, json) {\n        if (!json) return Slice.empty;\n        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n        if (typeof openStart != \"number\" || typeof openEnd != \"number\") throw new RangeError(\"Invalid input for Slice.fromJSON\");\n        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */ static maxOpen(fragment, openIsolating = true) {\n        let openStart = 0, openEnd = 0;\n        for(let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)openStart++;\n        for(let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)openEnd++;\n        return new Slice(fragment, openStart, openEnd);\n    }\n}\n/**\nThe empty slice.\n*/ Slice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from || child.isText) {\n        if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n        return content.cut(0, from).append(content.cut(to));\n    }\n    if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n        if (parent && !parent.canReplace(index, index, insert)) return null;\n        return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert, child);\n    return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n    if (slice.openStart > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n    if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError(\"Inconsistent open depths\");\n    return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n        let inner = replaceOuter($from, $to, slice, depth + 1);\n        return node.copy(node.content.replaceChild(index, inner));\n    } else if (!slice.content.size) {\n        return close(node, replaceTwoWay($from, $to, depth));\n    } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n        let parent = $from.parent, content = parent.content;\n        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n    } else {\n        let { start, end } = prepareSliceForReplace(slice, $from);\n        return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n}\nfunction checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n}\nfunction addNode(child, target) {\n    let last = target.length - 1;\n    if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);\n    else target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n        startIndex = $start.index(depth);\n        if ($start.depth > depth) {\n            startIndex++;\n        } else if ($start.textOffset) {\n            addNode($start.nodeAfter, target);\n            startIndex++;\n        }\n    }\n    for(let i = startIndex; i < endIndex; i++)addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n        checkJoin(openStart, openEnd);\n        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    } else {\n        if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n        addRange($start, $end, depth, content);\n        if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n        let type = joinable($from, $to, depth + 1);\n        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n    let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice.content);\n    for(let i = extra - 1; i >= 0; i--)node = $along.node(i).copy(Fragment.from(node));\n    return {\n        start: node.resolveNoCache(slice.openStart + extra),\n        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n    };\n}\n/**\nYou can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more\ninformation about it. Objects of this class represent such a\nresolved position, providing various pieces of context\ninformation, and some helper methods.\n\nThroughout this interface, methods that take an optional `depth`\nparameter will interpret undefined as `this.depth` and negative\nnumbers as `this.depth + value`.\n*/ class ResolvedPos {\n    /**\n    @internal\n    */ constructor(/**\n    The position that was resolved.\n    */ pos, /**\n    @internal\n    */ path, /**\n    The offset this position has into its parent node.\n    */ parentOffset){\n        this.pos = pos;\n        this.path = path;\n        this.parentOffset = parentOffset;\n        this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */ resolveDepth(val) {\n        if (val == null) return this.depth;\n        if (val < 0) return this.depth + val;\n        return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */ get parent() {\n        return this.node(this.depth);\n    }\n    /**\n    The root node in which the position was resolved.\n    */ get doc() {\n        return this.node(0);\n    }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */ node(depth) {\n        return this.path[this.resolveDepth(depth) * 3];\n    }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */ index(depth) {\n        return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */ indexAfter(depth) {\n        depth = this.resolveDepth(depth);\n        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */ start(depth) {\n        depth = this.resolveDepth(depth);\n        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */ end(depth) {\n        depth = this.resolveDepth(depth);\n        return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */ before(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */ after(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */ get textOffset() {\n        return this.pos - this.path[this.path.length - 1];\n    }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */ get nodeAfter() {\n        let parent = this.parent, index = this.index(this.depth);\n        if (index == parent.childCount) return null;\n        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n        return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */ get nodeBefore() {\n        let index = this.index(this.depth);\n        let dOff = this.pos - this.path[this.path.length - 1];\n        if (dOff) return this.parent.child(index).cut(0, dOff);\n        return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */ posAtIndex(index, depth) {\n        depth = this.resolveDepth(depth);\n        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n        for(let i = 0; i < index; i++)pos += node.child(i).nodeSize;\n        return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */ marks() {\n        let parent = this.parent, index = this.index();\n        // In an empty parent, return the empty array\n        if (parent.content.size == 0) return Mark.none;\n        // When inside a text node, just return the text node's marks\n        if (this.textOffset) return parent.child(index).marks;\n        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n        // If the `after` flag is true of there is no node before, make\n        // the node after this position the main reference.\n        if (!main) {\n            let tmp = main;\n            main = other;\n            other = tmp;\n        }\n        // Use all marks in the main node, except those that have\n        // `inclusive` set to false and are not present in the other node.\n        let marks = main.marks;\n        for(var i = 0; i < marks.length; i++)if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */ marksAcross($end) {\n        let after = this.parent.maybeChild(this.index());\n        if (!after || !after.isInline) return null;\n        let marks = after.marks, next = $end.parent.maybeChild($end.index());\n        for(var i = 0; i < marks.length; i++)if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */ sharedDepth(pos) {\n        for(let depth = this.depth; depth > 0; depth--)if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;\n        return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */ blockRange(other = this, pred) {\n        if (other.pos < this.pos) return other.blockRange(this);\n        for(let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);\n        return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */ sameParent(other) {\n        return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */ max(other) {\n        return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */ min(other) {\n        return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */ toString() {\n        let str = \"\";\n        for(let i = 1; i <= this.depth; i++)str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n        return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */ static resolve(doc, pos) {\n        if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n        let path = [];\n        let start = 0, parentOffset = pos;\n        for(let node = doc;;){\n            let { index, offset } = node.content.findIndex(parentOffset);\n            let rem = parentOffset - offset;\n            path.push(node, index, start + offset);\n            if (!rem) break;\n            node = node.child(index);\n            if (node.isText) break;\n            parentOffset = rem - 1;\n            start += offset + 1;\n        }\n        return new ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */ static resolveCached(doc, pos) {\n        let cache = resolveCache.get(doc);\n        if (cache) {\n            for(let i = 0; i < cache.elts.length; i++){\n                let elt = cache.elts[i];\n                if (elt.pos == pos) return elt;\n            }\n        } else {\n            resolveCache.set(doc, cache = new ResolveCache);\n        }\n        let result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);\n        cache.i = (cache.i + 1) % resolveCacheSize;\n        return result;\n    }\n}\nclass ResolveCache {\n    constructor(){\n        this.elts = [];\n        this.i = 0;\n    }\n}\nconst resolveCacheSize = 12, resolveCache = new WeakMap();\n/**\nRepresents a flat range of content, i.e. one that starts and\nends in the same node.\n*/ class NodeRange {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */ constructor(/**\n    A resolved position along the start of the content. May have a\n    `depth` greater than this object's `depth` property, since\n    these are the positions that were used to compute the range,\n    not re-resolved positions directly at its boundaries.\n    */ $from, /**\n    A position along the end of the content. See\n    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).\n    */ $to, /**\n    The depth of the node that this range points into.\n    */ depth){\n        this.$from = $from;\n        this.$to = $to;\n        this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */ get start() {\n        return this.$from.before(this.depth + 1);\n    }\n    /**\n    The position at the end of the range.\n    */ get end() {\n        return this.$to.after(this.depth + 1);\n    }\n    /**\n    The parent node that the range points into.\n    */ get parent() {\n        return this.$from.node(this.depth);\n    }\n    /**\n    The start index of the range in the parent node.\n    */ get startIndex() {\n        return this.$from.index(this.depth);\n    }\n    /**\n    The end index of the range in the parent node.\n    */ get endIndex() {\n        return this.$to.indexAfter(this.depth);\n    }\n}\nconst emptyAttrs = Object.create(null);\n/**\nThis class represents a node in the tree that makes up a\nProseMirror document. So a document is an instance of `Node`, with\nchildren that are also instances of `Node`.\n\nNodes are persistent data structures. Instead of changing them, you\ncreate new ones with the content you want. Old ones keep pointing\nat the old document shape. This is made cheaper by sharing\nstructure between the old and new data as much as possible, which a\ntree shape like this (without back pointers) makes easy.\n\n**Do not** directly mutate the properties of a `Node` object. See\n[the guide](https://prosemirror.net/docs/guide/#doc) for more information.\n*/ class Node {\n    /**\n    @internal\n    */ constructor(/**\n    The type of node that this is.\n    */ type, /**\n    An object mapping attribute names to values. The kind of\n    attributes allowed and required are\n    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.\n    */ attrs, // A fragment holding the node's children.\n    content, /**\n    The marks (things like whether it is emphasized or part of a\n    link) applied to this node.\n    */ marks = Mark.none){\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.content = content || Fragment.empty;\n    }\n    /**\n    The array of this node's child nodes.\n    */ get children() {\n        return this.content.content;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */ get nodeSize() {\n        return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n    /**\n    The number of children that the node has.\n    */ get childCount() {\n        return this.content.childCount;\n    }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */ child(index) {\n        return this.content.child(index);\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */ maybeChild(index) {\n        return this.content.maybeChild(index);\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */ forEach(f) {\n        this.content.forEach(f);\n    }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */ nodesBetween(from, to, f, startPos = 0) {\n        this.content.nodesBetween(from, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */ descendants(f) {\n        this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */ get textContent() {\n        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.\n    */ textBetween(from, to, blockSeparator, leafText) {\n        return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */ get firstChild() {\n        return this.content.firstChild;\n    }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */ get lastChild() {\n        return this.content.lastChild;\n    }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */ eq(other) {\n        return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */ sameMarkup(other) {\n        return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */ hasMarkup(type, attrs, marks) {\n        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */ copy(content = null) {\n        if (content == this.content) return this;\n        return new Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */ mark(marks) {\n        return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */ cut(from, to = this.content.size) {\n        if (from == 0 && to == this.content.size) return this;\n        return this.copy(this.content.cut(from, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */ slice(from, to = this.content.size, includeParents = false) {\n        if (from == to) return Slice.empty;\n        let $from = this.resolve(from), $to = this.resolve(to);\n        let depth = includeParents ? 0 : $from.sharedDepth(to);\n        let start = $from.start(depth), node = $from.node(depth);\n        let content = node.content.cut($from.pos - start, $to.pos - start);\n        return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */ replace(from, to, slice) {\n        return replace(this.resolve(from), this.resolve(to), slice);\n    }\n    /**\n    Find the node directly after the given position.\n    */ nodeAt(pos) {\n        for(let node = this;;){\n            let { index, offset } = node.content.findIndex(pos);\n            node = node.maybeChild(index);\n            if (!node) return null;\n            if (offset == pos || node.isText) return node;\n            pos -= offset + 1;\n        }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */ childAfter(pos) {\n        let { index, offset } = this.content.findIndex(pos);\n        return {\n            node: this.content.maybeChild(index),\n            index,\n            offset\n        };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */ childBefore(pos) {\n        if (pos == 0) return {\n            node: null,\n            index: 0,\n            offset: 0\n        };\n        let { index, offset } = this.content.findIndex(pos);\n        if (offset < pos) return {\n            node: this.content.child(index),\n            index,\n            offset\n        };\n        let node = this.content.child(index - 1);\n        return {\n            node,\n            index: index - 1,\n            offset: offset - node.nodeSize\n        };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */ resolve(pos) {\n        return ResolvedPos.resolveCached(this, pos);\n    }\n    /**\n    @internal\n    */ resolveNoCache(pos) {\n        return ResolvedPos.resolve(this, pos);\n    }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */ rangeHasMark(from, to, type) {\n        let found = false;\n        if (to > from) this.nodesBetween(from, to, (node)=>{\n            if (type.isInSet(node.marks)) found = true;\n            return !found;\n        });\n        return found;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */ get isBlock() {\n        return this.type.isBlock;\n    }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */ get isTextblock() {\n        return this.type.isTextblock;\n    }\n    /**\n    True when this node allows inline content.\n    */ get inlineContent() {\n        return this.type.inlineContent;\n    }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */ get isInline() {\n        return this.type.isInline;\n    }\n    /**\n    True when this is a text node.\n    */ get isText() {\n        return this.type.isText;\n    }\n    /**\n    True when this is a leaf node.\n    */ get isLeaf() {\n        return this.type.isLeaf;\n    }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */ get isAtom() {\n        return this.type.isAtom;\n    }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */ toString() {\n        if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n        let name = this.type.name;\n        if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n        return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */ contentMatchAt(index) {\n        let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n        if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\");\n        return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */ canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n        let two = one && one.matchFragment(this.content, to);\n        if (!two || !two.validEnd) return false;\n        for(let i = start; i < end; i++)if (!this.type.allowsMarks(replacement.child(i).marks)) return false;\n        return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */ canReplaceWith(from, to, type, marks) {\n        if (marks && !this.type.allowsMarks(marks)) return false;\n        let start = this.contentMatchAt(from).matchType(type);\n        let end = start && start.matchFragment(this.content, to);\n        return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */ canAppend(other) {\n        if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);\n        else return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise an exception when they do not.\n    */ check() {\n        this.type.checkContent(this.content);\n        this.type.checkAttrs(this.attrs);\n        let copy = Mark.none;\n        for(let i = 0; i < this.marks.length; i++){\n            let mark = this.marks[i];\n            mark.type.checkAttrs(mark.attrs);\n            copy = mark.addToSet(copy);\n        }\n        if (!Mark.sameSet(copy, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m)=>m.type.name)}`);\n        this.content.forEach((node)=>node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */ toJSON() {\n        let obj = {\n            type: this.type.name\n        };\n        for(let _ in this.attrs){\n            obj.attrs = this.attrs;\n            break;\n        }\n        if (this.content.size) obj.content = this.content.toJSON();\n        if (this.marks.length) obj.marks = this.marks.map((n)=>n.toJSON());\n        return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */ static fromJSON(schema, json) {\n        if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\");\n        let marks = undefined;\n        if (json.marks) {\n            if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n            marks = json.marks.map(schema.markFromJSON);\n        }\n        if (json.type == \"text\") {\n            if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\");\n            return schema.text(json.text, marks);\n        }\n        let content = Fragment.fromJSON(schema, json.content);\n        let node = schema.nodeType(json.type).create(json.attrs, content, marks);\n        node.type.checkAttrs(node.attrs);\n        return node;\n    }\n}\nNode.prototype.text = undefined;\nclass TextNode extends Node {\n    /**\n    @internal\n    */ constructor(type, attrs, content, marks){\n        super(type, attrs, null, marks);\n        if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n        this.text = content;\n    }\n    toString() {\n        if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n        return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() {\n        return this.text;\n    }\n    textBetween(from, to) {\n        return this.text.slice(from, to);\n    }\n    get nodeSize() {\n        return this.text.length;\n    }\n    mark(marks) {\n        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n    withText(text) {\n        if (text == this.text) return this;\n        return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n    cut(from = 0, to = this.text.length) {\n        if (from == 0 && to == this.text.length) return this;\n        return this.withText(this.text.slice(from, to));\n    }\n    eq(other) {\n        return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n        let base = super.toJSON();\n        base.text = this.text;\n        return base;\n    }\n}\nfunction wrapMarks(marks, str) {\n    for(let i = marks.length - 1; i >= 0; i--)str = marks[i].type.name + \"(\" + str + \")\";\n    return str;\n}\n/**\nInstances of this class represent a match state of a node type's\n[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to\nfind out whether further content matches here, and whether a given\nposition is a valid end of the node.\n*/ class ContentMatch {\n    /**\n    @internal\n    */ constructor(/**\n    True when this match state represents a valid end of the node.\n    */ validEnd){\n        this.validEnd = validEnd;\n        /**\n        @internal\n        */ this.next = [];\n        /**\n        @internal\n        */ this.wrapCache = [];\n    }\n    /**\n    @internal\n    */ static parse(string, nodeTypes) {\n        let stream = new TokenStream(string, nodeTypes);\n        if (stream.next == null) return ContentMatch.empty;\n        let expr = parseExpr(stream);\n        if (stream.next) stream.err(\"Unexpected trailing text\");\n        let match = dfa(nfa(expr));\n        checkForDeadEnds(match, stream);\n        return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */ matchType(type) {\n        for(let i = 0; i < this.next.length; i++)if (this.next[i].type == type) return this.next[i].next;\n        return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */ matchFragment(frag, start = 0, end = frag.childCount) {\n        let cur = this;\n        for(let i = start; cur && i < end; i++)cur = cur.matchType(frag.child(i).type);\n        return cur;\n    }\n    /**\n    @internal\n    */ get inlineContent() {\n        return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */ get defaultType() {\n        for(let i = 0; i < this.next.length; i++){\n            let { type } = this.next[i];\n            if (!(type.isText || type.hasRequiredAttrs())) return type;\n        }\n        return null;\n    }\n    /**\n    @internal\n    */ compatible(other) {\n        for(let i = 0; i < this.next.length; i++)for(let j = 0; j < other.next.length; j++)if (this.next[i].type == other.next[j].type) return true;\n        return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */ fillBefore(after, toEnd = false, startIndex = 0) {\n        let seen = [\n            this\n        ];\n        function search(match, types) {\n            let finished = match.matchFragment(after, startIndex);\n            if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map((tp)=>tp.createAndFill()));\n            for(let i = 0; i < match.next.length; i++){\n                let { type, next } = match.next[i];\n                if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n                    seen.push(next);\n                    let found = search(next, types.concat(type));\n                    if (found) return found;\n                }\n            }\n            return null;\n        }\n        return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */ findWrapping(target) {\n        for(let i = 0; i < this.wrapCache.length; i += 2)if (this.wrapCache[i] == target) return this.wrapCache[i + 1];\n        let computed = this.computeWrapping(target);\n        this.wrapCache.push(target, computed);\n        return computed;\n    }\n    /**\n    @internal\n    */ computeWrapping(target) {\n        let seen = Object.create(null), active = [\n            {\n                match: this,\n                type: null,\n                via: null\n            }\n        ];\n        while(active.length){\n            let current = active.shift(), match = current.match;\n            if (match.matchType(target)) {\n                let result = [];\n                for(let obj = current; obj.type; obj = obj.via)result.push(obj.type);\n                return result.reverse();\n            }\n            for(let i = 0; i < match.next.length; i++){\n                let { type, next } = match.next[i];\n                if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n                    active.push({\n                        match: type.contentMatch,\n                        type,\n                        via: current\n                    });\n                    seen[type.name] = true;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */ get edgeCount() {\n        return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */ edge(n) {\n        if (n >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`);\n        return this.next[n];\n    }\n    /**\n    @internal\n    */ toString() {\n        let seen = [];\n        function scan(m) {\n            seen.push(m);\n            for(let i = 0; i < m.next.length; i++)if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);\n        }\n        scan(this);\n        return seen.map((m, i)=>{\n            let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n            for(let i = 0; i < m.next.length; i++)out += (i ? \", \" : \"\") + m.next[i].type.name + \"->\" + seen.indexOf(m.next[i].next);\n            return out;\n        }).join(\"\\n\");\n    }\n}\n/**\n@internal\n*/ ContentMatch.empty = new ContentMatch(true);\nclass TokenStream {\n    constructor(string, nodeTypes){\n        this.string = string;\n        this.nodeTypes = nodeTypes;\n        this.inline = null;\n        this.pos = 0;\n        this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n        if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop();\n        if (this.tokens[0] == \"\") this.tokens.shift();\n    }\n    get next() {\n        return this.tokens[this.pos];\n    }\n    eat(tok) {\n        return this.next == tok && (this.pos++ || true);\n    }\n    err(str) {\n        throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n}\nfunction parseExpr(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSeq(stream));\n    }while (stream.eat(\"|\"));\n    return exprs.length == 1 ? exprs[0] : {\n        type: \"choice\",\n        exprs\n    };\n}\nfunction parseExprSeq(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSubscript(stream));\n    }while (stream.next && stream.next != \")\" && stream.next != \"|\");\n    return exprs.length == 1 ? exprs[0] : {\n        type: \"seq\",\n        exprs\n    };\n}\nfunction parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for(;;){\n        if (stream.eat(\"+\")) expr = {\n            type: \"plus\",\n            expr\n        };\n        else if (stream.eat(\"*\")) expr = {\n            type: \"star\",\n            expr\n        };\n        else if (stream.eat(\"?\")) expr = {\n            type: \"opt\",\n            expr\n        };\n        else if (stream.eat(\"{\")) expr = parseExprRange(stream, expr);\n        else break;\n    }\n    return expr;\n}\nfunction parseNum(stream) {\n    if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n}\nfunction parseExprRange(stream, expr) {\n    let min = parseNum(stream), max = min;\n    if (stream.eat(\",\")) {\n        if (stream.next != \"}\") max = parseNum(stream);\n        else max = -1;\n    }\n    if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\");\n    return {\n        type: \"range\",\n        min,\n        max,\n        expr\n    };\n}\nfunction resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type) return [\n        type\n    ];\n    let result = [];\n    for(let typeName in types){\n        let type = types[typeName];\n        if (type.isInGroup(name)) result.push(type);\n    }\n    if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\");\n    return result;\n}\nfunction parseExprAtom(stream) {\n    if (stream.eat(\"(\")) {\n        let expr = parseExpr(stream);\n        if (!stream.eat(\")\")) stream.err(\"Missing closing paren\");\n        return expr;\n    } else if (!/\\W/.test(stream.next)) {\n        let exprs = resolveName(stream, stream.next).map((type)=>{\n            if (stream.inline == null) stream.inline = type.isInline;\n            else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\");\n            return {\n                type: \"name\",\n                value: type\n            };\n        });\n        stream.pos++;\n        return exprs.length == 1 ? exprs[0] : {\n            type: \"choice\",\n            exprs\n        };\n    } else {\n        stream.err(\"Unexpected token '\" + stream.next + \"'\");\n    }\n}\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n    let nfa = [\n        []\n    ];\n    connect(compile(expr, 0), node());\n    return nfa;\n    function node() {\n        return nfa.push([]) - 1;\n    }\n    function edge(from, to, term) {\n        let edge = {\n            term,\n            to\n        };\n        nfa[from].push(edge);\n        return edge;\n    }\n    function connect(edges, to) {\n        edges.forEach((edge)=>edge.to = to);\n    }\n    function compile(expr, from) {\n        if (expr.type == \"choice\") {\n            return expr.exprs.reduce((out, expr)=>out.concat(compile(expr, from)), []);\n        } else if (expr.type == \"seq\") {\n            for(let i = 0;; i++){\n                let next = compile(expr.exprs[i], from);\n                if (i == expr.exprs.length - 1) return next;\n                connect(next, from = node());\n            }\n        } else if (expr.type == \"star\") {\n            let loop = node();\n            edge(from, loop);\n            connect(compile(expr.expr, loop), loop);\n            return [\n                edge(loop)\n            ];\n        } else if (expr.type == \"plus\") {\n            let loop = node();\n            connect(compile(expr.expr, from), loop);\n            connect(compile(expr.expr, loop), loop);\n            return [\n                edge(loop)\n            ];\n        } else if (expr.type == \"opt\") {\n            return [\n                edge(from)\n            ].concat(compile(expr.expr, from));\n        } else if (expr.type == \"range\") {\n            let cur = from;\n            for(let i = 0; i < expr.min; i++){\n                let next = node();\n                connect(compile(expr.expr, cur), next);\n                cur = next;\n            }\n            if (expr.max == -1) {\n                connect(compile(expr.expr, cur), cur);\n            } else {\n                for(let i = expr.min; i < expr.max; i++){\n                    let next = node();\n                    edge(cur, next);\n                    connect(compile(expr.expr, cur), next);\n                    cur = next;\n                }\n            }\n            return [\n                edge(cur)\n            ];\n        } else if (expr.type == \"name\") {\n            return [\n                edge(from, undefined, expr.value)\n            ];\n        } else {\n            throw new Error(\"Unknown expr type\");\n        }\n    }\n}\nfunction cmp(a, b) {\n    return b - a;\n}\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node) {\n        let edges = nfa[node];\n        if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);\n        result.push(node);\n        for(let i = 0; i < edges.length; i++){\n            let { term, to } = edges[i];\n            if (!term && result.indexOf(to) == -1) scan(to);\n        }\n    }\n}\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n    let labeled = Object.create(null);\n    return explore(nullFrom(nfa, 0));\n    function explore(states) {\n        let out = [];\n        states.forEach((node)=>{\n            nfa[node].forEach(({ term, to })=>{\n                if (!term) return;\n                let set;\n                for(let i = 0; i < out.length; i++)if (out[i][0] == term) set = out[i][1];\n                nullFrom(nfa, to).forEach((node)=>{\n                    if (!set) out.push([\n                        term,\n                        set = []\n                    ]);\n                    if (set.indexOf(node) == -1) set.push(node);\n                });\n            });\n        });\n        let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n        for(let i = 0; i < out.length; i++){\n            let states = out[i][1].sort(cmp);\n            state.next.push({\n                type: out[i][0],\n                next: labeled[states.join(\",\")] || explore(states)\n            });\n        }\n        return state;\n    }\n}\nfunction checkForDeadEnds(match, stream) {\n    for(let i = 0, work = [\n        match\n    ]; i < work.length; i++){\n        let state = work[i], dead = !state.validEnd, nodes = [];\n        for(let j = 0; j < state.next.length; j++){\n            let { type, next } = state.next[j];\n            nodes.push(type.name);\n            if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;\n            if (work.indexOf(next) == -1) work.push(next);\n        }\n        if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n}\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n    let defaults = Object.create(null);\n    for(let attrName in attrs){\n        let attr = attrs[attrName];\n        if (!attr.hasDefault) return null;\n        defaults[attrName] = attr.default;\n    }\n    return defaults;\n}\nfunction computeAttrs(attrs, value) {\n    let built = Object.create(null);\n    for(let name in attrs){\n        let given = value && value[name];\n        if (given === undefined) {\n            let attr = attrs[name];\n            if (attr.hasDefault) given = attr.default;\n            else throw new RangeError(\"No value supplied for attribute \" + name);\n        }\n        built[name] = given;\n    }\n    return built;\n}\nfunction checkAttrs(attrs, values, type, name) {\n    for(let name in values)if (!(name in attrs)) throw new RangeError(`Unsupported attribute ${name} for ${type} of type ${name}`);\n    for(let name in attrs){\n        let attr = attrs[name];\n        if (attr.validate) attr.validate(values[name]);\n    }\n}\nfunction initAttrs(typeName, attrs) {\n    let result = Object.create(null);\n    if (attrs) for(let name in attrs)result[name] = new Attribute(typeName, name, attrs[name]);\n    return result;\n}\n/**\nNode types are objects allocated once per `Schema` and used to\n[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information\nabout the node type, such as its name and what kind of node it\nrepresents.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name the node type has in this schema.\n    */ name, /**\n    A link back to the `Schema` the node type belongs to.\n    */ schema, /**\n    The spec that this type is based on\n    */ spec){\n        this.name = name;\n        this.schema = schema;\n        this.spec = spec;\n        /**\n        The set of marks allowed in this node. `null` means all marks\n        are allowed.\n        */ this.markSet = null;\n        this.groups = spec.group ? spec.group.split(\" \") : [];\n        this.attrs = initAttrs(name, spec.attrs);\n        this.defaultAttrs = defaultAttrs(this.attrs);\n        this.contentMatch = null;\n        this.inlineContent = null;\n        this.isBlock = !(spec.inline || name == \"text\");\n        this.isText = name == \"text\";\n    }\n    /**\n    True if this is an inline type.\n    */ get isInline() {\n        return !this.isBlock;\n    }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */ get isTextblock() {\n        return this.isBlock && this.inlineContent;\n    }\n    /**\n    True for node types that allow no content.\n    */ get isLeaf() {\n        return this.contentMatch == ContentMatch.empty;\n    }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */ get isAtom() {\n        return this.isLeaf || !!this.spec.atom;\n    }\n    /**\n    Return true when this node type is part of the given\n    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).\n    */ isInGroup(group) {\n        return this.groups.indexOf(group) > -1;\n    }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */ get whitespace() {\n        return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */ hasRequiredAttrs() {\n        for(let n in this.attrs)if (this.attrs[n].isRequired) return true;\n        return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */ compatibleContent(other) {\n        return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */ computeAttrs(attrs) {\n        if (!attrs && this.defaultAttrs) return this.defaultAttrs;\n        else return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */ create(attrs = null, content, marks) {\n        if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\");\n        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */ createChecked(attrs = null, content, marks) {\n        content = Fragment.from(content);\n        this.checkContent(content);\n        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */ createAndFill(attrs = null, content, marks) {\n        attrs = this.computeAttrs(attrs);\n        content = Fragment.from(content);\n        if (content.size) {\n            let before = this.contentMatch.fillBefore(content);\n            if (!before) return null;\n            content = before.append(content);\n        }\n        let matched = this.contentMatch.matchFragment(content);\n        let after = matched && matched.fillBefore(Fragment.empty, true);\n        if (!after) return null;\n        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type.\n    */ validContent(content) {\n        let result = this.contentMatch.matchFragment(content);\n        if (!result || !result.validEnd) return false;\n        for(let i = 0; i < content.childCount; i++)if (!this.allowsMarks(content.child(i).marks)) return false;\n        return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */ checkContent(content) {\n        if (!this.validContent(content)) throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    @internal\n    */ checkAttrs(attrs) {\n        checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */ allowsMarkType(markType) {\n        return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */ allowsMarks(marks) {\n        if (this.markSet == null) return true;\n        for(let i = 0; i < marks.length; i++)if (!this.allowsMarkType(marks[i].type)) return false;\n        return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */ allowedMarks(marks) {\n        if (this.markSet == null) return marks;\n        let copy;\n        for(let i = 0; i < marks.length; i++){\n            if (!this.allowsMarkType(marks[i].type)) {\n                if (!copy) copy = marks.slice(0, i);\n            } else if (copy) {\n                copy.push(marks[i]);\n            }\n        }\n        return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n    /**\n    @internal\n    */ static compile(nodes, schema) {\n        let result = Object.create(null);\n        nodes.forEach((name, spec)=>result[name] = new NodeType(name, schema, spec));\n        let topType = schema.spec.topNode || \"doc\";\n        if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n        if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n        for(let _ in result.text.attrs)throw new RangeError(\"The text node type should not have attributes\");\n        return result;\n    }\n}\nfunction validateType(typeName, attrName, type) {\n    let types = type.split(\"|\");\n    return (value)=>{\n        let name = value === null ? \"null\" : typeof value;\n        if (types.indexOf(name) < 0) throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);\n    };\n}\n// Attribute descriptors\nclass Attribute {\n    constructor(typeName, attrName, options){\n        this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n        this.default = options.default;\n        this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n    }\n    get isRequired() {\n        return !this.hasDefault;\n    }\n}\n// Marks\n/**\nLike nodes, marks (which are associated with nodes to signify\nthings like emphasis or being part of a link) are\n[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are\ninstantiated once per `Schema`.\n*/ class MarkType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the mark type.\n    */ name, /**\n    @internal\n    */ rank, /**\n    The schema that this mark type instance is part of.\n    */ schema, /**\n    The spec on which the type is based.\n    */ spec){\n        this.name = name;\n        this.rank = rank;\n        this.schema = schema;\n        this.spec = spec;\n        this.attrs = initAttrs(name, spec.attrs);\n        this.excluded = null;\n        let defaults = defaultAttrs(this.attrs);\n        this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark's attributes. The others, if\n    they have defaults, will be added.\n    */ create(attrs = null) {\n        if (!attrs && this.instance) return this.instance;\n        return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */ static compile(marks, schema) {\n        let result = Object.create(null), rank = 0;\n        marks.forEach((name, spec)=>result[name] = new MarkType(name, rank++, schema, spec));\n        return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */ removeFromSet(set) {\n        for(var i = 0; i < set.length; i++)if (set[i].type == this) {\n            set = set.slice(0, i).concat(set.slice(i + 1));\n            i--;\n        }\n        return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */ isInSet(set) {\n        for(let i = 0; i < set.length; i++)if (set[i].type == this) return set[i];\n    }\n    /**\n    @internal\n    */ checkAttrs(attrs) {\n        checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */ excludes(other) {\n        return this.excluded.indexOf(other) > -1;\n    }\n}\n/**\nA document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark\ntype](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may\noccur in conforming documents, and provides functionality for\ncreating and deserializing such documents.\n\nWhen given, the type parameters provide the names of the nodes and\nmarks in this schema.\n*/ class Schema {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */ constructor(spec){\n        /**\n        The [linebreak\n        replacement](https://prosemirror.net/docs/ref/#model.NodeSpec.linebreakReplacement) node defined\n        in this schema, if any.\n        */ this.linebreakReplacement = null;\n        /**\n        An object for storing whatever values modules may want to\n        compute and cache per schema. (If you want to store something\n        in it, try to use property names unlikely to clash.)\n        */ this.cached = Object.create(null);\n        let instanceSpec = this.spec = {};\n        for(let prop in spec)instanceSpec[prop] = spec[prop];\n        instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.nodes), instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n        this.marks = MarkType.compile(this.spec.marks, this);\n        let contentExprCache = Object.create(null);\n        for(let prop in this.nodes){\n            if (prop in this.marks) throw new RangeError(prop + \" can not be both a node and a mark\");\n            let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n            type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n            type.inlineContent = type.contentMatch.inlineContent;\n            if (type.spec.linebreakReplacement) {\n                if (this.linebreakReplacement) throw new RangeError(\"Multiple linebreak nodes defined\");\n                if (!type.isInline || !type.isLeaf) throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n                this.linebreakReplacement = type;\n            }\n            type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n        }\n        for(let prop in this.marks){\n            let type = this.marks[prop], excl = type.spec.excludes;\n            type.excluded = excl == null ? [\n                type\n            ] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n        }\n        this.nodeFromJSON = (json)=>Node.fromJSON(this, json);\n        this.markFromJSON = (json)=>Mark.fromJSON(this, json);\n        this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n        this.cached.wrappings = Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */ node(type, attrs = null, content, marks) {\n        if (typeof type == \"string\") type = this.nodeType(type);\n        else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);\n        else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n        return type.createChecked(attrs, content, marks);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */ text(text, marks) {\n        let type = this.nodes.text;\n        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */ mark(type, attrs) {\n        if (typeof type == \"string\") type = this.marks[type];\n        return type.create(attrs);\n    }\n    /**\n    @internal\n    */ nodeType(name) {\n        let found = this.nodes[name];\n        if (!found) throw new RangeError(\"Unknown node type: \" + name);\n        return found;\n    }\n}\nfunction gatherMarks(schema, marks) {\n    let found = [];\n    for(let i = 0; i < marks.length; i++){\n        let name = marks[i], mark = schema.marks[name], ok = mark;\n        if (mark) {\n            found.push(mark);\n        } else {\n            for(let prop in schema.marks){\n                let mark = schema.marks[prop];\n                if (name == \"_\" || mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1) found.push(ok = mark);\n            }\n        }\n        if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n    }\n    return found;\n}\nfunction isTagRule(rule) {\n    return rule.tag != null;\n}\nfunction isStyleRule(rule) {\n    return rule.style != null;\n}\n/**\nA DOM parser represents a strategy for parsing DOM content into a\nProseMirror document conforming to a given schema. Its behavior is\ndefined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).\n*/ class DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */ constructor(/**\n    The schema into which the parser parses.\n    */ schema, /**\n    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser\n    uses, in order of precedence.\n    */ rules){\n        this.schema = schema;\n        this.rules = rules;\n        /**\n        @internal\n        */ this.tags = [];\n        /**\n        @internal\n        */ this.styles = [];\n        let matchedStyles = this.matchedStyles = [];\n        rules.forEach((rule)=>{\n            if (isTagRule(rule)) {\n                this.tags.push(rule);\n            } else if (isStyleRule(rule)) {\n                let prop = /[^=]*/.exec(rule.style)[0];\n                if (matchedStyles.indexOf(prop) < 0) matchedStyles.push(prop);\n                this.styles.push(rule);\n            }\n        });\n        // Only normalize list elements when lists in the schema can't directly contain themselves\n        this.normalizeLists = !this.tags.some((r)=>{\n            if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false;\n            let node = schema.nodes[r.node];\n            return node.contentMatch.matchType(node);\n        });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */ parse(dom, options = {}) {\n        let context = new ParseContext(this, options, false);\n        context.addAll(dom, Mark.none, options.from, options.to);\n        return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */ parseSlice(dom, options = {}) {\n        let context = new ParseContext(this, options, true);\n        context.addAll(dom, Mark.none, options.from, options.to);\n        return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */ matchTag(dom, context, after) {\n        for(let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++){\n            let rule = this.tags[i];\n            if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n                if (rule.getAttrs) {\n                    let result = rule.getAttrs(dom);\n                    if (result === false) continue;\n                    rule.attrs = result || undefined;\n                }\n                return rule;\n            }\n        }\n    }\n    /**\n    @internal\n    */ matchStyle(prop, value, context, after) {\n        for(let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++){\n            let rule = this.styles[i], style = rule.style;\n            if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,\n            // or has an '=' sign after the prop, followed by the given\n            // value.\n            style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;\n            if (rule.getAttrs) {\n                let result = rule.getAttrs(value);\n                if (result === false) continue;\n                rule.attrs = result || undefined;\n            }\n            return rule;\n        }\n    }\n    /**\n    @internal\n    */ static schemaRules(schema) {\n        let result = [];\n        function insert(rule) {\n            let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n            for(; i < result.length; i++){\n                let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n                if (nextPriority < priority) break;\n            }\n            result.splice(i, 0, rule);\n        }\n        for(let name in schema.marks){\n            let rules = schema.marks[name].spec.parseDOM;\n            if (rules) rules.forEach((rule)=>{\n                insert(rule = copy(rule));\n                if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;\n            });\n        }\n        for(let name in schema.nodes){\n            let rules = schema.nodes[name].spec.parseDOM;\n            if (rules) rules.forEach((rule)=>{\n                insert(rule = copy(rule));\n                if (!(rule.node || rule.ignore || rule.mark)) rule.node = name;\n            });\n        }\n        return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).\n    */ static fromSchema(schema) {\n        return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n}\nconst blockTags = {\n    address: true,\n    article: true,\n    aside: true,\n    blockquote: true,\n    canvas: true,\n    dd: true,\n    div: true,\n    dl: true,\n    fieldset: true,\n    figcaption: true,\n    figure: true,\n    footer: true,\n    form: true,\n    h1: true,\n    h2: true,\n    h3: true,\n    h4: true,\n    h5: true,\n    h6: true,\n    header: true,\n    hgroup: true,\n    hr: true,\n    li: true,\n    noscript: true,\n    ol: true,\n    output: true,\n    p: true,\n    pre: true,\n    section: true,\n    table: true,\n    tfoot: true,\n    ul: true\n};\nconst ignoreTags = {\n    head: true,\n    noscript: true,\n    object: true,\n    script: true,\n    style: true,\n    title: true\n};\nconst listTags = {\n    ol: true,\n    ul: true\n};\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n    if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nclass NodeContext {\n    constructor(type, attrs, marks, solid, match, options){\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.solid = solid;\n        this.options = options;\n        this.content = [];\n        // Marks applied to the node's children\n        this.activeMarks = Mark.none;\n        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n        if (!this.match) {\n            if (!this.type) return [];\n            let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n            if (fill) {\n                this.match = this.type.contentMatch.matchFragment(fill);\n            } else {\n                let start = this.type.contentMatch, wrap;\n                if (wrap = start.findWrapping(node.type)) {\n                    this.match = start;\n                    return wrap;\n                } else {\n                    return null;\n                }\n            }\n        }\n        return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n        if (!(this.options & OPT_PRESERVE_WS)) {\n            let last = this.content[this.content.length - 1], m;\n            if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n                let text = last;\n                if (last.text.length == m[0].length) this.content.pop();\n                else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n            }\n        }\n        let content = Fragment.from(this.content);\n        if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));\n        return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    inlineContext(node) {\n        if (this.type) return this.type.inlineContent;\n        if (this.content.length) return this.content[0].isInline;\n        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n}\nclass ParseContext {\n    constructor(// The parser we are using.\n    parser, // The options passed to this parse.\n    options, isOpen){\n        this.parser = parser;\n        this.options = options;\n        this.isOpen = isOpen;\n        this.open = 0;\n        this.localPreserveWS = false;\n        let topNode = options.topNode, topContext;\n        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n        if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n        else if (isOpen) topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);\n        else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n        this.nodes = [\n            topContext\n        ];\n        this.find = options.findPositions;\n        this.needsBlock = false;\n    }\n    get top() {\n        return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom, marks) {\n        if (dom.nodeType == 3) this.addTextNode(dom, marks);\n        else if (dom.nodeType == 1) this.addElement(dom, marks);\n    }\n    addTextNode(dom, marks) {\n        let value = dom.nodeValue;\n        let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n        let { schema } = this.parser;\n        if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n            if (!preserveWS) {\n                value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n                // If this starts with whitespace, and there is no node before it, or\n                // a hard break, or a text node that ends with whitespace, strip the\n                // leading space.\n                if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n                    let nodeBefore = top.content[top.content.length - 1];\n                    let domNodeBefore = dom.previousSibling;\n                    if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == \"BR\" || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) value = value.slice(1);\n                }\n            } else if (preserveWS === \"full\") {\n                value = value.replace(/\\r\\n?/g, \"\\n\");\n            } else if (schema.linebreakReplacement && /[\\r\\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {\n                let lines = value.split(/\\r?\\n|\\r/);\n                for(let i = 0; i < lines.length; i++){\n                    if (i) this.insertNode(schema.linebreakReplacement.create(), marks, true);\n                    if (lines[i]) this.insertNode(schema.text(lines[i]), marks, !/\\S/.test(lines[i]));\n                }\n                value = \"\";\n            } else {\n                value = value.replace(/\\r?\\n|\\r/g, \" \");\n            }\n            if (value) this.insertNode(schema.text(value), marks, !/\\S/.test(value));\n            this.findInText(dom);\n        } else {\n            this.findInside(dom);\n        }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n    addElement(dom, marks, matchAfter) {\n        let outerWS = this.localPreserveWS, top = this.top;\n        if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace)) this.localPreserveWS = true;\n        let name = dom.nodeName.toLowerCase(), ruleID;\n        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);\n        let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n        out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n            this.findInside(dom);\n            this.ignoreFallback(dom, marks);\n        } else if (!rule || rule.skip || rule.closeParent) {\n            if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);\n            else if (rule && rule.skip.nodeType) dom = rule.skip;\n            let sync, oldNeedsBlock = this.needsBlock;\n            if (blockTags.hasOwnProperty(name)) {\n                if (top.content.length && top.content[0].isInline && this.open) {\n                    this.open--;\n                    top = this.top;\n                }\n                sync = true;\n                if (!top.type) this.needsBlock = true;\n            } else if (!dom.firstChild) {\n                this.leafFallback(dom, marks);\n                break out;\n            }\n            let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);\n            if (innerMarks) this.addAll(dom, innerMarks);\n            if (sync) this.sync(top);\n            this.needsBlock = oldNeedsBlock;\n        } else {\n            let innerMarks = this.readStyles(dom, marks);\n            if (innerMarks) this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : undefined);\n        }\n        this.localPreserveWS = outerWS;\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom, marks) {\n        if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks);\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom, marks) {\n        // Ignored BR nodes should at least create an inline context\n        if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text(\"-\"), marks, true);\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an updated array of marks, or null to indicate some of the\n    // styles had a rule with `ignore` set.\n    readStyles(dom, marks) {\n        let styles = dom.style;\n        // Because many properties will only show up in 'normalized' form\n        // in `style.item` (i.e. text-decoration becomes\n        // text-decoration-line, text-decoration-color, etc), we directly\n        // query the styles mentioned in our rules instead of iterating\n        // over the items.\n        if (styles && styles.length) for(let i = 0; i < this.parser.matchedStyles.length; i++){\n            let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);\n            if (value) for(let after = undefined;;){\n                let rule = this.parser.matchStyle(name, value, this, after);\n                if (!rule) break;\n                if (rule.ignore) return null;\n                if (rule.clearMark) marks = marks.filter((m)=>!rule.clearMark(m));\n                else marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));\n                if (rule.consuming === false) after = rule;\n                else break;\n            }\n        }\n        return marks;\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n    addElementByRule(dom, rule, marks, continueAfter) {\n        let sync, nodeType;\n        if (rule.node) {\n            nodeType = this.parser.schema.nodes[rule.node];\n            if (!nodeType.isLeaf) {\n                let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);\n                if (inner) {\n                    sync = true;\n                    marks = inner;\n                }\n            } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == \"BR\")) {\n                this.leafFallback(dom, marks);\n            }\n        } else {\n            let markType = this.parser.schema.marks[rule.mark];\n            marks = marks.concat(markType.create(rule.attrs));\n        }\n        let startIn = this.top;\n        if (nodeType && nodeType.isLeaf) {\n            this.findInside(dom);\n        } else if (continueAfter) {\n            this.addElement(dom, marks, continueAfter);\n        } else if (rule.getContent) {\n            this.findInside(dom);\n            rule.getContent(dom, this.parser.schema).forEach((node)=>this.insertNode(node, marks, false));\n        } else {\n            let contentDOM = dom;\n            if (typeof rule.contentElement == \"string\") contentDOM = dom.querySelector(rule.contentElement);\n            else if (typeof rule.contentElement == \"function\") contentDOM = rule.contentElement(dom);\n            else if (rule.contentElement) contentDOM = rule.contentElement;\n            this.findAround(dom, contentDOM, true);\n            this.addAll(contentDOM, marks);\n            this.findAround(dom, contentDOM, false);\n        }\n        if (sync && this.sync(startIn)) this.open--;\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, marks, startIndex, endIndex) {\n        let index = startIndex || 0;\n        for(let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index){\n            this.findAtPoint(parent, index);\n            this.addDOM(dom, marks);\n        }\n        this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n    findPlace(node, marks, cautious) {\n        let route, sync;\n        for(let depth = this.open, penalty = 0; depth >= 0; depth--){\n            let cx = this.nodes[depth];\n            let found = cx.findWrapping(node);\n            if (found && (!route || route.length > found.length + penalty)) {\n                route = found;\n                sync = cx;\n                if (!found.length) break;\n            }\n            if (cx.solid) {\n                if (cautious) break;\n                penalty += 2;\n            }\n        }\n        if (!route) return null;\n        this.sync(sync);\n        for(let i = 0; i < route.length; i++)marks = this.enterInner(route[i], null, marks, false);\n        return marks;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node, marks, cautious) {\n        if (node.isInline && this.needsBlock && !this.top.type) {\n            let block = this.textblockFromContext();\n            if (block) marks = this.enterInner(block, null, marks);\n        }\n        let innerMarks = this.findPlace(node, marks, cautious);\n        if (innerMarks) {\n            this.closeExtra();\n            let top = this.top;\n            if (top.match) top.match = top.match.matchType(node.type);\n            let nodeMarks = Mark.none;\n            for (let m of innerMarks.concat(node.marks))if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type)) nodeMarks = m.addToSet(nodeMarks);\n            top.content.push(node.mark(nodeMarks));\n            return true;\n        }\n        return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, marks, preserveWS) {\n        let innerMarks = this.findPlace(type.create(attrs), marks, false);\n        if (innerMarks) innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);\n        return innerMarks;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs, marks, solid = false, preserveWS) {\n        this.closeExtra();\n        let top = this.top;\n        top.match = top.match && top.match.matchType(type);\n        let options = wsOptionsFor(type, preserveWS, top.options);\n        if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;\n        let applyMarks = Mark.none;\n        marks = marks.filter((m)=>{\n            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n                applyMarks = m.addToSet(applyMarks);\n                return false;\n            }\n            return true;\n        });\n        this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n        this.open++;\n        return marks;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n        let i = this.nodes.length - 1;\n        if (i > this.open) {\n            for(; i > this.open; i--)this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n            this.nodes.length = this.open + 1;\n        }\n    }\n    finish() {\n        this.open = 0;\n        this.closeExtra(this.isOpen);\n        return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n    sync(to) {\n        for(let i = this.open; i >= 0; i--){\n            if (this.nodes[i] == to) {\n                this.open = i;\n                return true;\n            } else if (this.localPreserveWS) {\n                this.nodes[i].options |= OPT_PRESERVE_WS;\n            }\n        }\n        return false;\n    }\n    get currentPos() {\n        this.closeExtra();\n        let pos = 0;\n        for(let i = this.open; i >= 0; i--){\n            let content = this.nodes[i].content;\n            for(let j = content.length - 1; j >= 0; j--)pos += content[j].nodeSize;\n            if (i) pos++;\n        }\n        return pos;\n    }\n    findAtPoint(parent, offset) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;\n        }\n    }\n    findInside(parent) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;\n        }\n    }\n    findAround(parent, content, before) {\n        if (parent != content && this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n                let pos = content.compareDocumentPosition(this.find[i].node);\n                if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;\n            }\n        }\n    }\n    findInText(textNode) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n        }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n        if (context.indexOf(\"|\") > -1) return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n        let parts = context.split(\"/\");\n        let option = this.options.context;\n        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n        let match = (i, depth)=>{\n            for(; i >= 0; i--){\n                let part = parts[i];\n                if (part == \"\") {\n                    if (i == parts.length - 1 || i == 0) continue;\n                    for(; depth >= minDepth; depth--)if (match(i - 1, depth)) return true;\n                    return false;\n                } else {\n                    let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n                    if (!next || next.name != part && !next.isInGroup(part)) return false;\n                    depth--;\n                }\n            }\n            return true;\n        };\n        return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n        let $context = this.options.context;\n        if ($context) for(let d = $context.depth; d >= 0; d--){\n            let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n            if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;\n        }\n        for(let name in this.parser.schema.nodes){\n            let type = this.parser.schema.nodes[name];\n            if (type.isTextblock && type.defaultAttrs) return type;\n        }\n    }\n}\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n    for(let child = dom.firstChild, prevItem = null; child; child = child.nextSibling){\n        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n        if (name && listTags.hasOwnProperty(name) && prevItem) {\n            prevItem.appendChild(child);\n            child = prevItem;\n        } else if (name == \"li\") {\n            prevItem = child;\n        } else if (name) {\n            prevItem = null;\n        }\n    }\n}\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n    let copy = {};\n    for(let prop in obj)copy[prop] = obj[prop];\n    return copy;\n}\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n    let nodes = nodeType.schema.nodes;\n    for(let name in nodes){\n        let parent = nodes[name];\n        if (!parent.allowsMarkType(markType)) continue;\n        let seen = [], scan = (match)=>{\n            seen.push(match);\n            for(let i = 0; i < match.edgeCount; i++){\n                let { type, next } = match.edge(i);\n                if (type == nodeType) return true;\n                if (seen.indexOf(next) < 0 && scan(next)) return true;\n            }\n        };\n        if (scan(parent.contentMatch)) return true;\n    }\n}\n/**\nA DOM serializer knows how to convert ProseMirror nodes and\nmarks of various types to DOM nodes.\n*/ class DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark's content is block or\n    inline content (for typical use, it'll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */ constructor(/**\n    The node serialization functions.\n    */ nodes, /**\n    The mark serialization functions.\n    */ marks){\n        this.nodes = nodes;\n        this.marks = marks;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */ serializeFragment(fragment, options = {}, target) {\n        if (!target) target = doc(options).createDocumentFragment();\n        let top = target, active = [];\n        fragment.forEach((node)=>{\n            if (active.length || node.marks.length) {\n                let keep = 0, rendered = 0;\n                while(keep < active.length && rendered < node.marks.length){\n                    let next = node.marks[rendered];\n                    if (!this.marks[next.type.name]) {\n                        rendered++;\n                        continue;\n                    }\n                    if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;\n                    keep++;\n                    rendered++;\n                }\n                while(keep < active.length)top = active.pop()[1];\n                while(rendered < node.marks.length){\n                    let add = node.marks[rendered++];\n                    let markDOM = this.serializeMark(add, node.isInline, options);\n                    if (markDOM) {\n                        active.push([\n                            add,\n                            top\n                        ]);\n                        top.appendChild(markDOM.dom);\n                        top = markDOM.contentDOM || markDOM.dom;\n                    }\n                }\n            }\n            top.appendChild(this.serializeNodeInner(node, options));\n        });\n        return target;\n    }\n    /**\n    @internal\n    */ serializeNodeInner(node, options) {\n        let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);\n        if (contentDOM) {\n            if (node.isLeaf) throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n            this.serializeFragment(node.content, options, contentDOM);\n        }\n        return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */ serializeNode(node, options = {}) {\n        let dom = this.serializeNodeInner(node, options);\n        for(let i = node.marks.length - 1; i >= 0; i--){\n            let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n            if (wrap) {\n                (wrap.contentDOM || wrap.dom).appendChild(dom);\n                dom = wrap.dom;\n            }\n        }\n        return dom;\n    }\n    /**\n    @internal\n    */ serializeMark(mark, inline, options = {}) {\n        let toDOM = this.marks[mark.type.name];\n        return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n    static renderSpec(doc, structure, xmlNS = null, blockArraysIn) {\n        return renderSpec(doc, structure, xmlNS, blockArraysIn);\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */ static fromSchema(schema) {\n        return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */ static nodesFromSchema(schema) {\n        let result = gatherToDOM(schema.nodes);\n        if (!result.text) result.text = (node)=>node.text;\n        return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */ static marksFromSchema(schema) {\n        return gatherToDOM(schema.marks);\n    }\n}\nfunction gatherToDOM(obj) {\n    let result = {};\n    for(let name in obj){\n        let toDOM = obj[name].spec.toDOM;\n        if (toDOM) result[name] = toDOM;\n    }\n    return result;\n}\nfunction doc(options) {\n    return options.document || window.document;\n}\nconst suspiciousAttributeCache = new WeakMap();\nfunction suspiciousAttributes(attrs) {\n    let value = suspiciousAttributeCache.get(attrs);\n    if (value === undefined) suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n    return value;\n}\nfunction suspiciousAttributesInner(attrs) {\n    let result = null;\n    function scan(value) {\n        if (value && typeof value == \"object\") {\n            if (Array.isArray(value)) {\n                if (typeof value[0] == \"string\") {\n                    if (!result) result = [];\n                    result.push(value);\n                } else {\n                    for(let i = 0; i < value.length; i++)scan(value[i]);\n                }\n            } else {\n                for(let prop in value)scan(value[prop]);\n            }\n        }\n    }\n    scan(attrs);\n    return result;\n}\nfunction renderSpec(doc, structure, xmlNS, blockArraysIn) {\n    if (typeof structure == \"string\") return {\n        dom: doc.createTextNode(structure)\n    };\n    if (structure.nodeType != null) return {\n        dom: structure\n    };\n    if (structure.dom && structure.dom.nodeType != null) return structure;\n    let tagName = structure[0], suspicious;\n    if (typeof tagName != \"string\") throw new RangeError(\"Invalid array passed to renderSpec\");\n    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1) throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n    let space = tagName.indexOf(\" \");\n    if (space > 0) {\n        xmlNS = tagName.slice(0, space);\n        tagName = tagName.slice(space + 1);\n    }\n    let contentDOM;\n    let dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n    let attrs = structure[1], start = 1;\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n        start = 2;\n        for(let name in attrs)if (attrs[name] != null) {\n            let space = name.indexOf(\" \");\n            if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name]);\n            else if (name == \"style\" && dom.style) dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    for(let i = start; i < structure.length; i++){\n        let child = structure[i];\n        if (child === 0) {\n            if (i < structure.length - 1 || i > start) throw new RangeError(\"Content hole must be the only child of its parent node\");\n            return {\n                dom,\n                contentDOM: dom\n            };\n        } else {\n            let { dom: inner, contentDOM: innerContent } = renderSpec(doc, child, xmlNS, blockArraysIn);\n            dom.appendChild(inner);\n            if (innerContent) {\n                if (contentDOM) throw new RangeError(\"Multiple content holes\");\n                contentDOM = innerContent;\n            }\n        }\n    }\n    return {\n        dom,\n        contentDOM\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3ItbW9kZWxAMS4yNS40L25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1tb2RlbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBRXBDLFNBQVNDLGNBQWNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxHQUFHO0lBQzVCLElBQUssSUFBSUMsSUFBSSxJQUFJQSxJQUFLO1FBQ2xCLElBQUlBLEtBQUtILEVBQUVJLFVBQVUsSUFBSUQsS0FBS0YsRUFBRUcsVUFBVSxFQUN0QyxPQUFPSixFQUFFSSxVQUFVLElBQUlILEVBQUVHLFVBQVUsR0FBRyxPQUFPRjtRQUNqRCxJQUFJRyxTQUFTTCxFQUFFTSxLQUFLLENBQUNILElBQUlJLFNBQVNOLEVBQUVLLEtBQUssQ0FBQ0g7UUFDMUMsSUFBSUUsVUFBVUUsUUFBUTtZQUNsQkwsT0FBT0csT0FBT0csUUFBUTtZQUN0QjtRQUNKO1FBQ0EsSUFBSSxDQUFDSCxPQUFPSSxVQUFVLENBQUNGLFNBQ25CLE9BQU9MO1FBQ1gsSUFBSUcsT0FBT0ssTUFBTSxJQUFJTCxPQUFPTSxJQUFJLElBQUlKLE9BQU9JLElBQUksRUFBRTtZQUM3QyxJQUFLLElBQUlDLElBQUksR0FBR1AsT0FBT00sSUFBSSxDQUFDQyxFQUFFLElBQUlMLE9BQU9JLElBQUksQ0FBQ0MsRUFBRSxFQUFFQSxJQUM5Q1Y7WUFDSixPQUFPQTtRQUNYO1FBQ0EsSUFBSUcsT0FBT1EsT0FBTyxDQUFDQyxJQUFJLElBQUlQLE9BQU9NLE9BQU8sQ0FBQ0MsSUFBSSxFQUFFO1lBQzVDLElBQUlDLFFBQVFoQixjQUFjTSxPQUFPUSxPQUFPLEVBQUVOLE9BQU9NLE9BQU8sRUFBRVgsTUFBTTtZQUNoRSxJQUFJYSxTQUFTLE1BQ1QsT0FBT0E7UUFDZjtRQUNBYixPQUFPRyxPQUFPRyxRQUFRO0lBQzFCO0FBQ0o7QUFDQSxTQUFTUSxZQUFZaEIsQ0FBQyxFQUFFQyxDQUFD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QU8sQ0FBQztZQUN6QixJQUFJbVMsUUFBUSxHQUNSekwsSUFBSTRMLGNBQWMsQ0FBQ25jLEtBQUsvRCxLQUFLLENBQUMsR0FBRytmLFFBQVFoYyxLQUFLL0QsS0FBSyxDQUFDK2YsUUFBUSxJQUFJNWMsS0FBSyxDQUFDWSxLQUFLO2lCQUMxRSxJQUFJQSxRQUFRLFdBQVd1USxJQUFJVixLQUFLLEVBQ2pDVSxJQUFJVixLQUFLLENBQUN1TSxPQUFPLEdBQUdoZCxLQUFLLENBQUNZLEtBQUs7aUJBRS9CdVEsSUFBSThMLFlBQVksQ0FBQ3JjLE1BQU1aLEtBQUssQ0FBQ1ksS0FBSztRQUMxQztJQUNSO0lBQ0EsSUFBSyxJQUFJeEcsSUFBSWdDLE9BQU9oQyxJQUFJMmhCLFVBQVVyZ0IsTUFBTSxFQUFFdEIsSUFBSztRQUMzQyxJQUFJRyxRQUFRd2hCLFNBQVMsQ0FBQzNoQixFQUFFO1FBQ3hCLElBQUlHLFVBQVUsR0FBRztZQUNiLElBQUlILElBQUkyaEIsVUFBVXJnQixNQUFNLEdBQUcsS0FBS3RCLElBQUlnQyxPQUNoQyxNQUFNLElBQUltQyxXQUFXO1lBQ3pCLE9BQU87Z0JBQUU0UztnQkFBSzJILFlBQVkzSDtZQUFJO1FBQ2xDLE9BQ0s7WUFDRCxJQUFJLEVBQUVBLEtBQUtuVyxLQUFLLEVBQUU4ZCxZQUFZb0UsWUFBWSxFQUFFLEdBQUd0QixXQUFXaFgsS0FBS3JLLE9BQU95aEIsT0FBT0M7WUFDN0U5SyxJQUFJMEosV0FBVyxDQUFDN2Y7WUFDaEIsSUFBSWtpQixjQUFjO2dCQUNkLElBQUlwRSxZQUNBLE1BQU0sSUFBSXZhLFdBQVc7Z0JBQ3pCdWEsYUFBYW9FO1lBQ2pCO1FBQ0o7SUFDSjtJQUNBLE9BQU87UUFBRS9MO1FBQUsySDtJQUFXO0FBQzdCO0FBRWlKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VudGluZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3ItbW9kZWxAMS4yNS40L25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1tb2RlbC9kaXN0L2luZGV4LmpzPzY5YTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9yZGVyZWRNYXAgZnJvbSAnb3JkZXJlZG1hcCc7XG5cbmZ1bmN0aW9uIGZpbmREaWZmU3RhcnQoYSwgYiwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT0gYS5jaGlsZENvdW50IHx8IGkgPT0gYi5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGEuY2hpbGRDb3VudCA9PSBiLmNoaWxkQ291bnQgPyBudWxsIDogcG9zO1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZChpKSwgY2hpbGRCID0gYi5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGNoaWxkQS50ZXh0W2pdID09IGNoaWxkQi50ZXh0W2pdOyBqKyspXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmU3RhcnQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3MgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgICBmb3IgKGxldCBpQSA9IGEuY2hpbGRDb3VudCwgaUIgPSBiLmNoaWxkQ291bnQ7Oykge1xuICAgICAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGlBID09IGlCID8gbnVsbCA6IHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZCgtLWlBKSwgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSwgc2l6ZSA9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGxldCBzYW1lID0gMCwgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgc2FtZSsrO1xuICAgICAgICAgICAgICAgIHBvc0EtLTtcbiAgICAgICAgICAgICAgICBwb3NCLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuQSBmcmFnbWVudCByZXByZXNlbnRzIGEgbm9kZSdzIGNvbGxlY3Rpb24gb2YgY2hpbGQgbm9kZXMuXG5cbkxpa2Ugbm9kZXMsIGZyYWdtZW50cyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMsIGFuZCB5b3VcbnNob3VsZCBub3QgbXV0YXRlIHRoZW0gb3IgdGhlaXIgY29udGVudC4gUmF0aGVyLCB5b3UgY3JlYXRlIG5ld1xuaW5zdGFuY2VzIHdoZW5ldmVyIG5lZWRlZC4gVGhlIEFQSSB0cmllcyB0byBtYWtlIHRoaXMgZWFzeS5cbiovXG5jbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQsIHNpemUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSB8fCAwO1xuICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSBjb250ZW50W2ldLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvXG4gICAgcG9zaXRpb25zIChyZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzIGZyYWdtZW50KS4gRG9lc24ndCBkZXNjZW5kXG4gICAgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBub2RlU3RhcnQgPSAwLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSAmJiBmKGNoaWxkLCBub2RlU3RhcnQgKyBwb3MsIHBhcmVudCB8fCBudWxsLCBpKSAhPT0gZmFsc2UgJiYgY2hpbGQuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgZnJvbSAtIHN0YXJ0KSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHN0YXJ0KSwgZiwgbm9kZVN0YXJ0ICsgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIGBwb3NgIHdpbGwgYmVcbiAgICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LiBUaGUgY2FsbGJhY2sgbWF5IHJldHVyblxuICAgIGBmYWxzZWAgdG8gcHJldmVudCB0cmF2ZXJzYWwgb2YgYSBnaXZlbiBub2RlJ3MgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHRleHQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFNlZSB0aGUgc2FtZSBtZXRob2Qgb25cbiAgICBbYE5vZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50ZXh0QmV0d2VlbikuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIiwgZmlyc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGVUZXh0ID0gbm9kZS5pc1RleHQgPyBub2RlLnRleHQuc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpXG4gICAgICAgICAgICAgICAgOiAhbm9kZS5pc0xlYWYgPyBcIlwiXG4gICAgICAgICAgICAgICAgICAgIDogbGVhZlRleHQgPyAodHlwZW9mIGxlYWZUZXh0ID09PSBcImZ1bmN0aW9uXCIgPyBsZWFmVGV4dChub2RlKSA6IGxlYWZUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dCA/IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNCbG9jayAmJiAobm9kZS5pc0xlYWYgJiYgbm9kZVRleHQgfHwgbm9kZS5pc1RleHRibG9jaykgJiYgYmxvY2tTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCArPSBub2RlVGV4dDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgY29tYmluZWQgY29udGVudCBvZiB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBvdGhlci5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5sYXN0Q2hpbGQsIGZpcnN0ID0gb3RoZXIuZmlyc3RDaGlsZCwgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpLCBpID0gMDtcbiAgICAgICAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9IGxhc3Qud2l0aFRleHQobGFzdC50ZXh0ICsgZmlyc3QudGV4dCk7XG4gICAgICAgICAgICBpID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG90aGVyLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb250ZW50LnB1c2gob3RoZXIuY29udGVudFtpXSk7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCwgdGhpcy5zaXplICsgb3RoZXIuc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHN1Yi1mcmFnbWVudCBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgY3V0KGZyb20sIHRvID0gdGhpcy5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gfHwgZW5kID4gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIE1hdGgubWluKGNoaWxkLnRleHQubGVuZ3RoLCB0byAtIHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MgLSAxKSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHBvcyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChyZXN1bHQsIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1dEJ5SW5kZXgoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW4gd2hpY2ggdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4IGlzXG4gICAgcmVwbGFjZWQgYnkgdGhlIGdpdmVuIG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlQ2hpbGQoaW5kZXgsIG5vZGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjb3B5ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gICAgICAgIGNvcHlbaW5kZXhdID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb3B5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IHByZXBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9TdGFydChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVdLmNvbmNhdCh0aGlzLmNvbnRlbnQpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IGFwcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb0VuZChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LmNvbmNhdChub2RlKSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBmcmFnbWVudCB0byBhbm90aGVyIG9uZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoICE9IG90aGVyLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2ldLmVxKG90aGVyLmNvbnRlbnRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFswXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbGFzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGluIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRDb3VudCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZSBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcyk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50W2luZGV4XSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuICAgIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbiAgICAqL1xuICAgIGZvckVhY2goZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcCA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgICAgICAgICAgcCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiBhdCB3aGljaCB0aGlzIGZyYWdtZW50IGFuZCBhbm90aGVyXG4gICAgZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmUgdGhlIHNhbWUuXG4gICAgKi9cbiAgICBmaW5kRGlmZlN0YXJ0KG90aGVyLCBwb3MgPSAwKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZlN0YXJ0KHRoaXMsIG90aGVyLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiwgc2VhcmNoaW5nIGZyb20gdGhlIGVuZCwgYXQgd2hpY2ggdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgZ2l2ZW4gZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmVcbiAgICB0aGUgc2FtZS4gU2luY2UgdGhpcyBwb3NpdGlvbiB3aWxsIG5vdCBiZSB0aGUgc2FtZSBpbiBib3RoXG4gICAgbm9kZXMsIGFuIG9iamVjdCB3aXRoIHR3byBzZXBhcmF0ZSBwb3NpdGlvbnMgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBmaW5kRGlmZkVuZChvdGhlciwgcG9zID0gdGhpcy5zaXplLCBvdGhlclBvcyA9IG90aGVyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZXggYW5kIGlubmVyIG9mZnNldCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gcmVsYXRpdmVcbiAgICBwb3NpdGlvbiBpbiB0aGlzIGZyYWdtZW50LiBUaGUgcmVzdWx0IG9iamVjdCB3aWxsIGJlIHJldXNlZFxuICAgIChvdmVyd3JpdHRlbikgdGhlIG5leHQgdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmRJbmRleChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gb3V0c2lkZSBvZiBmcmFnbWVudCAoJHt0aGlzfSlgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJQb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZGVidWdnaW5nIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBcIjxcIiArIHRoaXMudG9TdHJpbmdJbm5lcigpICsgXCI+XCI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nSW5uZXIoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuam9pbihcIiwgXCIpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50Lm1hcChuID0+IG4udG9KU09OKCkpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBmcmFnbWVudCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRnJhZ21lbnQuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodmFsdWUubWFwKHNjaGVtYS5ub2RlRnJvbUpTT04pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBmcmFnbWVudCBmcm9tIGFuIGFycmF5IG9mIG5vZGVzLiBFbnN1cmVzIHRoYXQgYWRqYWNlbnRcbiAgICB0ZXh0IG5vZGVzIHdpdGggdGhlIHNhbWUgbWFya3MgYXJlIGpvaW5lZCB0b2dldGhlci5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgaWYgKCFhcnJheS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGxldCBqb2luZWQsIHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgJiYgbm9kZS5pc1RleHQgJiYgYXJyYXlbaSAtIDFdLnNhbWVNYXJrdXAobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpvaW5lZClcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkID0gYXJyYXkuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXSA9IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLndpdGhUZXh0KGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0udGV4dCArIG5vZGUudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqb2luZWQpIHtcbiAgICAgICAgICAgICAgICBqb2luZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZyYWdtZW50IGZyb20gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGludGVycHJldGVkIGFzIGFcbiAgICBzZXQgb2Ygbm9kZXMuIEZvciBgbnVsbGAsIGl0IHJldHVybnMgdGhlIGVtcHR5IGZyYWdtZW50LiBGb3IgYVxuICAgIGZyYWdtZW50LCB0aGUgZnJhZ21lbnQgaXRzZWxmLiBGb3IgYSBub2RlIG9yIGFycmF5IG9mIG5vZGVzLCBhXG4gICAgZnJhZ21lbnQgY29udGFpbmluZyB0aG9zZSBub2Rlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5vZGVzKSB7XG4gICAgICAgIGlmICghbm9kZXMpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChub2RlcyBpbnN0YW5jZW9mIEZyYWdtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkobm9kZXMpO1xuICAgICAgICBpZiAobm9kZXMuYXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2Rlc10sIG5vZGVzLm5vZGVTaXplKTtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgXCIgKyBub2RlcyArIFwiIHRvIGEgRnJhZ21lbnRcIiArXG4gICAgICAgICAgICAobm9kZXMubm9kZXNCZXR3ZWVuID8gXCIgKGxvb2tzIGxpa2UgbXVsdGlwbGUgdmVyc2lvbnMgb2YgcHJvc2VtaXJyb3ItbW9kZWwgd2VyZSBsb2FkZWQpXCIgOiBcIlwiKSk7XG4gICAgfVxufVxuLyoqXG5BbiBlbXB0eSBmcmFnbWVudC4gSW50ZW5kZWQgdG8gYmUgcmV1c2VkIHdoZW5ldmVyIGEgbm9kZSBkb2Vzbid0XG5jb250YWluIGFueXRoaW5nIChyYXRoZXIgdGhhbiBhbGxvY2F0aW5nIGEgbmV3IGVtcHR5IGZyYWdtZW50IGZvclxuZWFjaCBsZWFmIG5vZGUpLlxuKi9cbkZyYWdtZW50LmVtcHR5ID0gbmV3IEZyYWdtZW50KFtdLCAwKTtcbmNvbnN0IGZvdW5kID0geyBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gICAgZm91bmQuaW5kZXggPSBpbmRleDtcbiAgICBmb3VuZC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlRGVlcChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghKGEgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIikgfHxcbiAgICAgICAgIShiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghY29tcGFyZURlZXAoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBiKSB8fCAhY29tcGFyZURlZXAoYVtwXSwgYltwXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgICAgICBpZiAoIShwIGluIGEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQSBtYXJrIGlzIGEgcGllY2Ugb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlLFxuc3VjaCBhcyBpdCBiZWluZyBlbXBoYXNpemVkLCBpbiBjb2RlIGZvbnQsIG9yIGEgbGluay4gSXQgaGFzIGFcbnR5cGUgYW5kIG9wdGlvbmFsbHkgYSBzZXQgb2YgYXR0cmlidXRlcyB0aGF0IHByb3ZpZGUgZnVydGhlclxuaW5mb3JtYXRpb24gKHN1Y2ggYXMgdGhlIHRhcmdldCBvZiB0aGUgbGluaykuIE1hcmtzIGFyZSBjcmVhdGVkXG50aHJvdWdoIGEgYFNjaGVtYWAsIHdoaWNoIGNvbnRyb2xzIHdoaWNoIHR5cGVzIGV4aXN0IGFuZCB3aGljaFxuYXR0cmlidXRlcyB0aGV5IGhhdmUuXG4qL1xuY2xhc3MgTWFyayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXJrLlxuICAgICovXG4gICAgYXR0cnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHNldCBvZiBtYXJrcywgY3JlYXRlIGEgbmV3IHNldCB3aGljaCBjb250YWlucyB0aGlzIG9uZSBhc1xuICAgIHdlbGwsIGluIHRoZSByaWdodCBwb3NpdGlvbi4gSWYgdGhpcyBtYXJrIGlzIGFscmVhZHkgaW4gdGhlIHNldCxcbiAgICB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC4gSWYgYW55IG1hcmtzIHRoYXQgYXJlIHNldCB0byBiZVxuICAgIFtleGNsdXNpdmVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgd2l0aCB0aGlzIG1hcmsgYXJlIHByZXNlbnQsXG4gICAgdGhvc2UgYXJlIHJlcGxhY2VkIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBjb3B5LCBwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IHNldFtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5leGNsdWRlcyhvdGhlci50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyLnR5cGUuZXhjbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBsYWNlZCAmJiBvdGhlci50eXBlLnJhbmsgPiB0aGlzLnR5cGUucmFuaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnB1c2gob3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoKTtcbiAgICAgICAgaWYgKCFwbGFjZWQpXG4gICAgICAgICAgICBjb3B5LnB1c2godGhpcyk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgdGhpcyBtYXJrIGZyb20gdGhlIGdpdmVuIHNldCwgcmV0dXJuaW5nIGEgbmV3IHNldC4gSWYgdGhpc1xuICAgIG1hcmsgaXMgbm90IGluIHRoZSBzZXQsIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGlzIGluIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBoYXMgdGhlIHNhbWUgdHlwZSBhbmQgYXR0cmlidXRlcyBhc1xuICAgIGFub3RoZXIgbWFyay5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAodGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgY29tcGFyZURlZXAodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIG1hcmsgdG8gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIEpTT04uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTWFyay5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEubWFya3NbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSAke2pzb24udHlwZX0gaW4gdGhpcyBzY2hlbWFgKTtcbiAgICAgICAgbGV0IG1hcmsgPSB0eXBlLmNyZWF0ZShqc29uLmF0dHJzKTtcbiAgICAgICAgdHlwZS5jaGVja0F0dHJzKG1hcmsuYXR0cnMpO1xuICAgICAgICByZXR1cm4gbWFyaztcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBzZXRzIG9mIG1hcmtzIGFyZSBpZGVudGljYWwuXG4gICAgKi9cbiAgICBzdGF0aWMgc2FtZVNldChhLCBiKSB7XG4gICAgICAgIGlmIChhID09IGIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcHJvcGVybHkgc29ydGVkIG1hcmsgc2V0IGZyb20gbnVsbCwgYSBzaW5nbGUgbWFyaywgb3IgYW5cbiAgICB1bnNvcnRlZCBhcnJheSBvZiBtYXJrcy5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXRGcm9tKG1hcmtzKSB7XG4gICAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKVxuICAgICAgICAgICAgcmV0dXJuIFttYXJrc107XG4gICAgICAgIGxldCBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5zb3J0KChhLCBiKSA9PiBhLnR5cGUucmFuayAtIGIudHlwZS5yYW5rKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIG1hcmtzLlxuKi9cbk1hcmsubm9uZSA9IFtdO1xuXG4vKipcbkVycm9yIHR5cGUgcmFpc2VkIGJ5IFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2hlblxuZ2l2ZW4gYW4gaW52YWxpZCByZXBsYWNlbWVudC5cbiovXG5jbGFzcyBSZXBsYWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKlxuUmVwbGFjZUVycm9yID0gZnVuY3Rpb24odGhpczogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSlcbiAgOyhlcnIgYXMgYW55KS5fX3Byb3RvX18gPSBSZXBsYWNlRXJyb3IucHJvdG90eXBlXG4gIHJldHVybiBlcnJcbn0gYXMgYW55XG5cblJlcGxhY2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblJlcGxhY2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlRXJyb3JcblJlcGxhY2VFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiUmVwbGFjZUVycm9yXCJcbiovXG4vKipcbkEgc2xpY2UgcmVwcmVzZW50cyBhIHBpZWNlIGN1dCBvdXQgb2YgYSBsYXJnZXIgZG9jdW1lbnQuIEl0XG5zdG9yZXMgbm90IG9ubHkgYSBmcmFnbWVudCwgYnV0IGFsc28gdGhlIGRlcHRoIHVwIHRvIHdoaWNoIG5vZGVzIG9uXG5ib3RoIHNpZGUgYXJlIOKAmG9wZW7igJkgKGN1dCB0aHJvdWdoKS5cbiovXG5jbGFzcyBTbGljZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UuIFdoZW4gc3BlY2lmeWluZyBhIG5vbi16ZXJvIG9wZW4gZGVwdGgsIHlvdSBtdXN0XG4gICAgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vZGVzIG9mIGF0IGxlYXN0IHRoYXQgZGVwdGggYXQgdGhlXG4gICAgYXBwcm9wcmlhdGUgc2lkZSBvZiB0aGUgZnJhZ21lbnTigJRpLmUuIGlmIHRoZSBmcmFnbWVudCBpcyBhblxuICAgIGVtcHR5IHBhcmFncmFwaCBub2RlLCBgb3BlblN0YXJ0YCBhbmQgYG9wZW5FbmRgIGNhbid0IGJlIGdyZWF0ZXJcbiAgICB0aGFuIDEuXG4gICAgXG4gICAgSXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlIGNvbnRlbnQgb2Ygb3BlbiBub2RlcyB0byBjb25mb3JtIHRvXG4gICAgdGhlIHNjaGVtYSdzIGNvbnRlbnQgY29uc3RyYWludHMsIHRob3VnaCBpdCBzaG91bGQgYmUgYSB2YWxpZFxuICAgIHN0YXJ0L2VuZC9taWRkbGUgZm9yIHN1Y2ggYSBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZXMgYXJlXG4gICAgb3Blbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgb3BlblN0YXJ0LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgb3BlbkVuZCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gb3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgdGhpcyBzbGljZSB3b3VsZCBhZGQgd2hlbiBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0QXQocG9zLCBmcmFnbWVudCkge1xuICAgICAgICBsZXQgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhpcyBzbGljZSBpcyBlcXVhbCB0byBhbm90aGVyIHNsaWNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIHNsaWNlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSB7IGNvbnRlbnQ6IHRoaXMuY29udGVudC50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgICAgaWYgKHRoaXMub3BlbkVuZCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHNsaWNlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVuU3RhcnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb3BlbkVuZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlIGZyb20gYSBmcmFnbWVudCBieSB0YWtpbmcgdGhlIG1heGltdW0gcG9zc2libGVcbiAgICBvcGVuIHZhbHVlIG9uIGJvdGggc2lkZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF4T3BlbihmcmFnbWVudCwgb3Blbklzb2xhdGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50Lmxhc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmxhc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShmcmFnbWVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzbGljZS5cbiovXG5TbGljZS5lbXB0eSA9IG5ldyBTbGljZShGcmFnbWVudC5lbXB0eSwgMCwgMCk7XG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGZyb20pLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgbGV0IHsgaW5kZXg6IGluZGV4VG8sIG9mZnNldDogb2Zmc2V0VG8gfSA9IGNvbnRlbnQuZmluZEluZGV4KHRvKTtcbiAgICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPSBpbmRleFRvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShyZW1vdmVSYW5nZShjaGlsZC5jb250ZW50LCBmcm9tIC0gb2Zmc2V0IC0gMSwgdG8gLSBvZmZzZXQgLSAxKSkpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW50byhjb250ZW50LCBkaXN0LCBpbnNlcnQsIHBhcmVudCkge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGRpc3QpLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgaWYgKG9mZnNldCA9PSBkaXN0IHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGRpc3QpLmFwcGVuZChpbnNlcnQpLmFwcGVuZChjb250ZW50LmN1dChkaXN0KSk7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IGluc2VydEludG8oY2hpbGQuY29udGVudCwgZGlzdCAtIG9mZnNldCAtIDEsIGluc2VydCwgY2hpbGQpO1xuICAgIHJldHVybiBpbm5lciAmJiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIGlmIChzbGljZS5vcGVuU3RhcnQgPiAkZnJvbS5kZXB0aClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluc2VydGVkIGNvbnRlbnQgZGVlcGVyIHRoYW4gaW5zZXJ0aW9uIHBvc2l0aW9uXCIpO1xuICAgIGlmICgkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCAhPSAkdG8uZGVwdGggLSBzbGljZS5vcGVuRW5kKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5jb25zaXN0ZW50IG9wZW4gZGVwdGhzXCIpO1xuICAgIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApO1xufVxuZnVuY3Rpb24gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCkge1xuICAgIGxldCBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSAkdG8uaW5kZXgoZGVwdGgpICYmIGRlcHRoIDwgJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgbGV0IGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgICAgICByZXR1cm4gbm9kZS5jb3B5KG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGlubmVyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5kZXB0aCA9PSBkZXB0aCAmJiAkdG8uZGVwdGggPT0gZGVwdGgpIHsgLy8gU2ltcGxlLCBmbGF0IGNhc2VcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLnBhcmVudCwgY29udGVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICByZXR1cm4gY2xvc2UocGFyZW50LCBjb250ZW50LmN1dCgwLCAkZnJvbS5wYXJlbnRPZmZzZXQpLmFwcGVuZChzbGljZS5jb250ZW50KS5hcHBlbmQoY29udGVudC5jdXQoJHRvLnBhcmVudE9mZnNldCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRmcm9tKTtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgc3RhcnQsIGVuZCwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgICBpZiAoIXN1Yi50eXBlLmNvbXBhdGlibGVDb250ZW50KG1haW4udHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJDYW5ub3Qgam9pbiBcIiArIHN1Yi50eXBlLm5hbWUgKyBcIiBvbnRvIFwiICsgbWFpbi50eXBlLm5hbWUpO1xufVxuZnVuY3Rpb24gam9pbmFibGUoJGJlZm9yZSwgJGFmdGVyLCBkZXB0aCkge1xuICAgIGxldCBub2RlID0gJGJlZm9yZS5ub2RlKGRlcHRoKTtcbiAgICBjaGVja0pvaW4obm9kZSwgJGFmdGVyLm5vZGUoZGVwdGgpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFkZE5vZGUoY2hpbGQsIHRhcmdldCkge1xuICAgIGxldCBsYXN0ID0gdGFyZ2V0Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBjaGlsZC5pc1RleHQgJiYgY2hpbGQuc2FtZU1hcmt1cCh0YXJnZXRbbGFzdF0pKVxuICAgICAgICB0YXJnZXRbbGFzdF0gPSBjaGlsZC53aXRoVGV4dCh0YXJnZXRbbGFzdF0udGV4dCArIGNoaWxkLnRleHQpO1xuICAgIGVsc2VcbiAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gICAgbGV0IG5vZGUgPSAoJGVuZCB8fCAkc3RhcnQpLm5vZGUoZGVwdGgpO1xuICAgIGxldCBzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSAkZW5kID8gJGVuZC5pbmRleChkZXB0aCkgOiBub2RlLmNoaWxkQ291bnQ7XG4gICAgaWYgKCRzdGFydCkge1xuICAgICAgICBzdGFydEluZGV4ID0gJHN0YXJ0LmluZGV4KGRlcHRoKTtcbiAgICAgICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJHN0YXJ0LnRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGFkZE5vZGUoJHN0YXJ0Lm5vZGVBZnRlciwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTtcbiAgICBpZiAoJGVuZCAmJiAkZW5kLmRlcHRoID09IGRlcHRoICYmICRlbmQudGV4dE9mZnNldClcbiAgICAgICAgYWRkTm9kZSgkZW5kLm5vZGVCZWZvcmUsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBjbG9zZShub2RlLCBjb250ZW50KSB7XG4gICAgbm9kZS50eXBlLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGgpIHtcbiAgICBsZXQgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpO1xuICAgIGxldCBvcGVuRW5kID0gJHRvLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGVuZCwgJHRvLCBkZXB0aCArIDEpO1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgJHN0YXJ0LmluZGV4KGRlcHRoKSA9PSAkZW5kLmluZGV4KGRlcHRoKSkge1xuICAgICAgICBjaGVja0pvaW4ob3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcGVuU3RhcnQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgICAgIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgICAgICBpZiAob3BlbkVuZClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBqb2luYWJsZSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKHR5cGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGFsb25nKSB7XG4gICAgbGV0IGV4dHJhID0gJGFsb25nLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0LCBwYXJlbnQgPSAkYWxvbmcubm9kZShleHRyYSk7XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuY29weShzbGljZS5jb250ZW50KTtcbiAgICBmb3IgKGxldCBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUoc2xpY2Uub3BlblN0YXJ0ICsgZXh0cmEpLFxuICAgICAgICBlbmQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUobm9kZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kIC0gZXh0cmEpIH07XG59XG5cbi8qKlxuWW91IGNhbiBbX3Jlc29sdmVfXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXNvbHZlKSBhIHBvc2l0aW9uIHRvIGdldCBtb3JlXG5pbmZvcm1hdGlvbiBhYm91dCBpdC4gT2JqZWN0cyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBzdWNoIGFcbnJlc29sdmVkIHBvc2l0aW9uLCBwcm92aWRpbmcgdmFyaW91cyBwaWVjZXMgb2YgY29udGV4dFxuaW5mb3JtYXRpb24sIGFuZCBzb21lIGhlbHBlciBtZXRob2RzLlxuXG5UaHJvdWdob3V0IHRoaXMgaW50ZXJmYWNlLCBtZXRob2RzIHRoYXQgdGFrZSBhbiBvcHRpb25hbCBgZGVwdGhgXG5wYXJhbWV0ZXIgd2lsbCBpbnRlcnByZXQgdW5kZWZpbmVkIGFzIGB0aGlzLmRlcHRoYCBhbmQgbmVnYXRpdmVcbm51bWJlcnMgYXMgYHRoaXMuZGVwdGggKyB2YWx1ZWAuXG4qL1xuY2xhc3MgUmVzb2x2ZWRQb3Mge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIHRoYXQgd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhdGgsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgdGhpcyBwb3NpdGlvbiBoYXMgaW50byBpdHMgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBwYXJlbnRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucGFyZW50T2Zmc2V0ID0gcGFyZW50T2Zmc2V0O1xuICAgICAgICB0aGlzLmRlcHRoID0gcGF0aC5sZW5ndGggLyAzIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlRGVwdGgodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgICAgICBpZiAodmFsIDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoICsgdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcGFyZW50IG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gcG9pbnRzIGludG8uIE5vdGUgdGhhdCBldmVuIGlmXG4gICAgYSBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhhdCBub2RlIGlzIG5vdCBjb25zaWRlcmVkXG4gICAgdGhlIHBhcmVudOKAlHRleHQgbm9kZXMgYXJlIOKAmGZsYXTigJkgaW4gdGhpcyBtb2RlbCwgYW5kIGhhdmUgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgcm9vdCBub2RlIGluIHdoaWNoIHRoZSBwb3NpdGlvbiB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBnZXQgZG9jKCkgeyByZXR1cm4gdGhpcy5ub2RlKDApOyB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2VzdG9yIG5vZGUgYXQgdGhlIGdpdmVuIGxldmVsLiBgcC5ub2RlKHAuZGVwdGgpYCBpcyB0aGVcbiAgICBzYW1lIGFzIGBwLnBhcmVudGAuXG4gICAgKi9cbiAgICBub2RlKGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogM107IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlIGdpdmVuIGxldmVsLiBJZiB0aGlzIHBvaW50c1xuICAgIGF0IHRoZSAzcmQgbm9kZSBpbiB0aGUgMm5kIHBhcmFncmFwaCBvbiB0aGUgdG9wIGxldmVsLCBmb3JcbiAgICBleGFtcGxlLCBgcC5pbmRleCgwKWAgaXMgMSBhbmQgYHAuaW5kZXgoMSlgIGlzIDIuXG4gICAgKi9cbiAgICBpbmRleChkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDMgKyAxXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBwb2ludGluZyBhZnRlciB0aGlzIHBvc2l0aW9uIGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLlxuICAgICovXG4gICAgaW5kZXhBZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoZGVwdGgpICsgKGRlcHRoID09IHRoaXMuZGVwdGggJiYgIXRoaXMudGV4dE9mZnNldCA/IDAgOiAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgc3RhcnQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBlbmQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGRlcHRoKSArIHRoaXMubm9kZShkZXB0aCkuY29udGVudC5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBiZWZvcmUgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yLCB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYCwgdGhlIG9yaWdpbmFsXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBiZWZvcmUoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGJlZm9yZSB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLlxuICAgICovXG4gICAgYWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGFmdGVyIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyB0aGlzLnBhdGhbZGVwdGggKiAzXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGlzIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGlzIHJldHVybnMgdGhlXG4gICAgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gYW5kIHRoZSBzdGFydCBvZiB0aGUgdGV4dCBub2RlLlxuICAgIFdpbGwgYmUgemVybyBmb3IgcG9zaXRpb25zIHRoYXQgcG9pbnQgYmV0d2VlbiBub2Rlcy5cbiAgICAqL1xuICAgIGdldCB0ZXh0T2Zmc2V0KCkgeyByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGUgcG9zaXRpb25cbiAgICBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGUgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUFmdGVyKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdLCBjaGlsZCA9IHBhcmVudC5jaGlsZChpbmRleCk7XG4gICAgICAgIHJldHVybiBkT2ZmID8gcGFyZW50LmNoaWxkKGluZGV4KS5jdXQoZE9mZikgOiBjaGlsZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGJlZm9yZSB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlXG4gICAgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlXG4gICAgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQmVmb3JlKCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXgpLmN1dCgwLCBkT2ZmKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09IDAgPyBudWxsIDogdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIHBhcmVudCBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGRlcHRoICh3aGljaCBkZWZhdWx0cyB0byBgdGhpcy5kZXB0aGApLlxuICAgICovXG4gICAgcG9zQXRJbmRleChpbmRleCwgZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sIHBvcyA9IGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICAgICAgcG9zICs9IG5vZGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYXQgdGhpcyBwb3NpdGlvbiwgZmFjdG9yaW5nIGluIHRoZSBzdXJyb3VuZGluZ1xuICAgIG1hcmtzJyBbYGluY2x1c2l2ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5pbmNsdXNpdmUpIHByb3BlcnR5LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBpcyBhdCB0aGUgc3RhcnQgb2YgYSBub24tZW1wdHkgbm9kZSwgdGhlIG1hcmtzIG9mIHRoZVxuICAgIG5vZGUgYWZ0ZXIgaXQgKGlmIGFueSkgYXJlIHJldHVybmVkLlxuICAgICovXG4gICAgbWFya3MoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICAgIC8vIEluIGFuIGVtcHR5IHBhcmVudCwgcmV0dXJuIHRoZSBlbXB0eSBhcnJheVxuICAgICAgICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgLy8gV2hlbiBpbnNpZGUgYSB0ZXh0IG5vZGUsIGp1c3QgcmV0dXJuIHRoZSB0ZXh0IG5vZGUncyBtYXJrc1xuICAgICAgICBpZiAodGhpcy50ZXh0T2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3M7XG4gICAgICAgIGxldCBtYWluID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXggLSAxKSwgb3RoZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIC8vIElmIHRoZSBgYWZ0ZXJgIGZsYWcgaXMgdHJ1ZSBvZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSwgbWFrZVxuICAgICAgICAvLyB0aGUgbm9kZSBhZnRlciB0aGlzIHBvc2l0aW9uIHRoZSBtYWluIHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgICAgICBsZXQgdG1wID0gbWFpbjtcbiAgICAgICAgICAgIG1haW4gPSBvdGhlcjtcbiAgICAgICAgICAgIG90aGVyID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhbGwgbWFya3MgaW4gdGhlIG1haW4gbm9kZSwgZXhjZXB0IHRob3NlIHRoYXQgaGF2ZVxuICAgICAgICAvLyBgaW5jbHVzaXZlYCBzZXQgdG8gZmFsc2UgYW5kIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgb3RoZXIgbm9kZS5cbiAgICAgICAgbGV0IG1hcmtzID0gbWFpbi5tYXJrcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW90aGVyIHx8ICFtYXJrc1tpXS5pc0luU2V0KG90aGVyLm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGlmIGFueSwgZXhjZXB0IHRob3NlXG4gICAgdGhhdCBhcmUgbm9uLWluY2x1c2l2ZSBhbmQgbm90IHByZXNlbnQgYXQgcG9zaXRpb24gYCRlbmRgLiBUaGlzXG4gICAgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgc2V0IG9mIG1hcmtzIHRvIHByZXNlcnZlIGFmdGVyIGFcbiAgICBkZWxldGlvbi4gV2lsbCByZXR1cm4gYG51bGxgIGlmIHRoaXMgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZSBvciBpdHMgcGFyZW50IG5vZGUgaXNuJ3QgYSB0ZXh0YmxvY2sgKGluIHdoaWNoXG4gICAgY2FzZSBubyBtYXJrcyBzaG91bGQgYmUgcHJlc2VydmVkKS5cbiAgICAqL1xuICAgIG1hcmtzQWNyb3NzKCRlbmQpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5wYXJlbnQubWF5YmVDaGlsZCh0aGlzLmluZGV4KCkpO1xuICAgICAgICBpZiAoIWFmdGVyIHx8ICFhZnRlci5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbWFya3MgPSBhZnRlci5tYXJrcywgbmV4dCA9ICRlbmQucGFyZW50Lm1heWJlQ2hpbGQoJGVuZC5pbmRleCgpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW5leHQgfHwgIW1hcmtzW2ldLmlzSW5TZXQobmV4dC5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVwdGggdXAgdG8gd2hpY2ggdGhpcyBwb3NpdGlvbiBhbmQgdGhlIGdpdmVuIChub24tcmVzb2x2ZWQpXG4gICAgcG9zaXRpb24gc2hhcmUgdGhlIHNhbWUgcGFyZW50IG5vZGVzLlxuICAgICovXG4gICAgc2hhcmVkRGVwdGgocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aC0tKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnQoZGVwdGgpIDw9IHBvcyAmJiB0aGlzLmVuZChkZXB0aCkgPj0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSByYW5nZSBiYXNlZCBvbiB0aGUgcGxhY2Ugd2hlcmUgdGhpcyBwb3NpdGlvbiBhbmQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24gZGl2ZXJnZSBhcm91bmQgYmxvY2sgY29udGVudC4gSWYgYm90aCBwb2ludCBpbnRvXG4gICAgdGhlIHNhbWUgdGV4dGJsb2NrLCBmb3IgZXhhbXBsZSwgYSByYW5nZSBhcm91bmQgdGhhdCB0ZXh0YmxvY2tcbiAgICB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGV5IHBvaW50IGludG8gZGlmZmVyZW50IGJsb2NrcywgdGhlIHJhbmdlXG4gICAgYXJvdW5kIHRob3NlIGJsb2NrcyBpbiB0aGVpciBzaGFyZWQgYW5jZXN0b3IgaXMgcmV0dXJuZWQuIFlvdSBjYW5cbiAgICBwYXNzIGluIGFuIG9wdGlvbmFsIHByZWRpY2F0ZSB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJlbnRcbiAgICBub2RlIHRvIHNlZSBpZiBhIHJhbmdlIGludG8gdGhhdCBwYXJlbnQgaXMgYWNjZXB0YWJsZS5cbiAgICAqL1xuICAgIGJsb2NrUmFuZ2Uob3RoZXIgPSB0aGlzLCBwcmVkKSB7XG4gICAgICAgIGlmIChvdGhlci5wb3MgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5ibG9ja1JhbmdlKHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBkID0gdGhpcy5kZXB0aCAtICh0aGlzLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHRoaXMucG9zID09IG90aGVyLnBvcyA/IDEgOiAwKTsgZCA+PSAwOyBkLS0pXG4gICAgICAgICAgICBpZiAob3RoZXIucG9zIDw9IHRoaXMuZW5kKGQpICYmICghcHJlZCB8fCBwcmVkKHRoaXMubm9kZShkKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVJhbmdlKHRoaXMsIG90aGVyLCBkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIHNoYXJlcyB0aGUgc2FtZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHNhbWVQYXJlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXJlbnRPZmZzZXQgPT0gb3RoZXIucG9zIC0gb3RoZXIucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWF4KG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPiB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBzbWFsbGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zIDwgdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmRlcHRoOyBpKyspXG4gICAgICAgICAgICBzdHIgKz0gKHN0ciA/IFwiL1wiIDogXCJcIikgKyB0aGlzLm5vZGUoaSkudHlwZS5uYW1lICsgXCJfXCIgKyB0aGlzLmluZGV4KGkgLSAxKTtcbiAgICAgICAgcmV0dXJuIHN0ciArIFwiOlwiICsgdGhpcy5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmUoZG9jLCBwb3MpIHtcbiAgICAgICAgaWYgKCEocG9zID49IDAgJiYgcG9zIDw9IGRvYy5jb250ZW50LnNpemUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMCwgcGFyZW50T2Zmc2V0ID0gcG9zO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gZG9jOzspIHtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCByZW0gPSBwYXJlbnRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSwgaW5kZXgsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghcmVtKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gcmVtIC0gMTtcbiAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFBvcyhwb3MsIHBhdGgsIHBhcmVudE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmVDYWNoZWQoZG9jLCBwb3MpIHtcbiAgICAgICAgbGV0IGNhY2hlID0gcmVzb2x2ZUNhY2hlLmdldChkb2MpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FjaGUuZWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBlbHQgPSBjYWNoZS5lbHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbHQucG9zID09IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVDYWNoZS5zZXQoZG9jLCBjYWNoZSA9IG5ldyBSZXNvbHZlQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBjYWNoZS5lbHRzW2NhY2hlLmldID0gUmVzb2x2ZWRQb3MucmVzb2x2ZShkb2MsIHBvcyk7XG4gICAgICAgIGNhY2hlLmkgPSAoY2FjaGUuaSArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5jbGFzcyBSZXNvbHZlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVsdHMgPSBbXTtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICB9XG59XG5jb25zdCByZXNvbHZlQ2FjaGVTaXplID0gMTIsIHJlc29sdmVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcblJlcHJlc2VudHMgYSBmbGF0IHJhbmdlIG9mIGNvbnRlbnQsIGkuZS4gb25lIHRoYXQgc3RhcnRzIGFuZFxuZW5kcyBpbiB0aGUgc2FtZSBub2RlLlxuKi9cbmNsYXNzIE5vZGVSYW5nZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbm9kZSByYW5nZS4gYCRmcm9tYCBhbmQgYCR0b2Agc2hvdWxkIHBvaW50IGludG8gdGhlXG4gICAgc2FtZSBub2RlIHVudGlsIGF0IGxlYXN0IHRoZSBnaXZlbiBgZGVwdGhgLCBzaW5jZSBhIG5vZGUgcmFuZ2VcbiAgICBkZW5vdGVzIGFuIGFkamFjZW50IHNldCBvZiBub2RlcyBpbiBhIHNpbmdsZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEEgcmVzb2x2ZWQgcG9zaXRpb24gYWxvbmcgdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50LiBNYXkgaGF2ZSBhXG4gICAgYGRlcHRoYCBncmVhdGVyIHRoYW4gdGhpcyBvYmplY3QncyBgZGVwdGhgIHByb3BlcnR5LCBzaW5jZVxuICAgIHRoZXNlIGFyZSB0aGUgcG9zaXRpb25zIHRoYXQgd2VyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIHJhbmdlLFxuICAgIG5vdCByZS1yZXNvbHZlZCBwb3NpdGlvbnMgZGlyZWN0bHkgYXQgaXRzIGJvdW5kYXJpZXMuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgQSBwb3NpdGlvbiBhbG9uZyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LiBTZWVcbiAgICBjYXZlYXQgZm9yIFtgJGZyb21gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlLiRmcm9tKS5cbiAgICAqL1xuICAgICR0bywgXG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRoYXQgdGhpcyByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGRlcHRoKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLmJlZm9yZSh0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy4kdG8uYWZ0ZXIodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0SW5kZXgoKSB7IHJldHVybiB0aGlzLiRmcm9tLmluZGV4KHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IGVuZEluZGV4KCkgeyByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTsgfVxufVxuXG5jb25zdCBlbXB0eUF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgdHJlZSB0aGF0IG1ha2VzIHVwIGFcblByb3NlTWlycm9yIGRvY3VtZW50LiBTbyBhIGRvY3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGBOb2RlYCwgd2l0aFxuY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBpbnN0YW5jZXMgb2YgYE5vZGVgLlxuXG5Ob2RlcyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMuIEluc3RlYWQgb2YgY2hhbmdpbmcgdGhlbSwgeW91XG5jcmVhdGUgbmV3IG9uZXMgd2l0aCB0aGUgY29udGVudCB5b3Ugd2FudC4gT2xkIG9uZXMga2VlcCBwb2ludGluZ1xuYXQgdGhlIG9sZCBkb2N1bWVudCBzaGFwZS4gVGhpcyBpcyBtYWRlIGNoZWFwZXIgYnkgc2hhcmluZ1xuc3RydWN0dXJlIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3IGRhdGEgYXMgbXVjaCBhcyBwb3NzaWJsZSwgd2hpY2ggYVxudHJlZSBzaGFwZSBsaWtlIHRoaXMgKHdpdGhvdXQgYmFjayBwb2ludGVycykgbWFrZXMgZWFzeS5cblxuKipEbyBub3QqKiBkaXJlY3RseSBtdXRhdGUgdGhlIHByb3BlcnRpZXMgb2YgYSBgTm9kZWAgb2JqZWN0LiBTZWVcblt0aGUgZ3VpZGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2RvYykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBub2RlIHRoYXQgdGhpcyBpcy5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIEFuIG9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMuIFRoZSBraW5kIG9mXG4gICAgYXR0cmlidXRlcyBhbGxvd2VkIGFuZCByZXF1aXJlZCBhcmVcbiAgICBbZGV0ZXJtaW5lZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0dHJzKSBieSB0aGUgbm9kZSB0eXBlLlxuICAgICovXG4gICAgYXR0cnMsIFxuICAgIC8vIEEgZnJhZ21lbnQgaG9sZGluZyB0aGUgbm9kZSdzIGNoaWxkcmVuLlxuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrcyAodGhpbmdzIGxpa2Ugd2hldGhlciBpdCBpcyBlbXBoYXNpemVkIG9yIHBhcnQgb2YgYVxuICAgIGxpbmspIGFwcGxpZWQgdG8gdGhpcyBub2RlLlxuICAgICovXG4gICAgbWFya3MgPSBNYXJrLm5vbmUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgRnJhZ21lbnQuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhcnJheSBvZiB0aGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jb250ZW50OyB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuICAgIHNjaGVtZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZG9jLmluZGV4aW5nKS4gRm9yIHRleHQgbm9kZXMsIHRoaXMgaXMgdGhlXG4gICAgYW1vdW50IG9mIGNoYXJhY3RlcnMuIEZvciBvdGhlciBsZWFmIG5vZGVzLCBpdCBpcyBvbmUuIEZvclxuICAgIG5vbi1sZWFmIG5vZGVzLCBpdCBpcyB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBwbHVzIHR3byAodGhlXG4gICAgc3RhcnQgYW5kIGVuZCB0b2tlbikuXG4gICAgKi9cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLmlzTGVhZiA/IDEgOiAyICsgdGhpcy5jb250ZW50LnNpemU7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgdGhlIG5vZGUgaGFzLlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGRDb3VudDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlcyBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHsgdGhpcy5jb250ZW50LmZvckVhY2goZik7IH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgcmVjdXJzaXZlbHkgYmV0d2VlblxuICAgIHRoZSBnaXZlbiB0d28gcG9zaXRpb25zIHRoYXQgYXJlIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXNcbiAgICBub2RlJ3MgY29udGVudC4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWQgd2l0aCB0aGUgbm9kZSwgaXRzXG4gICAgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIG5vZGUgKG1ldGhvZCByZWNlaXZlciksXG4gICAgaXRzIHBhcmVudCBub2RlLCBhbmQgaXRzIGNoaWxkIGluZGV4LiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgZmFsc2UgZm9yIGEgZ2l2ZW4gbm9kZSwgdGhhdCBub2RlJ3MgY2hpbGRyZW4gd2lsbCBub3QgYmVcbiAgICByZWN1cnNlZCBvdmVyLiBUaGUgbGFzdCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhXG4gICAgc3RhcnRpbmcgcG9zaXRpb24gdG8gY291bnQgZnJvbS5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MgPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gRG9lc24ndFxuICAgIGRlc2NlbmQgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmNhdGVuYXRlcyBhbGwgdGhlIHRleHQgbm9kZXMgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBhbmQgaXRzXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0xlYWYgJiYgdGhpcy50eXBlLnNwZWMubGVhZlRleHQpXG4gICAgICAgICAgICA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMudGV4dEJldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYWxsIHRleHQgYmV0d2VlbiBwb3NpdGlvbnMgYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYGJsb2NrU2VwYXJhdG9yYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBpbnNlcnRlZCB0byBzZXBhcmF0ZSB0ZXh0XG4gICAgZnJvbSBkaWZmZXJlbnQgYmxvY2sgbm9kZXMuIElmIGBsZWFmVGV4dGAgaXMgZ2l2ZW4sIGl0J2xsIGJlXG4gICAgaW5zZXJ0ZWQgZm9yIGV2ZXJ5IG5vbi10ZXh0IGxlYWYgbm9kZSBlbmNvdW50ZXJlZCwgb3RoZXJ3aXNlXG4gICAgW2BsZWFmVGV4dGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5sZWFmVGV4dCkgd2lsbCBiZSB1c2VkLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5maXJzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gbm9kZXMgcmVwcmVzZW50IHRoZSBzYW1lIHBpZWNlIG9mIGRvY3VtZW50LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgKHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgbWFya3VwICh0eXBlLCBhdHRyaWJ1dGVzLCBhbmQgbWFya3MpIG9mIHRoaXMgbm9kZSB0b1xuICAgIHRob3NlIG9mIGFub3RoZXIuIFJldHVybnMgYHRydWVgIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBtYXJrdXAuXG4gICAgKi9cbiAgICBzYW1lTWFya3VwKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSdzIG1hcmt1cCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiB0eXBlLFxuICAgIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcy5cbiAgICAqL1xuICAgIGhhc01hcmt1cCh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmXG4gICAgICAgICAgICBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJlxuICAgICAgICAgICAgTWFyay5zYW1lU2V0KHRoaXMubWFya3MsIG1hcmtzIHx8IE1hcmsubm9uZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHdpdGggdGhlIHNhbWUgbWFya3VwIGFzIHRoaXMgbm9kZSwgY29udGFpbmluZ1xuICAgIHRoZSBnaXZlbiBjb250ZW50IChvciBlbXB0eSwgaWYgbm8gY29udGVudCBpcyBnaXZlbikuXG4gICAgKi9cbiAgICBjb3B5KGNvbnRlbnQgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUsIHdpdGggdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBpbnN0ZWFkXG4gICAgb2YgdGhlIG5vZGUncyBvd24gbWFya3MuXG4gICAgKi9cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy5jb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlIHdpdGggb25seSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9ucy4gSWYgYHRvYCBpcyBub3QgZ2l2ZW4sIGl0IGRlZmF1bHRzIHRvIHRoZSBlbmQgb2ZcbiAgICB0aGUgbm9kZS5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmNvbnRlbnQuY3V0KGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucywgYW5kXG4gICAgcmV0dXJuIGl0IGFzIGEgYFNsaWNlYCBvYmplY3QuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplLCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICAgIGxldCBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucyB3aXRoXG4gICAgdGhlIGdpdmVuIHNsaWNlLiBUaGUgc2xpY2UgbXVzdCAnZml0JywgbWVhbmluZyBpdHMgb3BlbiBzaWRlc1xuICAgIG11c3QgYmUgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LCBhbmQgaXRzXG4gICAgY29udGVudCBub2RlcyBtdXN0IGJlIHZhbGlkIGNoaWxkcmVuIGZvciB0aGUgbm9kZSB0aGV5IGFyZSBwbGFjZWRcbiAgICBpbnRvLiBJZiBhbnkgb2YgdGhpcyBpcyB2aW9sYXRlZCwgYW4gZXJyb3Igb2YgdHlwZVxuICAgIFtgUmVwbGFjZUVycm9yYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlcGxhY2VFcnJvcikgaXMgdGhyb3duLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBiZWZvcmUgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBudWxsLCBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgaW5kZXg6IGluZGV4IC0gMSwgb2Zmc2V0OiBvZmZzZXQgLSBub2RlLm5vZGVTaXplIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc29sdmUgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcmV0dXJuaW5nIGFuXG4gICAgW29iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlc29sdmVkUG9zKSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGl0cyBjb250ZXh0LlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmVDYWNoZWQodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU5vQ2FjaGUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBtYXJrIG9yIG1hcmsgdHlwZSBvY2N1cnMgaW4gdGhpcyBkb2N1bWVudFxuICAgIGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICByYW5nZUhhc01hcmsoZnJvbSwgdG8sIHR5cGUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGJsb2NrIChub24taW5saW5lIG5vZGUpXG4gICAgKi9cbiAgICBnZXQgaXNCbG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0YmxvY2sgbm9kZSwgYSBibG9jayBub2RlIHdpdGggaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHRibG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgYWxsb3dzIGlubGluZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7IHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGlubGluZSBub2RlIChhIHRleHQgbm9kZSBvciBhIG5vZGUgdGhhdCBjYW5cbiAgICBhcHBlYXIgYW1vbmcgdGV4dCkuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc1RleHQoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzTGVhZjsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlIGRpcmVjdGx5XG4gICAgZWRpdGFibGUgY29udGVudC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGBpc0xlYWZgLCBidXQgY2FuXG4gICAgYmUgY29uZmlndXJlZCB3aXRoIHRoZSBbYGF0b21gIHByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXRvbSlcbiAgICBvbiBhIG5vZGUncyBzcGVjICh0eXBpY2FsbHkgdXNlZCB3aGVuIHRoZSBub2RlIGlzIGRpc3BsYXllZCBhc1xuICAgIGFuIHVuZWRpdGFibGUgW25vZGUgdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpKS5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLnR5cGUuaXNBdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBmb3IgZGVidWdnaW5nXG4gICAgcHVycG9zZXMuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG1hdGNoIGluIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgKi9cbiAgICBjb250ZW50TWF0Y2hBdChpbmRleCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIChieVxuICAgIGNoaWxkIGluZGV4KSB3aXRoIHRoZSBnaXZlbiByZXBsYWNlbWVudCBmcmFnbWVudCAod2hpY2ggZGVmYXVsdHNcbiAgICB0byB0aGUgZW1wdHkgZnJhZ21lbnQpIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC4gWW91XG4gICAgY2FuIG9wdGlvbmFsbHkgcGFzcyBgc3RhcnRgIGFuZCBgZW5kYCBpbmRpY2VzIGludG8gdGhlXG4gICAgcmVwbGFjZW1lbnQgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlKGZyb20sIHRvLCByZXBsYWNlbWVudCA9IEZyYWdtZW50LmVtcHR5LCBzdGFydCA9IDAsIGVuZCA9IHJlcGxhY2VtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGxldCB0d28gPSBvbmUgJiYgb25lLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIGlmICghdHdvIHx8ICF0d28udmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuYWxsb3dzTWFya3MocmVwbGFjZW1lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGBmcm9tYCB0byBgdG9gIChieSBpbmRleCkgd2l0aFxuICAgIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlV2l0aChmcm9tLCB0bywgdHlwZSwgbWFya3MpIHtcbiAgICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICYmIHN0YXJ0Lm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBub2RlJ3MgY29udGVudCBjb3VsZCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gICAgbm9kZS4gSWYgdGhhdCBub2RlIGlzIGVtcHR5LCB0aGlzIHdpbGwgb25seSByZXR1cm4gdHJ1ZSBpZiB0aGVyZVxuICAgIGlzIGF0IGxlYXN0IG9uZSBub2RlIHR5cGUgdGhhdCBjYW4gYXBwZWFyIGluIGJvdGggbm9kZXMgKHRvIGF2b2lkXG4gICAgbWVyZ2luZyBjb21wbGV0ZWx5IGluY29tcGF0aWJsZSBub2RlcykuXG4gICAgKi9cbiAgICBjYW5BcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhblJlcGxhY2UodGhpcy5jaGlsZENvdW50LCB0aGlzLmNoaWxkQ291bnQsIG90aGVyLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGNvbmZvcm0gdG8gdGhlXG4gICAgc2NoZW1hLCBhbmQgcmFpc2UgYW4gZXhjZXB0aW9uIHdoZW4gdGhleSBkbyBub3QuXG4gICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLnR5cGUuY2hlY2tBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmsgPSB0aGlzLm1hcmtzW2ldO1xuICAgICAgICAgICAgbWFyay50eXBlLmNoZWNrQXR0cnMobWFyay5hdHRycyk7XG4gICAgICAgICAgICBjb3B5ID0gbWFyay5hZGRUb1NldChjb3B5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU1hcmsuc2FtZVNldChjb3B5LCB0aGlzLm1hcmtzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbGxlY3Rpb24gb2YgbWFya3MgZm9yIG5vZGUgJHt0aGlzLnR5cGUubmFtZX06ICR7dGhpcy5tYXJrcy5tYXAobSA9PiBtLnR5cGUubmFtZSl9YCk7XG4gICAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jaGVjaygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aClcbiAgICAgICAgICAgIG9iai5tYXJrcyA9IHRoaXMubWFya3MubWFwKG4gPT4gbi50b0pTT04oKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCBtYXJrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGpzb24ubWFya3MpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbWFyayBkYXRhIGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICAgICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24udGV4dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KTtcbiAgICAgICAgbGV0IG5vZGUgPSBzY2hlbWEubm9kZVR5cGUoanNvbi50eXBlKS5jcmVhdGUoanNvbi5hdHRycywgY29udGVudCwgbWFya3MpO1xuICAgICAgICBub2RlLnR5cGUuY2hlY2tBdHRycyhub2RlLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufVxuTm9kZS5wcm90b3R5cGUudGV4dCA9IHVuZGVmaW5lZDtcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHsgcmV0dXJuIHRoaXMudGV4dDsgfVxuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pOyB9XG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICAgIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gdGhpcy50ZXh0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgY3V0KGZyb20gPSAwLCB0byA9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgYmFzZSA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBiYXNlLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBzdHIgPSBtYXJrc1tpXS50eXBlLm5hbWUgKyBcIihcIiArIHN0ciArIFwiKVwiO1xuICAgIHJldHVybiBzdHI7XG59XG5cbi8qKlxuSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgbWF0Y2ggc3RhdGUgb2YgYSBub2RlIHR5cGUnc1xuW2NvbnRlbnQgZXhwcmVzc2lvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvbnRlbnQpLCBhbmQgY2FuIGJlIHVzZWQgdG9cbmZpbmQgb3V0IHdoZXRoZXIgZnVydGhlciBjb250ZW50IG1hdGNoZXMgaGVyZSwgYW5kIHdoZXRoZXIgYSBnaXZlblxucG9zaXRpb24gaXMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4qL1xuY2xhc3MgQ29udGVudE1hdGNoIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG1hdGNoIHN0YXRlIHJlcHJlc2VudHMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4gICAgKi9cbiAgICB2YWxpZEVuZCkge1xuICAgICAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uoc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTtcbiAgICAgICAgbGV0IG1hdGNoID0gZGZhKG5mYShleHByKSk7XG4gICAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggYSBub2RlIHR5cGUsIHJldHVybmluZyBhIG1hdGNoIGFmdGVyIHRoYXQgbm9kZSBpZlxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaFR5cGUodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRbaV0ubmV4dDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCBhIGZyYWdtZW50LiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgbWF0Y2ggd2hlblxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaEZyYWdtZW50KGZyYWcsIHN0YXJ0ID0gMCwgZW5kID0gZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBjdXIgPSBjdXIubWF0Y2hUeXBlKGZyYWcuY2hpbGQoaSkudHlwZSk7XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoICE9IDAgJiYgdGhpcy5uZXh0WzBdLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSB0eXBlIGF0IHRoaXMgbWF0Y2ggcG9zaXRpb24gdGhhdCBjYW5cbiAgICBiZSBnZW5lcmF0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdFR5cGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSB0aGlzLm5leHRbaV07XG4gICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGF0aWJsZShvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggdGhlIGdpdmVuIGZyYWdtZW50LCBhbmQgaWYgdGhhdCBmYWlscywgc2VlIGlmIGl0IGNhblxuICAgIGJlIG1hZGUgdG8gbWF0Y2ggYnkgaW5zZXJ0aW5nIG5vZGVzIGluIGZyb250IG9mIGl0LiBXaGVuXG4gICAgc3VjY2Vzc2Z1bCwgcmV0dXJuIGEgZnJhZ21lbnQgb2YgaW5zZXJ0ZWQgbm9kZXMgKHdoaWNoIG1heSBiZVxuICAgIGVtcHR5IGlmIG5vdGhpbmcgaGFkIHRvIGJlIGluc2VydGVkKS4gV2hlbiBgdG9FbmRgIGlzIHRydWUsIG9ubHlcbiAgICByZXR1cm4gYSBmcmFnbWVudCBpZiB0aGUgcmVzdWx0aW5nIG1hdGNoIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBmaWxsQmVmb3JlKGFmdGVyLCB0b0VuZCA9IGZhbHNlLCBzdGFydEluZGV4ID0gMCkge1xuICAgICAgICBsZXQgc2VlbiA9IFt0aGlzXTtcbiAgICAgICAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQgJiYgKCF0b0VuZCB8fCBmaW5pc2hlZC52YWxpZEVuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKHRwID0+IHRwLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgJiYgc2Vlbi5pbmRleE9mKG5leHQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gc2VhcmNoKG5leHQsIHR5cGVzLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHNldCBvZiB3cmFwcGluZyBub2RlIHR5cGVzIHRoYXQgd291bGQgYWxsb3cgYSBub2RlIG9mIHRoZVxuICAgIGdpdmVuIHR5cGUgdG8gYXBwZWFyIGF0IHRoaXMgcG9zaXRpb24uIFRoZSByZXN1bHQgbWF5IGJlIGVtcHR5XG4gICAgKHdoZW4gaXQgZml0cyBkaXJlY3RseSkgYW5kIHdpbGwgYmUgbnVsbCB3aGVuIG5vIHN1Y2ggd3JhcHBpbmdcbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBmaW5kV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwQ2FjaGVbaV0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICAgIGxldCBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVdyYXBwaW5nKHRhcmdldCk7XG4gICAgICAgIHRoaXMud3JhcENhY2hlLnB1c2godGFyZ2V0LCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGxldCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYWN0aXZlID0gW3sgbWF0Y2g6IHRoaXMsIHR5cGU6IG51bGwsIHZpYTogbnVsbCB9XTtcbiAgICAgICAgd2hpbGUgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksIG1hdGNoID0gY3VycmVudC5tYXRjaDtcbiAgICAgICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvYmogPSBjdXJyZW50OyBvYmoudHlwZTsgb2JqID0gb2JqLnZpYSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqLnR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh7IG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCwgdHlwZSwgdmlhOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyB0aGlzIG5vZGUgaGFzIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGdldCBlZGdlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIF9uX+KAi3RoIG91dGdvaW5nIGVkZ2UgZnJvbSB0aGlzIG5vZGUgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZWRnZShuKSB7XG4gICAgICAgIGlmIChuID49IHRoaXMubmV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUncyBubyAke259dGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2NhbihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlZW4ubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ID0gaSArIChtLnZhbGlkRW5kID8gXCIqXCIgOiBcIiBcIikgKyBcIiBcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIG91dCArPSAoaSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcbmNsYXNzIFRva2VuU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXTsgfVxuICAgIGVhdCh0b2spIHsgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7IH1cbiAgICBlcnIoc3RyKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcihzdHIgKyBcIiAoaW4gY29udGVudCBleHByZXNzaW9uICdcIiArIHRoaXMuc3RyaW5nICsgXCInKVwiKTsgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLm5leHQgJiYgc3RyZWFtLm5leHQgIT0gXCIpXCIgJiYgc3RyZWFtLm5leHQgIT0gXCJ8XCIpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcInNlcVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkge1xuICAgIGxldCBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJwbHVzXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInN0YXJcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwib3B0XCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpXG4gICAgICAgICAgICBleHByID0gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gcGFyc2VOdW0oc3RyZWFtKSB7XG4gICAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgbGV0IHJlc3VsdCA9IE51bWJlcihzdHJlYW0ubmV4dCk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgICBsZXQgbWluID0gcGFyc2VOdW0oc3RyZWFtKSwgbWF4ID0gbWluO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpXG4gICAgICAgICAgICBtYXggPSBwYXJzZU51bShzdHJlYW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXggPSAtMTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSlcbiAgICAgICAgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcInJhbmdlXCIsIG1pbiwgbWF4LCBleHByIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgICBsZXQgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiBbdHlwZV07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgICAgICBpZiAodHlwZS5pc0luR3JvdXAobmFtZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMClcbiAgICAgICAgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIpXCIpKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk1pc3NpbmcgY2xvc2luZyBwYXJlblwiKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEvXFxXLy50ZXN0KHN0cmVhbS5uZXh0KSkge1xuICAgICAgICBsZXQgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5pbmxpbmUgPSB0eXBlLmlzSW5saW5lO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmlubGluZSAhPSB0eXBlLmlzSW5saW5lKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ucG9zKys7XG4gICAgICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgfVxufVxuLy8gQ29uc3RydWN0IGFuIE5GQSBmcm9tIGFuIGV4cHJlc3Npb24gYXMgcmV0dXJuZWQgYnkgdGhlIHBhcnNlci4gVGhlXG4vLyBORkEgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGVzLCB3aGljaCBhcmUgdGhlbXNlbHZlc1xuLy8gYXJyYXlzIG9mIGVkZ2VzLCB3aGljaCBhcmUgYHt0ZXJtLCB0b31gIG9iamVjdHMuIFRoZSBmaXJzdCBzdGF0ZSBpc1xuLy8gdGhlIGVudHJ5IHN0YXRlIGFuZCB0aGUgbGFzdCBub2RlIGlzIHRoZSBzdWNjZXNzIHN0YXRlLlxuLy9cbi8vIE5vdGUgdGhhdCB1bmxpa2UgdHlwaWNhbCBORkFzLCB0aGUgZWRnZSBvcmRlcmluZyBpbiB0aGlzIG9uZSBpc1xuLy8gc2lnbmlmaWNhbnQsIGluIHRoYXQgaXQgaXMgdXNlZCB0byBjb250cnVjdCBmaWxsZXIgY29udGVudCB3aGVuXG4vLyBuZWNlc3NhcnkuXG5mdW5jdGlvbiBuZmEoZXhwcikge1xuICAgIGxldCBuZmEgPSBbW11dO1xuICAgIGNvbm5lY3QoY29tcGlsZShleHByLCAwKSwgbm9kZSgpKTtcbiAgICByZXR1cm4gbmZhO1xuICAgIGZ1bmN0aW9uIG5vZGUoKSB7IHJldHVybiBuZmEucHVzaChbXSkgLSAxOyB9XG4gICAgZnVuY3Rpb24gZWRnZShmcm9tLCB0bywgdGVybSkge1xuICAgICAgICBsZXQgZWRnZSA9IHsgdGVybSwgdG8gfTtcbiAgICAgICAgbmZhW2Zyb21dLnB1c2goZWRnZSk7XG4gICAgICAgIHJldHVybiBlZGdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25uZWN0KGVkZ2VzLCB0bykge1xuICAgICAgICBlZGdlcy5mb3JFYWNoKGVkZ2UgPT4gZWRnZS50byA9IHRvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGlsZShleHByLCBmcm9tKSB7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT0gXCJjaG9pY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHIuZXhwcnMucmVkdWNlKChvdXQsIGV4cHIpID0+IG91dC5jb25jYXQoY29tcGlsZShleHByLCBmcm9tKSksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzZXFcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvbXBpbGUoZXhwci5leHByc1tpXSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICBjb25uZWN0KG5leHQsIGZyb20gPSBub2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJwbHVzXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwci5taW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5tYXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGV4cHIubWluOyBpIDwgZXhwci5tYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZShjdXIsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoY3VyKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSwgdW5kZWZpbmVkLCBleHByLnZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV4cHIgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcChhLCBiKSB7IHJldHVybiBiIC0gYTsgfVxuLy8gR2V0IHRoZSBzZXQgb2Ygbm9kZXMgcmVhY2hhYmxlIGJ5IG51bGwgZWRnZXMgZnJvbSBgbm9kZWAuIE9taXRcbi8vIG5vZGVzIHdpdGggb25seSBhIHNpbmdsZSBudWxsLW91dC1lZGdlLCBzaW5jZSB0aGV5IG1heSBsZWFkIHRvXG4vLyBuZWVkbGVzcyBkdXBsaWNhdGVkIG5vZGVzLlxuZnVuY3Rpb24gbnVsbEZyb20obmZhLCBub2RlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIHNjYW4obm9kZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCk7XG4gICAgZnVuY3Rpb24gc2Nhbihub2RlKSB7XG4gICAgICAgIGxldCBlZGdlcyA9IG5mYVtub2RlXTtcbiAgICAgICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIHNjYW4oZWRnZXNbMF0udG8pO1xuICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdGVybSwgdG8gfSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBzY2FuKHRvKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIENvbXBpbGVzIGFuIE5GQSBhcyBwcm9kdWNlZCBieSBgbmZhYCBpbnRvIGEgREZBLCBtb2RlbGVkIGFzIGEgc2V0XG4vLyBvZiBzdGF0ZSBvYmplY3RzIChgQ29udGVudE1hdGNoYCBpbnN0YW5jZXMpIHdpdGggdHJhbnNpdGlvbnNcbi8vIGJldHdlZW4gdGhlbS5cbmZ1bmN0aW9uIGRmYShuZmEpIHtcbiAgICBsZXQgbGFiZWxlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSk7XG4gICAgZnVuY3Rpb24gZXhwbG9yZShzdGF0ZXMpIHtcbiAgICAgICAgbGV0IG91dCA9IFtdO1xuICAgICAgICBzdGF0ZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIG5mYVtub2RlXS5mb3JFYWNoKCh7IHRlcm0sIHRvIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlcm0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0W2ldWzBdID09IHRlcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgPSBvdXRbaV1bMV07XG4gICAgICAgICAgICAgICAgbnVsbEZyb20obmZhLCB0bykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChbdGVybSwgc2V0ID0gW11dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldC5pbmRleE9mKG5vZGUpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBzdGF0ZSA9IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSA9IG5ldyBDb250ZW50TWF0Y2goc3RhdGVzLmluZGV4T2YobmZhLmxlbmd0aCAtIDEpID4gLTEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXRlcyA9IG91dFtpXVsxXS5zb3J0KGNtcCk7XG4gICAgICAgICAgICBzdGF0ZS5uZXh0LnB1c2goeyB0eXBlOiBvdXRbaV1bMF0sIG5leHQ6IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSB8fCBleHBsb3JlKHN0YXRlcykgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCB3b3JrID0gW21hdGNoXTsgaSA8IHdvcmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXRlID0gd29ya1tpXSwgZGVhZCA9ICFzdGF0ZS52YWxpZEVuZCwgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5uZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBzdGF0ZS5uZXh0W2pdO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0eXBlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlYWQgJiYgISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgZGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHdvcmsuaW5kZXhPZihuZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICB3b3JrLnB1c2gobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlYWQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiT25seSBub24tZ2VuZXJhdGFibGUgbm9kZXMgKFwiICsgbm9kZXMuam9pbihcIiwgXCIpICsgXCIpIGluIGEgcmVxdWlyZWQgcG9zaXRpb24gKHNlZSBodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNnZW5lcmF0YWJsZSlcIik7XG4gICAgfVxufVxuXG4vLyBGb3Igbm9kZSB0eXBlcyB3aGVyZSBhbGwgYXR0cnMgaGF2ZSBhIGRlZmF1bHQgdmFsdWUgKG9yIHdoaWNoIGRvbid0XG4vLyBoYXZlIGFueSBhdHRyaWJ1dGVzKSwgYnVpbGQgdXAgYSBzaW5nbGUgcmV1c2FibGUgZGVmYXVsdCBhdHRyaWJ1dGVcbi8vIG9iamVjdCwgYW5kIHVzZSBpdCBmb3IgYWxsIG5vZGVzIHRoYXQgZG9uJ3Qgc3BlY2lmeSBzcGVjaWZpY1xuLy8gYXR0cmlidXRlcy5cbmZ1bmN0aW9uIGRlZmF1bHRBdHRycyhhdHRycykge1xuICAgIGxldCBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIGlmICghYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlZmF1bHRzW2F0dHJOYW1lXSA9IGF0dHIuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUF0dHJzKGF0dHJzLCB2YWx1ZSkge1xuICAgIGxldCBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgZ2l2ZW4gPSB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYgKGdpdmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICBpZiAoYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgICAgIGdpdmVuID0gYXR0ci5kZWZhdWx0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gdmFsdWUgc3VwcGxpZWQgZm9yIGF0dHJpYnV0ZSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWx0W25hbWVdID0gZ2l2ZW47XG4gICAgfVxuICAgIHJldHVybiBidWlsdDtcbn1cbmZ1bmN0aW9uIGNoZWNrQXR0cnMoYXR0cnMsIHZhbHVlcywgdHlwZSwgbmFtZSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gdmFsdWVzKVxuICAgICAgICBpZiAoIShuYW1lIGluIGF0dHJzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgJHtuYW1lfSBmb3IgJHt0eXBlfSBvZiB0eXBlICR7bmFtZX1gKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICAgIGlmIChhdHRyLnZhbGlkYXRlKVxuICAgICAgICAgICAgYXR0ci52YWxpZGF0ZSh2YWx1ZXNbbmFtZV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRBdHRycyh0eXBlTmFtZSwgYXR0cnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBuZXcgQXR0cmlidXRlKHR5cGVOYW1lLCBuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuTm9kZSB0eXBlcyBhcmUgb2JqZWN0cyBhbGxvY2F0ZWQgb25jZSBwZXIgYFNjaGVtYWAgYW5kIHVzZWQgdG9cblt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnR5cGUpIGBOb2RlYCBpbnN0YW5jZXMuIFRoZXkgY29udGFpbiBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIG5vZGUgdHlwZSwgc3VjaCBhcyBpdHMgbmFtZSBhbmQgd2hhdCBraW5kIG9mIG5vZGUgaXRcbnJlcHJlc2VudHMuXG4qL1xuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgdGhlIG5vZGUgdHlwZSBoYXMgaW4gdGhpcyBzY2hlbWEuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBIGxpbmsgYmFjayB0byB0aGUgYFNjaGVtYWAgdGhlIG5vZGUgdHlwZSBiZWxvbmdzIHRvLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyB0aGF0IHRoaXMgdHlwZSBpcyBiYXNlZCBvblxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzZXQgb2YgbWFya3MgYWxsb3dlZCBpbiB0aGlzIG5vZGUuIGBudWxsYCBtZWFucyBhbGwgbWFya3NcbiAgICAgICAgYXJlIGFsbG93ZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya1NldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMobmFtZSwgc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCbG9jayA9ICEoc3BlYy5pbmxpbmUgfHwgbmFtZSA9PSBcInRleHRcIik7XG4gICAgICAgIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGFuIGlubGluZSB0eXBlLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gIXRoaXMuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhIHRleHRibG9jayB0eXBlLCBhIGJsb2NrIHRoYXQgY29udGFpbnMgaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIGZvciBub2RlIHR5cGVzIHRoYXQgYWxsb3cgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlXG4gICAgZGlyZWN0bHkgZWRpdGFibGUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRydWUgd2hlbiB0aGlzIG5vZGUgdHlwZSBpcyBwYXJ0IG9mIHRoZSBnaXZlblxuICAgIFtncm91cF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmdyb3VwKS5cbiAgICAqL1xuICAgIGlzSW5Hcm91cChncm91cCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5vZGUgdHlwZSdzIFt3aGl0ZXNwYWNlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMud2hpdGVzcGFjZSkgb3B0aW9uLlxuICAgICovXG4gICAgZ2V0IHdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMud2hpdGVzcGFjZSB8fCAodGhpcy5zcGVjLmNvZGUgPyBcInByZVwiIDogXCJub3JtYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgbm9kZSB0eXBlIGhhcyBhbnkgcmVxdWlyZWQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIGhhc1JlcXVpcmVkQXR0cnMoKSB7XG4gICAgICAgIGZvciAobGV0IG4gaW4gdGhpcy5hdHRycylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIGFsbG93cyBzb21lIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXNcbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlLlxuICAgICovXG4gICAgY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb250ZW50TWF0Y2guY29tcGF0aWJsZShvdGhlci5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYE5vZGVgIG9mIHRoaXMgdHlwZS4gVGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlXG4gICAgY2hlY2tlZCBhbmQgZGVmYXVsdGVkICh5b3UgY2FuIHBhc3MgYG51bGxgIHRvIHVzZSB0aGUgdHlwZSdzXG4gICAgZGVmYXVsdHMgZW50aXJlbHksIGlmIG5vIHJlcXVpcmVkIGF0dHJpYnV0ZXMgZXhpc3QpLiBgY29udGVudGBcbiAgICBtYXkgYmUgYSBgRnJhZ21lbnRgLCBhIG5vZGUsIGFuIGFycmF5IG9mIG5vZGVzLCBvclxuICAgIGBudWxsYC4gU2ltaWxhcmx5IGBtYXJrc2AgbWF5IGJlIGBudWxsYCB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuICAgIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgRnJhZ21lbnQuZnJvbShjb250ZW50KSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IGNoZWNrIHRoZSBnaXZlbiBjb250ZW50XG4gICAgYWdhaW5zdCB0aGUgbm9kZSB0eXBlJ3MgY29udGVudCByZXN0cmljdGlvbnMsIGFuZCB0aHJvdyBhbiBlcnJvclxuICAgIGlmIGl0IGRvZXNuJ3QgbWF0Y2guXG4gICAgKi9cbiAgICBjcmVhdGVDaGVja2VkKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIHRoaXMuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBjb250ZW50LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgc2VlIGlmIGl0IGlzXG4gICAgbmVjZXNzYXJ5IHRvIGFkZCBub2RlcyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBnaXZlbiBmcmFnbWVudFxuICAgIHRvIG1ha2UgaXQgZml0IHRoZSBub2RlLiBJZiBubyBmaXR0aW5nIHdyYXBwaW5nIGNhbiBiZSBmb3VuZCxcbiAgICByZXR1cm4gbnVsbC4gTm90ZSB0aGF0LCBkdWUgdG8gdGhlIGZhY3QgdGhhdCByZXF1aXJlZCBub2RlcyBjYW5cbiAgICBhbHdheXMgYmUgY3JlYXRlZCwgdGhpcyB3aWxsIGFsd2F5cyBzdWNjZWVkIGlmIHlvdSBwYXNzIG51bGwgb3JcbiAgICBgRnJhZ21lbnQuZW1wdHlgIGFzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjcmVhdGVBbmRGaWxsKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgYXR0cnMgPSB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyk7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoZWQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaGVkICYmIG1hdGNoZWQuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIHZhbGlkIGNvbnRlbnQgZm9yIHRoaXMgbm9kZVxuICAgIHR5cGUuXG4gICAgKi9cbiAgICB2YWxpZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrcyhjb250ZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyBub3QgdmFsaWQgY29udGVudCBmb3IgdGhpc1xuICAgIG5vZGUgdHlwZS5cbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZENvbnRlbnQoY29udGVudCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb250ZW50IGZvciBub2RlICR7dGhpcy5uYW1lfTogJHtjb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApfWApO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgY2hlY2tBdHRycyh0aGlzLmF0dHJzLCBhdHRycywgXCJub2RlXCIsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmsgdHlwZSBpcyBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtTZXQgPT0gbnVsbCB8fCB0aGlzLm1hcmtTZXQuaW5kZXhPZihtYXJrVHlwZSkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgYXJlIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgbWFya3MgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBub2RlIGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGFsbG93ZWRNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5ub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG5vZGVzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgbGV0IHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICAgIGlmICghcmVzdWx0W3RvcFR5cGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKHR5cGVOYW1lLCBhdHRyTmFtZSwgdHlwZSkge1xuICAgIGxldCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpO1xuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgbGV0IG5hbWUgPSB2YWx1ZSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHZhbHVlO1xuICAgICAgICBpZiAodHlwZXMuaW5kZXhPZihuYW1lKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSAke3R5cGVzfSBmb3IgYXR0cmlidXRlICR7YXR0ck5hbWV9IG9uIHR5cGUgJHt0eXBlTmFtZX0sIGdvdCAke25hbWV9YCk7XG4gICAgfTtcbn1cbi8vIEF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuY2xhc3MgQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdHlwZW9mIG9wdGlvbnMudmFsaWRhdGUgPT0gXCJzdHJpbmdcIiA/IHZhbGlkYXRlVHlwZSh0eXBlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMudmFsaWRhdGUpIDogb3B0aW9ucy52YWxpZGF0ZTtcbiAgICB9XG4gICAgZ2V0IGlzUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5oYXNEZWZhdWx0O1xuICAgIH1cbn1cbi8vIE1hcmtzXG4vKipcbkxpa2Ugbm9kZXMsIG1hcmtzICh3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIG5vZGVzIHRvIHNpZ25pZnlcbnRoaW5ncyBsaWtlIGVtcGhhc2lzIG9yIGJlaW5nIHBhcnQgb2YgYSBsaW5rKSBhcmVcblt0YWdnZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrLnR5cGUpIHdpdGggdHlwZSBvYmplY3RzLCB3aGljaCBhcmVcbmluc3RhbnRpYXRlZCBvbmNlIHBlciBgU2NoZW1hYC5cbiovXG5jbGFzcyBNYXJrVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbWFyayB0eXBlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5rLCBcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIHRoYXQgdGhpcyBtYXJrIHR5cGUgaW5zdGFuY2UgaXMgcGFydCBvZi5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgb24gd2hpY2ggdGhlIHR5cGUgaXMgYmFzZWQuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKG5hbWUsIHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICAgICAgbGV0IGRlZmF1bHRzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gZGVmYXVsdHMgPyBuZXcgTWFyayh0aGlzLCBkZWZhdWx0cykgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIG9mIHRoaXMgdHlwZS4gYGF0dHJzYCBtYXkgYmUgYG51bGxgIG9yIGFuIG9iamVjdFxuICAgIGNvbnRhaW5pbmcgb25seSBzb21lIG9mIHRoZSBtYXJrJ3MgYXR0cmlidXRlcy4gVGhlIG90aGVycywgaWZcbiAgICB0aGV5IGhhdmUgZGVmYXVsdHMsIHdpbGwgYmUgYWRkZWQuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmsodGhpcywgY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobWFya3MsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmFuayA9IDA7XG4gICAgICAgIG1hcmtzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBNYXJrVHlwZShuYW1lLCByYW5rKyssIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldCwgYSBuZXcgc2V0XG4gICAgd2l0aG91dCBpdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgc2V0IGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0F0dHJzKGF0dHJzKSB7XG4gICAgICAgIGNoZWNrQXR0cnModGhpcy5hdHRycywgYXR0cnMsIFwibWFya1wiLCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyaWVzIHdoZXRoZXIgYSBnaXZlbiBtYXJrIHR5cGUgaXNcbiAgICBbZXhjbHVkZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBleGNsdWRlcyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbn1cbi8qKlxuQSBkb2N1bWVudCBzY2hlbWEuIEhvbGRzIFtub2RlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUpIGFuZCBbbWFya1xudHlwZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtUeXBlKSBvYmplY3RzIGZvciB0aGUgbm9kZXMgYW5kIG1hcmtzIHRoYXQgbWF5XG5vY2N1ciBpbiBjb25mb3JtaW5nIGRvY3VtZW50cywgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG5jcmVhdGluZyBhbmQgZGVzZXJpYWxpemluZyBzdWNoIGRvY3VtZW50cy5cblxuV2hlbiBnaXZlbiwgdGhlIHR5cGUgcGFyYW1ldGVycyBwcm92aWRlIHRoZSBuYW1lcyBvZiB0aGUgbm9kZXMgYW5kXG5tYXJrcyBpbiB0aGlzIHNjaGVtYS5cbiovXG5jbGFzcyBTY2hlbWEge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHNjaGVtYSBmcm9tIGEgc2NoZW1hIFtzcGVjaWZpY2F0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2NoZW1hU3BlYykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgW2xpbmVicmVha1xuICAgICAgICByZXBsYWNlbWVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmxpbmVicmVha1JlcGxhY2VtZW50KSBub2RlIGRlZmluZWRcbiAgICAgICAgaW4gdGhpcyBzY2hlbWEsIGlmIGFueS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lYnJlYWtSZXBsYWNlbWVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBBbiBvYmplY3QgZm9yIHN0b3Jpbmcgd2hhdGV2ZXIgdmFsdWVzIG1vZHVsZXMgbWF5IHdhbnQgdG9cbiAgICAgICAgY29tcHV0ZSBhbmQgY2FjaGUgcGVyIHNjaGVtYS4gKElmIHlvdSB3YW50IHRvIHN0b3JlIHNvbWV0aGluZ1xuICAgICAgICBpbiBpdCwgdHJ5IHRvIHVzZSBwcm9wZXJ0eSBuYW1lcyB1bmxpa2VseSB0byBjbGFzaC4pXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGluc3RhbmNlU3BlYyA9IHRoaXMuc3BlYyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgICAgICBpbnN0YW5jZVNwZWMubm9kZXMgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5ub2RlcyksXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWMubWFya3MgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5tYXJrcyB8fCB7fSksXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFya1R5cGUuY29tcGlsZSh0aGlzLnNwZWMubWFya3MsIHRoaXMpO1xuICAgICAgICBsZXQgY29udGVudEV4cHJDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5tYXJrcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzW3Byb3BdLCBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsIG1hcmtFeHByID0gdHlwZS5zcGVjLm1hcmtzO1xuICAgICAgICAgICAgdHlwZS5jb250ZW50TWF0Y2ggPSBjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSB8fFxuICAgICAgICAgICAgICAgIChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgICAgICAgIGlmICh0eXBlLnNwZWMubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lYnJlYWtSZXBsYWNlbWVudClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBsaW5lYnJlYWsgbm9kZXMgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNJbmxpbmUgfHwgIXR5cGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkxpbmVicmVhayByZXBsYWNlbWVudCBub2RlcyBtdXN0IGJlIGlubGluZSBsZWFmIG5vZGVzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICBtYXJrRXhwciA/IGdhdGhlck1hcmtzKHRoaXMsIG1hcmtFeHByLnNwbGl0KFwiIFwiKSkgOlxuICAgICAgICAgICAgICAgICAgICBtYXJrRXhwciA9PSBcIlwiIHx8ICF0eXBlLmlubGluZUNvbnRlbnQgPyBbXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubWFya3NbcHJvcF0sIGV4Y2wgPSB0eXBlLnNwZWMuZXhjbHVkZXM7XG4gICAgICAgICAgICB0eXBlLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW3R5cGVdIDogZXhjbCA9PSBcIlwiID8gW10gOiBnYXRoZXJNYXJrcyh0aGlzLCBleGNsLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlRnJvbUpTT04gPSBqc29uID0+IE5vZGUuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgICAgIHRoaXMubWFya0Zyb21KU09OID0ganNvbiA9PiBNYXJrLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgICAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICAgICAgdGhpcy5jYWNoZWQud3JhcHBpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBpbiB0aGlzIHNjaGVtYS4gVGhlIGB0eXBlYCBtYXkgYmUgYSBzdHJpbmcgb3IgYVxuICAgIGBOb2RlVHlwZWAgaW5zdGFuY2UuIEF0dHJpYnV0ZXMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLFxuICAgIGBjb250ZW50YCBtYXkgYmUgYSBgRnJhZ21lbnRgLCBgbnVsbGAsIGEgYE5vZGVgLCBvciBhbiBhcnJheSBvZlxuICAgIG5vZGVzLlxuICAgICovXG4gICAgbm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBub2RlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBmcm9tIGRpZmZlcmVudCBzY2hlbWEgdXNlZCAoXCIgKyB0eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBub2RlIGluIHRoZSBzY2hlbWEuIEVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdFxuICAgIGFsbG93ZWQuXG4gICAgKi9cbiAgICB0ZXh0KHRleHQsIG1hcmtzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlcy50ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCB0ZXh0LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5vZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmFtZSA9IG1hcmtzW2ldLCBtYXJrID0gc2NoZW1hLm1hcmtzW25hbWVdLCBvayA9IG1hcms7XG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIl9cIiB8fCAobWFyay5zcGVjLmdyb3VwICYmIG1hcmsuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQucHVzaChvayA9IG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIG1hcmsgdHlwZTogJ1wiICsgbWFya3NbaV0gKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gaXNUYWdSdWxlKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudGFnICE9IG51bGw7IH1cbmZ1bmN0aW9uIGlzU3R5bGVSdWxlKHJ1bGUpIHsgcmV0dXJuIHJ1bGUuc3R5bGUgIT0gbnVsbDsgfVxuLyoqXG5BIERPTSBwYXJzZXIgcmVwcmVzZW50cyBhIHN0cmF0ZWd5IGZvciBwYXJzaW5nIERPTSBjb250ZW50IGludG8gYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQgY29uZm9ybWluZyB0byBhIGdpdmVuIHNjaGVtYS4gSXRzIGJlaGF2aW9yIGlzXG5kZWZpbmVkIGJ5IGFuIGFycmF5IG9mIFtydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkuXG4qL1xuY2xhc3MgRE9NUGFyc2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwYXJzZXIgdGhhdCB0YXJnZXRzIHRoZSBnaXZlbiBzY2hlbWEsIHVzaW5nIHRoZSBnaXZlblxuICAgIHBhcnNpbmcgcnVsZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIGludG8gd2hpY2ggdGhlIHBhcnNlciBwYXJzZXMuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgW3BhcnNlIHJ1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKSB0aGF0IHRoZSBwYXJzZXJcbiAgICB1c2VzLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgcnVsZXMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICBsZXQgbWF0Y2hlZFN0eWxlcyA9IHRoaXMubWF0Y2hlZFN0eWxlcyA9IFtdO1xuICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVGFnUnVsZShydWxlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHlsZVJ1bGUocnVsZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IC9bXj1dKi8uZXhlYyhydWxlLnN0eWxlKVswXTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFN0eWxlcy5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFN0eWxlcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IG5vcm1hbGl6ZSBsaXN0IGVsZW1lbnRzIHdoZW4gbGlzdHMgaW4gdGhlIHNjaGVtYSBjYW4ndCBkaXJlY3RseSBjb250YWluIHRoZW1zZWx2ZXNcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShyID0+IHtcbiAgICAgICAgICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2UgYSBkb2N1bWVudCBmcm9tIHRoZSBjb250ZW50IG9mIGEgRE9NIG5vZGUuXG4gICAgKi9cbiAgICBwYXJzZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIE1hcmsubm9uZSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlcyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUsIGxpa2VcbiAgICBbYHBhcnNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVBhcnNlci5wYXJzZSksIGFuZCB0YWtlcyB0aGUgc2FtZSBzZXQgb2ZcbiAgICBvcHRpb25zLiBCdXQgdW5saWtlIHRoYXQgbWV0aG9kLCB3aGljaCBwcm9kdWNlcyBhIHdob2xlIG5vZGUsXG4gICAgdGhpcyBvbmUgcmV0dXJucyBhIHNsaWNlIHRoYXQgaXMgb3BlbiBhdCB0aGUgc2lkZXMsIG1lYW5pbmcgdGhhdFxuICAgIHRoZSBzY2hlbWEgY29uc3RyYWludHMgYXJlbid0IGFwcGxpZWQgdG8gdGhlIHN0YXJ0IG9mIG5vZGVzIHRvXG4gICAgdGhlIGxlZnQgb2YgdGhlIGlucHV0IGFuZCB0aGUgZW5kIG9mIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBwYXJzZVNsaWNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBNYXJrLm5vbmUsIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBTbGljZS5tYXhPcGVuKGNvbnRleHQuZmluaXNoKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy50YWdzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy50YWdzW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMoZG9tLCBydWxlLnRhZykgJiZcbiAgICAgICAgICAgICAgICAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJlxuICAgICAgICAgICAgICAgICghcnVsZS5jb250ZXh0IHx8IGNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyhkb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnN0eWxlcy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy5zdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5zdHlsZXNbaV0sIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKHByb3ApICE9IDAgfHxcbiAgICAgICAgICAgICAgICBydWxlLmNvbnRleHQgJiYgIWNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgc3R5bGUgc3RyaW5nIGVpdGhlciBwcmVjaXNlbHkgbWF0Y2hlcyB0aGUgcHJvcCxcbiAgICAgICAgICAgICAgICAvLyBvciBoYXMgYW4gJz0nIHNpZ24gYWZ0ZXIgdGhlIHByb3AsIGZvbGxvd2VkIGJ5IHRoZSBnaXZlblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHNjaGVtYVJ1bGVzKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBydWxlLnByaW9yaXR5ID09IG51bGwgPyA1MCA6IHJ1bGUucHJpb3JpdHksIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHJlc3VsdFtpXSwgbmV4dFByaW9yaXR5ID0gbmV4dC5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBuZXh0LnByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHkgPCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubWFya3NbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm1hcmsgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5jbGVhck1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm5vZGVzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5ub2RlIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUubWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5vZGUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIERPTSBwYXJzZXIgdXNpbmcgdGhlIHBhcnNpbmcgcnVsZXMgbGlzdGVkIGluIGFcbiAgICBzY2hlbWEncyBbbm9kZSBzcGVjc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSwgcmVvcmRlcmVkIGJ5XG4gICAgW3ByaW9yaXR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuR2VuZXJpY1BhcnNlUnVsZS5wcmlvcml0eSkuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKHNjaGVtYSwgRE9NUGFyc2VyLnNjaGVtYVJ1bGVzKHNjaGVtYSkpKTtcbiAgICB9XG59XG5jb25zdCBibG9ja1RhZ3MgPSB7XG4gICAgYWRkcmVzczogdHJ1ZSwgYXJ0aWNsZTogdHJ1ZSwgYXNpZGU6IHRydWUsIGJsb2NrcXVvdGU6IHRydWUsIGNhbnZhczogdHJ1ZSxcbiAgICBkZDogdHJ1ZSwgZGl2OiB0cnVlLCBkbDogdHJ1ZSwgZmllbGRzZXQ6IHRydWUsIGZpZ2NhcHRpb246IHRydWUsIGZpZ3VyZTogdHJ1ZSxcbiAgICBmb290ZXI6IHRydWUsIGZvcm06IHRydWUsIGgxOiB0cnVlLCBoMjogdHJ1ZSwgaDM6IHRydWUsIGg0OiB0cnVlLCBoNTogdHJ1ZSxcbiAgICBoNjogdHJ1ZSwgaGVhZGVyOiB0cnVlLCBoZ3JvdXA6IHRydWUsIGhyOiB0cnVlLCBsaTogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9sOiB0cnVlLFxuICAgIG91dHB1dDogdHJ1ZSwgcDogdHJ1ZSwgcHJlOiB0cnVlLCBzZWN0aW9uOiB0cnVlLCB0YWJsZTogdHJ1ZSwgdGZvb3Q6IHRydWUsIHVsOiB0cnVlXG59O1xuY29uc3QgaWdub3JlVGFncyA9IHtcbiAgICBoZWFkOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2JqZWN0OiB0cnVlLCBzY3JpcHQ6IHRydWUsIHN0eWxlOiB0cnVlLCB0aXRsZTogdHJ1ZVxufTtcbmNvbnN0IGxpc3RUYWdzID0geyBvbDogdHJ1ZSwgdWw6IHRydWUgfTtcbi8vIFVzaW5nIGEgYml0ZmllbGQgZm9yIG5vZGUgY29udGV4dCBvcHRpb25zXG5jb25zdCBPUFRfUFJFU0VSVkVfV1MgPSAxLCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA9IDIsIE9QVF9PUEVOX0xFRlQgPSA0O1xuZnVuY3Rpb24gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV2hpdGVzcGFjZSwgYmFzZSkge1xuICAgIGlmIChwcmVzZXJ2ZVdoaXRlc3BhY2UgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPyBPUFRfUFJFU0VSVkVfV1MgOiAwKSB8XG4gICAgICAgICAgICAocHJlc2VydmVXaGl0ZXNwYWNlID09PSBcImZ1bGxcIiA/IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogMCk7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBPUFRfUFJFU0VSVkVfV1MgfCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IGJhc2UgJiB+T1BUX09QRU5fTEVGVDtcbn1cbmNsYXNzIE5vZGVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgbWFya3MsIHNvbGlkLCBtYXRjaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgLy8gTWFya3MgYXBwbGllZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuYWN0aXZlTWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICBmaW5kV3JhcHBpbmcobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBmaWxsID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZpbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaCwgd3JhcDtcbiAgICAgICAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHsgLy8gU3RyaXAgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLCBtO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5pc1RleHQgJiYgKG0gPSAvWyBcXHRcXHJcXG5cXHUwMDBjXSskLy5leGVjKGxhc3QudGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsYXN0LnRleHQubGVuZ3RoID09IG1bMF0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdID0gdGV4dC53aXRoVGV4dCh0ZXh0LnRleHQuc2xpY2UoMCwgdGV4dC50ZXh0Lmxlbmd0aCAtIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICghb3BlbkVuZCAmJiB0aGlzLm1hdGNoKVxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKHRoaXMubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID8gdGhpcy50eXBlLmNyZWF0ZSh0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKSA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIGlubGluZUNvbnRleHQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmU7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgIWJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShub2RlLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgcGFyc2VyIHdlIGFyZSB1c2luZy5cbiAgICBwYXJzZXIsIFxuICAgIC8vIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGlzIHBhcnNlLlxuICAgIG9wdGlvbnMsIGlzT3Blbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc09wZW4gPSBpc09wZW47XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIHRoaXMubG9jYWxQcmVzZXJ2ZVdTID0gZmFsc2U7XG4gICAgICAgIGxldCB0b3BOb2RlID0gb3B0aW9ucy50b3BOb2RlLCB0b3BDb250ZXh0O1xuICAgICAgICBsZXQgdG9wT3B0aW9ucyA9IHdzT3B0aW9uc0ZvcihudWxsLCBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgMCkgfCAoaXNPcGVuID8gT1BUX09QRU5fTEVGVCA6IDApO1xuICAgICAgICBpZiAodG9wTm9kZSlcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQodG9wTm9kZS50eXBlLCB0b3BOb2RlLmF0dHJzLCBNYXJrLm5vbmUsIHRydWUsIG9wdGlvbnMudG9wTWF0Y2ggfHwgdG9wTm9kZS50eXBlLmNvbnRlbnRNYXRjaCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2UgaWYgKGlzT3BlbilcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQobnVsbCwgbnVsbCwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChwYXJzZXIuc2NoZW1hLnRvcE5vZGVUeXBlLCBudWxsLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAgICAgICB0aGlzLmZpbmQgPSBvcHRpb25zLmZpbmRQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubmVlZHNCbG9jayA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLm9wZW5dO1xuICAgIH1cbiAgICAvLyBBZGQgYSBET00gbm9kZSB0byB0aGUgY29udGVudC4gVGV4dCBpcyBpbnNlcnRlZCBhcyB0ZXh0IG5vZGUsXG4gICAgLy8gb3RoZXJ3aXNlLCB0aGUgbm9kZSBpcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgIG9yLCBpZiBpdCBoYXMgYVxuICAgIC8vIGBzdHlsZWAgYXR0cmlidXRlLCBgYWRkRWxlbWVudFdpdGhTdHlsZXNgLlxuICAgIGFkZERPTShkb20sIG1hcmtzKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tLCBtYXJrcyk7XG4gICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgbWFya3MpO1xuICAgIH1cbiAgICBhZGRUZXh0Tm9kZShkb20sIG1hcmtzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRvbS5ub2RlVmFsdWU7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcCwgcHJlc2VydmVXUyA9ICh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMKSA/IFwiZnVsbFwiXG4gICAgICAgICAgICA6IHRoaXMubG9jYWxQcmVzZXJ2ZVdTIHx8ICh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykgPiAwO1xuICAgICAgICBsZXQgeyBzY2hlbWEgfSA9IHRoaXMucGFyc2VyO1xuICAgICAgICBpZiAocHJlc2VydmVXUyA9PT0gXCJmdWxsXCIgfHxcbiAgICAgICAgICAgIHRvcC5pbmxpbmVDb250ZXh0KGRvbSkgfHxcbiAgICAgICAgICAgIC9bXiBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghcHJlc2VydmVXUykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvWyBcXHRcXHJcXG5cXHUwMDBjXSsvZywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgc3RhcnRzIHdpdGggd2hpdGVzcGFjZSwgYW5kIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIGl0LCBvclxuICAgICAgICAgICAgICAgIC8vIGEgaGFyZCBicmVhaywgb3IgYSB0ZXh0IG5vZGUgdGhhdCBlbmRzIHdpdGggd2hpdGVzcGFjZSwgc3RyaXAgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVhZGluZyBzcGFjZS5cbiAgICAgICAgICAgICAgICBpZiAoL15bIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSAmJiB0aGlzLm9wZW4gPT0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlQmVmb3JlID0gdG9wLmNvbnRlbnRbdG9wLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb21Ob2RlQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlQmVmb3JlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZG9tTm9kZUJlZm9yZSAmJiBkb21Ob2RlQmVmb3JlLm5vZGVOYW1lID09ICdCUicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZUJlZm9yZS5pc1RleHQgJiYgL1sgXFx0XFxyXFxuXFx1MDAwY10kLy50ZXN0KG5vZGVCZWZvcmUudGV4dCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVzZXJ2ZVdTID09PSBcImZ1bGxcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCAmJiAvW1xcclxcbl0vLnRlc3QodmFsdWUpICYmIHRoaXMudG9wLmZpbmRXcmFwcGluZyhzY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQuY3JlYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gdmFsdWUuc3BsaXQoL1xccj9cXG58XFxyLyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Tm9kZShzY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQuY3JlYXRlKCksIG1hcmtzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHNjaGVtYS50ZXh0KGxpbmVzW2ldKSwgbWFya3MsICEvXFxTLy50ZXN0KGxpbmVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Tm9kZShzY2hlbWEudGV4dCh2YWx1ZSksIG1hcmtzLCAhL1xcUy8udGVzdCh2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0YWcgYW5kIHVzZSB0aGF0IHRvIHBhcnNlLiBJZlxuICAgIC8vIG5vbmUgaXMgZm91bmQsIHRoZSBlbGVtZW50J3MgY29udGVudCBub2RlcyBhcmUgYWRkZWQgZGlyZWN0bHkuXG4gICAgYWRkRWxlbWVudChkb20sIG1hcmtzLCBtYXRjaEFmdGVyKSB7XG4gICAgICAgIGxldCBvdXRlcldTID0gdGhpcy5sb2NhbFByZXNlcnZlV1MsIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBpZiAoZG9tLnRhZ05hbWUgPT0gXCJQUkVcIiB8fCAvcHJlLy50ZXN0KGRvbS5zdHlsZSAmJiBkb20uc3R5bGUud2hpdGVTcGFjZSkpXG4gICAgICAgICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IHRydWU7XG4gICAgICAgIGxldCBuYW1lID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHJ1bGVJRDtcbiAgICAgICAgaWYgKGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMucGFyc2VyLm5vcm1hbGl6ZUxpc3RzKVxuICAgICAgICAgICAgbm9ybWFsaXplTGlzdChkb20pO1xuICAgICAgICBsZXQgcnVsZSA9ICh0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSkgfHxcbiAgICAgICAgICAgIChydWxlSUQgPSB0aGlzLnBhcnNlci5tYXRjaFRhZyhkb20sIHRoaXMsIG1hdGNoQWZ0ZXIpKTtcbiAgICAgICAgb3V0OiBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgZG9tID0gcnVsZS5za2lwO1xuICAgICAgICAgICAgbGV0IHN5bmMsIG9sZE5lZWRzQmxvY2sgPSB0aGlzLm5lZWRzQmxvY2s7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcC5jb250ZW50Lmxlbmd0aCAmJiB0b3AuY29udGVudFswXS5pc0lubGluZSAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tLCBtYXJrcyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlubmVyTWFya3MgPSBydWxlICYmIHJ1bGUuc2tpcCA/IG1hcmtzIDogdGhpcy5yZWFkU3R5bGVzKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgaWYgKGlubmVyTWFya3MpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbGwoZG9tLCBpbm5lck1hcmtzKTtcbiAgICAgICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgICAgIHRoaXMuc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gb2xkTmVlZHNCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpbm5lck1hcmtzID0gdGhpcy5yZWFkU3R5bGVzKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgaWYgKGlubmVyTWFya3MpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgaW5uZXJNYXJrcywgcnVsZS5jb25zdW1pbmcgPT09IGZhbHNlID8gcnVsZUlEIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IG91dGVyV1M7XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgbGVhZiBET00gbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgaWdub3JlZFxuICAgIGxlYWZGYWxsYmFjayhkb20sIG1hcmtzKSB7XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIHRoaXMudG9wLnR5cGUgJiYgdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSwgbWFya3MpO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGlnbm9yZWQgbm9kZXNcbiAgICBpZ25vcmVGYWxsYmFjayhkb20sIG1hcmtzKSB7XG4gICAgICAgIC8vIElnbm9yZWQgQlIgbm9kZXMgc2hvdWxkIGF0IGxlYXN0IGNyZWF0ZSBhbiBpbmxpbmUgY29udGV4dFxuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAoIXRoaXMudG9wLnR5cGUgfHwgIXRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudCkpXG4gICAgICAgICAgICB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIiksIG1hcmtzLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gUnVuIGFueSBzdHlsZSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlJ3Mgc3R5bGVzLiBFaXRoZXJcbiAgICAvLyByZXR1cm4gYW4gdXBkYXRlZCBhcnJheSBvZiBtYXJrcywgb3IgbnVsbCB0byBpbmRpY2F0ZSBzb21lIG9mIHRoZVxuICAgIC8vIHN0eWxlcyBoYWQgYSBydWxlIHdpdGggYGlnbm9yZWAgc2V0LlxuICAgIHJlYWRTdHlsZXMoZG9tLCBtYXJrcykge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9tLnN0eWxlO1xuICAgICAgICAvLyBCZWNhdXNlIG1hbnkgcHJvcGVydGllcyB3aWxsIG9ubHkgc2hvdyB1cCBpbiAnbm9ybWFsaXplZCcgZm9ybVxuICAgICAgICAvLyBpbiBgc3R5bGUuaXRlbWAgKGkuZS4gdGV4dC1kZWNvcmF0aW9uIGJlY29tZXNcbiAgICAgICAgLy8gdGV4dC1kZWNvcmF0aW9uLWxpbmUsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZXRjKSwgd2UgZGlyZWN0bHlcbiAgICAgICAgLy8gcXVlcnkgdGhlIHN0eWxlcyBtZW50aW9uZWQgaW4gb3VyIHJ1bGVzIGluc3RlYWQgb2YgaXRlcmF0aW5nXG4gICAgICAgIC8vIG92ZXIgdGhlIGl0ZW1zLlxuICAgICAgICBpZiAoc3R5bGVzICYmIHN0eWxlcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyc2VyLm1hdGNoZWRTdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHRoaXMucGFyc2VyLm1hdGNoZWRTdHlsZXNbaV0sIHZhbHVlID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUobmFtZSwgdmFsdWUsIHRoaXMsIGFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmlnbm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmZpbHRlcihtID0+ICFydWxlLmNsZWFyTWFyayhtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBydWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLy8gTG9vayB1cCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiBub25lIGFyZSBmb3VuZCwgcmV0dXJuXG4gICAgLy8gZmFsc2UuIE90aGVyd2lzZSwgYXBwbHkgaXQsIHVzZSBpdHMgcmV0dXJuIHZhbHVlIHRvIGRyaXZlIHRoZSB3YXlcbiAgICAvLyB0aGUgbm9kZSdzIGNvbnRlbnQgaXMgd3JhcHBlZCwgYW5kIHJldHVybiB0cnVlLlxuICAgIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBtYXJrcywgY29udGludWVBZnRlcikge1xuICAgICAgICBsZXQgc3luYywgbm9kZVR5cGU7XG4gICAgICAgIGlmIChydWxlLm5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgICAgICAgICBpZiAoIW5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IHRoaXMuZW50ZXIobm9kZVR5cGUsIHJ1bGUuYXR0cnMgfHwgbnVsbCwgbWFya3MsIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtzID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5zZXJ0Tm9kZShub2RlVHlwZS5jcmVhdGUocnVsZS5hdHRycyksIG1hcmtzLCBkb20ubm9kZU5hbWUgPT0gXCJCUlwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydEluID0gdGhpcy50b3A7XG4gICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20sIG1hcmtzLCBjb250aW51ZUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5pbnNlcnROb2RlKG5vZGUsIG1hcmtzLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRET00gPSBkb207XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gZG9tLnF1ZXJ5U2VsZWN0b3IocnVsZS5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQoZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuY29udGVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00sIG1hcmtzKTtcbiAgICAgICAgICAgIHRoaXMuZmluZEFyb3VuZChkb20sIGNvbnRlbnRET00sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3luYyAmJiB0aGlzLnN5bmMoc3RhcnRJbikpXG4gICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICB9XG4gICAgLy8gQWRkIGFsbCBjaGlsZCBub2RlcyBiZXR3ZWVuIGBzdGFydEluZGV4YCBhbmQgYGVuZEluZGV4YCAob3IgdGhlXG4gICAgLy8gd2hvbGUgbm9kZSwgaWYgbm90IGdpdmVuKS4gSWYgYHN5bmNgIGlzIHBhc3NlZCwgdXNlIGl0IHRvXG4gICAgLy8gc3luY2hyb25pemUgYWZ0ZXIgZXZlcnkgYmxvY2sgZWxlbWVudC5cbiAgICBhZGRBbGwocGFyZW50LCBtYXJrcywgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICAgICAgICBmb3IgKGxldCBkb20gPSBzdGFydEluZGV4ID8gcGFyZW50LmNoaWxkTm9kZXNbc3RhcnRJbmRleF0gOiBwYXJlbnQuZmlyc3RDaGlsZCwgZW5kID0gZW5kSW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuY2hpbGROb2Rlc1tlbmRJbmRleF07IGRvbSAhPSBlbmQ7IGRvbSA9IGRvbS5uZXh0U2libGluZywgKytpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYWRkRE9NKGRvbSwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgd2F5IHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZSB0eXBlIGludG8gdGhlIGN1cnJlbnRcbiAgICAvLyBjb250ZXh0LiBNYXkgYWRkIGludGVybWVkaWF0ZSB3cmFwcGVycyBhbmQvb3IgbGVhdmUgbm9uLXNvbGlkXG4gICAgLy8gbm9kZXMgdGhhdCB3ZSdyZSBpbi5cbiAgICBmaW5kUGxhY2Uobm9kZSwgbWFya3MsIGNhdXRpb3VzKSB7XG4gICAgICAgIGxldCByb3V0ZSwgc3luYztcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLm9wZW4sIHBlbmFsdHkgPSAwOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiAoIXJvdXRlIHx8IHJvdXRlLmxlbmd0aCA+IGZvdW5kLmxlbmd0aCArIHBlbmFsdHkpKSB7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICBzeW5jID0gY3g7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN4LnNvbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhdXRpb3VzKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwZW5hbHR5ICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3V0ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLnN5bmMoc3luYyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgbWFya3MsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gaW5zZXJ0IHRoZSBnaXZlbiBub2RlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlbiBuZWVkZWQuXG4gICAgaW5zZXJ0Tm9kZShub2RlLCBtYXJrcywgY2F1dGlvdXMpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLnRleHRibG9ja0Zyb21Db250ZXh0KCk7XG4gICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgbWFya3MgPSB0aGlzLmVudGVySW5uZXIoYmxvY2ssIG51bGwsIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXJNYXJrcyA9IHRoaXMuZmluZFBsYWNlKG5vZGUsIG1hcmtzLCBjYXV0aW91cyk7XG4gICAgICAgIGlmIChpbm5lck1hcmtzKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgIGlmICh0b3AubWF0Y2gpXG4gICAgICAgICAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgbGV0IG5vZGVNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IG0gb2YgaW5uZXJNYXJrcy5jb25jYXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgaWYgKHRvcC50eXBlID8gdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobS50eXBlKSA6IG1hcmtNYXlBcHBseShtLnR5cGUsIG5vZGUudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVNYXJrcyA9IG0uYWRkVG9TZXQobm9kZU1hcmtzKTtcbiAgICAgICAgICAgIHRvcC5jb250ZW50LnB1c2gobm9kZS5tYXJrKG5vZGVNYXJrcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gc3RhcnQgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlblxuICAgIC8vIG5lY2Vzc2FyeS5cbiAgICBlbnRlcih0eXBlLCBhdHRycywgbWFya3MsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgbGV0IGlubmVyTWFya3MgPSB0aGlzLmZpbmRQbGFjZSh0eXBlLmNyZWF0ZShhdHRycyksIG1hcmtzLCBmYWxzZSk7XG4gICAgICAgIGlmIChpbm5lck1hcmtzKVxuICAgICAgICAgICAgaW5uZXJNYXJrcyA9IHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MsIHRydWUsIHByZXNlcnZlV1MpO1xuICAgICAgICByZXR1cm4gaW5uZXJNYXJrcztcbiAgICB9XG4gICAgLy8gT3BlbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAgICBlbnRlcklubmVyKHR5cGUsIGF0dHJzLCBtYXJrcywgc29saWQgPSBmYWxzZSwgcHJlc2VydmVXUykge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXUywgdG9wLm9wdGlvbnMpO1xuICAgICAgICBpZiAoKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCkgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICBvcHRpb25zIHw9IE9QVF9PUEVOX0xFRlQ7XG4gICAgICAgIGxldCBhcHBseU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmZpbHRlcihtID0+IHtcbiAgICAgICAgICAgIGlmICh0b3AudHlwZSA/IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG0udHlwZSkgOiBtYXJrTWF5QXBwbHkobS50eXBlLCB0eXBlKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5TWFya3MgPSBtLmFkZFRvU2V0KGFwcGx5TWFya3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBOb2RlQ29udGV4dCh0eXBlLCBhdHRycywgYXBwbHlNYXJrcywgc29saWQsIG51bGwsIG9wdGlvbnMpKTtcbiAgICAgICAgdGhpcy5vcGVuKys7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGFsbCBub2RlcyBhYm92ZSB0aGlzLm9wZW4gYXJlIGZpbmlzaGVkIGFuZCBhZGRlZCB0b1xuICAgIC8vIHRoZWlyIHBhcmVudHNcbiAgICBjbG9zZUV4dHJhKG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaSA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgIGZvciAoOyBpID4gdGhpcy5vcGVuOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5vcGVuICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdLmZpbmlzaCghISh0aGlzLmlzT3BlbiB8fCB0aGlzLm9wdGlvbnMudG9wT3BlbikpO1xuICAgIH1cbiAgICBzeW5jKHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvY2FsUHJlc2VydmVXUykge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaV0ub3B0aW9ucyB8PSBPUFRfUFJFU0VSVkVfV1M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBvcygpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLm5vZGVzW2ldLmNvbnRlbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gY29udGVudC5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gY29udGVudFtqXS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZpbmRBdFBvaW50KHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSBwYXJlbnQgJiYgdGhpcy5maW5kW2ldLm9mZnNldCA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJbnNpZGUocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEFyb3VuZChwYXJlbnQsIGNvbnRlbnQsIGJlZm9yZSkge1xuICAgICAgICBpZiAocGFyZW50ICE9IGNvbnRlbnQgJiYgdGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGNvbnRlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5maW5kW2ldLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5UZXh0KHRleHROb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gY29udGV4dCBzdHJpbmcgbWF0Y2hlcyB0aGlzIGNvbnRleHQuXG4gICAgbWF0Y2hlc0NvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5pbmRleE9mKFwifFwiKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKTtcbiAgICAgICAgbGV0IHBhcnRzID0gY29udGV4dC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgbGV0IHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gICAgICAgIGxldCBtaW5EZXB0aCA9IC0ob3B0aW9uID8gb3B0aW9uLmRlcHRoICsgMSA6IDApICsgKHVzZVJvb3QgPyAwIDogMSk7XG4gICAgICAgIGxldCBtYXRjaCA9IChpLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHBhcnRzLmxlbmd0aCAtIDEgfHwgaSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBkZXB0aCA+PSBtaW5EZXB0aDsgZGVwdGgtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRlcHRoID4gMCB8fCAoZGVwdGggPT0gMCAmJiB1c2VSb290KSA/IHRoaXMubm9kZXNbZGVwdGhdLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IChuZXh0Lm5hbWUgIT0gcGFydCAmJiAhbmV4dC5pc0luR3JvdXAocGFydCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gICAgdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICAgIGxldCAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBpZiAoJGNvbnRleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGRpcmVjdGx5IG5lc3RlZCBsaXN0IG5vZGVzIHByb2R1Y2VkIGJ5IHNvbWVcbi8vIHRvb2xzIGFuZCBhbGxvd2VkIGJ5IGJyb3dzZXJzIHRvIG1lYW4gdGhhdCB0aGUgbmVzdGVkIGxpc3QgaXNcbi8vIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgaXRlbSBhYm92ZSBpdC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3QoZG9tKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBsZXQgbmFtZSA9IGNoaWxkLm5vZGVUeXBlID09IDEgPyBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgJiYgbGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcHJldkl0ZW0pIHtcbiAgICAgICAgICAgIHByZXZJdGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJldkl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQXBwbHkgYSBDU1Mgc2VsZWN0b3IuXG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKGRvbS5tYXRjaGVzIHx8IGRvbS5tc01hdGNoZXNTZWxlY3RvciB8fCBkb20ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS5tb3pNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZG9tLCBzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vLyBVc2VkIHdoZW4gZmluZGluZyBhIG1hcmsgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZyYWdtZW50IHBhcnNlLlxuLy8gQ2hlY2tzIHdoZXRoZXIgaXQgd291bGQgYmUgcmVhc29uYWJsZSB0byBhcHBseSBhIGdpdmVuIG1hcmsgdHlwZSB0b1xuLy8gYSBnaXZlbiBub2RlLCBieSBsb29raW5nIGF0IHRoZSB3YXkgdGhlIG1hcmsgb2NjdXJzIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBtYXJrTWF5QXBwbHkobWFya1R5cGUsIG5vZGVUeXBlKSB7XG4gICAgbGV0IG5vZGVzID0gbm9kZVR5cGUuc2NoZW1hLm5vZGVzO1xuICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZXMpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIXBhcmVudC5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHNlZW4gPSBbXSwgc2NhbiA9IChtYXRjaCkgPT4ge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5leHQpIDwgMCAmJiBzY2FuKG5leHQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjYW4ocGFyZW50LmNvbnRlbnRNYXRjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuQSBET00gc2VyaWFsaXplciBrbm93cyBob3cgdG8gY29udmVydCBQcm9zZU1pcnJvciBub2RlcyBhbmRcbm1hcmtzIG9mIHZhcmlvdXMgdHlwZXMgdG8gRE9NIG5vZGVzLlxuKi9cbmNsYXNzIERPTVNlcmlhbGl6ZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlcmlhbGl6ZXIuIGBub2Rlc2Agc2hvdWxkIG1hcCBub2RlIG5hbWVzIHRvIGZ1bmN0aW9uc1xuICAgIHRoYXQgdGFrZSBhIG5vZGUgYW5kIHJldHVybiBhIGRlc2NyaXB0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgRE9NLiBgbWFya3NgIGRvZXMgdGhlIHNhbWUgZm9yIG1hcmsgbmFtZXMsIGJ1dCBhbHNvIGdldHMgYW5cbiAgICBhcmd1bWVudCB0aGF0IHRlbGxzIGl0IHdoZXRoZXIgdGhlIG1hcmsncyBjb250ZW50IGlzIGJsb2NrIG9yXG4gICAgaW5saW5lIGNvbnRlbnQgKGZvciB0eXBpY2FsIHVzZSwgaXQnbGwgYWx3YXlzIGJlIGlubGluZSkuIEEgbWFya1xuICAgIHNlcmlhbGl6ZXIgbWF5IGJlIGBudWxsYCB0byBpbmRpY2F0ZSB0aGF0IG1hcmtzIG9mIHRoYXQgdHlwZVxuICAgIHNob3VsZCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbm9kZXMsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHNlcmlhbGl6YXRpb24gZnVuY3Rpb25zLlxuICAgICovXG4gICAgbWFya3MpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGlzIGZyYWdtZW50IHRvIGEgRE9NIGZyYWdtZW50LiBXaGVuXG4gICAgbm90IGluIHRoZSBicm93c2VyLCB0aGUgYGRvY3VtZW50YCBvcHRpb24sIGNvbnRhaW5pbmcgYSBET01cbiAgICBkb2N1bWVudCwgc2hvdWxkIGJlIHBhc3NlZCBzbyB0aGF0IHRoZSBzZXJpYWxpemVyIGNhbiBjcmVhdGVcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zID0ge30sIHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IGRvYyhvcHRpb25zKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGxldCB0b3AgPSB0YXJnZXQsIGFjdGl2ZSA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggfHwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQga2VlcCA9IDAsIHJlbmRlcmVkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGggJiYgcmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0b3AgPSBhY3RpdmUucG9wKClbMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IG5vZGUubWFya3NbcmVuZGVyZWQrK107XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrRE9NID0gdGhpcy5zZXJpYWxpemVNYXJrKGFkZCwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChbYWRkLCB0b3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZChtYXJrRE9NLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQodGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgeyBkb20sIGNvbnRlbnRET00gfSA9IHJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSwgbnVsbCwgbm9kZS5hdHRycyk7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplRnJhZ21lbnQobm9kZS5jb250ZW50LCBvcHRpb25zLCBjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBub2RlIHRvIGEgRE9NIG5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdVxuICAgIG5lZWQgdG8gc2VyaWFsaXplIGEgcGFydCBvZiBhIGRvY3VtZW50LCBhcyBvcHBvc2VkIHRvIHRoZSB3aG9sZVxuICAgIGRvY3VtZW50LiBUbyBzZXJpYWxpemUgYSB3aG9sZSBkb2N1bWVudCwgdXNlXG4gICAgW2BzZXJpYWxpemVGcmFnbWVudGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01TZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KSBvblxuICAgIGl0cyBbY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUuY29udGVudCkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgICAgICAgKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU1hcmsobWFyaywgaW5saW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIHJldHVybiB0b0RPTSAmJiByZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSwgbnVsbCwgbWFyay5hdHRycyk7XG4gICAgfVxuICAgIHN0YXRpYyByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUyA9IG51bGwsIGJsb2NrQXJyYXlzSW4pIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TLCBibG9ja0FycmF5c0luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBzZXJpYWxpemVyIHVzaW5nIHRoZSBbYHRvRE9NYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnRvRE9NKVxuICAgIHByb3BlcnRpZXMgaW4gYSBzY2hlbWEncyBub2RlIGFuZCBtYXJrIHNwZWNzLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBub2RlIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgIFRoaXMgY2FuIGJlIHVzZWZ1bCBhcyBhIGJhc2UgdG8gYnVpbGQgYSBjdXN0b20gc2VyaWFsaXplciBmcm9tLlxuICAgICovXG4gICAgc3RhdGljIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICByZXN1bHQudGV4dCA9IG5vZGUgPT4gbm9kZS50ZXh0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3MgbWFyayBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBnYXRoZXJUb0RPTShzY2hlbWEubWFya3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9iaikge1xuICAgICAgICBsZXQgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICAgICAgaWYgKHRvRE9NKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdG9ET007XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkb2Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cbmNvbnN0IHN1c3BpY2lvdXNBdHRyaWJ1dGVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzdXNwaWNpb3VzQXR0cmlidXRlcyhhdHRycykge1xuICAgIGxldCB2YWx1ZSA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVDYWNoZS5nZXQoYXR0cnMpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUuc2V0KGF0dHJzLCB2YWx1ZSA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzSW5uZXIoYXR0cnMpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzdXNwaWNpb3VzQXR0cmlidXRlc0lubmVyKGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZnVuY3Rpb24gc2Nhbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVbMF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbih2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2Nhbih2YWx1ZVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NhbihhdHRycyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TLCBibG9ja0FycmF5c0luKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHsgZG9tOiBkb2MuY3JlYXRlVGV4dE5vZGUoc3RydWN0dXJlKSB9O1xuICAgIGlmIChzdHJ1Y3R1cmUubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHsgZG9tOiBzdHJ1Y3R1cmUgfTtcbiAgICBpZiAoc3RydWN0dXJlLmRvbSAmJiBzdHJ1Y3R1cmUuZG9tLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmU7XG4gICAgbGV0IHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sIHN1c3BpY2lvdXM7XG4gICAgaWYgKHR5cGVvZiB0YWdOYW1lICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcnJheSBwYXNzZWQgdG8gcmVuZGVyU3BlY1wiKTtcbiAgICBpZiAoYmxvY2tBcnJheXNJbiAmJiAoc3VzcGljaW91cyA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzKGJsb2NrQXJyYXlzSW4pKSAmJlxuICAgICAgICBzdXNwaWNpb3VzLmluZGV4T2Yoc3RydWN0dXJlKSA+IC0xKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVzaW5nIGFuIGFycmF5IGZyb20gYW4gYXR0cmlidXRlIG9iamVjdCBhcyBhIERPTSBzcGVjLiBUaGlzIG1heSBiZSBhbiBhdHRlbXB0ZWQgY3Jvc3Mgc2l0ZSBzY3JpcHRpbmcgYXR0YWNrLlwiKTtcbiAgICBsZXQgc3BhY2UgPSB0YWdOYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgIGlmIChzcGFjZSA+IDApIHtcbiAgICAgICAgeG1sTlMgPSB0YWdOYW1lLnNsaWNlKDAsIHNwYWNlKTtcbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnRET007XG4gICAgbGV0IGRvbSA9ICh4bWxOUyA/IGRvYy5jcmVhdGVFbGVtZW50TlMoeG1sTlMsIHRhZ05hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICAgIGxldCBhdHRycyA9IHN0cnVjdHVyZVsxXSwgc3RhcnQgPSAxO1xuICAgIGlmIChhdHRycyAmJiB0eXBlb2YgYXR0cnMgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICBzdGFydCA9IDI7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoYXR0cnNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBzcGFjZSA9IG5hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlID4gMClcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgc3BhY2UpLCBuYW1lLnNsaWNlKHNwYWNlICsgMSksIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiBkb20uc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RydWN0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHN0cnVjdHVyZVtpXTtcbiAgICAgICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaSA8IHN0cnVjdHVyZS5sZW5ndGggLSAxIHx8IGkgPiBzdGFydClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBtdXN0IGJlIHRoZSBvbmx5IGNoaWxkIG9mIGl0cyBwYXJlbnQgbm9kZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTTogZG9tIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBkb206IGlubmVyLCBjb250ZW50RE9NOiBpbm5lckNvbnRlbnQgfSA9IHJlbmRlclNwZWMoZG9jLCBjaGlsZCwgeG1sTlMsIGJsb2NrQXJyYXlzSW4pO1xuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgICAgICAgIGlmIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBjb250ZW50IGhvbGVzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NIH07XG59XG5cbmV4cG9ydCB7IENvbnRlbnRNYXRjaCwgRE9NUGFyc2VyLCBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgTWFya1R5cGUsIE5vZGUsIE5vZGVSYW5nZSwgTm9kZVR5cGUsIFJlcGxhY2VFcnJvciwgUmVzb2x2ZWRQb3MsIFNjaGVtYSwgU2xpY2UgfTtcbiJdLCJuYW1lcyI6WyJPcmRlcmVkTWFwIiwiZmluZERpZmZTdGFydCIsImEiLCJiIiwicG9zIiwiaSIsImNoaWxkQ291bnQiLCJjaGlsZEEiLCJjaGlsZCIsImNoaWxkQiIsIm5vZGVTaXplIiwic2FtZU1hcmt1cCIsImlzVGV4dCIsInRleHQiLCJqIiwiY29udGVudCIsInNpemUiLCJpbm5lciIsImZpbmREaWZmRW5kIiwicG9zQSIsInBvc0IiLCJpQSIsImlCIiwic2FtZSIsIm1pblNpemUiLCJNYXRoIiwibWluIiwibGVuZ3RoIiwiRnJhZ21lbnQiLCJjb25zdHJ1Y3RvciIsIm5vZGVzQmV0d2VlbiIsImZyb20iLCJ0byIsImYiLCJub2RlU3RhcnQiLCJwYXJlbnQiLCJlbmQiLCJzdGFydCIsIm1heCIsImRlc2NlbmRhbnRzIiwidGV4dEJldHdlZW4iLCJibG9ja1NlcGFyYXRvciIsImxlYWZUZXh0IiwiZmlyc3QiLCJub2RlIiwibm9kZVRleHQiLCJzbGljZSIsImlzTGVhZiIsInR5cGUiLCJzcGVjIiwiaXNCbG9jayIsImlzVGV4dGJsb2NrIiwiYXBwZW5kIiwib3RoZXIiLCJsYXN0IiwibGFzdENoaWxkIiwiZmlyc3RDaGlsZCIsIndpdGhUZXh0IiwicHVzaCIsImN1dCIsInJlc3VsdCIsImN1dEJ5SW5kZXgiLCJlbXB0eSIsInJlcGxhY2VDaGlsZCIsImluZGV4IiwiY3VycmVudCIsImNvcHkiLCJhZGRUb1N0YXJ0IiwiY29uY2F0IiwiYWRkVG9FbmQiLCJlcSIsImZvdW5kIiwiUmFuZ2VFcnJvciIsIm1heWJlQ2hpbGQiLCJmb3JFYWNoIiwicCIsIm90aGVyUG9zIiwiZmluZEluZGV4IiwicmV0SW5kZXgiLCJjdXJQb3MiLCJjdXIiLCJ0b1N0cmluZyIsInRvU3RyaW5nSW5uZXIiLCJqb2luIiwidG9KU09OIiwibWFwIiwibiIsImZyb21KU09OIiwic2NoZW1hIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJub2RlRnJvbUpTT04iLCJmcm9tQXJyYXkiLCJhcnJheSIsImpvaW5lZCIsIm5vZGVzIiwiYXR0cnMiLCJvZmZzZXQiLCJjb21wYXJlRGVlcCIsIk1hcmsiLCJhZGRUb1NldCIsInNldCIsInBsYWNlZCIsImV4Y2x1ZGVzIiwicmFuayIsInJlbW92ZUZyb21TZXQiLCJpc0luU2V0Iiwib2JqIiwibmFtZSIsIl8iLCJqc29uIiwibWFya3MiLCJtYXJrIiwiY3JlYXRlIiwiY2hlY2tBdHRycyIsInNhbWVTZXQiLCJzZXRGcm9tIiwibm9uZSIsInNvcnQiLCJSZXBsYWNlRXJyb3IiLCJFcnJvciIsIlNsaWNlIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsImluc2VydEF0IiwiZnJhZ21lbnQiLCJpbnNlcnRJbnRvIiwicmVtb3ZlQmV0d2VlbiIsInJlbW92ZVJhbmdlIiwibWF4T3BlbiIsIm9wZW5Jc29sYXRpbmciLCJpc29sYXRpbmciLCJpbmRleFRvIiwib2Zmc2V0VG8iLCJkaXN0IiwiaW5zZXJ0IiwiY2FuUmVwbGFjZSIsInJlcGxhY2UiLCIkZnJvbSIsIiR0byIsImRlcHRoIiwicmVwbGFjZU91dGVyIiwiY2xvc2UiLCJyZXBsYWNlVHdvV2F5IiwicGFyZW50T2Zmc2V0IiwicHJlcGFyZVNsaWNlRm9yUmVwbGFjZSIsInJlcGxhY2VUaHJlZVdheSIsImNoZWNrSm9pbiIsIm1haW4iLCJzdWIiLCJjb21wYXRpYmxlQ29udGVudCIsImpvaW5hYmxlIiwiJGJlZm9yZSIsIiRhZnRlciIsImFkZE5vZGUiLCJ0YXJnZXQiLCJhZGRSYW5nZSIsIiRzdGFydCIsIiRlbmQiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJ0ZXh0T2Zmc2V0Iiwibm9kZUFmdGVyIiwibm9kZUJlZm9yZSIsImNoZWNrQ29udGVudCIsIiRhbG9uZyIsImV4dHJhIiwicmVzb2x2ZU5vQ2FjaGUiLCJSZXNvbHZlZFBvcyIsInBhdGgiLCJyZXNvbHZlRGVwdGgiLCJ2YWwiLCJkb2MiLCJpbmRleEFmdGVyIiwiYmVmb3JlIiwiYWZ0ZXIiLCJkT2ZmIiwicG9zQXRJbmRleCIsInRtcCIsImluY2x1c2l2ZSIsIm1hcmtzQWNyb3NzIiwiaXNJbmxpbmUiLCJuZXh0Iiwic2hhcmVkRGVwdGgiLCJibG9ja1JhbmdlIiwicHJlZCIsImQiLCJpbmxpbmVDb250ZW50IiwiTm9kZVJhbmdlIiwic2FtZVBhcmVudCIsInN0ciIsInJlc29sdmUiLCJyZW0iLCJyZXNvbHZlQ2FjaGVkIiwiY2FjaGUiLCJyZXNvbHZlQ2FjaGUiLCJnZXQiLCJlbHRzIiwiZWx0IiwiUmVzb2x2ZUNhY2hlIiwicmVzb2x2ZUNhY2hlU2l6ZSIsIldlYWtNYXAiLCJlbXB0eUF0dHJzIiwiT2JqZWN0IiwiTm9kZSIsImNoaWxkcmVuIiwic3RhcnRQb3MiLCJ0ZXh0Q29udGVudCIsImhhc01hcmt1cCIsImRlZmF1bHRBdHRycyIsImluY2x1ZGVQYXJlbnRzIiwibm9kZUF0IiwiY2hpbGRBZnRlciIsImNoaWxkQmVmb3JlIiwicmFuZ2VIYXNNYXJrIiwiaXNBdG9tIiwidG9EZWJ1Z1N0cmluZyIsIndyYXBNYXJrcyIsImNvbnRlbnRNYXRjaEF0IiwibWF0Y2giLCJjb250ZW50TWF0Y2giLCJtYXRjaEZyYWdtZW50IiwicmVwbGFjZW1lbnQiLCJvbmUiLCJ0d28iLCJ2YWxpZEVuZCIsImFsbG93c01hcmtzIiwiY2FuUmVwbGFjZVdpdGgiLCJtYXRjaFR5cGUiLCJjYW5BcHBlbmQiLCJjaGVjayIsIm0iLCJ1bmRlZmluZWQiLCJtYXJrRnJvbUpTT04iLCJub2RlVHlwZSIsInByb3RvdHlwZSIsIlRleHROb2RlIiwiSlNPTiIsInN0cmluZ2lmeSIsImJhc2UiLCJDb250ZW50TWF0Y2giLCJ3cmFwQ2FjaGUiLCJwYXJzZSIsInN0cmluZyIsIm5vZGVUeXBlcyIsInN0cmVhbSIsIlRva2VuU3RyZWFtIiwiZXhwciIsInBhcnNlRXhwciIsImVyciIsImRmYSIsIm5mYSIsImNoZWNrRm9yRGVhZEVuZHMiLCJmcmFnIiwiZGVmYXVsdFR5cGUiLCJoYXNSZXF1aXJlZEF0dHJzIiwiY29tcGF0aWJsZSIsImZpbGxCZWZvcmUiLCJ0b0VuZCIsInNlZW4iLCJzZWFyY2giLCJ0eXBlcyIsImZpbmlzaGVkIiwidHAiLCJjcmVhdGVBbmRGaWxsIiwiaW5kZXhPZiIsImZpbmRXcmFwcGluZyIsImNvbXB1dGVkIiwiY29tcHV0ZVdyYXBwaW5nIiwiYWN0aXZlIiwidmlhIiwic2hpZnQiLCJyZXZlcnNlIiwiZWRnZUNvdW50IiwiZWRnZSIsInNjYW4iLCJvdXQiLCJpbmxpbmUiLCJ0b2tlbnMiLCJzcGxpdCIsInBvcCIsImVhdCIsInRvayIsIlN5bnRheEVycm9yIiwiZXhwcnMiLCJwYXJzZUV4cHJTZXEiLCJwYXJzZUV4cHJTdWJzY3JpcHQiLCJwYXJzZUV4cHJBdG9tIiwicGFyc2VFeHByUmFuZ2UiLCJwYXJzZU51bSIsInRlc3QiLCJOdW1iZXIiLCJyZXNvbHZlTmFtZSIsInR5cGVOYW1lIiwiaXNJbkdyb3VwIiwiY29ubmVjdCIsImNvbXBpbGUiLCJ0ZXJtIiwiZWRnZXMiLCJyZWR1Y2UiLCJsb29wIiwiY21wIiwibnVsbEZyb20iLCJsYWJlbGVkIiwiZXhwbG9yZSIsInN0YXRlcyIsInN0YXRlIiwid29yayIsImRlYWQiLCJkZWZhdWx0cyIsImF0dHJOYW1lIiwiYXR0ciIsImhhc0RlZmF1bHQiLCJkZWZhdWx0IiwiY29tcHV0ZUF0dHJzIiwiYnVpbHQiLCJnaXZlbiIsInZhbHVlcyIsInZhbGlkYXRlIiwiaW5pdEF0dHJzIiwiQXR0cmlidXRlIiwiTm9kZVR5cGUiLCJtYXJrU2V0IiwiZ3JvdXBzIiwiZ3JvdXAiLCJhdG9tIiwid2hpdGVzcGFjZSIsImNvZGUiLCJpc1JlcXVpcmVkIiwiY3JlYXRlQ2hlY2tlZCIsIm1hdGNoZWQiLCJ2YWxpZENvbnRlbnQiLCJhbGxvd3NNYXJrVHlwZSIsIm1hcmtUeXBlIiwiYWxsb3dlZE1hcmtzIiwidG9wVHlwZSIsInRvcE5vZGUiLCJ2YWxpZGF0ZVR5cGUiLCJvcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiTWFya1R5cGUiLCJleGNsdWRlZCIsImluc3RhbmNlIiwiU2NoZW1hIiwibGluZWJyZWFrUmVwbGFjZW1lbnQiLCJjYWNoZWQiLCJpbnN0YW5jZVNwZWMiLCJwcm9wIiwiY29udGVudEV4cHJDYWNoZSIsImNvbnRlbnRFeHByIiwibWFya0V4cHIiLCJnYXRoZXJNYXJrcyIsImV4Y2wiLCJ0b3BOb2RlVHlwZSIsIndyYXBwaW5ncyIsIm9rIiwiaXNUYWdSdWxlIiwicnVsZSIsInRhZyIsImlzU3R5bGVSdWxlIiwic3R5bGUiLCJET01QYXJzZXIiLCJydWxlcyIsInRhZ3MiLCJzdHlsZXMiLCJtYXRjaGVkU3R5bGVzIiwiZXhlYyIsIm5vcm1hbGl6ZUxpc3RzIiwic29tZSIsInIiLCJkb20iLCJjb250ZXh0IiwiUGFyc2VDb250ZXh0IiwiYWRkQWxsIiwiZmluaXNoIiwicGFyc2VTbGljZSIsIm1hdGNoVGFnIiwibWF0Y2hlcyIsIm5hbWVzcGFjZSIsIm5hbWVzcGFjZVVSSSIsIm1hdGNoZXNDb250ZXh0IiwiZ2V0QXR0cnMiLCJtYXRjaFN0eWxlIiwiY2hhckNvZGVBdCIsInNjaGVtYVJ1bGVzIiwicHJpb3JpdHkiLCJuZXh0UHJpb3JpdHkiLCJzcGxpY2UiLCJwYXJzZURPTSIsImlnbm9yZSIsImNsZWFyTWFyayIsImZyb21TY2hlbWEiLCJkb21QYXJzZXIiLCJibG9ja1RhZ3MiLCJhZGRyZXNzIiwiYXJ0aWNsZSIsImFzaWRlIiwiYmxvY2txdW90ZSIsImNhbnZhcyIsImRkIiwiZGl2IiwiZGwiLCJmaWVsZHNldCIsImZpZ2NhcHRpb24iLCJmaWd1cmUiLCJmb290ZXIiLCJmb3JtIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaGVhZGVyIiwiaGdyb3VwIiwiaHIiLCJsaSIsIm5vc2NyaXB0Iiwib2wiLCJvdXRwdXQiLCJwcmUiLCJzZWN0aW9uIiwidGFibGUiLCJ0Zm9vdCIsInVsIiwiaWdub3JlVGFncyIsImhlYWQiLCJvYmplY3QiLCJzY3JpcHQiLCJ0aXRsZSIsImxpc3RUYWdzIiwiT1BUX1BSRVNFUlZFX1dTIiwiT1BUX1BSRVNFUlZFX1dTX0ZVTEwiLCJPUFRfT1BFTl9MRUZUIiwid3NPcHRpb25zRm9yIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwiTm9kZUNvbnRleHQiLCJzb2xpZCIsImFjdGl2ZU1hcmtzIiwiZmlsbCIsIndyYXAiLCJpbmxpbmVDb250ZXh0IiwicGFyZW50Tm9kZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJwYXJzZXIiLCJpc09wZW4iLCJvcGVuIiwibG9jYWxQcmVzZXJ2ZVdTIiwidG9wQ29udGV4dCIsInRvcE9wdGlvbnMiLCJ0b3BNYXRjaCIsImZpbmQiLCJmaW5kUG9zaXRpb25zIiwibmVlZHNCbG9jayIsInRvcCIsImFkZERPTSIsImFkZFRleHROb2RlIiwiYWRkRWxlbWVudCIsIm5vZGVWYWx1ZSIsInByZXNlcnZlV1MiLCJkb21Ob2RlQmVmb3JlIiwicHJldmlvdXNTaWJsaW5nIiwibGluZXMiLCJpbnNlcnROb2RlIiwiZmluZEluVGV4dCIsImZpbmRJbnNpZGUiLCJtYXRjaEFmdGVyIiwib3V0ZXJXUyIsInRhZ05hbWUiLCJ3aGl0ZVNwYWNlIiwicnVsZUlEIiwibm9ybWFsaXplTGlzdCIsInJ1bGVGcm9tTm9kZSIsImlnbm9yZUZhbGxiYWNrIiwic2tpcCIsImNsb3NlUGFyZW50Iiwic3luYyIsIm9sZE5lZWRzQmxvY2siLCJsZWFmRmFsbGJhY2siLCJpbm5lck1hcmtzIiwicmVhZFN0eWxlcyIsImFkZEVsZW1lbnRCeVJ1bGUiLCJjb25zdW1pbmciLCJvd25lckRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJmaW5kUGxhY2UiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZmlsdGVyIiwiY29udGludWVBZnRlciIsImVudGVyIiwic3RhcnRJbiIsImdldENvbnRlbnQiLCJjb250ZW50RE9NIiwiY29udGVudEVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZmluZEFyb3VuZCIsImNoaWxkTm9kZXMiLCJuZXh0U2libGluZyIsImZpbmRBdFBvaW50IiwiY2F1dGlvdXMiLCJyb3V0ZSIsInBlbmFsdHkiLCJjeCIsImVudGVySW5uZXIiLCJibG9jayIsInRleHRibG9ja0Zyb21Db250ZXh0IiwiY2xvc2VFeHRyYSIsIm5vZGVNYXJrcyIsIm1hcmtNYXlBcHBseSIsImFwcGx5TWFya3MiLCJ0b3BPcGVuIiwiY3VycmVudFBvcyIsImNvbnRhaW5zIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJ0ZXh0Tm9kZSIsInBhcnRzIiwib3B0aW9uIiwidXNlUm9vdCIsIm1pbkRlcHRoIiwicGFydCIsIiRjb250ZXh0IiwiZGVmbHQiLCJwcmV2SXRlbSIsImFwcGVuZENoaWxkIiwic2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIkRPTVNlcmlhbGl6ZXIiLCJzZXJpYWxpemVGcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJrZWVwIiwicmVuZGVyZWQiLCJzcGFubmluZyIsImFkZCIsIm1hcmtET00iLCJzZXJpYWxpemVNYXJrIiwic2VyaWFsaXplTm9kZUlubmVyIiwicmVuZGVyU3BlYyIsInNlcmlhbGl6ZU5vZGUiLCJ0b0RPTSIsInN0cnVjdHVyZSIsInhtbE5TIiwiYmxvY2tBcnJheXNJbiIsImRvbVNlcmlhbGl6ZXIiLCJub2Rlc0Zyb21TY2hlbWEiLCJtYXJrc0Zyb21TY2hlbWEiLCJnYXRoZXJUb0RPTSIsImRvY3VtZW50Iiwid2luZG93Iiwic3VzcGljaW91c0F0dHJpYnV0ZUNhY2hlIiwic3VzcGljaW91c0F0dHJpYnV0ZXMiLCJzdXNwaWNpb3VzQXR0cmlidXRlc0lubmVyIiwic3VzcGljaW91cyIsInNwYWNlIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZU5TIiwiY3NzVGV4dCIsInNldEF0dHJpYnV0ZSIsImlubmVyQ29udGVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.js\n");

/***/ })

};
;