"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer+highlight@1.2.3";
exports.ids = ["vendor-chunks/@lezer+highlight@1.2.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lezer+highlight@1.2.3/node_modules/@lezer/highlight/dist/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lezer+highlight@1.2.3/node_modules/@lezer/highlight/dist/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/ class Tag {\n    /**\n    @internal\n    */ constructor(/**\n    The optional name of the base tag @internal\n    */ name, /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */ set, /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */ base, /**\n    The modifiers applied to this.base @internal\n    */ modified){\n        this.name = name;\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */ this.id = nextTagID++;\n    }\n    toString() {\n        let { name } = this;\n        for (let mod of this.modified)if (mod.name) name = `${mod.name}(${name})`;\n        return name;\n    }\n    static define(nameOrParent, parent) {\n        let name = typeof nameOrParent == \"string\" ? nameOrParent : \"?\";\n        if (nameOrParent instanceof Tag) parent = nameOrParent;\n        if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag(name, [], null, []);\n        tag.set.push(tag);\n        if (parent) for (let t of parent.set)tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */ static defineModifier(name) {\n        let mod = new Modifier(name);\n        return (tag)=>{\n            if (tag.modified.indexOf(mod) > -1) return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b)=>a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(name){\n        this.name = name;\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length) return base;\n        let exists = mods[0].instances.find((t)=>t.base == base && sameArray(mods, t.modified));\n        if (exists) return exists;\n        let set = [], tag = new Tag(base.name, set, base, mods);\n        for (let m of mods)m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)if (!parent.modified.length) for (let config of configs)set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i)=>x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [\n        []\n    ];\n    for(let i = 0; i < array.length; i++){\n        for(let j = 0, e = sets.length; j < e; j++){\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b)=>b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single level—wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.configure({props: [\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n]})\n```\n*/ function styleTags(spec) {\n    let byName = Object.create(null);\n    for(let prop in spec){\n        let tags = spec[prop];\n        if (!Array.isArray(tags)) tags = [\n            tags\n        ];\n        for (let part of prop.split(\" \"))if (part) {\n            let pieces = [], mode = 2 /* Mode.Normal */ , rest = part;\n            for(let pos = 0;;){\n                if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                    mode = 1 /* Mode.Inherit */ ;\n                    break;\n                }\n                let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                if (!m) throw new RangeError(\"Invalid path: \" + part);\n                pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                pos += m[0].length;\n                if (pos == part.length) break;\n                let next = part[pos++];\n                if (pos == part.length && next == \"!\") {\n                    mode = 0 /* Mode.Opaque */ ;\n                    break;\n                }\n                if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n                rest = part.slice(pos);\n            }\n            let last = pieces.length - 1, inner = pieces[last];\n            if (!inner) throw new RangeError(\"Invalid path: \" + part);\n            let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n            byName[inner] = rule.sort(byName[inner]);\n        }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n    combine (a, b) {\n        let cur, root, take;\n        while(a || b){\n            if (!a || b && a.depth >= b.depth) {\n                take = b;\n                b = b.next;\n            } else {\n                take = a;\n                a = a.next;\n            }\n            if (cur && cur.mode == take.mode && !take.context && !cur.context) continue;\n            let copy = new Rule(take.tags, take.mode, take.context);\n            if (cur) cur.next = copy;\n            else root = copy;\n            cur = copy;\n        }\n        return root;\n    }\n});\nclass Rule {\n    constructor(tags, mode, context, next){\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() {\n        return this.mode == 0 /* Mode.Opaque */ ;\n    }\n    get inherit() {\n        return this.mode == 1 /* Mode.Inherit */ ;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() {\n        return this.context ? this.context.length : 0;\n    }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */ , null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/ function tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags){\n        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;\n        else for (let tag of style.tag)map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags)=>{\n            let cls = all;\n            for (let tag of tags){\n                for (let sub of tag.set){\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters){\n        let value = highlighter.style(tags);\n        if (value) result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/ function highlightTree(tree, highlighter, /**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/ putStyle, /**\nThe start of the range to highlight.\n*/ from = 0, /**\nThe end of the range.\n*/ to = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [\n        highlighter\n    ], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/ function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos) return;\n        for(let text = code.slice(pos, p), i = 0;;){\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i) putText(text.slice(i, upto), classes);\n            if (nextBreak < 0) break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes)=>{\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span){\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at) this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class) this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from) return;\n        if (type.isTop) highlighters = this.highlighters.filter((h)=>!h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls) cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */ ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque) return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter((h)=>!h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for(let i = 0, pos = start;; i++){\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while(cursor.from < rangeTo){\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n                    }\n                }\n                if (!next || nextPos > to) break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild) cursor.parent();\n        } else if (cursor.firstChild()) {\n            if (mounted) inheritedClass = \"\";\n            do {\n                if (cursor.to <= from) continue;\n                if (cursor.from >= to) break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            }while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/ function getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while(rule && rule.context && !node.matchContext(rule.context))rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an element—if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/ const tags = {\n    /**\n    A comment.\n    */ comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */ lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */ blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */ docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */ name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */ variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */ typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */ tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */ propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */ attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */ className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */ labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */ namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */ macroName: t(name),\n    /**\n    A literal value.\n    */ literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */ string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */ docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */ character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */ attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */ number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */ integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */ float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */ bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */ regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */ escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */ color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */ url: t(literal),\n    /**\n    A language keyword.\n    */ keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */ self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */ null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */ atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */ unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */ modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */ operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */ controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */ definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */ moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */ operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */ derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */ arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */ logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */ bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */ compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */ updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */ definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */ typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */ controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */ punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */ separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */ bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */ angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */ squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */ content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */ heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */ heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */ heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */ heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */ heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */ heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */ heading6: t(heading),\n    /**\n    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).\n    */ contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */ list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */ quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */ emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */ strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */ link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */ monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */ strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */ inserted: t(),\n    /**\n    Deleted text.\n    */ deleted: t(),\n    /**\n    Changed text.\n    */ changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */ invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */ meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */ documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */ annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */ processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */ definition: Tag.defineModifier(\"definition\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */ constant: Tag.defineModifier(\"constant\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */ function: Tag.defineModifier(\"function\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */ standard: Tag.defineModifier(\"standard\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */ local: Tag.defineModifier(\"local\"),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */ special: Tag.defineModifier(\"special\")\n};\nfor(let name in tags){\n    let val = tags[name];\n    if (val instanceof Tag) val.name = name;\n}\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/ const classHighlighter = tagHighlighter([\n    {\n        tag: tags.link,\n        class: \"tok-link\"\n    },\n    {\n        tag: tags.heading,\n        class: \"tok-heading\"\n    },\n    {\n        tag: tags.emphasis,\n        class: \"tok-emphasis\"\n    },\n    {\n        tag: tags.strong,\n        class: \"tok-strong\"\n    },\n    {\n        tag: tags.keyword,\n        class: \"tok-keyword\"\n    },\n    {\n        tag: tags.atom,\n        class: \"tok-atom\"\n    },\n    {\n        tag: tags.bool,\n        class: \"tok-bool\"\n    },\n    {\n        tag: tags.url,\n        class: \"tok-url\"\n    },\n    {\n        tag: tags.labelName,\n        class: \"tok-labelName\"\n    },\n    {\n        tag: tags.inserted,\n        class: \"tok-inserted\"\n    },\n    {\n        tag: tags.deleted,\n        class: \"tok-deleted\"\n    },\n    {\n        tag: tags.literal,\n        class: \"tok-literal\"\n    },\n    {\n        tag: tags.string,\n        class: \"tok-string\"\n    },\n    {\n        tag: tags.number,\n        class: \"tok-number\"\n    },\n    {\n        tag: [\n            tags.regexp,\n            tags.escape,\n            tags.special(tags.string)\n        ],\n        class: \"tok-string2\"\n    },\n    {\n        tag: tags.variableName,\n        class: \"tok-variableName\"\n    },\n    {\n        tag: tags.local(tags.variableName),\n        class: \"tok-variableName tok-local\"\n    },\n    {\n        tag: tags.definition(tags.variableName),\n        class: \"tok-variableName tok-definition\"\n    },\n    {\n        tag: tags.special(tags.variableName),\n        class: \"tok-variableName2\"\n    },\n    {\n        tag: tags.definition(tags.propertyName),\n        class: \"tok-propertyName tok-definition\"\n    },\n    {\n        tag: tags.typeName,\n        class: \"tok-typeName\"\n    },\n    {\n        tag: tags.namespace,\n        class: \"tok-namespace\"\n    },\n    {\n        tag: tags.className,\n        class: \"tok-className\"\n    },\n    {\n        tag: tags.macroName,\n        class: \"tok-macroName\"\n    },\n    {\n        tag: tags.propertyName,\n        class: \"tok-propertyName\"\n    },\n    {\n        tag: tags.operator,\n        class: \"tok-operator\"\n    },\n    {\n        tag: tags.comment,\n        class: \"tok-comment\"\n    },\n    {\n        tag: tags.meta,\n        class: \"tok-meta\"\n    },\n    {\n        tag: tags.invalid,\n        class: \"tok-invalid\"\n    },\n    {\n        tag: tags.punctuation,\n        class: \"tok-punctuation\"\n    }\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxlemVyK2hpZ2hsaWdodEAxLjIuMy9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUV6QyxJQUFJQyxZQUFZO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0FDLFlBQ0E7O0lBRUEsR0FDQUMsSUFBSSxFQUNKOzs7SUFHQSxHQUNBQyxHQUFHLEVBQ0g7OztJQUdBLEdBQ0FDLElBQUksRUFDSjs7SUFFQSxHQUNBQyxRQUFRLENBQUU7UUFDTixJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEI7O1FBRUEsR0FDQSxJQUFJLENBQUNDLEVBQUUsR0FBR1A7SUFDZDtJQUNBUSxXQUFXO1FBQ1AsSUFBSSxFQUFFTCxJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQ25CLEtBQUssSUFBSU0sT0FBTyxJQUFJLENBQUNILFFBQVEsQ0FDekIsSUFBSUcsSUFBSU4sSUFBSSxFQUNSQSxPQUFPLENBQUMsRUFBRU0sSUFBSU4sSUFBSSxDQUFDLENBQUMsRUFBRUEsS0FBSyxDQUFDLENBQUM7UUFDckMsT0FBT0E7SUFDWDtJQUNBLE9BQU9PLE9BQU9DLFlBQVksRUFBRUMsTUFBTSxFQUFFO1FBQ2hDLElBQUlULE9BQU8sT0FBT1EsZ0JBQWdCLFdBQVdBLGVBQWU7UUFDNUQsSUFBSUEsd0JBQXdCVixLQUN4QlcsU0FBU0Q7UUFDYixJQUFJQyxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT1AsSUFBSSxFQUMzRCxNQUFNLElBQUlRLE1BQU07UUFDcEIsSUFBSUMsTUFBTSxJQUFJYixJQUFJRSxNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUU7UUFDcENXLElBQUlWLEdBQUcsQ0FBQ1csSUFBSSxDQUFDRDtRQUNiLElBQUlGLFFBQ0EsS0FBSyxJQUFJSSxLQUFLSixPQUFPUixHQUFHLENBQ3BCVSxJQUFJVixHQUFHLENBQUNXLElBQUksQ0FBQ0M7UUFDckIsT0FBT0Y7SUFDWDtJQUNBOzs7Ozs7Ozs7OztJQVdBLEdBQ0EsT0FBT0csZUFBZWQsSUFBSSxFQUFFO1FBQ3hCLElBQUlNLE1BQU0sSUFBSVMsU0FBU2Y7UUFDdkIsT0FBTyxDQUFDVztZQUNKLElBQUlBLElBQUlSLFFBQVEsQ0FBQ2EsT0FBTyxDQUFDVixPQUFPLENBQUMsR0FDN0IsT0FBT0s7WUFDWCxPQUFPSSxTQUFTRSxHQUFHLENBQUNOLElBQUlULElBQUksSUFBSVMsS0FBS0EsSUFBSVIsUUFBUSxDQUFDZSxNQUFNLENBQUNaLEtBQUthLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFaEIsRUFBRSxHQUFHaUIsRUFBRWpCLEVBQUU7UUFDNUY7SUFDSjtBQUNKO0FBQ0EsSUFBSWtCLGlCQUFpQjtBQUNyQixNQUFNUDtJQUNGaEIsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDdUIsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDbkIsRUFBRSxHQUFHa0I7SUFDZDtJQUNBLE9BQU9MLElBQUlmLElBQUksRUFBRXNCLElBQUksRUFBRTtRQUNuQixJQUFJLENBQUNBLEtBQUtDLE1BQU0sRUFDWixPQUFPdkI7UUFDWCxJQUFJd0IsU0FBU0YsSUFBSSxDQUFDLEVBQUUsQ0FBQ0QsU0FBUyxDQUFDSSxJQUFJLENBQUNkLENBQUFBLElBQUtBLEVBQUVYLElBQUksSUFBSUEsUUFBUTBCLFVBQVVKLE1BQU1YLEVBQUVWLFFBQVE7UUFDckYsSUFBSXVCLFFBQ0EsT0FBT0E7UUFDWCxJQUFJekIsTUFBTSxFQUFFLEVBQUVVLE1BQU0sSUFBSWIsSUFBSUksS0FBS0YsSUFBSSxFQUFFQyxLQUFLQyxNQUFNc0I7UUFDbEQsS0FBSyxJQUFJSyxLQUFLTCxLQUNWSyxFQUFFTixTQUFTLENBQUNYLElBQUksQ0FBQ0Q7UUFDckIsSUFBSW1CLFVBQVVDLFNBQVNQO1FBQ3ZCLEtBQUssSUFBSWYsVUFBVVAsS0FBS0QsR0FBRyxDQUN2QixJQUFJLENBQUNRLE9BQU9OLFFBQVEsQ0FBQ3NCLE1BQU0sRUFDdkIsS0FBSyxJQUFJTyxVQUFVRixRQUNmN0IsSUFBSVcsSUFBSSxDQUFDRyxTQUFTRSxHQUFHLENBQUNSLFFBQVF1QjtRQUMxQyxPQUFPckI7SUFDWDtBQUNKO0FBQ0EsU0FBU2lCLFVBQVVSLENBQUMsRUFBRUMsQ0FBQztJQUNuQixPQUFPRCxFQUFFSyxNQUFNLElBQUlKLEVBQUVJLE1BQU0sSUFBSUwsRUFBRWEsS0FBSyxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEtBQUtiLENBQUMsQ0FBQ2MsRUFBRTtBQUM5RDtBQUNBLFNBQVNKLFNBQVNLLEtBQUs7SUFDbkIsSUFBSUMsT0FBTztRQUFDLEVBQUU7S0FBQztJQUNmLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJQyxNQUFNWCxNQUFNLEVBQUVVLElBQUs7UUFDbkMsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLElBQUlGLEtBQUtaLE1BQU0sRUFBRWEsSUFBSUMsR0FBR0QsSUFBSztZQUN6Q0QsS0FBS3pCLElBQUksQ0FBQ3lCLElBQUksQ0FBQ0MsRUFBRSxDQUFDcEIsTUFBTSxDQUFDa0IsS0FBSyxDQUFDRCxFQUFFO1FBQ3JDO0lBQ0o7SUFDQSxPQUFPRSxLQUFLbEIsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVJLE1BQU0sR0FBR0wsRUFBRUssTUFBTTtBQUNsRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtEQSxHQUNBLFNBQVNlLFVBQVVDLElBQUk7SUFDbkIsSUFBSUMsU0FBU0MsT0FBT0MsTUFBTSxDQUFDO0lBQzNCLElBQUssSUFBSUMsUUFBUUosS0FBTTtRQUNuQixJQUFJSyxPQUFPTCxJQUFJLENBQUNJLEtBQUs7UUFDckIsSUFBSSxDQUFDRSxNQUFNQyxPQUFPLENBQUNGLE9BQ2ZBLE9BQU87WUFBQ0E7U0FBSztRQUNqQixLQUFLLElBQUlHLFFBQVFKLEtBQUtLLEtBQUssQ0FBQyxLQUN4QixJQUFJRCxNQUFNO1lBQ04sSUFBSUUsU0FBUyxFQUFFLEVBQUVDLE9BQU8sRUFBRSxlQUFlLEtBQUlDLE9BQU9KO1lBQ3BELElBQUssSUFBSUssTUFBTSxJQUFLO2dCQUNoQixJQUFJRCxRQUFRLFNBQVNDLE1BQU0sS0FBS0EsTUFBTSxLQUFLTCxLQUFLeEIsTUFBTSxFQUFFO29CQUNwRDJCLE9BQU8sRUFBRSxnQkFBZ0I7b0JBQ3pCO2dCQUNKO2dCQUNBLElBQUl2QixJQUFJLDhCQUE4QjBCLElBQUksQ0FBQ0Y7Z0JBQzNDLElBQUksQ0FBQ3hCLEdBQ0QsTUFBTSxJQUFJMkIsV0FBVyxtQkFBbUJQO2dCQUM1Q0UsT0FBT3ZDLElBQUksQ0FBQ2lCLENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTSxLQUFLQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxNQUFNNEIsS0FBS0MsS0FBSyxDQUFDN0IsQ0FBQyxDQUFDLEVBQUUsSUFBSUEsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3ZFeUIsT0FBT3pCLENBQUMsQ0FBQyxFQUFFLENBQUNKLE1BQU07Z0JBQ2xCLElBQUk2QixPQUFPTCxLQUFLeEIsTUFBTSxFQUNsQjtnQkFDSixJQUFJa0MsT0FBT1YsSUFBSSxDQUFDSyxNQUFNO2dCQUN0QixJQUFJQSxPQUFPTCxLQUFLeEIsTUFBTSxJQUFJa0MsUUFBUSxLQUFLO29CQUNuQ1AsT0FBTyxFQUFFLGVBQWU7b0JBQ3hCO2dCQUNKO2dCQUNBLElBQUlPLFFBQVEsS0FDUixNQUFNLElBQUlILFdBQVcsbUJBQW1CUDtnQkFDNUNJLE9BQU9KLEtBQUtXLEtBQUssQ0FBQ047WUFDdEI7WUFDQSxJQUFJTyxPQUFPVixPQUFPMUIsTUFBTSxHQUFHLEdBQUdxQyxRQUFRWCxNQUFNLENBQUNVLEtBQUs7WUFDbEQsSUFBSSxDQUFDQyxPQUNELE1BQU0sSUFBSU4sV0FBVyxtQkFBbUJQO1lBQzVDLElBQUljLE9BQU8sSUFBSUMsS0FBS2xCLE1BQU1NLE1BQU1TLE9BQU8sSUFBSVYsT0FBT1MsS0FBSyxDQUFDLEdBQUdDLFFBQVE7WUFDbkVuQixNQUFNLENBQUNvQixNQUFNLEdBQUdDLEtBQUs1QyxJQUFJLENBQUN1QixNQUFNLENBQUNvQixNQUFNO1FBQzNDO0lBQ1I7SUFDQSxPQUFPRyxhQUFhQyxHQUFHLENBQUN4QjtBQUM1QjtBQUNBLE1BQU11QixlQUFlLElBQUlyRSxtREFBUUEsQ0FBQztJQUM5QnVFLFNBQVEvQyxDQUFDLEVBQUVDLENBQUM7UUFDUixJQUFJK0MsS0FBS0MsTUFBTUM7UUFDZixNQUFPbEQsS0FBS0MsRUFBRztZQUNYLElBQUksQ0FBQ0QsS0FBS0MsS0FBS0QsRUFBRW1ELEtBQUssSUFBSWxELEVBQUVrRCxLQUFLLEVBQUU7Z0JBQy9CRCxPQUFPakQ7Z0JBQ1BBLElBQUlBLEVBQUVzQyxJQUFJO1lBQ2QsT0FDSztnQkFDRFcsT0FBT2xEO2dCQUNQQSxJQUFJQSxFQUFFdUMsSUFBSTtZQUNkO1lBQ0EsSUFBSVMsT0FBT0EsSUFBSWhCLElBQUksSUFBSWtCLEtBQUtsQixJQUFJLElBQUksQ0FBQ2tCLEtBQUtFLE9BQU8sSUFBSSxDQUFDSixJQUFJSSxPQUFPLEVBQzdEO1lBQ0osSUFBSUMsT0FBTyxJQUFJVCxLQUFLTSxLQUFLeEIsSUFBSSxFQUFFd0IsS0FBS2xCLElBQUksRUFBRWtCLEtBQUtFLE9BQU87WUFDdEQsSUFBSUosS0FDQUEsSUFBSVQsSUFBSSxHQUFHYztpQkFFWEosT0FBT0k7WUFDWEwsTUFBTUs7UUFDVjtRQUNBLE9BQU9KO0lBQ1g7QUFDSjtBQUNBLE1BQU1MO0lBQ0ZqRSxZQUFZK0MsSUFBSSxFQUFFTSxJQUFJLEVBQUVvQixPQUFPLEVBQUViLElBQUksQ0FBRTtRQUNuQyxJQUFJLENBQUNiLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNNLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNvQixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDYixJQUFJLEdBQUdBO0lBQ2hCO0lBQ0EsSUFBSWUsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDdEIsSUFBSSxJQUFJLEVBQUUsZUFBZTtJQUFJO0lBQ3hELElBQUl1QixVQUFVO1FBQUUsT0FBTyxJQUFJLENBQUN2QixJQUFJLElBQUksRUFBRSxnQkFBZ0I7SUFBSTtJQUMxRGpDLEtBQUt5RCxLQUFLLEVBQUU7UUFDUixJQUFJLENBQUNBLFNBQVNBLE1BQU1MLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssRUFBRTtZQUNwQyxJQUFJLENBQUNaLElBQUksR0FBR2lCO1lBQ1osT0FBTyxJQUFJO1FBQ2Y7UUFDQUEsTUFBTWpCLElBQUksR0FBRyxJQUFJLENBQUN4QyxJQUFJLENBQUN5RCxNQUFNakIsSUFBSTtRQUNqQyxPQUFPaUI7SUFDWDtJQUNBLElBQUlMLFFBQVE7UUFBRSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDL0MsTUFBTSxHQUFHO0lBQUc7QUFDakU7QUFDQXVDLEtBQUthLEtBQUssR0FBRyxJQUFJYixLQUFLLEVBQUUsRUFBRSxFQUFFLGVBQWUsS0FBSTtBQUMvQzs7OztBQUlBLEdBQ0EsU0FBU2MsZUFBZWhDLElBQUksRUFBRWlDLE9BQU87SUFDakMsSUFBSUMsTUFBTXJDLE9BQU9DLE1BQU0sQ0FBQztJQUN4QixLQUFLLElBQUlxQyxTQUFTbkMsS0FBTTtRQUNwQixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ2lDLE1BQU10RSxHQUFHLEdBQ3hCcUUsR0FBRyxDQUFDQyxNQUFNdEUsR0FBRyxDQUFDUCxFQUFFLENBQUMsR0FBRzZFLE1BQU1DLEtBQUs7YUFFL0IsS0FBSyxJQUFJdkUsT0FBT3NFLE1BQU10RSxHQUFHLENBQ3JCcUUsR0FBRyxDQUFDckUsSUFBSVAsRUFBRSxDQUFDLEdBQUc2RSxNQUFNQyxLQUFLO0lBQ3JDO0lBQ0EsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sSUFBSSxFQUFFLEdBQUdMLFdBQVcsQ0FBQztJQUN4QyxPQUFPO1FBQ0hFLE9BQU8sQ0FBQ25DO1lBQ0osSUFBSXVDLE1BQU1EO1lBQ1YsS0FBSyxJQUFJekUsT0FBT21DLEtBQU07Z0JBQ2xCLEtBQUssSUFBSXdDLE9BQU8zRSxJQUFJVixHQUFHLENBQUU7b0JBQ3JCLElBQUlzRixXQUFXUCxHQUFHLENBQUNNLElBQUlsRixFQUFFLENBQUM7b0JBQzFCLElBQUltRixVQUFVO3dCQUNWRixNQUFNQSxNQUFNQSxNQUFNLE1BQU1FLFdBQVdBO3dCQUNuQztvQkFDSjtnQkFDSjtZQUNKO1lBQ0EsT0FBT0Y7UUFDWDtRQUNBRjtJQUNKO0FBQ0o7QUFDQSxTQUFTSyxjQUFjQyxZQUFZLEVBQUUzQyxJQUFJO0lBQ3JDLElBQUk0QyxTQUFTO0lBQ2IsS0FBSyxJQUFJQyxlQUFlRixhQUFjO1FBQ2xDLElBQUlHLFFBQVFELFlBQVlWLEtBQUssQ0FBQ25DO1FBQzlCLElBQUk4QyxPQUNBRixTQUFTQSxTQUFTQSxTQUFTLE1BQU1FLFFBQVFBO0lBQ2pEO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU0csY0FBY0MsSUFBSSxFQUFFSCxXQUFXLEVBQ3hDOzs7O0FBSUEsR0FDQUksUUFBUSxFQUNSOztBQUVBLEdBQ0FDLE9BQU8sQ0FBQyxFQUNSOztBQUVBLEdBQ0FDLEtBQUtILEtBQUtyRSxNQUFNO0lBQ1osSUFBSXlFLFVBQVUsSUFBSUMsaUJBQWlCSCxNQUFNakQsTUFBTUMsT0FBTyxDQUFDMkMsZUFBZUEsY0FBYztRQUFDQTtLQUFZLEVBQUVJO0lBQ25HRyxRQUFRRSxjQUFjLENBQUNOLEtBQUtPLE1BQU0sSUFBSUwsTUFBTUMsSUFBSSxJQUFJQyxRQUFRVCxZQUFZO0lBQ3hFUyxRQUFRSSxLQUFLLENBQUNMO0FBQ2xCO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTTSxjQUFjQyxJQUFJLEVBQUVWLElBQUksRUFBRUgsV0FBVyxFQUFFYyxPQUFPLEVBQUVDLFFBQVEsRUFBRVYsT0FBTyxDQUFDLEVBQUVDLEtBQUtPLEtBQUsvRSxNQUFNO0lBQ3pGLElBQUk2QixNQUFNMEM7SUFDVixTQUFTVyxRQUFRQyxDQUFDLEVBQUVDLE9BQU87UUFDdkIsSUFBSUQsS0FBS3RELEtBQ0w7UUFDSixJQUFLLElBQUl3RCxPQUFPTixLQUFLNUMsS0FBSyxDQUFDTixLQUFLc0QsSUFBSXpFLElBQUksSUFBSztZQUN6QyxJQUFJNEUsWUFBWUQsS0FBSzlGLE9BQU8sQ0FBQyxNQUFNbUI7WUFDbkMsSUFBSTZFLE9BQU9ELFlBQVksSUFBSUQsS0FBS3JGLE1BQU0sR0FBR3NGO1lBQ3pDLElBQUlDLE9BQU83RSxHQUNQc0UsUUFBUUssS0FBS2xELEtBQUssQ0FBQ3pCLEdBQUc2RSxPQUFPSDtZQUNqQyxJQUFJRSxZQUFZLEdBQ1o7WUFDSkw7WUFDQXZFLElBQUk0RSxZQUFZO1FBQ3BCO1FBQ0F6RCxNQUFNc0Q7SUFDVjtJQUNBZixjQUFjQyxNQUFNSCxhQUFhLENBQUNLLE1BQU1DLElBQUlZO1FBQ3hDRixRQUFRWCxNQUFNO1FBQ2RXLFFBQVFWLElBQUlZO0lBQ2hCLEdBQUdiLE1BQU1DO0lBQ1RVLFFBQVFWLElBQUk7QUFDaEI7QUFDQSxNQUFNRTtJQUNGcEcsWUFBWWtILEVBQUUsRUFBRXhCLFlBQVksRUFBRXlCLElBQUksQ0FBRTtRQUNoQyxJQUFJLENBQUNELEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUN4QixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ3lCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNoQyxLQUFLLEdBQUc7SUFDakI7SUFDQWlDLFVBQVVGLEVBQUUsRUFBRTVCLEdBQUcsRUFBRTtRQUNmLElBQUlBLE9BQU8sSUFBSSxDQUFDSCxLQUFLLEVBQUU7WUFDbkIsSUFBSSxDQUFDb0IsS0FBSyxDQUFDVztZQUNYLElBQUlBLEtBQUssSUFBSSxDQUFDQSxFQUFFLEVBQ1osSUFBSSxDQUFDQSxFQUFFLEdBQUdBO1lBQ2QsSUFBSSxDQUFDL0IsS0FBSyxHQUFHRztRQUNqQjtJQUNKO0lBQ0FpQixNQUFNTCxFQUFFLEVBQUU7UUFDTixJQUFJQSxLQUFLLElBQUksQ0FBQ2dCLEVBQUUsSUFBSSxJQUFJLENBQUMvQixLQUFLLEVBQzFCLElBQUksQ0FBQ2dDLElBQUksQ0FBQyxJQUFJLENBQUNELEVBQUUsRUFBRWhCLElBQUksSUFBSSxDQUFDZixLQUFLO0lBQ3pDO0lBQ0FrQixlQUFlQyxNQUFNLEVBQUVMLElBQUksRUFBRUMsRUFBRSxFQUFFbUIsY0FBYyxFQUFFM0IsWUFBWSxFQUFFO1FBQzNELElBQUksRUFBRTRCLElBQUksRUFBRXJCLE1BQU1zQixLQUFLLEVBQUVyQixJQUFJc0IsR0FBRyxFQUFFLEdBQUdsQjtRQUNyQyxJQUFJaUIsU0FBU3JCLE1BQU1zQixPQUFPdkIsTUFDdEI7UUFDSixJQUFJcUIsS0FBS0csS0FBSyxFQUNWL0IsZUFBZSxJQUFJLENBQUNBLFlBQVksQ0FBQ2dDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBSyxDQUFDQSxFQUFFdkMsS0FBSyxJQUFJdUMsRUFBRXZDLEtBQUssQ0FBQ2tDO1FBQ3JFLElBQUloQyxNQUFNK0I7UUFDVixJQUFJckQsT0FBTzRELGFBQWF0QixXQUFXckMsS0FBS2EsS0FBSztRQUM3QyxJQUFJK0MsU0FBU3BDLGNBQWNDLGNBQWMxQixLQUFLakIsSUFBSTtRQUNsRCxJQUFJOEUsUUFBUTtZQUNSLElBQUl2QyxLQUNBQSxPQUFPO1lBQ1hBLE9BQU91QztZQUNQLElBQUk3RCxLQUFLWCxJQUFJLElBQUksRUFBRSxnQkFBZ0IsS0FDL0JnRSxrQkFBa0IsQ0FBQ0EsaUJBQWlCLE1BQU0sRUFBQyxJQUFLUTtRQUN4RDtRQUNBLElBQUksQ0FBQ1QsU0FBUyxDQUFDVSxLQUFLQyxHQUFHLENBQUM5QixNQUFNc0IsUUFBUWpDO1FBQ3RDLElBQUl0QixLQUFLVyxNQUFNLEVBQ1g7UUFDSixJQUFJcUQsVUFBVTFCLE9BQU9QLElBQUksSUFBSU8sT0FBT1AsSUFBSSxDQUFDakQsSUFBSSxDQUFDakQsbURBQVFBLENBQUNtSSxPQUFPO1FBQzlELElBQUlBLFdBQVdBLFFBQVFDLE9BQU8sRUFBRTtZQUM1QixJQUFJbEUsUUFBUXVDLE9BQU80QixJQUFJLENBQUNDLEtBQUssQ0FBQ0gsUUFBUUMsT0FBTyxDQUFDLEVBQUUsQ0FBQ2hDLElBQUksR0FBR3NCLE9BQU87WUFDL0QsSUFBSWEsb0JBQW9CLElBQUksQ0FBQzFDLFlBQVksQ0FBQ2dDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBSyxDQUFDQSxFQUFFdkMsS0FBSyxJQUFJdUMsRUFBRXZDLEtBQUssQ0FBQzRDLFFBQVFqQyxJQUFJLENBQUN1QixJQUFJO1lBQzNGLElBQUllLFdBQVcvQixPQUFPZ0MsVUFBVTtZQUNoQyxJQUFLLElBQUlsRyxJQUFJLEdBQUdtQixNQUFNZ0UsUUFBUW5GLElBQUs7Z0JBQy9CLElBQUl3QixPQUFPeEIsSUFBSTRGLFFBQVFDLE9BQU8sQ0FBQ3ZHLE1BQU0sR0FBR3NHLFFBQVFDLE9BQU8sQ0FBQzdGLEVBQUUsR0FBRztnQkFDN0QsSUFBSW1HLFVBQVUzRSxPQUFPQSxLQUFLcUMsSUFBSSxHQUFHc0IsUUFBUUM7Z0JBQ3pDLElBQUlnQixZQUFZVixLQUFLQyxHQUFHLENBQUM5QixNQUFNMUMsTUFBTWtGLFVBQVVYLEtBQUtZLEdBQUcsQ0FBQ3hDLElBQUlxQztnQkFDNUQsSUFBSUMsWUFBWUMsV0FBV0osVUFBVTtvQkFDakMsTUFBTy9CLE9BQU9MLElBQUksR0FBR3dDLFFBQVM7d0JBQzFCLElBQUksQ0FBQ3BDLGNBQWMsQ0FBQ0MsUUFBUWtDLFdBQVdDLFNBQVNwQixnQkFBZ0IzQjt3QkFDaEUsSUFBSSxDQUFDMEIsU0FBUyxDQUFDVSxLQUFLWSxHQUFHLENBQUNELFNBQVNuQyxPQUFPSixFQUFFLEdBQUdaO3dCQUM3QyxJQUFJZ0IsT0FBT0osRUFBRSxJQUFJcUMsV0FBVyxDQUFDakMsT0FBT3FDLFdBQVcsSUFDM0M7b0JBQ1I7Z0JBQ0o7Z0JBQ0EsSUFBSSxDQUFDL0UsUUFBUTJFLFVBQVVyQyxJQUNuQjtnQkFDSjNDLE1BQU1LLEtBQUtzQyxFQUFFLEdBQUdxQjtnQkFDaEIsSUFBSWhFLE1BQU0wQyxNQUFNO29CQUNaLElBQUksQ0FBQ0ksY0FBYyxDQUFDdEMsTUFBTXVDLE1BQU0sSUFBSXdCLEtBQUtDLEdBQUcsQ0FBQzlCLE1BQU1yQyxLQUFLcUMsSUFBSSxHQUFHc0IsUUFBUU8sS0FBS1ksR0FBRyxDQUFDeEMsSUFBSTNDLE1BQU0sSUFBSTZFO29CQUM5RixJQUFJLENBQUNoQixTQUFTLENBQUNVLEtBQUtZLEdBQUcsQ0FBQ3hDLElBQUkzQyxNQUFNK0I7Z0JBQ3RDO1lBQ0o7WUFDQSxJQUFJK0MsVUFDQS9CLE9BQU81RixNQUFNO1FBQ3JCLE9BQ0ssSUFBSTRGLE9BQU9nQyxVQUFVLElBQUk7WUFDMUIsSUFBSU4sU0FDQVgsaUJBQWlCO1lBQ3JCLEdBQUc7Z0JBQ0MsSUFBSWYsT0FBT0osRUFBRSxJQUFJRCxNQUNiO2dCQUNKLElBQUlLLE9BQU9MLElBQUksSUFBSUMsSUFDZjtnQkFDSixJQUFJLENBQUNHLGNBQWMsQ0FBQ0MsUUFBUUwsTUFBTUMsSUFBSW1CLGdCQUFnQjNCO2dCQUN0RCxJQUFJLENBQUMwQixTQUFTLENBQUNVLEtBQUtZLEdBQUcsQ0FBQ3hDLElBQUlJLE9BQU9KLEVBQUUsR0FBR1o7WUFDNUMsUUFBU2dCLE9BQU9xQyxXQUFXLElBQUk7WUFDL0JyQyxPQUFPNUYsTUFBTTtRQUNqQjtJQUNKO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsU0FBU2tILGFBQWFNLElBQUk7SUFDdEIsSUFBSWxFLE9BQU9rRSxLQUFLWixJQUFJLENBQUN4RSxJQUFJLENBQUNvQjtJQUMxQixNQUFPRixRQUFRQSxLQUFLUyxPQUFPLElBQUksQ0FBQ3lELEtBQUtVLFlBQVksQ0FBQzVFLEtBQUtTLE9BQU8sRUFDMURULE9BQU9BLEtBQUtKLElBQUk7SUFDcEIsT0FBT0ksUUFBUTtBQUNuQjtBQUNBLE1BQU1sRCxJQUFJZixJQUFJUyxNQUFNO0FBQ3BCLE1BQU1xSSxVQUFVL0gsS0FBS2IsT0FBT2EsS0FBS2dJLFdBQVdoSSxFQUFFYixPQUFPOEksZUFBZWpJLEVBQUViLE9BQU8rSSxVQUFVbEksS0FBS21JLFNBQVNuSSxFQUFFa0ksVUFBVUUsU0FBU3BJLEVBQUVrSSxVQUFVRyxVQUFVckksS0FBS3NJLFVBQVV0SSxFQUFFcUksVUFBVUUsVUFBVXZJLEtBQUt3SSxXQUFXeEksS0FBS3lJLGNBQWN6SSxLQUFLMEksVUFBVTFJLEVBQUV5SSxjQUFjRSxPQUFPM0k7QUFDOVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsR0FDQSxNQUFNaUMsT0FBTztJQUNUOztJQUVBLEdBQ0E4RjtJQUNBOztJQUVBLEdBQ0FhLGFBQWE1SSxFQUFFK0g7SUFDZjs7SUFFQSxHQUNBYyxjQUFjN0ksRUFBRStIO0lBQ2hCOztJQUVBLEdBQ0FlLFlBQVk5SSxFQUFFK0g7SUFDZDs7SUFFQSxHQUNBNUk7SUFDQTs7SUFFQSxHQUNBNEosY0FBYy9JLEVBQUViO0lBQ2hCOztJQUVBLEdBQ0E2SSxVQUFVQTtJQUNWOztJQUVBLEdBQ0FnQixTQUFTaEosRUFBRWdJO0lBQ1g7O0lBRUEsR0FDQUMsY0FBY0E7SUFDZDs7SUFFQSxHQUNBZ0IsZUFBZWpKLEVBQUVpSTtJQUNqQjs7SUFFQSxHQUNBaUIsV0FBV2xKLEVBQUViO0lBQ2I7O0lBRUEsR0FDQWdLLFdBQVduSixFQUFFYjtJQUNiOztJQUVBLEdBQ0FpSyxXQUFXcEosRUFBRWI7SUFDYjs7SUFFQSxHQUNBa0ssV0FBV3JKLEVBQUViO0lBQ2I7O0lBRUEsR0FDQStJO0lBQ0E7O0lBRUEsR0FDQUM7SUFDQTs7SUFFQSxHQUNBbUIsV0FBV3RKLEVBQUVtSTtJQUNiOztJQUVBLEdBQ0FvQixXQUFXdkosRUFBRW1JO0lBQ2I7O0lBRUEsR0FDQXFCLGdCQUFnQnhKLEVBQUVtSTtJQUNsQjs7SUFFQSxHQUNBQztJQUNBOztJQUVBLEdBQ0FxQixTQUFTekosRUFBRW9JO0lBQ1g7O0lBRUEsR0FDQXNCLE9BQU8xSixFQUFFb0k7SUFDVDs7SUFFQSxHQUNBdUIsTUFBTTNKLEVBQUVrSTtJQUNSOztJQUVBLEdBQ0EwQixRQUFRNUosRUFBRWtJO0lBQ1Y7OztJQUdBLEdBQ0EyQixRQUFRN0osRUFBRWtJO0lBQ1Y7O0lBRUEsR0FDQTRCLE9BQU85SixFQUFFa0k7SUFDVDs7SUFFQSxHQUNBNkIsS0FBSy9KLEVBQUVrSTtJQUNQOztJQUVBLEdBQ0FLO0lBQ0E7OztJQUdBLEdBQ0F5QixNQUFNaEssRUFBRXVJO0lBQ1I7O0lBRUEsR0FDQTBCLE1BQU1qSyxFQUFFdUk7SUFDUjs7SUFFQSxHQUNBMkIsTUFBTWxLLEVBQUV1STtJQUNSOztJQUVBLEdBQ0E0QixNQUFNbkssRUFBRXVJO0lBQ1I7O0lBRUEsR0FDQTZCLFVBQVVwSyxFQUFFdUk7SUFDWjs7SUFFQSxHQUNBOEIsaUJBQWlCckssRUFBRXVJO0lBQ25COztJQUVBLEdBQ0ErQixnQkFBZ0J0SyxFQUFFdUk7SUFDbEI7O0lBRUEsR0FDQWdDLG1CQUFtQnZLLEVBQUV1STtJQUNyQjs7O0lBR0EsR0FDQWlDLGVBQWV4SyxFQUFFdUk7SUFDakI7O0lBRUEsR0FDQUM7SUFDQTs7SUFFQSxHQUNBaUMsZUFBZXpLLEVBQUV3STtJQUNqQjs7SUFFQSxHQUNBa0Msb0JBQW9CMUssRUFBRXdJO0lBQ3RCOztJQUVBLEdBQ0FtQyxlQUFlM0ssRUFBRXdJO0lBQ2pCOztJQUVBLEdBQ0FvQyxpQkFBaUI1SyxFQUFFd0k7SUFDbkI7O0lBRUEsR0FDQXFDLGlCQUFpQjdLLEVBQUV3STtJQUNuQjs7SUFFQSxHQUNBc0MsZ0JBQWdCOUssRUFBRXdJO0lBQ2xCOztJQUVBLEdBQ0F1QyxvQkFBb0IvSyxFQUFFd0k7SUFDdEI7O0lBRUEsR0FDQXdDLGNBQWNoTCxFQUFFd0k7SUFDaEI7O0lBRUEsR0FDQXlDLGlCQUFpQmpMLEVBQUV3STtJQUNuQjs7SUFFQSxHQUNBQztJQUNBOzs7SUFHQSxHQUNBeUMsV0FBV2xMLEVBQUV5STtJQUNiOztJQUVBLEdBQ0FDO0lBQ0E7OztJQUdBLEdBQ0F5QyxjQUFjbkwsRUFBRTBJO0lBQ2hCOzs7SUFHQSxHQUNBMEMsZUFBZXBMLEVBQUUwSTtJQUNqQjs7O0lBR0EsR0FDQTJDLE9BQU9yTCxFQUFFMEk7SUFDVDs7O0lBR0EsR0FDQTRDLE9BQU90TCxFQUFFMEk7SUFDVDs7SUFFQSxHQUNBTDtJQUNBOztJQUVBLEdBQ0FDO0lBQ0E7O0lBRUEsR0FDQWlELFVBQVV2TCxFQUFFc0k7SUFDWjs7SUFFQSxHQUNBa0QsVUFBVXhMLEVBQUVzSTtJQUNaOztJQUVBLEdBQ0FtRCxVQUFVekwsRUFBRXNJO0lBQ1o7O0lBRUEsR0FDQW9ELFVBQVUxTCxFQUFFc0k7SUFDWjs7SUFFQSxHQUNBcUQsVUFBVTNMLEVBQUVzSTtJQUNaOztJQUVBLEdBQ0FzRCxVQUFVNUwsRUFBRXNJO0lBQ1o7O0lBRUEsR0FDQXVELGtCQUFrQjdMLEVBQUVxSTtJQUNwQjs7SUFFQSxHQUNBeUQsTUFBTTlMLEVBQUVxSTtJQUNSOztJQUVBLEdBQ0EwRCxPQUFPL0wsRUFBRXFJO0lBQ1Q7O0lBRUEsR0FDQTJELFVBQVVoTSxFQUFFcUk7SUFDWjs7SUFFQSxHQUNBNEQsUUFBUWpNLEVBQUVxSTtJQUNWOztJQUVBLEdBQ0E2RCxNQUFNbE0sRUFBRXFJO0lBQ1I7OztJQUdBLEdBQ0E4RCxXQUFXbk0sRUFBRXFJO0lBQ2I7OztJQUdBLEdBQ0ErRCxlQUFlcE0sRUFBRXFJO0lBQ2pCOztJQUVBLEdBQ0FnRSxVQUFVck07SUFDVjs7SUFFQSxHQUNBc00sU0FBU3RNO0lBQ1Q7O0lBRUEsR0FDQXVNLFNBQVN2TTtJQUNUOztJQUVBLEdBQ0F3TSxTQUFTeE07SUFDVDs7SUFFQSxHQUNBMkk7SUFDQTs7O0lBR0EsR0FDQThELGNBQWN6TSxFQUFFMkk7SUFDaEI7OztJQUdBLEdBQ0ErRCxZQUFZMU0sRUFBRTJJO0lBQ2Q7OztJQUdBLEdBQ0FnRSx1QkFBdUIzTSxFQUFFMkk7SUFDekI7Ozs7SUFJQSxHQUNBaUUsWUFBWTNOLElBQUlnQixjQUFjLENBQUM7SUFDL0I7Ozs7SUFJQSxHQUNBNE0sVUFBVTVOLElBQUlnQixjQUFjLENBQUM7SUFDN0I7Ozs7O0lBS0EsR0FDQTZNLFVBQVU3TixJQUFJZ0IsY0FBYyxDQUFDO0lBQzdCOzs7O0lBSUEsR0FDQThNLFVBQVU5TixJQUFJZ0IsY0FBYyxDQUFDO0lBQzdCOzs7SUFHQSxHQUNBK00sT0FBTy9OLElBQUlnQixjQUFjLENBQUM7SUFDMUI7Ozs7Ozs7SUFPQSxHQUNBZ04sU0FBU2hPLElBQUlnQixjQUFjLENBQUM7QUFDaEM7QUFDQSxJQUFLLElBQUlkLFFBQVE4QyxLQUFNO0lBQ25CLElBQUlpTCxNQUFNakwsSUFBSSxDQUFDOUMsS0FBSztJQUNwQixJQUFJK04sZUFBZWpPLEtBQ2ZpTyxJQUFJL04sSUFBSSxHQUFHQTtBQUNuQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDQSxHQUNBLE1BQU1nTyxtQkFBbUJsSixlQUFlO0lBQ3BDO1FBQUVuRSxLQUFLbUMsS0FBS2lLLElBQUk7UUFBRTdILE9BQU87SUFBVztJQUNwQztRQUFFdkUsS0FBS21DLEtBQUtxRyxPQUFPO1FBQUVqRSxPQUFPO0lBQWM7SUFDMUM7UUFBRXZFLEtBQUttQyxLQUFLK0osUUFBUTtRQUFFM0gsT0FBTztJQUFlO0lBQzVDO1FBQUV2RSxLQUFLbUMsS0FBS2dLLE1BQU07UUFBRTVILE9BQU87SUFBYTtJQUN4QztRQUFFdkUsS0FBS21DLEtBQUtzRyxPQUFPO1FBQUVsRSxPQUFPO0lBQWM7SUFDMUM7UUFBRXZFLEtBQUttQyxLQUFLaUksSUFBSTtRQUFFN0YsT0FBTztJQUFXO0lBQ3BDO1FBQUV2RSxLQUFLbUMsS0FBSzBILElBQUk7UUFBRXRGLE9BQU87SUFBVztJQUNwQztRQUFFdkUsS0FBS21DLEtBQUs4SCxHQUFHO1FBQUUxRixPQUFPO0lBQVU7SUFDbEM7UUFBRXZFLEtBQUttQyxLQUFLa0gsU0FBUztRQUFFOUUsT0FBTztJQUFnQjtJQUM5QztRQUFFdkUsS0FBS21DLEtBQUtvSyxRQUFRO1FBQUVoSSxPQUFPO0lBQWU7SUFDNUM7UUFBRXZFLEtBQUttQyxLQUFLcUssT0FBTztRQUFFakksT0FBTztJQUFjO0lBQzFDO1FBQUV2RSxLQUFLbUMsS0FBS2lHLE9BQU87UUFBRTdELE9BQU87SUFBYztJQUMxQztRQUFFdkUsS0FBS21DLEtBQUtrRyxNQUFNO1FBQUU5RCxPQUFPO0lBQWE7SUFDeEM7UUFBRXZFLEtBQUttQyxLQUFLbUcsTUFBTTtRQUFFL0QsT0FBTztJQUFhO0lBQ3hDO1FBQUV2RSxLQUFLO1lBQUNtQyxLQUFLMkgsTUFBTTtZQUFFM0gsS0FBSzRILE1BQU07WUFBRTVILEtBQUtnTCxPQUFPLENBQUNoTCxLQUFLa0csTUFBTTtTQUFFO1FBQUU5RCxPQUFPO0lBQWM7SUFDbkY7UUFBRXZFLEtBQUttQyxLQUFLOEcsWUFBWTtRQUFFMUUsT0FBTztJQUFtQjtJQUNwRDtRQUFFdkUsS0FBS21DLEtBQUsrSyxLQUFLLENBQUMvSyxLQUFLOEcsWUFBWTtRQUFHMUUsT0FBTztJQUE2QjtJQUMxRTtRQUFFdkUsS0FBS21DLEtBQUsySyxVQUFVLENBQUMzSyxLQUFLOEcsWUFBWTtRQUFHMUUsT0FBTztJQUFrQztJQUNwRjtRQUFFdkUsS0FBS21DLEtBQUtnTCxPQUFPLENBQUNoTCxLQUFLOEcsWUFBWTtRQUFHMUUsT0FBTztJQUFvQjtJQUNuRTtRQUFFdkUsS0FBS21DLEtBQUsySyxVQUFVLENBQUMzSyxLQUFLZ0csWUFBWTtRQUFHNUQsT0FBTztJQUFrQztJQUNwRjtRQUFFdkUsS0FBS21DLEtBQUsrRixRQUFRO1FBQUUzRCxPQUFPO0lBQWU7SUFDNUM7UUFBRXZFLEtBQUttQyxLQUFLbUgsU0FBUztRQUFFL0UsT0FBTztJQUFnQjtJQUM5QztRQUFFdkUsS0FBS21DLEtBQUtpSCxTQUFTO1FBQUU3RSxPQUFPO0lBQWdCO0lBQzlDO1FBQUV2RSxLQUFLbUMsS0FBS29ILFNBQVM7UUFBRWhGLE9BQU87SUFBZ0I7SUFDOUM7UUFBRXZFLEtBQUttQyxLQUFLZ0csWUFBWTtRQUFFNUQsT0FBTztJQUFtQjtJQUNwRDtRQUFFdkUsS0FBS21DLEtBQUt1RyxRQUFRO1FBQUVuRSxPQUFPO0lBQWU7SUFDNUM7UUFBRXZFLEtBQUttQyxLQUFLOEYsT0FBTztRQUFFMUQsT0FBTztJQUFjO0lBQzFDO1FBQUV2RSxLQUFLbUMsS0FBSzBHLElBQUk7UUFBRXRFLE9BQU87SUFBVztJQUNwQztRQUFFdkUsS0FBS21DLEtBQUt1SyxPQUFPO1FBQUVuSSxPQUFPO0lBQWM7SUFDMUM7UUFBRXZFLEtBQUttQyxLQUFLd0csV0FBVztRQUFFcEUsT0FBTztJQUFrQjtDQUNyRDtBQUU2RyIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXplcitoaWdobGlnaHRAMS4yLjMvbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcz8wNjdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxudHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG5hIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cbnRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcbmhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG52YXJpb3VzIGxhbmd1YWdlcykuXG5cbkl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbnRoZSBsYW5ndWFnZSBwYWNrYWdlIGFuZCB0aGUgaGlnaGxpZ2h0ZXIpLCBidXQgc3VjaCB0YWdzIHdpbGwgbm90XG5iZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG5mcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG4qL1xuY2xhc3MgVGFnIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBvcHRpb25hbCBuYW1lIG9mIHRoZSBiYXNlIHRhZyBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgICovXG4gICAgc2V0LCBcbiAgICAvKipcbiAgICBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgbW9kaWZpZWQgQGludGVybmFsXG4gICAgKi9cbiAgICBiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgeyBuYW1lIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBtb2Qgb2YgdGhpcy5tb2RpZmllZClcbiAgICAgICAgICAgIGlmIChtb2QubmFtZSlcbiAgICAgICAgICAgICAgICBuYW1lID0gYCR7bW9kLm5hbWV9KCR7bmFtZX0pYDtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZpbmUobmFtZU9yUGFyZW50LCBwYXJlbnQpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGFyZW50ID09IFwic3RyaW5nXCIgPyBuYW1lT3JQYXJlbnQgOiBcIj9cIjtcbiAgICAgICAgaWYgKG5hbWVPclBhcmVudCBpbnN0YW5jZW9mIFRhZylcbiAgICAgICAgICAgIHBhcmVudCA9IG5hbWVPclBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5iYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXJpdmUgZnJvbSBhIG1vZGlmaWVkIHRhZ1wiKTtcbiAgICAgICAgbGV0IHRhZyA9IG5ldyBUYWcobmFtZSwgW10sIG51bGwsIFtdKTtcbiAgICAgICAgdGFnLnNldC5wdXNoKHRhZyk7XG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHBhcmVudC5zZXQpXG4gICAgICAgICAgICAgICAgdGFnLnNldC5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSB0YWcgX21vZGlmaWVyXywgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIHRhZyxcbiAgICB3aWxsIHJldHVybiBhIHRhZyB0aGF0IGlzIGEgc3VidGFnIG9mIHRoZSBvcmlnaW5hbC4gQXBwbHlpbmcgdGhlXG4gICAgc2FtZSBtb2RpZmllciB0byBhIHR3aWNlIHRhZyB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZSAoYG0xKHQxKVxuICAgID09IG0xKHQxKWApIGFuZCBhcHBseWluZyBtdWx0aXBsZSBtb2RpZmllcnMgd2lsbCwgcmVnYXJkbGVzcyBvclxuICAgIG9yZGVyLCBwcm9kdWNlIHRoZSBzYW1lIHRhZyAoYG0xKG0yKHQxKSkgPT0gbTIobTEodDEpKWApLlxuICAgIFxuICAgIFdoZW4gbXVsdGlwbGUgbW9kaWZpZXJzIGFyZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYmFzZSB0YWcsIGVhY2hcbiAgICBzbWFsbGVyIHNldCBvZiBtb2RpZmllcnMgaXMgcmVnaXN0ZXJlZCBhcyBhIHBhcmVudCwgc28gdGhhdCBmb3JcbiAgICBleGFtcGxlIGBtMShtMihtMyh0MSkpKWAgaXMgYSBzdWJ0eXBlIG9mIGBtMShtMih0MSkpYCxcbiAgICBgbTEobTModDEpYCwgYW5kIHNvIG9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZU1vZGlmaWVyKG5hbWUpIHtcbiAgICAgICAgbGV0IG1vZCA9IG5ldyBNb2RpZmllcihuYW1lKTtcbiAgICAgICAgcmV0dXJuICh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWcubW9kaWZpZWQuaW5kZXhPZihtb2QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgICAgIHJldHVybiBNb2RpZmllci5nZXQodGFnLmJhc2UgfHwgdGFnLCB0YWcubW9kaWZpZWQuY29uY2F0KG1vZCkuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5sZXQgbmV4dE1vZGlmaWVySUQgPSAwO1xuY2xhc3MgTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhiYXNlLm5hbWUsIHNldCwgYmFzZSwgbW9kcyk7XG4gICAgICAgIGZvciAobGV0IG0gb2YgbW9kcylcbiAgICAgICAgICAgIG0uaW5zdGFuY2VzLnB1c2godGFnKTtcbiAgICAgICAgbGV0IGNvbmZpZ3MgPSBwb3dlclNldChtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50IG9mIGJhc2Uuc2V0KVxuICAgICAgICAgICAgaWYgKCFwYXJlbnQubW9kaWZpZWQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChNb2RpZmllci5nZXQocGFyZW50LCBjb25maWcpKTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09IGJbaV0pO1xufVxuZnVuY3Rpb24gcG93ZXJTZXQoYXJyYXkpIHtcbiAgICBsZXQgc2V0cyA9IFtbXV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgZSA9IHNldHMubGVuZ3RoOyBqIDwgZTsgaisrKSB7XG4gICAgICAgICAgICBzZXRzLnB1c2goc2V0c1tqXS5jb25jYXQoYXJyYXlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V0cy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbn1cbi8qKlxuVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGFkZCBhIHNldCBvZiB0YWdzIHRvIGEgbGFuZ3VhZ2Ugc3ludGF4XG52aWEgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG5bYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuXG5UaGUgYXJndW1lbnQgb2JqZWN0IG1hcHMgbm9kZSBzZWxlY3RvcnMgdG8gW2hpZ2hsaWdodGluZ1xudGFnc10oI2hpZ2hsaWdodC5UYWcpIG9yIGFycmF5cyBvZiB0YWdzLlxuXG5Ob2RlIHNlbGVjdG9ycyBtYXkgaG9sZCBvbmUgb3IgbW9yZSAoc3BhY2Utc2VwYXJhdGVkKSBub2RlIHBhdGhzLlxuU3VjaCBhIHBhdGggY2FuIGJlIGEgW25vZGUgbmFtZV0oI2NvbW1vbi5Ob2RlVHlwZS5uYW1lKSwgb3Jcbm11bHRpcGxlIG5vZGUgbmFtZXMgKG9yIGAqYCB3aWxkY2FyZHMpIHNlcGFyYXRlZCBieSBzbGFzaFxuY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxubWF0Y2hlcyB0aGUgZmluYWwgbm9kZSBidXQgb25seSBpZiBpdHMgZGlyZWN0IHBhcmVudCBub2RlcyBhcmUgdGhlXG5vdGhlciBub2RlcyBtZW50aW9uZWQuIEEgYCpgIGluIHN1Y2ggYSBwYXRoIG1hdGNoZXMgYW55IHBhcmVudCxcbmJ1dCBvbmx5IGEgc2luZ2xlIGxldmVs4oCUd2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuYXJlbid0IHN1cHBvcnRlZCwgYm90aCBmb3IgZWZmaWNpZW5jeSByZWFzb25zIGFuZCBiZWNhdXNlIExlemVyXG50cmVlcyBtYWtlIGl0IHJhdGhlciBoYXJkIHRvIHJlYXNvbiBhYm91dCB3aGF0IHRoZXkgd291bGQgbWF0Y2guKVxuXG5BIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxudG8gdGhlIG5vZGUgc2hvdWxkIGFsc28gYXBwbHkgdG8gYWxsIGNoaWxkIG5vZGVzLCBldmVuIGlmIHRoZXlcbm1hdGNoIHRoZWlyIG93biBzdHlsZSAoYnkgZGVmYXVsdCwgb25seSB0aGUgaW5uZXJtb3N0IHN0eWxlIGlzXG51c2VkKS5cblxuV2hlbiBhIHBhdGggZW5kcyBpbiBgIWAsIGFzIGluIGBBdHRyaWJ1dGUhYCwgbm8gZnVydGhlciBtYXRjaGluZ1xuaGFwcGVucyBmb3IgdGhlIG5vZGUncyBjaGlsZCBub2RlcywgYW5kIHRoZSBlbnRpcmUgbm9kZSBnZXRzIHRoZVxuZ2l2ZW4gc3R5bGUuXG5cbkluIHRoaXMgbm90YXRpb24sIG5vZGUgbmFtZXMgdGhhdCBjb250YWluIGAvYCwgYCFgLCBgKmAsIG9yIGAuLi5gXG5tdXN0IGJlIHF1b3RlZCBhcyBKU09OIHN0cmluZ3MuXG5cbkZvciBleGFtcGxlOlxuXG5gYGBqYXZhc2NyaXB0XG5wYXJzZXIuY29uZmlndXJlKHtwcm9wczogW1xuICBzdHlsZVRhZ3Moe1xuICAgIC8vIFN0eWxlIE51bWJlciBhbmQgQmlnTnVtYmVyIG5vZGVzXG4gICAgXCJOdW1iZXIgQmlnTnVtYmVyXCI6IHRhZ3MubnVtYmVyLFxuICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4gICAgXCJTdHJpbmcvRXNjYXBlXCI6IHRhZ3MuZXNjYXBlLFxuICAgIC8vIFN0eWxlIGFueXRoaW5nIGluc2lkZSBBdHRyaWJ1dGVzIG5vZGVzXG4gICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4gICAgLy8gQWRkIGEgc3R5bGUgdG8gYWxsIGNvbnRlbnQgaW5zaWRlIEl0YWxpYyBub2Rlc1xuICAgIFwiSXRhbGljLy4uLlwiOiB0YWdzLmVtcGhhc2lzLFxuICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4gICAgXCJJbnZhbGlkU3RyaW5nXCI6IFt0YWdzLnN0cmluZywgdGFncy5pbnZhbGlkXSxcbiAgICAvLyBTdHlsZSB0aGUgbm9kZSBuYW1lZCBcIi9cIiBhcyBwdW5jdHVhdGlvblxuICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbiAgfSlcbl19KVxuYGBgXG4qL1xuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE1vZGUuTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIE1vZGUuSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IFwiXCIgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE1vZGUuT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgTm9kZVByb3Aoe1xuICAgIGNvbWJpbmUoYSwgYikge1xuICAgICAgICBsZXQgY3VyLCByb290LCB0YWtlO1xuICAgICAgICB3aGlsZSAoYSB8fCBiKSB7XG4gICAgICAgICAgICBpZiAoIWEgfHwgYiAmJiBhLmRlcHRoID49IGIuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICB0YWtlID0gYjtcbiAgICAgICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFrZSA9IGE7XG4gICAgICAgICAgICAgICAgYSA9IGEubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXIgJiYgY3VyLm1vZGUgPT0gdGFrZS5tb2RlICYmICF0YWtlLmNvbnRleHQgJiYgIWN1ci5jb250ZXh0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGNvcHkgPSBuZXcgUnVsZSh0YWtlLnRhZ3MsIHRha2UubW9kZSwgdGFrZS5jb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjdXIpXG4gICAgICAgICAgICAgICAgY3VyLm5leHQgPSBjb3B5O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJvb3QgPSBjb3B5O1xuICAgICAgICAgICAgY3VyID0gY29weTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG59KTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE1vZGUuT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBNb2RlLk5vcm1hbCAqLywgbnVsbCk7XG4vKipcbkRlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxudGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxudGFrZSBwcmVjZWRlbmNlLlxuKi9cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiBbdHJlZV0oI2NvbW1vbi5UcmVlKSB3aXRoIHRoZSBnaXZlblxuW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS4gT2Z0ZW4sIHRoZSBoaWdoZXItbGV2ZWxcbltgaGlnaGxpZ2h0Q29kZWBdKCNoaWdobGlnaHQuaGlnaGxpZ2h0Q29kZSkgZnVuY3Rpb24gaXMgZWFzaWVyIHRvXG51c2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgXG4vKipcbkFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbm9mIHBvc2l0aW9uLCBmb3IgYW55IHJhbmdlcyB3aGVyZSBtb3JlIHRoYW4gemVybyBjbGFzc2VzIGFwcGx5LlxuYGNsYXNzZXNgIGlzIGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBDU1MgY2xhc3Nlcy5cbiovXG5wdXRTdHlsZSwgXG4vKipcblRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuKi9cbmZyb20gPSAwLCBcbi8qKlxuVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4qL1xudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG4vKipcbkhpZ2hsaWdodCB0aGUgZ2l2ZW4gdHJlZSB3aXRoIHRoZSBnaXZlbiBoaWdobGlnaHRlciwgY2FsbGluZ1xuYHB1dFRleHRgIGZvciBldmVyeSBwaWVjZSBvZiB0ZXh0LCBlaXRoZXIgd2l0aCBhIHNldCBvZiBjbGFzc2VzIG9yXG53aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiB1bnN0eWxlZCwgYW5kIGBwdXRCcmVha2AgZm9yIGV2ZXJ5IGxpbmVcbmJyZWFrLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodENvZGUoY29kZSwgdHJlZSwgaGlnaGxpZ2h0ZXIsIHB1dFRleHQsIHB1dEJyZWFrLCBmcm9tID0gMCwgdG8gPSBjb2RlLmxlbmd0aCkge1xuICAgIGxldCBwb3MgPSBmcm9tO1xuICAgIGZ1bmN0aW9uIHdyaXRlVG8ocCwgY2xhc3Nlcykge1xuICAgICAgICBpZiAocCA8PSBwb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHRleHQgPSBjb2RlLnNsaWNlKHBvcywgcCksIGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgaSk7XG4gICAgICAgICAgICBsZXQgdXB0byA9IG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaztcbiAgICAgICAgICAgIGlmICh1cHRvID4gaSlcbiAgICAgICAgICAgICAgICBwdXRUZXh0KHRleHQuc2xpY2UoaSwgdXB0byksIGNsYXNzZXMpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwdXRCcmVhaygpO1xuICAgICAgICAgICAgaSA9IG5leHRCcmVhayArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gcDtcbiAgICB9XG4gICAgaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgKGZyb20sIHRvLCBjbGFzc2VzKSA9PiB7XG4gICAgICAgIHdyaXRlVG8oZnJvbSwgXCJcIik7XG4gICAgICAgIHdyaXRlVG8odG8sIGNsYXNzZXMpO1xuICAgIH0sIGZyb20sIHRvKTtcbiAgICB3cml0ZVRvKHRvLCBcIlwiKTtcbn1cbmNsYXNzIEhpZ2hsaWdodEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF0LCBoaWdobGlnaHRlcnMsIHNwYW4pIHtcbiAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVycyA9IGhpZ2hsaWdodGVycztcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IFwiXCI7XG4gICAgfVxuICAgIHN0YXJ0U3BhbihhdCwgY2xzKSB7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5mbHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQgPiB0aGlzLmF0KVxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgICAgIHRoaXMuY2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2godG8pIHtcbiAgICAgICAgaWYgKHRvID4gdGhpcy5hdCAmJiB0aGlzLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5zcGFuKHRoaXMuYXQsIHRvLCB0aGlzLmNsYXNzKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgeyB0eXBlLCBmcm9tOiBzdGFydCwgdG86IGVuZCB9ID0gY3Vyc29yO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlLmlzVG9wKVxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZSh0eXBlKSk7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSBnZXRTdHlsZVRhZ3MoY3Vyc29yKSB8fCBSdWxlLmVtcHR5O1xuICAgICAgICBsZXQgdGFnQ2xzID0gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHJ1bGUudGFncyk7XG4gICAgICAgIGlmICh0YWdDbHMpIHtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiO1xuICAgICAgICAgICAgY2xzICs9IHRhZ0NscztcbiAgICAgICAgICAgIGlmIChydWxlLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1heChmcm9tLCBzdGFydCksIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIFwiXCIsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIHBvcyksIGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICBpZiAobW91bnRlZClcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyA9IFwiXCI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA8PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbk1hdGNoIGEgc3ludGF4IG5vZGUncyBbaGlnaGxpZ2h0IHJ1bGVzXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykuIElmXG50aGVyZSdzIGEgbWF0Y2gsIHJldHVybiBpdHMgc2V0IG9mIHRhZ3MsIGFuZCB3aGV0aGVyIGl0IGlzXG5vcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuKi9cbmZ1bmN0aW9uIGdldFN0eWxlVGFncyhub2RlKSB7XG4gICAgbGV0IHJ1bGUgPSBub2RlLnR5cGUucHJvcChydWxlTm9kZVByb3ApO1xuICAgIHdoaWxlIChydWxlICYmIHJ1bGUuY29udGV4dCAmJiAhbm9kZS5tYXRjaENvbnRleHQocnVsZS5jb250ZXh0KSlcbiAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICByZXR1cm4gcnVsZSB8fCBudWxsO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIHByb3BlcnR5TmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8qKlxuVGhlIGRlZmF1bHQgc2V0IG9mIGhpZ2hsaWdodGluZyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuXG5UaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG5hbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuY29uc3RydWN0cyB3b3VsZCBmaWxsIGEgc3RhY2sgb2YgYm9va3MsIGFuZCBiZSBpbXByYWN0aWNhbCB0b1xud3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2VcbmZhaWxzLCBbb3BlbiBhblxuaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2NvZGVtaXJyb3IubmV4dCkgdG8gcHJvcG9zZSBhXG5uZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3JcbnlvdXIgdXNlIGNhc2UuXG5cbk5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG50YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbmRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG5pdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG5cbkZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbnRoZSBwYXJlbnQuXG4qL1xuY29uc3QgdGFncyA9IHtcbiAgICAvKipcbiAgICBBIGNvbW1lbnQuXG4gICAgKi9cbiAgICBjb21tZW50LFxuICAgIC8qKlxuICAgIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgbGluZUNvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgICovXG4gICAgbmFtZSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgICovXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgdHlwZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8qKlxuICAgIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgKi9cbiAgICB0YWdOYW1lOiB0KHR5cGVOYW1lKSxcbiAgICAvKipcbiAgICBBIHByb3BlcnR5IG9yIGZpZWxkIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkpLlxuICAgICovXG4gICAgYXR0cmlidXRlTmFtZTogdChwcm9wZXJ0eU5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgKi9cbiAgICBjbGFzc05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICAqL1xuICAgIG1hY3JvTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxpdGVyYWwgdmFsdWUuXG4gICAgKi9cbiAgICBsaXRlcmFsLFxuICAgIC8qKlxuICAgIEEgc3RyaW5nIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBzdHJpbmcsXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgICovXG4gICAgZG9jU3RyaW5nOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZVZhbHVlOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIG51bWJlcixcbiAgICAvKipcbiAgICBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBmbG9hdGluZy1wb2ludCBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgZmxvYXQ6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGJvb2w6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQW4gZXNjYXBlIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgICovXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGNvbG9yOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICB1cmw6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAgICovXG4gICAga2V5d29yZCxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIG9iamVjdC5cbiAgICAqL1xuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICAgKi9cbiAgICBudWxsOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICAqL1xuICAgIGF0b206IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgKi9cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIG1vZGlmaWVyOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIGludGVyZmFjaW5nIHdpdGggbW9kdWxlcy5cbiAgICAqL1xuICAgIG1vZHVsZUtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcixcbiAgICAvKipcbiAgICBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZXJlZmVyZW5jZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGFyaXRobWV0aWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBCaXQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbXBhcmVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICAqL1xuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIHR5cGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICAgKi9cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvKipcbiAgICBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICB0aGluZ3MuXG4gICAgKi9cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8qKlxuICAgIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgICovXG4gICAgYnJhY2tldCxcbiAgICAvKipcbiAgICBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBhbmdsZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIHNxdWFyZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIHBhcmVuOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgYnJhY2U6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICAqL1xuICAgIGNvbnRlbnQsXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBoZWFkaW5nLlxuICAgICovXG4gICAgaGVhZGluZyxcbiAgICAvKipcbiAgICBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcxOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAzIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc0OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA2IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIHByb3NlIFtjb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgc2VwYXJhdG9yIChzdWNoIGFzIGEgaG9yaXpvbnRhbCBydWxlKS5cbiAgICAqL1xuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgICovXG4gICAgbGlzdDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgICovXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIGVtcGhhc2l6ZWQuXG4gICAgKi9cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICAqL1xuICAgIHN0cm9uZzogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgKi9cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgYXMgY29kZSBvclxuICAgIG1vbm9zcGFjZS5cbiAgICAqL1xuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaGFzIGEgc3RyaWtlLXRocm91Z2hcbiAgICBzdHlsZS5cbiAgICAqL1xuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgSW5zZXJ0ZWQgdGV4dCBpbiBhIGNoYW5nZS10cmFja2luZyBmb3JtYXQuXG4gICAgKi9cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8qKlxuICAgIERlbGV0ZWQgdGV4dC5cbiAgICAqL1xuICAgIGRlbGV0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBDaGFuZ2VkIHRleHQuXG4gICAgKi9cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLyoqXG4gICAgQW4gaW52YWxpZCBvciB1bnN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8qKlxuICAgIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgKi9cbiAgICBtZXRhLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2N1bWVudE1ldGE6IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGFubm90YXRpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgICovXG4gICAgcHJvY2Vzc2luZ0luc3RydWN0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIHZhcmlvdXMgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0YWdzLlxuICAgICovXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKFwiZGVmaW5pdGlvblwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0XG4gICAgc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgICAqL1xuICAgIGNvbnN0YW50OiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJjb25zdGFudFwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgICBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XG4gICAgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkgaXMgYmVpbmcgY2FsbGVkIG9yIGRlZmluZWRcbiAgICBhcyBhIGZ1bmN0aW9uLlxuICAgICovXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcihcImZ1bmN0aW9uXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG9cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgKi9cbiAgICBzdGFuZGFyZDogVGFnLmRlZmluZU1vZGlmaWVyKFwic3RhbmRhcmRcIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgKi9cbiAgICBsb2NhbDogVGFnLmRlZmluZU1vZGlmaWVyKFwibG9jYWxcIiksXG4gICAgLyoqXG4gICAgQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICAgIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxuICAgIHNvbWUgY29tbW9uIHRhZy4gSXQgaXMgcmVjb21tZW5kZWQgZm9yIHRoZW1lcyB0byBkZWZpbmUgc3BlY2lhbFxuICAgIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcbiAgICBjb21lIHVwIGEgbG90LlxuICAgICovXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKFwic3BlY2lhbFwiKVxufTtcbmZvciAobGV0IG5hbWUgaW4gdGFncykge1xuICAgIGxldCB2YWwgPSB0YWdzW25hbWVdO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgIHZhbC5uYW1lID0gbmFtZTtcbn1cbi8qKlxuVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbnRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG5cblRoZSBmb2xsb3dpbmcgdGFncyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5hbWUgcHJlZml4ZWQgd2l0aCBgXCJ0b2stXCJgXG4oZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuXG4qIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuKiBbYGhlYWRpbmdgXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZylcbiogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbiogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuKiBbYGtleXdvcmRgXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZClcbiogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4qIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuKiBbYHVybGBdKCNoaWdobGlnaHQudGFncy51cmwpXG4qIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbiogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbiogW2BkZWxldGVkYF0oI2hpZ2hsaWdodC50YWdzLmRlbGV0ZWQpXG4qIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4qIFtgbnVtYmVyYF0oI2hpZ2hsaWdodC50YWdzLm51bWJlcilcbiogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuKiBbYG5hbWVzcGFjZWBdKCNoaWdobGlnaHQudGFncy5uYW1lc3BhY2UpXG4qIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbiogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuKiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4qIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4qIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuKiBbYG1ldGFgXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSlcbiogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbiogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG5cbkluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG5cbiogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbiAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4gIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4qIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxuKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKi9cbmNvbnN0IGNsYXNzSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcihbXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGNsYXNzOiBcInRvay1oZWFkaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNsYXNzOiBcInRvay1rZXl3b3JkXCIgfSxcbiAgICB7IHRhZzogdGFncy5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnVybCwgY2xhc3M6IFwidG9rLXVybFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWxldGVkLCBjbGFzczogXCJ0b2stZGVsZXRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MubnVtYmVyLCBjbGFzczogXCJ0b2stbnVtYmVyXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSwgY2xhc3M6IFwidG9rLWNsYXNzTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm9wZXJhdG9yLCBjbGFzczogXCJ0b2stb3BlcmF0b3JcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY2xhc3M6IFwidG9rLWludmFsaWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcblxuZXhwb3J0IHsgVGFnLCBjbGFzc0hpZ2hsaWdodGVyLCBnZXRTdHlsZVRhZ3MsIGhpZ2hsaWdodENvZGUsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncywgdGFnSGlnaGxpZ2h0ZXIsIHRhZ3MgfTtcbiJdLCJuYW1lcyI6WyJOb2RlUHJvcCIsIm5leHRUYWdJRCIsIlRhZyIsImNvbnN0cnVjdG9yIiwibmFtZSIsInNldCIsImJhc2UiLCJtb2RpZmllZCIsImlkIiwidG9TdHJpbmciLCJtb2QiLCJkZWZpbmUiLCJuYW1lT3JQYXJlbnQiLCJwYXJlbnQiLCJFcnJvciIsInRhZyIsInB1c2giLCJ0IiwiZGVmaW5lTW9kaWZpZXIiLCJNb2RpZmllciIsImluZGV4T2YiLCJnZXQiLCJjb25jYXQiLCJzb3J0IiwiYSIsImIiLCJuZXh0TW9kaWZpZXJJRCIsImluc3RhbmNlcyIsIm1vZHMiLCJsZW5ndGgiLCJleGlzdHMiLCJmaW5kIiwic2FtZUFycmF5IiwibSIsImNvbmZpZ3MiLCJwb3dlclNldCIsImNvbmZpZyIsImV2ZXJ5IiwieCIsImkiLCJhcnJheSIsInNldHMiLCJqIiwiZSIsInN0eWxlVGFncyIsInNwZWMiLCJieU5hbWUiLCJPYmplY3QiLCJjcmVhdGUiLCJwcm9wIiwidGFncyIsIkFycmF5IiwiaXNBcnJheSIsInBhcnQiLCJzcGxpdCIsInBpZWNlcyIsIm1vZGUiLCJyZXN0IiwicG9zIiwiZXhlYyIsIlJhbmdlRXJyb3IiLCJKU09OIiwicGFyc2UiLCJuZXh0Iiwic2xpY2UiLCJsYXN0IiwiaW5uZXIiLCJydWxlIiwiUnVsZSIsInJ1bGVOb2RlUHJvcCIsImFkZCIsImNvbWJpbmUiLCJjdXIiLCJyb290IiwidGFrZSIsImRlcHRoIiwiY29udGV4dCIsImNvcHkiLCJvcGFxdWUiLCJpbmhlcml0Iiwib3RoZXIiLCJlbXB0eSIsInRhZ0hpZ2hsaWdodGVyIiwib3B0aW9ucyIsIm1hcCIsInN0eWxlIiwiY2xhc3MiLCJzY29wZSIsImFsbCIsImNscyIsInN1YiIsInRhZ0NsYXNzIiwiaGlnaGxpZ2h0VGFncyIsImhpZ2hsaWdodGVycyIsInJlc3VsdCIsImhpZ2hsaWdodGVyIiwidmFsdWUiLCJoaWdobGlnaHRUcmVlIiwidHJlZSIsInB1dFN0eWxlIiwiZnJvbSIsInRvIiwiYnVpbGRlciIsIkhpZ2hsaWdodEJ1aWxkZXIiLCJoaWdobGlnaHRSYW5nZSIsImN1cnNvciIsImZsdXNoIiwiaGlnaGxpZ2h0Q29kZSIsImNvZGUiLCJwdXRUZXh0IiwicHV0QnJlYWsiLCJ3cml0ZVRvIiwicCIsImNsYXNzZXMiLCJ0ZXh0IiwibmV4dEJyZWFrIiwidXB0byIsImF0Iiwic3BhbiIsInN0YXJ0U3BhbiIsImluaGVyaXRlZENsYXNzIiwidHlwZSIsInN0YXJ0IiwiZW5kIiwiaXNUb3AiLCJmaWx0ZXIiLCJoIiwiZ2V0U3R5bGVUYWdzIiwidGFnQ2xzIiwiTWF0aCIsIm1heCIsIm1vdW50ZWQiLCJvdmVybGF5Iiwibm9kZSIsImVudGVyIiwiaW5uZXJIaWdobGlnaHRlcnMiLCJoYXNDaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0UG9zIiwicmFuZ2VGcm9tIiwicmFuZ2VUbyIsIm1pbiIsIm5leHRTaWJsaW5nIiwibWF0Y2hDb250ZXh0IiwiY29tbWVudCIsInR5cGVOYW1lIiwicHJvcGVydHlOYW1lIiwibGl0ZXJhbCIsInN0cmluZyIsIm51bWJlciIsImNvbnRlbnQiLCJoZWFkaW5nIiwia2V5d29yZCIsIm9wZXJhdG9yIiwicHVuY3R1YXRpb24iLCJicmFja2V0IiwibWV0YSIsImxpbmVDb21tZW50IiwiYmxvY2tDb21tZW50IiwiZG9jQ29tbWVudCIsInZhcmlhYmxlTmFtZSIsInRhZ05hbWUiLCJhdHRyaWJ1dGVOYW1lIiwiY2xhc3NOYW1lIiwibGFiZWxOYW1lIiwibmFtZXNwYWNlIiwibWFjcm9OYW1lIiwiZG9jU3RyaW5nIiwiY2hhcmFjdGVyIiwiYXR0cmlidXRlVmFsdWUiLCJpbnRlZ2VyIiwiZmxvYXQiLCJib29sIiwicmVnZXhwIiwiZXNjYXBlIiwiY29sb3IiLCJ1cmwiLCJzZWxmIiwibnVsbCIsImF0b20iLCJ1bml0IiwibW9kaWZpZXIiLCJvcGVyYXRvcktleXdvcmQiLCJjb250cm9sS2V5d29yZCIsImRlZmluaXRpb25LZXl3b3JkIiwibW9kdWxlS2V5d29yZCIsImRlcmVmT3BlcmF0b3IiLCJhcml0aG1ldGljT3BlcmF0b3IiLCJsb2dpY09wZXJhdG9yIiwiYml0d2lzZU9wZXJhdG9yIiwiY29tcGFyZU9wZXJhdG9yIiwidXBkYXRlT3BlcmF0b3IiLCJkZWZpbml0aW9uT3BlcmF0b3IiLCJ0eXBlT3BlcmF0b3IiLCJjb250cm9sT3BlcmF0b3IiLCJzZXBhcmF0b3IiLCJhbmdsZUJyYWNrZXQiLCJzcXVhcmVCcmFja2V0IiwicGFyZW4iLCJicmFjZSIsImhlYWRpbmcxIiwiaGVhZGluZzIiLCJoZWFkaW5nMyIsImhlYWRpbmc0IiwiaGVhZGluZzUiLCJoZWFkaW5nNiIsImNvbnRlbnRTZXBhcmF0b3IiLCJsaXN0IiwicXVvdGUiLCJlbXBoYXNpcyIsInN0cm9uZyIsImxpbmsiLCJtb25vc3BhY2UiLCJzdHJpa2V0aHJvdWdoIiwiaW5zZXJ0ZWQiLCJkZWxldGVkIiwiY2hhbmdlZCIsImludmFsaWQiLCJkb2N1bWVudE1ldGEiLCJhbm5vdGF0aW9uIiwicHJvY2Vzc2luZ0luc3RydWN0aW9uIiwiZGVmaW5pdGlvbiIsImNvbnN0YW50IiwiZnVuY3Rpb24iLCJzdGFuZGFyZCIsImxvY2FsIiwic3BlY2lhbCIsInZhbCIsImNsYXNzSGlnaGxpZ2h0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lezer+highlight@1.2.3/node_modules/@lezer/highlight/dist/index.js\n");

/***/ })

};
;