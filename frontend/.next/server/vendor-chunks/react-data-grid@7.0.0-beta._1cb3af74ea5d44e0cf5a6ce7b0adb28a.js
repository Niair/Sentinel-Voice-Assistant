"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a";
exports.ids = ["vendor-chunks/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a/node_modules/react-data-grid/lib/styles.css":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a/node_modules/react-data-grid/lib/styles.css ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2775a1fecd7e\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZGF0YS1ncmlkQDcuMC4wLWJldGEuXzFjYjNhZjc0ZWE1ZDQ0ZTBjZjVhNmNlN2IwYWRiMjhhL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvbGliL3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kYXRhLWdyaWRANy4wLjAtYmV0YS5fMWNiM2FmNzRlYTVkNDRlMGNmNWE2Y2U3YjBhZGIyOGEvbm9kZV9tb2R1bGVzL3JlYWN0LWRhdGEtZ3JpZC9saWIvc3R5bGVzLmNzcz81YzYxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMjc3NWExZmVjZDdlXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a/node_modules/react-data-grid/lib/styles.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a/node_modules/react-data-grid/lib/index.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a/node_modules/react-data-grid/lib/index.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ Cell_default),\n/* harmony export */   DataGrid: () => (/* binding */ DataGrid),\n/* harmony export */   DataGridDefaultRenderersContext: () => (/* binding */ DataGridDefaultRenderersContext),\n/* harmony export */   Row: () => (/* binding */ Row_default),\n/* harmony export */   SELECT_COLUMN_KEY: () => (/* binding */ SELECT_COLUMN_KEY),\n/* harmony export */   SelectCellFormatter: () => (/* binding */ SelectCellFormatter),\n/* harmony export */   SelectColumn: () => (/* binding */ SelectColumn),\n/* harmony export */   ToggleGroup: () => (/* binding */ ToggleGroup),\n/* harmony export */   TreeDataGrid: () => (/* binding */ TreeDataGrid),\n/* harmony export */   renderCheckbox: () => (/* binding */ renderCheckbox),\n/* harmony export */   renderHeaderCell: () => (/* binding */ renderHeaderCell),\n/* harmony export */   renderSortIcon: () => (/* binding */ renderSortIcon),\n/* harmony export */   renderSortPriority: () => (/* binding */ renderSortPriority),\n/* harmony export */   renderTextEditor: () => (/* binding */ textTextEditor),\n/* harmony export */   renderToggleGroup: () => (/* binding */ renderToggleGroup),\n/* harmony export */   renderValue: () => (/* binding */ renderValue),\n/* harmony export */   useHeaderRowSelection: () => (/* binding */ useHeaderRowSelection),\n/* harmony export */   useRowSelection: () => (/* binding */ useRowSelection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_@opentelemetry+_95d5a05ac7ec0d735f17a907e734f3d8/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_@opentelemetry+_95d5a05ac7ec0d735f17a907e734f3d8/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_@opentelemetry+_95d5a05ac7ec0d735f17a907e734f3d8/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n\n\n\n//#region src/utils/colSpanUtils.ts\nfunction getColSpan(column, lastFrozenColumnIndex, args) {\n    const colSpan = typeof column.colSpan === \"function\" ? column.colSpan(args) : 1;\n    if (Number.isInteger(colSpan) && colSpan > 1 && (!column.frozen || column.idx + colSpan - 1 <= lastFrozenColumnIndex)) return colSpan;\n}\n//#endregion\n//#region src/utils/domUtils.ts\nfunction stopPropagation(event) {\n    event.stopPropagation();\n}\nfunction scrollIntoView(element, behavior = \"instant\") {\n    element?.scrollIntoView({\n        inline: \"nearest\",\n        block: \"nearest\",\n        behavior\n    });\n}\n//#endregion\n//#region src/utils/eventUtils.ts\nfunction createCellEvent(event) {\n    let defaultPrevented = false;\n    const cellEvent = {\n        ...event,\n        preventGridDefault () {\n            defaultPrevented = true;\n        },\n        isGridDefaultPrevented () {\n            return defaultPrevented;\n        }\n    };\n    Object.setPrototypeOf(cellEvent, Object.getPrototypeOf(event));\n    return cellEvent;\n}\n//#endregion\n//#region src/utils/keyboardUtils.ts\nconst nonInputKeys = new Set([\n    \"Unidentified\",\n    \"Alt\",\n    \"AltGraph\",\n    \"CapsLock\",\n    \"Control\",\n    \"Fn\",\n    \"FnLock\",\n    \"Meta\",\n    \"NumLock\",\n    \"ScrollLock\",\n    \"Shift\",\n    \"Tab\",\n    \"ArrowDown\",\n    \"ArrowLeft\",\n    \"ArrowRight\",\n    \"ArrowUp\",\n    \"End\",\n    \"Home\",\n    \"PageDown\",\n    \"PageUp\",\n    \"Insert\",\n    \"ContextMenu\",\n    \"Escape\",\n    \"Pause\",\n    \"Play\",\n    \"PrintScreen\",\n    \"F1\",\n    \"F3\",\n    \"F4\",\n    \"F5\",\n    \"F6\",\n    \"F7\",\n    \"F8\",\n    \"F9\",\n    \"F10\",\n    \"F11\",\n    \"F12\"\n]);\nfunction isCtrlKeyHeldDown(e) {\n    return (e.ctrlKey || e.metaKey) && e.key !== \"Control\";\n}\nconst vKey = 86;\nfunction isDefaultCellInput(event, isUserHandlingPaste) {\n    if (isCtrlKeyHeldDown(event) && (event.keyCode !== vKey || isUserHandlingPaste)) return false;\n    return !nonInputKeys.has(event.key);\n}\n/**\n* By default, the following navigation keys are enabled while an editor is open, under specific conditions:\n* - Tab:\n*   - The editor must be an <input>, a <textarea>, or a <select> element.\n*   - The editor element must be the only immediate child of the editor container/a label.\n*/ function onEditorNavigation({ key, target }) {\n    if (key === \"Tab\" && (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement)) return target.closest(\".rdg-editor-container\")?.querySelectorAll(\"input, textarea, select\").length === 1;\n    return false;\n}\nfunction getLeftRightKey(direction) {\n    const isRtl = direction === \"rtl\";\n    return {\n        leftKey: isRtl ? \"ArrowRight\" : \"ArrowLeft\",\n        rightKey: isRtl ? \"ArrowLeft\" : \"ArrowRight\"\n    };\n}\n//#endregion\n//#region src/utils/renderMeasuringCells.tsx\nconst measuringCellClassname = \"rdg-7-0-0-beta-58-fa71d63e\";\nfunction renderMeasuringCells(viewportColumns) {\n    return viewportColumns.map(({ key, idx, minWidth, maxWidth })=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            className: measuringCellClassname,\n            style: {\n                gridColumnStart: idx + 1,\n                minWidth,\n                maxWidth\n            },\n            \"data-measuring-cell-key\": key\n        }, key));\n}\n//#endregion\n//#region src/utils/selectedCellUtils.ts\nfunction isSelectedCellEditable({ selectedPosition, columns, rows }) {\n    const column = columns[selectedPosition.idx];\n    const row$1 = rows[selectedPosition.rowIdx];\n    return isCellEditableUtil(column, row$1);\n}\nfunction isCellEditableUtil(column, row$1) {\n    return column.renderEditCell != null && (typeof column.editable === \"function\" ? column.editable(row$1) : column.editable) !== false;\n}\nfunction getSelectedCellColSpan({ rows, topSummaryRows, bottomSummaryRows, rowIdx, mainHeaderRowIdx, lastFrozenColumnIndex, column }) {\n    const topSummaryRowsCount = topSummaryRows?.length ?? 0;\n    if (rowIdx === mainHeaderRowIdx) return getColSpan(column, lastFrozenColumnIndex, {\n        type: \"HEADER\"\n    });\n    if (topSummaryRows && rowIdx > mainHeaderRowIdx && rowIdx <= topSummaryRowsCount + mainHeaderRowIdx) return getColSpan(column, lastFrozenColumnIndex, {\n        type: \"SUMMARY\",\n        row: topSummaryRows[rowIdx + topSummaryRowsCount]\n    });\n    if (rowIdx >= 0 && rowIdx < rows.length) {\n        const row$1 = rows[rowIdx];\n        return getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row: row$1\n        });\n    }\n    if (bottomSummaryRows) return getColSpan(column, lastFrozenColumnIndex, {\n        type: \"SUMMARY\",\n        row: bottomSummaryRows[rowIdx - rows.length]\n    });\n}\nfunction getNextSelectedCellPosition({ moveUp, moveNext, cellNavigationMode, columns, colSpanColumns, rows, topSummaryRows, bottomSummaryRows, minRowIdx, mainHeaderRowIdx, maxRowIdx, currentPosition: { idx: currentIdx, rowIdx: currentRowIdx }, nextPosition, lastFrozenColumnIndex, isCellWithinBounds }) {\n    let { idx: nextIdx, rowIdx: nextRowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const setColSpan = (moveNext$1)=>{\n        for (const column of colSpanColumns){\n            const colIdx = column.idx;\n            if (colIdx > nextIdx) break;\n            const colSpan = getSelectedCellColSpan({\n                rows,\n                topSummaryRows,\n                bottomSummaryRows,\n                rowIdx: nextRowIdx,\n                mainHeaderRowIdx,\n                lastFrozenColumnIndex,\n                column\n            });\n            if (colSpan && nextIdx > colIdx && nextIdx < colSpan + colIdx) {\n                nextIdx = colIdx + (moveNext$1 ? colSpan : 0);\n                break;\n            }\n        }\n    };\n    const getParentRowIdx = (parent)=>{\n        return parent.level + mainHeaderRowIdx;\n    };\n    const setHeaderGroupColAndRowSpan = ()=>{\n        if (moveNext) {\n            let parent = columns[nextIdx].parent;\n            while(parent !== void 0){\n                const parentRowIdx = getParentRowIdx(parent);\n                if (nextRowIdx === parentRowIdx) {\n                    nextIdx = parent.idx + parent.colSpan;\n                    break;\n                }\n                parent = parent.parent;\n            }\n        } else if (moveUp) {\n            let parent = columns[nextIdx].parent;\n            let found = false;\n            while(parent !== void 0){\n                const parentRowIdx = getParentRowIdx(parent);\n                if (nextRowIdx >= parentRowIdx) {\n                    nextIdx = parent.idx;\n                    nextRowIdx = parentRowIdx;\n                    found = true;\n                    break;\n                }\n                parent = parent.parent;\n            }\n            if (!found) {\n                nextIdx = currentIdx;\n                nextRowIdx = currentRowIdx;\n            }\n        }\n    };\n    if (isCellWithinBounds(nextPosition)) {\n        setColSpan(moveNext);\n        if (nextRowIdx < mainHeaderRowIdx) setHeaderGroupColAndRowSpan();\n    }\n    if (cellNavigationMode === \"CHANGE_ROW\") {\n        const isAfterLastColumn = nextIdx === columnsCount;\n        const isBeforeFirstColumn = nextIdx === -1;\n        if (isAfterLastColumn) {\n            if (!(nextRowIdx === maxRowIdx)) {\n                nextIdx = 0;\n                nextRowIdx += 1;\n            }\n        } else if (isBeforeFirstColumn) {\n            if (!(nextRowIdx === minRowIdx)) {\n                nextRowIdx -= 1;\n                nextIdx = columnsCount - 1;\n            }\n            setColSpan(false);\n        }\n    }\n    if (nextRowIdx < mainHeaderRowIdx && nextIdx > -1 && nextIdx < columnsCount) {\n        let parent = columns[nextIdx].parent;\n        const nextParentRowIdx = nextRowIdx;\n        nextRowIdx = mainHeaderRowIdx;\n        while(parent !== void 0){\n            const parentRowIdx = getParentRowIdx(parent);\n            if (parentRowIdx >= nextParentRowIdx) {\n                nextRowIdx = parentRowIdx;\n                nextIdx = parent.idx;\n            }\n            parent = parent.parent;\n        }\n    }\n    return {\n        idx: nextIdx,\n        rowIdx: nextRowIdx\n    };\n}\nfunction canExitGrid({ maxColIdx, minRowIdx, maxRowIdx, selectedPosition: { rowIdx, idx }, shiftKey }) {\n    return shiftKey ? idx === 0 && rowIdx === minRowIdx : idx === maxColIdx && rowIdx === maxRowIdx;\n}\n//#endregion\n//#region src/style/cell.ts\nconst cell = \"rdg-7-0-0-beta-58-85c48527\";\nconst cellClassname = `rdg-cell ${cell}`;\nconst cellFrozen = \"rdg-7-0-0-beta-58-17a9a6d4\";\nconst cellFrozenClassname = `rdg-cell-frozen ${cellFrozen}`;\nconst cellDragHandle = \"rdg-7-0-0-beta-58-bfba19bc\";\nconst cellDragHandleFrozenClassname = \"rdg-7-0-0-beta-58-7abddb3e\";\nconst cellDragHandleClassname = `rdg-cell-drag-handle ${cellDragHandle}`;\n//#endregion\n//#region src/utils/styleUtils.ts\nfunction getRowStyle(rowIdx) {\n    return {\n        \"--rdg-grid-row-start\": rowIdx\n    };\n}\nfunction getHeaderCellStyle(column, rowIdx, rowSpan) {\n    const gridRowEnd = rowIdx + 1;\n    const paddingBlockStart = `calc(${rowSpan - 1} * var(--rdg-header-row-height))`;\n    if (column.parent === void 0) return {\n        insetBlockStart: 0,\n        gridRowStart: 1,\n        gridRowEnd,\n        paddingBlockStart\n    };\n    return {\n        insetBlockStart: `calc(${rowIdx - rowSpan} * var(--rdg-header-row-height))`,\n        gridRowStart: gridRowEnd - rowSpan,\n        gridRowEnd,\n        paddingBlockStart\n    };\n}\nfunction getCellStyle(column, colSpan = 1) {\n    const index = column.idx + 1;\n    return {\n        gridColumnStart: index,\n        gridColumnEnd: index + colSpan,\n        insetInlineStart: column.frozen ? `var(--rdg-frozen-left-${column.idx})` : void 0\n    };\n}\nfunction classnames(...args) {\n    let classname = \"\";\n    for (const arg of args)if (arg) {\n        if (typeof arg === \"string\") classname += ` ${arg}`;\n        else if (typeof arg === \"object\") {\n            for(const key in arg)if (arg[key]) classname += ` ${key}`;\n        }\n    }\n    return classname.trimStart();\n}\nfunction getCellClassname(column, ...extraClasses) {\n    return classnames(cellClassname, {\n        [cellFrozenClassname]: column.frozen\n    }, ...extraClasses);\n}\n//#endregion\n//#region src/utils/index.ts\nconst { min, max, floor, sign, abs } = Math;\nfunction assertIsValidKeyGetter(keyGetter) {\n    if (typeof keyGetter !== \"function\") throw new Error(\"Please specify the rowKeyGetter prop to use selection\");\n}\nfunction clampColumnWidth(width, { minWidth, maxWidth }) {\n    width = max(width, minWidth);\n    if (typeof maxWidth === \"number\" && maxWidth >= minWidth) return min(width, maxWidth);\n    return width;\n}\nfunction getHeaderCellRowSpan(column, rowIdx) {\n    return column.parent === void 0 ? rowIdx : column.level - column.parent.level;\n}\n//#endregion\n//#region src/cellRenderers/renderCheckbox.tsx\nconst checkboxClassname = `rdg-checkbox-input rdg-7-0-0-beta-58-3b807ead`;\nfunction renderCheckbox({ onChange, indeterminate, ...props }) {\n    function handleChange(e) {\n        onChange(e.target.checked, e.nativeEvent.shiftKey);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", {\n        ref: (el)=>{\n            if (el) el.indeterminate = indeterminate === true;\n        },\n        type: \"checkbox\",\n        className: checkboxClassname,\n        onChange: handleChange,\n        ...props\n    });\n}\n//#endregion\n//#region src/cellRenderers/renderToggleGroup.tsx\nconst groupCellContentClassname = `rdg-group-cell-content rdg-7-0-0-beta-58-07919382`;\nconst caretClassname = `rdg-caret rdg-7-0-0-beta-58-02a50147`;\nfunction renderToggleGroup(props) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleGroup, {\n        ...props\n    });\n}\nfunction ToggleGroup({ groupKey, isExpanded, tabIndex, toggleGroup }) {\n    function handleKeyDown({ key }) {\n        if (key === \"Enter\") toggleGroup();\n    }\n    const d = isExpanded ? \"M1 1 L 7 7 L 13 1\" : \"M1 7 L 7 1 L 13 7\";\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", {\n        className: groupCellContentClassname,\n        tabIndex,\n        onKeyDown: handleKeyDown,\n        children: [\n            groupKey,\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"svg\", {\n                viewBox: \"0 0 14 8\",\n                width: \"14\",\n                height: \"8\",\n                className: caretClassname,\n                \"aria-hidden\": true,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", {\n                    d\n                })\n            })\n        ]\n    });\n}\n//#endregion\n//#region src/cellRenderers/renderValue.tsx\nfunction renderValue(props) {\n    try {\n        return props.row[props.column.key];\n    } catch  {\n        return null;\n    }\n}\n//#endregion\n//#region src/DataGridDefaultRenderersContext.ts\nconst DataGridDefaultRenderersContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useDefaultRenderers() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DataGridDefaultRenderersContext);\n}\n//#endregion\n//#region src/cellRenderers/SelectCellFormatter.tsx\nfunction SelectCellFormatter({ value, tabIndex, indeterminate, disabled, onChange, \"aria-label\": ariaLabel, \"aria-labelledby\": ariaLabelledBy }) {\n    const renderCheckbox$1 = useDefaultRenderers().renderCheckbox;\n    return renderCheckbox$1({\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        tabIndex,\n        indeterminate,\n        disabled,\n        checked: value,\n        onChange\n    });\n}\n//#endregion\n//#region src/hooks/useRowSelection.ts\nconst RowSelectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst RowSelectionChangeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useRowSelection() {\n    const rowSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RowSelectionContext);\n    const rowSelectionChangeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RowSelectionChangeContext);\n    if (rowSelectionContext === void 0 || rowSelectionChangeContext === void 0) throw new Error(\"useRowSelection must be used within renderCell\");\n    return {\n        isRowSelectionDisabled: rowSelectionContext.isRowSelectionDisabled,\n        isRowSelected: rowSelectionContext.isRowSelected,\n        onRowSelectionChange: rowSelectionChangeContext\n    };\n}\nconst HeaderRowSelectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst HeaderRowSelectionChangeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useHeaderRowSelection() {\n    const headerRowSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(HeaderRowSelectionContext);\n    const headerRowSelectionChangeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(HeaderRowSelectionChangeContext);\n    if (headerRowSelectionContext === void 0 || headerRowSelectionChangeContext === void 0) throw new Error(\"useHeaderRowSelection must be used within renderHeaderCell\");\n    return {\n        isIndeterminate: headerRowSelectionContext.isIndeterminate,\n        isRowSelected: headerRowSelectionContext.isRowSelected,\n        onRowSelectionChange: headerRowSelectionChangeContext\n    };\n}\n//#endregion\n//#region src/Columns.tsx\nconst SELECT_COLUMN_KEY = \"rdg-select-column\";\nfunction HeaderRenderer(props) {\n    const { isIndeterminate, isRowSelected, onRowSelectionChange } = useHeaderRowSelection();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select All\",\n        tabIndex: props.tabIndex,\n        indeterminate: isIndeterminate,\n        value: isRowSelected,\n        onChange: (checked)=>{\n            onRowSelectionChange({\n                checked: isIndeterminate ? false : checked\n            });\n        }\n    });\n}\nfunction SelectFormatter(props) {\n    const { isRowSelectionDisabled, isRowSelected, onRowSelectionChange } = useRowSelection();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select\",\n        tabIndex: props.tabIndex,\n        disabled: isRowSelectionDisabled,\n        value: isRowSelected,\n        onChange: (checked, isShiftClick)=>{\n            onRowSelectionChange({\n                row: props.row,\n                checked,\n                isShiftClick\n            });\n        }\n    });\n}\nfunction SelectGroupFormatter(props) {\n    const { isRowSelected, onRowSelectionChange } = useRowSelection();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectCellFormatter, {\n        \"aria-label\": \"Select Group\",\n        tabIndex: props.tabIndex,\n        value: isRowSelected,\n        onChange: (checked)=>{\n            onRowSelectionChange({\n                row: props.row,\n                checked,\n                isShiftClick: false\n            });\n        }\n    });\n}\nconst SelectColumn = {\n    key: SELECT_COLUMN_KEY,\n    name: \"\",\n    width: 35,\n    minWidth: 35,\n    maxWidth: 35,\n    resizable: false,\n    sortable: false,\n    frozen: true,\n    renderHeaderCell (props) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(HeaderRenderer, {\n            ...props\n        });\n    },\n    renderCell (props) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectFormatter, {\n            ...props\n        });\n    },\n    renderGroupCell (props) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectGroupFormatter, {\n            ...props\n        });\n    }\n};\n//#endregion\n//#region src/renderHeaderCell.tsx\nconst headerSortCellClassname = \"rdg-7-0-0-beta-58-56a248e4\";\nconst headerSortNameClassname = `rdg-header-sort-name rdg-7-0-0-beta-58-7fad8c83`;\nfunction renderHeaderCell({ column, sortDirection, priority }) {\n    if (!column.sortable) return column.name;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SortableHeaderCell, {\n        sortDirection,\n        priority,\n        children: column.name\n    });\n}\nfunction SortableHeaderCell({ sortDirection, priority, children }) {\n    const renderSortStatus$1 = useDefaultRenderers().renderSortStatus;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", {\n        className: headerSortCellClassname,\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n                className: headerSortNameClassname,\n                children\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n                children: renderSortStatus$1({\n                    sortDirection,\n                    priority\n                })\n            })\n        ]\n    });\n}\n//#endregion\n//#region src/hooks/useCalculatedColumns.ts\nconst DEFAULT_COLUMN_WIDTH = \"auto\";\nconst DEFAULT_COLUMN_MIN_WIDTH = 50;\nfunction useCalculatedColumns({ rawColumns, defaultColumnOptions, getColumnWidth, viewportWidth, scrollLeft, enableVirtualization }) {\n    const defaultWidth = defaultColumnOptions?.width ?? DEFAULT_COLUMN_WIDTH;\n    const defaultMinWidth = defaultColumnOptions?.minWidth ?? DEFAULT_COLUMN_MIN_WIDTH;\n    const defaultMaxWidth = defaultColumnOptions?.maxWidth ?? void 0;\n    const defaultRenderCell$1 = defaultColumnOptions?.renderCell ?? renderValue;\n    const defaultRenderHeaderCell = defaultColumnOptions?.renderHeaderCell ?? renderHeaderCell;\n    const defaultSortable = defaultColumnOptions?.sortable ?? false;\n    const defaultResizable = defaultColumnOptions?.resizable ?? false;\n    const defaultDraggable = defaultColumnOptions?.draggable ?? false;\n    const { columns, colSpanColumns, lastFrozenColumnIndex, headerRowsCount } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let lastFrozenColumnIndex$1 = -1;\n        let headerRowsCount$1 = 1;\n        const columns$1 = [];\n        collectColumns(rawColumns, 1);\n        function collectColumns(rawColumns$1, level, parent) {\n            for (const rawColumn of rawColumns$1){\n                if (\"children\" in rawColumn) {\n                    const calculatedColumnParent = {\n                        name: rawColumn.name,\n                        parent,\n                        idx: -1,\n                        colSpan: 0,\n                        level: 0,\n                        headerCellClass: rawColumn.headerCellClass\n                    };\n                    collectColumns(rawColumn.children, level + 1, calculatedColumnParent);\n                    continue;\n                }\n                const frozen = rawColumn.frozen ?? false;\n                const column = {\n                    ...rawColumn,\n                    parent,\n                    idx: 0,\n                    level: 0,\n                    frozen,\n                    width: rawColumn.width ?? defaultWidth,\n                    minWidth: rawColumn.minWidth ?? defaultMinWidth,\n                    maxWidth: rawColumn.maxWidth ?? defaultMaxWidth,\n                    sortable: rawColumn.sortable ?? defaultSortable,\n                    resizable: rawColumn.resizable ?? defaultResizable,\n                    draggable: rawColumn.draggable ?? defaultDraggable,\n                    renderCell: rawColumn.renderCell ?? defaultRenderCell$1,\n                    renderHeaderCell: rawColumn.renderHeaderCell ?? defaultRenderHeaderCell\n                };\n                columns$1.push(column);\n                if (frozen) lastFrozenColumnIndex$1++;\n                if (level > headerRowsCount$1) headerRowsCount$1 = level;\n            }\n        }\n        columns$1.sort(({ key: aKey, frozen: frozenA }, { key: bKey, frozen: frozenB })=>{\n            if (aKey === SELECT_COLUMN_KEY) return -1;\n            if (bKey === SELECT_COLUMN_KEY) return 1;\n            if (frozenA) {\n                if (frozenB) return 0;\n                return -1;\n            }\n            if (frozenB) return 1;\n            return 0;\n        });\n        const colSpanColumns$1 = [];\n        columns$1.forEach((column, idx)=>{\n            column.idx = idx;\n            updateColumnParent(column, idx, 0);\n            if (column.colSpan != null) colSpanColumns$1.push(column);\n        });\n        return {\n            columns: columns$1,\n            colSpanColumns: colSpanColumns$1,\n            lastFrozenColumnIndex: lastFrozenColumnIndex$1,\n            headerRowsCount: headerRowsCount$1\n        };\n    }, [\n        rawColumns,\n        defaultWidth,\n        defaultMinWidth,\n        defaultMaxWidth,\n        defaultRenderCell$1,\n        defaultRenderHeaderCell,\n        defaultResizable,\n        defaultSortable,\n        defaultDraggable\n    ]);\n    const { templateColumns, layoutCssVars, totalFrozenColumnWidth, columnMetrics } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const columnMetrics$1 = /* @__PURE__ */ new Map();\n        let left = 0;\n        let totalFrozenColumnWidth$1 = 0;\n        const templateColumns$1 = [];\n        for (const column of columns){\n            let width = getColumnWidth(column);\n            if (typeof width === \"number\") width = clampColumnWidth(width, column);\n            else width = column.minWidth;\n            templateColumns$1.push(`${width}px`);\n            columnMetrics$1.set(column, {\n                width,\n                left\n            });\n            left += width;\n        }\n        if (lastFrozenColumnIndex !== -1) {\n            const columnMetric = columnMetrics$1.get(columns[lastFrozenColumnIndex]);\n            totalFrozenColumnWidth$1 = columnMetric.left + columnMetric.width;\n        }\n        const layoutCssVars$1 = {};\n        for(let i = 0; i <= lastFrozenColumnIndex; i++){\n            const column = columns[i];\n            layoutCssVars$1[`--rdg-frozen-left-${column.idx}`] = `${columnMetrics$1.get(column).left}px`;\n        }\n        return {\n            templateColumns: templateColumns$1,\n            layoutCssVars: layoutCssVars$1,\n            totalFrozenColumnWidth: totalFrozenColumnWidth$1,\n            columnMetrics: columnMetrics$1\n        };\n    }, [\n        getColumnWidth,\n        columns,\n        lastFrozenColumnIndex\n    ]);\n    const [colOverscanStartIdx, colOverscanEndIdx] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!enableVirtualization) return [\n            0,\n            columns.length - 1\n        ];\n        const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n        const viewportRight = scrollLeft + viewportWidth;\n        const lastColIdx = columns.length - 1;\n        const firstUnfrozenColumnIdx = min(lastFrozenColumnIndex + 1, lastColIdx);\n        if (viewportLeft >= viewportRight) return [\n            firstUnfrozenColumnIdx,\n            firstUnfrozenColumnIdx\n        ];\n        let colVisibleStartIdx = firstUnfrozenColumnIdx;\n        while(colVisibleStartIdx < lastColIdx){\n            const { left, width } = columnMetrics.get(columns[colVisibleStartIdx]);\n            if (left + width > viewportLeft) break;\n            colVisibleStartIdx++;\n        }\n        let colVisibleEndIdx = colVisibleStartIdx;\n        while(colVisibleEndIdx < lastColIdx){\n            const { left, width } = columnMetrics.get(columns[colVisibleEndIdx]);\n            if (left + width >= viewportRight) break;\n            colVisibleEndIdx++;\n        }\n        return [\n            max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1),\n            min(lastColIdx, colVisibleEndIdx + 1)\n        ];\n    }, [\n        columnMetrics,\n        columns,\n        lastFrozenColumnIndex,\n        scrollLeft,\n        totalFrozenColumnWidth,\n        viewportWidth,\n        enableVirtualization\n    ]);\n    return {\n        columns,\n        colSpanColumns,\n        colOverscanStartIdx,\n        colOverscanEndIdx,\n        templateColumns,\n        layoutCssVars,\n        headerRowsCount,\n        lastFrozenColumnIndex,\n        totalFrozenColumnWidth\n    };\n}\nfunction updateColumnParent(column, index, level) {\n    if (level < column.level) column.level = level;\n    if (column.parent !== void 0) {\n        const { parent } = column;\n        if (parent.idx === -1) parent.idx = index;\n        parent.colSpan += 1;\n        updateColumnParent(parent, index, level - 1);\n    }\n}\n//#endregion\n//#region src/hooks/useColumnWidths.ts\nfunction useColumnWidths(columns, viewportColumns, templateColumns, gridRef, gridWidth, columnWidths, onColumnWidthsChange, onColumnResize, setColumnResizing) {\n    const [columnToAutoResize, setColumnToAutoResize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [columnsToMeasureOnResize, setColumnsToMeasureOnResize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [prevGridWidth, setPreviousGridWidth] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(gridWidth);\n    const columnsCanFlex = columns.length === viewportColumns.length;\n    const ignorePreviouslyMeasuredColumnsOnGridWidthChange = columnsCanFlex && gridWidth !== prevGridWidth;\n    const newTemplateColumns = [\n        ...templateColumns\n    ];\n    const columnsToMeasure = [];\n    for (const { key, idx, width } of viewportColumns){\n        const columnWidth = columnWidths.get(key);\n        if (key === columnToAutoResize?.key) {\n            newTemplateColumns[idx] = columnToAutoResize.width === \"max-content\" ? columnToAutoResize.width : `${columnToAutoResize.width}px`;\n            columnsToMeasure.push(key);\n        } else if (typeof width === \"string\" && columnWidth?.type !== \"resized\" && (ignorePreviouslyMeasuredColumnsOnGridWidthChange || columnsToMeasureOnResize?.has(key) === true || columnWidth === void 0)) {\n            newTemplateColumns[idx] = width;\n            columnsToMeasure.push(key);\n        }\n    }\n    const gridTemplateColumns = newTemplateColumns.join(\" \");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(updateMeasuredAndResizedWidths);\n    function updateMeasuredAndResizedWidths() {\n        setPreviousGridWidth(gridWidth);\n        if (columnsToMeasure.length === 0) return;\n        const newColumnWidths = new Map(columnWidths);\n        let hasChanges = false;\n        for (const key of columnsToMeasure){\n            const measuredWidth = measureColumnWidth(gridRef, key);\n            hasChanges ||= measuredWidth !== columnWidths.get(key)?.width;\n            if (measuredWidth === void 0) newColumnWidths.delete(key);\n            else newColumnWidths.set(key, {\n                type: \"measured\",\n                width: measuredWidth\n            });\n        }\n        if (columnToAutoResize !== null) {\n            const resizingKey = columnToAutoResize.key;\n            const oldWidth = columnWidths.get(resizingKey)?.width;\n            const newWidth = measureColumnWidth(gridRef, resizingKey);\n            if (newWidth !== void 0 && oldWidth !== newWidth) {\n                hasChanges = true;\n                newColumnWidths.set(resizingKey, {\n                    type: \"resized\",\n                    width: newWidth\n                });\n            }\n            setColumnToAutoResize(null);\n        }\n        if (hasChanges) onColumnWidthsChange(newColumnWidths);\n    }\n    function handleColumnResize(column, nextWidth) {\n        const { key: resizingKey } = column;\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            if (columnsCanFlex) {\n                const columnsToRemeasure = /* @__PURE__ */ new Set();\n                for (const { key, width } of viewportColumns)if (resizingKey !== key && typeof width === \"string\" && columnWidths.get(key)?.type !== \"resized\") columnsToRemeasure.add(key);\n                setColumnsToMeasureOnResize(columnsToRemeasure);\n            }\n            setColumnToAutoResize({\n                key: resizingKey,\n                width: nextWidth\n            });\n            setColumnResizing(typeof nextWidth === \"number\");\n        });\n        setColumnsToMeasureOnResize(null);\n        if (onColumnResize) {\n            const previousWidth = columnWidths.get(resizingKey)?.width;\n            const newWidth = typeof nextWidth === \"number\" ? nextWidth : measureColumnWidth(gridRef, resizingKey);\n            if (newWidth !== void 0 && newWidth !== previousWidth) onColumnResize(column, newWidth);\n        }\n    }\n    return {\n        gridTemplateColumns,\n        handleColumnResize\n    };\n}\nfunction measureColumnWidth(gridRef, key) {\n    const selector = `[data-measuring-cell-key=\"${CSS.escape(key)}\"]`;\n    return gridRef.current?.querySelector(selector)?.getBoundingClientRect().width;\n}\n//#endregion\n//#region src/hooks/useGridDimensions.ts\nfunction useGridDimensions() {\n    const gridRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [inlineSize, setInlineSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [blockSize, setBlockSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [horizontalScrollbarHeight, setHorizontalScrollbarHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        const { ResizeObserver } = window;\n        if (ResizeObserver == null) return;\n        const { clientWidth, clientHeight, offsetWidth, offsetHeight } = gridRef.current;\n        const { width, height } = gridRef.current.getBoundingClientRect();\n        const initialHorizontalScrollbarHeight = offsetHeight - clientHeight;\n        const initialWidth = width - offsetWidth + clientWidth;\n        const initialHeight = height - initialHorizontalScrollbarHeight;\n        setInlineSize(initialWidth);\n        setBlockSize(initialHeight);\n        setHorizontalScrollbarHeight(initialHorizontalScrollbarHeight);\n        const resizeObserver = new ResizeObserver((entries)=>{\n            const size = entries[0].contentBoxSize[0];\n            const { clientHeight: clientHeight$1, offsetHeight: offsetHeight$1 } = gridRef.current;\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                setInlineSize(size.inlineSize);\n                setBlockSize(size.blockSize);\n                setHorizontalScrollbarHeight(offsetHeight$1 - clientHeight$1);\n            });\n        });\n        resizeObserver.observe(gridRef.current);\n        return ()=>{\n            resizeObserver.disconnect();\n        };\n    }, []);\n    return [\n        gridRef,\n        inlineSize,\n        blockSize,\n        horizontalScrollbarHeight\n    ];\n}\n//#endregion\n//#region src/hooks/useLatestFunc.ts\nfunction useLatestFunc(fn) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fn);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        ref.current = fn;\n    });\n    const callbackFn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        ref.current(...args);\n    }, []);\n    return fn ? callbackFn : fn;\n}\n//#endregion\n//#region src/hooks/useRovingTabIndex.ts\nfunction useRovingTabIndex(isSelected) {\n    const [isChildFocused, setIsChildFocused] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    if (isChildFocused && !isSelected) setIsChildFocused(false);\n    function onFocus(event) {\n        if (event.target === event.currentTarget) {\n            const elementToFocus = event.currentTarget.querySelector('[tabindex=\"0\"]');\n            if (elementToFocus !== null) {\n                elementToFocus.focus({\n                    preventScroll: true\n                });\n                setIsChildFocused(true);\n            } else setIsChildFocused(false);\n        } else setIsChildFocused(true);\n    }\n    return {\n        tabIndex: isSelected && !isChildFocused ? 0 : -1,\n        childTabIndex: isSelected ? 0 : -1,\n        onFocus: isSelected ? onFocus : void 0\n    };\n}\n//#endregion\n//#region src/hooks/useViewportColumns.ts\nfunction useViewportColumns({ columns, colSpanColumns, rows, topSummaryRows, bottomSummaryRows, colOverscanStartIdx, colOverscanEndIdx, lastFrozenColumnIndex, rowOverscanStartIdx, rowOverscanEndIdx }) {\n    const startIdx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (colOverscanStartIdx === 0) return 0;\n        let startIdx$1 = colOverscanStartIdx;\n        const updateStartIdx = (colIdx, colSpan)=>{\n            if (colSpan !== void 0 && colIdx + colSpan > colOverscanStartIdx) {\n                startIdx$1 = colIdx;\n                return true;\n            }\n            return false;\n        };\n        for (const column of colSpanColumns){\n            const colIdx = column.idx;\n            if (colIdx >= startIdx$1) break;\n            if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                type: \"HEADER\"\n            }))) break;\n            for(let rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++){\n                const row$1 = rows[rowIdx];\n                if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                    type: \"ROW\",\n                    row: row$1\n                }))) break;\n            }\n            if (topSummaryRows != null) {\n                for (const row$1 of topSummaryRows)if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                    type: \"SUMMARY\",\n                    row: row$1\n                }))) break;\n            }\n            if (bottomSummaryRows != null) {\n                for (const row$1 of bottomSummaryRows)if (updateStartIdx(colIdx, getColSpan(column, lastFrozenColumnIndex, {\n                    type: \"SUMMARY\",\n                    row: row$1\n                }))) break;\n            }\n        }\n        return startIdx$1;\n    }, [\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        rows,\n        topSummaryRows,\n        bottomSummaryRows,\n        colOverscanStartIdx,\n        lastFrozenColumnIndex,\n        colSpanColumns\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const viewportColumns = [];\n        for(let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++){\n            const column = columns[colIdx];\n            if (colIdx < startIdx && !column.frozen) continue;\n            viewportColumns.push(column);\n        }\n        return viewportColumns;\n    }, [\n        startIdx,\n        colOverscanEndIdx,\n        columns\n    ]);\n}\n//#endregion\n//#region src/hooks/useViewportRows.ts\nfunction useViewportRows({ rows, rowHeight, clientHeight, scrollTop, enableVirtualization }) {\n    const { totalRowHeight, gridTemplateRows, getRowTop, getRowHeight, findRowIdx } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof rowHeight === \"number\") return {\n            totalRowHeight: rowHeight * rows.length,\n            gridTemplateRows: ` repeat(${rows.length}, ${rowHeight}px)`,\n            getRowTop: (rowIdx)=>rowIdx * rowHeight,\n            getRowHeight: ()=>rowHeight,\n            findRowIdx: (offset)=>floor(offset / rowHeight)\n        };\n        let totalRowHeight$1 = 0;\n        let gridTemplateRows$1 = \"\";\n        let currentHeight = null;\n        let repeatCount = 0;\n        const rowPositions = rows.map((row$1, index)=>{\n            const currentRowHeight = rowHeight(row$1);\n            const position = {\n                top: totalRowHeight$1,\n                height: currentRowHeight\n            };\n            totalRowHeight$1 += currentRowHeight;\n            if (currentHeight === null) {\n                currentHeight = currentRowHeight;\n                repeatCount = 1;\n            } else if (currentHeight === currentRowHeight) repeatCount++;\n            else {\n                if (repeatCount > 1) gridTemplateRows$1 += `repeat(${repeatCount}, ${currentHeight}px) `;\n                else gridTemplateRows$1 += `${currentHeight}px `;\n                currentHeight = currentRowHeight;\n                repeatCount = 1;\n            }\n            if (index === rows.length - 1) if (repeatCount > 1) gridTemplateRows$1 += `repeat(${repeatCount}, ${currentHeight}px)`;\n            else gridTemplateRows$1 += `${currentHeight}px`;\n            return position;\n        });\n        const validateRowIdx = (rowIdx)=>{\n            return max(0, min(rows.length - 1, rowIdx));\n        };\n        return {\n            totalRowHeight: totalRowHeight$1,\n            gridTemplateRows: gridTemplateRows$1,\n            getRowTop: (rowIdx)=>rowPositions[validateRowIdx(rowIdx)].top,\n            getRowHeight: (rowIdx)=>rowPositions[validateRowIdx(rowIdx)].height,\n            findRowIdx (offset) {\n                let start = 0;\n                let end = rowPositions.length - 1;\n                while(start <= end){\n                    const middle = start + floor((end - start) / 2);\n                    const currentOffset = rowPositions[middle].top;\n                    if (currentOffset === offset) return middle;\n                    if (currentOffset < offset) start = middle + 1;\n                    else if (currentOffset > offset) end = middle - 1;\n                    if (start > end) return end;\n                }\n                return 0;\n            }\n        };\n    }, [\n        rowHeight,\n        rows\n    ]);\n    let rowOverscanStartIdx = 0;\n    let rowOverscanEndIdx = rows.length - 1;\n    if (enableVirtualization) {\n        const overscanThreshold = 4;\n        const rowVisibleStartIdx = findRowIdx(scrollTop);\n        const rowVisibleEndIdx = findRowIdx(scrollTop + clientHeight);\n        rowOverscanStartIdx = max(0, rowVisibleStartIdx - overscanThreshold);\n        rowOverscanEndIdx = min(rows.length - 1, rowVisibleEndIdx + overscanThreshold);\n    }\n    return {\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        totalRowHeight,\n        gridTemplateRows,\n        getRowTop,\n        getRowHeight,\n        findRowIdx\n    };\n}\n//#endregion\n//#region src/Cell.tsx\nconst cellDraggedOverClassname = `rdg-cell-dragged-over rdg-7-0-0-beta-58-35ccb4c8`;\nfunction Cell({ column, colSpan, isCellSelected, isDraggedOver, row: row$1, rowIdx, className, onMouseDown, onCellMouseDown, onClick, onCellClick, onDoubleClick, onCellDoubleClick, onContextMenu, onCellContextMenu, onRowChange, selectCell, style, ...props }) {\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { cellClass } = column;\n    className = getCellClassname(column, {\n        [cellDraggedOverClassname]: isDraggedOver\n    }, typeof cellClass === \"function\" ? cellClass(row$1) : cellClass, className);\n    const isEditable = isCellEditableUtil(column, row$1);\n    function selectCellWrapper(enableEditor) {\n        selectCell({\n            rowIdx,\n            idx: column.idx\n        }, {\n            enableEditor\n        });\n    }\n    function handleMouseEvent(event, eventHandler) {\n        let eventHandled = false;\n        if (eventHandler) {\n            const cellEvent = createCellEvent(event);\n            eventHandler({\n                rowIdx,\n                row: row$1,\n                column,\n                selectCell: selectCellWrapper\n            }, cellEvent);\n            eventHandled = cellEvent.isGridDefaultPrevented();\n        }\n        return eventHandled;\n    }\n    function handleMouseDown(event) {\n        onMouseDown?.(event);\n        if (!handleMouseEvent(event, onCellMouseDown)) selectCellWrapper();\n    }\n    function handleClick(event) {\n        onClick?.(event);\n        handleMouseEvent(event, onCellClick);\n    }\n    function handleDoubleClick(event) {\n        onDoubleClick?.(event);\n        if (!handleMouseEvent(event, onCellDoubleClick)) selectCellWrapper(true);\n    }\n    function handleContextMenu(event) {\n        onContextMenu?.(event);\n        handleMouseEvent(event, onCellContextMenu);\n    }\n    function handleRowChange(newRow) {\n        onRowChange(column, newRow);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": isCellSelected,\n        \"aria-readonly\": !isEditable || void 0,\n        tabIndex,\n        className,\n        style: {\n            ...getCellStyle(column, colSpan),\n            ...style\n        },\n        onClick: handleClick,\n        onMouseDown: handleMouseDown,\n        onDoubleClick: handleDoubleClick,\n        onContextMenu: handleContextMenu,\n        onFocus,\n        ...props,\n        children: column.renderCell({\n            column,\n            row: row$1,\n            rowIdx,\n            isCellEditable: isEditable,\n            tabIndex: childTabIndex,\n            onRowChange: handleRowChange\n        })\n    });\n}\nconst CellComponent = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Cell);\nvar Cell_default = CellComponent;\nfunction defaultRenderCell(key, props) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CellComponent, {\n        ...props\n    }, key);\n}\n//#endregion\n//#region src/EditCell.tsx\nconst canUsePostTask = typeof scheduler === \"object\" && typeof scheduler.postTask === \"function\";\nconst cellEditing = \"rdg-7-0-0-beta-58-46f9ea88\";\nfunction EditCell({ column, colSpan, row: row$1, rowIdx, onRowChange, closeEditor, onKeyDown, navigate }) {\n    const captureEventRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    const frameRequestRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    const commitOnOutsideClick = column.editorOptions?.commitOnOutsideClick ?? true;\n    const commitOnOutsideMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffectEvent)(()=>{\n        onClose(true, false);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!commitOnOutsideClick) return;\n        function onWindowCaptureMouseDown(event) {\n            captureEventRef.current = event;\n            if (canUsePostTask) {\n                const abortController = new AbortController();\n                const { signal } = abortController;\n                abortControllerRef.current = abortController;\n                scheduler.postTask(commitOnOutsideMouseDown, {\n                    priority: \"user-blocking\",\n                    signal\n                }).catch(()=>{});\n            } else frameRequestRef.current = requestAnimationFrame(commitOnOutsideMouseDown);\n        }\n        function onWindowMouseDown(event) {\n            if (captureEventRef.current === event) commitOnOutsideMouseDown();\n        }\n        addEventListener(\"mousedown\", onWindowCaptureMouseDown, {\n            capture: true\n        });\n        addEventListener(\"mousedown\", onWindowMouseDown);\n        return ()=>{\n            removeEventListener(\"mousedown\", onWindowCaptureMouseDown, {\n                capture: true\n            });\n            removeEventListener(\"mousedown\", onWindowMouseDown);\n            cancelTask();\n        };\n    }, [\n        commitOnOutsideClick\n    ]);\n    function cancelTask() {\n        captureEventRef.current = void 0;\n        if (abortControllerRef.current !== void 0) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = void 0;\n        }\n        if (frameRequestRef.current !== void 0) {\n            cancelAnimationFrame(frameRequestRef.current);\n            frameRequestRef.current = void 0;\n        }\n    }\n    function handleKeyDown(event) {\n        if (onKeyDown) {\n            const cellEvent = createCellEvent(event);\n            onKeyDown({\n                mode: \"EDIT\",\n                row: row$1,\n                column,\n                rowIdx,\n                navigate () {\n                    navigate(event);\n                },\n                onClose\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        if (event.key === \"Escape\") onClose();\n        else if (event.key === \"Enter\") onClose(true);\n        else if (onEditorNavigation(event)) navigate(event);\n    }\n    function onClose(commitChanges = false, shouldFocusCell = true) {\n        if (commitChanges) onRowChange(row$1, true, shouldFocusCell);\n        else closeEditor(shouldFocusCell);\n    }\n    function onEditorRowChange(row$2, commitChangesAndFocus = false) {\n        onRowChange(row$2, commitChangesAndFocus, commitChangesAndFocus);\n    }\n    const { cellClass } = column;\n    const className = getCellClassname(column, \"rdg-editor-container\", !column.editorOptions?.displayCellContent && cellEditing, typeof cellClass === \"function\" ? cellClass(row$1) : cellClass);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": true,\n        className,\n        style: getCellStyle(column, colSpan),\n        onKeyDown: handleKeyDown,\n        onMouseDownCapture: cancelTask,\n        children: column.renderEditCell != null && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n            children: [\n                column.renderEditCell({\n                    column,\n                    row: row$1,\n                    rowIdx,\n                    onRowChange: onEditorRowChange,\n                    onClose\n                }),\n                column.editorOptions?.displayCellContent && column.renderCell({\n                    column,\n                    row: row$1,\n                    rowIdx,\n                    isCellEditable: true,\n                    tabIndex: -1,\n                    onRowChange: onEditorRowChange\n                })\n            ]\n        })\n    });\n}\n//#endregion\n//#region src/GroupedColumnHeaderCell.tsx\nfunction GroupedColumnHeaderCell({ column, rowIdx, isCellSelected, selectCell }) {\n    const { tabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { colSpan } = column;\n    const rowSpan = getHeaderCellRowSpan(column, rowIdx);\n    const index = column.idx + 1;\n    function onMouseDown() {\n        selectCell({\n            idx: column.idx,\n            rowIdx\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"columnheader\",\n        \"aria-colindex\": index,\n        \"aria-colspan\": colSpan,\n        \"aria-rowspan\": rowSpan,\n        \"aria-selected\": isCellSelected,\n        tabIndex,\n        className: classnames(cellClassname, column.headerCellClass),\n        style: {\n            ...getHeaderCellStyle(column, rowIdx, rowSpan),\n            gridColumnStart: index,\n            gridColumnEnd: index + colSpan\n        },\n        onFocus,\n        onMouseDown,\n        children: column.name\n    });\n}\n//#endregion\n//#region src/HeaderCell.tsx\nconst cellSortableClassname = \"rdg-7-0-0-beta-58-2a7e240d\";\nconst cellResizableClassname = `rdg-cell-resizable rdg-7-0-0-beta-58-1893dc0f`;\nconst resizeHandleClassname = `rdg-resize-handle rdg-7-0-0-beta-58-4e60db91`;\nconst cellDraggableClassname = \"rdg-cell-draggable\";\nconst cellDraggingClassname = `rdg-cell-dragging rdg-7-0-0-beta-58-3e1a4ad4`;\nconst cellOverClassname = `rdg-cell-drag-over rdg-7-0-0-beta-58-51abd8b8`;\nconst dragImageClassname = \"rdg-7-0-0-beta-58-c8d7aa64\";\nfunction HeaderCell({ column, colSpan, rowIdx, isCellSelected, onColumnResize, onColumnResizeEnd, onColumnsReorder, sortColumns, onSortColumnsChange, selectCell, shouldFocusGrid, direction, draggedColumnKey, setDraggedColumnKey }) {\n    const [isOver, setIsOver] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const dragImageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isDragging = draggedColumnKey === column.key;\n    const rowSpan = getHeaderCellRowSpan(column, rowIdx);\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(shouldFocusGrid || isCellSelected);\n    const sortIndex = sortColumns?.findIndex((sort)=>sort.columnKey === column.key);\n    const sortColumn = sortIndex !== void 0 && sortIndex > -1 ? sortColumns[sortIndex] : void 0;\n    const sortDirection = sortColumn?.direction;\n    const priority = sortColumn !== void 0 && sortColumns.length > 1 ? sortIndex + 1 : void 0;\n    const ariaSort = sortDirection && !priority ? sortDirection === \"ASC\" ? \"ascending\" : \"descending\" : void 0;\n    const { sortable, resizable, draggable } = column;\n    const className = getCellClassname(column, column.headerCellClass, {\n        [cellSortableClassname]: sortable,\n        [cellResizableClassname]: resizable,\n        [cellDraggableClassname]: draggable,\n        [cellDraggingClassname]: isDragging,\n        [cellOverClassname]: isOver\n    });\n    function onSort(ctrlClick) {\n        if (onSortColumnsChange == null) return;\n        const { sortDescendingFirst } = column;\n        if (sortColumn === void 0) {\n            const nextSort = {\n                columnKey: column.key,\n                direction: sortDescendingFirst ? \"DESC\" : \"ASC\"\n            };\n            onSortColumnsChange(sortColumns && ctrlClick ? [\n                ...sortColumns,\n                nextSort\n            ] : [\n                nextSort\n            ]);\n        } else {\n            let nextSortColumn;\n            if (sortDescendingFirst === true && sortDirection === \"DESC\" || sortDescendingFirst !== true && sortDirection === \"ASC\") nextSortColumn = {\n                columnKey: column.key,\n                direction: sortDirection === \"ASC\" ? \"DESC\" : \"ASC\"\n            };\n            if (ctrlClick) {\n                const nextSortColumns = [\n                    ...sortColumns\n                ];\n                if (nextSortColumn) nextSortColumns[sortIndex] = nextSortColumn;\n                else nextSortColumns.splice(sortIndex, 1);\n                onSortColumnsChange(nextSortColumns);\n            } else onSortColumnsChange(nextSortColumn ? [\n                nextSortColumn\n            ] : []);\n        }\n    }\n    function handleFocus(event) {\n        onFocus?.(event);\n        if (shouldFocusGrid) selectCell({\n            idx: 0,\n            rowIdx\n        });\n    }\n    function onMouseDown() {\n        selectCell({\n            idx: column.idx,\n            rowIdx\n        });\n    }\n    function onClick(event) {\n        if (sortable) onSort(event.ctrlKey || event.metaKey);\n    }\n    function onKeyDown(event) {\n        const { key } = event;\n        if (sortable && (key === \" \" || key === \"Enter\")) {\n            event.preventDefault();\n            onSort(event.ctrlKey || event.metaKey);\n        } else if (resizable && isCtrlKeyHeldDown(event) && (key === \"ArrowLeft\" || key === \"ArrowRight\")) {\n            event.stopPropagation();\n            const { width } = event.currentTarget.getBoundingClientRect();\n            const { leftKey } = getLeftRightKey(direction);\n            const newWidth = clampColumnWidth(width + (key === leftKey ? -10 : 10), column);\n            if (newWidth !== width) onColumnResize(column, newWidth);\n        }\n    }\n    function onDragStart(event) {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            setDraggedColumnKey(column.key);\n        });\n        event.dataTransfer.setDragImage(dragImageRef.current, 0, 0);\n        event.dataTransfer.dropEffect = \"move\";\n    }\n    function onDragEnd() {\n        setDraggedColumnKey(void 0);\n    }\n    function onDragOver(event) {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = \"move\";\n    }\n    function onDrop(event) {\n        setIsOver(false);\n        event.preventDefault();\n        onColumnsReorder?.(draggedColumnKey, column.key);\n    }\n    function onDragEnter(event) {\n        if (isEventPertinent(event)) setIsOver(true);\n    }\n    function onDragLeave(event) {\n        if (isEventPertinent(event)) setIsOver(false);\n    }\n    let dragTargetProps;\n    let dropTargetProps;\n    if (draggable) {\n        dragTargetProps = {\n            draggable: true,\n            onDragStart,\n            onDragEnd\n        };\n        if (draggedColumnKey !== void 0 && draggedColumnKey !== column.key) dropTargetProps = {\n            onDragOver,\n            onDragEnter,\n            onDragLeave,\n            onDrop\n        };\n    }\n    const style = {\n        ...getHeaderCellStyle(column, rowIdx, rowSpan),\n        ...getCellStyle(column, colSpan)\n    };\n    const content = column.renderHeaderCell({\n        column,\n        sortDirection,\n        priority,\n        tabIndex: childTabIndex\n    });\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            isDragging && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                ref: dragImageRef,\n                style,\n                className: getCellClassname(column, column.headerCellClass, dragImageClassname),\n                children: content\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n                role: \"columnheader\",\n                \"aria-colindex\": column.idx + 1,\n                \"aria-colspan\": colSpan,\n                \"aria-rowspan\": rowSpan,\n                \"aria-selected\": isCellSelected,\n                \"aria-sort\": ariaSort,\n                tabIndex,\n                className,\n                style,\n                onMouseDown,\n                onFocus: handleFocus,\n                onClick,\n                onKeyDown,\n                ...dragTargetProps,\n                ...dropTargetProps,\n                children: [\n                    content,\n                    resizable && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ResizeHandle, {\n                        direction,\n                        column,\n                        onColumnResize,\n                        onColumnResizeEnd\n                    })\n                ]\n            })\n        ]\n    });\n}\nfunction ResizeHandle({ direction, column, onColumnResize, onColumnResizeEnd }) {\n    const resizingOffsetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n    const isRtl = direction === \"rtl\";\n    function onPointerDown(event) {\n        if (event.pointerType === \"mouse\" && event.buttons !== 1) return;\n        event.preventDefault();\n        const { currentTarget, pointerId } = event;\n        currentTarget.setPointerCapture(pointerId);\n        const { right, left } = currentTarget.parentElement.getBoundingClientRect();\n        resizingOffsetRef.current = isRtl ? event.clientX - left : right - event.clientX;\n    }\n    function onPointerMove(event) {\n        const offset = resizingOffsetRef.current;\n        if (offset === void 0) return;\n        const { width, right, left } = event.currentTarget.parentElement.getBoundingClientRect();\n        let newWidth = isRtl ? right + offset - event.clientX : event.clientX + offset - left;\n        newWidth = clampColumnWidth(newWidth, column);\n        if (width > 0 && newWidth !== width) onColumnResize(column, newWidth);\n    }\n    function onLostPointerCapture() {\n        onColumnResizeEnd();\n        resizingOffsetRef.current = void 0;\n    }\n    function onDoubleClick() {\n        onColumnResize(column, \"max-content\");\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        \"aria-hidden\": true,\n        className: resizeHandleClassname,\n        onClick: stopPropagation,\n        onPointerDown,\n        onPointerMove,\n        onLostPointerCapture,\n        onDoubleClick\n    });\n}\nfunction isEventPertinent(event) {\n    const relatedTarget = event.relatedTarget;\n    return !event.currentTarget.contains(relatedTarget);\n}\n//#endregion\n//#region src/style/row.ts\nconst row = \"rdg-7-0-0-beta-58-3c083f1b\";\nconst rowClassname = `rdg-row ${row}`;\nconst rowSelected = \"rdg-7-0-0-beta-58-3fe773c3\";\nconst rowSelectedClassname = \"rdg-row-selected\";\nconst rowSelectedWithFrozenCell = \"rdg-7-0-0-beta-58-97ce3fde\";\nconst topSummaryRowClassname = \"rdg-top-summary-row\";\nconst bottomSummaryRowClassname = \"rdg-bottom-summary-row\";\n//#endregion\n//#region src/HeaderRow.tsx\nconst headerRow = \"rdg-7-0-0-beta-58-0dbd5994\";\nconst headerRowClassname = `rdg-header-row ${headerRow}`;\nfunction HeaderRow({ headerRowClass, rowIdx, columns, onColumnResize, onColumnResizeEnd, onColumnsReorder, sortColumns, onSortColumnsChange, lastFrozenColumnIndex, selectedCellIdx, selectCell, shouldFocusGrid, direction }) {\n    const [draggedColumnKey, setDraggedColumnKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const cells = [];\n    for(let index = 0; index < columns.length; index++){\n        const column = columns[index];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"HEADER\"\n        });\n        if (colSpan !== void 0) index += colSpan - 1;\n        cells.push(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(HeaderCell, {\n            column,\n            colSpan,\n            rowIdx,\n            isCellSelected: selectedCellIdx === column.idx,\n            onColumnResize,\n            onColumnResizeEnd,\n            onColumnsReorder,\n            onSortColumnsChange,\n            sortColumns,\n            selectCell,\n            shouldFocusGrid: shouldFocusGrid && index === 0,\n            direction,\n            draggedColumnKey,\n            setDraggedColumnKey\n        }, column.key));\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": rowIdx,\n        className: classnames(headerRowClassname, {\n            [rowSelectedClassname]: selectedCellIdx === -1\n        }, headerRowClass),\n        children: cells\n    });\n}\nvar HeaderRow_default = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(HeaderRow);\n//#endregion\n//#region src/GroupedColumnHeaderRow.tsx\nfunction GroupedColumnHeaderRow({ rowIdx, level, columns, selectedCellIdx, selectCell }) {\n    const cells = [];\n    const renderedParents = /* @__PURE__ */ new Set();\n    for (const column of columns){\n        let { parent } = column;\n        if (parent === void 0) continue;\n        while(parent.level > level){\n            if (parent.parent === void 0) break;\n            parent = parent.parent;\n        }\n        if (parent.level === level && !renderedParents.has(parent)) {\n            renderedParents.add(parent);\n            const { idx } = parent;\n            cells.push(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GroupedColumnHeaderCell, {\n                column: parent,\n                rowIdx,\n                isCellSelected: selectedCellIdx === idx,\n                selectCell\n            }, idx));\n        }\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": rowIdx,\n        className: headerRowClassname,\n        children: cells\n    });\n}\nvar GroupedColumnHeaderRow_default = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupedColumnHeaderRow);\n//#endregion\n//#region src/Row.tsx\nfunction Row({ className, rowIdx, gridRowStart, selectedCellIdx, isRowSelectionDisabled, isRowSelected, draggedOverCellIdx, lastFrozenColumnIndex, row: row$1, viewportColumns, selectedCellEditor, onCellMouseDown, onCellClick, onCellDoubleClick, onCellContextMenu, rowClass, onRowChange, selectCell, style, ...props }) {\n    const renderCell = useDefaultRenderers().renderCell;\n    const handleRowChange = useLatestFunc((column, newRow)=>{\n        onRowChange(column, rowIdx, newRow);\n    });\n    className = classnames(rowClassname, `rdg-row-${rowIdx % 2 === 0 ? \"even\" : \"odd\"}`, {\n        [rowSelectedClassname]: selectedCellIdx === -1\n    }, rowClass?.(row$1, rowIdx), className);\n    const cells = [];\n    for(let index = 0; index < viewportColumns.length; index++){\n        const column = viewportColumns[index];\n        const { idx } = column;\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row: row$1\n        });\n        if (colSpan !== void 0) index += colSpan - 1;\n        const isCellSelected = selectedCellIdx === idx;\n        if (isCellSelected && selectedCellEditor) cells.push(selectedCellEditor);\n        else cells.push(renderCell(column.key, {\n            column,\n            colSpan,\n            row: row$1,\n            rowIdx,\n            isDraggedOver: draggedOverCellIdx === idx,\n            isCellSelected,\n            onCellMouseDown,\n            onCellClick,\n            onCellDoubleClick,\n            onCellContextMenu,\n            onRowChange: handleRowChange,\n            selectCell\n        }));\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RowSelectionContext, {\n        value: (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                isRowSelected,\n                isRowSelectionDisabled\n            }), [\n            isRowSelectionDisabled,\n            isRowSelected\n        ]),\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            role: \"row\",\n            className,\n            style: {\n                ...getRowStyle(gridRowStart),\n                ...style\n            },\n            ...props,\n            children: cells\n        })\n    });\n}\nconst RowComponent = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(Row);\nvar Row_default = RowComponent;\nfunction defaultRenderRow(key, props) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RowComponent, {\n        ...props\n    }, key);\n}\n//#endregion\n//#region src/ScrollToCell.tsx\nfunction ScrollToCell({ scrollToPosition: { idx, rowIdx }, gridRef, setScrollToCellPosition }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        scrollIntoView(ref.current, \"auto\");\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        function removeScrollToCell() {\n            setScrollToCellPosition(null);\n        }\n        const observer = new IntersectionObserver(removeScrollToCell, {\n            root: gridRef.current,\n            threshold: 1\n        });\n        observer.observe(ref.current);\n        return ()=>{\n            observer.disconnect();\n        };\n    }, [\n        gridRef,\n        setScrollToCellPosition\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        ref,\n        style: {\n            gridColumn: idx === void 0 ? \"1/-1\" : idx + 1,\n            gridRow: rowIdx === void 0 ? \"1/-1\" : rowIdx + 2\n        }\n    });\n}\n//#endregion\n//#region src/sortStatus.tsx\nconst arrowClassname = `rdg-sort-arrow rdg-7-0-0-beta-58-3d5115f3`;\nfunction renderSortStatus({ sortDirection, priority }) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: [\n            renderSortIcon({\n                sortDirection\n            }),\n            renderSortPriority({\n                priority\n            })\n        ]\n    });\n}\nfunction renderSortIcon({ sortDirection }) {\n    if (sortDirection === void 0) return null;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"svg\", {\n        viewBox: \"0 0 12 8\",\n        width: \"12\",\n        height: \"8\",\n        className: arrowClassname,\n        \"aria-hidden\": true,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", {\n            d: sortDirection === \"ASC\" ? \"M0 8 6 0 12 8\" : \"M0 0 6 8 12 0\"\n        })\n    });\n}\nfunction renderSortPriority({ priority }) {\n    return priority;\n}\n//#endregion\n//#region src/style/core.ts\nconst root = \"rdg-7-0-0-beta-58-ccd2e5d9\";\nconst rootClassname = `rdg ${root}`;\nconst viewportDragging = \"rdg-7-0-0-beta-58-e9b0e1c9\";\nconst viewportDraggingClassname = `rdg-viewport-dragging ${viewportDragging}`;\nconst focusSinkClassname = \"rdg-7-0-0-beta-58-dbb8b3c5\";\nconst focusSinkHeaderAndSummaryClassname = \"rdg-7-0-0-beta-58-e9f55541\";\n//#endregion\n//#region src/SummaryCell.tsx\nconst summaryCellClassname = \"rdg-7-0-0-beta-58-d907aa87\";\nfunction SummaryCell({ column, colSpan, row: row$1, rowIdx, isCellSelected, selectCell }) {\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    const { summaryCellClass } = column;\n    const className = getCellClassname(column, summaryCellClassname, typeof summaryCellClass === \"function\" ? summaryCellClass(row$1) : summaryCellClass);\n    function onMouseDown() {\n        selectCell({\n            rowIdx,\n            idx: column.idx\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-colspan\": colSpan,\n        \"aria-selected\": isCellSelected,\n        tabIndex,\n        className,\n        style: getCellStyle(column, colSpan),\n        onMouseDown,\n        onFocus,\n        children: column.renderSummaryCell?.({\n            column,\n            row: row$1,\n            tabIndex: childTabIndex\n        })\n    });\n}\nvar SummaryCell_default = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SummaryCell);\n//#endregion\n//#region src/SummaryRow.tsx\nconst summaryRow = \"rdg-7-0-0-beta-58-0b90c82c\";\nconst topSummaryRow = \"rdg-7-0-0-beta-58-d0520eab\";\nconst summaryRowClassname = `rdg-summary-row ${summaryRow}`;\nfunction SummaryRow({ rowIdx, gridRowStart, row: row$1, viewportColumns, top, bottom, lastFrozenColumnIndex, selectedCellIdx, isTop, selectCell, \"aria-rowindex\": ariaRowIndex }) {\n    const cells = [];\n    for(let index = 0; index < viewportColumns.length; index++){\n        const column = viewportColumns[index];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"SUMMARY\",\n            row: row$1\n        });\n        if (colSpan !== void 0) index += colSpan - 1;\n        const isCellSelected = selectedCellIdx === column.idx;\n        cells.push(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SummaryCell_default, {\n            column,\n            colSpan,\n            row: row$1,\n            rowIdx,\n            isCellSelected,\n            selectCell\n        }, column.key));\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"row\",\n        \"aria-rowindex\": ariaRowIndex,\n        className: classnames(rowClassname, `rdg-row-${rowIdx % 2 === 0 ? \"even\" : \"odd\"}`, summaryRowClassname, {\n            [rowSelectedClassname]: selectedCellIdx === -1,\n            [`${topSummaryRowClassname} ${topSummaryRow}`]: isTop,\n            [bottomSummaryRowClassname]: !isTop\n        }),\n        style: {\n            ...getRowStyle(gridRowStart),\n            \"--rdg-summary-row-top\": top !== void 0 ? `${top}px` : void 0,\n            \"--rdg-summary-row-bottom\": bottom !== void 0 ? `${bottom}px` : void 0\n        },\n        children: cells\n    });\n}\nvar SummaryRow_default = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(SummaryRow);\n//#endregion\n//#region src/DataGrid.tsx\n/**\n* Main API Component to render a data grid of rows and columns\n*\n* @example\n*\n* <DataGrid columns={columns} rows={rows} />\n*/ function DataGrid(props) {\n    const { ref, columns: rawColumns, rows, topSummaryRows, bottomSummaryRows, rowKeyGetter, onRowsChange, rowHeight: rawRowHeight, headerRowHeight: rawHeaderRowHeight, summaryRowHeight: rawSummaryRowHeight, columnWidths: columnWidthsRaw, onColumnWidthsChange: onColumnWidthsChangeRaw, selectedRows, isRowSelectionDisabled, onSelectedRowsChange, sortColumns, onSortColumnsChange, defaultColumnOptions, onCellMouseDown, onCellClick, onCellDoubleClick, onCellContextMenu, onCellKeyDown, onSelectedCellChange, onScroll, onColumnResize, onColumnsReorder, onFill, onCellCopy, onCellPaste, enableVirtualization: rawEnableVirtualization, renderers, className, style, rowClass, headerRowClass, direction: rawDirection, role: rawRole, \"aria-label\": ariaLabel, \"aria-labelledby\": ariaLabelledBy, \"aria-description\": ariaDescription, \"aria-describedby\": ariaDescribedBy, \"aria-rowcount\": rawAriaRowCount, \"data-testid\": testId, \"data-cy\": dataCy } = props;\n    /**\n\t* defaults\n\t*/ const defaultRenderers = useDefaultRenderers();\n    const role = rawRole ?? \"grid\";\n    const rowHeight = rawRowHeight ?? 35;\n    const headerRowHeight = rawHeaderRowHeight ?? (typeof rowHeight === \"number\" ? rowHeight : 35);\n    const summaryRowHeight = rawSummaryRowHeight ?? (typeof rowHeight === \"number\" ? rowHeight : 35);\n    const renderRow = renderers?.renderRow ?? defaultRenderers?.renderRow ?? defaultRenderRow;\n    const renderCell = renderers?.renderCell ?? defaultRenderers?.renderCell ?? defaultRenderCell;\n    const renderSortStatus$1 = renderers?.renderSortStatus ?? defaultRenderers?.renderSortStatus ?? renderSortStatus;\n    const renderCheckbox$1 = renderers?.renderCheckbox ?? defaultRenderers?.renderCheckbox ?? renderCheckbox;\n    const noRowsFallback = renderers?.noRowsFallback ?? defaultRenderers?.noRowsFallback;\n    const enableVirtualization = rawEnableVirtualization ?? true;\n    const direction = rawDirection ?? \"ltr\";\n    /**\n\t* states\n\t*/ const [scrollTop, setScrollTop] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [scrollLeft, setScrollLeft] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [columnWidthsInternal, setColumnWidthsInternal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>columnWidthsRaw ?? /* @__PURE__ */ new Map());\n    const [isColumnResizing, setColumnResizing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isDragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [draggedOverRowIdx, setDraggedOverRowIdx] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [scrollToPosition, setScrollToPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [shouldFocusCell, setShouldFocusCell] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [previousRowIdx, setPreviousRowIdx] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(-1);\n    const isColumnWidthsControlled = columnWidthsRaw != null && onColumnWidthsChangeRaw != null && !isColumnResizing;\n    const columnWidths = isColumnWidthsControlled ? columnWidthsRaw : columnWidthsInternal;\n    const onColumnWidthsChange = isColumnWidthsControlled ? (columnWidths$1)=>{\n        setColumnWidthsInternal(columnWidths$1);\n        onColumnWidthsChangeRaw(columnWidths$1);\n    } : setColumnWidthsInternal;\n    const getColumnWidth = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((column)=>{\n        return columnWidths.get(column.key)?.width ?? column.width;\n    }, [\n        columnWidths\n    ]);\n    const [gridRef, gridWidth, gridHeight, horizontalScrollbarHeight] = useGridDimensions();\n    const { columns, colSpanColumns, lastFrozenColumnIndex, headerRowsCount, colOverscanStartIdx, colOverscanEndIdx, templateColumns, layoutCssVars, totalFrozenColumnWidth } = useCalculatedColumns({\n        rawColumns,\n        defaultColumnOptions,\n        getColumnWidth,\n        scrollLeft,\n        viewportWidth: gridWidth,\n        enableVirtualization\n    });\n    const topSummaryRowsCount = topSummaryRows?.length ?? 0;\n    const bottomSummaryRowsCount = bottomSummaryRows?.length ?? 0;\n    const summaryRowsCount = topSummaryRowsCount + bottomSummaryRowsCount;\n    const headerAndTopSummaryRowsCount = headerRowsCount + topSummaryRowsCount;\n    const groupedColumnHeaderRowsCount = headerRowsCount - 1;\n    const minRowIdx = -headerAndTopSummaryRowsCount;\n    const mainHeaderRowIdx = minRowIdx + groupedColumnHeaderRowsCount;\n    const maxRowIdx = rows.length + bottomSummaryRowsCount - 1;\n    const [selectedPosition, setSelectedPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>({\n            idx: -1,\n            rowIdx: minRowIdx - 1,\n            mode: \"SELECT\"\n        }));\n    /**\n\t* refs\n\t*/ const focusSinkRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    /**\n\t* computed values\n\t*/ const isTreeGrid = role === \"treegrid\";\n    const headerRowsHeight = headerRowsCount * headerRowHeight;\n    const summaryRowsHeight = summaryRowsCount * summaryRowHeight;\n    const clientHeight = gridHeight - headerRowsHeight - summaryRowsHeight;\n    const isSelectable = selectedRows != null && onSelectedRowsChange != null;\n    const { leftKey, rightKey } = getLeftRightKey(direction);\n    const ariaRowCount = rawAriaRowCount ?? headerRowsCount + rows.length + summaryRowsCount;\n    const defaultGridComponents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            renderCheckbox: renderCheckbox$1,\n            renderSortStatus: renderSortStatus$1,\n            renderCell\n        }), [\n        renderCheckbox$1,\n        renderSortStatus$1,\n        renderCell\n    ]);\n    const headerSelectionValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let hasSelectedRow = false;\n        let hasUnselectedRow = false;\n        if (rowKeyGetter != null && selectedRows != null && selectedRows.size > 0) for (const row$1 of rows){\n            if (selectedRows.has(rowKeyGetter(row$1))) hasSelectedRow = true;\n            else hasUnselectedRow = true;\n            if (hasSelectedRow && hasUnselectedRow) break;\n        }\n        return {\n            isRowSelected: hasSelectedRow && !hasUnselectedRow,\n            isIndeterminate: hasSelectedRow && hasUnselectedRow\n        };\n    }, [\n        rows,\n        selectedRows,\n        rowKeyGetter\n    ]);\n    const { rowOverscanStartIdx, rowOverscanEndIdx, totalRowHeight, gridTemplateRows, getRowTop, getRowHeight, findRowIdx } = useViewportRows({\n        rows,\n        rowHeight,\n        clientHeight,\n        scrollTop,\n        enableVirtualization\n    });\n    const viewportColumns = useViewportColumns({\n        columns,\n        colSpanColumns,\n        colOverscanStartIdx,\n        colOverscanEndIdx,\n        lastFrozenColumnIndex,\n        rowOverscanStartIdx,\n        rowOverscanEndIdx,\n        rows,\n        topSummaryRows,\n        bottomSummaryRows\n    });\n    const { gridTemplateColumns, handleColumnResize } = useColumnWidths(columns, viewportColumns, templateColumns, gridRef, gridWidth, columnWidths, onColumnWidthsChange, onColumnResize, setColumnResizing);\n    const minColIdx = isTreeGrid ? -1 : 0;\n    const maxColIdx = columns.length - 1;\n    const selectedCellIsWithinSelectionBounds = isCellWithinSelectionBounds(selectedPosition);\n    const selectedCellIsWithinViewportBounds = isCellWithinViewportBounds(selectedPosition);\n    const scrollHeight = headerRowHeight + totalRowHeight + summaryRowsHeight + horizontalScrollbarHeight;\n    /**\n\t* The identity of the wrapper function is stable so it won't break memoization\n\t*/ const handleColumnResizeLatest = useLatestFunc(handleColumnResize);\n    const handleColumnResizeEndLatest = useLatestFunc(handleColumnResizeEnd);\n    const onColumnsReorderLastest = useLatestFunc(onColumnsReorder);\n    const onSortColumnsChangeLatest = useLatestFunc(onSortColumnsChange);\n    const onCellMouseDownLatest = useLatestFunc(onCellMouseDown);\n    const onCellClickLatest = useLatestFunc(onCellClick);\n    const onCellDoubleClickLatest = useLatestFunc(onCellDoubleClick);\n    const onCellContextMenuLatest = useLatestFunc(onCellContextMenu);\n    const selectHeaderRowLatest = useLatestFunc(selectHeaderRow);\n    const selectRowLatest = useLatestFunc(selectRow);\n    const handleFormatterRowChangeLatest = useLatestFunc(updateRow);\n    const selectCellLatest = useLatestFunc(selectCell);\n    const selectHeaderCellLatest = useLatestFunc(selectHeaderCell);\n    /**\n\t* callbacks\n\t*/ const focusCell = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((shouldScroll = true)=>{\n        const cell$1 = getCellToScroll(gridRef.current);\n        if (cell$1 === null) return;\n        if (shouldScroll) scrollIntoView(cell$1);\n        cell$1.focus({\n            preventScroll: true\n        });\n    }, [\n        gridRef\n    ]);\n    /**\n\t* effects\n\t*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (shouldFocusCell) {\n            if (focusSinkRef.current !== null && selectedPosition.idx === -1) {\n                focusSinkRef.current.focus({\n                    preventScroll: true\n                });\n                scrollIntoView(focusSinkRef.current);\n            } else focusCell();\n            setShouldFocusCell(false);\n        }\n    }, [\n        shouldFocusCell,\n        focusCell,\n        selectedPosition.idx\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>({\n            element: gridRef.current,\n            scrollToCell ({ idx, rowIdx }) {\n                const scrollToIdx = idx !== void 0 && idx > lastFrozenColumnIndex && idx < columns.length ? idx : void 0;\n                const scrollToRowIdx = rowIdx !== void 0 && isRowIdxWithinViewportBounds(rowIdx) ? rowIdx : void 0;\n                if (scrollToIdx !== void 0 || scrollToRowIdx !== void 0) setScrollToPosition({\n                    idx: scrollToIdx,\n                    rowIdx: scrollToRowIdx\n                });\n            },\n            selectCell\n        }));\n    /**\n\t* event handlers\n\t*/ function selectHeaderRow(args) {\n        if (!onSelectedRowsChange) return;\n        assertIsValidKeyGetter(rowKeyGetter);\n        const newSelectedRows = new Set(selectedRows);\n        for (const row$1 of rows){\n            if (isRowSelectionDisabled?.(row$1) === true) continue;\n            const rowKey = rowKeyGetter(row$1);\n            if (args.checked) newSelectedRows.add(rowKey);\n            else newSelectedRows.delete(rowKey);\n        }\n        onSelectedRowsChange(newSelectedRows);\n    }\n    function selectRow(args) {\n        if (!onSelectedRowsChange) return;\n        assertIsValidKeyGetter(rowKeyGetter);\n        const { row: row$1, checked, isShiftClick } = args;\n        if (isRowSelectionDisabled?.(row$1) === true) return;\n        const newSelectedRows = new Set(selectedRows);\n        const rowKey = rowKeyGetter(row$1);\n        const rowIdx = rows.indexOf(row$1);\n        setPreviousRowIdx(rowIdx);\n        if (checked) newSelectedRows.add(rowKey);\n        else newSelectedRows.delete(rowKey);\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx && previousRowIdx < rows.length) {\n            const step = sign(rowIdx - previousRowIdx);\n            for(let i = previousRowIdx + step; i !== rowIdx; i += step){\n                const row$2 = rows[i];\n                if (isRowSelectionDisabled?.(row$2) === true) continue;\n                if (checked) newSelectedRows.add(rowKeyGetter(row$2));\n                else newSelectedRows.delete(rowKeyGetter(row$2));\n            }\n        }\n        onSelectedRowsChange(newSelectedRows);\n    }\n    function handleKeyDown(event) {\n        const { idx, rowIdx, mode } = selectedPosition;\n        if (mode === \"EDIT\") return;\n        if (onCellKeyDown && isRowIdxWithinViewportBounds(rowIdx)) {\n            const row$1 = rows[rowIdx];\n            const cellEvent = createCellEvent(event);\n            onCellKeyDown({\n                mode: \"SELECT\",\n                row: row$1,\n                column: columns[idx],\n                rowIdx,\n                selectCell\n            }, cellEvent);\n            if (cellEvent.isGridDefaultPrevented()) return;\n        }\n        if (!(event.target instanceof Element)) return;\n        const isCellEvent = event.target.closest(\".rdg-cell\") !== null;\n        const isRowEvent = isTreeGrid && event.target === focusSinkRef.current;\n        if (!isCellEvent && !isRowEvent) return;\n        switch(event.key){\n            case \"ArrowUp\":\n            case \"ArrowDown\":\n            case \"ArrowLeft\":\n            case \"ArrowRight\":\n            case \"Tab\":\n            case \"Home\":\n            case \"End\":\n            case \"PageUp\":\n            case \"PageDown\":\n                navigate(event);\n                break;\n            default:\n                handleCellInput(event);\n                break;\n        }\n    }\n    function handleScroll(event) {\n        const { scrollTop: scrollTop$1, scrollLeft: scrollLeft$1 } = event.currentTarget;\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n            setScrollTop(scrollTop$1);\n            setScrollLeft(abs(scrollLeft$1));\n        });\n        onScroll?.(event);\n    }\n    function updateRow(column, rowIdx, row$1) {\n        if (typeof onRowsChange !== \"function\") return;\n        if (row$1 === rows[rowIdx]) return;\n        onRowsChange(rows.with(rowIdx, row$1), {\n            indexes: [\n                rowIdx\n            ],\n            column\n        });\n    }\n    function commitEditorChanges() {\n        if (selectedPosition.mode !== \"EDIT\") return;\n        updateRow(columns[selectedPosition.idx], selectedPosition.rowIdx, selectedPosition.row);\n    }\n    function handleCellCopy(event) {\n        if (!selectedCellIsWithinViewportBounds) return;\n        const { idx, rowIdx } = selectedPosition;\n        onCellCopy?.({\n            row: rows[rowIdx],\n            column: columns[idx]\n        }, event);\n    }\n    function handleCellPaste(event) {\n        if (!onCellPaste || !onRowsChange || !isCellEditable(selectedPosition)) return;\n        const { idx, rowIdx } = selectedPosition;\n        const column = columns[idx];\n        updateRow(column, rowIdx, onCellPaste({\n            row: rows[rowIdx],\n            column\n        }, event));\n    }\n    function handleCellInput(event) {\n        if (!selectedCellIsWithinViewportBounds) return;\n        const row$1 = rows[selectedPosition.rowIdx];\n        const { key, shiftKey } = event;\n        if (isSelectable && shiftKey && key === \" \") {\n            assertIsValidKeyGetter(rowKeyGetter);\n            const rowKey = rowKeyGetter(row$1);\n            selectRow({\n                row: row$1,\n                checked: !selectedRows.has(rowKey),\n                isShiftClick: false\n            });\n            event.preventDefault();\n            return;\n        }\n        if (isCellEditable(selectedPosition) && isDefaultCellInput(event, onCellPaste != null)) setSelectedPosition(({ idx, rowIdx })=>({\n                idx,\n                rowIdx,\n                mode: \"EDIT\",\n                row: row$1,\n                originalRow: row$1\n            }));\n    }\n    function handleColumnResizeEnd() {\n        if (isColumnResizing) {\n            onColumnWidthsChangeRaw?.(columnWidths);\n            setColumnResizing(false);\n        }\n    }\n    function handleDragHandlePointerDown(event) {\n        event.preventDefault();\n        if (event.pointerType === \"mouse\" && event.buttons !== 1) return;\n        setDragging(true);\n        event.currentTarget.setPointerCapture(event.pointerId);\n    }\n    function handleDragHandlePointerMove(event) {\n        const gridEl = gridRef.current;\n        const overRowIdx = findRowIdx(scrollTop - (headerRowsHeight + topSummaryRowsCount * summaryRowHeight) + event.clientY - gridEl.getBoundingClientRect().top);\n        setDraggedOverRowIdx(overRowIdx);\n        const ariaRowIndex = headerAndTopSummaryRowsCount + overRowIdx + 1;\n        scrollIntoView(gridEl.querySelector(`:scope > [aria-rowindex=\"${ariaRowIndex}\"] > [aria-colindex=\"${selectedPosition.idx + 1}\"]`));\n    }\n    function handleDragHandleLostPointerCapture() {\n        setDragging(false);\n        if (draggedOverRowIdx === void 0) return;\n        const { rowIdx } = selectedPosition;\n        const [startRowIndex, endRowIndex] = rowIdx < draggedOverRowIdx ? [\n            rowIdx + 1,\n            draggedOverRowIdx + 1\n        ] : [\n            draggedOverRowIdx,\n            rowIdx\n        ];\n        updateRows(startRowIndex, endRowIndex);\n        setDraggedOverRowIdx(void 0);\n    }\n    function handleDragHandleClick() {\n        focusCell(false);\n    }\n    function handleDragHandleDoubleClick(event) {\n        event.stopPropagation();\n        updateRows(selectedPosition.rowIdx + 1, rows.length);\n    }\n    function updateRows(startRowIdx, endRowIdx) {\n        if (onRowsChange == null) return;\n        const { rowIdx, idx } = selectedPosition;\n        const column = columns[idx];\n        const sourceRow = rows[rowIdx];\n        const updatedRows = [\n            ...rows\n        ];\n        const indexes = [];\n        for(let i = startRowIdx; i < endRowIdx; i++)if (isCellEditable({\n            rowIdx: i,\n            idx\n        })) {\n            const updatedRow = onFill({\n                columnKey: column.key,\n                sourceRow,\n                targetRow: rows[i]\n            });\n            if (updatedRow !== rows[i]) {\n                updatedRows[i] = updatedRow;\n                indexes.push(i);\n            }\n        }\n        if (indexes.length > 0) onRowsChange(updatedRows, {\n            indexes,\n            column\n        });\n    }\n    /**\n\t* utils\n\t*/ function isColIdxWithinSelectionBounds(idx) {\n        return idx >= minColIdx && idx <= maxColIdx;\n    }\n    function isRowIdxWithinViewportBounds(rowIdx) {\n        return rowIdx >= 0 && rowIdx < rows.length;\n    }\n    function isCellWithinSelectionBounds({ idx, rowIdx }) {\n        return rowIdx >= minRowIdx && rowIdx <= maxRowIdx && isColIdxWithinSelectionBounds(idx);\n    }\n    function isCellWithinEditBounds({ idx, rowIdx }) {\n        return isRowIdxWithinViewportBounds(rowIdx) && idx >= 0 && idx <= maxColIdx;\n    }\n    function isCellWithinViewportBounds({ idx, rowIdx }) {\n        return isRowIdxWithinViewportBounds(rowIdx) && isColIdxWithinSelectionBounds(idx);\n    }\n    function isCellEditable(position) {\n        return isCellWithinEditBounds(position) && isSelectedCellEditable({\n            columns,\n            rows,\n            selectedPosition: position\n        });\n    }\n    function selectCell(position, options) {\n        if (!isCellWithinSelectionBounds(position)) return;\n        commitEditorChanges();\n        const samePosition = isSamePosition(selectedPosition, position);\n        if (options?.enableEditor && isCellEditable(position)) {\n            const row$1 = rows[position.rowIdx];\n            setSelectedPosition({\n                ...position,\n                mode: \"EDIT\",\n                row: row$1,\n                originalRow: row$1\n            });\n        } else if (samePosition) scrollIntoView(getCellToScroll(gridRef.current));\n        else {\n            setShouldFocusCell(options?.shouldFocusCell === true);\n            setSelectedPosition({\n                ...position,\n                mode: \"SELECT\"\n            });\n        }\n        if (onSelectedCellChange && !samePosition) onSelectedCellChange({\n            rowIdx: position.rowIdx,\n            row: isRowIdxWithinViewportBounds(position.rowIdx) ? rows[position.rowIdx] : void 0,\n            column: columns[position.idx]\n        });\n    }\n    function selectHeaderCell({ idx, rowIdx }) {\n        selectCell({\n            rowIdx: minRowIdx + rowIdx - 1,\n            idx\n        });\n    }\n    function getNextPosition(key, ctrlKey, shiftKey) {\n        const { idx, rowIdx } = selectedPosition;\n        const isRowSelected = selectedCellIsWithinSelectionBounds && idx === -1;\n        switch(key){\n            case \"ArrowUp\":\n                return {\n                    idx,\n                    rowIdx: rowIdx - 1\n                };\n            case \"ArrowDown\":\n                return {\n                    idx,\n                    rowIdx: rowIdx + 1\n                };\n            case leftKey:\n                return {\n                    idx: idx - 1,\n                    rowIdx\n                };\n            case rightKey:\n                return {\n                    idx: idx + 1,\n                    rowIdx\n                };\n            case \"Tab\":\n                return {\n                    idx: idx + (shiftKey ? -1 : 1),\n                    rowIdx\n                };\n            case \"Home\":\n                if (isRowSelected) return {\n                    idx,\n                    rowIdx: minRowIdx\n                };\n                return {\n                    idx: 0,\n                    rowIdx: ctrlKey ? minRowIdx : rowIdx\n                };\n            case \"End\":\n                if (isRowSelected) return {\n                    idx,\n                    rowIdx: maxRowIdx\n                };\n                return {\n                    idx: maxColIdx,\n                    rowIdx: ctrlKey ? maxRowIdx : rowIdx\n                };\n            case \"PageUp\":\n                {\n                    if (selectedPosition.rowIdx === minRowIdx) return selectedPosition;\n                    const nextRowY = getRowTop(rowIdx) + getRowHeight(rowIdx) - clientHeight;\n                    return {\n                        idx,\n                        rowIdx: nextRowY > 0 ? findRowIdx(nextRowY) : 0\n                    };\n                }\n            case \"PageDown\":\n                {\n                    if (selectedPosition.rowIdx >= rows.length) return selectedPosition;\n                    const nextRowY = getRowTop(rowIdx) + clientHeight;\n                    return {\n                        idx,\n                        rowIdx: nextRowY < totalRowHeight ? findRowIdx(nextRowY) : rows.length - 1\n                    };\n                }\n            default:\n                return selectedPosition;\n        }\n    }\n    function navigate(event) {\n        const { key, shiftKey } = event;\n        let cellNavigationMode = \"NONE\";\n        if (key === \"Tab\") {\n            if (canExitGrid({\n                shiftKey,\n                maxColIdx,\n                minRowIdx,\n                maxRowIdx,\n                selectedPosition\n            })) {\n                commitEditorChanges();\n                return;\n            }\n            cellNavigationMode = \"CHANGE_ROW\";\n        }\n        event.preventDefault();\n        const nextPosition = getNextPosition(key, isCtrlKeyHeldDown(event), shiftKey);\n        if (isSamePosition(selectedPosition, nextPosition)) return;\n        selectCell(getNextSelectedCellPosition({\n            moveUp: key === \"ArrowUp\",\n            moveNext: key === rightKey || key === \"Tab\" && !shiftKey,\n            columns,\n            colSpanColumns,\n            rows,\n            topSummaryRows,\n            bottomSummaryRows,\n            minRowIdx,\n            mainHeaderRowIdx,\n            maxRowIdx,\n            lastFrozenColumnIndex,\n            cellNavigationMode,\n            currentPosition: selectedPosition,\n            nextPosition,\n            isCellWithinBounds: isCellWithinSelectionBounds\n        }), {\n            shouldFocusCell: true\n        });\n    }\n    function getDraggedOverCellIdx(currentRowIdx) {\n        if (draggedOverRowIdx === void 0) return;\n        const { rowIdx } = selectedPosition;\n        return (rowIdx < draggedOverRowIdx ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx) ? selectedPosition.idx : void 0;\n    }\n    function getDragHandle() {\n        if (onFill == null || selectedPosition.mode === \"EDIT\" || !isCellWithinViewportBounds(selectedPosition)) return;\n        const { idx, rowIdx } = selectedPosition;\n        const column = columns[idx];\n        if (column.renderEditCell == null || column.editable === false) return;\n        const isLastRow = rowIdx === maxRowIdx;\n        const columnWidth = getColumnWidth(column);\n        const colSpan = column.colSpan?.({\n            type: \"ROW\",\n            row: rows[rowIdx]\n        }) ?? 1;\n        const { insetInlineStart, ...style$1 } = getCellStyle(column, colSpan);\n        const marginEnd = \"calc(var(--rdg-drag-handle-size) * -0.5 + 1px)\";\n        const isLastColumn = column.idx + colSpan - 1 === maxColIdx;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            style: {\n                ...style$1,\n                gridRowStart: headerAndTopSummaryRowsCount + rowIdx + 1,\n                marginInlineEnd: isLastColumn ? void 0 : marginEnd,\n                marginBlockEnd: isLastRow ? void 0 : marginEnd,\n                insetInlineStart: insetInlineStart ? `calc(${insetInlineStart} + ${columnWidth}px + var(--rdg-drag-handle-size) * -0.5 - 1px)` : void 0\n            },\n            className: classnames(cellDragHandleClassname, column.frozen && cellDragHandleFrozenClassname),\n            onPointerDown: handleDragHandlePointerDown,\n            onPointerMove: isDragging ? handleDragHandlePointerMove : void 0,\n            onLostPointerCapture: isDragging ? handleDragHandleLostPointerCapture : void 0,\n            onClick: handleDragHandleClick,\n            onDoubleClick: handleDragHandleDoubleClick\n        });\n    }\n    function getCellEditor(rowIdx) {\n        if (!isCellWithinViewportBounds(selectedPosition) || selectedPosition.rowIdx !== rowIdx || selectedPosition.mode === \"SELECT\") return;\n        const { idx, row: row$1 } = selectedPosition;\n        const column = columns[idx];\n        const colSpan = getColSpan(column, lastFrozenColumnIndex, {\n            type: \"ROW\",\n            row: row$1\n        });\n        const closeOnExternalRowChange = column.editorOptions?.closeOnExternalRowChange ?? true;\n        const closeEditor = (shouldFocusCell$1)=>{\n            setShouldFocusCell(shouldFocusCell$1);\n            setSelectedPosition(({ idx: idx$1, rowIdx: rowIdx$1 })=>({\n                    idx: idx$1,\n                    rowIdx: rowIdx$1,\n                    mode: \"SELECT\"\n                }));\n        };\n        const onRowChange = (row$2, commitChanges, shouldFocusCell$1)=>{\n            if (commitChanges) (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                updateRow(column, selectedPosition.rowIdx, row$2);\n                closeEditor(shouldFocusCell$1);\n            });\n            else setSelectedPosition((position)=>({\n                    ...position,\n                    row: row$2\n                }));\n        };\n        if (closeOnExternalRowChange && rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) closeEditor(false);\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EditCell, {\n            column,\n            colSpan,\n            row: row$1,\n            rowIdx,\n            onRowChange,\n            closeEditor,\n            onKeyDown: onCellKeyDown,\n            navigate\n        }, column.key);\n    }\n    function getRowViewportColumns(rowIdx) {\n        const selectedColumn = selectedPosition.idx === -1 ? void 0 : columns[selectedPosition.idx];\n        if (selectedColumn !== void 0 && selectedPosition.rowIdx === rowIdx && !viewportColumns.includes(selectedColumn)) return selectedPosition.idx > colOverscanEndIdx ? [\n            ...viewportColumns,\n            selectedColumn\n        ] : [\n            ...viewportColumns.slice(0, lastFrozenColumnIndex + 1),\n            selectedColumn,\n            ...viewportColumns.slice(lastFrozenColumnIndex + 1)\n        ];\n        return viewportColumns;\n    }\n    function getViewportRows() {\n        const rowElements = [];\n        const { idx: selectedIdx, rowIdx: selectedRowIdx } = selectedPosition;\n        const startRowIdx = selectedCellIsWithinViewportBounds && selectedRowIdx < rowOverscanStartIdx ? rowOverscanStartIdx - 1 : rowOverscanStartIdx;\n        const endRowIdx = selectedCellIsWithinViewportBounds && selectedRowIdx > rowOverscanEndIdx ? rowOverscanEndIdx + 1 : rowOverscanEndIdx;\n        for(let viewportRowIdx = startRowIdx; viewportRowIdx <= endRowIdx; viewportRowIdx++){\n            const isRowOutsideViewport = viewportRowIdx === rowOverscanStartIdx - 1 || viewportRowIdx === rowOverscanEndIdx + 1;\n            const rowIdx = isRowOutsideViewport ? selectedRowIdx : viewportRowIdx;\n            let rowColumns = viewportColumns;\n            const selectedColumn = selectedIdx === -1 ? void 0 : columns[selectedIdx];\n            if (selectedColumn !== void 0) if (isRowOutsideViewport) rowColumns = [\n                selectedColumn\n            ];\n            else rowColumns = getRowViewportColumns(rowIdx);\n            const row$1 = rows[rowIdx];\n            const gridRowStart = headerAndTopSummaryRowsCount + rowIdx + 1;\n            let key = rowIdx;\n            let isRowSelected = false;\n            if (typeof rowKeyGetter === \"function\") {\n                key = rowKeyGetter(row$1);\n                isRowSelected = selectedRows?.has(key) ?? false;\n            }\n            rowElements.push(renderRow(key, {\n                \"aria-rowindex\": headerAndTopSummaryRowsCount + rowIdx + 1,\n                \"aria-selected\": isSelectable ? isRowSelected : void 0,\n                rowIdx,\n                row: row$1,\n                viewportColumns: rowColumns,\n                isRowSelectionDisabled: isRowSelectionDisabled?.(row$1) ?? false,\n                isRowSelected,\n                onCellMouseDown: onCellMouseDownLatest,\n                onCellClick: onCellClickLatest,\n                onCellDoubleClick: onCellDoubleClickLatest,\n                onCellContextMenu: onCellContextMenuLatest,\n                rowClass,\n                gridRowStart,\n                selectedCellIdx: selectedRowIdx === rowIdx ? selectedIdx : void 0,\n                draggedOverCellIdx: getDraggedOverCellIdx(rowIdx),\n                lastFrozenColumnIndex,\n                onRowChange: handleFormatterRowChangeLatest,\n                selectCell: selectCellLatest,\n                selectedCellEditor: getCellEditor(rowIdx)\n            }));\n        }\n        return rowElements;\n    }\n    if (selectedPosition.idx > maxColIdx || selectedPosition.rowIdx > maxRowIdx) {\n        setSelectedPosition({\n            idx: -1,\n            rowIdx: minRowIdx - 1,\n            mode: \"SELECT\"\n        });\n        setDraggedOverRowIdx(void 0);\n    }\n    if (isColumnWidthsControlled && columnWidthsInternal !== columnWidthsRaw) setColumnWidthsInternal(columnWidthsRaw);\n    let templateRows = `repeat(${headerRowsCount}, ${headerRowHeight}px)`;\n    if (topSummaryRowsCount > 0) templateRows += ` repeat(${topSummaryRowsCount}, ${summaryRowHeight}px)`;\n    if (rows.length > 0) templateRows += gridTemplateRows;\n    if (bottomSummaryRowsCount > 0) templateRows += ` repeat(${bottomSummaryRowsCount}, ${summaryRowHeight}px)`;\n    const isGroupRowFocused = selectedPosition.idx === -1 && selectedPosition.rowIdx !== minRowIdx - 1;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n        role,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        \"aria-description\": ariaDescription,\n        \"aria-describedby\": ariaDescribedBy,\n        \"aria-multiselectable\": isSelectable ? true : void 0,\n        \"aria-colcount\": columns.length,\n        \"aria-rowcount\": ariaRowCount,\n        tabIndex: -1,\n        className: classnames(rootClassname, {\n            [viewportDraggingClassname]: isDragging\n        }, className),\n        style: {\n            ...style,\n            scrollPaddingInlineStart: selectedPosition.idx > lastFrozenColumnIndex || scrollToPosition?.idx !== void 0 ? `${totalFrozenColumnWidth}px` : void 0,\n            scrollPaddingBlock: isRowIdxWithinViewportBounds(selectedPosition.rowIdx) || scrollToPosition?.rowIdx !== void 0 ? `${headerRowsHeight + topSummaryRowsCount * summaryRowHeight}px ${bottomSummaryRowsCount * summaryRowHeight}px` : void 0,\n            gridTemplateColumns,\n            gridTemplateRows: templateRows,\n            \"--rdg-header-row-height\": `${headerRowHeight}px`,\n            \"--rdg-scroll-height\": `${scrollHeight}px`,\n            ...layoutCssVars\n        },\n        dir: direction,\n        ref: gridRef,\n        onScroll: handleScroll,\n        onKeyDown: handleKeyDown,\n        onCopy: handleCellCopy,\n        onPaste: handleCellPaste,\n        \"data-testid\": testId,\n        \"data-cy\": dataCy,\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(DataGridDefaultRenderersContext, {\n                value: defaultGridComponents,\n                children: [\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(HeaderRowSelectionChangeContext, {\n                        value: selectHeaderRowLatest,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(HeaderRowSelectionContext, {\n                            value: headerSelectionValue,\n                            children: [\n                                Array.from({\n                                    length: groupedColumnHeaderRowsCount\n                                }, (_, index)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GroupedColumnHeaderRow_default, {\n                                        rowIdx: index + 1,\n                                        level: -groupedColumnHeaderRowsCount + index,\n                                        columns: getRowViewportColumns(minRowIdx + index),\n                                        selectedCellIdx: selectedPosition.rowIdx === minRowIdx + index ? selectedPosition.idx : void 0,\n                                        selectCell: selectHeaderCellLatest\n                                    }, index)),\n                                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(HeaderRow_default, {\n                                    headerRowClass,\n                                    rowIdx: headerRowsCount,\n                                    columns: getRowViewportColumns(mainHeaderRowIdx),\n                                    onColumnResize: handleColumnResizeLatest,\n                                    onColumnResizeEnd: handleColumnResizeEndLatest,\n                                    onColumnsReorder: onColumnsReorderLastest,\n                                    sortColumns,\n                                    onSortColumnsChange: onSortColumnsChangeLatest,\n                                    lastFrozenColumnIndex,\n                                    selectedCellIdx: selectedPosition.rowIdx === mainHeaderRowIdx ? selectedPosition.idx : void 0,\n                                    selectCell: selectHeaderCellLatest,\n                                    shouldFocusGrid: !selectedCellIsWithinSelectionBounds,\n                                    direction\n                                })\n                            ]\n                        })\n                    }),\n                    rows.length === 0 && noRowsFallback ? noRowsFallback : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n                        children: [\n                            topSummaryRows?.map((row$1, rowIdx)=>{\n                                const gridRowStart = headerRowsCount + 1 + rowIdx;\n                                const summaryRowIdx = mainHeaderRowIdx + 1 + rowIdx;\n                                const isSummaryRowSelected = selectedPosition.rowIdx === summaryRowIdx;\n                                const top = headerRowsHeight + summaryRowHeight * rowIdx;\n                                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SummaryRow_default, {\n                                    \"aria-rowindex\": gridRowStart,\n                                    rowIdx: summaryRowIdx,\n                                    gridRowStart,\n                                    row: row$1,\n                                    top,\n                                    bottom: void 0,\n                                    viewportColumns: getRowViewportColumns(summaryRowIdx),\n                                    lastFrozenColumnIndex,\n                                    selectedCellIdx: isSummaryRowSelected ? selectedPosition.idx : void 0,\n                                    isTop: true,\n                                    selectCell: selectCellLatest\n                                }, rowIdx);\n                            }),\n                            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RowSelectionChangeContext, {\n                                value: selectRowLatest,\n                                children: getViewportRows()\n                            }),\n                            bottomSummaryRows?.map((row$1, rowIdx)=>{\n                                const gridRowStart = headerAndTopSummaryRowsCount + rows.length + rowIdx + 1;\n                                const summaryRowIdx = rows.length + rowIdx;\n                                const isSummaryRowSelected = selectedPosition.rowIdx === summaryRowIdx;\n                                const top = clientHeight > totalRowHeight ? gridHeight - summaryRowHeight * (bottomSummaryRows.length - rowIdx) : void 0;\n                                const bottom = top === void 0 ? summaryRowHeight * (bottomSummaryRows.length - 1 - rowIdx) : void 0;\n                                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SummaryRow_default, {\n                                    \"aria-rowindex\": ariaRowCount - bottomSummaryRowsCount + rowIdx + 1,\n                                    rowIdx: summaryRowIdx,\n                                    gridRowStart,\n                                    row: row$1,\n                                    top,\n                                    bottom,\n                                    viewportColumns: getRowViewportColumns(summaryRowIdx),\n                                    lastFrozenColumnIndex,\n                                    selectedCellIdx: isSummaryRowSelected ? selectedPosition.idx : void 0,\n                                    isTop: false,\n                                    selectCell: selectCellLatest\n                                }, rowIdx);\n                            })\n                        ]\n                    })\n                ]\n            }),\n            getDragHandle(),\n            renderMeasuringCells(viewportColumns),\n            isTreeGrid && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                ref: focusSinkRef,\n                tabIndex: isGroupRowFocused ? 0 : -1,\n                className: classnames(focusSinkClassname, {\n                    [focusSinkHeaderAndSummaryClassname]: !isRowIdxWithinViewportBounds(selectedPosition.rowIdx),\n                    [rowSelected]: isGroupRowFocused,\n                    [rowSelectedWithFrozenCell]: isGroupRowFocused && lastFrozenColumnIndex !== -1\n                }),\n                style: {\n                    gridRowStart: selectedPosition.rowIdx + headerAndTopSummaryRowsCount + 1\n                }\n            }),\n            scrollToPosition !== null && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ScrollToCell, {\n                scrollToPosition,\n                setScrollToCellPosition: setScrollToPosition,\n                gridRef\n            })\n        ]\n    });\n}\nfunction getCellToScroll(gridEl) {\n    return gridEl.querySelector(':scope > [role=\"row\"] > [tabindex=\"0\"]');\n}\nfunction isSamePosition(p1, p2) {\n    return p1.idx === p2.idx && p1.rowIdx === p2.rowIdx;\n}\n//#endregion\n//#region src/GroupCell.tsx\nfunction GroupCell({ id, groupKey, childRows, isExpanded, isCellSelected, column, row: row$1, groupColumnIndex, isGroupByColumn, toggleGroup: toggleGroupWrapper }) {\n    const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n    function toggleGroup() {\n        toggleGroupWrapper(id);\n    }\n    const isLevelMatching = isGroupByColumn && groupColumnIndex === column.idx;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        role: \"gridcell\",\n        \"aria-colindex\": column.idx + 1,\n        \"aria-selected\": isCellSelected,\n        tabIndex,\n        className: getCellClassname(column),\n        style: {\n            ...getCellStyle(column),\n            cursor: isLevelMatching ? \"pointer\" : \"default\"\n        },\n        onMouseDown: (event)=>{\n            event.preventDefault();\n        },\n        onClick: isLevelMatching ? toggleGroup : void 0,\n        onFocus,\n        children: (!isGroupByColumn || isLevelMatching) && column.renderGroupCell?.({\n            groupKey,\n            childRows,\n            column,\n            row: row$1,\n            isExpanded,\n            tabIndex: childTabIndex,\n            toggleGroup\n        })\n    }, column.key);\n}\nvar GroupCell_default = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupCell);\n//#endregion\n//#region src/GroupRow.tsx\nconst groupRowClassname = `rdg-group-row rdg-7-0-0-beta-58-e74a2be3`;\nfunction GroupedRow({ className, row: row$1, rowIdx, viewportColumns, selectedCellIdx, isRowSelected, selectCell, gridRowStart, groupBy, toggleGroup, isRowSelectionDisabled, ...props }) {\n    const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? row$1.level + 1 : row$1.level;\n    function handleSelectGroup() {\n        selectCell({\n            rowIdx,\n            idx: -1\n        }, {\n            shouldFocusCell: true\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RowSelectionContext, {\n        value: (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                isRowSelectionDisabled: false,\n                isRowSelected\n            }), [\n            isRowSelected\n        ]),\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            role: \"row\",\n            \"aria-level\": row$1.level + 1,\n            \"aria-setsize\": row$1.setSize,\n            \"aria-posinset\": row$1.posInSet + 1,\n            \"aria-expanded\": row$1.isExpanded,\n            className: classnames(rowClassname, groupRowClassname, `rdg-row-${rowIdx % 2 === 0 ? \"even\" : \"odd\"}`, selectedCellIdx === -1 && rowSelectedClassname, className),\n            onMouseDown: handleSelectGroup,\n            style: getRowStyle(gridRowStart),\n            ...props,\n            children: viewportColumns.map((column)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GroupCell_default, {\n                    id: row$1.id,\n                    groupKey: row$1.groupKey,\n                    childRows: row$1.childRows,\n                    isExpanded: row$1.isExpanded,\n                    isCellSelected: selectedCellIdx === column.idx,\n                    column,\n                    row: row$1,\n                    groupColumnIndex: idx,\n                    toggleGroup,\n                    isGroupByColumn: groupBy.includes(column.key)\n                }, column.key))\n        })\n    });\n}\nvar GroupRow_default = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(GroupedRow);\n//#endregion\n//#region src/TreeDataGrid.tsx\nfunction TreeDataGrid({ columns: rawColumns, rows: rawRows, rowHeight: rawRowHeight, rowKeyGetter: rawRowKeyGetter, onCellKeyDown: rawOnCellKeyDown, onCellCopy: rawOnCellCopy, onCellPaste: rawOnCellPaste, onRowsChange, selectedRows: rawSelectedRows, onSelectedRowsChange: rawOnSelectedRowsChange, renderers, groupBy: rawGroupBy, rowGrouper, expandedGroupIds, onExpandedGroupIdsChange, groupIdGetter: rawGroupIdGetter, ...props }) {\n    const defaultRenderers = useDefaultRenderers();\n    const rawRenderRow = renderers?.renderRow ?? defaultRenderers?.renderRow ?? defaultRenderRow;\n    const headerAndTopSummaryRowsCount = 1 + (props.topSummaryRows?.length ?? 0);\n    const { leftKey, rightKey } = getLeftRightKey(props.direction);\n    const toggleGroupLatest = useLatestFunc(toggleGroup);\n    const groupIdGetter = rawGroupIdGetter ?? defaultGroupIdGetter;\n    const { columns, groupBy } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const columns$1 = rawColumns.toSorted(({ key: aKey }, { key: bKey })=>{\n            if (aKey === SELECT_COLUMN_KEY) return -1;\n            if (bKey === SELECT_COLUMN_KEY) return 1;\n            if (rawGroupBy.includes(aKey)) {\n                if (rawGroupBy.includes(bKey)) return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n                return -1;\n            }\n            if (rawGroupBy.includes(bKey)) return 1;\n            return 0;\n        });\n        const groupBy$1 = [];\n        for (const [index, column] of columns$1.entries())if (rawGroupBy.includes(column.key)) {\n            groupBy$1.push(column.key);\n            columns$1[index] = {\n                ...column,\n                frozen: true,\n                renderCell: ()=>null,\n                renderGroupCell: column.renderGroupCell ?? renderToggleGroup,\n                editable: false\n            };\n        }\n        return {\n            columns: columns$1,\n            groupBy: groupBy$1\n        };\n    }, [\n        rawColumns,\n        rawGroupBy\n    ]);\n    const [groupedRows, rowsCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (groupBy.length === 0) return [\n            void 0,\n            rawRows.length\n        ];\n        const groupRows = (rows$1, [groupByKey, ...remainingGroupByKeys], startRowIndex)=>{\n            let groupRowsCount = 0;\n            const groups = {};\n            for (const [key, childRows] of Object.entries(rowGrouper(rows$1, groupByKey))){\n                const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0 ? [\n                    childRows,\n                    childRows.length\n                ] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1);\n                groups[key] = {\n                    childRows,\n                    childGroups,\n                    startRowIndex: startRowIndex + groupRowsCount\n                };\n                groupRowsCount += childRowsCount + 1;\n            }\n            return [\n                groups,\n                groupRowsCount\n            ];\n        };\n        return groupRows(rawRows, groupBy, 0);\n    }, [\n        groupBy,\n        rowGrouper,\n        rawRows\n    ]);\n    const [rows, isGroupRow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const allGroupRows = /* @__PURE__ */ new Set();\n        if (!groupedRows) return [\n            rawRows,\n            isGroupRow$1\n        ];\n        const flattenedRows = [];\n        const expandGroup = (rows$1, parentId, level)=>{\n            if (isReadonlyArray(rows$1)) {\n                flattenedRows.push(...rows$1);\n                return;\n            }\n            Object.keys(rows$1).forEach((groupKey, posInSet, keys)=>{\n                const id = groupIdGetter(groupKey, parentId);\n                const isExpanded = expandedGroupIds.has(id);\n                const { childRows, childGroups, startRowIndex } = rows$1[groupKey];\n                const groupRow = {\n                    id,\n                    parentId,\n                    groupKey,\n                    isExpanded,\n                    childRows,\n                    level,\n                    posInSet,\n                    startRowIndex,\n                    setSize: keys.length\n                };\n                flattenedRows.push(groupRow);\n                allGroupRows.add(groupRow);\n                if (isExpanded) expandGroup(childGroups, id, level + 1);\n            });\n        };\n        expandGroup(groupedRows, void 0, 0);\n        return [\n            flattenedRows,\n            isGroupRow$1\n        ];\n        function isGroupRow$1(row$1) {\n            return allGroupRows.has(row$1);\n        }\n    }, [\n        expandedGroupIds,\n        groupedRows,\n        rawRows,\n        groupIdGetter\n    ]);\n    const rowHeight = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof rawRowHeight === \"function\") return (row$1)=>{\n            if (isGroupRow(row$1)) return rawRowHeight({\n                type: \"GROUP\",\n                row: row$1\n            });\n            return rawRowHeight({\n                type: \"ROW\",\n                row: row$1\n            });\n        };\n        return rawRowHeight;\n    }, [\n        isGroupRow,\n        rawRowHeight\n    ]);\n    const getParentRowAndIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((row$1)=>{\n        const rowIdx = rows.indexOf(row$1);\n        for(let i = rowIdx - 1; i >= 0; i--){\n            const parentRow = rows[i];\n            if (isGroupRow(parentRow) && (!isGroupRow(row$1) || row$1.parentId === parentRow.id)) return [\n                parentRow,\n                i\n            ];\n        }\n    }, [\n        isGroupRow,\n        rows\n    ]);\n    const rowKeyGetter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((row$1)=>{\n        if (isGroupRow(row$1)) return row$1.id;\n        if (typeof rawRowKeyGetter === \"function\") return rawRowKeyGetter(row$1);\n        const parentRowAndIndex = getParentRowAndIndex(row$1);\n        if (parentRowAndIndex !== void 0) {\n            const { startRowIndex, childRows } = parentRowAndIndex[0];\n            return startRowIndex + childRows.indexOf(row$1) + 1;\n        }\n        return rows.indexOf(row$1);\n    }, [\n        getParentRowAndIndex,\n        isGroupRow,\n        rawRowKeyGetter,\n        rows\n    ]);\n    const selectedRows = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (rawSelectedRows == null) return null;\n        assertIsValidKeyGetter(rawRowKeyGetter);\n        const selectedRows$1 = new Set(rawSelectedRows);\n        for (const row$1 of rows)if (isGroupRow(row$1)) {\n            if (row$1.childRows.every((cr)=>rawSelectedRows.has(rawRowKeyGetter(cr)))) selectedRows$1.add(row$1.id);\n        }\n        return selectedRows$1;\n    }, [\n        isGroupRow,\n        rawRowKeyGetter,\n        rawSelectedRows,\n        rows\n    ]);\n    function onSelectedRowsChange(newSelectedRows) {\n        if (!rawOnSelectedRowsChange) return;\n        assertIsValidKeyGetter(rawRowKeyGetter);\n        const newRawSelectedRows = new Set(rawSelectedRows);\n        for (const row$1 of rows){\n            const key = rowKeyGetter(row$1);\n            if (selectedRows?.has(key) && !newSelectedRows.has(key)) if (isGroupRow(row$1)) for (const cr of row$1.childRows)newRawSelectedRows.delete(rawRowKeyGetter(cr));\n            else newRawSelectedRows.delete(key);\n            else if (!selectedRows?.has(key) && newSelectedRows.has(key)) if (isGroupRow(row$1)) for (const cr of row$1.childRows)newRawSelectedRows.add(rawRowKeyGetter(cr));\n            else newRawSelectedRows.add(key);\n        }\n        rawOnSelectedRowsChange(newRawSelectedRows);\n    }\n    function handleKeyDown(args, event) {\n        rawOnCellKeyDown?.(args, event);\n        if (event.isGridDefaultPrevented()) return;\n        if (args.mode === \"EDIT\") return;\n        const { column, rowIdx, selectCell } = args;\n        const idx = column?.idx ?? -1;\n        const row$1 = rows[rowIdx];\n        if (!isGroupRow(row$1)) return;\n        if (idx === -1 && (event.key === leftKey && row$1.isExpanded || event.key === rightKey && !row$1.isExpanded)) {\n            event.preventDefault();\n            event.preventGridDefault();\n            toggleGroup(row$1.id);\n        }\n        if (idx === -1 && event.key === leftKey && !row$1.isExpanded && row$1.level !== 0) {\n            const parentRowAndIndex = getParentRowAndIndex(row$1);\n            if (parentRowAndIndex !== void 0) {\n                event.preventGridDefault();\n                selectCell({\n                    idx,\n                    rowIdx: parentRowAndIndex[1]\n                });\n            }\n        }\n    }\n    function handleCellCopy({ row: row$1, column }, event) {\n        if (!isGroupRow(row$1)) rawOnCellCopy?.({\n            row: row$1,\n            column\n        }, event);\n    }\n    function handleCellPaste({ row: row$1, column }, event) {\n        return isGroupRow(row$1) ? row$1 : rawOnCellPaste({\n            row: row$1,\n            column\n        }, event);\n    }\n    function handleRowsChange(updatedRows, { indexes, column }) {\n        if (!onRowsChange) return;\n        const updatedRawRows = [\n            ...rawRows\n        ];\n        const rawIndexes = [];\n        for (const index of indexes){\n            const rawIndex = rawRows.indexOf(rows[index]);\n            updatedRawRows[rawIndex] = updatedRows[index];\n            rawIndexes.push(rawIndex);\n        }\n        onRowsChange(updatedRawRows, {\n            indexes: rawIndexes,\n            column\n        });\n    }\n    function toggleGroup(groupId) {\n        const newExpandedGroupIds = new Set(expandedGroupIds);\n        if (newExpandedGroupIds.has(groupId)) newExpandedGroupIds.delete(groupId);\n        else newExpandedGroupIds.add(groupId);\n        onExpandedGroupIdsChange(newExpandedGroupIds);\n    }\n    function renderRow(key, { row: row$1, rowClass, onCellMouseDown, onCellClick, onCellDoubleClick, onCellContextMenu, onRowChange, lastFrozenColumnIndex, draggedOverCellIdx, selectedCellEditor, ...rowProps }) {\n        if (isGroupRow(row$1)) {\n            const { startRowIndex } = row$1;\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GroupRow_default, {\n                ...rowProps,\n                \"aria-rowindex\": headerAndTopSummaryRowsCount + startRowIndex + 1,\n                row: row$1,\n                groupBy,\n                toggleGroup: toggleGroupLatest\n            }, key);\n        }\n        let ariaRowIndex = rowProps[\"aria-rowindex\"];\n        const parentRowAndIndex = getParentRowAndIndex(row$1);\n        if (parentRowAndIndex !== void 0) {\n            const { startRowIndex, childRows } = parentRowAndIndex[0];\n            const groupIndex = childRows.indexOf(row$1);\n            ariaRowIndex = startRowIndex + headerAndTopSummaryRowsCount + groupIndex + 2;\n        }\n        return rawRenderRow(key, {\n            ...rowProps,\n            \"aria-rowindex\": ariaRowIndex,\n            row: row$1,\n            rowClass,\n            onCellMouseDown,\n            onCellClick,\n            onCellDoubleClick,\n            onCellContextMenu,\n            onRowChange,\n            lastFrozenColumnIndex,\n            draggedOverCellIdx,\n            selectedCellEditor\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DataGrid, {\n        ...props,\n        role: \"treegrid\",\n        \"aria-rowcount\": rowsCount + 1 + (props.topSummaryRows?.length ?? 0) + (props.bottomSummaryRows?.length ?? 0),\n        columns,\n        rows,\n        rowHeight,\n        rowKeyGetter,\n        onRowsChange: handleRowsChange,\n        selectedRows,\n        onSelectedRowsChange,\n        onCellKeyDown: handleKeyDown,\n        onCellCopy: handleCellCopy,\n        onCellPaste: rawOnCellPaste ? handleCellPaste : void 0,\n        renderers: {\n            ...renderers,\n            renderRow\n        }\n    });\n}\nfunction defaultGroupIdGetter(groupKey, parentId) {\n    return parentId !== void 0 ? `${parentId}__${groupKey}` : groupKey;\n}\nfunction isReadonlyArray(arr) {\n    return Array.isArray(arr);\n}\n//#endregion\n//#region src/editors/renderTextEditor.tsx\nconst textEditorInternalClassname = \"rdg-7-0-0-beta-58-2f8db206\";\nconst textEditorClassname = `rdg-text-editor ${textEditorInternalClassname}`;\nfunction autoFocusAndSelect(input) {\n    input?.focus();\n    input?.select();\n}\nfunction textTextEditor({ row: row$1, column, onRowChange, onClose }) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", {\n        className: textEditorClassname,\n        ref: autoFocusAndSelect,\n        value: row$1[column.key],\n        onChange: (event)=>onRowChange({\n                ...row$1,\n                [column.key]: event.target.value\n            }),\n        onBlur: ()=>onClose(true, false)\n    });\n}\n//#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZGF0YS1ncmlkQDcuMC4wLWJldGEuXzFjYjNhZjc0ZWE1ZDQ0ZTBjZjVhNmNlN2IwYWRiMjhhL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSjtBQUNoSDtBQUNrQjtBQUV4RCxtQ0FBbUM7QUFDbkMsU0FBU2MsV0FBV0MsTUFBTSxFQUFFQyxxQkFBcUIsRUFBRUMsSUFBSTtJQUN0RCxNQUFNQyxVQUFVLE9BQU9ILE9BQU9HLE9BQU8sS0FBSyxhQUFhSCxPQUFPRyxPQUFPLENBQUNELFFBQVE7SUFDOUUsSUFBSUUsT0FBT0MsU0FBUyxDQUFDRixZQUFZQSxVQUFVLEtBQU0sRUFBQ0gsT0FBT00sTUFBTSxJQUFJTixPQUFPTyxHQUFHLEdBQUdKLFVBQVUsS0FBS0YscUJBQW9CLEdBQUksT0FBT0U7QUFDL0g7QUFFQSxZQUFZO0FBQ1osK0JBQStCO0FBQy9CLFNBQVNLLGdCQUFnQkMsS0FBSztJQUM3QkEsTUFBTUQsZUFBZTtBQUN0QjtBQUNBLFNBQVNFLGVBQWVDLE9BQU8sRUFBRUMsV0FBVyxTQUFTO0lBQ3BERCxTQUFTRCxlQUFlO1FBQ3ZCRyxRQUFRO1FBQ1JDLE9BQU87UUFDUEY7SUFDRDtBQUNEO0FBRUEsWUFBWTtBQUNaLGlDQUFpQztBQUNqQyxTQUFTRyxnQkFBZ0JOLEtBQUs7SUFDN0IsSUFBSU8sbUJBQW1CO0lBQ3ZCLE1BQU1DLFlBQVk7UUFDakIsR0FBR1IsS0FBSztRQUNSUztZQUNDRixtQkFBbUI7UUFDcEI7UUFDQUc7WUFDQyxPQUFPSDtRQUNSO0lBQ0Q7SUFDQUksT0FBT0MsY0FBYyxDQUFDSixXQUFXRyxPQUFPRSxjQUFjLENBQUNiO0lBQ3ZELE9BQU9RO0FBQ1I7QUFFQSxZQUFZO0FBQ1osb0NBQW9DO0FBQ3BDLE1BQU1NLGVBQWUsSUFBSUMsSUFBSTtJQUM1QjtJQUNBO0lBQ0E7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LFNBQVNDLGVBQWUsRUFBRXh0QixLQUFLWCxLQUFLLEVBQUU3RCxNQUFNLEVBQUUrWCxXQUFXLEVBQUVpQyxPQUFPLEVBQUU7SUFDbkUsT0FBTyxhQUFhLEdBQUduYSxzREFBR0EsQ0FBQyxTQUFTO1FBQ25DeUQsV0FBV3N1QjtRQUNYem9CLEtBQUswb0I7UUFDTHRuQixPQUFPMUcsS0FBSyxDQUFDN0QsT0FBTzZCLEdBQUcsQ0FBQztRQUN4QmdILFVBQVUsQ0FBQ3BJLFFBQVVzWCxZQUFZO2dCQUNoQyxHQUFHbFUsS0FBSztnQkFDUixDQUFDN0QsT0FBTzZCLEdBQUcsQ0FBQyxFQUFFcEIsTUFBTTJCLE1BQU0sQ0FBQ21JLEtBQUs7WUFDakM7UUFDQTBuQixRQUFRLElBQU1qWSxRQUFRLE1BQU07SUFDN0I7QUFDRDtBQUVBLFlBQVk7QUFDc1YsQ0FDbFcsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VudGluZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZGF0YS1ncmlkQDcuMC4wLWJldGEuXzFjYjNhZjc0ZWE1ZDQ0ZTBjZjVhNmNlN2IwYWRiMjhhL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRhLWdyaWQvbGliL2luZGV4LmpzPzQwYTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgbWVtbywgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdEV2ZW50LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VMYXlvdXRFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZsdXNoU3luYyB9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IEZyYWdtZW50LCBqc3gsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcblxuLy8jcmVnaW9uIHNyYy91dGlscy9jb2xTcGFuVXRpbHMudHNcbmZ1bmN0aW9uIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIGFyZ3MpIHtcblx0Y29uc3QgY29sU3BhbiA9IHR5cGVvZiBjb2x1bW4uY29sU3BhbiA9PT0gXCJmdW5jdGlvblwiID8gY29sdW1uLmNvbFNwYW4oYXJncykgOiAxO1xuXHRpZiAoTnVtYmVyLmlzSW50ZWdlcihjb2xTcGFuKSAmJiBjb2xTcGFuID4gMSAmJiAoIWNvbHVtbi5mcm96ZW4gfHwgY29sdW1uLmlkeCArIGNvbFNwYW4gLSAxIDw9IGxhc3RGcm96ZW5Db2x1bW5JbmRleCkpIHJldHVybiBjb2xTcGFuO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbHMvZG9tVXRpbHMudHNcbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuXHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQsIGJlaGF2aW9yID0gXCJpbnN0YW50XCIpIHtcblx0ZWxlbWVudD8uc2Nyb2xsSW50b1ZpZXcoe1xuXHRcdGlubGluZTogXCJuZWFyZXN0XCIsXG5cdFx0YmxvY2s6IFwibmVhcmVzdFwiLFxuXHRcdGJlaGF2aW9yXG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbHMvZXZlbnRVdGlscy50c1xuZnVuY3Rpb24gY3JlYXRlQ2VsbEV2ZW50KGV2ZW50KSB7XG5cdGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cdGNvbnN0IGNlbGxFdmVudCA9IHtcblx0XHQuLi5ldmVudCxcblx0XHRwcmV2ZW50R3JpZERlZmF1bHQoKSB7XG5cdFx0XHRkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cdH07XG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihjZWxsRXZlbnQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpO1xuXHRyZXR1cm4gY2VsbEV2ZW50O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbHMva2V5Ym9hcmRVdGlscy50c1xuY29uc3Qgbm9uSW5wdXRLZXlzID0gbmV3IFNldChbXG5cdFwiVW5pZGVudGlmaWVkXCIsXG5cdFwiQWx0XCIsXG5cdFwiQWx0R3JhcGhcIixcblx0XCJDYXBzTG9ja1wiLFxuXHRcIkNvbnRyb2xcIixcblx0XCJGblwiLFxuXHRcIkZuTG9ja1wiLFxuXHRcIk1ldGFcIixcblx0XCJOdW1Mb2NrXCIsXG5cdFwiU2Nyb2xsTG9ja1wiLFxuXHRcIlNoaWZ0XCIsXG5cdFwiVGFiXCIsXG5cdFwiQXJyb3dEb3duXCIsXG5cdFwiQXJyb3dMZWZ0XCIsXG5cdFwiQXJyb3dSaWdodFwiLFxuXHRcIkFycm93VXBcIixcblx0XCJFbmRcIixcblx0XCJIb21lXCIsXG5cdFwiUGFnZURvd25cIixcblx0XCJQYWdlVXBcIixcblx0XCJJbnNlcnRcIixcblx0XCJDb250ZXh0TWVudVwiLFxuXHRcIkVzY2FwZVwiLFxuXHRcIlBhdXNlXCIsXG5cdFwiUGxheVwiLFxuXHRcIlByaW50U2NyZWVuXCIsXG5cdFwiRjFcIixcblx0XCJGM1wiLFxuXHRcIkY0XCIsXG5cdFwiRjVcIixcblx0XCJGNlwiLFxuXHRcIkY3XCIsXG5cdFwiRjhcIixcblx0XCJGOVwiLFxuXHRcIkYxMFwiLFxuXHRcIkYxMVwiLFxuXHRcIkYxMlwiXG5dKTtcbmZ1bmN0aW9uIGlzQ3RybEtleUhlbGREb3duKGUpIHtcblx0cmV0dXJuIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiBlLmtleSAhPT0gXCJDb250cm9sXCI7XG59XG5jb25zdCB2S2V5ID0gODY7XG5mdW5jdGlvbiBpc0RlZmF1bHRDZWxsSW5wdXQoZXZlbnQsIGlzVXNlckhhbmRsaW5nUGFzdGUpIHtcblx0aWYgKGlzQ3RybEtleUhlbGREb3duKGV2ZW50KSAmJiAoZXZlbnQua2V5Q29kZSAhPT0gdktleSB8fCBpc1VzZXJIYW5kbGluZ1Bhc3RlKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gIW5vbklucHV0S2V5cy5oYXMoZXZlbnQua2V5KTtcbn1cbi8qKlxuKiBCeSBkZWZhdWx0LCB0aGUgZm9sbG93aW5nIG5hdmlnYXRpb24ga2V5cyBhcmUgZW5hYmxlZCB3aGlsZSBhbiBlZGl0b3IgaXMgb3BlbiwgdW5kZXIgc3BlY2lmaWMgY29uZGl0aW9uczpcbiogLSBUYWI6XG4qICAgLSBUaGUgZWRpdG9yIG11c3QgYmUgYW4gPGlucHV0PiwgYSA8dGV4dGFyZWE+LCBvciBhIDxzZWxlY3Q+IGVsZW1lbnQuXG4qICAgLSBUaGUgZWRpdG9yIGVsZW1lbnQgbXVzdCBiZSB0aGUgb25seSBpbW1lZGlhdGUgY2hpbGQgb2YgdGhlIGVkaXRvciBjb250YWluZXIvYSBsYWJlbC5cbiovXG5mdW5jdGlvbiBvbkVkaXRvck5hdmlnYXRpb24oeyBrZXksIHRhcmdldCB9KSB7XG5cdGlmIChrZXkgPT09IFwiVGFiXCIgJiYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpIHJldHVybiB0YXJnZXQuY2xvc2VzdChcIi5yZGctZWRpdG9yLWNvbnRhaW5lclwiKT8ucXVlcnlTZWxlY3RvckFsbChcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0XCIpLmxlbmd0aCA9PT0gMTtcblx0cmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0TGVmdFJpZ2h0S2V5KGRpcmVjdGlvbikge1xuXHRjb25zdCBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gXCJydGxcIjtcblx0cmV0dXJuIHtcblx0XHRsZWZ0S2V5OiBpc1J0bCA/IFwiQXJyb3dSaWdodFwiIDogXCJBcnJvd0xlZnRcIixcblx0XHRyaWdodEtleTogaXNSdGwgPyBcIkFycm93TGVmdFwiIDogXCJBcnJvd1JpZ2h0XCJcblx0fTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3V0aWxzL3JlbmRlck1lYXN1cmluZ0NlbGxzLnRzeFxuY29uc3QgbWVhc3VyaW5nQ2VsbENsYXNzbmFtZSA9IFwicmRnLTctMC0wLWJldGEtNTgtZmE3MWQ2M2VcIjtcbmZ1bmN0aW9uIHJlbmRlck1lYXN1cmluZ0NlbGxzKHZpZXdwb3J0Q29sdW1ucykge1xuXHRyZXR1cm4gdmlld3BvcnRDb2x1bW5zLm1hcCgoeyBrZXksIGlkeCwgbWluV2lkdGgsIG1heFdpZHRoIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwge1xuXHRcdGNsYXNzTmFtZTogbWVhc3VyaW5nQ2VsbENsYXNzbmFtZSxcblx0XHRzdHlsZToge1xuXHRcdFx0Z3JpZENvbHVtblN0YXJ0OiBpZHggKyAxLFxuXHRcdFx0bWluV2lkdGgsXG5cdFx0XHRtYXhXaWR0aFxuXHRcdH0sXG5cdFx0XCJkYXRhLW1lYXN1cmluZy1jZWxsLWtleVwiOiBrZXlcblx0fSwga2V5KSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91dGlscy9zZWxlY3RlZENlbGxVdGlscy50c1xuZnVuY3Rpb24gaXNTZWxlY3RlZENlbGxFZGl0YWJsZSh7IHNlbGVjdGVkUG9zaXRpb24sIGNvbHVtbnMsIHJvd3MgfSkge1xuXHRjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3NlbGVjdGVkUG9zaXRpb24uaWR4XTtcblx0Y29uc3Qgcm93JDEgPSByb3dzW3NlbGVjdGVkUG9zaXRpb24ucm93SWR4XTtcblx0cmV0dXJuIGlzQ2VsbEVkaXRhYmxlVXRpbChjb2x1bW4sIHJvdyQxKTtcbn1cbmZ1bmN0aW9uIGlzQ2VsbEVkaXRhYmxlVXRpbChjb2x1bW4sIHJvdyQxKSB7XG5cdHJldHVybiBjb2x1bW4ucmVuZGVyRWRpdENlbGwgIT0gbnVsbCAmJiAodHlwZW9mIGNvbHVtbi5lZGl0YWJsZSA9PT0gXCJmdW5jdGlvblwiID8gY29sdW1uLmVkaXRhYmxlKHJvdyQxKSA6IGNvbHVtbi5lZGl0YWJsZSkgIT09IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRDZWxsQ29sU3Bhbih7IHJvd3MsIHRvcFN1bW1hcnlSb3dzLCBib3R0b21TdW1tYXJ5Um93cywgcm93SWR4LCBtYWluSGVhZGVyUm93SWR4LCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIGNvbHVtbiB9KSB7XG5cdGNvbnN0IHRvcFN1bW1hcnlSb3dzQ291bnQgPSB0b3BTdW1tYXJ5Um93cz8ubGVuZ3RoID8/IDA7XG5cdGlmIChyb3dJZHggPT09IG1haW5IZWFkZXJSb3dJZHgpIHJldHVybiBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7IHR5cGU6IFwiSEVBREVSXCIgfSk7XG5cdGlmICh0b3BTdW1tYXJ5Um93cyAmJiByb3dJZHggPiBtYWluSGVhZGVyUm93SWR4ICYmIHJvd0lkeCA8PSB0b3BTdW1tYXJ5Um93c0NvdW50ICsgbWFpbkhlYWRlclJvd0lkeCkgcmV0dXJuIGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcblx0XHR0eXBlOiBcIlNVTU1BUllcIixcblx0XHRyb3c6IHRvcFN1bW1hcnlSb3dzW3Jvd0lkeCArIHRvcFN1bW1hcnlSb3dzQ291bnRdXG5cdH0pO1xuXHRpZiAocm93SWR4ID49IDAgJiYgcm93SWR4IDwgcm93cy5sZW5ndGgpIHtcblx0XHRjb25zdCByb3ckMSA9IHJvd3Nbcm93SWR4XTtcblx0XHRyZXR1cm4gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuXHRcdFx0dHlwZTogXCJST1dcIixcblx0XHRcdHJvdzogcm93JDFcblx0XHR9KTtcblx0fVxuXHRpZiAoYm90dG9tU3VtbWFyeVJvd3MpIHJldHVybiBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG5cdFx0dHlwZTogXCJTVU1NQVJZXCIsXG5cdFx0cm93OiBib3R0b21TdW1tYXJ5Um93c1tyb3dJZHggLSByb3dzLmxlbmd0aF1cblx0fSk7XG59XG5mdW5jdGlvbiBnZXROZXh0U2VsZWN0ZWRDZWxsUG9zaXRpb24oeyBtb3ZlVXAsIG1vdmVOZXh0LCBjZWxsTmF2aWdhdGlvbk1vZGUsIGNvbHVtbnMsIGNvbFNwYW5Db2x1bW5zLCByb3dzLCB0b3BTdW1tYXJ5Um93cywgYm90dG9tU3VtbWFyeVJvd3MsIG1pblJvd0lkeCwgbWFpbkhlYWRlclJvd0lkeCwgbWF4Um93SWR4LCBjdXJyZW50UG9zaXRpb246IHsgaWR4OiBjdXJyZW50SWR4LCByb3dJZHg6IGN1cnJlbnRSb3dJZHggfSwgbmV4dFBvc2l0aW9uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIGlzQ2VsbFdpdGhpbkJvdW5kcyB9KSB7XG5cdGxldCB7IGlkeDogbmV4dElkeCwgcm93SWR4OiBuZXh0Um93SWR4IH0gPSBuZXh0UG9zaXRpb247XG5cdGNvbnN0IGNvbHVtbnNDb3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuXHRjb25zdCBzZXRDb2xTcGFuID0gKG1vdmVOZXh0JDEpID0+IHtcblx0XHRmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2xTcGFuQ29sdW1ucykge1xuXHRcdFx0Y29uc3QgY29sSWR4ID0gY29sdW1uLmlkeDtcblx0XHRcdGlmIChjb2xJZHggPiBuZXh0SWR4KSBicmVhaztcblx0XHRcdGNvbnN0IGNvbFNwYW4gPSBnZXRTZWxlY3RlZENlbGxDb2xTcGFuKHtcblx0XHRcdFx0cm93cyxcblx0XHRcdFx0dG9wU3VtbWFyeVJvd3MsXG5cdFx0XHRcdGJvdHRvbVN1bW1hcnlSb3dzLFxuXHRcdFx0XHRyb3dJZHg6IG5leHRSb3dJZHgsXG5cdFx0XHRcdG1haW5IZWFkZXJSb3dJZHgsXG5cdFx0XHRcdGxhc3RGcm96ZW5Db2x1bW5JbmRleCxcblx0XHRcdFx0Y29sdW1uXG5cdFx0XHR9KTtcblx0XHRcdGlmIChjb2xTcGFuICYmIG5leHRJZHggPiBjb2xJZHggJiYgbmV4dElkeCA8IGNvbFNwYW4gKyBjb2xJZHgpIHtcblx0XHRcdFx0bmV4dElkeCA9IGNvbElkeCArIChtb3ZlTmV4dCQxID8gY29sU3BhbiA6IDApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGNvbnN0IGdldFBhcmVudFJvd0lkeCA9IChwYXJlbnQpID0+IHtcblx0XHRyZXR1cm4gcGFyZW50LmxldmVsICsgbWFpbkhlYWRlclJvd0lkeDtcblx0fTtcblx0Y29uc3Qgc2V0SGVhZGVyR3JvdXBDb2xBbmRSb3dTcGFuID0gKCkgPT4ge1xuXHRcdGlmIChtb3ZlTmV4dCkge1xuXHRcdFx0bGV0IHBhcmVudCA9IGNvbHVtbnNbbmV4dElkeF0ucGFyZW50O1xuXHRcdFx0d2hpbGUgKHBhcmVudCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGNvbnN0IHBhcmVudFJvd0lkeCA9IGdldFBhcmVudFJvd0lkeChwYXJlbnQpO1xuXHRcdFx0XHRpZiAobmV4dFJvd0lkeCA9PT0gcGFyZW50Um93SWR4KSB7XG5cdFx0XHRcdFx0bmV4dElkeCA9IHBhcmVudC5pZHggKyBwYXJlbnQuY29sU3Bhbjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobW92ZVVwKSB7XG5cdFx0XHRsZXQgcGFyZW50ID0gY29sdW1uc1tuZXh0SWR4XS5wYXJlbnQ7XG5cdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcblx0XHRcdHdoaWxlIChwYXJlbnQgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcblx0XHRcdFx0aWYgKG5leHRSb3dJZHggPj0gcGFyZW50Um93SWR4KSB7XG5cdFx0XHRcdFx0bmV4dElkeCA9IHBhcmVudC5pZHg7XG5cdFx0XHRcdFx0bmV4dFJvd0lkeCA9IHBhcmVudFJvd0lkeDtcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHRcdH1cblx0XHRcdGlmICghZm91bmQpIHtcblx0XHRcdFx0bmV4dElkeCA9IGN1cnJlbnRJZHg7XG5cdFx0XHRcdG5leHRSb3dJZHggPSBjdXJyZW50Um93SWR4O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKGlzQ2VsbFdpdGhpbkJvdW5kcyhuZXh0UG9zaXRpb24pKSB7XG5cdFx0c2V0Q29sU3Bhbihtb3ZlTmV4dCk7XG5cdFx0aWYgKG5leHRSb3dJZHggPCBtYWluSGVhZGVyUm93SWR4KSBzZXRIZWFkZXJHcm91cENvbEFuZFJvd1NwYW4oKTtcblx0fVxuXHRpZiAoY2VsbE5hdmlnYXRpb25Nb2RlID09PSBcIkNIQU5HRV9ST1dcIikge1xuXHRcdGNvbnN0IGlzQWZ0ZXJMYXN0Q29sdW1uID0gbmV4dElkeCA9PT0gY29sdW1uc0NvdW50O1xuXHRcdGNvbnN0IGlzQmVmb3JlRmlyc3RDb2x1bW4gPSBuZXh0SWR4ID09PSAtMTtcblx0XHRpZiAoaXNBZnRlckxhc3RDb2x1bW4pIHtcblx0XHRcdGlmICghKG5leHRSb3dJZHggPT09IG1heFJvd0lkeCkpIHtcblx0XHRcdFx0bmV4dElkeCA9IDA7XG5cdFx0XHRcdG5leHRSb3dJZHggKz0gMTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGlzQmVmb3JlRmlyc3RDb2x1bW4pIHtcblx0XHRcdGlmICghKG5leHRSb3dJZHggPT09IG1pblJvd0lkeCkpIHtcblx0XHRcdFx0bmV4dFJvd0lkeCAtPSAxO1xuXHRcdFx0XHRuZXh0SWR4ID0gY29sdW1uc0NvdW50IC0gMTtcblx0XHRcdH1cblx0XHRcdHNldENvbFNwYW4oZmFsc2UpO1xuXHRcdH1cblx0fVxuXHRpZiAobmV4dFJvd0lkeCA8IG1haW5IZWFkZXJSb3dJZHggJiYgbmV4dElkeCA+IC0xICYmIG5leHRJZHggPCBjb2x1bW5zQ291bnQpIHtcblx0XHRsZXQgcGFyZW50ID0gY29sdW1uc1tuZXh0SWR4XS5wYXJlbnQ7XG5cdFx0Y29uc3QgbmV4dFBhcmVudFJvd0lkeCA9IG5leHRSb3dJZHg7XG5cdFx0bmV4dFJvd0lkeCA9IG1haW5IZWFkZXJSb3dJZHg7XG5cdFx0d2hpbGUgKHBhcmVudCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRjb25zdCBwYXJlbnRSb3dJZHggPSBnZXRQYXJlbnRSb3dJZHgocGFyZW50KTtcblx0XHRcdGlmIChwYXJlbnRSb3dJZHggPj0gbmV4dFBhcmVudFJvd0lkeCkge1xuXHRcdFx0XHRuZXh0Um93SWR4ID0gcGFyZW50Um93SWR4O1xuXHRcdFx0XHRuZXh0SWR4ID0gcGFyZW50LmlkeDtcblx0XHRcdH1cblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB7XG5cdFx0aWR4OiBuZXh0SWR4LFxuXHRcdHJvd0lkeDogbmV4dFJvd0lkeFxuXHR9O1xufVxuZnVuY3Rpb24gY2FuRXhpdEdyaWQoeyBtYXhDb2xJZHgsIG1pblJvd0lkeCwgbWF4Um93SWR4LCBzZWxlY3RlZFBvc2l0aW9uOiB7IHJvd0lkeCwgaWR4IH0sIHNoaWZ0S2V5IH0pIHtcblx0cmV0dXJuIHNoaWZ0S2V5ID8gaWR4ID09PSAwICYmIHJvd0lkeCA9PT0gbWluUm93SWR4IDogaWR4ID09PSBtYXhDb2xJZHggJiYgcm93SWR4ID09PSBtYXhSb3dJZHg7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9zdHlsZS9jZWxsLnRzXG5jb25zdCBjZWxsID0gXCJyZGctNy0wLTAtYmV0YS01OC04NWM0ODUyN1wiO1xuY29uc3QgY2VsbENsYXNzbmFtZSA9IGByZGctY2VsbCAke2NlbGx9YDtcbmNvbnN0IGNlbGxGcm96ZW4gPSBcInJkZy03LTAtMC1iZXRhLTU4LTE3YTlhNmQ0XCI7XG5jb25zdCBjZWxsRnJvemVuQ2xhc3NuYW1lID0gYHJkZy1jZWxsLWZyb3plbiAke2NlbGxGcm96ZW59YDtcbmNvbnN0IGNlbGxEcmFnSGFuZGxlID0gXCJyZGctNy0wLTAtYmV0YS01OC1iZmJhMTliY1wiO1xuY29uc3QgY2VsbERyYWdIYW5kbGVGcm96ZW5DbGFzc25hbWUgPSBcInJkZy03LTAtMC1iZXRhLTU4LTdhYmRkYjNlXCI7XG5jb25zdCBjZWxsRHJhZ0hhbmRsZUNsYXNzbmFtZSA9IGByZGctY2VsbC1kcmFnLWhhbmRsZSAke2NlbGxEcmFnSGFuZGxlfWA7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91dGlscy9zdHlsZVV0aWxzLnRzXG5mdW5jdGlvbiBnZXRSb3dTdHlsZShyb3dJZHgpIHtcblx0cmV0dXJuIHsgXCItLXJkZy1ncmlkLXJvdy1zdGFydFwiOiByb3dJZHggfTtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckNlbGxTdHlsZShjb2x1bW4sIHJvd0lkeCwgcm93U3Bhbikge1xuXHRjb25zdCBncmlkUm93RW5kID0gcm93SWR4ICsgMTtcblx0Y29uc3QgcGFkZGluZ0Jsb2NrU3RhcnQgPSBgY2FsYygke3Jvd1NwYW4gLSAxfSAqIHZhcigtLXJkZy1oZWFkZXItcm93LWhlaWdodCkpYDtcblx0aWYgKGNvbHVtbi5wYXJlbnQgPT09IHZvaWQgMCkgcmV0dXJuIHtcblx0XHRpbnNldEJsb2NrU3RhcnQ6IDAsXG5cdFx0Z3JpZFJvd1N0YXJ0OiAxLFxuXHRcdGdyaWRSb3dFbmQsXG5cdFx0cGFkZGluZ0Jsb2NrU3RhcnRcblx0fTtcblx0cmV0dXJuIHtcblx0XHRpbnNldEJsb2NrU3RhcnQ6IGBjYWxjKCR7cm93SWR4IC0gcm93U3Bhbn0gKiB2YXIoLS1yZGctaGVhZGVyLXJvdy1oZWlnaHQpKWAsXG5cdFx0Z3JpZFJvd1N0YXJ0OiBncmlkUm93RW5kIC0gcm93U3Bhbixcblx0XHRncmlkUm93RW5kLFxuXHRcdHBhZGRpbmdCbG9ja1N0YXJ0XG5cdH07XG59XG5mdW5jdGlvbiBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuID0gMSkge1xuXHRjb25zdCBpbmRleCA9IGNvbHVtbi5pZHggKyAxO1xuXHRyZXR1cm4ge1xuXHRcdGdyaWRDb2x1bW5TdGFydDogaW5kZXgsXG5cdFx0Z3JpZENvbHVtbkVuZDogaW5kZXggKyBjb2xTcGFuLFxuXHRcdGluc2V0SW5saW5lU3RhcnQ6IGNvbHVtbi5mcm96ZW4gPyBgdmFyKC0tcmRnLWZyb3plbi1sZWZ0LSR7Y29sdW1uLmlkeH0pYCA6IHZvaWQgMFxuXHR9O1xufVxuZnVuY3Rpb24gY2xhc3NuYW1lcyguLi5hcmdzKSB7XG5cdGxldCBjbGFzc25hbWUgPSBcIlwiO1xuXHRmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSBpZiAoYXJnKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIGNsYXNzbmFtZSArPSBgICR7YXJnfWA7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gYXJnKSBpZiAoYXJnW2tleV0pIGNsYXNzbmFtZSArPSBgICR7a2V5fWA7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjbGFzc25hbWUudHJpbVN0YXJ0KCk7XG59XG5mdW5jdGlvbiBnZXRDZWxsQ2xhc3NuYW1lKGNvbHVtbiwgLi4uZXh0cmFDbGFzc2VzKSB7XG5cdHJldHVybiBjbGFzc25hbWVzKGNlbGxDbGFzc25hbWUsIHsgW2NlbGxGcm96ZW5DbGFzc25hbWVdOiBjb2x1bW4uZnJvemVuIH0sIC4uLmV4dHJhQ2xhc3Nlcyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91dGlscy9pbmRleC50c1xuY29uc3QgeyBtaW4sIG1heCwgZmxvb3IsIHNpZ24sIGFicyB9ID0gTWF0aDtcbmZ1bmN0aW9uIGFzc2VydElzVmFsaWRLZXlHZXR0ZXIoa2V5R2V0dGVyKSB7XG5cdGlmICh0eXBlb2Yga2V5R2V0dGVyICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IHRoZSByb3dLZXlHZXR0ZXIgcHJvcCB0byB1c2Ugc2VsZWN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2xhbXBDb2x1bW5XaWR0aCh3aWR0aCwgeyBtaW5XaWR0aCwgbWF4V2lkdGggfSkge1xuXHR3aWR0aCA9IG1heCh3aWR0aCwgbWluV2lkdGgpO1xuXHRpZiAodHlwZW9mIG1heFdpZHRoID09PSBcIm51bWJlclwiICYmIG1heFdpZHRoID49IG1pbldpZHRoKSByZXR1cm4gbWluKHdpZHRoLCBtYXhXaWR0aCk7XG5cdHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckNlbGxSb3dTcGFuKGNvbHVtbiwgcm93SWR4KSB7XG5cdHJldHVybiBjb2x1bW4ucGFyZW50ID09PSB2b2lkIDAgPyByb3dJZHggOiBjb2x1bW4ubGV2ZWwgLSBjb2x1bW4ucGFyZW50LmxldmVsO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvY2VsbFJlbmRlcmVycy9yZW5kZXJDaGVja2JveC50c3hcbmNvbnN0IGNoZWNrYm94Q2xhc3NuYW1lID0gYHJkZy1jaGVja2JveC1pbnB1dCByZGctNy0wLTAtYmV0YS01OC0zYjgwN2VhZGA7XG5mdW5jdGlvbiByZW5kZXJDaGVja2JveCh7IG9uQ2hhbmdlLCBpbmRldGVybWluYXRlLCAuLi5wcm9wcyB9KSB7XG5cdGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShlKSB7XG5cdFx0b25DaGFuZ2UoZS50YXJnZXQuY2hlY2tlZCwgZS5uYXRpdmVFdmVudC5zaGlmdEtleSk7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJpbnB1dFwiLCB7XG5cdFx0cmVmOiAoZWwpID0+IHtcblx0XHRcdGlmIChlbCkgZWwuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGUgPT09IHRydWU7XG5cdFx0fSxcblx0XHR0eXBlOiBcImNoZWNrYm94XCIsXG5cdFx0Y2xhc3NOYW1lOiBjaGVja2JveENsYXNzbmFtZSxcblx0XHRvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuXHRcdC4uLnByb3BzXG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvY2VsbFJlbmRlcmVycy9yZW5kZXJUb2dnbGVHcm91cC50c3hcbmNvbnN0IGdyb3VwQ2VsbENvbnRlbnRDbGFzc25hbWUgPSBgcmRnLWdyb3VwLWNlbGwtY29udGVudCByZGctNy0wLTAtYmV0YS01OC0wNzkxOTM4MmA7XG5jb25zdCBjYXJldENsYXNzbmFtZSA9IGByZGctY2FyZXQgcmRnLTctMC0wLWJldGEtNTgtMDJhNTAxNDdgO1xuZnVuY3Rpb24gcmVuZGVyVG9nZ2xlR3JvdXAocHJvcHMpIHtcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9nZ2xlR3JvdXAsIHsgLi4ucHJvcHMgfSk7XG59XG5mdW5jdGlvbiBUb2dnbGVHcm91cCh7IGdyb3VwS2V5LCBpc0V4cGFuZGVkLCB0YWJJbmRleCwgdG9nZ2xlR3JvdXAgfSkge1xuXHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKHsga2V5IH0pIHtcblx0XHRpZiAoa2V5ID09PSBcIkVudGVyXCIpIHRvZ2dsZUdyb3VwKCk7XG5cdH1cblx0Y29uc3QgZCA9IGlzRXhwYW5kZWQgPyBcIk0xIDEgTCA3IDcgTCAxMyAxXCIgOiBcIk0xIDcgTCA3IDEgTCAxMyA3XCI7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwge1xuXHRcdGNsYXNzTmFtZTogZ3JvdXBDZWxsQ29udGVudENsYXNzbmFtZSxcblx0XHR0YWJJbmRleCxcblx0XHRvbktleURvd246IGhhbmRsZUtleURvd24sXG5cdFx0Y2hpbGRyZW46IFtncm91cEtleSwgLyogQF9fUFVSRV9fICovIGpzeChcInN2Z1wiLCB7XG5cdFx0XHR2aWV3Qm94OiBcIjAgMCAxNCA4XCIsXG5cdFx0XHR3aWR0aDogXCIxNFwiLFxuXHRcdFx0aGVpZ2h0OiBcIjhcIixcblx0XHRcdGNsYXNzTmFtZTogY2FyZXRDbGFzc25hbWUsXG5cdFx0XHRcImFyaWEtaGlkZGVuXCI6IHRydWUsXG5cdFx0XHRjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInBhdGhcIiwgeyBkIH0pXG5cdFx0fSldXG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvY2VsbFJlbmRlcmVycy9yZW5kZXJWYWx1ZS50c3hcbmZ1bmN0aW9uIHJlbmRlclZhbHVlKHByb3BzKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BzLnJvd1twcm9wcy5jb2x1bW4ua2V5XTtcblx0fSBjYXRjaCB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL0RhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc0NvbnRleHQudHNcbmNvbnN0IERhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiB1c2VEZWZhdWx0UmVuZGVyZXJzKCkge1xuXHRyZXR1cm4gdXNlQ29udGV4dChEYXRhR3JpZERlZmF1bHRSZW5kZXJlcnNDb250ZXh0KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2NlbGxSZW5kZXJlcnMvU2VsZWN0Q2VsbEZvcm1hdHRlci50c3hcbmZ1bmN0aW9uIFNlbGVjdENlbGxGb3JtYXR0ZXIoeyB2YWx1ZSwgdGFiSW5kZXgsIGluZGV0ZXJtaW5hdGUsIGRpc2FibGVkLCBvbkNoYW5nZSwgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkQnkgfSkge1xuXHRjb25zdCByZW5kZXJDaGVja2JveCQxID0gdXNlRGVmYXVsdFJlbmRlcmVycygpLnJlbmRlckNoZWNrYm94O1xuXHRyZXR1cm4gcmVuZGVyQ2hlY2tib3gkMSh7XG5cdFx0XCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCxcblx0XHRcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSxcblx0XHR0YWJJbmRleCxcblx0XHRpbmRldGVybWluYXRlLFxuXHRcdGRpc2FibGVkLFxuXHRcdGNoZWNrZWQ6IHZhbHVlLFxuXHRcdG9uQ2hhbmdlXG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvaG9va3MvdXNlUm93U2VsZWN0aW9uLnRzXG5jb25zdCBSb3dTZWxlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuY29uc3QgUm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIHVzZVJvd1NlbGVjdGlvbigpIHtcblx0Y29uc3Qgcm93U2VsZWN0aW9uQ29udGV4dCA9IHVzZUNvbnRleHQoUm93U2VsZWN0aW9uQ29udGV4dCk7XG5cdGNvbnN0IHJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQgPSB1c2VDb250ZXh0KFJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQpO1xuXHRpZiAocm93U2VsZWN0aW9uQ29udGV4dCA9PT0gdm9pZCAwIHx8IHJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwidXNlUm93U2VsZWN0aW9uIG11c3QgYmUgdXNlZCB3aXRoaW4gcmVuZGVyQ2VsbFwiKTtcblx0cmV0dXJuIHtcblx0XHRpc1Jvd1NlbGVjdGlvbkRpc2FibGVkOiByb3dTZWxlY3Rpb25Db250ZXh0LmlzUm93U2VsZWN0aW9uRGlzYWJsZWQsXG5cdFx0aXNSb3dTZWxlY3RlZDogcm93U2VsZWN0aW9uQ29udGV4dC5pc1Jvd1NlbGVjdGVkLFxuXHRcdG9uUm93U2VsZWN0aW9uQ2hhbmdlOiByb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0XG5cdH07XG59XG5jb25zdCBIZWFkZXJSb3dTZWxlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuY29uc3QgSGVhZGVyUm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIHVzZUhlYWRlclJvd1NlbGVjdGlvbigpIHtcblx0Y29uc3QgaGVhZGVyUm93U2VsZWN0aW9uQ29udGV4dCA9IHVzZUNvbnRleHQoSGVhZGVyUm93U2VsZWN0aW9uQ29udGV4dCk7XG5cdGNvbnN0IGhlYWRlclJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQgPSB1c2VDb250ZXh0KEhlYWRlclJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQpO1xuXHRpZiAoaGVhZGVyUm93U2VsZWN0aW9uQ29udGV4dCA9PT0gdm9pZCAwIHx8IGhlYWRlclJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwidXNlSGVhZGVyUm93U2VsZWN0aW9uIG11c3QgYmUgdXNlZCB3aXRoaW4gcmVuZGVySGVhZGVyQ2VsbFwiKTtcblx0cmV0dXJuIHtcblx0XHRpc0luZGV0ZXJtaW5hdGU6IGhlYWRlclJvd1NlbGVjdGlvbkNvbnRleHQuaXNJbmRldGVybWluYXRlLFxuXHRcdGlzUm93U2VsZWN0ZWQ6IGhlYWRlclJvd1NlbGVjdGlvbkNvbnRleHQuaXNSb3dTZWxlY3RlZCxcblx0XHRvblJvd1NlbGVjdGlvbkNoYW5nZTogaGVhZGVyUm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dFxuXHR9O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvQ29sdW1ucy50c3hcbmNvbnN0IFNFTEVDVF9DT0xVTU5fS0VZID0gXCJyZGctc2VsZWN0LWNvbHVtblwiO1xuZnVuY3Rpb24gSGVhZGVyUmVuZGVyZXIocHJvcHMpIHtcblx0Y29uc3QgeyBpc0luZGV0ZXJtaW5hdGUsIGlzUm93U2VsZWN0ZWQsIG9uUm93U2VsZWN0aW9uQ2hhbmdlIH0gPSB1c2VIZWFkZXJSb3dTZWxlY3Rpb24oKTtcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0Q2VsbEZvcm1hdHRlciwge1xuXHRcdFwiYXJpYS1sYWJlbFwiOiBcIlNlbGVjdCBBbGxcIixcblx0XHR0YWJJbmRleDogcHJvcHMudGFiSW5kZXgsXG5cdFx0aW5kZXRlcm1pbmF0ZTogaXNJbmRldGVybWluYXRlLFxuXHRcdHZhbHVlOiBpc1Jvd1NlbGVjdGVkLFxuXHRcdG9uQ2hhbmdlOiAoY2hlY2tlZCkgPT4ge1xuXHRcdFx0b25Sb3dTZWxlY3Rpb25DaGFuZ2UoeyBjaGVja2VkOiBpc0luZGV0ZXJtaW5hdGUgPyBmYWxzZSA6IGNoZWNrZWQgfSk7XG5cdFx0fVxuXHR9KTtcbn1cbmZ1bmN0aW9uIFNlbGVjdEZvcm1hdHRlcihwcm9wcykge1xuXHRjb25zdCB7IGlzUm93U2VsZWN0aW9uRGlzYWJsZWQsIGlzUm93U2VsZWN0ZWQsIG9uUm93U2VsZWN0aW9uQ2hhbmdlIH0gPSB1c2VSb3dTZWxlY3Rpb24oKTtcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0Q2VsbEZvcm1hdHRlciwge1xuXHRcdFwiYXJpYS1sYWJlbFwiOiBcIlNlbGVjdFwiLFxuXHRcdHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCxcblx0XHRkaXNhYmxlZDogaXNSb3dTZWxlY3Rpb25EaXNhYmxlZCxcblx0XHR2YWx1ZTogaXNSb3dTZWxlY3RlZCxcblx0XHRvbkNoYW5nZTogKGNoZWNrZWQsIGlzU2hpZnRDbGljaykgPT4ge1xuXHRcdFx0b25Sb3dTZWxlY3Rpb25DaGFuZ2Uoe1xuXHRcdFx0XHRyb3c6IHByb3BzLnJvdyxcblx0XHRcdFx0Y2hlY2tlZCxcblx0XHRcdFx0aXNTaGlmdENsaWNrXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufVxuZnVuY3Rpb24gU2VsZWN0R3JvdXBGb3JtYXR0ZXIocHJvcHMpIHtcblx0Y29uc3QgeyBpc1Jvd1NlbGVjdGVkLCBvblJvd1NlbGVjdGlvbkNoYW5nZSB9ID0gdXNlUm93U2VsZWN0aW9uKCk7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNlbGVjdENlbGxGb3JtYXR0ZXIsIHtcblx0XHRcImFyaWEtbGFiZWxcIjogXCJTZWxlY3QgR3JvdXBcIixcblx0XHR0YWJJbmRleDogcHJvcHMudGFiSW5kZXgsXG5cdFx0dmFsdWU6IGlzUm93U2VsZWN0ZWQsXG5cdFx0b25DaGFuZ2U6IChjaGVja2VkKSA9PiB7XG5cdFx0XHRvblJvd1NlbGVjdGlvbkNoYW5nZSh7XG5cdFx0XHRcdHJvdzogcHJvcHMucm93LFxuXHRcdFx0XHRjaGVja2VkLFxuXHRcdFx0XHRpc1NoaWZ0Q2xpY2s6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufVxuY29uc3QgU2VsZWN0Q29sdW1uID0ge1xuXHRrZXk6IFNFTEVDVF9DT0xVTU5fS0VZLFxuXHRuYW1lOiBcIlwiLFxuXHR3aWR0aDogMzUsXG5cdG1pbldpZHRoOiAzNSxcblx0bWF4V2lkdGg6IDM1LFxuXHRyZXNpemFibGU6IGZhbHNlLFxuXHRzb3J0YWJsZTogZmFsc2UsXG5cdGZyb3plbjogdHJ1ZSxcblx0cmVuZGVySGVhZGVyQ2VsbChwcm9wcykge1xuXHRcdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEhlYWRlclJlbmRlcmVyLCB7IC4uLnByb3BzIH0pO1xuXHR9LFxuXHRyZW5kZXJDZWxsKHByb3BzKSB7XG5cdFx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0Rm9ybWF0dGVyLCB7IC4uLnByb3BzIH0pO1xuXHR9LFxuXHRyZW5kZXJHcm91cENlbGwocHJvcHMpIHtcblx0XHRyZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RHcm91cEZvcm1hdHRlciwgeyAuLi5wcm9wcyB9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3JlbmRlckhlYWRlckNlbGwudHN4XG5jb25zdCBoZWFkZXJTb3J0Q2VsbENsYXNzbmFtZSA9IFwicmRnLTctMC0wLWJldGEtNTgtNTZhMjQ4ZTRcIjtcbmNvbnN0IGhlYWRlclNvcnROYW1lQ2xhc3NuYW1lID0gYHJkZy1oZWFkZXItc29ydC1uYW1lIHJkZy03LTAtMC1iZXRhLTU4LTdmYWQ4YzgzYDtcbmZ1bmN0aW9uIHJlbmRlckhlYWRlckNlbGwoeyBjb2x1bW4sIHNvcnREaXJlY3Rpb24sIHByaW9yaXR5IH0pIHtcblx0aWYgKCFjb2x1bW4uc29ydGFibGUpIHJldHVybiBjb2x1bW4ubmFtZTtcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU29ydGFibGVIZWFkZXJDZWxsLCB7XG5cdFx0c29ydERpcmVjdGlvbixcblx0XHRwcmlvcml0eSxcblx0XHRjaGlsZHJlbjogY29sdW1uLm5hbWVcblx0fSk7XG59XG5mdW5jdGlvbiBTb3J0YWJsZUhlYWRlckNlbGwoeyBzb3J0RGlyZWN0aW9uLCBwcmlvcml0eSwgY2hpbGRyZW4gfSkge1xuXHRjb25zdCByZW5kZXJTb3J0U3RhdHVzJDEgPSB1c2VEZWZhdWx0UmVuZGVyZXJzKCkucmVuZGVyU29ydFN0YXR1cztcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7XG5cdFx0Y2xhc3NOYW1lOiBoZWFkZXJTb3J0Q2VsbENsYXNzbmFtZSxcblx0XHRjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHtcblx0XHRcdGNsYXNzTmFtZTogaGVhZGVyU29ydE5hbWVDbGFzc25hbWUsXG5cdFx0XHRjaGlsZHJlblxuXHRcdH0pLCAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiByZW5kZXJTb3J0U3RhdHVzJDEoe1xuXHRcdFx0c29ydERpcmVjdGlvbixcblx0XHRcdHByaW9yaXR5XG5cdFx0fSkgfSldXG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvaG9va3MvdXNlQ2FsY3VsYXRlZENvbHVtbnMudHNcbmNvbnN0IERFRkFVTFRfQ09MVU1OX1dJRFRIID0gXCJhdXRvXCI7XG5jb25zdCBERUZBVUxUX0NPTFVNTl9NSU5fV0lEVEggPSA1MDtcbmZ1bmN0aW9uIHVzZUNhbGN1bGF0ZWRDb2x1bW5zKHsgcmF3Q29sdW1ucywgZGVmYXVsdENvbHVtbk9wdGlvbnMsIGdldENvbHVtbldpZHRoLCB2aWV3cG9ydFdpZHRoLCBzY3JvbGxMZWZ0LCBlbmFibGVWaXJ0dWFsaXphdGlvbiB9KSB7XG5cdGNvbnN0IGRlZmF1bHRXaWR0aCA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy53aWR0aCA/PyBERUZBVUxUX0NPTFVNTl9XSURUSDtcblx0Y29uc3QgZGVmYXVsdE1pbldpZHRoID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/Lm1pbldpZHRoID8/IERFRkFVTFRfQ09MVU1OX01JTl9XSURUSDtcblx0Y29uc3QgZGVmYXVsdE1heFdpZHRoID0gZGVmYXVsdENvbHVtbk9wdGlvbnM/Lm1heFdpZHRoID8/IHZvaWQgMDtcblx0Y29uc3QgZGVmYXVsdFJlbmRlckNlbGwkMSA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy5yZW5kZXJDZWxsID8/IHJlbmRlclZhbHVlO1xuXHRjb25zdCBkZWZhdWx0UmVuZGVySGVhZGVyQ2VsbCA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy5yZW5kZXJIZWFkZXJDZWxsID8/IHJlbmRlckhlYWRlckNlbGw7XG5cdGNvbnN0IGRlZmF1bHRTb3J0YWJsZSA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy5zb3J0YWJsZSA/PyBmYWxzZTtcblx0Y29uc3QgZGVmYXVsdFJlc2l6YWJsZSA9IGRlZmF1bHRDb2x1bW5PcHRpb25zPy5yZXNpemFibGUgPz8gZmFsc2U7XG5cdGNvbnN0IGRlZmF1bHREcmFnZ2FibGUgPSBkZWZhdWx0Q29sdW1uT3B0aW9ucz8uZHJhZ2dhYmxlID8/IGZhbHNlO1xuXHRjb25zdCB7IGNvbHVtbnMsIGNvbFNwYW5Db2x1bW5zLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIGhlYWRlclJvd3NDb3VudCB9ID0gdXNlTWVtbygoKSA9PiB7XG5cdFx0bGV0IGxhc3RGcm96ZW5Db2x1bW5JbmRleCQxID0gLTE7XG5cdFx0bGV0IGhlYWRlclJvd3NDb3VudCQxID0gMTtcblx0XHRjb25zdCBjb2x1bW5zJDEgPSBbXTtcblx0XHRjb2xsZWN0Q29sdW1ucyhyYXdDb2x1bW5zLCAxKTtcblx0XHRmdW5jdGlvbiBjb2xsZWN0Q29sdW1ucyhyYXdDb2x1bW5zJDEsIGxldmVsLCBwYXJlbnQpIHtcblx0XHRcdGZvciAoY29uc3QgcmF3Q29sdW1uIG9mIHJhd0NvbHVtbnMkMSkge1xuXHRcdFx0XHRpZiAoXCJjaGlsZHJlblwiIGluIHJhd0NvbHVtbikge1xuXHRcdFx0XHRcdGNvbnN0IGNhbGN1bGF0ZWRDb2x1bW5QYXJlbnQgPSB7XG5cdFx0XHRcdFx0XHRuYW1lOiByYXdDb2x1bW4ubmFtZSxcblx0XHRcdFx0XHRcdHBhcmVudCxcblx0XHRcdFx0XHRcdGlkeDogLTEsXG5cdFx0XHRcdFx0XHRjb2xTcGFuOiAwLFxuXHRcdFx0XHRcdFx0bGV2ZWw6IDAsXG5cdFx0XHRcdFx0XHRoZWFkZXJDZWxsQ2xhc3M6IHJhd0NvbHVtbi5oZWFkZXJDZWxsQ2xhc3Ncblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGNvbGxlY3RDb2x1bW5zKHJhd0NvbHVtbi5jaGlsZHJlbiwgbGV2ZWwgKyAxLCBjYWxjdWxhdGVkQ29sdW1uUGFyZW50KTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBmcm96ZW4gPSByYXdDb2x1bW4uZnJvemVuID8/IGZhbHNlO1xuXHRcdFx0XHRjb25zdCBjb2x1bW4gPSB7XG5cdFx0XHRcdFx0Li4ucmF3Q29sdW1uLFxuXHRcdFx0XHRcdHBhcmVudCxcblx0XHRcdFx0XHRpZHg6IDAsXG5cdFx0XHRcdFx0bGV2ZWw6IDAsXG5cdFx0XHRcdFx0ZnJvemVuLFxuXHRcdFx0XHRcdHdpZHRoOiByYXdDb2x1bW4ud2lkdGggPz8gZGVmYXVsdFdpZHRoLFxuXHRcdFx0XHRcdG1pbldpZHRoOiByYXdDb2x1bW4ubWluV2lkdGggPz8gZGVmYXVsdE1pbldpZHRoLFxuXHRcdFx0XHRcdG1heFdpZHRoOiByYXdDb2x1bW4ubWF4V2lkdGggPz8gZGVmYXVsdE1heFdpZHRoLFxuXHRcdFx0XHRcdHNvcnRhYmxlOiByYXdDb2x1bW4uc29ydGFibGUgPz8gZGVmYXVsdFNvcnRhYmxlLFxuXHRcdFx0XHRcdHJlc2l6YWJsZTogcmF3Q29sdW1uLnJlc2l6YWJsZSA/PyBkZWZhdWx0UmVzaXphYmxlLFxuXHRcdFx0XHRcdGRyYWdnYWJsZTogcmF3Q29sdW1uLmRyYWdnYWJsZSA/PyBkZWZhdWx0RHJhZ2dhYmxlLFxuXHRcdFx0XHRcdHJlbmRlckNlbGw6IHJhd0NvbHVtbi5yZW5kZXJDZWxsID8/IGRlZmF1bHRSZW5kZXJDZWxsJDEsXG5cdFx0XHRcdFx0cmVuZGVySGVhZGVyQ2VsbDogcmF3Q29sdW1uLnJlbmRlckhlYWRlckNlbGwgPz8gZGVmYXVsdFJlbmRlckhlYWRlckNlbGxcblx0XHRcdFx0fTtcblx0XHRcdFx0Y29sdW1ucyQxLnB1c2goY29sdW1uKTtcblx0XHRcdFx0aWYgKGZyb3plbikgbGFzdEZyb3plbkNvbHVtbkluZGV4JDErKztcblx0XHRcdFx0aWYgKGxldmVsID4gaGVhZGVyUm93c0NvdW50JDEpIGhlYWRlclJvd3NDb3VudCQxID0gbGV2ZWw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbHVtbnMkMS5zb3J0KCh7IGtleTogYUtleSwgZnJvemVuOiBmcm96ZW5BIH0sIHsga2V5OiBiS2V5LCBmcm96ZW46IGZyb3plbkIgfSkgPT4ge1xuXHRcdFx0aWYgKGFLZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZKSByZXR1cm4gLTE7XG5cdFx0XHRpZiAoYktleSA9PT0gU0VMRUNUX0NPTFVNTl9LRVkpIHJldHVybiAxO1xuXHRcdFx0aWYgKGZyb3plbkEpIHtcblx0XHRcdFx0aWYgKGZyb3plbkIpIHJldHVybiAwO1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZnJvemVuQikgcmV0dXJuIDE7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9KTtcblx0XHRjb25zdCBjb2xTcGFuQ29sdW1ucyQxID0gW107XG5cdFx0Y29sdW1ucyQxLmZvckVhY2goKGNvbHVtbiwgaWR4KSA9PiB7XG5cdFx0XHRjb2x1bW4uaWR4ID0gaWR4O1xuXHRcdFx0dXBkYXRlQ29sdW1uUGFyZW50KGNvbHVtbiwgaWR4LCAwKTtcblx0XHRcdGlmIChjb2x1bW4uY29sU3BhbiAhPSBudWxsKSBjb2xTcGFuQ29sdW1ucyQxLnB1c2goY29sdW1uKTtcblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29sdW1uczogY29sdW1ucyQxLFxuXHRcdFx0Y29sU3BhbkNvbHVtbnM6IGNvbFNwYW5Db2x1bW5zJDEsXG5cdFx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXg6IGxhc3RGcm96ZW5Db2x1bW5JbmRleCQxLFxuXHRcdFx0aGVhZGVyUm93c0NvdW50OiBoZWFkZXJSb3dzQ291bnQkMVxuXHRcdH07XG5cdH0sIFtcblx0XHRyYXdDb2x1bW5zLFxuXHRcdGRlZmF1bHRXaWR0aCxcblx0XHRkZWZhdWx0TWluV2lkdGgsXG5cdFx0ZGVmYXVsdE1heFdpZHRoLFxuXHRcdGRlZmF1bHRSZW5kZXJDZWxsJDEsXG5cdFx0ZGVmYXVsdFJlbmRlckhlYWRlckNlbGwsXG5cdFx0ZGVmYXVsdFJlc2l6YWJsZSxcblx0XHRkZWZhdWx0U29ydGFibGUsXG5cdFx0ZGVmYXVsdERyYWdnYWJsZVxuXHRdKTtcblx0Y29uc3QgeyB0ZW1wbGF0ZUNvbHVtbnMsIGxheW91dENzc1ZhcnMsIHRvdGFsRnJvemVuQ29sdW1uV2lkdGgsIGNvbHVtbk1ldHJpY3MgfSA9IHVzZU1lbW8oKCkgPT4ge1xuXHRcdGNvbnN0IGNvbHVtbk1ldHJpY3MkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5cdFx0bGV0IGxlZnQgPSAwO1xuXHRcdGxldCB0b3RhbEZyb3plbkNvbHVtbldpZHRoJDEgPSAwO1xuXHRcdGNvbnN0IHRlbXBsYXRlQ29sdW1ucyQxID0gW107XG5cdFx0Zm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuXHRcdFx0bGV0IHdpZHRoID0gZ2V0Q29sdW1uV2lkdGgoY29sdW1uKTtcblx0XHRcdGlmICh0eXBlb2Ygd2lkdGggPT09IFwibnVtYmVyXCIpIHdpZHRoID0gY2xhbXBDb2x1bW5XaWR0aCh3aWR0aCwgY29sdW1uKTtcblx0XHRcdGVsc2Ugd2lkdGggPSBjb2x1bW4ubWluV2lkdGg7XG5cdFx0XHR0ZW1wbGF0ZUNvbHVtbnMkMS5wdXNoKGAke3dpZHRofXB4YCk7XG5cdFx0XHRjb2x1bW5NZXRyaWNzJDEuc2V0KGNvbHVtbiwge1xuXHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0bGVmdFxuXHRcdFx0fSk7XG5cdFx0XHRsZWZ0ICs9IHdpZHRoO1xuXHRcdH1cblx0XHRpZiAobGFzdEZyb3plbkNvbHVtbkluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y29uc3QgY29sdW1uTWV0cmljID0gY29sdW1uTWV0cmljcyQxLmdldChjb2x1bW5zW2xhc3RGcm96ZW5Db2x1bW5JbmRleF0pO1xuXHRcdFx0dG90YWxGcm96ZW5Db2x1bW5XaWR0aCQxID0gY29sdW1uTWV0cmljLmxlZnQgKyBjb2x1bW5NZXRyaWMud2lkdGg7XG5cdFx0fVxuXHRcdGNvbnN0IGxheW91dENzc1ZhcnMkMSA9IHt9O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RGcm96ZW5Db2x1bW5JbmRleDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuXHRcdFx0bGF5b3V0Q3NzVmFycyQxW2AtLXJkZy1mcm96ZW4tbGVmdC0ke2NvbHVtbi5pZHh9YF0gPSBgJHtjb2x1bW5NZXRyaWNzJDEuZ2V0KGNvbHVtbikubGVmdH1weGA7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR0ZW1wbGF0ZUNvbHVtbnM6IHRlbXBsYXRlQ29sdW1ucyQxLFxuXHRcdFx0bGF5b3V0Q3NzVmFyczogbGF5b3V0Q3NzVmFycyQxLFxuXHRcdFx0dG90YWxGcm96ZW5Db2x1bW5XaWR0aDogdG90YWxGcm96ZW5Db2x1bW5XaWR0aCQxLFxuXHRcdFx0Y29sdW1uTWV0cmljczogY29sdW1uTWV0cmljcyQxXG5cdFx0fTtcblx0fSwgW1xuXHRcdGdldENvbHVtbldpZHRoLFxuXHRcdGNvbHVtbnMsXG5cdFx0bGFzdEZyb3plbkNvbHVtbkluZGV4XG5cdF0pO1xuXHRjb25zdCBbY29sT3ZlcnNjYW5TdGFydElkeCwgY29sT3ZlcnNjYW5FbmRJZHhdID0gdXNlTWVtbygoKSA9PiB7XG5cdFx0aWYgKCFlbmFibGVWaXJ0dWFsaXphdGlvbikgcmV0dXJuIFswLCBjb2x1bW5zLmxlbmd0aCAtIDFdO1xuXHRcdGNvbnN0IHZpZXdwb3J0TGVmdCA9IHNjcm9sbExlZnQgKyB0b3RhbEZyb3plbkNvbHVtbldpZHRoO1xuXHRcdGNvbnN0IHZpZXdwb3J0UmlnaHQgPSBzY3JvbGxMZWZ0ICsgdmlld3BvcnRXaWR0aDtcblx0XHRjb25zdCBsYXN0Q29sSWR4ID0gY29sdW1ucy5sZW5ndGggLSAxO1xuXHRcdGNvbnN0IGZpcnN0VW5mcm96ZW5Db2x1bW5JZHggPSBtaW4obGFzdEZyb3plbkNvbHVtbkluZGV4ICsgMSwgbGFzdENvbElkeCk7XG5cdFx0aWYgKHZpZXdwb3J0TGVmdCA+PSB2aWV3cG9ydFJpZ2h0KSByZXR1cm4gW2ZpcnN0VW5mcm96ZW5Db2x1bW5JZHgsIGZpcnN0VW5mcm96ZW5Db2x1bW5JZHhdO1xuXHRcdGxldCBjb2xWaXNpYmxlU3RhcnRJZHggPSBmaXJzdFVuZnJvemVuQ29sdW1uSWR4O1xuXHRcdHdoaWxlIChjb2xWaXNpYmxlU3RhcnRJZHggPCBsYXN0Q29sSWR4KSB7XG5cdFx0XHRjb25zdCB7IGxlZnQsIHdpZHRoIH0gPSBjb2x1bW5NZXRyaWNzLmdldChjb2x1bW5zW2NvbFZpc2libGVTdGFydElkeF0pO1xuXHRcdFx0aWYgKGxlZnQgKyB3aWR0aCA+IHZpZXdwb3J0TGVmdCkgYnJlYWs7XG5cdFx0XHRjb2xWaXNpYmxlU3RhcnRJZHgrKztcblx0XHR9XG5cdFx0bGV0IGNvbFZpc2libGVFbmRJZHggPSBjb2xWaXNpYmxlU3RhcnRJZHg7XG5cdFx0d2hpbGUgKGNvbFZpc2libGVFbmRJZHggPCBsYXN0Q29sSWR4KSB7XG5cdFx0XHRjb25zdCB7IGxlZnQsIHdpZHRoIH0gPSBjb2x1bW5NZXRyaWNzLmdldChjb2x1bW5zW2NvbFZpc2libGVFbmRJZHhdKTtcblx0XHRcdGlmIChsZWZ0ICsgd2lkdGggPj0gdmlld3BvcnRSaWdodCkgYnJlYWs7XG5cdFx0XHRjb2xWaXNpYmxlRW5kSWR4Kys7XG5cdFx0fVxuXHRcdHJldHVybiBbbWF4KGZpcnN0VW5mcm96ZW5Db2x1bW5JZHgsIGNvbFZpc2libGVTdGFydElkeCAtIDEpLCBtaW4obGFzdENvbElkeCwgY29sVmlzaWJsZUVuZElkeCArIDEpXTtcblx0fSwgW1xuXHRcdGNvbHVtbk1ldHJpY3MsXG5cdFx0Y29sdW1ucyxcblx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0c2Nyb2xsTGVmdCxcblx0XHR0b3RhbEZyb3plbkNvbHVtbldpZHRoLFxuXHRcdHZpZXdwb3J0V2lkdGgsXG5cdFx0ZW5hYmxlVmlydHVhbGl6YXRpb25cblx0XSk7XG5cdHJldHVybiB7XG5cdFx0Y29sdW1ucyxcblx0XHRjb2xTcGFuQ29sdW1ucyxcblx0XHRjb2xPdmVyc2NhblN0YXJ0SWR4LFxuXHRcdGNvbE92ZXJzY2FuRW5kSWR4LFxuXHRcdHRlbXBsYXRlQ29sdW1ucyxcblx0XHRsYXlvdXRDc3NWYXJzLFxuXHRcdGhlYWRlclJvd3NDb3VudCxcblx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0dG90YWxGcm96ZW5Db2x1bW5XaWR0aFxuXHR9O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29sdW1uUGFyZW50KGNvbHVtbiwgaW5kZXgsIGxldmVsKSB7XG5cdGlmIChsZXZlbCA8IGNvbHVtbi5sZXZlbCkgY29sdW1uLmxldmVsID0gbGV2ZWw7XG5cdGlmIChjb2x1bW4ucGFyZW50ICE9PSB2b2lkIDApIHtcblx0XHRjb25zdCB7IHBhcmVudCB9ID0gY29sdW1uO1xuXHRcdGlmIChwYXJlbnQuaWR4ID09PSAtMSkgcGFyZW50LmlkeCA9IGluZGV4O1xuXHRcdHBhcmVudC5jb2xTcGFuICs9IDE7XG5cdFx0dXBkYXRlQ29sdW1uUGFyZW50KHBhcmVudCwgaW5kZXgsIGxldmVsIC0gMSk7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2hvb2tzL3VzZUNvbHVtbldpZHRocy50c1xuZnVuY3Rpb24gdXNlQ29sdW1uV2lkdGhzKGNvbHVtbnMsIHZpZXdwb3J0Q29sdW1ucywgdGVtcGxhdGVDb2x1bW5zLCBncmlkUmVmLCBncmlkV2lkdGgsIGNvbHVtbldpZHRocywgb25Db2x1bW5XaWR0aHNDaGFuZ2UsIG9uQ29sdW1uUmVzaXplLCBzZXRDb2x1bW5SZXNpemluZykge1xuXHRjb25zdCBbY29sdW1uVG9BdXRvUmVzaXplLCBzZXRDb2x1bW5Ub0F1dG9SZXNpemVdID0gdXNlU3RhdGUobnVsbCk7XG5cdGNvbnN0IFtjb2x1bW5zVG9NZWFzdXJlT25SZXNpemUsIHNldENvbHVtbnNUb01lYXN1cmVPblJlc2l6ZV0gPSB1c2VTdGF0ZShudWxsKTtcblx0Y29uc3QgW3ByZXZHcmlkV2lkdGgsIHNldFByZXZpb3VzR3JpZFdpZHRoXSA9IHVzZVN0YXRlKGdyaWRXaWR0aCk7XG5cdGNvbnN0IGNvbHVtbnNDYW5GbGV4ID0gY29sdW1ucy5sZW5ndGggPT09IHZpZXdwb3J0Q29sdW1ucy5sZW5ndGg7XG5cdGNvbnN0IGlnbm9yZVByZXZpb3VzbHlNZWFzdXJlZENvbHVtbnNPbkdyaWRXaWR0aENoYW5nZSA9IGNvbHVtbnNDYW5GbGV4ICYmIGdyaWRXaWR0aCAhPT0gcHJldkdyaWRXaWR0aDtcblx0Y29uc3QgbmV3VGVtcGxhdGVDb2x1bW5zID0gWy4uLnRlbXBsYXRlQ29sdW1uc107XG5cdGNvbnN0IGNvbHVtbnNUb01lYXN1cmUgPSBbXTtcblx0Zm9yIChjb25zdCB7IGtleSwgaWR4LCB3aWR0aCB9IG9mIHZpZXdwb3J0Q29sdW1ucykge1xuXHRcdGNvbnN0IGNvbHVtbldpZHRoID0gY29sdW1uV2lkdGhzLmdldChrZXkpO1xuXHRcdGlmIChrZXkgPT09IGNvbHVtblRvQXV0b1Jlc2l6ZT8ua2V5KSB7XG5cdFx0XHRuZXdUZW1wbGF0ZUNvbHVtbnNbaWR4XSA9IGNvbHVtblRvQXV0b1Jlc2l6ZS53aWR0aCA9PT0gXCJtYXgtY29udGVudFwiID8gY29sdW1uVG9BdXRvUmVzaXplLndpZHRoIDogYCR7Y29sdW1uVG9BdXRvUmVzaXplLndpZHRofXB4YDtcblx0XHRcdGNvbHVtbnNUb01lYXN1cmUucHVzaChrZXkpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHdpZHRoID09PSBcInN0cmluZ1wiICYmIGNvbHVtbldpZHRoPy50eXBlICE9PSBcInJlc2l6ZWRcIiAmJiAoaWdub3JlUHJldmlvdXNseU1lYXN1cmVkQ29sdW1uc09uR3JpZFdpZHRoQ2hhbmdlIHx8IGNvbHVtbnNUb01lYXN1cmVPblJlc2l6ZT8uaGFzKGtleSkgPT09IHRydWUgfHwgY29sdW1uV2lkdGggPT09IHZvaWQgMCkpIHtcblx0XHRcdG5ld1RlbXBsYXRlQ29sdW1uc1tpZHhdID0gd2lkdGg7XG5cdFx0XHRjb2x1bW5zVG9NZWFzdXJlLnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblx0Y29uc3QgZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IG5ld1RlbXBsYXRlQ29sdW1ucy5qb2luKFwiIFwiKTtcblx0dXNlTGF5b3V0RWZmZWN0KHVwZGF0ZU1lYXN1cmVkQW5kUmVzaXplZFdpZHRocyk7XG5cdGZ1bmN0aW9uIHVwZGF0ZU1lYXN1cmVkQW5kUmVzaXplZFdpZHRocygpIHtcblx0XHRzZXRQcmV2aW91c0dyaWRXaWR0aChncmlkV2lkdGgpO1xuXHRcdGlmIChjb2x1bW5zVG9NZWFzdXJlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXHRcdGNvbnN0IG5ld0NvbHVtbldpZHRocyA9IG5ldyBNYXAoY29sdW1uV2lkdGhzKTtcblx0XHRsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuXHRcdGZvciAoY29uc3Qga2V5IG9mIGNvbHVtbnNUb01lYXN1cmUpIHtcblx0XHRcdGNvbnN0IG1lYXN1cmVkV2lkdGggPSBtZWFzdXJlQ29sdW1uV2lkdGgoZ3JpZFJlZiwga2V5KTtcblx0XHRcdGhhc0NoYW5nZXMgfHw9IG1lYXN1cmVkV2lkdGggIT09IGNvbHVtbldpZHRocy5nZXQoa2V5KT8ud2lkdGg7XG5cdFx0XHRpZiAobWVhc3VyZWRXaWR0aCA9PT0gdm9pZCAwKSBuZXdDb2x1bW5XaWR0aHMuZGVsZXRlKGtleSk7XG5cdFx0XHRlbHNlIG5ld0NvbHVtbldpZHRocy5zZXQoa2V5LCB7XG5cdFx0XHRcdHR5cGU6IFwibWVhc3VyZWRcIixcblx0XHRcdFx0d2lkdGg6IG1lYXN1cmVkV2lkdGhcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoY29sdW1uVG9BdXRvUmVzaXplICE9PSBudWxsKSB7XG5cdFx0XHRjb25zdCByZXNpemluZ0tleSA9IGNvbHVtblRvQXV0b1Jlc2l6ZS5rZXk7XG5cdFx0XHRjb25zdCBvbGRXaWR0aCA9IGNvbHVtbldpZHRocy5nZXQocmVzaXppbmdLZXkpPy53aWR0aDtcblx0XHRcdGNvbnN0IG5ld1dpZHRoID0gbWVhc3VyZUNvbHVtbldpZHRoKGdyaWRSZWYsIHJlc2l6aW5nS2V5KTtcblx0XHRcdGlmIChuZXdXaWR0aCAhPT0gdm9pZCAwICYmIG9sZFdpZHRoICE9PSBuZXdXaWR0aCkge1xuXHRcdFx0XHRoYXNDaGFuZ2VzID0gdHJ1ZTtcblx0XHRcdFx0bmV3Q29sdW1uV2lkdGhzLnNldChyZXNpemluZ0tleSwge1xuXHRcdFx0XHRcdHR5cGU6IFwicmVzaXplZFwiLFxuXHRcdFx0XHRcdHdpZHRoOiBuZXdXaWR0aFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHNldENvbHVtblRvQXV0b1Jlc2l6ZShudWxsKTtcblx0XHR9XG5cdFx0aWYgKGhhc0NoYW5nZXMpIG9uQ29sdW1uV2lkdGhzQ2hhbmdlKG5ld0NvbHVtbldpZHRocyk7XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlQ29sdW1uUmVzaXplKGNvbHVtbiwgbmV4dFdpZHRoKSB7XG5cdFx0Y29uc3QgeyBrZXk6IHJlc2l6aW5nS2V5IH0gPSBjb2x1bW47XG5cdFx0Zmx1c2hTeW5jKCgpID0+IHtcblx0XHRcdGlmIChjb2x1bW5zQ2FuRmxleCkge1xuXHRcdFx0XHRjb25zdCBjb2x1bW5zVG9SZW1lYXN1cmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHsga2V5LCB3aWR0aCB9IG9mIHZpZXdwb3J0Q29sdW1ucykgaWYgKHJlc2l6aW5nS2V5ICE9PSBrZXkgJiYgdHlwZW9mIHdpZHRoID09PSBcInN0cmluZ1wiICYmIGNvbHVtbldpZHRocy5nZXQoa2V5KT8udHlwZSAhPT0gXCJyZXNpemVkXCIpIGNvbHVtbnNUb1JlbWVhc3VyZS5hZGQoa2V5KTtcblx0XHRcdFx0c2V0Q29sdW1uc1RvTWVhc3VyZU9uUmVzaXplKGNvbHVtbnNUb1JlbWVhc3VyZSk7XG5cdFx0XHR9XG5cdFx0XHRzZXRDb2x1bW5Ub0F1dG9SZXNpemUoe1xuXHRcdFx0XHRrZXk6IHJlc2l6aW5nS2V5LFxuXHRcdFx0XHR3aWR0aDogbmV4dFdpZHRoXG5cdFx0XHR9KTtcblx0XHRcdHNldENvbHVtblJlc2l6aW5nKHR5cGVvZiBuZXh0V2lkdGggPT09IFwibnVtYmVyXCIpO1xuXHRcdH0pO1xuXHRcdHNldENvbHVtbnNUb01lYXN1cmVPblJlc2l6ZShudWxsKTtcblx0XHRpZiAob25Db2x1bW5SZXNpemUpIHtcblx0XHRcdGNvbnN0IHByZXZpb3VzV2lkdGggPSBjb2x1bW5XaWR0aHMuZ2V0KHJlc2l6aW5nS2V5KT8ud2lkdGg7XG5cdFx0XHRjb25zdCBuZXdXaWR0aCA9IHR5cGVvZiBuZXh0V2lkdGggPT09IFwibnVtYmVyXCIgPyBuZXh0V2lkdGggOiBtZWFzdXJlQ29sdW1uV2lkdGgoZ3JpZFJlZiwgcmVzaXppbmdLZXkpO1xuXHRcdFx0aWYgKG5ld1dpZHRoICE9PSB2b2lkIDAgJiYgbmV3V2lkdGggIT09IHByZXZpb3VzV2lkdGgpIG9uQ29sdW1uUmVzaXplKGNvbHVtbiwgbmV3V2lkdGgpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4ge1xuXHRcdGdyaWRUZW1wbGF0ZUNvbHVtbnMsXG5cdFx0aGFuZGxlQ29sdW1uUmVzaXplXG5cdH07XG59XG5mdW5jdGlvbiBtZWFzdXJlQ29sdW1uV2lkdGgoZ3JpZFJlZiwga2V5KSB7XG5cdGNvbnN0IHNlbGVjdG9yID0gYFtkYXRhLW1lYXN1cmluZy1jZWxsLWtleT1cIiR7Q1NTLmVzY2FwZShrZXkpfVwiXWA7XG5cdHJldHVybiAoZ3JpZFJlZi5jdXJyZW50Py5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSk/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvaG9va3MvdXNlR3JpZERpbWVuc2lvbnMudHNcbmZ1bmN0aW9uIHVzZUdyaWREaW1lbnNpb25zKCkge1xuXHRjb25zdCBncmlkUmVmID0gdXNlUmVmKG51bGwpO1xuXHRjb25zdCBbaW5saW5lU2l6ZSwgc2V0SW5saW5lU2l6ZV0gPSB1c2VTdGF0ZSgxKTtcblx0Y29uc3QgW2Jsb2NrU2l6ZSwgc2V0QmxvY2tTaXplXSA9IHVzZVN0YXRlKDEpO1xuXHRjb25zdCBbaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCwgc2V0SG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodF0gPSB1c2VTdGF0ZSgwKTtcblx0dXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcblx0XHRjb25zdCB7IFJlc2l6ZU9ic2VydmVyIH0gPSB3aW5kb3c7XG5cdFx0aWYgKFJlc2l6ZU9ic2VydmVyID09IG51bGwpIHJldHVybjtcblx0XHRjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQsIG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IGdyaWRSZWYuY3VycmVudDtcblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdyaWRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCBpbml0aWFsSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCA9IG9mZnNldEhlaWdodCAtIGNsaWVudEhlaWdodDtcblx0XHRjb25zdCBpbml0aWFsV2lkdGggPSB3aWR0aCAtIG9mZnNldFdpZHRoICsgY2xpZW50V2lkdGg7XG5cdFx0Y29uc3QgaW5pdGlhbEhlaWdodCA9IGhlaWdodCAtIGluaXRpYWxIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0O1xuXHRcdHNldElubGluZVNpemUoaW5pdGlhbFdpZHRoKTtcblx0XHRzZXRCbG9ja1NpemUoaW5pdGlhbEhlaWdodCk7XG5cdFx0c2V0SG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodChpbml0aWFsSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCk7XG5cdFx0Y29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcblx0XHRcdGNvbnN0IHNpemUgPSBlbnRyaWVzWzBdLmNvbnRlbnRCb3hTaXplWzBdO1xuXHRcdFx0Y29uc3QgeyBjbGllbnRIZWlnaHQ6IGNsaWVudEhlaWdodCQxLCBvZmZzZXRIZWlnaHQ6IG9mZnNldEhlaWdodCQxIH0gPSBncmlkUmVmLmN1cnJlbnQ7XG5cdFx0XHRmbHVzaFN5bmMoKCkgPT4ge1xuXHRcdFx0XHRzZXRJbmxpbmVTaXplKHNpemUuaW5saW5lU2l6ZSk7XG5cdFx0XHRcdHNldEJsb2NrU2l6ZShzaXplLmJsb2NrU2l6ZSk7XG5cdFx0XHRcdHNldEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQob2Zmc2V0SGVpZ2h0JDEgLSBjbGllbnRIZWlnaHQkMSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRyZXNpemVPYnNlcnZlci5vYnNlcnZlKGdyaWRSZWYuY3VycmVudCk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0XHR9O1xuXHR9LCBbXSk7XG5cdHJldHVybiBbXG5cdFx0Z3JpZFJlZixcblx0XHRpbmxpbmVTaXplLFxuXHRcdGJsb2NrU2l6ZSxcblx0XHRob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XG5cdF07XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9ob29rcy91c2VMYXRlc3RGdW5jLnRzXG5mdW5jdGlvbiB1c2VMYXRlc3RGdW5jKGZuKSB7XG5cdGNvbnN0IHJlZiA9IHVzZVJlZihmbik7XG5cdHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cdFx0cmVmLmN1cnJlbnQgPSBmbjtcblx0fSk7XG5cdGNvbnN0IGNhbGxiYWNrRm4gPSB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4ge1xuXHRcdHJlZi5jdXJyZW50KC4uLmFyZ3MpO1xuXHR9LCBbXSk7XG5cdHJldHVybiBmbiA/IGNhbGxiYWNrRm4gOiBmbjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2hvb2tzL3VzZVJvdmluZ1RhYkluZGV4LnRzXG5mdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleChpc1NlbGVjdGVkKSB7XG5cdGNvbnN0IFtpc0NoaWxkRm9jdXNlZCwgc2V0SXNDaGlsZEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXHRpZiAoaXNDaGlsZEZvY3VzZWQgJiYgIWlzU2VsZWN0ZWQpIHNldElzQ2hpbGRGb2N1c2VkKGZhbHNlKTtcblx0ZnVuY3Rpb24gb25Gb2N1cyhldmVudCkge1xuXHRcdGlmIChldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcblx0XHRcdGNvbnN0IGVsZW1lbnRUb0ZvY3VzID0gZXZlbnQuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKFwiW3RhYmluZGV4PVxcXCIwXFxcIl1cIik7XG5cdFx0XHRpZiAoZWxlbWVudFRvRm9jdXMgIT09IG51bGwpIHtcblx0XHRcdFx0ZWxlbWVudFRvRm9jdXMuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuXHRcdFx0XHRzZXRJc0NoaWxkRm9jdXNlZCh0cnVlKTtcblx0XHRcdH0gZWxzZSBzZXRJc0NoaWxkRm9jdXNlZChmYWxzZSk7XG5cdFx0fSBlbHNlIHNldElzQ2hpbGRGb2N1c2VkKHRydWUpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0dGFiSW5kZXg6IGlzU2VsZWN0ZWQgJiYgIWlzQ2hpbGRGb2N1c2VkID8gMCA6IC0xLFxuXHRcdGNoaWxkVGFiSW5kZXg6IGlzU2VsZWN0ZWQgPyAwIDogLTEsXG5cdFx0b25Gb2N1czogaXNTZWxlY3RlZCA/IG9uRm9jdXMgOiB2b2lkIDBcblx0fTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2hvb2tzL3VzZVZpZXdwb3J0Q29sdW1ucy50c1xuZnVuY3Rpb24gdXNlVmlld3BvcnRDb2x1bW5zKHsgY29sdW1ucywgY29sU3BhbkNvbHVtbnMsIHJvd3MsIHRvcFN1bW1hcnlSb3dzLCBib3R0b21TdW1tYXJ5Um93cywgY29sT3ZlcnNjYW5TdGFydElkeCwgY29sT3ZlcnNjYW5FbmRJZHgsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgcm93T3ZlcnNjYW5TdGFydElkeCwgcm93T3ZlcnNjYW5FbmRJZHggfSkge1xuXHRjb25zdCBzdGFydElkeCA9IHVzZU1lbW8oKCkgPT4ge1xuXHRcdGlmIChjb2xPdmVyc2NhblN0YXJ0SWR4ID09PSAwKSByZXR1cm4gMDtcblx0XHRsZXQgc3RhcnRJZHgkMSA9IGNvbE92ZXJzY2FuU3RhcnRJZHg7XG5cdFx0Y29uc3QgdXBkYXRlU3RhcnRJZHggPSAoY29sSWR4LCBjb2xTcGFuKSA9PiB7XG5cdFx0XHRpZiAoY29sU3BhbiAhPT0gdm9pZCAwICYmIGNvbElkeCArIGNvbFNwYW4gPiBjb2xPdmVyc2NhblN0YXJ0SWR4KSB7XG5cdFx0XHRcdHN0YXJ0SWR4JDEgPSBjb2xJZHg7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdFx0Zm9yIChjb25zdCBjb2x1bW4gb2YgY29sU3BhbkNvbHVtbnMpIHtcblx0XHRcdGNvbnN0IGNvbElkeCA9IGNvbHVtbi5pZHg7XG5cdFx0XHRpZiAoY29sSWR4ID49IHN0YXJ0SWR4JDEpIGJyZWFrO1xuXHRcdFx0aWYgKHVwZGF0ZVN0YXJ0SWR4KGNvbElkeCwgZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgeyB0eXBlOiBcIkhFQURFUlwiIH0pKSkgYnJlYWs7XG5cdFx0XHRmb3IgKGxldCByb3dJZHggPSByb3dPdmVyc2NhblN0YXJ0SWR4OyByb3dJZHggPD0gcm93T3ZlcnNjYW5FbmRJZHg7IHJvd0lkeCsrKSB7XG5cdFx0XHRcdGNvbnN0IHJvdyQxID0gcm93c1tyb3dJZHhdO1xuXHRcdFx0XHRpZiAodXBkYXRlU3RhcnRJZHgoY29sSWR4LCBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG5cdFx0XHRcdFx0dHlwZTogXCJST1dcIixcblx0XHRcdFx0XHRyb3c6IHJvdyQxXG5cdFx0XHRcdH0pKSkgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAodG9wU3VtbWFyeVJvd3MgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IHJvdyQxIG9mIHRvcFN1bW1hcnlSb3dzKSBpZiAodXBkYXRlU3RhcnRJZHgoY29sSWR4LCBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG5cdFx0XHRcdFx0dHlwZTogXCJTVU1NQVJZXCIsXG5cdFx0XHRcdFx0cm93OiByb3ckMVxuXHRcdFx0XHR9KSkpIGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGJvdHRvbVN1bW1hcnlSb3dzICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yIChjb25zdCByb3ckMSBvZiBib3R0b21TdW1tYXJ5Um93cykgaWYgKHVwZGF0ZVN0YXJ0SWR4KGNvbElkeCwgZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwge1xuXHRcdFx0XHRcdHR5cGU6IFwiU1VNTUFSWVwiLFxuXHRcdFx0XHRcdHJvdzogcm93JDFcblx0XHRcdFx0fSkpKSBicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHN0YXJ0SWR4JDE7XG5cdH0sIFtcblx0XHRyb3dPdmVyc2NhblN0YXJ0SWR4LFxuXHRcdHJvd092ZXJzY2FuRW5kSWR4LFxuXHRcdHJvd3MsXG5cdFx0dG9wU3VtbWFyeVJvd3MsXG5cdFx0Ym90dG9tU3VtbWFyeVJvd3MsXG5cdFx0Y29sT3ZlcnNjYW5TdGFydElkeCxcblx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0Y29sU3BhbkNvbHVtbnNcblx0XSk7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IHtcblx0XHRjb25zdCB2aWV3cG9ydENvbHVtbnMgPSBbXTtcblx0XHRmb3IgKGxldCBjb2xJZHggPSAwOyBjb2xJZHggPD0gY29sT3ZlcnNjYW5FbmRJZHg7IGNvbElkeCsrKSB7XG5cdFx0XHRjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2NvbElkeF07XG5cdFx0XHRpZiAoY29sSWR4IDwgc3RhcnRJZHggJiYgIWNvbHVtbi5mcm96ZW4pIGNvbnRpbnVlO1xuXHRcdFx0dmlld3BvcnRDb2x1bW5zLnB1c2goY29sdW1uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZpZXdwb3J0Q29sdW1ucztcblx0fSwgW1xuXHRcdHN0YXJ0SWR4LFxuXHRcdGNvbE92ZXJzY2FuRW5kSWR4LFxuXHRcdGNvbHVtbnNcblx0XSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9ob29rcy91c2VWaWV3cG9ydFJvd3MudHNcbmZ1bmN0aW9uIHVzZVZpZXdwb3J0Um93cyh7IHJvd3MsIHJvd0hlaWdodCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxUb3AsIGVuYWJsZVZpcnR1YWxpemF0aW9uIH0pIHtcblx0Y29uc3QgeyB0b3RhbFJvd0hlaWdodCwgZ3JpZFRlbXBsYXRlUm93cywgZ2V0Um93VG9wLCBnZXRSb3dIZWlnaHQsIGZpbmRSb3dJZHggfSA9IHVzZU1lbW8oKCkgPT4ge1xuXHRcdGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuXHRcdFx0dG90YWxSb3dIZWlnaHQ6IHJvd0hlaWdodCAqIHJvd3MubGVuZ3RoLFxuXHRcdFx0Z3JpZFRlbXBsYXRlUm93czogYCByZXBlYXQoJHtyb3dzLmxlbmd0aH0sICR7cm93SGVpZ2h0fXB4KWAsXG5cdFx0XHRnZXRSb3dUb3A6IChyb3dJZHgpID0+IHJvd0lkeCAqIHJvd0hlaWdodCxcblx0XHRcdGdldFJvd0hlaWdodDogKCkgPT4gcm93SGVpZ2h0LFxuXHRcdFx0ZmluZFJvd0lkeDogKG9mZnNldCkgPT4gZmxvb3Iob2Zmc2V0IC8gcm93SGVpZ2h0KVxuXHRcdH07XG5cdFx0bGV0IHRvdGFsUm93SGVpZ2h0JDEgPSAwO1xuXHRcdGxldCBncmlkVGVtcGxhdGVSb3dzJDEgPSBcIlwiO1xuXHRcdGxldCBjdXJyZW50SGVpZ2h0ID0gbnVsbDtcblx0XHRsZXQgcmVwZWF0Q291bnQgPSAwO1xuXHRcdGNvbnN0IHJvd1Bvc2l0aW9ucyA9IHJvd3MubWFwKChyb3ckMSwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IGN1cnJlbnRSb3dIZWlnaHQgPSByb3dIZWlnaHQocm93JDEpO1xuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSB7XG5cdFx0XHRcdHRvcDogdG90YWxSb3dIZWlnaHQkMSxcblx0XHRcdFx0aGVpZ2h0OiBjdXJyZW50Um93SGVpZ2h0XG5cdFx0XHR9O1xuXHRcdFx0dG90YWxSb3dIZWlnaHQkMSArPSBjdXJyZW50Um93SGVpZ2h0O1xuXHRcdFx0aWYgKGN1cnJlbnRIZWlnaHQgPT09IG51bGwpIHtcblx0XHRcdFx0Y3VycmVudEhlaWdodCA9IGN1cnJlbnRSb3dIZWlnaHQ7XG5cdFx0XHRcdHJlcGVhdENvdW50ID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoY3VycmVudEhlaWdodCA9PT0gY3VycmVudFJvd0hlaWdodCkgcmVwZWF0Q291bnQrKztcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocmVwZWF0Q291bnQgPiAxKSBncmlkVGVtcGxhdGVSb3dzJDEgKz0gYHJlcGVhdCgke3JlcGVhdENvdW50fSwgJHtjdXJyZW50SGVpZ2h0fXB4KSBgO1xuXHRcdFx0XHRlbHNlIGdyaWRUZW1wbGF0ZVJvd3MkMSArPSBgJHtjdXJyZW50SGVpZ2h0fXB4IGA7XG5cdFx0XHRcdGN1cnJlbnRIZWlnaHQgPSBjdXJyZW50Um93SGVpZ2h0O1xuXHRcdFx0XHRyZXBlYXRDb3VudCA9IDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5kZXggPT09IHJvd3MubGVuZ3RoIC0gMSkgaWYgKHJlcGVhdENvdW50ID4gMSkgZ3JpZFRlbXBsYXRlUm93cyQxICs9IGByZXBlYXQoJHtyZXBlYXRDb3VudH0sICR7Y3VycmVudEhlaWdodH1weClgO1xuXHRcdFx0ZWxzZSBncmlkVGVtcGxhdGVSb3dzJDEgKz0gYCR7Y3VycmVudEhlaWdodH1weGA7XG5cdFx0XHRyZXR1cm4gcG9zaXRpb247XG5cdFx0fSk7XG5cdFx0Y29uc3QgdmFsaWRhdGVSb3dJZHggPSAocm93SWR4KSA9PiB7XG5cdFx0XHRyZXR1cm4gbWF4KDAsIG1pbihyb3dzLmxlbmd0aCAtIDEsIHJvd0lkeCkpO1xuXHRcdH07XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvdGFsUm93SGVpZ2h0OiB0b3RhbFJvd0hlaWdodCQxLFxuXHRcdFx0Z3JpZFRlbXBsYXRlUm93czogZ3JpZFRlbXBsYXRlUm93cyQxLFxuXHRcdFx0Z2V0Um93VG9wOiAocm93SWR4KSA9PiByb3dQb3NpdGlvbnNbdmFsaWRhdGVSb3dJZHgocm93SWR4KV0udG9wLFxuXHRcdFx0Z2V0Um93SGVpZ2h0OiAocm93SWR4KSA9PiByb3dQb3NpdGlvbnNbdmFsaWRhdGVSb3dJZHgocm93SWR4KV0uaGVpZ2h0LFxuXHRcdFx0ZmluZFJvd0lkeChvZmZzZXQpIHtcblx0XHRcdFx0bGV0IHN0YXJ0ID0gMDtcblx0XHRcdFx0bGV0IGVuZCA9IHJvd1Bvc2l0aW9ucy5sZW5ndGggLSAxO1xuXHRcdFx0XHR3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG5cdFx0XHRcdFx0Y29uc3QgbWlkZGxlID0gc3RhcnQgKyBmbG9vcigoZW5kIC0gc3RhcnQpIC8gMik7XG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudE9mZnNldCA9IHJvd1Bvc2l0aW9uc1ttaWRkbGVdLnRvcDtcblx0XHRcdFx0XHRpZiAoY3VycmVudE9mZnNldCA9PT0gb2Zmc2V0KSByZXR1cm4gbWlkZGxlO1xuXHRcdFx0XHRcdGlmIChjdXJyZW50T2Zmc2V0IDwgb2Zmc2V0KSBzdGFydCA9IG1pZGRsZSArIDE7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoY3VycmVudE9mZnNldCA+IG9mZnNldCkgZW5kID0gbWlkZGxlIC0gMTtcblx0XHRcdFx0XHRpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBlbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSwgW3Jvd0hlaWdodCwgcm93c10pO1xuXHRsZXQgcm93T3ZlcnNjYW5TdGFydElkeCA9IDA7XG5cdGxldCByb3dPdmVyc2NhbkVuZElkeCA9IHJvd3MubGVuZ3RoIC0gMTtcblx0aWYgKGVuYWJsZVZpcnR1YWxpemF0aW9uKSB7XG5cdFx0Y29uc3Qgb3ZlcnNjYW5UaHJlc2hvbGQgPSA0O1xuXHRcdGNvbnN0IHJvd1Zpc2libGVTdGFydElkeCA9IGZpbmRSb3dJZHgoc2Nyb2xsVG9wKTtcblx0XHRjb25zdCByb3dWaXNpYmxlRW5kSWR4ID0gZmluZFJvd0lkeChzY3JvbGxUb3AgKyBjbGllbnRIZWlnaHQpO1xuXHRcdHJvd092ZXJzY2FuU3RhcnRJZHggPSBtYXgoMCwgcm93VmlzaWJsZVN0YXJ0SWR4IC0gb3ZlcnNjYW5UaHJlc2hvbGQpO1xuXHRcdHJvd092ZXJzY2FuRW5kSWR4ID0gbWluKHJvd3MubGVuZ3RoIC0gMSwgcm93VmlzaWJsZUVuZElkeCArIG92ZXJzY2FuVGhyZXNob2xkKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHJvd092ZXJzY2FuU3RhcnRJZHgsXG5cdFx0cm93T3ZlcnNjYW5FbmRJZHgsXG5cdFx0dG90YWxSb3dIZWlnaHQsXG5cdFx0Z3JpZFRlbXBsYXRlUm93cyxcblx0XHRnZXRSb3dUb3AsXG5cdFx0Z2V0Um93SGVpZ2h0LFxuXHRcdGZpbmRSb3dJZHhcblx0fTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL0NlbGwudHN4XG5jb25zdCBjZWxsRHJhZ2dlZE92ZXJDbGFzc25hbWUgPSBgcmRnLWNlbGwtZHJhZ2dlZC1vdmVyIHJkZy03LTAtMC1iZXRhLTU4LTM1Y2NiNGM4YDtcbmZ1bmN0aW9uIENlbGwoeyBjb2x1bW4sIGNvbFNwYW4sIGlzQ2VsbFNlbGVjdGVkLCBpc0RyYWdnZWRPdmVyLCByb3c6IHJvdyQxLCByb3dJZHgsIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uQ2VsbE1vdXNlRG93biwgb25DbGljaywgb25DZWxsQ2xpY2ssIG9uRG91YmxlQ2xpY2ssIG9uQ2VsbERvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51LCBvbkNlbGxDb250ZXh0TWVudSwgb25Sb3dDaGFuZ2UsIHNlbGVjdENlbGwsIHN0eWxlLCAuLi5wcm9wcyB9KSB7XG5cdGNvbnN0IHsgdGFiSW5kZXgsIGNoaWxkVGFiSW5kZXgsIG9uRm9jdXMgfSA9IHVzZVJvdmluZ1RhYkluZGV4KGlzQ2VsbFNlbGVjdGVkKTtcblx0Y29uc3QgeyBjZWxsQ2xhc3MgfSA9IGNvbHVtbjtcblx0Y2xhc3NOYW1lID0gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIHsgW2NlbGxEcmFnZ2VkT3ZlckNsYXNzbmFtZV06IGlzRHJhZ2dlZE92ZXIgfSwgdHlwZW9mIGNlbGxDbGFzcyA9PT0gXCJmdW5jdGlvblwiID8gY2VsbENsYXNzKHJvdyQxKSA6IGNlbGxDbGFzcywgY2xhc3NOYW1lKTtcblx0Y29uc3QgaXNFZGl0YWJsZSA9IGlzQ2VsbEVkaXRhYmxlVXRpbChjb2x1bW4sIHJvdyQxKTtcblx0ZnVuY3Rpb24gc2VsZWN0Q2VsbFdyYXBwZXIoZW5hYmxlRWRpdG9yKSB7XG5cdFx0c2VsZWN0Q2VsbCh7XG5cdFx0XHRyb3dJZHgsXG5cdFx0XHRpZHg6IGNvbHVtbi5pZHhcblx0XHR9LCB7IGVuYWJsZUVkaXRvciB9KTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZUV2ZW50KGV2ZW50LCBldmVudEhhbmRsZXIpIHtcblx0XHRsZXQgZXZlbnRIYW5kbGVkID0gZmFsc2U7XG5cdFx0aWYgKGV2ZW50SGFuZGxlcikge1xuXHRcdFx0Y29uc3QgY2VsbEV2ZW50ID0gY3JlYXRlQ2VsbEV2ZW50KGV2ZW50KTtcblx0XHRcdGV2ZW50SGFuZGxlcih7XG5cdFx0XHRcdHJvd0lkeCxcblx0XHRcdFx0cm93OiByb3ckMSxcblx0XHRcdFx0Y29sdW1uLFxuXHRcdFx0XHRzZWxlY3RDZWxsOiBzZWxlY3RDZWxsV3JhcHBlclxuXHRcdFx0fSwgY2VsbEV2ZW50KTtcblx0XHRcdGV2ZW50SGFuZGxlZCA9IGNlbGxFdmVudC5pc0dyaWREZWZhdWx0UHJldmVudGVkKCk7XG5cdFx0fVxuXHRcdHJldHVybiBldmVudEhhbmRsZWQ7XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG5cdFx0b25Nb3VzZURvd24/LihldmVudCk7XG5cdFx0aWYgKCFoYW5kbGVNb3VzZUV2ZW50KGV2ZW50LCBvbkNlbGxNb3VzZURvd24pKSBzZWxlY3RDZWxsV3JhcHBlcigpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG5cdFx0b25DbGljaz8uKGV2ZW50KTtcblx0XHRoYW5kbGVNb3VzZUV2ZW50KGV2ZW50LCBvbkNlbGxDbGljayk7XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2soZXZlbnQpIHtcblx0XHRvbkRvdWJsZUNsaWNrPy4oZXZlbnQpO1xuXHRcdGlmICghaGFuZGxlTW91c2VFdmVudChldmVudCwgb25DZWxsRG91YmxlQ2xpY2spKSBzZWxlY3RDZWxsV3JhcHBlcih0cnVlKTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVDb250ZXh0TWVudShldmVudCkge1xuXHRcdG9uQ29udGV4dE1lbnU/LihldmVudCk7XG5cdFx0aGFuZGxlTW91c2VFdmVudChldmVudCwgb25DZWxsQ29udGV4dE1lbnUpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZVJvd0NoYW5nZShuZXdSb3cpIHtcblx0XHRvblJvd0NoYW5nZShjb2x1bW4sIG5ld1Jvdyk7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwge1xuXHRcdHJvbGU6IFwiZ3JpZGNlbGxcIixcblx0XHRcImFyaWEtY29saW5kZXhcIjogY29sdW1uLmlkeCArIDEsXG5cdFx0XCJhcmlhLWNvbHNwYW5cIjogY29sU3Bhbixcblx0XHRcImFyaWEtc2VsZWN0ZWRcIjogaXNDZWxsU2VsZWN0ZWQsXG5cdFx0XCJhcmlhLXJlYWRvbmx5XCI6ICFpc0VkaXRhYmxlIHx8IHZvaWQgMCxcblx0XHR0YWJJbmRleCxcblx0XHRjbGFzc05hbWUsXG5cdFx0c3R5bGU6IHtcblx0XHRcdC4uLmdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pLFxuXHRcdFx0Li4uc3R5bGVcblx0XHR9LFxuXHRcdG9uQ2xpY2s6IGhhbmRsZUNsaWNrLFxuXHRcdG9uTW91c2VEb3duOiBoYW5kbGVNb3VzZURvd24sXG5cdFx0b25Eb3VibGVDbGljazogaGFuZGxlRG91YmxlQ2xpY2ssXG5cdFx0b25Db250ZXh0TWVudTogaGFuZGxlQ29udGV4dE1lbnUsXG5cdFx0b25Gb2N1cyxcblx0XHQuLi5wcm9wcyxcblx0XHRjaGlsZHJlbjogY29sdW1uLnJlbmRlckNlbGwoe1xuXHRcdFx0Y29sdW1uLFxuXHRcdFx0cm93OiByb3ckMSxcblx0XHRcdHJvd0lkeCxcblx0XHRcdGlzQ2VsbEVkaXRhYmxlOiBpc0VkaXRhYmxlLFxuXHRcdFx0dGFiSW5kZXg6IGNoaWxkVGFiSW5kZXgsXG5cdFx0XHRvblJvd0NoYW5nZTogaGFuZGxlUm93Q2hhbmdlXG5cdFx0fSlcblx0fSk7XG59XG5jb25zdCBDZWxsQ29tcG9uZW50ID0gbWVtbyhDZWxsKTtcbnZhciBDZWxsX2RlZmF1bHQgPSBDZWxsQ29tcG9uZW50O1xuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNlbGwoa2V5LCBwcm9wcykge1xuXHRyZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDZWxsQ29tcG9uZW50LCB7IC4uLnByb3BzIH0sIGtleSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9FZGl0Q2VsbC50c3hcbmNvbnN0IGNhblVzZVBvc3RUYXNrID0gdHlwZW9mIHNjaGVkdWxlciA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc2NoZWR1bGVyLnBvc3RUYXNrID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBjZWxsRWRpdGluZyA9IFwicmRnLTctMC0wLWJldGEtNTgtNDZmOWVhODhcIjtcbmZ1bmN0aW9uIEVkaXRDZWxsKHsgY29sdW1uLCBjb2xTcGFuLCByb3c6IHJvdyQxLCByb3dJZHgsIG9uUm93Q2hhbmdlLCBjbG9zZUVkaXRvciwgb25LZXlEb3duLCBuYXZpZ2F0ZSB9KSB7XG5cdGNvbnN0IGNhcHR1cmVFdmVudFJlZiA9IHVzZVJlZih2b2lkIDApO1xuXHRjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWYodm9pZCAwKTtcblx0Y29uc3QgZnJhbWVSZXF1ZXN0UmVmID0gdXNlUmVmKHZvaWQgMCk7XG5cdGNvbnN0IGNvbW1pdE9uT3V0c2lkZUNsaWNrID0gY29sdW1uLmVkaXRvck9wdGlvbnM/LmNvbW1pdE9uT3V0c2lkZUNsaWNrID8/IHRydWU7XG5cdGNvbnN0IGNvbW1pdE9uT3V0c2lkZU1vdXNlRG93biA9IHVzZUVmZmVjdEV2ZW50KCgpID0+IHtcblx0XHRvbkNsb3NlKHRydWUsIGZhbHNlKTtcblx0fSk7XG5cdHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKCFjb21taXRPbk91dHNpZGVDbGljaykgcmV0dXJuO1xuXHRcdGZ1bmN0aW9uIG9uV2luZG93Q2FwdHVyZU1vdXNlRG93bihldmVudCkge1xuXHRcdFx0Y2FwdHVyZUV2ZW50UmVmLmN1cnJlbnQgPSBldmVudDtcblx0XHRcdGlmIChjYW5Vc2VQb3N0VGFzaykge1xuXHRcdFx0XHRjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cdFx0XHRcdGNvbnN0IHsgc2lnbmFsIH0gPSBhYm9ydENvbnRyb2xsZXI7XG5cdFx0XHRcdGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuXHRcdFx0XHRzY2hlZHVsZXIucG9zdFRhc2soY29tbWl0T25PdXRzaWRlTW91c2VEb3duLCB7XG5cdFx0XHRcdFx0cHJpb3JpdHk6IFwidXNlci1ibG9ja2luZ1wiLFxuXHRcdFx0XHRcdHNpZ25hbFxuXHRcdFx0XHR9KS5jYXRjaCgoKSA9PiB7fSk7XG5cdFx0XHR9IGVsc2UgZnJhbWVSZXF1ZXN0UmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY29tbWl0T25PdXRzaWRlTW91c2VEb3duKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gb25XaW5kb3dNb3VzZURvd24oZXZlbnQpIHtcblx0XHRcdGlmIChjYXB0dXJlRXZlbnRSZWYuY3VycmVudCA9PT0gZXZlbnQpIGNvbW1pdE9uT3V0c2lkZU1vdXNlRG93bigpO1xuXHRcdH1cblx0XHRhZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uV2luZG93Q2FwdHVyZU1vdXNlRG93biwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXHRcdGFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25XaW5kb3dNb3VzZURvd24pO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRyZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uV2luZG93Q2FwdHVyZU1vdXNlRG93biwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXHRcdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbldpbmRvd01vdXNlRG93bik7XG5cdFx0XHRjYW5jZWxUYXNrKCk7XG5cdFx0fTtcblx0fSwgW2NvbW1pdE9uT3V0c2lkZUNsaWNrXSk7XG5cdGZ1bmN0aW9uIGNhbmNlbFRhc2soKSB7XG5cdFx0Y2FwdHVyZUV2ZW50UmVmLmN1cnJlbnQgPSB2b2lkIDA7XG5cdFx0aWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ICE9PSB2b2lkIDApIHtcblx0XHRcdGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG5cdFx0XHRhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IHZvaWQgMDtcblx0XHR9XG5cdFx0aWYgKGZyYW1lUmVxdWVzdFJlZi5jdXJyZW50ICE9PSB2b2lkIDApIHtcblx0XHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lUmVxdWVzdFJlZi5jdXJyZW50KTtcblx0XHRcdGZyYW1lUmVxdWVzdFJlZi5jdXJyZW50ID0gdm9pZCAwO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG5cdFx0aWYgKG9uS2V5RG93bikge1xuXHRcdFx0Y29uc3QgY2VsbEV2ZW50ID0gY3JlYXRlQ2VsbEV2ZW50KGV2ZW50KTtcblx0XHRcdG9uS2V5RG93bih7XG5cdFx0XHRcdG1vZGU6IFwiRURJVFwiLFxuXHRcdFx0XHRyb3c6IHJvdyQxLFxuXHRcdFx0XHRjb2x1bW4sXG5cdFx0XHRcdHJvd0lkeCxcblx0XHRcdFx0bmF2aWdhdGUoKSB7XG5cdFx0XHRcdFx0bmF2aWdhdGUoZXZlbnQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvbkNsb3NlXG5cdFx0XHR9LCBjZWxsRXZlbnQpO1xuXHRcdFx0aWYgKGNlbGxFdmVudC5pc0dyaWREZWZhdWx0UHJldmVudGVkKCkpIHJldHVybjtcblx0XHR9XG5cdFx0aWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikgb25DbG9zZSgpO1xuXHRcdGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSBvbkNsb3NlKHRydWUpO1xuXHRcdGVsc2UgaWYgKG9uRWRpdG9yTmF2aWdhdGlvbihldmVudCkpIG5hdmlnYXRlKGV2ZW50KTtcblx0fVxuXHRmdW5jdGlvbiBvbkNsb3NlKGNvbW1pdENoYW5nZXMgPSBmYWxzZSwgc2hvdWxkRm9jdXNDZWxsID0gdHJ1ZSkge1xuXHRcdGlmIChjb21taXRDaGFuZ2VzKSBvblJvd0NoYW5nZShyb3ckMSwgdHJ1ZSwgc2hvdWxkRm9jdXNDZWxsKTtcblx0XHRlbHNlIGNsb3NlRWRpdG9yKHNob3VsZEZvY3VzQ2VsbCk7XG5cdH1cblx0ZnVuY3Rpb24gb25FZGl0b3JSb3dDaGFuZ2Uocm93JDIsIGNvbW1pdENoYW5nZXNBbmRGb2N1cyA9IGZhbHNlKSB7XG5cdFx0b25Sb3dDaGFuZ2Uocm93JDIsIGNvbW1pdENoYW5nZXNBbmRGb2N1cywgY29tbWl0Q2hhbmdlc0FuZEZvY3VzKTtcblx0fVxuXHRjb25zdCB7IGNlbGxDbGFzcyB9ID0gY29sdW1uO1xuXHRjb25zdCBjbGFzc05hbWUgPSBnZXRDZWxsQ2xhc3NuYW1lKGNvbHVtbiwgXCJyZGctZWRpdG9yLWNvbnRhaW5lclwiLCAhY29sdW1uLmVkaXRvck9wdGlvbnM/LmRpc3BsYXlDZWxsQ29udGVudCAmJiBjZWxsRWRpdGluZywgdHlwZW9mIGNlbGxDbGFzcyA9PT0gXCJmdW5jdGlvblwiID8gY2VsbENsYXNzKHJvdyQxKSA6IGNlbGxDbGFzcyk7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcblx0XHRyb2xlOiBcImdyaWRjZWxsXCIsXG5cdFx0XCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuXHRcdFwiYXJpYS1jb2xzcGFuXCI6IGNvbFNwYW4sXG5cdFx0XCJhcmlhLXNlbGVjdGVkXCI6IHRydWUsXG5cdFx0Y2xhc3NOYW1lLFxuXHRcdHN0eWxlOiBnZXRDZWxsU3R5bGUoY29sdW1uLCBjb2xTcGFuKSxcblx0XHRvbktleURvd246IGhhbmRsZUtleURvd24sXG5cdFx0b25Nb3VzZURvd25DYXB0dXJlOiBjYW5jZWxUYXNrLFxuXHRcdGNoaWxkcmVuOiBjb2x1bW4ucmVuZGVyRWRpdENlbGwgIT0gbnVsbCAmJiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2NvbHVtbi5yZW5kZXJFZGl0Q2VsbCh7XG5cdFx0XHRjb2x1bW4sXG5cdFx0XHRyb3c6IHJvdyQxLFxuXHRcdFx0cm93SWR4LFxuXHRcdFx0b25Sb3dDaGFuZ2U6IG9uRWRpdG9yUm93Q2hhbmdlLFxuXHRcdFx0b25DbG9zZVxuXHRcdH0pLCBjb2x1bW4uZWRpdG9yT3B0aW9ucz8uZGlzcGxheUNlbGxDb250ZW50ICYmIGNvbHVtbi5yZW5kZXJDZWxsKHtcblx0XHRcdGNvbHVtbixcblx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRyb3dJZHgsXG5cdFx0XHRpc0NlbGxFZGl0YWJsZTogdHJ1ZSxcblx0XHRcdHRhYkluZGV4OiAtMSxcblx0XHRcdG9uUm93Q2hhbmdlOiBvbkVkaXRvclJvd0NoYW5nZVxuXHRcdH0pXSB9KVxuXHR9KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL0dyb3VwZWRDb2x1bW5IZWFkZXJDZWxsLnRzeFxuZnVuY3Rpb24gR3JvdXBlZENvbHVtbkhlYWRlckNlbGwoeyBjb2x1bW4sIHJvd0lkeCwgaXNDZWxsU2VsZWN0ZWQsIHNlbGVjdENlbGwgfSkge1xuXHRjb25zdCB7IHRhYkluZGV4LCBvbkZvY3VzIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG5cdGNvbnN0IHsgY29sU3BhbiB9ID0gY29sdW1uO1xuXHRjb25zdCByb3dTcGFuID0gZ2V0SGVhZGVyQ2VsbFJvd1NwYW4oY29sdW1uLCByb3dJZHgpO1xuXHRjb25zdCBpbmRleCA9IGNvbHVtbi5pZHggKyAxO1xuXHRmdW5jdGlvbiBvbk1vdXNlRG93bigpIHtcblx0XHRzZWxlY3RDZWxsKHtcblx0XHRcdGlkeDogY29sdW1uLmlkeCxcblx0XHRcdHJvd0lkeFxuXHRcdH0pO1xuXHR9XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcblx0XHRyb2xlOiBcImNvbHVtbmhlYWRlclwiLFxuXHRcdFwiYXJpYS1jb2xpbmRleFwiOiBpbmRleCxcblx0XHRcImFyaWEtY29sc3BhblwiOiBjb2xTcGFuLFxuXHRcdFwiYXJpYS1yb3dzcGFuXCI6IHJvd1NwYW4sXG5cdFx0XCJhcmlhLXNlbGVjdGVkXCI6IGlzQ2VsbFNlbGVjdGVkLFxuXHRcdHRhYkluZGV4LFxuXHRcdGNsYXNzTmFtZTogY2xhc3NuYW1lcyhjZWxsQ2xhc3NuYW1lLCBjb2x1bW4uaGVhZGVyQ2VsbENsYXNzKSxcblx0XHRzdHlsZToge1xuXHRcdFx0Li4uZ2V0SGVhZGVyQ2VsbFN0eWxlKGNvbHVtbiwgcm93SWR4LCByb3dTcGFuKSxcblx0XHRcdGdyaWRDb2x1bW5TdGFydDogaW5kZXgsXG5cdFx0XHRncmlkQ29sdW1uRW5kOiBpbmRleCArIGNvbFNwYW5cblx0XHR9LFxuXHRcdG9uRm9jdXMsXG5cdFx0b25Nb3VzZURvd24sXG5cdFx0Y2hpbGRyZW46IGNvbHVtbi5uYW1lXG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvSGVhZGVyQ2VsbC50c3hcbmNvbnN0IGNlbGxTb3J0YWJsZUNsYXNzbmFtZSA9IFwicmRnLTctMC0wLWJldGEtNTgtMmE3ZTI0MGRcIjtcbmNvbnN0IGNlbGxSZXNpemFibGVDbGFzc25hbWUgPSBgcmRnLWNlbGwtcmVzaXphYmxlIHJkZy03LTAtMC1iZXRhLTU4LTE4OTNkYzBmYDtcbmNvbnN0IHJlc2l6ZUhhbmRsZUNsYXNzbmFtZSA9IGByZGctcmVzaXplLWhhbmRsZSByZGctNy0wLTAtYmV0YS01OC00ZTYwZGI5MWA7XG5jb25zdCBjZWxsRHJhZ2dhYmxlQ2xhc3NuYW1lID0gXCJyZGctY2VsbC1kcmFnZ2FibGVcIjtcbmNvbnN0IGNlbGxEcmFnZ2luZ0NsYXNzbmFtZSA9IGByZGctY2VsbC1kcmFnZ2luZyByZGctNy0wLTAtYmV0YS01OC0zZTFhNGFkNGA7XG5jb25zdCBjZWxsT3ZlckNsYXNzbmFtZSA9IGByZGctY2VsbC1kcmFnLW92ZXIgcmRnLTctMC0wLWJldGEtNTgtNTFhYmQ4YjhgO1xuY29uc3QgZHJhZ0ltYWdlQ2xhc3NuYW1lID0gXCJyZGctNy0wLTAtYmV0YS01OC1jOGQ3YWE2NFwiO1xuZnVuY3Rpb24gSGVhZGVyQ2VsbCh7IGNvbHVtbiwgY29sU3Bhbiwgcm93SWR4LCBpc0NlbGxTZWxlY3RlZCwgb25Db2x1bW5SZXNpemUsIG9uQ29sdW1uUmVzaXplRW5kLCBvbkNvbHVtbnNSZW9yZGVyLCBzb3J0Q29sdW1ucywgb25Tb3J0Q29sdW1uc0NoYW5nZSwgc2VsZWN0Q2VsbCwgc2hvdWxkRm9jdXNHcmlkLCBkaXJlY3Rpb24sIGRyYWdnZWRDb2x1bW5LZXksIHNldERyYWdnZWRDb2x1bW5LZXkgfSkge1xuXHRjb25zdCBbaXNPdmVyLCBzZXRJc092ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuXHRjb25zdCBkcmFnSW1hZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG5cdGNvbnN0IGlzRHJhZ2dpbmcgPSBkcmFnZ2VkQ29sdW1uS2V5ID09PSBjb2x1bW4ua2V5O1xuXHRjb25zdCByb3dTcGFuID0gZ2V0SGVhZGVyQ2VsbFJvd1NwYW4oY29sdW1uLCByb3dJZHgpO1xuXHRjb25zdCB7IHRhYkluZGV4LCBjaGlsZFRhYkluZGV4LCBvbkZvY3VzIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChzaG91bGRGb2N1c0dyaWQgfHwgaXNDZWxsU2VsZWN0ZWQpO1xuXHRjb25zdCBzb3J0SW5kZXggPSBzb3J0Q29sdW1ucz8uZmluZEluZGV4KChzb3J0KSA9PiBzb3J0LmNvbHVtbktleSA9PT0gY29sdW1uLmtleSk7XG5cdGNvbnN0IHNvcnRDb2x1bW4gPSBzb3J0SW5kZXggIT09IHZvaWQgMCAmJiBzb3J0SW5kZXggPiAtMSA/IHNvcnRDb2x1bW5zW3NvcnRJbmRleF0gOiB2b2lkIDA7XG5cdGNvbnN0IHNvcnREaXJlY3Rpb24gPSBzb3J0Q29sdW1uPy5kaXJlY3Rpb247XG5cdGNvbnN0IHByaW9yaXR5ID0gc29ydENvbHVtbiAhPT0gdm9pZCAwICYmIHNvcnRDb2x1bW5zLmxlbmd0aCA+IDEgPyBzb3J0SW5kZXggKyAxIDogdm9pZCAwO1xuXHRjb25zdCBhcmlhU29ydCA9IHNvcnREaXJlY3Rpb24gJiYgIXByaW9yaXR5ID8gc29ydERpcmVjdGlvbiA9PT0gXCJBU0NcIiA/IFwiYXNjZW5kaW5nXCIgOiBcImRlc2NlbmRpbmdcIiA6IHZvaWQgMDtcblx0Y29uc3QgeyBzb3J0YWJsZSwgcmVzaXphYmxlLCBkcmFnZ2FibGUgfSA9IGNvbHVtbjtcblx0Y29uc3QgY2xhc3NOYW1lID0gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIGNvbHVtbi5oZWFkZXJDZWxsQ2xhc3MsIHtcblx0XHRbY2VsbFNvcnRhYmxlQ2xhc3NuYW1lXTogc29ydGFibGUsXG5cdFx0W2NlbGxSZXNpemFibGVDbGFzc25hbWVdOiByZXNpemFibGUsXG5cdFx0W2NlbGxEcmFnZ2FibGVDbGFzc25hbWVdOiBkcmFnZ2FibGUsXG5cdFx0W2NlbGxEcmFnZ2luZ0NsYXNzbmFtZV06IGlzRHJhZ2dpbmcsXG5cdFx0W2NlbGxPdmVyQ2xhc3NuYW1lXTogaXNPdmVyXG5cdH0pO1xuXHRmdW5jdGlvbiBvblNvcnQoY3RybENsaWNrKSB7XG5cdFx0aWYgKG9uU29ydENvbHVtbnNDaGFuZ2UgPT0gbnVsbCkgcmV0dXJuO1xuXHRcdGNvbnN0IHsgc29ydERlc2NlbmRpbmdGaXJzdCB9ID0gY29sdW1uO1xuXHRcdGlmIChzb3J0Q29sdW1uID09PSB2b2lkIDApIHtcblx0XHRcdGNvbnN0IG5leHRTb3J0ID0ge1xuXHRcdFx0XHRjb2x1bW5LZXk6IGNvbHVtbi5rZXksXG5cdFx0XHRcdGRpcmVjdGlvbjogc29ydERlc2NlbmRpbmdGaXJzdCA/IFwiREVTQ1wiIDogXCJBU0NcIlxuXHRcdFx0fTtcblx0XHRcdG9uU29ydENvbHVtbnNDaGFuZ2Uoc29ydENvbHVtbnMgJiYgY3RybENsaWNrID8gWy4uLnNvcnRDb2x1bW5zLCBuZXh0U29ydF0gOiBbbmV4dFNvcnRdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IG5leHRTb3J0Q29sdW1uO1xuXHRcdFx0aWYgKHNvcnREZXNjZW5kaW5nRmlyc3QgPT09IHRydWUgJiYgc29ydERpcmVjdGlvbiA9PT0gXCJERVNDXCIgfHwgc29ydERlc2NlbmRpbmdGaXJzdCAhPT0gdHJ1ZSAmJiBzb3J0RGlyZWN0aW9uID09PSBcIkFTQ1wiKSBuZXh0U29ydENvbHVtbiA9IHtcblx0XHRcdFx0Y29sdW1uS2V5OiBjb2x1bW4ua2V5LFxuXHRcdFx0XHRkaXJlY3Rpb246IHNvcnREaXJlY3Rpb24gPT09IFwiQVNDXCIgPyBcIkRFU0NcIiA6IFwiQVNDXCJcblx0XHRcdH07XG5cdFx0XHRpZiAoY3RybENsaWNrKSB7XG5cdFx0XHRcdGNvbnN0IG5leHRTb3J0Q29sdW1ucyA9IFsuLi5zb3J0Q29sdW1uc107XG5cdFx0XHRcdGlmIChuZXh0U29ydENvbHVtbikgbmV4dFNvcnRDb2x1bW5zW3NvcnRJbmRleF0gPSBuZXh0U29ydENvbHVtbjtcblx0XHRcdFx0ZWxzZSBuZXh0U29ydENvbHVtbnMuc3BsaWNlKHNvcnRJbmRleCwgMSk7XG5cdFx0XHRcdG9uU29ydENvbHVtbnNDaGFuZ2UobmV4dFNvcnRDb2x1bW5zKTtcblx0XHRcdH0gZWxzZSBvblNvcnRDb2x1bW5zQ2hhbmdlKG5leHRTb3J0Q29sdW1uID8gW25leHRTb3J0Q29sdW1uXSA6IFtdKTtcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlRm9jdXMoZXZlbnQpIHtcblx0XHRvbkZvY3VzPy4oZXZlbnQpO1xuXHRcdGlmIChzaG91bGRGb2N1c0dyaWQpIHNlbGVjdENlbGwoe1xuXHRcdFx0aWR4OiAwLFxuXHRcdFx0cm93SWR4XG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG5cdFx0c2VsZWN0Q2VsbCh7XG5cdFx0XHRpZHg6IGNvbHVtbi5pZHgsXG5cdFx0XHRyb3dJZHhcblx0XHR9KTtcblx0fVxuXHRmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG5cdFx0aWYgKHNvcnRhYmxlKSBvblNvcnQoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KTtcblx0fVxuXHRmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcblx0XHRjb25zdCB7IGtleSB9ID0gZXZlbnQ7XG5cdFx0aWYgKHNvcnRhYmxlICYmIChrZXkgPT09IFwiIFwiIHx8IGtleSA9PT0gXCJFbnRlclwiKSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdG9uU29ydChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpO1xuXHRcdH0gZWxzZSBpZiAocmVzaXphYmxlICYmIGlzQ3RybEtleUhlbGREb3duKGV2ZW50KSAmJiAoa2V5ID09PSBcIkFycm93TGVmdFwiIHx8IGtleSA9PT0gXCJBcnJvd1JpZ2h0XCIpKSB7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGNvbnN0IHsgd2lkdGggfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRjb25zdCB7IGxlZnRLZXkgfSA9IGdldExlZnRSaWdodEtleShkaXJlY3Rpb24pO1xuXHRcdFx0Y29uc3QgbmV3V2lkdGggPSBjbGFtcENvbHVtbldpZHRoKHdpZHRoICsgKGtleSA9PT0gbGVmdEtleSA/IC0xMCA6IDEwKSwgY29sdW1uKTtcblx0XHRcdGlmIChuZXdXaWR0aCAhPT0gd2lkdGgpIG9uQ29sdW1uUmVzaXplKGNvbHVtbiwgbmV3V2lkdGgpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuXHRcdGZsdXNoU3luYygoKSA9PiB7XG5cdFx0XHRzZXREcmFnZ2VkQ29sdW1uS2V5KGNvbHVtbi5rZXkpO1xuXHRcdH0pO1xuXHRcdGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoZHJhZ0ltYWdlUmVmLmN1cnJlbnQsIDAsIDApO1xuXHRcdGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJtb3ZlXCI7XG5cdH1cblx0ZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuXHRcdHNldERyYWdnZWRDb2x1bW5LZXkodm9pZCAwKTtcblx0fVxuXHRmdW5jdGlvbiBvbkRyYWdPdmVyKGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiO1xuXHR9XG5cdGZ1bmN0aW9uIG9uRHJvcChldmVudCkge1xuXHRcdHNldElzT3ZlcihmYWxzZSk7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRvbkNvbHVtbnNSZW9yZGVyPy4oZHJhZ2dlZENvbHVtbktleSwgY29sdW1uLmtleSk7XG5cdH1cblx0ZnVuY3Rpb24gb25EcmFnRW50ZXIoZXZlbnQpIHtcblx0XHRpZiAoaXNFdmVudFBlcnRpbmVudChldmVudCkpIHNldElzT3Zlcih0cnVlKTtcblx0fVxuXHRmdW5jdGlvbiBvbkRyYWdMZWF2ZShldmVudCkge1xuXHRcdGlmIChpc0V2ZW50UGVydGluZW50KGV2ZW50KSkgc2V0SXNPdmVyKGZhbHNlKTtcblx0fVxuXHRsZXQgZHJhZ1RhcmdldFByb3BzO1xuXHRsZXQgZHJvcFRhcmdldFByb3BzO1xuXHRpZiAoZHJhZ2dhYmxlKSB7XG5cdFx0ZHJhZ1RhcmdldFByb3BzID0ge1xuXHRcdFx0ZHJhZ2dhYmxlOiB0cnVlLFxuXHRcdFx0b25EcmFnU3RhcnQsXG5cdFx0XHRvbkRyYWdFbmRcblx0XHR9O1xuXHRcdGlmIChkcmFnZ2VkQ29sdW1uS2V5ICE9PSB2b2lkIDAgJiYgZHJhZ2dlZENvbHVtbktleSAhPT0gY29sdW1uLmtleSkgZHJvcFRhcmdldFByb3BzID0ge1xuXHRcdFx0b25EcmFnT3Zlcixcblx0XHRcdG9uRHJhZ0VudGVyLFxuXHRcdFx0b25EcmFnTGVhdmUsXG5cdFx0XHRvbkRyb3Bcblx0XHR9O1xuXHR9XG5cdGNvbnN0IHN0eWxlID0ge1xuXHRcdC4uLmdldEhlYWRlckNlbGxTdHlsZShjb2x1bW4sIHJvd0lkeCwgcm93U3BhbiksXG5cdFx0Li4uZ2V0Q2VsbFN0eWxlKGNvbHVtbiwgY29sU3Bhbilcblx0fTtcblx0Y29uc3QgY29udGVudCA9IGNvbHVtbi5yZW5kZXJIZWFkZXJDZWxsKHtcblx0XHRjb2x1bW4sXG5cdFx0c29ydERpcmVjdGlvbixcblx0XHRwcmlvcml0eSxcblx0XHR0YWJJbmRleDogY2hpbGRUYWJJbmRleFxuXHR9KTtcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbaXNEcmFnZ2luZyAmJiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcblx0XHRyZWY6IGRyYWdJbWFnZVJlZixcblx0XHRzdHlsZSxcblx0XHRjbGFzc05hbWU6IGdldENlbGxDbGFzc25hbWUoY29sdW1uLCBjb2x1bW4uaGVhZGVyQ2VsbENsYXNzLCBkcmFnSW1hZ2VDbGFzc25hbWUpLFxuXHRcdGNoaWxkcmVuOiBjb250ZW50XG5cdH0pLCAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7XG5cdFx0cm9sZTogXCJjb2x1bW5oZWFkZXJcIixcblx0XHRcImFyaWEtY29saW5kZXhcIjogY29sdW1uLmlkeCArIDEsXG5cdFx0XCJhcmlhLWNvbHNwYW5cIjogY29sU3Bhbixcblx0XHRcImFyaWEtcm93c3BhblwiOiByb3dTcGFuLFxuXHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBpc0NlbGxTZWxlY3RlZCxcblx0XHRcImFyaWEtc29ydFwiOiBhcmlhU29ydCxcblx0XHR0YWJJbmRleCxcblx0XHRjbGFzc05hbWUsXG5cdFx0c3R5bGUsXG5cdFx0b25Nb3VzZURvd24sXG5cdFx0b25Gb2N1czogaGFuZGxlRm9jdXMsXG5cdFx0b25DbGljayxcblx0XHRvbktleURvd24sXG5cdFx0Li4uZHJhZ1RhcmdldFByb3BzLFxuXHRcdC4uLmRyb3BUYXJnZXRQcm9wcyxcblx0XHRjaGlsZHJlbjogW2NvbnRlbnQsIHJlc2l6YWJsZSAmJiAvKiBAX19QVVJFX18gKi8ganN4KFJlc2l6ZUhhbmRsZSwge1xuXHRcdFx0ZGlyZWN0aW9uLFxuXHRcdFx0Y29sdW1uLFxuXHRcdFx0b25Db2x1bW5SZXNpemUsXG5cdFx0XHRvbkNvbHVtblJlc2l6ZUVuZFxuXHRcdH0pXVxuXHR9KV0gfSk7XG59XG5mdW5jdGlvbiBSZXNpemVIYW5kbGUoeyBkaXJlY3Rpb24sIGNvbHVtbiwgb25Db2x1bW5SZXNpemUsIG9uQ29sdW1uUmVzaXplRW5kIH0pIHtcblx0Y29uc3QgcmVzaXppbmdPZmZzZXRSZWYgPSB1c2VSZWYodm9pZCAwKTtcblx0Y29uc3QgaXNSdGwgPSBkaXJlY3Rpb24gPT09IFwicnRsXCI7XG5cdGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiAmJiBldmVudC5idXR0b25zICE9PSAxKSByZXR1cm47XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRjb25zdCB7IGN1cnJlbnRUYXJnZXQsIHBvaW50ZXJJZCB9ID0gZXZlbnQ7XG5cdFx0Y3VycmVudFRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuXHRcdGNvbnN0IHsgcmlnaHQsIGxlZnQgfSA9IGN1cnJlbnRUYXJnZXQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRyZXNpemluZ09mZnNldFJlZi5jdXJyZW50ID0gaXNSdGwgPyBldmVudC5jbGllbnRYIC0gbGVmdCA6IHJpZ2h0IC0gZXZlbnQuY2xpZW50WDtcblx0fVxuXHRmdW5jdGlvbiBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG5cdFx0Y29uc3Qgb2Zmc2V0ID0gcmVzaXppbmdPZmZzZXRSZWYuY3VycmVudDtcblx0XHRpZiAob2Zmc2V0ID09PSB2b2lkIDApIHJldHVybjtcblx0XHRjb25zdCB7IHdpZHRoLCByaWdodCwgbGVmdCB9ID0gZXZlbnQuY3VycmVudFRhcmdldC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGxldCBuZXdXaWR0aCA9IGlzUnRsID8gcmlnaHQgKyBvZmZzZXQgLSBldmVudC5jbGllbnRYIDogZXZlbnQuY2xpZW50WCArIG9mZnNldCAtIGxlZnQ7XG5cdFx0bmV3V2lkdGggPSBjbGFtcENvbHVtbldpZHRoKG5ld1dpZHRoLCBjb2x1bW4pO1xuXHRcdGlmICh3aWR0aCA+IDAgJiYgbmV3V2lkdGggIT09IHdpZHRoKSBvbkNvbHVtblJlc2l6ZShjb2x1bW4sIG5ld1dpZHRoKTtcblx0fVxuXHRmdW5jdGlvbiBvbkxvc3RQb2ludGVyQ2FwdHVyZSgpIHtcblx0XHRvbkNvbHVtblJlc2l6ZUVuZCgpO1xuXHRcdHJlc2l6aW5nT2Zmc2V0UmVmLmN1cnJlbnQgPSB2b2lkIDA7XG5cdH1cblx0ZnVuY3Rpb24gb25Eb3VibGVDbGljaygpIHtcblx0XHRvbkNvbHVtblJlc2l6ZShjb2x1bW4sIFwibWF4LWNvbnRlbnRcIik7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwge1xuXHRcdFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcblx0XHRjbGFzc05hbWU6IHJlc2l6ZUhhbmRsZUNsYXNzbmFtZSxcblx0XHRvbkNsaWNrOiBzdG9wUHJvcGFnYXRpb24sXG5cdFx0b25Qb2ludGVyRG93bixcblx0XHRvblBvaW50ZXJNb3ZlLFxuXHRcdG9uTG9zdFBvaW50ZXJDYXB0dXJlLFxuXHRcdG9uRG91YmxlQ2xpY2tcblx0fSk7XG59XG5mdW5jdGlvbiBpc0V2ZW50UGVydGluZW50KGV2ZW50KSB7XG5cdGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXHRyZXR1cm4gIWV2ZW50LmN1cnJlbnRUYXJnZXQuY29udGFpbnMocmVsYXRlZFRhcmdldCk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9zdHlsZS9yb3cudHNcbmNvbnN0IHJvdyA9IFwicmRnLTctMC0wLWJldGEtNTgtM2MwODNmMWJcIjtcbmNvbnN0IHJvd0NsYXNzbmFtZSA9IGByZGctcm93ICR7cm93fWA7XG5jb25zdCByb3dTZWxlY3RlZCA9IFwicmRnLTctMC0wLWJldGEtNTgtM2ZlNzczYzNcIjtcbmNvbnN0IHJvd1NlbGVjdGVkQ2xhc3NuYW1lID0gXCJyZGctcm93LXNlbGVjdGVkXCI7XG5jb25zdCByb3dTZWxlY3RlZFdpdGhGcm96ZW5DZWxsID0gXCJyZGctNy0wLTAtYmV0YS01OC05N2NlM2ZkZVwiO1xuY29uc3QgdG9wU3VtbWFyeVJvd0NsYXNzbmFtZSA9IFwicmRnLXRvcC1zdW1tYXJ5LXJvd1wiO1xuY29uc3QgYm90dG9tU3VtbWFyeVJvd0NsYXNzbmFtZSA9IFwicmRnLWJvdHRvbS1zdW1tYXJ5LXJvd1wiO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvSGVhZGVyUm93LnRzeFxuY29uc3QgaGVhZGVyUm93ID0gXCJyZGctNy0wLTAtYmV0YS01OC0wZGJkNTk5NFwiO1xuY29uc3QgaGVhZGVyUm93Q2xhc3NuYW1lID0gYHJkZy1oZWFkZXItcm93ICR7aGVhZGVyUm93fWA7XG5mdW5jdGlvbiBIZWFkZXJSb3coeyBoZWFkZXJSb3dDbGFzcywgcm93SWR4LCBjb2x1bW5zLCBvbkNvbHVtblJlc2l6ZSwgb25Db2x1bW5SZXNpemVFbmQsIG9uQ29sdW1uc1Jlb3JkZXIsIHNvcnRDb2x1bW5zLCBvblNvcnRDb2x1bW5zQ2hhbmdlLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHNlbGVjdGVkQ2VsbElkeCwgc2VsZWN0Q2VsbCwgc2hvdWxkRm9jdXNHcmlkLCBkaXJlY3Rpb24gfSkge1xuXHRjb25zdCBbZHJhZ2dlZENvbHVtbktleSwgc2V0RHJhZ2dlZENvbHVtbktleV0gPSB1c2VTdGF0ZSgpO1xuXHRjb25zdCBjZWxscyA9IFtdO1xuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2luZGV4XTtcblx0XHRjb25zdCBjb2xTcGFuID0gZ2V0Q29sU3Bhbihjb2x1bW4sIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgeyB0eXBlOiBcIkhFQURFUlwiIH0pO1xuXHRcdGlmIChjb2xTcGFuICE9PSB2b2lkIDApIGluZGV4ICs9IGNvbFNwYW4gLSAxO1xuXHRcdGNlbGxzLnB1c2goLyogQF9fUFVSRV9fICovIGpzeChIZWFkZXJDZWxsLCB7XG5cdFx0XHRjb2x1bW4sXG5cdFx0XHRjb2xTcGFuLFxuXHRcdFx0cm93SWR4LFxuXHRcdFx0aXNDZWxsU2VsZWN0ZWQ6IHNlbGVjdGVkQ2VsbElkeCA9PT0gY29sdW1uLmlkeCxcblx0XHRcdG9uQ29sdW1uUmVzaXplLFxuXHRcdFx0b25Db2x1bW5SZXNpemVFbmQsXG5cdFx0XHRvbkNvbHVtbnNSZW9yZGVyLFxuXHRcdFx0b25Tb3J0Q29sdW1uc0NoYW5nZSxcblx0XHRcdHNvcnRDb2x1bW5zLFxuXHRcdFx0c2VsZWN0Q2VsbCxcblx0XHRcdHNob3VsZEZvY3VzR3JpZDogc2hvdWxkRm9jdXNHcmlkICYmIGluZGV4ID09PSAwLFxuXHRcdFx0ZGlyZWN0aW9uLFxuXHRcdFx0ZHJhZ2dlZENvbHVtbktleSxcblx0XHRcdHNldERyYWdnZWRDb2x1bW5LZXlcblx0XHR9LCBjb2x1bW4ua2V5KSk7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwge1xuXHRcdHJvbGU6IFwicm93XCIsXG5cdFx0XCJhcmlhLXJvd2luZGV4XCI6IHJvd0lkeCxcblx0XHRjbGFzc05hbWU6IGNsYXNzbmFtZXMoaGVhZGVyUm93Q2xhc3NuYW1lLCB7IFtyb3dTZWxlY3RlZENsYXNzbmFtZV06IHNlbGVjdGVkQ2VsbElkeCA9PT0gLTEgfSwgaGVhZGVyUm93Q2xhc3MpLFxuXHRcdGNoaWxkcmVuOiBjZWxsc1xuXHR9KTtcbn1cbnZhciBIZWFkZXJSb3dfZGVmYXVsdCA9IG1lbW8oSGVhZGVyUm93KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL0dyb3VwZWRDb2x1bW5IZWFkZXJSb3cudHN4XG5mdW5jdGlvbiBHcm91cGVkQ29sdW1uSGVhZGVyUm93KHsgcm93SWR4LCBsZXZlbCwgY29sdW1ucywgc2VsZWN0ZWRDZWxsSWR4LCBzZWxlY3RDZWxsIH0pIHtcblx0Y29uc3QgY2VsbHMgPSBbXTtcblx0Y29uc3QgcmVuZGVyZWRQYXJlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcblx0Zm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuXHRcdGxldCB7IHBhcmVudCB9ID0gY29sdW1uO1xuXHRcdGlmIChwYXJlbnQgPT09IHZvaWQgMCkgY29udGludWU7XG5cdFx0d2hpbGUgKHBhcmVudC5sZXZlbCA+IGxldmVsKSB7XG5cdFx0XHRpZiAocGFyZW50LnBhcmVudCA9PT0gdm9pZCAwKSBicmVhaztcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0fVxuXHRcdGlmIChwYXJlbnQubGV2ZWwgPT09IGxldmVsICYmICFyZW5kZXJlZFBhcmVudHMuaGFzKHBhcmVudCkpIHtcblx0XHRcdHJlbmRlcmVkUGFyZW50cy5hZGQocGFyZW50KTtcblx0XHRcdGNvbnN0IHsgaWR4IH0gPSBwYXJlbnQ7XG5cdFx0XHRjZWxscy5wdXNoKC8qIEBfX1BVUkVfXyAqLyBqc3goR3JvdXBlZENvbHVtbkhlYWRlckNlbGwsIHtcblx0XHRcdFx0Y29sdW1uOiBwYXJlbnQsXG5cdFx0XHRcdHJvd0lkeCxcblx0XHRcdFx0aXNDZWxsU2VsZWN0ZWQ6IHNlbGVjdGVkQ2VsbElkeCA9PT0gaWR4LFxuXHRcdFx0XHRzZWxlY3RDZWxsXG5cdFx0XHR9LCBpZHgpKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwge1xuXHRcdHJvbGU6IFwicm93XCIsXG5cdFx0XCJhcmlhLXJvd2luZGV4XCI6IHJvd0lkeCxcblx0XHRjbGFzc05hbWU6IGhlYWRlclJvd0NsYXNzbmFtZSxcblx0XHRjaGlsZHJlbjogY2VsbHNcblx0fSk7XG59XG52YXIgR3JvdXBlZENvbHVtbkhlYWRlclJvd19kZWZhdWx0ID0gbWVtbyhHcm91cGVkQ29sdW1uSGVhZGVyUm93KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Jvdy50c3hcbmZ1bmN0aW9uIFJvdyh7IGNsYXNzTmFtZSwgcm93SWR4LCBncmlkUm93U3RhcnQsIHNlbGVjdGVkQ2VsbElkeCwgaXNSb3dTZWxlY3Rpb25EaXNhYmxlZCwgaXNSb3dTZWxlY3RlZCwgZHJhZ2dlZE92ZXJDZWxsSWR4LCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHJvdzogcm93JDEsIHZpZXdwb3J0Q29sdW1ucywgc2VsZWN0ZWRDZWxsRWRpdG9yLCBvbkNlbGxNb3VzZURvd24sIG9uQ2VsbENsaWNrLCBvbkNlbGxEb3VibGVDbGljaywgb25DZWxsQ29udGV4dE1lbnUsIHJvd0NsYXNzLCBvblJvd0NoYW5nZSwgc2VsZWN0Q2VsbCwgc3R5bGUsIC4uLnByb3BzIH0pIHtcblx0Y29uc3QgcmVuZGVyQ2VsbCA9IHVzZURlZmF1bHRSZW5kZXJlcnMoKS5yZW5kZXJDZWxsO1xuXHRjb25zdCBoYW5kbGVSb3dDaGFuZ2UgPSB1c2VMYXRlc3RGdW5jKChjb2x1bW4sIG5ld1JvdykgPT4ge1xuXHRcdG9uUm93Q2hhbmdlKGNvbHVtbiwgcm93SWR4LCBuZXdSb3cpO1xuXHR9KTtcblx0Y2xhc3NOYW1lID0gY2xhc3NuYW1lcyhyb3dDbGFzc25hbWUsIGByZGctcm93LSR7cm93SWR4ICUgMiA9PT0gMCA/IFwiZXZlblwiIDogXCJvZGRcIn1gLCB7IFtyb3dTZWxlY3RlZENsYXNzbmFtZV06IHNlbGVjdGVkQ2VsbElkeCA9PT0gLTEgfSwgcm93Q2xhc3M/Lihyb3ckMSwgcm93SWR4KSwgY2xhc3NOYW1lKTtcblx0Y29uc3QgY2VsbHMgPSBbXTtcblx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZpZXdwb3J0Q29sdW1ucy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRjb25zdCBjb2x1bW4gPSB2aWV3cG9ydENvbHVtbnNbaW5kZXhdO1xuXHRcdGNvbnN0IHsgaWR4IH0gPSBjb2x1bW47XG5cdFx0Y29uc3QgY29sU3BhbiA9IGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcblx0XHRcdHR5cGU6IFwiUk9XXCIsXG5cdFx0XHRyb3c6IHJvdyQxXG5cdFx0fSk7XG5cdFx0aWYgKGNvbFNwYW4gIT09IHZvaWQgMCkgaW5kZXggKz0gY29sU3BhbiAtIDE7XG5cdFx0Y29uc3QgaXNDZWxsU2VsZWN0ZWQgPSBzZWxlY3RlZENlbGxJZHggPT09IGlkeDtcblx0XHRpZiAoaXNDZWxsU2VsZWN0ZWQgJiYgc2VsZWN0ZWRDZWxsRWRpdG9yKSBjZWxscy5wdXNoKHNlbGVjdGVkQ2VsbEVkaXRvcik7XG5cdFx0ZWxzZSBjZWxscy5wdXNoKHJlbmRlckNlbGwoY29sdW1uLmtleSwge1xuXHRcdFx0Y29sdW1uLFxuXHRcdFx0Y29sU3Bhbixcblx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRyb3dJZHgsXG5cdFx0XHRpc0RyYWdnZWRPdmVyOiBkcmFnZ2VkT3ZlckNlbGxJZHggPT09IGlkeCxcblx0XHRcdGlzQ2VsbFNlbGVjdGVkLFxuXHRcdFx0b25DZWxsTW91c2VEb3duLFxuXHRcdFx0b25DZWxsQ2xpY2ssXG5cdFx0XHRvbkNlbGxEb3VibGVDbGljayxcblx0XHRcdG9uQ2VsbENvbnRleHRNZW51LFxuXHRcdFx0b25Sb3dDaGFuZ2U6IGhhbmRsZVJvd0NoYW5nZSxcblx0XHRcdHNlbGVjdENlbGxcblx0XHR9KSk7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUm93U2VsZWN0aW9uQ29udGV4dCwge1xuXHRcdHZhbHVlOiB1c2VNZW1vKCgpID0+ICh7XG5cdFx0XHRpc1Jvd1NlbGVjdGVkLFxuXHRcdFx0aXNSb3dTZWxlY3Rpb25EaXNhYmxlZFxuXHRcdH0pLCBbaXNSb3dTZWxlY3Rpb25EaXNhYmxlZCwgaXNSb3dTZWxlY3RlZF0pLFxuXHRcdGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcblx0XHRcdHJvbGU6IFwicm93XCIsXG5cdFx0XHRjbGFzc05hbWUsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHQuLi5nZXRSb3dTdHlsZShncmlkUm93U3RhcnQpLFxuXHRcdFx0XHQuLi5zdHlsZVxuXHRcdFx0fSxcblx0XHRcdC4uLnByb3BzLFxuXHRcdFx0Y2hpbGRyZW46IGNlbGxzXG5cdFx0fSlcblx0fSk7XG59XG5jb25zdCBSb3dDb21wb25lbnQgPSBtZW1vKFJvdyk7XG52YXIgUm93X2RlZmF1bHQgPSBSb3dDb21wb25lbnQ7XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyUm93KGtleSwgcHJvcHMpIHtcblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUm93Q29tcG9uZW50LCB7IC4uLnByb3BzIH0sIGtleSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9TY3JvbGxUb0NlbGwudHN4XG5mdW5jdGlvbiBTY3JvbGxUb0NlbGwoeyBzY3JvbGxUb1Bvc2l0aW9uOiB7IGlkeCwgcm93SWR4IH0sIGdyaWRSZWYsIHNldFNjcm9sbFRvQ2VsbFBvc2l0aW9uIH0pIHtcblx0Y29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuXHR1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXHRcdHNjcm9sbEludG9WaWV3KHJlZi5jdXJyZW50LCBcImF1dG9cIik7XG5cdH0pO1xuXHR1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuXHRcdGZ1bmN0aW9uIHJlbW92ZVNjcm9sbFRvQ2VsbCgpIHtcblx0XHRcdHNldFNjcm9sbFRvQ2VsbFBvc2l0aW9uKG51bGwpO1xuXHRcdH1cblx0XHRjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihyZW1vdmVTY3JvbGxUb0NlbGwsIHtcblx0XHRcdHJvb3Q6IGdyaWRSZWYuY3VycmVudCxcblx0XHRcdHRocmVzaG9sZDogMVxuXHRcdH0pO1xuXHRcdG9ic2VydmVyLm9ic2VydmUocmVmLmN1cnJlbnQpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0fTtcblx0fSwgW2dyaWRSZWYsIHNldFNjcm9sbFRvQ2VsbFBvc2l0aW9uXSk7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcblx0XHRyZWYsXG5cdFx0c3R5bGU6IHtcblx0XHRcdGdyaWRDb2x1bW46IGlkeCA9PT0gdm9pZCAwID8gXCIxLy0xXCIgOiBpZHggKyAxLFxuXHRcdFx0Z3JpZFJvdzogcm93SWR4ID09PSB2b2lkIDAgPyBcIjEvLTFcIiA6IHJvd0lkeCArIDJcblx0XHR9XG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvc29ydFN0YXR1cy50c3hcbmNvbnN0IGFycm93Q2xhc3NuYW1lID0gYHJkZy1zb3J0LWFycm93IHJkZy03LTAtMC1iZXRhLTU4LTNkNTExNWYzYDtcbmZ1bmN0aW9uIHJlbmRlclNvcnRTdGF0dXMoeyBzb3J0RGlyZWN0aW9uLCBwcmlvcml0eSB9KSB7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW3JlbmRlclNvcnRJY29uKHsgc29ydERpcmVjdGlvbiB9KSwgcmVuZGVyU29ydFByaW9yaXR5KHsgcHJpb3JpdHkgfSldIH0pO1xufVxuZnVuY3Rpb24gcmVuZGVyU29ydEljb24oeyBzb3J0RGlyZWN0aW9uIH0pIHtcblx0aWYgKHNvcnREaXJlY3Rpb24gPT09IHZvaWQgMCkgcmV0dXJuIG51bGw7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwic3ZnXCIsIHtcblx0XHR2aWV3Qm94OiBcIjAgMCAxMiA4XCIsXG5cdFx0d2lkdGg6IFwiMTJcIixcblx0XHRoZWlnaHQ6IFwiOFwiLFxuXHRcdGNsYXNzTmFtZTogYXJyb3dDbGFzc25hbWUsXG5cdFx0XCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuXHRcdGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwicGF0aFwiLCB7IGQ6IHNvcnREaXJlY3Rpb24gPT09IFwiQVNDXCIgPyBcIk0wIDggNiAwIDEyIDhcIiA6IFwiTTAgMCA2IDggMTIgMFwiIH0pXG5cdH0pO1xufVxuZnVuY3Rpb24gcmVuZGVyU29ydFByaW9yaXR5KHsgcHJpb3JpdHkgfSkge1xuXHRyZXR1cm4gcHJpb3JpdHk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9zdHlsZS9jb3JlLnRzXG5jb25zdCByb290ID0gXCJyZGctNy0wLTAtYmV0YS01OC1jY2QyZTVkOVwiO1xuY29uc3Qgcm9vdENsYXNzbmFtZSA9IGByZGcgJHtyb290fWA7XG5jb25zdCB2aWV3cG9ydERyYWdnaW5nID0gXCJyZGctNy0wLTAtYmV0YS01OC1lOWIwZTFjOVwiO1xuY29uc3Qgdmlld3BvcnREcmFnZ2luZ0NsYXNzbmFtZSA9IGByZGctdmlld3BvcnQtZHJhZ2dpbmcgJHt2aWV3cG9ydERyYWdnaW5nfWA7XG5jb25zdCBmb2N1c1NpbmtDbGFzc25hbWUgPSBcInJkZy03LTAtMC1iZXRhLTU4LWRiYjhiM2M1XCI7XG5jb25zdCBmb2N1c1NpbmtIZWFkZXJBbmRTdW1tYXJ5Q2xhc3NuYW1lID0gXCJyZGctNy0wLTAtYmV0YS01OC1lOWY1NTU0MVwiO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvU3VtbWFyeUNlbGwudHN4XG5jb25zdCBzdW1tYXJ5Q2VsbENsYXNzbmFtZSA9IFwicmRnLTctMC0wLWJldGEtNTgtZDkwN2FhODdcIjtcbmZ1bmN0aW9uIFN1bW1hcnlDZWxsKHsgY29sdW1uLCBjb2xTcGFuLCByb3c6IHJvdyQxLCByb3dJZHgsIGlzQ2VsbFNlbGVjdGVkLCBzZWxlY3RDZWxsIH0pIHtcblx0Y29uc3QgeyB0YWJJbmRleCwgY2hpbGRUYWJJbmRleCwgb25Gb2N1cyB9ID0gdXNlUm92aW5nVGFiSW5kZXgoaXNDZWxsU2VsZWN0ZWQpO1xuXHRjb25zdCB7IHN1bW1hcnlDZWxsQ2xhc3MgfSA9IGNvbHVtbjtcblx0Y29uc3QgY2xhc3NOYW1lID0gZ2V0Q2VsbENsYXNzbmFtZShjb2x1bW4sIHN1bW1hcnlDZWxsQ2xhc3NuYW1lLCB0eXBlb2Ygc3VtbWFyeUNlbGxDbGFzcyA9PT0gXCJmdW5jdGlvblwiID8gc3VtbWFyeUNlbGxDbGFzcyhyb3ckMSkgOiBzdW1tYXJ5Q2VsbENsYXNzKTtcblx0ZnVuY3Rpb24gb25Nb3VzZURvd24oKSB7XG5cdFx0c2VsZWN0Q2VsbCh7XG5cdFx0XHRyb3dJZHgsXG5cdFx0XHRpZHg6IGNvbHVtbi5pZHhcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7XG5cdFx0cm9sZTogXCJncmlkY2VsbFwiLFxuXHRcdFwiYXJpYS1jb2xpbmRleFwiOiBjb2x1bW4uaWR4ICsgMSxcblx0XHRcImFyaWEtY29sc3BhblwiOiBjb2xTcGFuLFxuXHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBpc0NlbGxTZWxlY3RlZCxcblx0XHR0YWJJbmRleCxcblx0XHRjbGFzc05hbWUsXG5cdFx0c3R5bGU6IGdldENlbGxTdHlsZShjb2x1bW4sIGNvbFNwYW4pLFxuXHRcdG9uTW91c2VEb3duLFxuXHRcdG9uRm9jdXMsXG5cdFx0Y2hpbGRyZW46IGNvbHVtbi5yZW5kZXJTdW1tYXJ5Q2VsbD8uKHtcblx0XHRcdGNvbHVtbixcblx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHR0YWJJbmRleDogY2hpbGRUYWJJbmRleFxuXHRcdH0pXG5cdH0pO1xufVxudmFyIFN1bW1hcnlDZWxsX2RlZmF1bHQgPSBtZW1vKFN1bW1hcnlDZWxsKTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1N1bW1hcnlSb3cudHN4XG5jb25zdCBzdW1tYXJ5Um93ID0gXCJyZGctNy0wLTAtYmV0YS01OC0wYjkwYzgyY1wiO1xuY29uc3QgdG9wU3VtbWFyeVJvdyA9IFwicmRnLTctMC0wLWJldGEtNTgtZDA1MjBlYWJcIjtcbmNvbnN0IHN1bW1hcnlSb3dDbGFzc25hbWUgPSBgcmRnLXN1bW1hcnktcm93ICR7c3VtbWFyeVJvd31gO1xuZnVuY3Rpb24gU3VtbWFyeVJvdyh7IHJvd0lkeCwgZ3JpZFJvd1N0YXJ0LCByb3c6IHJvdyQxLCB2aWV3cG9ydENvbHVtbnMsIHRvcCwgYm90dG9tLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHNlbGVjdGVkQ2VsbElkeCwgaXNUb3AsIHNlbGVjdENlbGwsIFwiYXJpYS1yb3dpbmRleFwiOiBhcmlhUm93SW5kZXggfSkge1xuXHRjb25zdCBjZWxscyA9IFtdO1xuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmlld3BvcnRDb2x1bW5zLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdGNvbnN0IGNvbHVtbiA9IHZpZXdwb3J0Q29sdW1uc1tpbmRleF07XG5cdFx0Y29uc3QgY29sU3BhbiA9IGdldENvbFNwYW4oY29sdW1uLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIHtcblx0XHRcdHR5cGU6IFwiU1VNTUFSWVwiLFxuXHRcdFx0cm93OiByb3ckMVxuXHRcdH0pO1xuXHRcdGlmIChjb2xTcGFuICE9PSB2b2lkIDApIGluZGV4ICs9IGNvbFNwYW4gLSAxO1xuXHRcdGNvbnN0IGlzQ2VsbFNlbGVjdGVkID0gc2VsZWN0ZWRDZWxsSWR4ID09PSBjb2x1bW4uaWR4O1xuXHRcdGNlbGxzLnB1c2goLyogQF9fUFVSRV9fICovIGpzeChTdW1tYXJ5Q2VsbF9kZWZhdWx0LCB7XG5cdFx0XHRjb2x1bW4sXG5cdFx0XHRjb2xTcGFuLFxuXHRcdFx0cm93OiByb3ckMSxcblx0XHRcdHJvd0lkeCxcblx0XHRcdGlzQ2VsbFNlbGVjdGVkLFxuXHRcdFx0c2VsZWN0Q2VsbFxuXHRcdH0sIGNvbHVtbi5rZXkpKTtcblx0fVxuXHRyZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7XG5cdFx0cm9sZTogXCJyb3dcIixcblx0XHRcImFyaWEtcm93aW5kZXhcIjogYXJpYVJvd0luZGV4LFxuXHRcdGNsYXNzTmFtZTogY2xhc3NuYW1lcyhyb3dDbGFzc25hbWUsIGByZGctcm93LSR7cm93SWR4ICUgMiA9PT0gMCA/IFwiZXZlblwiIDogXCJvZGRcIn1gLCBzdW1tYXJ5Um93Q2xhc3NuYW1lLCB7XG5cdFx0XHRbcm93U2VsZWN0ZWRDbGFzc25hbWVdOiBzZWxlY3RlZENlbGxJZHggPT09IC0xLFxuXHRcdFx0W2Ake3RvcFN1bW1hcnlSb3dDbGFzc25hbWV9ICR7dG9wU3VtbWFyeVJvd31gXTogaXNUb3AsXG5cdFx0XHRbYm90dG9tU3VtbWFyeVJvd0NsYXNzbmFtZV06ICFpc1RvcFxuXHRcdH0pLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHQuLi5nZXRSb3dTdHlsZShncmlkUm93U3RhcnQpLFxuXHRcdFx0XCItLXJkZy1zdW1tYXJ5LXJvdy10b3BcIjogdG9wICE9PSB2b2lkIDAgPyBgJHt0b3B9cHhgIDogdm9pZCAwLFxuXHRcdFx0XCItLXJkZy1zdW1tYXJ5LXJvdy1ib3R0b21cIjogYm90dG9tICE9PSB2b2lkIDAgPyBgJHtib3R0b219cHhgIDogdm9pZCAwXG5cdFx0fSxcblx0XHRjaGlsZHJlbjogY2VsbHNcblx0fSk7XG59XG52YXIgU3VtbWFyeVJvd19kZWZhdWx0ID0gbWVtbyhTdW1tYXJ5Um93KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL0RhdGFHcmlkLnRzeFxuLyoqXG4qIE1haW4gQVBJIENvbXBvbmVudCB0byByZW5kZXIgYSBkYXRhIGdyaWQgb2Ygcm93cyBhbmQgY29sdW1uc1xuKlxuKiBAZXhhbXBsZVxuKlxuKiA8RGF0YUdyaWQgY29sdW1ucz17Y29sdW1uc30gcm93cz17cm93c30gLz5cbiovXG5mdW5jdGlvbiBEYXRhR3JpZChwcm9wcykge1xuXHRjb25zdCB7IHJlZiwgY29sdW1uczogcmF3Q29sdW1ucywgcm93cywgdG9wU3VtbWFyeVJvd3MsIGJvdHRvbVN1bW1hcnlSb3dzLCByb3dLZXlHZXR0ZXIsIG9uUm93c0NoYW5nZSwgcm93SGVpZ2h0OiByYXdSb3dIZWlnaHQsIGhlYWRlclJvd0hlaWdodDogcmF3SGVhZGVyUm93SGVpZ2h0LCBzdW1tYXJ5Um93SGVpZ2h0OiByYXdTdW1tYXJ5Um93SGVpZ2h0LCBjb2x1bW5XaWR0aHM6IGNvbHVtbldpZHRoc1Jhdywgb25Db2x1bW5XaWR0aHNDaGFuZ2U6IG9uQ29sdW1uV2lkdGhzQ2hhbmdlUmF3LCBzZWxlY3RlZFJvd3MsIGlzUm93U2VsZWN0aW9uRGlzYWJsZWQsIG9uU2VsZWN0ZWRSb3dzQ2hhbmdlLCBzb3J0Q29sdW1ucywgb25Tb3J0Q29sdW1uc0NoYW5nZSwgZGVmYXVsdENvbHVtbk9wdGlvbnMsIG9uQ2VsbE1vdXNlRG93biwgb25DZWxsQ2xpY2ssIG9uQ2VsbERvdWJsZUNsaWNrLCBvbkNlbGxDb250ZXh0TWVudSwgb25DZWxsS2V5RG93biwgb25TZWxlY3RlZENlbGxDaGFuZ2UsIG9uU2Nyb2xsLCBvbkNvbHVtblJlc2l6ZSwgb25Db2x1bW5zUmVvcmRlciwgb25GaWxsLCBvbkNlbGxDb3B5LCBvbkNlbGxQYXN0ZSwgZW5hYmxlVmlydHVhbGl6YXRpb246IHJhd0VuYWJsZVZpcnR1YWxpemF0aW9uLCByZW5kZXJlcnMsIGNsYXNzTmFtZSwgc3R5bGUsIHJvd0NsYXNzLCBoZWFkZXJSb3dDbGFzcywgZGlyZWN0aW9uOiByYXdEaXJlY3Rpb24sIHJvbGU6IHJhd1JvbGUsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LCBcImFyaWEtZGVzY3JpcHRpb25cIjogYXJpYURlc2NyaXB0aW9uLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5LCBcImFyaWEtcm93Y291bnRcIjogcmF3QXJpYVJvd0NvdW50LCBcImRhdGEtdGVzdGlkXCI6IHRlc3RJZCwgXCJkYXRhLWN5XCI6IGRhdGFDeSB9ID0gcHJvcHM7XG5cdC8qKlxuXHQqIGRlZmF1bHRzXG5cdCovXG5cdGNvbnN0IGRlZmF1bHRSZW5kZXJlcnMgPSB1c2VEZWZhdWx0UmVuZGVyZXJzKCk7XG5cdGNvbnN0IHJvbGUgPSByYXdSb2xlID8/IFwiZ3JpZFwiO1xuXHRjb25zdCByb3dIZWlnaHQgPSByYXdSb3dIZWlnaHQgPz8gMzU7XG5cdGNvbnN0IGhlYWRlclJvd0hlaWdodCA9IHJhd0hlYWRlclJvd0hlaWdodCA/PyAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIiA/IHJvd0hlaWdodCA6IDM1KTtcblx0Y29uc3Qgc3VtbWFyeVJvd0hlaWdodCA9IHJhd1N1bW1hcnlSb3dIZWlnaHQgPz8gKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIgPyByb3dIZWlnaHQgOiAzNSk7XG5cdGNvbnN0IHJlbmRlclJvdyA9IHJlbmRlcmVycz8ucmVuZGVyUm93ID8/IGRlZmF1bHRSZW5kZXJlcnM/LnJlbmRlclJvdyA/PyBkZWZhdWx0UmVuZGVyUm93O1xuXHRjb25zdCByZW5kZXJDZWxsID0gcmVuZGVyZXJzPy5yZW5kZXJDZWxsID8/IGRlZmF1bHRSZW5kZXJlcnM/LnJlbmRlckNlbGwgPz8gZGVmYXVsdFJlbmRlckNlbGw7XG5cdGNvbnN0IHJlbmRlclNvcnRTdGF0dXMkMSA9IHJlbmRlcmVycz8ucmVuZGVyU29ydFN0YXR1cyA/PyBkZWZhdWx0UmVuZGVyZXJzPy5yZW5kZXJTb3J0U3RhdHVzID8/IHJlbmRlclNvcnRTdGF0dXM7XG5cdGNvbnN0IHJlbmRlckNoZWNrYm94JDEgPSByZW5kZXJlcnM/LnJlbmRlckNoZWNrYm94ID8/IGRlZmF1bHRSZW5kZXJlcnM/LnJlbmRlckNoZWNrYm94ID8/IHJlbmRlckNoZWNrYm94O1xuXHRjb25zdCBub1Jvd3NGYWxsYmFjayA9IHJlbmRlcmVycz8ubm9Sb3dzRmFsbGJhY2sgPz8gZGVmYXVsdFJlbmRlcmVycz8ubm9Sb3dzRmFsbGJhY2s7XG5cdGNvbnN0IGVuYWJsZVZpcnR1YWxpemF0aW9uID0gcmF3RW5hYmxlVmlydHVhbGl6YXRpb24gPz8gdHJ1ZTtcblx0Y29uc3QgZGlyZWN0aW9uID0gcmF3RGlyZWN0aW9uID8/IFwibHRyXCI7XG5cdC8qKlxuXHQqIHN0YXRlc1xuXHQqL1xuXHRjb25zdCBbc2Nyb2xsVG9wLCBzZXRTY3JvbGxUb3BdID0gdXNlU3RhdGUoMCk7XG5cdGNvbnN0IFtzY3JvbGxMZWZ0LCBzZXRTY3JvbGxMZWZ0XSA9IHVzZVN0YXRlKDApO1xuXHRjb25zdCBbY29sdW1uV2lkdGhzSW50ZXJuYWwsIHNldENvbHVtbldpZHRoc0ludGVybmFsXSA9IHVzZVN0YXRlKCgpID0+IGNvbHVtbldpZHRoc1JhdyA/PyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcblx0Y29uc3QgW2lzQ29sdW1uUmVzaXppbmcsIHNldENvbHVtblJlc2l6aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblx0Y29uc3QgW2lzRHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblx0Y29uc3QgW2RyYWdnZWRPdmVyUm93SWR4LCBzZXREcmFnZ2VkT3ZlclJvd0lkeF0gPSB1c2VTdGF0ZSh2b2lkIDApO1xuXHRjb25zdCBbc2Nyb2xsVG9Qb3NpdGlvbiwgc2V0U2Nyb2xsVG9Qb3NpdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcblx0Y29uc3QgW3Nob3VsZEZvY3VzQ2VsbCwgc2V0U2hvdWxkRm9jdXNDZWxsXSA9IHVzZVN0YXRlKGZhbHNlKTtcblx0Y29uc3QgW3ByZXZpb3VzUm93SWR4LCBzZXRQcmV2aW91c1Jvd0lkeF0gPSB1c2VTdGF0ZSgtMSk7XG5cdGNvbnN0IGlzQ29sdW1uV2lkdGhzQ29udHJvbGxlZCA9IGNvbHVtbldpZHRoc1JhdyAhPSBudWxsICYmIG9uQ29sdW1uV2lkdGhzQ2hhbmdlUmF3ICE9IG51bGwgJiYgIWlzQ29sdW1uUmVzaXppbmc7XG5cdGNvbnN0IGNvbHVtbldpZHRocyA9IGlzQ29sdW1uV2lkdGhzQ29udHJvbGxlZCA/IGNvbHVtbldpZHRoc1JhdyA6IGNvbHVtbldpZHRoc0ludGVybmFsO1xuXHRjb25zdCBvbkNvbHVtbldpZHRoc0NoYW5nZSA9IGlzQ29sdW1uV2lkdGhzQ29udHJvbGxlZCA/IChjb2x1bW5XaWR0aHMkMSkgPT4ge1xuXHRcdHNldENvbHVtbldpZHRoc0ludGVybmFsKGNvbHVtbldpZHRocyQxKTtcblx0XHRvbkNvbHVtbldpZHRoc0NoYW5nZVJhdyhjb2x1bW5XaWR0aHMkMSk7XG5cdH0gOiBzZXRDb2x1bW5XaWR0aHNJbnRlcm5hbDtcblx0Y29uc3QgZ2V0Q29sdW1uV2lkdGggPSB1c2VDYWxsYmFjaygoY29sdW1uKSA9PiB7XG5cdFx0cmV0dXJuIGNvbHVtbldpZHRocy5nZXQoY29sdW1uLmtleSk/LndpZHRoID8/IGNvbHVtbi53aWR0aDtcblx0fSwgW2NvbHVtbldpZHRoc10pO1xuXHRjb25zdCBbZ3JpZFJlZiwgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0LCBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XSA9IHVzZUdyaWREaW1lbnNpb25zKCk7XG5cdGNvbnN0IHsgY29sdW1ucywgY29sU3BhbkNvbHVtbnMsIGxhc3RGcm96ZW5Db2x1bW5JbmRleCwgaGVhZGVyUm93c0NvdW50LCBjb2xPdmVyc2NhblN0YXJ0SWR4LCBjb2xPdmVyc2NhbkVuZElkeCwgdGVtcGxhdGVDb2x1bW5zLCBsYXlvdXRDc3NWYXJzLCB0b3RhbEZyb3plbkNvbHVtbldpZHRoIH0gPSB1c2VDYWxjdWxhdGVkQ29sdW1ucyh7XG5cdFx0cmF3Q29sdW1ucyxcblx0XHRkZWZhdWx0Q29sdW1uT3B0aW9ucyxcblx0XHRnZXRDb2x1bW5XaWR0aCxcblx0XHRzY3JvbGxMZWZ0LFxuXHRcdHZpZXdwb3J0V2lkdGg6IGdyaWRXaWR0aCxcblx0XHRlbmFibGVWaXJ0dWFsaXphdGlvblxuXHR9KTtcblx0Y29uc3QgdG9wU3VtbWFyeVJvd3NDb3VudCA9IHRvcFN1bW1hcnlSb3dzPy5sZW5ndGggPz8gMDtcblx0Y29uc3QgYm90dG9tU3VtbWFyeVJvd3NDb3VudCA9IGJvdHRvbVN1bW1hcnlSb3dzPy5sZW5ndGggPz8gMDtcblx0Y29uc3Qgc3VtbWFyeVJvd3NDb3VudCA9IHRvcFN1bW1hcnlSb3dzQ291bnQgKyBib3R0b21TdW1tYXJ5Um93c0NvdW50O1xuXHRjb25zdCBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ID0gaGVhZGVyUm93c0NvdW50ICsgdG9wU3VtbWFyeVJvd3NDb3VudDtcblx0Y29uc3QgZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudCA9IGhlYWRlclJvd3NDb3VudCAtIDE7XG5cdGNvbnN0IG1pblJvd0lkeCA9IC1oZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50O1xuXHRjb25zdCBtYWluSGVhZGVyUm93SWR4ID0gbWluUm93SWR4ICsgZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudDtcblx0Y29uc3QgbWF4Um93SWR4ID0gcm93cy5sZW5ndGggKyBib3R0b21TdW1tYXJ5Um93c0NvdW50IC0gMTtcblx0Y29uc3QgW3NlbGVjdGVkUG9zaXRpb24sIHNldFNlbGVjdGVkUG9zaXRpb25dID0gdXNlU3RhdGUoKCkgPT4gKHtcblx0XHRpZHg6IC0xLFxuXHRcdHJvd0lkeDogbWluUm93SWR4IC0gMSxcblx0XHRtb2RlOiBcIlNFTEVDVFwiXG5cdH0pKTtcblx0LyoqXG5cdCogcmVmc1xuXHQqL1xuXHRjb25zdCBmb2N1c1NpbmtSZWYgPSB1c2VSZWYobnVsbCk7XG5cdC8qKlxuXHQqIGNvbXB1dGVkIHZhbHVlc1xuXHQqL1xuXHRjb25zdCBpc1RyZWVHcmlkID0gcm9sZSA9PT0gXCJ0cmVlZ3JpZFwiO1xuXHRjb25zdCBoZWFkZXJSb3dzSGVpZ2h0ID0gaGVhZGVyUm93c0NvdW50ICogaGVhZGVyUm93SGVpZ2h0O1xuXHRjb25zdCBzdW1tYXJ5Um93c0hlaWdodCA9IHN1bW1hcnlSb3dzQ291bnQgKiBzdW1tYXJ5Um93SGVpZ2h0O1xuXHRjb25zdCBjbGllbnRIZWlnaHQgPSBncmlkSGVpZ2h0IC0gaGVhZGVyUm93c0hlaWdodCAtIHN1bW1hcnlSb3dzSGVpZ2h0O1xuXHRjb25zdCBpc1NlbGVjdGFibGUgPSBzZWxlY3RlZFJvd3MgIT0gbnVsbCAmJiBvblNlbGVjdGVkUm93c0NoYW5nZSAhPSBudWxsO1xuXHRjb25zdCB7IGxlZnRLZXksIHJpZ2h0S2V5IH0gPSBnZXRMZWZ0UmlnaHRLZXkoZGlyZWN0aW9uKTtcblx0Y29uc3QgYXJpYVJvd0NvdW50ID0gcmF3QXJpYVJvd0NvdW50ID8/IGhlYWRlclJvd3NDb3VudCArIHJvd3MubGVuZ3RoICsgc3VtbWFyeVJvd3NDb3VudDtcblx0Y29uc3QgZGVmYXVsdEdyaWRDb21wb25lbnRzID0gdXNlTWVtbygoKSA9PiAoe1xuXHRcdHJlbmRlckNoZWNrYm94OiByZW5kZXJDaGVja2JveCQxLFxuXHRcdHJlbmRlclNvcnRTdGF0dXM6IHJlbmRlclNvcnRTdGF0dXMkMSxcblx0XHRyZW5kZXJDZWxsXG5cdH0pLCBbXG5cdFx0cmVuZGVyQ2hlY2tib3gkMSxcblx0XHRyZW5kZXJTb3J0U3RhdHVzJDEsXG5cdFx0cmVuZGVyQ2VsbFxuXHRdKTtcblx0Y29uc3QgaGVhZGVyU2VsZWN0aW9uVmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcblx0XHRsZXQgaGFzU2VsZWN0ZWRSb3cgPSBmYWxzZTtcblx0XHRsZXQgaGFzVW5zZWxlY3RlZFJvdyA9IGZhbHNlO1xuXHRcdGlmIChyb3dLZXlHZXR0ZXIgIT0gbnVsbCAmJiBzZWxlY3RlZFJvd3MgIT0gbnVsbCAmJiBzZWxlY3RlZFJvd3Muc2l6ZSA+IDApIGZvciAoY29uc3Qgcm93JDEgb2Ygcm93cykge1xuXHRcdFx0aWYgKHNlbGVjdGVkUm93cy5oYXMocm93S2V5R2V0dGVyKHJvdyQxKSkpIGhhc1NlbGVjdGVkUm93ID0gdHJ1ZTtcblx0XHRcdGVsc2UgaGFzVW5zZWxlY3RlZFJvdyA9IHRydWU7XG5cdFx0XHRpZiAoaGFzU2VsZWN0ZWRSb3cgJiYgaGFzVW5zZWxlY3RlZFJvdykgYnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRpc1Jvd1NlbGVjdGVkOiBoYXNTZWxlY3RlZFJvdyAmJiAhaGFzVW5zZWxlY3RlZFJvdyxcblx0XHRcdGlzSW5kZXRlcm1pbmF0ZTogaGFzU2VsZWN0ZWRSb3cgJiYgaGFzVW5zZWxlY3RlZFJvd1xuXHRcdH07XG5cdH0sIFtcblx0XHRyb3dzLFxuXHRcdHNlbGVjdGVkUm93cyxcblx0XHRyb3dLZXlHZXR0ZXJcblx0XSk7XG5cdGNvbnN0IHsgcm93T3ZlcnNjYW5TdGFydElkeCwgcm93T3ZlcnNjYW5FbmRJZHgsIHRvdGFsUm93SGVpZ2h0LCBncmlkVGVtcGxhdGVSb3dzLCBnZXRSb3dUb3AsIGdldFJvd0hlaWdodCwgZmluZFJvd0lkeCB9ID0gdXNlVmlld3BvcnRSb3dzKHtcblx0XHRyb3dzLFxuXHRcdHJvd0hlaWdodCxcblx0XHRjbGllbnRIZWlnaHQsXG5cdFx0c2Nyb2xsVG9wLFxuXHRcdGVuYWJsZVZpcnR1YWxpemF0aW9uXG5cdH0pO1xuXHRjb25zdCB2aWV3cG9ydENvbHVtbnMgPSB1c2VWaWV3cG9ydENvbHVtbnMoe1xuXHRcdGNvbHVtbnMsXG5cdFx0Y29sU3BhbkNvbHVtbnMsXG5cdFx0Y29sT3ZlcnNjYW5TdGFydElkeCxcblx0XHRjb2xPdmVyc2NhbkVuZElkeCxcblx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0cm93T3ZlcnNjYW5TdGFydElkeCxcblx0XHRyb3dPdmVyc2NhbkVuZElkeCxcblx0XHRyb3dzLFxuXHRcdHRvcFN1bW1hcnlSb3dzLFxuXHRcdGJvdHRvbVN1bW1hcnlSb3dzXG5cdH0pO1xuXHRjb25zdCB7IGdyaWRUZW1wbGF0ZUNvbHVtbnMsIGhhbmRsZUNvbHVtblJlc2l6ZSB9ID0gdXNlQ29sdW1uV2lkdGhzKGNvbHVtbnMsIHZpZXdwb3J0Q29sdW1ucywgdGVtcGxhdGVDb2x1bW5zLCBncmlkUmVmLCBncmlkV2lkdGgsIGNvbHVtbldpZHRocywgb25Db2x1bW5XaWR0aHNDaGFuZ2UsIG9uQ29sdW1uUmVzaXplLCBzZXRDb2x1bW5SZXNpemluZyk7XG5cdGNvbnN0IG1pbkNvbElkeCA9IGlzVHJlZUdyaWQgPyAtMSA6IDA7XG5cdGNvbnN0IG1heENvbElkeCA9IGNvbHVtbnMubGVuZ3RoIC0gMTtcblx0Y29uc3Qgc2VsZWN0ZWRDZWxsSXNXaXRoaW5TZWxlY3Rpb25Cb3VuZHMgPSBpc0NlbGxXaXRoaW5TZWxlY3Rpb25Cb3VuZHMoc2VsZWN0ZWRQb3NpdGlvbik7XG5cdGNvbnN0IHNlbGVjdGVkQ2VsbElzV2l0aGluVmlld3BvcnRCb3VuZHMgPSBpc0NlbGxXaXRoaW5WaWV3cG9ydEJvdW5kcyhzZWxlY3RlZFBvc2l0aW9uKTtcblx0Y29uc3Qgc2Nyb2xsSGVpZ2h0ID0gaGVhZGVyUm93SGVpZ2h0ICsgdG90YWxSb3dIZWlnaHQgKyBzdW1tYXJ5Um93c0hlaWdodCArIGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQ7XG5cdC8qKlxuXHQqIFRoZSBpZGVudGl0eSBvZiB0aGUgd3JhcHBlciBmdW5jdGlvbiBpcyBzdGFibGUgc28gaXQgd29uJ3QgYnJlYWsgbWVtb2l6YXRpb25cblx0Ki9cblx0Y29uc3QgaGFuZGxlQ29sdW1uUmVzaXplTGF0ZXN0ID0gdXNlTGF0ZXN0RnVuYyhoYW5kbGVDb2x1bW5SZXNpemUpO1xuXHRjb25zdCBoYW5kbGVDb2x1bW5SZXNpemVFbmRMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKGhhbmRsZUNvbHVtblJlc2l6ZUVuZCk7XG5cdGNvbnN0IG9uQ29sdW1uc1Jlb3JkZXJMYXN0ZXN0ID0gdXNlTGF0ZXN0RnVuYyhvbkNvbHVtbnNSZW9yZGVyKTtcblx0Y29uc3Qgb25Tb3J0Q29sdW1uc0NoYW5nZUxhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25Tb3J0Q29sdW1uc0NoYW5nZSk7XG5cdGNvbnN0IG9uQ2VsbE1vdXNlRG93bkxhdGVzdCA9IHVzZUxhdGVzdEZ1bmMob25DZWxsTW91c2VEb3duKTtcblx0Y29uc3Qgb25DZWxsQ2xpY2tMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKG9uQ2VsbENsaWNrKTtcblx0Y29uc3Qgb25DZWxsRG91YmxlQ2xpY2tMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKG9uQ2VsbERvdWJsZUNsaWNrKTtcblx0Y29uc3Qgb25DZWxsQ29udGV4dE1lbnVMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKG9uQ2VsbENvbnRleHRNZW51KTtcblx0Y29uc3Qgc2VsZWN0SGVhZGVyUm93TGF0ZXN0ID0gdXNlTGF0ZXN0RnVuYyhzZWxlY3RIZWFkZXJSb3cpO1xuXHRjb25zdCBzZWxlY3RSb3dMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKHNlbGVjdFJvdyk7XG5cdGNvbnN0IGhhbmRsZUZvcm1hdHRlclJvd0NoYW5nZUxhdGVzdCA9IHVzZUxhdGVzdEZ1bmModXBkYXRlUm93KTtcblx0Y29uc3Qgc2VsZWN0Q2VsbExhdGVzdCA9IHVzZUxhdGVzdEZ1bmMoc2VsZWN0Q2VsbCk7XG5cdGNvbnN0IHNlbGVjdEhlYWRlckNlbGxMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKHNlbGVjdEhlYWRlckNlbGwpO1xuXHQvKipcblx0KiBjYWxsYmFja3Ncblx0Ki9cblx0Y29uc3QgZm9jdXNDZWxsID0gdXNlQ2FsbGJhY2soKHNob3VsZFNjcm9sbCA9IHRydWUpID0+IHtcblx0XHRjb25zdCBjZWxsJDEgPSBnZXRDZWxsVG9TY3JvbGwoZ3JpZFJlZi5jdXJyZW50KTtcblx0XHRpZiAoY2VsbCQxID09PSBudWxsKSByZXR1cm47XG5cdFx0aWYgKHNob3VsZFNjcm9sbCkgc2Nyb2xsSW50b1ZpZXcoY2VsbCQxKTtcblx0XHRjZWxsJDEuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuXHR9LCBbZ3JpZFJlZl0pO1xuXHQvKipcblx0KiBlZmZlY3RzXG5cdCovXG5cdHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKHNob3VsZEZvY3VzQ2VsbCkge1xuXHRcdFx0aWYgKGZvY3VzU2lua1JlZi5jdXJyZW50ICE9PSBudWxsICYmIHNlbGVjdGVkUG9zaXRpb24uaWR4ID09PSAtMSkge1xuXHRcdFx0XHRmb2N1c1NpbmtSZWYuY3VycmVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG5cdFx0XHRcdHNjcm9sbEludG9WaWV3KGZvY3VzU2lua1JlZi5jdXJyZW50KTtcblx0XHRcdH0gZWxzZSBmb2N1c0NlbGwoKTtcblx0XHRcdHNldFNob3VsZEZvY3VzQ2VsbChmYWxzZSk7XG5cdFx0fVxuXHR9LCBbXG5cdFx0c2hvdWxkRm9jdXNDZWxsLFxuXHRcdGZvY3VzQ2VsbCxcblx0XHRzZWxlY3RlZFBvc2l0aW9uLmlkeFxuXHRdKTtcblx0dXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XG5cdFx0ZWxlbWVudDogZ3JpZFJlZi5jdXJyZW50LFxuXHRcdHNjcm9sbFRvQ2VsbCh7IGlkeCwgcm93SWR4IH0pIHtcblx0XHRcdGNvbnN0IHNjcm9sbFRvSWR4ID0gaWR4ICE9PSB2b2lkIDAgJiYgaWR4ID4gbGFzdEZyb3plbkNvbHVtbkluZGV4ICYmIGlkeCA8IGNvbHVtbnMubGVuZ3RoID8gaWR4IDogdm9pZCAwO1xuXHRcdFx0Y29uc3Qgc2Nyb2xsVG9Sb3dJZHggPSByb3dJZHggIT09IHZvaWQgMCAmJiBpc1Jvd0lkeFdpdGhpblZpZXdwb3J0Qm91bmRzKHJvd0lkeCkgPyByb3dJZHggOiB2b2lkIDA7XG5cdFx0XHRpZiAoc2Nyb2xsVG9JZHggIT09IHZvaWQgMCB8fCBzY3JvbGxUb1Jvd0lkeCAhPT0gdm9pZCAwKSBzZXRTY3JvbGxUb1Bvc2l0aW9uKHtcblx0XHRcdFx0aWR4OiBzY3JvbGxUb0lkeCxcblx0XHRcdFx0cm93SWR4OiBzY3JvbGxUb1Jvd0lkeFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRzZWxlY3RDZWxsXG5cdH0pKTtcblx0LyoqXG5cdCogZXZlbnQgaGFuZGxlcnNcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0SGVhZGVyUm93KGFyZ3MpIHtcblx0XHRpZiAoIW9uU2VsZWN0ZWRSb3dzQ2hhbmdlKSByZXR1cm47XG5cdFx0YXNzZXJ0SXNWYWxpZEtleUdldHRlcihyb3dLZXlHZXR0ZXIpO1xuXHRcdGNvbnN0IG5ld1NlbGVjdGVkUm93cyA9IG5ldyBTZXQoc2VsZWN0ZWRSb3dzKTtcblx0XHRmb3IgKGNvbnN0IHJvdyQxIG9mIHJvd3MpIHtcblx0XHRcdGlmIChpc1Jvd1NlbGVjdGlvbkRpc2FibGVkPy4ocm93JDEpID09PSB0cnVlKSBjb250aW51ZTtcblx0XHRcdGNvbnN0IHJvd0tleSA9IHJvd0tleUdldHRlcihyb3ckMSk7XG5cdFx0XHRpZiAoYXJncy5jaGVja2VkKSBuZXdTZWxlY3RlZFJvd3MuYWRkKHJvd0tleSk7XG5cdFx0XHRlbHNlIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5KTtcblx0XHR9XG5cdFx0b25TZWxlY3RlZFJvd3NDaGFuZ2UobmV3U2VsZWN0ZWRSb3dzKTtcblx0fVxuXHRmdW5jdGlvbiBzZWxlY3RSb3coYXJncykge1xuXHRcdGlmICghb25TZWxlY3RlZFJvd3NDaGFuZ2UpIHJldHVybjtcblx0XHRhc3NlcnRJc1ZhbGlkS2V5R2V0dGVyKHJvd0tleUdldHRlcik7XG5cdFx0Y29uc3QgeyByb3c6IHJvdyQxLCBjaGVja2VkLCBpc1NoaWZ0Q2xpY2sgfSA9IGFyZ3M7XG5cdFx0aWYgKGlzUm93U2VsZWN0aW9uRGlzYWJsZWQ/Lihyb3ckMSkgPT09IHRydWUpIHJldHVybjtcblx0XHRjb25zdCBuZXdTZWxlY3RlZFJvd3MgPSBuZXcgU2V0KHNlbGVjdGVkUm93cyk7XG5cdFx0Y29uc3Qgcm93S2V5ID0gcm93S2V5R2V0dGVyKHJvdyQxKTtcblx0XHRjb25zdCByb3dJZHggPSByb3dzLmluZGV4T2Yocm93JDEpO1xuXHRcdHNldFByZXZpb3VzUm93SWR4KHJvd0lkeCk7XG5cdFx0aWYgKGNoZWNrZWQpIG5ld1NlbGVjdGVkUm93cy5hZGQocm93S2V5KTtcblx0XHRlbHNlIG5ld1NlbGVjdGVkUm93cy5kZWxldGUocm93S2V5KTtcblx0XHRpZiAoaXNTaGlmdENsaWNrICYmIHByZXZpb3VzUm93SWR4ICE9PSAtMSAmJiBwcmV2aW91c1Jvd0lkeCAhPT0gcm93SWR4ICYmIHByZXZpb3VzUm93SWR4IDwgcm93cy5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IHN0ZXAgPSBzaWduKHJvd0lkeCAtIHByZXZpb3VzUm93SWR4KTtcblx0XHRcdGZvciAobGV0IGkgPSBwcmV2aW91c1Jvd0lkeCArIHN0ZXA7IGkgIT09IHJvd0lkeDsgaSArPSBzdGVwKSB7XG5cdFx0XHRcdGNvbnN0IHJvdyQyID0gcm93c1tpXTtcblx0XHRcdFx0aWYgKGlzUm93U2VsZWN0aW9uRGlzYWJsZWQ/Lihyb3ckMikgPT09IHRydWUpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAoY2hlY2tlZCkgbmV3U2VsZWN0ZWRSb3dzLmFkZChyb3dLZXlHZXR0ZXIocm93JDIpKTtcblx0XHRcdFx0ZWxzZSBuZXdTZWxlY3RlZFJvd3MuZGVsZXRlKHJvd0tleUdldHRlcihyb3ckMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRvblNlbGVjdGVkUm93c0NoYW5nZShuZXdTZWxlY3RlZFJvd3MpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcblx0XHRjb25zdCB7IGlkeCwgcm93SWR4LCBtb2RlIH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuXHRcdGlmIChtb2RlID09PSBcIkVESVRcIikgcmV0dXJuO1xuXHRcdGlmIChvbkNlbGxLZXlEb3duICYmIGlzUm93SWR4V2l0aGluVmlld3BvcnRCb3VuZHMocm93SWR4KSkge1xuXHRcdFx0Y29uc3Qgcm93JDEgPSByb3dzW3Jvd0lkeF07XG5cdFx0XHRjb25zdCBjZWxsRXZlbnQgPSBjcmVhdGVDZWxsRXZlbnQoZXZlbnQpO1xuXHRcdFx0b25DZWxsS2V5RG93bih7XG5cdFx0XHRcdG1vZGU6IFwiU0VMRUNUXCIsXG5cdFx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRcdGNvbHVtbjogY29sdW1uc1tpZHhdLFxuXHRcdFx0XHRyb3dJZHgsXG5cdFx0XHRcdHNlbGVjdENlbGxcblx0XHRcdH0sIGNlbGxFdmVudCk7XG5cdFx0XHRpZiAoY2VsbEV2ZW50LmlzR3JpZERlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuXHRcdGNvbnN0IGlzQ2VsbEV2ZW50ID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCIucmRnLWNlbGxcIikgIT09IG51bGw7XG5cdFx0Y29uc3QgaXNSb3dFdmVudCA9IGlzVHJlZUdyaWQgJiYgZXZlbnQudGFyZ2V0ID09PSBmb2N1c1NpbmtSZWYuY3VycmVudDtcblx0XHRpZiAoIWlzQ2VsbEV2ZW50ICYmICFpc1Jvd0V2ZW50KSByZXR1cm47XG5cdFx0c3dpdGNoIChldmVudC5rZXkpIHtcblx0XHRcdGNhc2UgXCJBcnJvd1VwXCI6XG5cdFx0XHRjYXNlIFwiQXJyb3dEb3duXCI6XG5cdFx0XHRjYXNlIFwiQXJyb3dMZWZ0XCI6XG5cdFx0XHRjYXNlIFwiQXJyb3dSaWdodFwiOlxuXHRcdFx0Y2FzZSBcIlRhYlwiOlxuXHRcdFx0Y2FzZSBcIkhvbWVcIjpcblx0XHRcdGNhc2UgXCJFbmRcIjpcblx0XHRcdGNhc2UgXCJQYWdlVXBcIjpcblx0XHRcdGNhc2UgXCJQYWdlRG93blwiOlxuXHRcdFx0XHRuYXZpZ2F0ZShldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aGFuZGxlQ2VsbElucHV0KGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZVNjcm9sbChldmVudCkge1xuXHRcdGNvbnN0IHsgc2Nyb2xsVG9wOiBzY3JvbGxUb3AkMSwgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCQxIH0gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXHRcdGZsdXNoU3luYygoKSA9PiB7XG5cdFx0XHRzZXRTY3JvbGxUb3Aoc2Nyb2xsVG9wJDEpO1xuXHRcdFx0c2V0U2Nyb2xsTGVmdChhYnMoc2Nyb2xsTGVmdCQxKSk7XG5cdFx0fSk7XG5cdFx0b25TY3JvbGw/LihldmVudCk7XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlUm93KGNvbHVtbiwgcm93SWR4LCByb3ckMSkge1xuXHRcdGlmICh0eXBlb2Ygb25Sb3dzQ2hhbmdlICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybjtcblx0XHRpZiAocm93JDEgPT09IHJvd3Nbcm93SWR4XSkgcmV0dXJuO1xuXHRcdG9uUm93c0NoYW5nZShyb3dzLndpdGgocm93SWR4LCByb3ckMSksIHtcblx0XHRcdGluZGV4ZXM6IFtyb3dJZHhdLFxuXHRcdFx0Y29sdW1uXG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gY29tbWl0RWRpdG9yQ2hhbmdlcygpIHtcblx0XHRpZiAoc2VsZWN0ZWRQb3NpdGlvbi5tb2RlICE9PSBcIkVESVRcIikgcmV0dXJuO1xuXHRcdHVwZGF0ZVJvdyhjb2x1bW5zW3NlbGVjdGVkUG9zaXRpb24uaWR4XSwgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHgsIHNlbGVjdGVkUG9zaXRpb24ucm93KTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVDZWxsQ29weShldmVudCkge1xuXHRcdGlmICghc2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcykgcmV0dXJuO1xuXHRcdGNvbnN0IHsgaWR4LCByb3dJZHggfSA9IHNlbGVjdGVkUG9zaXRpb247XG5cdFx0b25DZWxsQ29weT8uKHtcblx0XHRcdHJvdzogcm93c1tyb3dJZHhdLFxuXHRcdFx0Y29sdW1uOiBjb2x1bW5zW2lkeF1cblx0XHR9LCBldmVudCk7XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlQ2VsbFBhc3RlKGV2ZW50KSB7XG5cdFx0aWYgKCFvbkNlbGxQYXN0ZSB8fCAhb25Sb3dzQ2hhbmdlIHx8ICFpc0NlbGxFZGl0YWJsZShzZWxlY3RlZFBvc2l0aW9uKSkgcmV0dXJuO1xuXHRcdGNvbnN0IHsgaWR4LCByb3dJZHggfSA9IHNlbGVjdGVkUG9zaXRpb247XG5cdFx0Y29uc3QgY29sdW1uID0gY29sdW1uc1tpZHhdO1xuXHRcdHVwZGF0ZVJvdyhjb2x1bW4sIHJvd0lkeCwgb25DZWxsUGFzdGUoe1xuXHRcdFx0cm93OiByb3dzW3Jvd0lkeF0sXG5cdFx0XHRjb2x1bW5cblx0XHR9LCBldmVudCkpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZUNlbGxJbnB1dChldmVudCkge1xuXHRcdGlmICghc2VsZWN0ZWRDZWxsSXNXaXRoaW5WaWV3cG9ydEJvdW5kcykgcmV0dXJuO1xuXHRcdGNvbnN0IHJvdyQxID0gcm93c1tzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeF07XG5cdFx0Y29uc3QgeyBrZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblx0XHRpZiAoaXNTZWxlY3RhYmxlICYmIHNoaWZ0S2V5ICYmIGtleSA9PT0gXCIgXCIpIHtcblx0XHRcdGFzc2VydElzVmFsaWRLZXlHZXR0ZXIocm93S2V5R2V0dGVyKTtcblx0XHRcdGNvbnN0IHJvd0tleSA9IHJvd0tleUdldHRlcihyb3ckMSk7XG5cdFx0XHRzZWxlY3RSb3coe1xuXHRcdFx0XHRyb3c6IHJvdyQxLFxuXHRcdFx0XHRjaGVja2VkOiAhc2VsZWN0ZWRSb3dzLmhhcyhyb3dLZXkpLFxuXHRcdFx0XHRpc1NoaWZ0Q2xpY2s6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChpc0NlbGxFZGl0YWJsZShzZWxlY3RlZFBvc2l0aW9uKSAmJiBpc0RlZmF1bHRDZWxsSW5wdXQoZXZlbnQsIG9uQ2VsbFBhc3RlICE9IG51bGwpKSBzZXRTZWxlY3RlZFBvc2l0aW9uKCh7IGlkeCwgcm93SWR4IH0pID0+ICh7XG5cdFx0XHRpZHgsXG5cdFx0XHRyb3dJZHgsXG5cdFx0XHRtb2RlOiBcIkVESVRcIixcblx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRvcmlnaW5hbFJvdzogcm93JDFcblx0XHR9KSk7XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlQ29sdW1uUmVzaXplRW5kKCkge1xuXHRcdGlmIChpc0NvbHVtblJlc2l6aW5nKSB7XG5cdFx0XHRvbkNvbHVtbldpZHRoc0NoYW5nZVJhdz8uKGNvbHVtbldpZHRocyk7XG5cdFx0XHRzZXRDb2x1bW5SZXNpemluZyhmYWxzZSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZURyYWdIYW5kbGVQb2ludGVyRG93bihldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0aWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgJiYgZXZlbnQuYnV0dG9ucyAhPT0gMSkgcmV0dXJuO1xuXHRcdHNldERyYWdnaW5nKHRydWUpO1xuXHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVEcmFnSGFuZGxlUG9pbnRlck1vdmUoZXZlbnQpIHtcblx0XHRjb25zdCBncmlkRWwgPSBncmlkUmVmLmN1cnJlbnQ7XG5cdFx0Y29uc3Qgb3ZlclJvd0lkeCA9IGZpbmRSb3dJZHgoc2Nyb2xsVG9wIC0gKGhlYWRlclJvd3NIZWlnaHQgKyB0b3BTdW1tYXJ5Um93c0NvdW50ICogc3VtbWFyeVJvd0hlaWdodCkgKyBldmVudC5jbGllbnRZIC0gZ3JpZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG5cdFx0c2V0RHJhZ2dlZE92ZXJSb3dJZHgob3ZlclJvd0lkeCk7XG5cdFx0Y29uc3QgYXJpYVJvd0luZGV4ID0gaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIG92ZXJSb3dJZHggKyAxO1xuXHRcdHNjcm9sbEludG9WaWV3KGdyaWRFbC5xdWVyeVNlbGVjdG9yKGA6c2NvcGUgPiBbYXJpYS1yb3dpbmRleD1cIiR7YXJpYVJvd0luZGV4fVwiXSA+IFthcmlhLWNvbGluZGV4PVwiJHtzZWxlY3RlZFBvc2l0aW9uLmlkeCArIDF9XCJdYCkpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZURyYWdIYW5kbGVMb3N0UG9pbnRlckNhcHR1cmUoKSB7XG5cdFx0c2V0RHJhZ2dpbmcoZmFsc2UpO1xuXHRcdGlmIChkcmFnZ2VkT3ZlclJvd0lkeCA9PT0gdm9pZCAwKSByZXR1cm47XG5cdFx0Y29uc3QgeyByb3dJZHggfSA9IHNlbGVjdGVkUG9zaXRpb247XG5cdFx0Y29uc3QgW3N0YXJ0Um93SW5kZXgsIGVuZFJvd0luZGV4XSA9IHJvd0lkeCA8IGRyYWdnZWRPdmVyUm93SWR4ID8gW3Jvd0lkeCArIDEsIGRyYWdnZWRPdmVyUm93SWR4ICsgMV0gOiBbZHJhZ2dlZE92ZXJSb3dJZHgsIHJvd0lkeF07XG5cdFx0dXBkYXRlUm93cyhzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCk7XG5cdFx0c2V0RHJhZ2dlZE92ZXJSb3dJZHgodm9pZCAwKTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVEcmFnSGFuZGxlQ2xpY2soKSB7XG5cdFx0Zm9jdXNDZWxsKGZhbHNlKTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVEcmFnSGFuZGxlRG91YmxlQ2xpY2soZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR1cGRhdGVSb3dzKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ICsgMSwgcm93cy5sZW5ndGgpO1xuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVJvd3Moc3RhcnRSb3dJZHgsIGVuZFJvd0lkeCkge1xuXHRcdGlmIChvblJvd3NDaGFuZ2UgPT0gbnVsbCkgcmV0dXJuO1xuXHRcdGNvbnN0IHsgcm93SWR4LCBpZHggfSA9IHNlbGVjdGVkUG9zaXRpb247XG5cdFx0Y29uc3QgY29sdW1uID0gY29sdW1uc1tpZHhdO1xuXHRcdGNvbnN0IHNvdXJjZVJvdyA9IHJvd3Nbcm93SWR4XTtcblx0XHRjb25zdCB1cGRhdGVkUm93cyA9IFsuLi5yb3dzXTtcblx0XHRjb25zdCBpbmRleGVzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IHN0YXJ0Um93SWR4OyBpIDwgZW5kUm93SWR4OyBpKyspIGlmIChpc0NlbGxFZGl0YWJsZSh7XG5cdFx0XHRyb3dJZHg6IGksXG5cdFx0XHRpZHhcblx0XHR9KSkge1xuXHRcdFx0Y29uc3QgdXBkYXRlZFJvdyA9IG9uRmlsbCh7XG5cdFx0XHRcdGNvbHVtbktleTogY29sdW1uLmtleSxcblx0XHRcdFx0c291cmNlUm93LFxuXHRcdFx0XHR0YXJnZXRSb3c6IHJvd3NbaV1cblx0XHRcdH0pO1xuXHRcdFx0aWYgKHVwZGF0ZWRSb3cgIT09IHJvd3NbaV0pIHtcblx0XHRcdFx0dXBkYXRlZFJvd3NbaV0gPSB1cGRhdGVkUm93O1xuXHRcdFx0XHRpbmRleGVzLnB1c2goaSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChpbmRleGVzLmxlbmd0aCA+IDApIG9uUm93c0NoYW5nZSh1cGRhdGVkUm93cywge1xuXHRcdFx0aW5kZXhlcyxcblx0XHRcdGNvbHVtblxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIHV0aWxzXG5cdCovXG5cdGZ1bmN0aW9uIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCkge1xuXHRcdHJldHVybiBpZHggPj0gbWluQ29sSWR4ICYmIGlkeCA8PSBtYXhDb2xJZHg7XG5cdH1cblx0ZnVuY3Rpb24gaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpIHtcblx0XHRyZXR1cm4gcm93SWR4ID49IDAgJiYgcm93SWR4IDwgcm93cy5sZW5ndGg7XG5cdH1cblx0ZnVuY3Rpb24gaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzKHsgaWR4LCByb3dJZHggfSkge1xuXHRcdHJldHVybiByb3dJZHggPj0gbWluUm93SWR4ICYmIHJvd0lkeCA8PSBtYXhSb3dJZHggJiYgaXNDb2xJZHhXaXRoaW5TZWxlY3Rpb25Cb3VuZHMoaWR4KTtcblx0fVxuXHRmdW5jdGlvbiBpc0NlbGxXaXRoaW5FZGl0Qm91bmRzKHsgaWR4LCByb3dJZHggfSkge1xuXHRcdHJldHVybiBpc1Jvd0lkeFdpdGhpblZpZXdwb3J0Qm91bmRzKHJvd0lkeCkgJiYgaWR4ID49IDAgJiYgaWR4IDw9IG1heENvbElkeDtcblx0fVxuXHRmdW5jdGlvbiBpc0NlbGxXaXRoaW5WaWV3cG9ydEJvdW5kcyh7IGlkeCwgcm93SWR4IH0pIHtcblx0XHRyZXR1cm4gaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhyb3dJZHgpICYmIGlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzKGlkeCk7XG5cdH1cblx0ZnVuY3Rpb24gaXNDZWxsRWRpdGFibGUocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gaXNDZWxsV2l0aGluRWRpdEJvdW5kcyhwb3NpdGlvbikgJiYgaXNTZWxlY3RlZENlbGxFZGl0YWJsZSh7XG5cdFx0XHRjb2x1bW5zLFxuXHRcdFx0cm93cyxcblx0XHRcdHNlbGVjdGVkUG9zaXRpb246IHBvc2l0aW9uXG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gc2VsZWN0Q2VsbChwb3NpdGlvbiwgb3B0aW9ucykge1xuXHRcdGlmICghaXNDZWxsV2l0aGluU2VsZWN0aW9uQm91bmRzKHBvc2l0aW9uKSkgcmV0dXJuO1xuXHRcdGNvbW1pdEVkaXRvckNoYW5nZXMoKTtcblx0XHRjb25zdCBzYW1lUG9zaXRpb24gPSBpc1NhbWVQb3NpdGlvbihzZWxlY3RlZFBvc2l0aW9uLCBwb3NpdGlvbik7XG5cdFx0aWYgKG9wdGlvbnM/LmVuYWJsZUVkaXRvciAmJiBpc0NlbGxFZGl0YWJsZShwb3NpdGlvbikpIHtcblx0XHRcdGNvbnN0IHJvdyQxID0gcm93c1twb3NpdGlvbi5yb3dJZHhdO1xuXHRcdFx0c2V0U2VsZWN0ZWRQb3NpdGlvbih7XG5cdFx0XHRcdC4uLnBvc2l0aW9uLFxuXHRcdFx0XHRtb2RlOiBcIkVESVRcIixcblx0XHRcdFx0cm93OiByb3ckMSxcblx0XHRcdFx0b3JpZ2luYWxSb3c6IHJvdyQxXG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKHNhbWVQb3NpdGlvbikgc2Nyb2xsSW50b1ZpZXcoZ2V0Q2VsbFRvU2Nyb2xsKGdyaWRSZWYuY3VycmVudCkpO1xuXHRcdGVsc2Uge1xuXHRcdFx0c2V0U2hvdWxkRm9jdXNDZWxsKG9wdGlvbnM/LnNob3VsZEZvY3VzQ2VsbCA9PT0gdHJ1ZSk7XG5cdFx0XHRzZXRTZWxlY3RlZFBvc2l0aW9uKHtcblx0XHRcdFx0Li4ucG9zaXRpb24sXG5cdFx0XHRcdG1vZGU6IFwiU0VMRUNUXCJcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAob25TZWxlY3RlZENlbGxDaGFuZ2UgJiYgIXNhbWVQb3NpdGlvbikgb25TZWxlY3RlZENlbGxDaGFuZ2Uoe1xuXHRcdFx0cm93SWR4OiBwb3NpdGlvbi5yb3dJZHgsXG5cdFx0XHRyb3c6IGlzUm93SWR4V2l0aGluVmlld3BvcnRCb3VuZHMocG9zaXRpb24ucm93SWR4KSA/IHJvd3NbcG9zaXRpb24ucm93SWR4XSA6IHZvaWQgMCxcblx0XHRcdGNvbHVtbjogY29sdW1uc1twb3NpdGlvbi5pZHhdXG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gc2VsZWN0SGVhZGVyQ2VsbCh7IGlkeCwgcm93SWR4IH0pIHtcblx0XHRzZWxlY3RDZWxsKHtcblx0XHRcdHJvd0lkeDogbWluUm93SWR4ICsgcm93SWR4IC0gMSxcblx0XHRcdGlkeFxuXHRcdH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRQb3NpdGlvbihrZXksIGN0cmxLZXksIHNoaWZ0S2V5KSB7XG5cdFx0Y29uc3QgeyBpZHgsIHJvd0lkeCB9ID0gc2VsZWN0ZWRQb3NpdGlvbjtcblx0XHRjb25zdCBpc1Jvd1NlbGVjdGVkID0gc2VsZWN0ZWRDZWxsSXNXaXRoaW5TZWxlY3Rpb25Cb3VuZHMgJiYgaWR4ID09PSAtMTtcblx0XHRzd2l0Y2ggKGtleSkge1xuXHRcdFx0Y2FzZSBcIkFycm93VXBcIjogcmV0dXJuIHtcblx0XHRcdFx0aWR4LFxuXHRcdFx0XHRyb3dJZHg6IHJvd0lkeCAtIDFcblx0XHRcdH07XG5cdFx0XHRjYXNlIFwiQXJyb3dEb3duXCI6IHJldHVybiB7XG5cdFx0XHRcdGlkeCxcblx0XHRcdFx0cm93SWR4OiByb3dJZHggKyAxXG5cdFx0XHR9O1xuXHRcdFx0Y2FzZSBsZWZ0S2V5OiByZXR1cm4ge1xuXHRcdFx0XHRpZHg6IGlkeCAtIDEsXG5cdFx0XHRcdHJvd0lkeFxuXHRcdFx0fTtcblx0XHRcdGNhc2UgcmlnaHRLZXk6IHJldHVybiB7XG5cdFx0XHRcdGlkeDogaWR4ICsgMSxcblx0XHRcdFx0cm93SWR4XG5cdFx0XHR9O1xuXHRcdFx0Y2FzZSBcIlRhYlwiOiByZXR1cm4ge1xuXHRcdFx0XHRpZHg6IGlkeCArIChzaGlmdEtleSA/IC0xIDogMSksXG5cdFx0XHRcdHJvd0lkeFxuXHRcdFx0fTtcblx0XHRcdGNhc2UgXCJIb21lXCI6XG5cdFx0XHRcdGlmIChpc1Jvd1NlbGVjdGVkKSByZXR1cm4ge1xuXHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRyb3dJZHg6IG1pblJvd0lkeFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkeDogMCxcblx0XHRcdFx0XHRyb3dJZHg6IGN0cmxLZXkgPyBtaW5Sb3dJZHggOiByb3dJZHhcblx0XHRcdFx0fTtcblx0XHRcdGNhc2UgXCJFbmRcIjpcblx0XHRcdFx0aWYgKGlzUm93U2VsZWN0ZWQpIHJldHVybiB7XG5cdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdHJvd0lkeDogbWF4Um93SWR4XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aWR4OiBtYXhDb2xJZHgsXG5cdFx0XHRcdFx0cm93SWR4OiBjdHJsS2V5ID8gbWF4Um93SWR4IDogcm93SWR4XG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlIFwiUGFnZVVwXCI6IHtcblx0XHRcdFx0aWYgKHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ID09PSBtaW5Sb3dJZHgpIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBuZXh0Um93WSA9IGdldFJvd1RvcChyb3dJZHgpICsgZ2V0Um93SGVpZ2h0KHJvd0lkeCkgLSBjbGllbnRIZWlnaHQ7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdHJvd0lkeDogbmV4dFJvd1kgPiAwID8gZmluZFJvd0lkeChuZXh0Um93WSkgOiAwXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiUGFnZURvd25cIjoge1xuXHRcdFx0XHRpZiAoc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPj0gcm93cy5sZW5ndGgpIHJldHVybiBzZWxlY3RlZFBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBuZXh0Um93WSA9IGdldFJvd1RvcChyb3dJZHgpICsgY2xpZW50SGVpZ2h0O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRyb3dJZHg6IG5leHRSb3dZIDwgdG90YWxSb3dIZWlnaHQgPyBmaW5kUm93SWR4KG5leHRSb3dZKSA6IHJvd3MubGVuZ3RoIC0gMVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHNlbGVjdGVkUG9zaXRpb247XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5hdmlnYXRlKGV2ZW50KSB7XG5cdFx0Y29uc3QgeyBrZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblx0XHRsZXQgY2VsbE5hdmlnYXRpb25Nb2RlID0gXCJOT05FXCI7XG5cdFx0aWYgKGtleSA9PT0gXCJUYWJcIikge1xuXHRcdFx0aWYgKGNhbkV4aXRHcmlkKHtcblx0XHRcdFx0c2hpZnRLZXksXG5cdFx0XHRcdG1heENvbElkeCxcblx0XHRcdFx0bWluUm93SWR4LFxuXHRcdFx0XHRtYXhSb3dJZHgsXG5cdFx0XHRcdHNlbGVjdGVkUG9zaXRpb25cblx0XHRcdH0pKSB7XG5cdFx0XHRcdGNvbW1pdEVkaXRvckNoYW5nZXMoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2VsbE5hdmlnYXRpb25Nb2RlID0gXCJDSEFOR0VfUk9XXCI7XG5cdFx0fVxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Y29uc3QgbmV4dFBvc2l0aW9uID0gZ2V0TmV4dFBvc2l0aW9uKGtleSwgaXNDdHJsS2V5SGVsZERvd24oZXZlbnQpLCBzaGlmdEtleSk7XG5cdFx0aWYgKGlzU2FtZVBvc2l0aW9uKHNlbGVjdGVkUG9zaXRpb24sIG5leHRQb3NpdGlvbikpIHJldHVybjtcblx0XHRzZWxlY3RDZWxsKGdldE5leHRTZWxlY3RlZENlbGxQb3NpdGlvbih7XG5cdFx0XHRtb3ZlVXA6IGtleSA9PT0gXCJBcnJvd1VwXCIsXG5cdFx0XHRtb3ZlTmV4dDoga2V5ID09PSByaWdodEtleSB8fCBrZXkgPT09IFwiVGFiXCIgJiYgIXNoaWZ0S2V5LFxuXHRcdFx0Y29sdW1ucyxcblx0XHRcdGNvbFNwYW5Db2x1bW5zLFxuXHRcdFx0cm93cyxcblx0XHRcdHRvcFN1bW1hcnlSb3dzLFxuXHRcdFx0Ym90dG9tU3VtbWFyeVJvd3MsXG5cdFx0XHRtaW5Sb3dJZHgsXG5cdFx0XHRtYWluSGVhZGVyUm93SWR4LFxuXHRcdFx0bWF4Um93SWR4LFxuXHRcdFx0bGFzdEZyb3plbkNvbHVtbkluZGV4LFxuXHRcdFx0Y2VsbE5hdmlnYXRpb25Nb2RlLFxuXHRcdFx0Y3VycmVudFBvc2l0aW9uOiBzZWxlY3RlZFBvc2l0aW9uLFxuXHRcdFx0bmV4dFBvc2l0aW9uLFxuXHRcdFx0aXNDZWxsV2l0aGluQm91bmRzOiBpc0NlbGxXaXRoaW5TZWxlY3Rpb25Cb3VuZHNcblx0XHR9KSwgeyBzaG91bGRGb2N1c0NlbGw6IHRydWUgfSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0RHJhZ2dlZE92ZXJDZWxsSWR4KGN1cnJlbnRSb3dJZHgpIHtcblx0XHRpZiAoZHJhZ2dlZE92ZXJSb3dJZHggPT09IHZvaWQgMCkgcmV0dXJuO1xuXHRcdGNvbnN0IHsgcm93SWR4IH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuXHRcdHJldHVybiAocm93SWR4IDwgZHJhZ2dlZE92ZXJSb3dJZHggPyByb3dJZHggPCBjdXJyZW50Um93SWR4ICYmIGN1cnJlbnRSb3dJZHggPD0gZHJhZ2dlZE92ZXJSb3dJZHggOiByb3dJZHggPiBjdXJyZW50Um93SWR4ICYmIGN1cnJlbnRSb3dJZHggPj0gZHJhZ2dlZE92ZXJSb3dJZHgpID8gc2VsZWN0ZWRQb3NpdGlvbi5pZHggOiB2b2lkIDA7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0RHJhZ0hhbmRsZSgpIHtcblx0XHRpZiAob25GaWxsID09IG51bGwgfHwgc2VsZWN0ZWRQb3NpdGlvbi5tb2RlID09PSBcIkVESVRcIiB8fCAhaXNDZWxsV2l0aGluVmlld3BvcnRCb3VuZHMoc2VsZWN0ZWRQb3NpdGlvbikpIHJldHVybjtcblx0XHRjb25zdCB7IGlkeCwgcm93SWR4IH0gPSBzZWxlY3RlZFBvc2l0aW9uO1xuXHRcdGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbaWR4XTtcblx0XHRpZiAoY29sdW1uLnJlbmRlckVkaXRDZWxsID09IG51bGwgfHwgY29sdW1uLmVkaXRhYmxlID09PSBmYWxzZSkgcmV0dXJuO1xuXHRcdGNvbnN0IGlzTGFzdFJvdyA9IHJvd0lkeCA9PT0gbWF4Um93SWR4O1xuXHRcdGNvbnN0IGNvbHVtbldpZHRoID0gZ2V0Q29sdW1uV2lkdGgoY29sdW1uKTtcblx0XHRjb25zdCBjb2xTcGFuID0gY29sdW1uLmNvbFNwYW4/Lih7XG5cdFx0XHR0eXBlOiBcIlJPV1wiLFxuXHRcdFx0cm93OiByb3dzW3Jvd0lkeF1cblx0XHR9KSA/PyAxO1xuXHRcdGNvbnN0IHsgaW5zZXRJbmxpbmVTdGFydCwgLi4uc3R5bGUkMSB9ID0gZ2V0Q2VsbFN0eWxlKGNvbHVtbiwgY29sU3Bhbik7XG5cdFx0Y29uc3QgbWFyZ2luRW5kID0gXCJjYWxjKHZhcigtLXJkZy1kcmFnLWhhbmRsZS1zaXplKSAqIC0wLjUgKyAxcHgpXCI7XG5cdFx0Y29uc3QgaXNMYXN0Q29sdW1uID0gY29sdW1uLmlkeCArIGNvbFNwYW4gLSAxID09PSBtYXhDb2xJZHg7XG5cdFx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwge1xuXHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0Li4uc3R5bGUkMSxcblx0XHRcdFx0Z3JpZFJvd1N0YXJ0OiBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgcm93SWR4ICsgMSxcblx0XHRcdFx0bWFyZ2luSW5saW5lRW5kOiBpc0xhc3RDb2x1bW4gPyB2b2lkIDAgOiBtYXJnaW5FbmQsXG5cdFx0XHRcdG1hcmdpbkJsb2NrRW5kOiBpc0xhc3RSb3cgPyB2b2lkIDAgOiBtYXJnaW5FbmQsXG5cdFx0XHRcdGluc2V0SW5saW5lU3RhcnQ6IGluc2V0SW5saW5lU3RhcnQgPyBgY2FsYygke2luc2V0SW5saW5lU3RhcnR9ICsgJHtjb2x1bW5XaWR0aH1weCArIHZhcigtLXJkZy1kcmFnLWhhbmRsZS1zaXplKSAqIC0wLjUgLSAxcHgpYCA6IHZvaWQgMFxuXHRcdFx0fSxcblx0XHRcdGNsYXNzTmFtZTogY2xhc3NuYW1lcyhjZWxsRHJhZ0hhbmRsZUNsYXNzbmFtZSwgY29sdW1uLmZyb3plbiAmJiBjZWxsRHJhZ0hhbmRsZUZyb3plbkNsYXNzbmFtZSksXG5cdFx0XHRvblBvaW50ZXJEb3duOiBoYW5kbGVEcmFnSGFuZGxlUG9pbnRlckRvd24sXG5cdFx0XHRvblBvaW50ZXJNb3ZlOiBpc0RyYWdnaW5nID8gaGFuZGxlRHJhZ0hhbmRsZVBvaW50ZXJNb3ZlIDogdm9pZCAwLFxuXHRcdFx0b25Mb3N0UG9pbnRlckNhcHR1cmU6IGlzRHJhZ2dpbmcgPyBoYW5kbGVEcmFnSGFuZGxlTG9zdFBvaW50ZXJDYXB0dXJlIDogdm9pZCAwLFxuXHRcdFx0b25DbGljazogaGFuZGxlRHJhZ0hhbmRsZUNsaWNrLFxuXHRcdFx0b25Eb3VibGVDbGljazogaGFuZGxlRHJhZ0hhbmRsZURvdWJsZUNsaWNrXG5cdFx0fSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0Q2VsbEVkaXRvcihyb3dJZHgpIHtcblx0XHRpZiAoIWlzQ2VsbFdpdGhpblZpZXdwb3J0Qm91bmRzKHNlbGVjdGVkUG9zaXRpb24pIHx8IHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ICE9PSByb3dJZHggfHwgc2VsZWN0ZWRQb3NpdGlvbi5tb2RlID09PSBcIlNFTEVDVFwiKSByZXR1cm47XG5cdFx0Y29uc3QgeyBpZHgsIHJvdzogcm93JDEgfSA9IHNlbGVjdGVkUG9zaXRpb247XG5cdFx0Y29uc3QgY29sdW1uID0gY29sdW1uc1tpZHhdO1xuXHRcdGNvbnN0IGNvbFNwYW4gPSBnZXRDb2xTcGFuKGNvbHVtbiwgbGFzdEZyb3plbkNvbHVtbkluZGV4LCB7XG5cdFx0XHR0eXBlOiBcIlJPV1wiLFxuXHRcdFx0cm93OiByb3ckMVxuXHRcdH0pO1xuXHRcdGNvbnN0IGNsb3NlT25FeHRlcm5hbFJvd0NoYW5nZSA9IGNvbHVtbi5lZGl0b3JPcHRpb25zPy5jbG9zZU9uRXh0ZXJuYWxSb3dDaGFuZ2UgPz8gdHJ1ZTtcblx0XHRjb25zdCBjbG9zZUVkaXRvciA9IChzaG91bGRGb2N1c0NlbGwkMSkgPT4ge1xuXHRcdFx0c2V0U2hvdWxkRm9jdXNDZWxsKHNob3VsZEZvY3VzQ2VsbCQxKTtcblx0XHRcdHNldFNlbGVjdGVkUG9zaXRpb24oKHsgaWR4OiBpZHgkMSwgcm93SWR4OiByb3dJZHgkMSB9KSA9PiAoe1xuXHRcdFx0XHRpZHg6IGlkeCQxLFxuXHRcdFx0XHRyb3dJZHg6IHJvd0lkeCQxLFxuXHRcdFx0XHRtb2RlOiBcIlNFTEVDVFwiXG5cdFx0XHR9KSk7XG5cdFx0fTtcblx0XHRjb25zdCBvblJvd0NoYW5nZSA9IChyb3ckMiwgY29tbWl0Q2hhbmdlcywgc2hvdWxkRm9jdXNDZWxsJDEpID0+IHtcblx0XHRcdGlmIChjb21taXRDaGFuZ2VzKSBmbHVzaFN5bmMoKCkgPT4ge1xuXHRcdFx0XHR1cGRhdGVSb3coY29sdW1uLCBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCwgcm93JDIpO1xuXHRcdFx0XHRjbG9zZUVkaXRvcihzaG91bGRGb2N1c0NlbGwkMSk7XG5cdFx0XHR9KTtcblx0XHRcdGVsc2Ugc2V0U2VsZWN0ZWRQb3NpdGlvbigocG9zaXRpb24pID0+ICh7XG5cdFx0XHRcdC4uLnBvc2l0aW9uLFxuXHRcdFx0XHRyb3c6IHJvdyQyXG5cdFx0XHR9KSk7XG5cdFx0fTtcblx0XHRpZiAoY2xvc2VPbkV4dGVybmFsUm93Q2hhbmdlICYmIHJvd3Nbc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHhdICE9PSBzZWxlY3RlZFBvc2l0aW9uLm9yaWdpbmFsUm93KSBjbG9zZUVkaXRvcihmYWxzZSk7XG5cdFx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRWRpdENlbGwsIHtcblx0XHRcdGNvbHVtbixcblx0XHRcdGNvbFNwYW4sXG5cdFx0XHRyb3c6IHJvdyQxLFxuXHRcdFx0cm93SWR4LFxuXHRcdFx0b25Sb3dDaGFuZ2UsXG5cdFx0XHRjbG9zZUVkaXRvcixcblx0XHRcdG9uS2V5RG93bjogb25DZWxsS2V5RG93bixcblx0XHRcdG5hdmlnYXRlXG5cdFx0fSwgY29sdW1uLmtleSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0Um93Vmlld3BvcnRDb2x1bW5zKHJvd0lkeCkge1xuXHRcdGNvbnN0IHNlbGVjdGVkQ29sdW1uID0gc2VsZWN0ZWRQb3NpdGlvbi5pZHggPT09IC0xID8gdm9pZCAwIDogY29sdW1uc1tzZWxlY3RlZFBvc2l0aW9uLmlkeF07XG5cdFx0aWYgKHNlbGVjdGVkQ29sdW1uICE9PSB2b2lkIDAgJiYgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPT09IHJvd0lkeCAmJiAhdmlld3BvcnRDb2x1bW5zLmluY2x1ZGVzKHNlbGVjdGVkQ29sdW1uKSkgcmV0dXJuIHNlbGVjdGVkUG9zaXRpb24uaWR4ID4gY29sT3ZlcnNjYW5FbmRJZHggPyBbLi4udmlld3BvcnRDb2x1bW5zLCBzZWxlY3RlZENvbHVtbl0gOiBbXG5cdFx0XHQuLi52aWV3cG9ydENvbHVtbnMuc2xpY2UoMCwgbGFzdEZyb3plbkNvbHVtbkluZGV4ICsgMSksXG5cdFx0XHRzZWxlY3RlZENvbHVtbixcblx0XHRcdC4uLnZpZXdwb3J0Q29sdW1ucy5zbGljZShsYXN0RnJvemVuQ29sdW1uSW5kZXggKyAxKVxuXHRcdF07XG5cdFx0cmV0dXJuIHZpZXdwb3J0Q29sdW1ucztcblx0fVxuXHRmdW5jdGlvbiBnZXRWaWV3cG9ydFJvd3MoKSB7XG5cdFx0Y29uc3Qgcm93RWxlbWVudHMgPSBbXTtcblx0XHRjb25zdCB7IGlkeDogc2VsZWN0ZWRJZHgsIHJvd0lkeDogc2VsZWN0ZWRSb3dJZHggfSA9IHNlbGVjdGVkUG9zaXRpb247XG5cdFx0Y29uc3Qgc3RhcnRSb3dJZHggPSBzZWxlY3RlZENlbGxJc1dpdGhpblZpZXdwb3J0Qm91bmRzICYmIHNlbGVjdGVkUm93SWR4IDwgcm93T3ZlcnNjYW5TdGFydElkeCA/IHJvd092ZXJzY2FuU3RhcnRJZHggLSAxIDogcm93T3ZlcnNjYW5TdGFydElkeDtcblx0XHRjb25zdCBlbmRSb3dJZHggPSBzZWxlY3RlZENlbGxJc1dpdGhpblZpZXdwb3J0Qm91bmRzICYmIHNlbGVjdGVkUm93SWR4ID4gcm93T3ZlcnNjYW5FbmRJZHggPyByb3dPdmVyc2NhbkVuZElkeCArIDEgOiByb3dPdmVyc2NhbkVuZElkeDtcblx0XHRmb3IgKGxldCB2aWV3cG9ydFJvd0lkeCA9IHN0YXJ0Um93SWR4OyB2aWV3cG9ydFJvd0lkeCA8PSBlbmRSb3dJZHg7IHZpZXdwb3J0Um93SWR4KyspIHtcblx0XHRcdGNvbnN0IGlzUm93T3V0c2lkZVZpZXdwb3J0ID0gdmlld3BvcnRSb3dJZHggPT09IHJvd092ZXJzY2FuU3RhcnRJZHggLSAxIHx8IHZpZXdwb3J0Um93SWR4ID09PSByb3dPdmVyc2NhbkVuZElkeCArIDE7XG5cdFx0XHRjb25zdCByb3dJZHggPSBpc1Jvd091dHNpZGVWaWV3cG9ydCA/IHNlbGVjdGVkUm93SWR4IDogdmlld3BvcnRSb3dJZHg7XG5cdFx0XHRsZXQgcm93Q29sdW1ucyA9IHZpZXdwb3J0Q29sdW1ucztcblx0XHRcdGNvbnN0IHNlbGVjdGVkQ29sdW1uID0gc2VsZWN0ZWRJZHggPT09IC0xID8gdm9pZCAwIDogY29sdW1uc1tzZWxlY3RlZElkeF07XG5cdFx0XHRpZiAoc2VsZWN0ZWRDb2x1bW4gIT09IHZvaWQgMCkgaWYgKGlzUm93T3V0c2lkZVZpZXdwb3J0KSByb3dDb2x1bW5zID0gW3NlbGVjdGVkQ29sdW1uXTtcblx0XHRcdGVsc2Ugcm93Q29sdW1ucyA9IGdldFJvd1ZpZXdwb3J0Q29sdW1ucyhyb3dJZHgpO1xuXHRcdFx0Y29uc3Qgcm93JDEgPSByb3dzW3Jvd0lkeF07XG5cdFx0XHRjb25zdCBncmlkUm93U3RhcnQgPSBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ICsgcm93SWR4ICsgMTtcblx0XHRcdGxldCBrZXkgPSByb3dJZHg7XG5cdFx0XHRsZXQgaXNSb3dTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHR5cGVvZiByb3dLZXlHZXR0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRrZXkgPSByb3dLZXlHZXR0ZXIocm93JDEpO1xuXHRcdFx0XHRpc1Jvd1NlbGVjdGVkID0gc2VsZWN0ZWRSb3dzPy5oYXMoa2V5KSA/PyBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJvd0VsZW1lbnRzLnB1c2gocmVuZGVyUm93KGtleSwge1xuXHRcdFx0XHRcImFyaWEtcm93aW5kZXhcIjogaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIHJvd0lkeCArIDEsXG5cdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBpc1NlbGVjdGFibGUgPyBpc1Jvd1NlbGVjdGVkIDogdm9pZCAwLFxuXHRcdFx0XHRyb3dJZHgsXG5cdFx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRcdHZpZXdwb3J0Q29sdW1uczogcm93Q29sdW1ucyxcblx0XHRcdFx0aXNSb3dTZWxlY3Rpb25EaXNhYmxlZDogaXNSb3dTZWxlY3Rpb25EaXNhYmxlZD8uKHJvdyQxKSA/PyBmYWxzZSxcblx0XHRcdFx0aXNSb3dTZWxlY3RlZCxcblx0XHRcdFx0b25DZWxsTW91c2VEb3duOiBvbkNlbGxNb3VzZURvd25MYXRlc3QsXG5cdFx0XHRcdG9uQ2VsbENsaWNrOiBvbkNlbGxDbGlja0xhdGVzdCxcblx0XHRcdFx0b25DZWxsRG91YmxlQ2xpY2s6IG9uQ2VsbERvdWJsZUNsaWNrTGF0ZXN0LFxuXHRcdFx0XHRvbkNlbGxDb250ZXh0TWVudTogb25DZWxsQ29udGV4dE1lbnVMYXRlc3QsXG5cdFx0XHRcdHJvd0NsYXNzLFxuXHRcdFx0XHRncmlkUm93U3RhcnQsXG5cdFx0XHRcdHNlbGVjdGVkQ2VsbElkeDogc2VsZWN0ZWRSb3dJZHggPT09IHJvd0lkeCA/IHNlbGVjdGVkSWR4IDogdm9pZCAwLFxuXHRcdFx0XHRkcmFnZ2VkT3ZlckNlbGxJZHg6IGdldERyYWdnZWRPdmVyQ2VsbElkeChyb3dJZHgpLFxuXHRcdFx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0XHRcdG9uUm93Q2hhbmdlOiBoYW5kbGVGb3JtYXR0ZXJSb3dDaGFuZ2VMYXRlc3QsXG5cdFx0XHRcdHNlbGVjdENlbGw6IHNlbGVjdENlbGxMYXRlc3QsXG5cdFx0XHRcdHNlbGVjdGVkQ2VsbEVkaXRvcjogZ2V0Q2VsbEVkaXRvcihyb3dJZHgpXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHRcdHJldHVybiByb3dFbGVtZW50cztcblx0fVxuXHRpZiAoc2VsZWN0ZWRQb3NpdGlvbi5pZHggPiBtYXhDb2xJZHggfHwgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPiBtYXhSb3dJZHgpIHtcblx0XHRzZXRTZWxlY3RlZFBvc2l0aW9uKHtcblx0XHRcdGlkeDogLTEsXG5cdFx0XHRyb3dJZHg6IG1pblJvd0lkeCAtIDEsXG5cdFx0XHRtb2RlOiBcIlNFTEVDVFwiXG5cdFx0fSk7XG5cdFx0c2V0RHJhZ2dlZE92ZXJSb3dJZHgodm9pZCAwKTtcblx0fVxuXHRpZiAoaXNDb2x1bW5XaWR0aHNDb250cm9sbGVkICYmIGNvbHVtbldpZHRoc0ludGVybmFsICE9PSBjb2x1bW5XaWR0aHNSYXcpIHNldENvbHVtbldpZHRoc0ludGVybmFsKGNvbHVtbldpZHRoc1Jhdyk7XG5cdGxldCB0ZW1wbGF0ZVJvd3MgPSBgcmVwZWF0KCR7aGVhZGVyUm93c0NvdW50fSwgJHtoZWFkZXJSb3dIZWlnaHR9cHgpYDtcblx0aWYgKHRvcFN1bW1hcnlSb3dzQ291bnQgPiAwKSB0ZW1wbGF0ZVJvd3MgKz0gYCByZXBlYXQoJHt0b3BTdW1tYXJ5Um93c0NvdW50fSwgJHtzdW1tYXJ5Um93SGVpZ2h0fXB4KWA7XG5cdGlmIChyb3dzLmxlbmd0aCA+IDApIHRlbXBsYXRlUm93cyArPSBncmlkVGVtcGxhdGVSb3dzO1xuXHRpZiAoYm90dG9tU3VtbWFyeVJvd3NDb3VudCA+IDApIHRlbXBsYXRlUm93cyArPSBgIHJlcGVhdCgke2JvdHRvbVN1bW1hcnlSb3dzQ291bnR9LCAke3N1bW1hcnlSb3dIZWlnaHR9cHgpYDtcblx0Y29uc3QgaXNHcm91cFJvd0ZvY3VzZWQgPSBzZWxlY3RlZFBvc2l0aW9uLmlkeCA9PT0gLTEgJiYgc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggIT09IG1pblJvd0lkeCAtIDE7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7XG5cdFx0cm9sZSxcblx0XHRcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLFxuXHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LFxuXHRcdFwiYXJpYS1kZXNjcmlwdGlvblwiOiBhcmlhRGVzY3JpcHRpb24sXG5cdFx0XCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRCeSxcblx0XHRcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IGlzU2VsZWN0YWJsZSA/IHRydWUgOiB2b2lkIDAsXG5cdFx0XCJhcmlhLWNvbGNvdW50XCI6IGNvbHVtbnMubGVuZ3RoLFxuXHRcdFwiYXJpYS1yb3djb3VudFwiOiBhcmlhUm93Q291bnQsXG5cdFx0dGFiSW5kZXg6IC0xLFxuXHRcdGNsYXNzTmFtZTogY2xhc3NuYW1lcyhyb290Q2xhc3NuYW1lLCB7IFt2aWV3cG9ydERyYWdnaW5nQ2xhc3NuYW1lXTogaXNEcmFnZ2luZyB9LCBjbGFzc05hbWUpLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHQuLi5zdHlsZSxcblx0XHRcdHNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydDogc2VsZWN0ZWRQb3NpdGlvbi5pZHggPiBsYXN0RnJvemVuQ29sdW1uSW5kZXggfHwgc2Nyb2xsVG9Qb3NpdGlvbj8uaWR4ICE9PSB2b2lkIDAgPyBgJHt0b3RhbEZyb3plbkNvbHVtbldpZHRofXB4YCA6IHZvaWQgMCxcblx0XHRcdHNjcm9sbFBhZGRpbmdCbG9jazogaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCkgfHwgc2Nyb2xsVG9Qb3NpdGlvbj8ucm93SWR4ICE9PSB2b2lkIDAgPyBgJHtoZWFkZXJSb3dzSGVpZ2h0ICsgdG9wU3VtbWFyeVJvd3NDb3VudCAqIHN1bW1hcnlSb3dIZWlnaHR9cHggJHtib3R0b21TdW1tYXJ5Um93c0NvdW50ICogc3VtbWFyeVJvd0hlaWdodH1weGAgOiB2b2lkIDAsXG5cdFx0XHRncmlkVGVtcGxhdGVDb2x1bW5zLFxuXHRcdFx0Z3JpZFRlbXBsYXRlUm93czogdGVtcGxhdGVSb3dzLFxuXHRcdFx0XCItLXJkZy1oZWFkZXItcm93LWhlaWdodFwiOiBgJHtoZWFkZXJSb3dIZWlnaHR9cHhgLFxuXHRcdFx0XCItLXJkZy1zY3JvbGwtaGVpZ2h0XCI6IGAke3Njcm9sbEhlaWdodH1weGAsXG5cdFx0XHQuLi5sYXlvdXRDc3NWYXJzXG5cdFx0fSxcblx0XHRkaXI6IGRpcmVjdGlvbixcblx0XHRyZWY6IGdyaWRSZWYsXG5cdFx0b25TY3JvbGw6IGhhbmRsZVNjcm9sbCxcblx0XHRvbktleURvd246IGhhbmRsZUtleURvd24sXG5cdFx0b25Db3B5OiBoYW5kbGVDZWxsQ29weSxcblx0XHRvblBhc3RlOiBoYW5kbGVDZWxsUGFzdGUsXG5cdFx0XCJkYXRhLXRlc3RpZFwiOiB0ZXN0SWQsXG5cdFx0XCJkYXRhLWN5XCI6IGRhdGFDeSxcblx0XHRjaGlsZHJlbjogW1xuXHRcdFx0LyogQF9fUFVSRV9fICovIGpzeHMoRGF0YUdyaWREZWZhdWx0UmVuZGVyZXJzQ29udGV4dCwge1xuXHRcdFx0XHR2YWx1ZTogZGVmYXVsdEdyaWRDb21wb25lbnRzLFxuXHRcdFx0XHRjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBqc3goSGVhZGVyUm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCwge1xuXHRcdFx0XHRcdHZhbHVlOiBzZWxlY3RIZWFkZXJSb3dMYXRlc3QsXG5cdFx0XHRcdFx0Y2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEhlYWRlclJvd1NlbGVjdGlvbkNvbnRleHQsIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBoZWFkZXJTZWxlY3Rpb25WYWx1ZSxcblx0XHRcdFx0XHRcdGNoaWxkcmVuOiBbQXJyYXkuZnJvbSh7IGxlbmd0aDogZ3JvdXBlZENvbHVtbkhlYWRlclJvd3NDb3VudCB9LCAoXywgaW5kZXgpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goR3JvdXBlZENvbHVtbkhlYWRlclJvd19kZWZhdWx0LCB7XG5cdFx0XHRcdFx0XHRcdHJvd0lkeDogaW5kZXggKyAxLFxuXHRcdFx0XHRcdFx0XHRsZXZlbDogLWdyb3VwZWRDb2x1bW5IZWFkZXJSb3dzQ291bnQgKyBpbmRleCxcblx0XHRcdFx0XHRcdFx0Y29sdW1uczogZ2V0Um93Vmlld3BvcnRDb2x1bW5zKG1pblJvd0lkeCArIGluZGV4KSxcblx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRDZWxsSWR4OiBzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCA9PT0gbWluUm93SWR4ICsgaW5kZXggPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHZvaWQgMCxcblx0XHRcdFx0XHRcdFx0c2VsZWN0Q2VsbDogc2VsZWN0SGVhZGVyQ2VsbExhdGVzdFxuXHRcdFx0XHRcdFx0fSwgaW5kZXgpKSwgLyogQF9fUFVSRV9fICovIGpzeChIZWFkZXJSb3dfZGVmYXVsdCwge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJSb3dDbGFzcyxcblx0XHRcdFx0XHRcdFx0cm93SWR4OiBoZWFkZXJSb3dzQ291bnQsXG5cdFx0XHRcdFx0XHRcdGNvbHVtbnM6IGdldFJvd1ZpZXdwb3J0Q29sdW1ucyhtYWluSGVhZGVyUm93SWR4KSxcblx0XHRcdFx0XHRcdFx0b25Db2x1bW5SZXNpemU6IGhhbmRsZUNvbHVtblJlc2l6ZUxhdGVzdCxcblx0XHRcdFx0XHRcdFx0b25Db2x1bW5SZXNpemVFbmQ6IGhhbmRsZUNvbHVtblJlc2l6ZUVuZExhdGVzdCxcblx0XHRcdFx0XHRcdFx0b25Db2x1bW5zUmVvcmRlcjogb25Db2x1bW5zUmVvcmRlckxhc3Rlc3QsXG5cdFx0XHRcdFx0XHRcdHNvcnRDb2x1bW5zLFxuXHRcdFx0XHRcdFx0XHRvblNvcnRDb2x1bW5zQ2hhbmdlOiBvblNvcnRDb2x1bW5zQ2hhbmdlTGF0ZXN0LFxuXHRcdFx0XHRcdFx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkQ2VsbElkeDogc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPT09IG1haW5IZWFkZXJSb3dJZHggPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHZvaWQgMCxcblx0XHRcdFx0XHRcdFx0c2VsZWN0Q2VsbDogc2VsZWN0SGVhZGVyQ2VsbExhdGVzdCxcblx0XHRcdFx0XHRcdFx0c2hvdWxkRm9jdXNHcmlkOiAhc2VsZWN0ZWRDZWxsSXNXaXRoaW5TZWxlY3Rpb25Cb3VuZHMsXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvblxuXHRcdFx0XHRcdFx0fSldXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSksIHJvd3MubGVuZ3RoID09PSAwICYmIG5vUm93c0ZhbGxiYWNrID8gbm9Sb3dzRmFsbGJhY2sgOiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuXHRcdFx0XHRcdHRvcFN1bW1hcnlSb3dzPy5tYXAoKHJvdyQxLCByb3dJZHgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGdyaWRSb3dTdGFydCA9IGhlYWRlclJvd3NDb3VudCArIDEgKyByb3dJZHg7XG5cdFx0XHRcdFx0XHRjb25zdCBzdW1tYXJ5Um93SWR4ID0gbWFpbkhlYWRlclJvd0lkeCArIDEgKyByb3dJZHg7XG5cdFx0XHRcdFx0XHRjb25zdCBpc1N1bW1hcnlSb3dTZWxlY3RlZCA9IHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ID09PSBzdW1tYXJ5Um93SWR4O1xuXHRcdFx0XHRcdFx0Y29uc3QgdG9wID0gaGVhZGVyUm93c0hlaWdodCArIHN1bW1hcnlSb3dIZWlnaHQgKiByb3dJZHg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTdW1tYXJ5Um93X2RlZmF1bHQsIHtcblx0XHRcdFx0XHRcdFx0XCJhcmlhLXJvd2luZGV4XCI6IGdyaWRSb3dTdGFydCxcblx0XHRcdFx0XHRcdFx0cm93SWR4OiBzdW1tYXJ5Um93SWR4LFxuXHRcdFx0XHRcdFx0XHRncmlkUm93U3RhcnQsXG5cdFx0XHRcdFx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRcdFx0XHRcdHRvcCxcblx0XHRcdFx0XHRcdFx0Ym90dG9tOiB2b2lkIDAsXG5cdFx0XHRcdFx0XHRcdHZpZXdwb3J0Q29sdW1uczogZ2V0Um93Vmlld3BvcnRDb2x1bW5zKHN1bW1hcnlSb3dJZHgpLFxuXHRcdFx0XHRcdFx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkQ2VsbElkeDogaXNTdW1tYXJ5Um93U2VsZWN0ZWQgPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHZvaWQgMCxcblx0XHRcdFx0XHRcdFx0aXNUb3A6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHNlbGVjdENlbGw6IHNlbGVjdENlbGxMYXRlc3Rcblx0XHRcdFx0XHRcdH0sIHJvd0lkeCk7XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0LyogQF9fUFVSRV9fICovIGpzeChSb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0LCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogc2VsZWN0Um93TGF0ZXN0LFxuXHRcdFx0XHRcdFx0Y2hpbGRyZW46IGdldFZpZXdwb3J0Um93cygpXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0Ym90dG9tU3VtbWFyeVJvd3M/Lm1hcCgocm93JDEsIHJvd0lkeCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZ3JpZFJvd1N0YXJ0ID0gaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIHJvd3MubGVuZ3RoICsgcm93SWR4ICsgMTtcblx0XHRcdFx0XHRcdGNvbnN0IHN1bW1hcnlSb3dJZHggPSByb3dzLmxlbmd0aCArIHJvd0lkeDtcblx0XHRcdFx0XHRcdGNvbnN0IGlzU3VtbWFyeVJvd1NlbGVjdGVkID0gc2VsZWN0ZWRQb3NpdGlvbi5yb3dJZHggPT09IHN1bW1hcnlSb3dJZHg7XG5cdFx0XHRcdFx0XHRjb25zdCB0b3AgPSBjbGllbnRIZWlnaHQgPiB0b3RhbFJvd0hlaWdodCA/IGdyaWRIZWlnaHQgLSBzdW1tYXJ5Um93SGVpZ2h0ICogKGJvdHRvbVN1bW1hcnlSb3dzLmxlbmd0aCAtIHJvd0lkeCkgOiB2b2lkIDA7XG5cdFx0XHRcdFx0XHRjb25zdCBib3R0b20gPSB0b3AgPT09IHZvaWQgMCA/IHN1bW1hcnlSb3dIZWlnaHQgKiAoYm90dG9tU3VtbWFyeVJvd3MubGVuZ3RoIC0gMSAtIHJvd0lkeCkgOiB2b2lkIDA7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTdW1tYXJ5Um93X2RlZmF1bHQsIHtcblx0XHRcdFx0XHRcdFx0XCJhcmlhLXJvd2luZGV4XCI6IGFyaWFSb3dDb3VudCAtIGJvdHRvbVN1bW1hcnlSb3dzQ291bnQgKyByb3dJZHggKyAxLFxuXHRcdFx0XHRcdFx0XHRyb3dJZHg6IHN1bW1hcnlSb3dJZHgsXG5cdFx0XHRcdFx0XHRcdGdyaWRSb3dTdGFydCxcblx0XHRcdFx0XHRcdFx0cm93OiByb3ckMSxcblx0XHRcdFx0XHRcdFx0dG9wLFxuXHRcdFx0XHRcdFx0XHRib3R0b20sXG5cdFx0XHRcdFx0XHRcdHZpZXdwb3J0Q29sdW1uczogZ2V0Um93Vmlld3BvcnRDb2x1bW5zKHN1bW1hcnlSb3dJZHgpLFxuXHRcdFx0XHRcdFx0XHRsYXN0RnJvemVuQ29sdW1uSW5kZXgsXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkQ2VsbElkeDogaXNTdW1tYXJ5Um93U2VsZWN0ZWQgPyBzZWxlY3RlZFBvc2l0aW9uLmlkeCA6IHZvaWQgMCxcblx0XHRcdFx0XHRcdFx0aXNUb3A6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRzZWxlY3RDZWxsOiBzZWxlY3RDZWxsTGF0ZXN0XG5cdFx0XHRcdFx0XHR9LCByb3dJZHgpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdF0gfSldXG5cdFx0XHR9KSxcblx0XHRcdGdldERyYWdIYW5kbGUoKSxcblx0XHRcdHJlbmRlck1lYXN1cmluZ0NlbGxzKHZpZXdwb3J0Q29sdW1ucyksXG5cdFx0XHRpc1RyZWVHcmlkICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwge1xuXHRcdFx0XHRyZWY6IGZvY3VzU2lua1JlZixcblx0XHRcdFx0dGFiSW5kZXg6IGlzR3JvdXBSb3dGb2N1c2VkID8gMCA6IC0xLFxuXHRcdFx0XHRjbGFzc05hbWU6IGNsYXNzbmFtZXMoZm9jdXNTaW5rQ2xhc3NuYW1lLCB7XG5cdFx0XHRcdFx0W2ZvY3VzU2lua0hlYWRlckFuZFN1bW1hcnlDbGFzc25hbWVdOiAhaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyhzZWxlY3RlZFBvc2l0aW9uLnJvd0lkeCksXG5cdFx0XHRcdFx0W3Jvd1NlbGVjdGVkXTogaXNHcm91cFJvd0ZvY3VzZWQsXG5cdFx0XHRcdFx0W3Jvd1NlbGVjdGVkV2l0aEZyb3plbkNlbGxdOiBpc0dyb3VwUm93Rm9jdXNlZCAmJiBsYXN0RnJvemVuQ29sdW1uSW5kZXggIT09IC0xXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRzdHlsZTogeyBncmlkUm93U3RhcnQ6IHNlbGVjdGVkUG9zaXRpb24ucm93SWR4ICsgaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCArIDEgfVxuXHRcdFx0fSksXG5cdFx0XHRzY3JvbGxUb1Bvc2l0aW9uICE9PSBudWxsICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goU2Nyb2xsVG9DZWxsLCB7XG5cdFx0XHRcdHNjcm9sbFRvUG9zaXRpb24sXG5cdFx0XHRcdHNldFNjcm9sbFRvQ2VsbFBvc2l0aW9uOiBzZXRTY3JvbGxUb1Bvc2l0aW9uLFxuXHRcdFx0XHRncmlkUmVmXG5cdFx0XHR9KVxuXHRcdF1cblx0fSk7XG59XG5mdW5jdGlvbiBnZXRDZWxsVG9TY3JvbGwoZ3JpZEVsKSB7XG5cdHJldHVybiBncmlkRWwucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IFtyb2xlPVxcXCJyb3dcXFwiXSA+IFt0YWJpbmRleD1cXFwiMFxcXCJdXCIpO1xufVxuZnVuY3Rpb24gaXNTYW1lUG9zaXRpb24ocDEsIHAyKSB7XG5cdHJldHVybiBwMS5pZHggPT09IHAyLmlkeCAmJiBwMS5yb3dJZHggPT09IHAyLnJvd0lkeDtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL0dyb3VwQ2VsbC50c3hcbmZ1bmN0aW9uIEdyb3VwQ2VsbCh7IGlkLCBncm91cEtleSwgY2hpbGRSb3dzLCBpc0V4cGFuZGVkLCBpc0NlbGxTZWxlY3RlZCwgY29sdW1uLCByb3c6IHJvdyQxLCBncm91cENvbHVtbkluZGV4LCBpc0dyb3VwQnlDb2x1bW4sIHRvZ2dsZUdyb3VwOiB0b2dnbGVHcm91cFdyYXBwZXIgfSkge1xuXHRjb25zdCB7IHRhYkluZGV4LCBjaGlsZFRhYkluZGV4LCBvbkZvY3VzIH0gPSB1c2VSb3ZpbmdUYWJJbmRleChpc0NlbGxTZWxlY3RlZCk7XG5cdGZ1bmN0aW9uIHRvZ2dsZUdyb3VwKCkge1xuXHRcdHRvZ2dsZUdyb3VwV3JhcHBlcihpZCk7XG5cdH1cblx0Y29uc3QgaXNMZXZlbE1hdGNoaW5nID0gaXNHcm91cEJ5Q29sdW1uICYmIGdyb3VwQ29sdW1uSW5kZXggPT09IGNvbHVtbi5pZHg7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHtcblx0XHRyb2xlOiBcImdyaWRjZWxsXCIsXG5cdFx0XCJhcmlhLWNvbGluZGV4XCI6IGNvbHVtbi5pZHggKyAxLFxuXHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBpc0NlbGxTZWxlY3RlZCxcblx0XHR0YWJJbmRleCxcblx0XHRjbGFzc05hbWU6IGdldENlbGxDbGFzc25hbWUoY29sdW1uKSxcblx0XHRzdHlsZToge1xuXHRcdFx0Li4uZ2V0Q2VsbFN0eWxlKGNvbHVtbiksXG5cdFx0XHRjdXJzb3I6IGlzTGV2ZWxNYXRjaGluZyA/IFwicG9pbnRlclwiIDogXCJkZWZhdWx0XCJcblx0XHR9LFxuXHRcdG9uTW91c2VEb3duOiAoZXZlbnQpID0+IHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fSxcblx0XHRvbkNsaWNrOiBpc0xldmVsTWF0Y2hpbmcgPyB0b2dnbGVHcm91cCA6IHZvaWQgMCxcblx0XHRvbkZvY3VzLFxuXHRcdGNoaWxkcmVuOiAoIWlzR3JvdXBCeUNvbHVtbiB8fCBpc0xldmVsTWF0Y2hpbmcpICYmIGNvbHVtbi5yZW5kZXJHcm91cENlbGw/Lih7XG5cdFx0XHRncm91cEtleSxcblx0XHRcdGNoaWxkUm93cyxcblx0XHRcdGNvbHVtbixcblx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRpc0V4cGFuZGVkLFxuXHRcdFx0dGFiSW5kZXg6IGNoaWxkVGFiSW5kZXgsXG5cdFx0XHR0b2dnbGVHcm91cFxuXHRcdH0pXG5cdH0sIGNvbHVtbi5rZXkpO1xufVxudmFyIEdyb3VwQ2VsbF9kZWZhdWx0ID0gbWVtbyhHcm91cENlbGwpO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvR3JvdXBSb3cudHN4XG5jb25zdCBncm91cFJvd0NsYXNzbmFtZSA9IGByZGctZ3JvdXAtcm93IHJkZy03LTAtMC1iZXRhLTU4LWU3NGEyYmUzYDtcbmZ1bmN0aW9uIEdyb3VwZWRSb3coeyBjbGFzc05hbWUsIHJvdzogcm93JDEsIHJvd0lkeCwgdmlld3BvcnRDb2x1bW5zLCBzZWxlY3RlZENlbGxJZHgsIGlzUm93U2VsZWN0ZWQsIHNlbGVjdENlbGwsIGdyaWRSb3dTdGFydCwgZ3JvdXBCeSwgdG9nZ2xlR3JvdXAsIGlzUm93U2VsZWN0aW9uRGlzYWJsZWQsIC4uLnByb3BzIH0pIHtcblx0Y29uc3QgaWR4ID0gdmlld3BvcnRDb2x1bW5zWzBdLmtleSA9PT0gU0VMRUNUX0NPTFVNTl9LRVkgPyByb3ckMS5sZXZlbCArIDEgOiByb3ckMS5sZXZlbDtcblx0ZnVuY3Rpb24gaGFuZGxlU2VsZWN0R3JvdXAoKSB7XG5cdFx0c2VsZWN0Q2VsbCh7XG5cdFx0XHRyb3dJZHgsXG5cdFx0XHRpZHg6IC0xXG5cdFx0fSwgeyBzaG91bGRGb2N1c0NlbGw6IHRydWUgfSk7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUm93U2VsZWN0aW9uQ29udGV4dCwge1xuXHRcdHZhbHVlOiB1c2VNZW1vKCgpID0+ICh7XG5cdFx0XHRpc1Jvd1NlbGVjdGlvbkRpc2FibGVkOiBmYWxzZSxcblx0XHRcdGlzUm93U2VsZWN0ZWRcblx0XHR9KSwgW2lzUm93U2VsZWN0ZWRdKSxcblx0XHRjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7XG5cdFx0XHRyb2xlOiBcInJvd1wiLFxuXHRcdFx0XCJhcmlhLWxldmVsXCI6IHJvdyQxLmxldmVsICsgMSxcblx0XHRcdFwiYXJpYS1zZXRzaXplXCI6IHJvdyQxLnNldFNpemUsXG5cdFx0XHRcImFyaWEtcG9zaW5zZXRcIjogcm93JDEucG9zSW5TZXQgKyAxLFxuXHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IHJvdyQxLmlzRXhwYW5kZWQsXG5cdFx0XHRjbGFzc05hbWU6IGNsYXNzbmFtZXMocm93Q2xhc3NuYW1lLCBncm91cFJvd0NsYXNzbmFtZSwgYHJkZy1yb3ctJHtyb3dJZHggJSAyID09PSAwID8gXCJldmVuXCIgOiBcIm9kZFwifWAsIHNlbGVjdGVkQ2VsbElkeCA9PT0gLTEgJiYgcm93U2VsZWN0ZWRDbGFzc25hbWUsIGNsYXNzTmFtZSksXG5cdFx0XHRvbk1vdXNlRG93bjogaGFuZGxlU2VsZWN0R3JvdXAsXG5cdFx0XHRzdHlsZTogZ2V0Um93U3R5bGUoZ3JpZFJvd1N0YXJ0KSxcblx0XHRcdC4uLnByb3BzLFxuXHRcdFx0Y2hpbGRyZW46IHZpZXdwb3J0Q29sdW1ucy5tYXAoKGNvbHVtbikgPT4gLyogQF9fUFVSRV9fICovIGpzeChHcm91cENlbGxfZGVmYXVsdCwge1xuXHRcdFx0XHRpZDogcm93JDEuaWQsXG5cdFx0XHRcdGdyb3VwS2V5OiByb3ckMS5ncm91cEtleSxcblx0XHRcdFx0Y2hpbGRSb3dzOiByb3ckMS5jaGlsZFJvd3MsXG5cdFx0XHRcdGlzRXhwYW5kZWQ6IHJvdyQxLmlzRXhwYW5kZWQsXG5cdFx0XHRcdGlzQ2VsbFNlbGVjdGVkOiBzZWxlY3RlZENlbGxJZHggPT09IGNvbHVtbi5pZHgsXG5cdFx0XHRcdGNvbHVtbixcblx0XHRcdFx0cm93OiByb3ckMSxcblx0XHRcdFx0Z3JvdXBDb2x1bW5JbmRleDogaWR4LFxuXHRcdFx0XHR0b2dnbGVHcm91cCxcblx0XHRcdFx0aXNHcm91cEJ5Q29sdW1uOiBncm91cEJ5LmluY2x1ZGVzKGNvbHVtbi5rZXkpXG5cdFx0XHR9LCBjb2x1bW4ua2V5KSlcblx0XHR9KVxuXHR9KTtcbn1cbnZhciBHcm91cFJvd19kZWZhdWx0ID0gbWVtbyhHcm91cGVkUm93KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1RyZWVEYXRhR3JpZC50c3hcbmZ1bmN0aW9uIFRyZWVEYXRhR3JpZCh7IGNvbHVtbnM6IHJhd0NvbHVtbnMsIHJvd3M6IHJhd1Jvd3MsIHJvd0hlaWdodDogcmF3Um93SGVpZ2h0LCByb3dLZXlHZXR0ZXI6IHJhd1Jvd0tleUdldHRlciwgb25DZWxsS2V5RG93bjogcmF3T25DZWxsS2V5RG93biwgb25DZWxsQ29weTogcmF3T25DZWxsQ29weSwgb25DZWxsUGFzdGU6IHJhd09uQ2VsbFBhc3RlLCBvblJvd3NDaGFuZ2UsIHNlbGVjdGVkUm93czogcmF3U2VsZWN0ZWRSb3dzLCBvblNlbGVjdGVkUm93c0NoYW5nZTogcmF3T25TZWxlY3RlZFJvd3NDaGFuZ2UsIHJlbmRlcmVycywgZ3JvdXBCeTogcmF3R3JvdXBCeSwgcm93R3JvdXBlciwgZXhwYW5kZWRHcm91cElkcywgb25FeHBhbmRlZEdyb3VwSWRzQ2hhbmdlLCBncm91cElkR2V0dGVyOiByYXdHcm91cElkR2V0dGVyLCAuLi5wcm9wcyB9KSB7XG5cdGNvbnN0IGRlZmF1bHRSZW5kZXJlcnMgPSB1c2VEZWZhdWx0UmVuZGVyZXJzKCk7XG5cdGNvbnN0IHJhd1JlbmRlclJvdyA9IHJlbmRlcmVycz8ucmVuZGVyUm93ID8/IGRlZmF1bHRSZW5kZXJlcnM/LnJlbmRlclJvdyA/PyBkZWZhdWx0UmVuZGVyUm93O1xuXHRjb25zdCBoZWFkZXJBbmRUb3BTdW1tYXJ5Um93c0NvdW50ID0gMSArIChwcm9wcy50b3BTdW1tYXJ5Um93cz8ubGVuZ3RoID8/IDApO1xuXHRjb25zdCB7IGxlZnRLZXksIHJpZ2h0S2V5IH0gPSBnZXRMZWZ0UmlnaHRLZXkocHJvcHMuZGlyZWN0aW9uKTtcblx0Y29uc3QgdG9nZ2xlR3JvdXBMYXRlc3QgPSB1c2VMYXRlc3RGdW5jKHRvZ2dsZUdyb3VwKTtcblx0Y29uc3QgZ3JvdXBJZEdldHRlciA9IHJhd0dyb3VwSWRHZXR0ZXIgPz8gZGVmYXVsdEdyb3VwSWRHZXR0ZXI7XG5cdGNvbnN0IHsgY29sdW1ucywgZ3JvdXBCeSB9ID0gdXNlTWVtbygoKSA9PiB7XG5cdFx0Y29uc3QgY29sdW1ucyQxID0gcmF3Q29sdW1ucy50b1NvcnRlZCgoeyBrZXk6IGFLZXkgfSwgeyBrZXk6IGJLZXkgfSkgPT4ge1xuXHRcdFx0aWYgKGFLZXkgPT09IFNFTEVDVF9DT0xVTU5fS0VZKSByZXR1cm4gLTE7XG5cdFx0XHRpZiAoYktleSA9PT0gU0VMRUNUX0NPTFVNTl9LRVkpIHJldHVybiAxO1xuXHRcdFx0aWYgKHJhd0dyb3VwQnkuaW5jbHVkZXMoYUtleSkpIHtcblx0XHRcdFx0aWYgKHJhd0dyb3VwQnkuaW5jbHVkZXMoYktleSkpIHJldHVybiByYXdHcm91cEJ5LmluZGV4T2YoYUtleSkgLSByYXdHcm91cEJ5LmluZGV4T2YoYktleSk7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGJLZXkpKSByZXR1cm4gMTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH0pO1xuXHRcdGNvbnN0IGdyb3VwQnkkMSA9IFtdO1xuXHRcdGZvciAoY29uc3QgW2luZGV4LCBjb2x1bW5dIG9mIGNvbHVtbnMkMS5lbnRyaWVzKCkpIGlmIChyYXdHcm91cEJ5LmluY2x1ZGVzKGNvbHVtbi5rZXkpKSB7XG5cdFx0XHRncm91cEJ5JDEucHVzaChjb2x1bW4ua2V5KTtcblx0XHRcdGNvbHVtbnMkMVtpbmRleF0gPSB7XG5cdFx0XHRcdC4uLmNvbHVtbixcblx0XHRcdFx0ZnJvemVuOiB0cnVlLFxuXHRcdFx0XHRyZW5kZXJDZWxsOiAoKSA9PiBudWxsLFxuXHRcdFx0XHRyZW5kZXJHcm91cENlbGw6IGNvbHVtbi5yZW5kZXJHcm91cENlbGwgPz8gcmVuZGVyVG9nZ2xlR3JvdXAsXG5cdFx0XHRcdGVkaXRhYmxlOiBmYWxzZVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbHVtbnM6IGNvbHVtbnMkMSxcblx0XHRcdGdyb3VwQnk6IGdyb3VwQnkkMVxuXHRcdH07XG5cdH0sIFtyYXdDb2x1bW5zLCByYXdHcm91cEJ5XSk7XG5cdGNvbnN0IFtncm91cGVkUm93cywgcm93c0NvdW50XSA9IHVzZU1lbW8oKCkgPT4ge1xuXHRcdGlmIChncm91cEJ5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIFt2b2lkIDAsIHJhd1Jvd3MubGVuZ3RoXTtcblx0XHRjb25zdCBncm91cFJvd3MgPSAocm93cyQxLCBbZ3JvdXBCeUtleSwgLi4ucmVtYWluaW5nR3JvdXBCeUtleXNdLCBzdGFydFJvd0luZGV4KSA9PiB7XG5cdFx0XHRsZXQgZ3JvdXBSb3dzQ291bnQgPSAwO1xuXHRcdFx0Y29uc3QgZ3JvdXBzID0ge307XG5cdFx0XHRmb3IgKGNvbnN0IFtrZXksIGNoaWxkUm93c10gb2YgT2JqZWN0LmVudHJpZXMocm93R3JvdXBlcihyb3dzJDEsIGdyb3VwQnlLZXkpKSkge1xuXHRcdFx0XHRjb25zdCBbY2hpbGRHcm91cHMsIGNoaWxkUm93c0NvdW50XSA9IHJlbWFpbmluZ0dyb3VwQnlLZXlzLmxlbmd0aCA9PT0gMCA/IFtjaGlsZFJvd3MsIGNoaWxkUm93cy5sZW5ndGhdIDogZ3JvdXBSb3dzKGNoaWxkUm93cywgcmVtYWluaW5nR3JvdXBCeUtleXMsIHN0YXJ0Um93SW5kZXggKyBncm91cFJvd3NDb3VudCArIDEpO1xuXHRcdFx0XHRncm91cHNba2V5XSA9IHtcblx0XHRcdFx0XHRjaGlsZFJvd3MsXG5cdFx0XHRcdFx0Y2hpbGRHcm91cHMsXG5cdFx0XHRcdFx0c3RhcnRSb3dJbmRleDogc3RhcnRSb3dJbmRleCArIGdyb3VwUm93c0NvdW50XG5cdFx0XHRcdH07XG5cdFx0XHRcdGdyb3VwUm93c0NvdW50ICs9IGNoaWxkUm93c0NvdW50ICsgMTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbZ3JvdXBzLCBncm91cFJvd3NDb3VudF07XG5cdFx0fTtcblx0XHRyZXR1cm4gZ3JvdXBSb3dzKHJhd1Jvd3MsIGdyb3VwQnksIDApO1xuXHR9LCBbXG5cdFx0Z3JvdXBCeSxcblx0XHRyb3dHcm91cGVyLFxuXHRcdHJhd1Jvd3Ncblx0XSk7XG5cdGNvbnN0IFtyb3dzLCBpc0dyb3VwUm93XSA9IHVzZU1lbW8oKCkgPT4ge1xuXHRcdGNvbnN0IGFsbEdyb3VwUm93cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5cdFx0aWYgKCFncm91cGVkUm93cykgcmV0dXJuIFtyYXdSb3dzLCBpc0dyb3VwUm93JDFdO1xuXHRcdGNvbnN0IGZsYXR0ZW5lZFJvd3MgPSBbXTtcblx0XHRjb25zdCBleHBhbmRHcm91cCA9IChyb3dzJDEsIHBhcmVudElkLCBsZXZlbCkgPT4ge1xuXHRcdFx0aWYgKGlzUmVhZG9ubHlBcnJheShyb3dzJDEpKSB7XG5cdFx0XHRcdGZsYXR0ZW5lZFJvd3MucHVzaCguLi5yb3dzJDEpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRPYmplY3Qua2V5cyhyb3dzJDEpLmZvckVhY2goKGdyb3VwS2V5LCBwb3NJblNldCwga2V5cykgPT4ge1xuXHRcdFx0XHRjb25zdCBpZCA9IGdyb3VwSWRHZXR0ZXIoZ3JvdXBLZXksIHBhcmVudElkKTtcblx0XHRcdFx0Y29uc3QgaXNFeHBhbmRlZCA9IGV4cGFuZGVkR3JvdXBJZHMuaGFzKGlkKTtcblx0XHRcdFx0Y29uc3QgeyBjaGlsZFJvd3MsIGNoaWxkR3JvdXBzLCBzdGFydFJvd0luZGV4IH0gPSByb3dzJDFbZ3JvdXBLZXldO1xuXHRcdFx0XHRjb25zdCBncm91cFJvdyA9IHtcblx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRwYXJlbnRJZCxcblx0XHRcdFx0XHRncm91cEtleSxcblx0XHRcdFx0XHRpc0V4cGFuZGVkLFxuXHRcdFx0XHRcdGNoaWxkUm93cyxcblx0XHRcdFx0XHRsZXZlbCxcblx0XHRcdFx0XHRwb3NJblNldCxcblx0XHRcdFx0XHRzdGFydFJvd0luZGV4LFxuXHRcdFx0XHRcdHNldFNpemU6IGtleXMubGVuZ3RoXG5cdFx0XHRcdH07XG5cdFx0XHRcdGZsYXR0ZW5lZFJvd3MucHVzaChncm91cFJvdyk7XG5cdFx0XHRcdGFsbEdyb3VwUm93cy5hZGQoZ3JvdXBSb3cpO1xuXHRcdFx0XHRpZiAoaXNFeHBhbmRlZCkgZXhwYW5kR3JvdXAoY2hpbGRHcm91cHMsIGlkLCBsZXZlbCArIDEpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRleHBhbmRHcm91cChncm91cGVkUm93cywgdm9pZCAwLCAwKTtcblx0XHRyZXR1cm4gW2ZsYXR0ZW5lZFJvd3MsIGlzR3JvdXBSb3ckMV07XG5cdFx0ZnVuY3Rpb24gaXNHcm91cFJvdyQxKHJvdyQxKSB7XG5cdFx0XHRyZXR1cm4gYWxsR3JvdXBSb3dzLmhhcyhyb3ckMSk7XG5cdFx0fVxuXHR9LCBbXG5cdFx0ZXhwYW5kZWRHcm91cElkcyxcblx0XHRncm91cGVkUm93cyxcblx0XHRyYXdSb3dzLFxuXHRcdGdyb3VwSWRHZXR0ZXJcblx0XSk7XG5cdGNvbnN0IHJvd0hlaWdodCA9IHVzZU1lbW8oKCkgPT4ge1xuXHRcdGlmICh0eXBlb2YgcmF3Um93SGVpZ2h0ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiAocm93JDEpID0+IHtcblx0XHRcdGlmIChpc0dyb3VwUm93KHJvdyQxKSkgcmV0dXJuIHJhd1Jvd0hlaWdodCh7XG5cdFx0XHRcdHR5cGU6IFwiR1JPVVBcIixcblx0XHRcdFx0cm93OiByb3ckMVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmF3Um93SGVpZ2h0KHtcblx0XHRcdFx0dHlwZTogXCJST1dcIixcblx0XHRcdFx0cm93OiByb3ckMVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRyZXR1cm4gcmF3Um93SGVpZ2h0O1xuXHR9LCBbaXNHcm91cFJvdywgcmF3Um93SGVpZ2h0XSk7XG5cdGNvbnN0IGdldFBhcmVudFJvd0FuZEluZGV4ID0gdXNlQ2FsbGJhY2soKHJvdyQxKSA9PiB7XG5cdFx0Y29uc3Qgcm93SWR4ID0gcm93cy5pbmRleE9mKHJvdyQxKTtcblx0XHRmb3IgKGxldCBpID0gcm93SWR4IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IHBhcmVudFJvdyA9IHJvd3NbaV07XG5cdFx0XHRpZiAoaXNHcm91cFJvdyhwYXJlbnRSb3cpICYmICghaXNHcm91cFJvdyhyb3ckMSkgfHwgcm93JDEucGFyZW50SWQgPT09IHBhcmVudFJvdy5pZCkpIHJldHVybiBbcGFyZW50Um93LCBpXTtcblx0XHR9XG5cdH0sIFtpc0dyb3VwUm93LCByb3dzXSk7XG5cdGNvbnN0IHJvd0tleUdldHRlciA9IHVzZUNhbGxiYWNrKChyb3ckMSkgPT4ge1xuXHRcdGlmIChpc0dyb3VwUm93KHJvdyQxKSkgcmV0dXJuIHJvdyQxLmlkO1xuXHRcdGlmICh0eXBlb2YgcmF3Um93S2V5R2V0dGVyID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiByYXdSb3dLZXlHZXR0ZXIocm93JDEpO1xuXHRcdGNvbnN0IHBhcmVudFJvd0FuZEluZGV4ID0gZ2V0UGFyZW50Um93QW5kSW5kZXgocm93JDEpO1xuXHRcdGlmIChwYXJlbnRSb3dBbmRJbmRleCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRjb25zdCB7IHN0YXJ0Um93SW5kZXgsIGNoaWxkUm93cyB9ID0gcGFyZW50Um93QW5kSW5kZXhbMF07XG5cdFx0XHRyZXR1cm4gc3RhcnRSb3dJbmRleCArIGNoaWxkUm93cy5pbmRleE9mKHJvdyQxKSArIDE7XG5cdFx0fVxuXHRcdHJldHVybiByb3dzLmluZGV4T2Yocm93JDEpO1xuXHR9LCBbXG5cdFx0Z2V0UGFyZW50Um93QW5kSW5kZXgsXG5cdFx0aXNHcm91cFJvdyxcblx0XHRyYXdSb3dLZXlHZXR0ZXIsXG5cdFx0cm93c1xuXHRdKTtcblx0Y29uc3Qgc2VsZWN0ZWRSb3dzID0gdXNlTWVtbygoKSA9PiB7XG5cdFx0aWYgKHJhd1NlbGVjdGVkUm93cyA9PSBudWxsKSByZXR1cm4gbnVsbDtcblx0XHRhc3NlcnRJc1ZhbGlkS2V5R2V0dGVyKHJhd1Jvd0tleUdldHRlcik7XG5cdFx0Y29uc3Qgc2VsZWN0ZWRSb3dzJDEgPSBuZXcgU2V0KHJhd1NlbGVjdGVkUm93cyk7XG5cdFx0Zm9yIChjb25zdCByb3ckMSBvZiByb3dzKSBpZiAoaXNHcm91cFJvdyhyb3ckMSkpIHtcblx0XHRcdGlmIChyb3ckMS5jaGlsZFJvd3MuZXZlcnkoKGNyKSA9PiByYXdTZWxlY3RlZFJvd3MuaGFzKHJhd1Jvd0tleUdldHRlcihjcikpKSkgc2VsZWN0ZWRSb3dzJDEuYWRkKHJvdyQxLmlkKTtcblx0XHR9XG5cdFx0cmV0dXJuIHNlbGVjdGVkUm93cyQxO1xuXHR9LCBbXG5cdFx0aXNHcm91cFJvdyxcblx0XHRyYXdSb3dLZXlHZXR0ZXIsXG5cdFx0cmF3U2VsZWN0ZWRSb3dzLFxuXHRcdHJvd3Ncblx0XSk7XG5cdGZ1bmN0aW9uIG9uU2VsZWN0ZWRSb3dzQ2hhbmdlKG5ld1NlbGVjdGVkUm93cykge1xuXHRcdGlmICghcmF3T25TZWxlY3RlZFJvd3NDaGFuZ2UpIHJldHVybjtcblx0XHRhc3NlcnRJc1ZhbGlkS2V5R2V0dGVyKHJhd1Jvd0tleUdldHRlcik7XG5cdFx0Y29uc3QgbmV3UmF3U2VsZWN0ZWRSb3dzID0gbmV3IFNldChyYXdTZWxlY3RlZFJvd3MpO1xuXHRcdGZvciAoY29uc3Qgcm93JDEgb2Ygcm93cykge1xuXHRcdFx0Y29uc3Qga2V5ID0gcm93S2V5R2V0dGVyKHJvdyQxKTtcblx0XHRcdGlmIChzZWxlY3RlZFJvd3M/LmhhcyhrZXkpICYmICFuZXdTZWxlY3RlZFJvd3MuaGFzKGtleSkpIGlmIChpc0dyb3VwUm93KHJvdyQxKSkgZm9yIChjb25zdCBjciBvZiByb3ckMS5jaGlsZFJvd3MpIG5ld1Jhd1NlbGVjdGVkUm93cy5kZWxldGUocmF3Um93S2V5R2V0dGVyKGNyKSk7XG5cdFx0XHRlbHNlIG5ld1Jhd1NlbGVjdGVkUm93cy5kZWxldGUoa2V5KTtcblx0XHRcdGVsc2UgaWYgKCFzZWxlY3RlZFJvd3M/LmhhcyhrZXkpICYmIG5ld1NlbGVjdGVkUm93cy5oYXMoa2V5KSkgaWYgKGlzR3JvdXBSb3cocm93JDEpKSBmb3IgKGNvbnN0IGNyIG9mIHJvdyQxLmNoaWxkUm93cykgbmV3UmF3U2VsZWN0ZWRSb3dzLmFkZChyYXdSb3dLZXlHZXR0ZXIoY3IpKTtcblx0XHRcdGVsc2UgbmV3UmF3U2VsZWN0ZWRSb3dzLmFkZChrZXkpO1xuXHRcdH1cblx0XHRyYXdPblNlbGVjdGVkUm93c0NoYW5nZShuZXdSYXdTZWxlY3RlZFJvd3MpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZUtleURvd24oYXJncywgZXZlbnQpIHtcblx0XHRyYXdPbkNlbGxLZXlEb3duPy4oYXJncywgZXZlbnQpO1xuXHRcdGlmIChldmVudC5pc0dyaWREZWZhdWx0UHJldmVudGVkKCkpIHJldHVybjtcblx0XHRpZiAoYXJncy5tb2RlID09PSBcIkVESVRcIikgcmV0dXJuO1xuXHRcdGNvbnN0IHsgY29sdW1uLCByb3dJZHgsIHNlbGVjdENlbGwgfSA9IGFyZ3M7XG5cdFx0Y29uc3QgaWR4ID0gY29sdW1uPy5pZHggPz8gLTE7XG5cdFx0Y29uc3Qgcm93JDEgPSByb3dzW3Jvd0lkeF07XG5cdFx0aWYgKCFpc0dyb3VwUm93KHJvdyQxKSkgcmV0dXJuO1xuXHRcdGlmIChpZHggPT09IC0xICYmIChldmVudC5rZXkgPT09IGxlZnRLZXkgJiYgcm93JDEuaXNFeHBhbmRlZCB8fCBldmVudC5rZXkgPT09IHJpZ2h0S2V5ICYmICFyb3ckMS5pc0V4cGFuZGVkKSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnByZXZlbnRHcmlkRGVmYXVsdCgpO1xuXHRcdFx0dG9nZ2xlR3JvdXAocm93JDEuaWQpO1xuXHRcdH1cblx0XHRpZiAoaWR4ID09PSAtMSAmJiBldmVudC5rZXkgPT09IGxlZnRLZXkgJiYgIXJvdyQxLmlzRXhwYW5kZWQgJiYgcm93JDEubGV2ZWwgIT09IDApIHtcblx0XHRcdGNvbnN0IHBhcmVudFJvd0FuZEluZGV4ID0gZ2V0UGFyZW50Um93QW5kSW5kZXgocm93JDEpO1xuXHRcdFx0aWYgKHBhcmVudFJvd0FuZEluZGV4ICE9PSB2b2lkIDApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudEdyaWREZWZhdWx0KCk7XG5cdFx0XHRcdHNlbGVjdENlbGwoe1xuXHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRyb3dJZHg6IHBhcmVudFJvd0FuZEluZGV4WzFdXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVDZWxsQ29weSh7IHJvdzogcm93JDEsIGNvbHVtbiB9LCBldmVudCkge1xuXHRcdGlmICghaXNHcm91cFJvdyhyb3ckMSkpIHJhd09uQ2VsbENvcHk/Lih7XG5cdFx0XHRyb3c6IHJvdyQxLFxuXHRcdFx0Y29sdW1uXG5cdFx0fSwgZXZlbnQpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZUNlbGxQYXN0ZSh7IHJvdzogcm93JDEsIGNvbHVtbiB9LCBldmVudCkge1xuXHRcdHJldHVybiBpc0dyb3VwUm93KHJvdyQxKSA/IHJvdyQxIDogcmF3T25DZWxsUGFzdGUoe1xuXHRcdFx0cm93OiByb3ckMSxcblx0XHRcdGNvbHVtblxuXHRcdH0sIGV2ZW50KTtcblx0fVxuXHRmdW5jdGlvbiBoYW5kbGVSb3dzQ2hhbmdlKHVwZGF0ZWRSb3dzLCB7IGluZGV4ZXMsIGNvbHVtbiB9KSB7XG5cdFx0aWYgKCFvblJvd3NDaGFuZ2UpIHJldHVybjtcblx0XHRjb25zdCB1cGRhdGVkUmF3Um93cyA9IFsuLi5yYXdSb3dzXTtcblx0XHRjb25zdCByYXdJbmRleGVzID0gW107XG5cdFx0Zm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG5cdFx0XHRjb25zdCByYXdJbmRleCA9IHJhd1Jvd3MuaW5kZXhPZihyb3dzW2luZGV4XSk7XG5cdFx0XHR1cGRhdGVkUmF3Um93c1tyYXdJbmRleF0gPSB1cGRhdGVkUm93c1tpbmRleF07XG5cdFx0XHRyYXdJbmRleGVzLnB1c2gocmF3SW5kZXgpO1xuXHRcdH1cblx0XHRvblJvd3NDaGFuZ2UodXBkYXRlZFJhd1Jvd3MsIHtcblx0XHRcdGluZGV4ZXM6IHJhd0luZGV4ZXMsXG5cdFx0XHRjb2x1bW5cblx0XHR9KTtcblx0fVxuXHRmdW5jdGlvbiB0b2dnbGVHcm91cChncm91cElkKSB7XG5cdFx0Y29uc3QgbmV3RXhwYW5kZWRHcm91cElkcyA9IG5ldyBTZXQoZXhwYW5kZWRHcm91cElkcyk7XG5cdFx0aWYgKG5ld0V4cGFuZGVkR3JvdXBJZHMuaGFzKGdyb3VwSWQpKSBuZXdFeHBhbmRlZEdyb3VwSWRzLmRlbGV0ZShncm91cElkKTtcblx0XHRlbHNlIG5ld0V4cGFuZGVkR3JvdXBJZHMuYWRkKGdyb3VwSWQpO1xuXHRcdG9uRXhwYW5kZWRHcm91cElkc0NoYW5nZShuZXdFeHBhbmRlZEdyb3VwSWRzKTtcblx0fVxuXHRmdW5jdGlvbiByZW5kZXJSb3coa2V5LCB7IHJvdzogcm93JDEsIHJvd0NsYXNzLCBvbkNlbGxNb3VzZURvd24sIG9uQ2VsbENsaWNrLCBvbkNlbGxEb3VibGVDbGljaywgb25DZWxsQ29udGV4dE1lbnUsIG9uUm93Q2hhbmdlLCBsYXN0RnJvemVuQ29sdW1uSW5kZXgsIGRyYWdnZWRPdmVyQ2VsbElkeCwgc2VsZWN0ZWRDZWxsRWRpdG9yLCAuLi5yb3dQcm9wcyB9KSB7XG5cdFx0aWYgKGlzR3JvdXBSb3cocm93JDEpKSB7XG5cdFx0XHRjb25zdCB7IHN0YXJ0Um93SW5kZXggfSA9IHJvdyQxO1xuXHRcdFx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goR3JvdXBSb3dfZGVmYXVsdCwge1xuXHRcdFx0XHQuLi5yb3dQcm9wcyxcblx0XHRcdFx0XCJhcmlhLXJvd2luZGV4XCI6IGhlYWRlckFuZFRvcFN1bW1hcnlSb3dzQ291bnQgKyBzdGFydFJvd0luZGV4ICsgMSxcblx0XHRcdFx0cm93OiByb3ckMSxcblx0XHRcdFx0Z3JvdXBCeSxcblx0XHRcdFx0dG9nZ2xlR3JvdXA6IHRvZ2dsZUdyb3VwTGF0ZXN0XG5cdFx0XHR9LCBrZXkpO1xuXHRcdH1cblx0XHRsZXQgYXJpYVJvd0luZGV4ID0gcm93UHJvcHNbXCJhcmlhLXJvd2luZGV4XCJdO1xuXHRcdGNvbnN0IHBhcmVudFJvd0FuZEluZGV4ID0gZ2V0UGFyZW50Um93QW5kSW5kZXgocm93JDEpO1xuXHRcdGlmIChwYXJlbnRSb3dBbmRJbmRleCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRjb25zdCB7IHN0YXJ0Um93SW5kZXgsIGNoaWxkUm93cyB9ID0gcGFyZW50Um93QW5kSW5kZXhbMF07XG5cdFx0XHRjb25zdCBncm91cEluZGV4ID0gY2hpbGRSb3dzLmluZGV4T2Yocm93JDEpO1xuXHRcdFx0YXJpYVJvd0luZGV4ID0gc3RhcnRSb3dJbmRleCArIGhlYWRlckFuZFRvcFN1bW1hcnlSb3dzQ291bnQgKyBncm91cEluZGV4ICsgMjtcblx0XHR9XG5cdFx0cmV0dXJuIHJhd1JlbmRlclJvdyhrZXksIHtcblx0XHRcdC4uLnJvd1Byb3BzLFxuXHRcdFx0XCJhcmlhLXJvd2luZGV4XCI6IGFyaWFSb3dJbmRleCxcblx0XHRcdHJvdzogcm93JDEsXG5cdFx0XHRyb3dDbGFzcyxcblx0XHRcdG9uQ2VsbE1vdXNlRG93bixcblx0XHRcdG9uQ2VsbENsaWNrLFxuXHRcdFx0b25DZWxsRG91YmxlQ2xpY2ssXG5cdFx0XHRvbkNlbGxDb250ZXh0TWVudSxcblx0XHRcdG9uUm93Q2hhbmdlLFxuXHRcdFx0bGFzdEZyb3plbkNvbHVtbkluZGV4LFxuXHRcdFx0ZHJhZ2dlZE92ZXJDZWxsSWR4LFxuXHRcdFx0c2VsZWN0ZWRDZWxsRWRpdG9yXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRGF0YUdyaWQsIHtcblx0XHQuLi5wcm9wcyxcblx0XHRyb2xlOiBcInRyZWVncmlkXCIsXG5cdFx0XCJhcmlhLXJvd2NvdW50XCI6IHJvd3NDb3VudCArIDEgKyAocHJvcHMudG9wU3VtbWFyeVJvd3M/Lmxlbmd0aCA/PyAwKSArIChwcm9wcy5ib3R0b21TdW1tYXJ5Um93cz8ubGVuZ3RoID8/IDApLFxuXHRcdGNvbHVtbnMsXG5cdFx0cm93cyxcblx0XHRyb3dIZWlnaHQsXG5cdFx0cm93S2V5R2V0dGVyLFxuXHRcdG9uUm93c0NoYW5nZTogaGFuZGxlUm93c0NoYW5nZSxcblx0XHRzZWxlY3RlZFJvd3MsXG5cdFx0b25TZWxlY3RlZFJvd3NDaGFuZ2UsXG5cdFx0b25DZWxsS2V5RG93bjogaGFuZGxlS2V5RG93bixcblx0XHRvbkNlbGxDb3B5OiBoYW5kbGVDZWxsQ29weSxcblx0XHRvbkNlbGxQYXN0ZTogcmF3T25DZWxsUGFzdGUgPyBoYW5kbGVDZWxsUGFzdGUgOiB2b2lkIDAsXG5cdFx0cmVuZGVyZXJzOiB7XG5cdFx0XHQuLi5yZW5kZXJlcnMsXG5cdFx0XHRyZW5kZXJSb3dcblx0XHR9XG5cdH0pO1xufVxuZnVuY3Rpb24gZGVmYXVsdEdyb3VwSWRHZXR0ZXIoZ3JvdXBLZXksIHBhcmVudElkKSB7XG5cdHJldHVybiBwYXJlbnRJZCAhPT0gdm9pZCAwID8gYCR7cGFyZW50SWR9X18ke2dyb3VwS2V5fWAgOiBncm91cEtleTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHlBcnJheShhcnIpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2VkaXRvcnMvcmVuZGVyVGV4dEVkaXRvci50c3hcbmNvbnN0IHRleHRFZGl0b3JJbnRlcm5hbENsYXNzbmFtZSA9IFwicmRnLTctMC0wLWJldGEtNTgtMmY4ZGIyMDZcIjtcbmNvbnN0IHRleHRFZGl0b3JDbGFzc25hbWUgPSBgcmRnLXRleHQtZWRpdG9yICR7dGV4dEVkaXRvckludGVybmFsQ2xhc3NuYW1lfWA7XG5mdW5jdGlvbiBhdXRvRm9jdXNBbmRTZWxlY3QoaW5wdXQpIHtcblx0aW5wdXQ/LmZvY3VzKCk7XG5cdGlucHV0Py5zZWxlY3QoKTtcbn1cbmZ1bmN0aW9uIHRleHRUZXh0RWRpdG9yKHsgcm93OiByb3ckMSwgY29sdW1uLCBvblJvd0NoYW5nZSwgb25DbG9zZSB9KSB7XG5cdHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiaW5wdXRcIiwge1xuXHRcdGNsYXNzTmFtZTogdGV4dEVkaXRvckNsYXNzbmFtZSxcblx0XHRyZWY6IGF1dG9Gb2N1c0FuZFNlbGVjdCxcblx0XHR2YWx1ZTogcm93JDFbY29sdW1uLmtleV0sXG5cdFx0b25DaGFuZ2U6IChldmVudCkgPT4gb25Sb3dDaGFuZ2Uoe1xuXHRcdFx0Li4ucm93JDEsXG5cdFx0XHRbY29sdW1uLmtleV06IGV2ZW50LnRhcmdldC52YWx1ZVxuXHRcdH0pLFxuXHRcdG9uQmx1cjogKCkgPT4gb25DbG9zZSh0cnVlLCBmYWxzZSlcblx0fSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgQ2VsbF9kZWZhdWx0IGFzIENlbGwsIERhdGFHcmlkLCBEYXRhR3JpZERlZmF1bHRSZW5kZXJlcnNDb250ZXh0LCBSb3dfZGVmYXVsdCBhcyBSb3csIFNFTEVDVF9DT0xVTU5fS0VZLCBTZWxlY3RDZWxsRm9ybWF0dGVyLCBTZWxlY3RDb2x1bW4sIFRvZ2dsZUdyb3VwLCBUcmVlRGF0YUdyaWQsIHJlbmRlckNoZWNrYm94LCByZW5kZXJIZWFkZXJDZWxsLCByZW5kZXJTb3J0SWNvbiwgcmVuZGVyU29ydFByaW9yaXR5LCB0ZXh0VGV4dEVkaXRvciBhcyByZW5kZXJUZXh0RWRpdG9yLCByZW5kZXJUb2dnbGVHcm91cCwgcmVuZGVyVmFsdWUsIHVzZUhlYWRlclJvd1NlbGVjdGlvbiwgdXNlUm93U2VsZWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsIm1lbW8iLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3RFdmVudCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJmbHVzaFN5bmMiLCJGcmFnbWVudCIsImpzeCIsImpzeHMiLCJnZXRDb2xTcGFuIiwiY29sdW1uIiwibGFzdEZyb3plbkNvbHVtbkluZGV4IiwiYXJncyIsImNvbFNwYW4iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJmcm96ZW4iLCJpZHgiLCJzdG9wUHJvcGFnYXRpb24iLCJldmVudCIsInNjcm9sbEludG9WaWV3IiwiZWxlbWVudCIsImJlaGF2aW9yIiwiaW5saW5lIiwiYmxvY2siLCJjcmVhdGVDZWxsRXZlbnQiLCJkZWZhdWx0UHJldmVudGVkIiwiY2VsbEV2ZW50IiwicHJldmVudEdyaWREZWZhdWx0IiwiaXNHcmlkRGVmYXVsdFByZXZlbnRlZCIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJub25JbnB1dEtleXMiLCJTZXQiLCJpc0N0cmxLZXlIZWxkRG93biIsImUiLCJjdHJsS2V5IiwibWV0YUtleSIsImtleSIsInZLZXkiLCJpc0RlZmF1bHRDZWxsSW5wdXQiLCJpc1VzZXJIYW5kbGluZ1Bhc3RlIiwia2V5Q29kZSIsImhhcyIsIm9uRWRpdG9yTmF2aWdhdGlvbiIsInRhcmdldCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJjbG9zZXN0IiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsImdldExlZnRSaWdodEtleSIsImRpcmVjdGlvbiIsImlzUnRsIiwibGVmdEtleSIsInJpZ2h0S2V5IiwibWVhc3VyaW5nQ2VsbENsYXNzbmFtZSIsInJlbmRlck1lYXN1cmluZ0NlbGxzIiwidmlld3BvcnRDb2x1bW5zIiwibWFwIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImNsYXNzTmFtZSIsInN0eWxlIiwiZ3JpZENvbHVtblN0YXJ0IiwiaXNTZWxlY3RlZENlbGxFZGl0YWJsZSIsInNlbGVjdGVkUG9zaXRpb24iLCJjb2x1bW5zIiwicm93cyIsInJvdyQxIiwicm93SWR4IiwiaXNDZWxsRWRpdGFibGVVdGlsIiwicmVuZGVyRWRpdENlbGwiLCJlZGl0YWJsZSIsImdldFNlbGVjdGVkQ2VsbENvbFNwYW4iLCJ0b3BTdW1tYXJ5Um93cyIsImJvdHRvbVN1bW1hcnlSb3dzIiwibWFpbkhlYWRlclJvd0lkeCIsInRvcFN1bW1hcnlSb3dzQ291bnQiLCJ0eXBlIiwicm93IiwiZ2V0TmV4dFNlbGVjdGVkQ2VsbFBvc2l0aW9uIiwibW92ZVVwIiwibW92ZU5leHQiLCJjZWxsTmF2aWdhdGlvbk1vZGUiLCJjb2xTcGFuQ29sdW1ucyIsIm1pblJvd0lkeCIsIm1heFJvd0lkeCIsImN1cnJlbnRQb3NpdGlvbiIsImN1cnJlbnRJZHgiLCJjdXJyZW50Um93SWR4IiwibmV4dFBvc2l0aW9uIiwiaXNDZWxsV2l0aGluQm91bmRzIiwibmV4dElkeCIsIm5leHRSb3dJZHgiLCJjb2x1bW5zQ291bnQiLCJzZXRDb2xTcGFuIiwibW92ZU5leHQkMSIsImNvbElkeCIsImdldFBhcmVudFJvd0lkeCIsInBhcmVudCIsImxldmVsIiwic2V0SGVhZGVyR3JvdXBDb2xBbmRSb3dTcGFuIiwicGFyZW50Um93SWR4IiwiZm91bmQiLCJpc0FmdGVyTGFzdENvbHVtbiIsImlzQmVmb3JlRmlyc3RDb2x1bW4iLCJuZXh0UGFyZW50Um93SWR4IiwiY2FuRXhpdEdyaWQiLCJtYXhDb2xJZHgiLCJzaGlmdEtleSIsImNlbGwiLCJjZWxsQ2xhc3NuYW1lIiwiY2VsbEZyb3plbiIsImNlbGxGcm96ZW5DbGFzc25hbWUiLCJjZWxsRHJhZ0hhbmRsZSIsImNlbGxEcmFnSGFuZGxlRnJvemVuQ2xhc3NuYW1lIiwiY2VsbERyYWdIYW5kbGVDbGFzc25hbWUiLCJnZXRSb3dTdHlsZSIsImdldEhlYWRlckNlbGxTdHlsZSIsInJvd1NwYW4iLCJncmlkUm93RW5kIiwicGFkZGluZ0Jsb2NrU3RhcnQiLCJpbnNldEJsb2NrU3RhcnQiLCJncmlkUm93U3RhcnQiLCJnZXRDZWxsU3R5bGUiLCJpbmRleCIsImdyaWRDb2x1bW5FbmQiLCJpbnNldElubGluZVN0YXJ0IiwiY2xhc3NuYW1lcyIsImNsYXNzbmFtZSIsImFyZyIsInRyaW1TdGFydCIsImdldENlbGxDbGFzc25hbWUiLCJleHRyYUNsYXNzZXMiLCJtaW4iLCJtYXgiLCJmbG9vciIsInNpZ24iLCJhYnMiLCJNYXRoIiwiYXNzZXJ0SXNWYWxpZEtleUdldHRlciIsImtleUdldHRlciIsIkVycm9yIiwiY2xhbXBDb2x1bW5XaWR0aCIsIndpZHRoIiwiZ2V0SGVhZGVyQ2VsbFJvd1NwYW4iLCJjaGVja2JveENsYXNzbmFtZSIsInJlbmRlckNoZWNrYm94Iiwib25DaGFuZ2UiLCJpbmRldGVybWluYXRlIiwicHJvcHMiLCJoYW5kbGVDaGFuZ2UiLCJjaGVja2VkIiwibmF0aXZlRXZlbnQiLCJyZWYiLCJlbCIsImdyb3VwQ2VsbENvbnRlbnRDbGFzc25hbWUiLCJjYXJldENsYXNzbmFtZSIsInJlbmRlclRvZ2dsZUdyb3VwIiwiVG9nZ2xlR3JvdXAiLCJncm91cEtleSIsImlzRXhwYW5kZWQiLCJ0YWJJbmRleCIsInRvZ2dsZUdyb3VwIiwiaGFuZGxlS2V5RG93biIsImQiLCJvbktleURvd24iLCJjaGlsZHJlbiIsInZpZXdCb3giLCJoZWlnaHQiLCJyZW5kZXJWYWx1ZSIsIkRhdGFHcmlkRGVmYXVsdFJlbmRlcmVyc0NvbnRleHQiLCJ1c2VEZWZhdWx0UmVuZGVyZXJzIiwiU2VsZWN0Q2VsbEZvcm1hdHRlciIsInZhbHVlIiwiZGlzYWJsZWQiLCJhcmlhTGFiZWwiLCJhcmlhTGFiZWxsZWRCeSIsInJlbmRlckNoZWNrYm94JDEiLCJSb3dTZWxlY3Rpb25Db250ZXh0IiwiUm93U2VsZWN0aW9uQ2hhbmdlQ29udGV4dCIsInVzZVJvd1NlbGVjdGlvbiIsInJvd1NlbGVjdGlvbkNvbnRleHQiLCJyb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0IiwiaXNSb3dTZWxlY3Rpb25EaXNhYmxlZCIsImlzUm93U2VsZWN0ZWQiLCJvblJvd1NlbGVjdGlvbkNoYW5nZSIsIkhlYWRlclJvd1NlbGVjdGlvbkNvbnRleHQiLCJIZWFkZXJSb3dTZWxlY3Rpb25DaGFuZ2VDb250ZXh0IiwidXNlSGVhZGVyUm93U2VsZWN0aW9uIiwiaGVhZGVyUm93U2VsZWN0aW9uQ29udGV4dCIsImhlYWRlclJvd1NlbGVjdGlvbkNoYW5nZUNvbnRleHQiLCJpc0luZGV0ZXJtaW5hdGUiLCJTRUxFQ1RfQ09MVU1OX0tFWSIsIkhlYWRlclJlbmRlcmVyIiwiU2VsZWN0Rm9ybWF0dGVyIiwiaXNTaGlmdENsaWNrIiwiU2VsZWN0R3JvdXBGb3JtYXR0ZXIiLCJTZWxlY3RDb2x1bW4iLCJuYW1lIiwicmVzaXphYmxlIiwic29ydGFibGUiLCJyZW5kZXJIZWFkZXJDZWxsIiwicmVuZGVyQ2VsbCIsInJlbmRlckdyb3VwQ2VsbCIsImhlYWRlclNvcnRDZWxsQ2xhc3NuYW1lIiwiaGVhZGVyU29ydE5hbWVDbGFzc25hbWUiLCJzb3J0RGlyZWN0aW9uIiwicHJpb3JpdHkiLCJTb3J0YWJsZUhlYWRlckNlbGwiLCJyZW5kZXJTb3J0U3RhdHVzJDEiLCJyZW5kZXJTb3J0U3RhdHVzIiwiREVGQVVMVF9DT0xVTU5fV0lEVEgiLCJERUZBVUxUX0NPTFVNTl9NSU5fV0lEVEgiLCJ1c2VDYWxjdWxhdGVkQ29sdW1ucyIsInJhd0NvbHVtbnMiLCJkZWZhdWx0Q29sdW1uT3B0aW9ucyIsImdldENvbHVtbldpZHRoIiwidmlld3BvcnRXaWR0aCIsInNjcm9sbExlZnQiLCJlbmFibGVWaXJ0dWFsaXphdGlvbiIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRNaW5XaWR0aCIsImRlZmF1bHRNYXhXaWR0aCIsImRlZmF1bHRSZW5kZXJDZWxsJDEiLCJkZWZhdWx0UmVuZGVySGVhZGVyQ2VsbCIsImRlZmF1bHRTb3J0YWJsZSIsImRlZmF1bHRSZXNpemFibGUiLCJkZWZhdWx0RHJhZ2dhYmxlIiwiZHJhZ2dhYmxlIiwiaGVhZGVyUm93c0NvdW50IiwibGFzdEZyb3plbkNvbHVtbkluZGV4JDEiLCJoZWFkZXJSb3dzQ291bnQkMSIsImNvbHVtbnMkMSIsImNvbGxlY3RDb2x1bW5zIiwicmF3Q29sdW1ucyQxIiwicmF3Q29sdW1uIiwiY2FsY3VsYXRlZENvbHVtblBhcmVudCIsImhlYWRlckNlbGxDbGFzcyIsInB1c2giLCJzb3J0IiwiYUtleSIsImZyb3plbkEiLCJiS2V5IiwiZnJvemVuQiIsImNvbFNwYW5Db2x1bW5zJDEiLCJmb3JFYWNoIiwidXBkYXRlQ29sdW1uUGFyZW50IiwidGVtcGxhdGVDb2x1bW5zIiwibGF5b3V0Q3NzVmFycyIsInRvdGFsRnJvemVuQ29sdW1uV2lkdGgiLCJjb2x1bW5NZXRyaWNzIiwiY29sdW1uTWV0cmljcyQxIiwiTWFwIiwibGVmdCIsInRvdGFsRnJvemVuQ29sdW1uV2lkdGgkMSIsInRlbXBsYXRlQ29sdW1ucyQxIiwic2V0IiwiY29sdW1uTWV0cmljIiwiZ2V0IiwibGF5b3V0Q3NzVmFycyQxIiwiaSIsImNvbE92ZXJzY2FuU3RhcnRJZHgiLCJjb2xPdmVyc2NhbkVuZElkeCIsInZpZXdwb3J0TGVmdCIsInZpZXdwb3J0UmlnaHQiLCJsYXN0Q29sSWR4IiwiZmlyc3RVbmZyb3plbkNvbHVtbklkeCIsImNvbFZpc2libGVTdGFydElkeCIsImNvbFZpc2libGVFbmRJZHgiLCJ1c2VDb2x1bW5XaWR0aHMiLCJncmlkUmVmIiwiZ3JpZFdpZHRoIiwiY29sdW1uV2lkdGhzIiwib25Db2x1bW5XaWR0aHNDaGFuZ2UiLCJvbkNvbHVtblJlc2l6ZSIsInNldENvbHVtblJlc2l6aW5nIiwiY29sdW1uVG9BdXRvUmVzaXplIiwic2V0Q29sdW1uVG9BdXRvUmVzaXplIiwiY29sdW1uc1RvTWVhc3VyZU9uUmVzaXplIiwic2V0Q29sdW1uc1RvTWVhc3VyZU9uUmVzaXplIiwicHJldkdyaWRXaWR0aCIsInNldFByZXZpb3VzR3JpZFdpZHRoIiwiY29sdW1uc0NhbkZsZXgiLCJpZ25vcmVQcmV2aW91c2x5TWVhc3VyZWRDb2x1bW5zT25HcmlkV2lkdGhDaGFuZ2UiLCJuZXdUZW1wbGF0ZUNvbHVtbnMiLCJjb2x1bW5zVG9NZWFzdXJlIiwiY29sdW1uV2lkdGgiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwiam9pbiIsInVwZGF0ZU1lYXN1cmVkQW5kUmVzaXplZFdpZHRocyIsIm5ld0NvbHVtbldpZHRocyIsImhhc0NoYW5nZXMiLCJtZWFzdXJlZFdpZHRoIiwibWVhc3VyZUNvbHVtbldpZHRoIiwiZGVsZXRlIiwicmVzaXppbmdLZXkiLCJvbGRXaWR0aCIsIm5ld1dpZHRoIiwiaGFuZGxlQ29sdW1uUmVzaXplIiwibmV4dFdpZHRoIiwiY29sdW1uc1RvUmVtZWFzdXJlIiwiYWRkIiwicHJldmlvdXNXaWR0aCIsInNlbGVjdG9yIiwiQ1NTIiwiZXNjYXBlIiwiY3VycmVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ1c2VHcmlkRGltZW5zaW9ucyIsImlubGluZVNpemUiLCJzZXRJbmxpbmVTaXplIiwiYmxvY2tTaXplIiwic2V0QmxvY2tTaXplIiwiaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsInNldEhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQiLCJSZXNpemVPYnNlcnZlciIsIndpbmRvdyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJpbml0aWFsSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJyZXNpemVPYnNlcnZlciIsImVudHJpZXMiLCJzaXplIiwiY29udGVudEJveFNpemUiLCJjbGllbnRIZWlnaHQkMSIsIm9mZnNldEhlaWdodCQxIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJ1c2VMYXRlc3RGdW5jIiwiZm4iLCJjYWxsYmFja0ZuIiwidXNlUm92aW5nVGFiSW5kZXgiLCJpc1NlbGVjdGVkIiwiaXNDaGlsZEZvY3VzZWQiLCJzZXRJc0NoaWxkRm9jdXNlZCIsIm9uRm9jdXMiLCJjdXJyZW50VGFyZ2V0IiwiZWxlbWVudFRvRm9jdXMiLCJmb2N1cyIsInByZXZlbnRTY3JvbGwiLCJjaGlsZFRhYkluZGV4IiwidXNlVmlld3BvcnRDb2x1bW5zIiwicm93T3ZlcnNjYW5TdGFydElkeCIsInJvd092ZXJzY2FuRW5kSWR4Iiwic3RhcnRJZHgiLCJzdGFydElkeCQxIiwidXBkYXRlU3RhcnRJZHgiLCJ1c2VWaWV3cG9ydFJvd3MiLCJyb3dIZWlnaHQiLCJzY3JvbGxUb3AiLCJ0b3RhbFJvd0hlaWdodCIsImdyaWRUZW1wbGF0ZVJvd3MiLCJnZXRSb3dUb3AiLCJnZXRSb3dIZWlnaHQiLCJmaW5kUm93SWR4Iiwib2Zmc2V0IiwidG90YWxSb3dIZWlnaHQkMSIsImdyaWRUZW1wbGF0ZVJvd3MkMSIsImN1cnJlbnRIZWlnaHQiLCJyZXBlYXRDb3VudCIsInJvd1Bvc2l0aW9ucyIsImN1cnJlbnRSb3dIZWlnaHQiLCJwb3NpdGlvbiIsInRvcCIsInZhbGlkYXRlUm93SWR4Iiwic3RhcnQiLCJlbmQiLCJtaWRkbGUiLCJjdXJyZW50T2Zmc2V0Iiwib3ZlcnNjYW5UaHJlc2hvbGQiLCJyb3dWaXNpYmxlU3RhcnRJZHgiLCJyb3dWaXNpYmxlRW5kSWR4IiwiY2VsbERyYWdnZWRPdmVyQ2xhc3NuYW1lIiwiQ2VsbCIsImlzQ2VsbFNlbGVjdGVkIiwiaXNEcmFnZ2VkT3ZlciIsIm9uTW91c2VEb3duIiwib25DZWxsTW91c2VEb3duIiwib25DbGljayIsIm9uQ2VsbENsaWNrIiwib25Eb3VibGVDbGljayIsIm9uQ2VsbERvdWJsZUNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uQ2VsbENvbnRleHRNZW51Iiwib25Sb3dDaGFuZ2UiLCJzZWxlY3RDZWxsIiwiY2VsbENsYXNzIiwiaXNFZGl0YWJsZSIsInNlbGVjdENlbGxXcmFwcGVyIiwiZW5hYmxlRWRpdG9yIiwiaGFuZGxlTW91c2VFdmVudCIsImV2ZW50SGFuZGxlciIsImV2ZW50SGFuZGxlZCIsImhhbmRsZU1vdXNlRG93biIsImhhbmRsZUNsaWNrIiwiaGFuZGxlRG91YmxlQ2xpY2siLCJoYW5kbGVDb250ZXh0TWVudSIsImhhbmRsZVJvd0NoYW5nZSIsIm5ld1JvdyIsInJvbGUiLCJpc0NlbGxFZGl0YWJsZSIsIkNlbGxDb21wb25lbnQiLCJDZWxsX2RlZmF1bHQiLCJkZWZhdWx0UmVuZGVyQ2VsbCIsImNhblVzZVBvc3RUYXNrIiwic2NoZWR1bGVyIiwicG9zdFRhc2siLCJjZWxsRWRpdGluZyIsIkVkaXRDZWxsIiwiY2xvc2VFZGl0b3IiLCJuYXZpZ2F0ZSIsImNhcHR1cmVFdmVudFJlZiIsImFib3J0Q29udHJvbGxlclJlZiIsImZyYW1lUmVxdWVzdFJlZiIsImNvbW1pdE9uT3V0c2lkZUNsaWNrIiwiZWRpdG9yT3B0aW9ucyIsImNvbW1pdE9uT3V0c2lkZU1vdXNlRG93biIsIm9uQ2xvc2UiLCJvbldpbmRvd0NhcHR1cmVNb3VzZURvd24iLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJjYXRjaCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9uV2luZG93TW91c2VEb3duIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhcHR1cmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsVGFzayIsImFib3J0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtb2RlIiwiY29tbWl0Q2hhbmdlcyIsInNob3VsZEZvY3VzQ2VsbCIsIm9uRWRpdG9yUm93Q2hhbmdlIiwicm93JDIiLCJjb21taXRDaGFuZ2VzQW5kRm9jdXMiLCJkaXNwbGF5Q2VsbENvbnRlbnQiLCJvbk1vdXNlRG93bkNhcHR1cmUiLCJHcm91cGVkQ29sdW1uSGVhZGVyQ2VsbCIsImNlbGxTb3J0YWJsZUNsYXNzbmFtZSIsImNlbGxSZXNpemFibGVDbGFzc25hbWUiLCJyZXNpemVIYW5kbGVDbGFzc25hbWUiLCJjZWxsRHJhZ2dhYmxlQ2xhc3NuYW1lIiwiY2VsbERyYWdnaW5nQ2xhc3NuYW1lIiwiY2VsbE92ZXJDbGFzc25hbWUiLCJkcmFnSW1hZ2VDbGFzc25hbWUiLCJIZWFkZXJDZWxsIiwib25Db2x1bW5SZXNpemVFbmQiLCJvbkNvbHVtbnNSZW9yZGVyIiwic29ydENvbHVtbnMiLCJvblNvcnRDb2x1bW5zQ2hhbmdlIiwic2hvdWxkRm9jdXNHcmlkIiwiZHJhZ2dlZENvbHVtbktleSIsInNldERyYWdnZWRDb2x1bW5LZXkiLCJpc092ZXIiLCJzZXRJc092ZXIiLCJkcmFnSW1hZ2VSZWYiLCJpc0RyYWdnaW5nIiwic29ydEluZGV4IiwiZmluZEluZGV4IiwiY29sdW1uS2V5Iiwic29ydENvbHVtbiIsImFyaWFTb3J0Iiwib25Tb3J0IiwiY3RybENsaWNrIiwic29ydERlc2NlbmRpbmdGaXJzdCIsIm5leHRTb3J0IiwibmV4dFNvcnRDb2x1bW4iLCJuZXh0U29ydENvbHVtbnMiLCJzcGxpY2UiLCJoYW5kbGVGb2N1cyIsInByZXZlbnREZWZhdWx0Iiwib25EcmFnU3RhcnQiLCJkYXRhVHJhbnNmZXIiLCJzZXREcmFnSW1hZ2UiLCJkcm9wRWZmZWN0Iiwib25EcmFnRW5kIiwib25EcmFnT3ZlciIsIm9uRHJvcCIsIm9uRHJhZ0VudGVyIiwiaXNFdmVudFBlcnRpbmVudCIsIm9uRHJhZ0xlYXZlIiwiZHJhZ1RhcmdldFByb3BzIiwiZHJvcFRhcmdldFByb3BzIiwiY29udGVudCIsIlJlc2l6ZUhhbmRsZSIsInJlc2l6aW5nT2Zmc2V0UmVmIiwib25Qb2ludGVyRG93biIsInBvaW50ZXJUeXBlIiwiYnV0dG9ucyIsInBvaW50ZXJJZCIsInNldFBvaW50ZXJDYXB0dXJlIiwicmlnaHQiLCJwYXJlbnRFbGVtZW50IiwiY2xpZW50WCIsIm9uUG9pbnRlck1vdmUiLCJvbkxvc3RQb2ludGVyQ2FwdHVyZSIsInJlbGF0ZWRUYXJnZXQiLCJjb250YWlucyIsInJvd0NsYXNzbmFtZSIsInJvd1NlbGVjdGVkIiwicm93U2VsZWN0ZWRDbGFzc25hbWUiLCJyb3dTZWxlY3RlZFdpdGhGcm96ZW5DZWxsIiwidG9wU3VtbWFyeVJvd0NsYXNzbmFtZSIsImJvdHRvbVN1bW1hcnlSb3dDbGFzc25hbWUiLCJoZWFkZXJSb3ciLCJoZWFkZXJSb3dDbGFzc25hbWUiLCJIZWFkZXJSb3ciLCJoZWFkZXJSb3dDbGFzcyIsInNlbGVjdGVkQ2VsbElkeCIsImNlbGxzIiwiSGVhZGVyUm93X2RlZmF1bHQiLCJHcm91cGVkQ29sdW1uSGVhZGVyUm93IiwicmVuZGVyZWRQYXJlbnRzIiwiR3JvdXBlZENvbHVtbkhlYWRlclJvd19kZWZhdWx0IiwiUm93IiwiZHJhZ2dlZE92ZXJDZWxsSWR4Iiwic2VsZWN0ZWRDZWxsRWRpdG9yIiwicm93Q2xhc3MiLCJSb3dDb21wb25lbnQiLCJSb3dfZGVmYXVsdCIsImRlZmF1bHRSZW5kZXJSb3ciLCJTY3JvbGxUb0NlbGwiLCJzY3JvbGxUb1Bvc2l0aW9uIiwic2V0U2Nyb2xsVG9DZWxsUG9zaXRpb24iLCJyZW1vdmVTY3JvbGxUb0NlbGwiLCJvYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdCIsInRocmVzaG9sZCIsImdyaWRDb2x1bW4iLCJncmlkUm93IiwiYXJyb3dDbGFzc25hbWUiLCJyZW5kZXJTb3J0SWNvbiIsInJlbmRlclNvcnRQcmlvcml0eSIsInJvb3RDbGFzc25hbWUiLCJ2aWV3cG9ydERyYWdnaW5nIiwidmlld3BvcnREcmFnZ2luZ0NsYXNzbmFtZSIsImZvY3VzU2lua0NsYXNzbmFtZSIsImZvY3VzU2lua0hlYWRlckFuZFN1bW1hcnlDbGFzc25hbWUiLCJzdW1tYXJ5Q2VsbENsYXNzbmFtZSIsIlN1bW1hcnlDZWxsIiwic3VtbWFyeUNlbGxDbGFzcyIsInJlbmRlclN1bW1hcnlDZWxsIiwiU3VtbWFyeUNlbGxfZGVmYXVsdCIsInN1bW1hcnlSb3ciLCJ0b3BTdW1tYXJ5Um93Iiwic3VtbWFyeVJvd0NsYXNzbmFtZSIsIlN1bW1hcnlSb3ciLCJib3R0b20iLCJpc1RvcCIsImFyaWFSb3dJbmRleCIsIlN1bW1hcnlSb3dfZGVmYXVsdCIsIkRhdGFHcmlkIiwicm93S2V5R2V0dGVyIiwib25Sb3dzQ2hhbmdlIiwicmF3Um93SGVpZ2h0IiwiaGVhZGVyUm93SGVpZ2h0IiwicmF3SGVhZGVyUm93SGVpZ2h0Iiwic3VtbWFyeVJvd0hlaWdodCIsInJhd1N1bW1hcnlSb3dIZWlnaHQiLCJjb2x1bW5XaWR0aHNSYXciLCJvbkNvbHVtbldpZHRoc0NoYW5nZVJhdyIsInNlbGVjdGVkUm93cyIsIm9uU2VsZWN0ZWRSb3dzQ2hhbmdlIiwib25DZWxsS2V5RG93biIsIm9uU2VsZWN0ZWRDZWxsQ2hhbmdlIiwib25TY3JvbGwiLCJvbkZpbGwiLCJvbkNlbGxDb3B5Iiwib25DZWxsUGFzdGUiLCJyYXdFbmFibGVWaXJ0dWFsaXphdGlvbiIsInJlbmRlcmVycyIsInJhd0RpcmVjdGlvbiIsInJhd1JvbGUiLCJhcmlhRGVzY3JpcHRpb24iLCJhcmlhRGVzY3JpYmVkQnkiLCJyYXdBcmlhUm93Q291bnQiLCJ0ZXN0SWQiLCJkYXRhQ3kiLCJkZWZhdWx0UmVuZGVyZXJzIiwicmVuZGVyUm93Iiwibm9Sb3dzRmFsbGJhY2siLCJzZXRTY3JvbGxUb3AiLCJzZXRTY3JvbGxMZWZ0IiwiY29sdW1uV2lkdGhzSW50ZXJuYWwiLCJzZXRDb2x1bW5XaWR0aHNJbnRlcm5hbCIsImlzQ29sdW1uUmVzaXppbmciLCJzZXREcmFnZ2luZyIsImRyYWdnZWRPdmVyUm93SWR4Iiwic2V0RHJhZ2dlZE92ZXJSb3dJZHgiLCJzZXRTY3JvbGxUb1Bvc2l0aW9uIiwic2V0U2hvdWxkRm9jdXNDZWxsIiwicHJldmlvdXNSb3dJZHgiLCJzZXRQcmV2aW91c1Jvd0lkeCIsImlzQ29sdW1uV2lkdGhzQ29udHJvbGxlZCIsImNvbHVtbldpZHRocyQxIiwiZ3JpZEhlaWdodCIsImJvdHRvbVN1bW1hcnlSb3dzQ291bnQiLCJzdW1tYXJ5Um93c0NvdW50IiwiaGVhZGVyQW5kVG9wU3VtbWFyeVJvd3NDb3VudCIsImdyb3VwZWRDb2x1bW5IZWFkZXJSb3dzQ291bnQiLCJzZXRTZWxlY3RlZFBvc2l0aW9uIiwiZm9jdXNTaW5rUmVmIiwiaXNUcmVlR3JpZCIsImhlYWRlclJvd3NIZWlnaHQiLCJzdW1tYXJ5Um93c0hlaWdodCIsImlzU2VsZWN0YWJsZSIsImFyaWFSb3dDb3VudCIsImRlZmF1bHRHcmlkQ29tcG9uZW50cyIsImhlYWRlclNlbGVjdGlvblZhbHVlIiwiaGFzU2VsZWN0ZWRSb3ciLCJoYXNVbnNlbGVjdGVkUm93IiwibWluQ29sSWR4Iiwic2VsZWN0ZWRDZWxsSXNXaXRoaW5TZWxlY3Rpb25Cb3VuZHMiLCJpc0NlbGxXaXRoaW5TZWxlY3Rpb25Cb3VuZHMiLCJzZWxlY3RlZENlbGxJc1dpdGhpblZpZXdwb3J0Qm91bmRzIiwiaXNDZWxsV2l0aGluVmlld3BvcnRCb3VuZHMiLCJzY3JvbGxIZWlnaHQiLCJoYW5kbGVDb2x1bW5SZXNpemVMYXRlc3QiLCJoYW5kbGVDb2x1bW5SZXNpemVFbmRMYXRlc3QiLCJoYW5kbGVDb2x1bW5SZXNpemVFbmQiLCJvbkNvbHVtbnNSZW9yZGVyTGFzdGVzdCIsIm9uU29ydENvbHVtbnNDaGFuZ2VMYXRlc3QiLCJvbkNlbGxNb3VzZURvd25MYXRlc3QiLCJvbkNlbGxDbGlja0xhdGVzdCIsIm9uQ2VsbERvdWJsZUNsaWNrTGF0ZXN0Iiwib25DZWxsQ29udGV4dE1lbnVMYXRlc3QiLCJzZWxlY3RIZWFkZXJSb3dMYXRlc3QiLCJzZWxlY3RIZWFkZXJSb3ciLCJzZWxlY3RSb3dMYXRlc3QiLCJzZWxlY3RSb3ciLCJoYW5kbGVGb3JtYXR0ZXJSb3dDaGFuZ2VMYXRlc3QiLCJ1cGRhdGVSb3ciLCJzZWxlY3RDZWxsTGF0ZXN0Iiwic2VsZWN0SGVhZGVyQ2VsbExhdGVzdCIsInNlbGVjdEhlYWRlckNlbGwiLCJmb2N1c0NlbGwiLCJzaG91bGRTY3JvbGwiLCJjZWxsJDEiLCJnZXRDZWxsVG9TY3JvbGwiLCJzY3JvbGxUb0NlbGwiLCJzY3JvbGxUb0lkeCIsInNjcm9sbFRvUm93SWR4IiwiaXNSb3dJZHhXaXRoaW5WaWV3cG9ydEJvdW5kcyIsIm5ld1NlbGVjdGVkUm93cyIsInJvd0tleSIsImluZGV4T2YiLCJzdGVwIiwiRWxlbWVudCIsImlzQ2VsbEV2ZW50IiwiaXNSb3dFdmVudCIsImhhbmRsZUNlbGxJbnB1dCIsImhhbmRsZVNjcm9sbCIsInNjcm9sbFRvcCQxIiwic2Nyb2xsTGVmdCQxIiwid2l0aCIsImluZGV4ZXMiLCJjb21taXRFZGl0b3JDaGFuZ2VzIiwiaGFuZGxlQ2VsbENvcHkiLCJoYW5kbGVDZWxsUGFzdGUiLCJvcmlnaW5hbFJvdyIsImhhbmRsZURyYWdIYW5kbGVQb2ludGVyRG93biIsImhhbmRsZURyYWdIYW5kbGVQb2ludGVyTW92ZSIsImdyaWRFbCIsIm92ZXJSb3dJZHgiLCJjbGllbnRZIiwiaGFuZGxlRHJhZ0hhbmRsZUxvc3RQb2ludGVyQ2FwdHVyZSIsInN0YXJ0Um93SW5kZXgiLCJlbmRSb3dJbmRleCIsInVwZGF0ZVJvd3MiLCJoYW5kbGVEcmFnSGFuZGxlQ2xpY2siLCJoYW5kbGVEcmFnSGFuZGxlRG91YmxlQ2xpY2siLCJzdGFydFJvd0lkeCIsImVuZFJvd0lkeCIsInNvdXJjZVJvdyIsInVwZGF0ZWRSb3dzIiwidXBkYXRlZFJvdyIsInRhcmdldFJvdyIsImlzQ29sSWR4V2l0aGluU2VsZWN0aW9uQm91bmRzIiwiaXNDZWxsV2l0aGluRWRpdEJvdW5kcyIsIm9wdGlvbnMiLCJzYW1lUG9zaXRpb24iLCJpc1NhbWVQb3NpdGlvbiIsImdldE5leHRQb3NpdGlvbiIsIm5leHRSb3dZIiwiZ2V0RHJhZ2dlZE92ZXJDZWxsSWR4IiwiZ2V0RHJhZ0hhbmRsZSIsImlzTGFzdFJvdyIsInN0eWxlJDEiLCJtYXJnaW5FbmQiLCJpc0xhc3RDb2x1bW4iLCJtYXJnaW5JbmxpbmVFbmQiLCJtYXJnaW5CbG9ja0VuZCIsImdldENlbGxFZGl0b3IiLCJjbG9zZU9uRXh0ZXJuYWxSb3dDaGFuZ2UiLCJzaG91bGRGb2N1c0NlbGwkMSIsImlkeCQxIiwicm93SWR4JDEiLCJnZXRSb3dWaWV3cG9ydENvbHVtbnMiLCJzZWxlY3RlZENvbHVtbiIsImluY2x1ZGVzIiwic2xpY2UiLCJnZXRWaWV3cG9ydFJvd3MiLCJyb3dFbGVtZW50cyIsInNlbGVjdGVkSWR4Iiwic2VsZWN0ZWRSb3dJZHgiLCJ2aWV3cG9ydFJvd0lkeCIsImlzUm93T3V0c2lkZVZpZXdwb3J0Iiwicm93Q29sdW1ucyIsInRlbXBsYXRlUm93cyIsImlzR3JvdXBSb3dGb2N1c2VkIiwic2Nyb2xsUGFkZGluZ0lubGluZVN0YXJ0Iiwic2Nyb2xsUGFkZGluZ0Jsb2NrIiwiZGlyIiwib25Db3B5Iiwib25QYXN0ZSIsIkFycmF5IiwiZnJvbSIsIl8iLCJzdW1tYXJ5Um93SWR4IiwiaXNTdW1tYXJ5Um93U2VsZWN0ZWQiLCJwMSIsInAyIiwiR3JvdXBDZWxsIiwiaWQiLCJjaGlsZFJvd3MiLCJncm91cENvbHVtbkluZGV4IiwiaXNHcm91cEJ5Q29sdW1uIiwidG9nZ2xlR3JvdXBXcmFwcGVyIiwiaXNMZXZlbE1hdGNoaW5nIiwiY3Vyc29yIiwiR3JvdXBDZWxsX2RlZmF1bHQiLCJncm91cFJvd0NsYXNzbmFtZSIsIkdyb3VwZWRSb3ciLCJncm91cEJ5IiwiaGFuZGxlU2VsZWN0R3JvdXAiLCJzZXRTaXplIiwicG9zSW5TZXQiLCJHcm91cFJvd19kZWZhdWx0IiwiVHJlZURhdGFHcmlkIiwicmF3Um93cyIsInJhd1Jvd0tleUdldHRlciIsInJhd09uQ2VsbEtleURvd24iLCJyYXdPbkNlbGxDb3B5IiwicmF3T25DZWxsUGFzdGUiLCJyYXdTZWxlY3RlZFJvd3MiLCJyYXdPblNlbGVjdGVkUm93c0NoYW5nZSIsInJhd0dyb3VwQnkiLCJyb3dHcm91cGVyIiwiZXhwYW5kZWRHcm91cElkcyIsIm9uRXhwYW5kZWRHcm91cElkc0NoYW5nZSIsImdyb3VwSWRHZXR0ZXIiLCJyYXdHcm91cElkR2V0dGVyIiwicmF3UmVuZGVyUm93IiwidG9nZ2xlR3JvdXBMYXRlc3QiLCJkZWZhdWx0R3JvdXBJZEdldHRlciIsInRvU29ydGVkIiwiZ3JvdXBCeSQxIiwiZ3JvdXBlZFJvd3MiLCJyb3dzQ291bnQiLCJncm91cFJvd3MiLCJyb3dzJDEiLCJncm91cEJ5S2V5IiwicmVtYWluaW5nR3JvdXBCeUtleXMiLCJncm91cFJvd3NDb3VudCIsImdyb3VwcyIsImNoaWxkR3JvdXBzIiwiY2hpbGRSb3dzQ291bnQiLCJpc0dyb3VwUm93IiwiYWxsR3JvdXBSb3dzIiwiaXNHcm91cFJvdyQxIiwiZmxhdHRlbmVkUm93cyIsImV4cGFuZEdyb3VwIiwicGFyZW50SWQiLCJpc1JlYWRvbmx5QXJyYXkiLCJrZXlzIiwiZ3JvdXBSb3ciLCJnZXRQYXJlbnRSb3dBbmRJbmRleCIsInBhcmVudFJvdyIsInBhcmVudFJvd0FuZEluZGV4Iiwic2VsZWN0ZWRSb3dzJDEiLCJldmVyeSIsImNyIiwibmV3UmF3U2VsZWN0ZWRSb3dzIiwiaGFuZGxlUm93c0NoYW5nZSIsInVwZGF0ZWRSYXdSb3dzIiwicmF3SW5kZXhlcyIsInJhd0luZGV4IiwiZ3JvdXBJZCIsIm5ld0V4cGFuZGVkR3JvdXBJZHMiLCJyb3dQcm9wcyIsImdyb3VwSW5kZXgiLCJhcnIiLCJpc0FycmF5IiwidGV4dEVkaXRvckludGVybmFsQ2xhc3NuYW1lIiwidGV4dEVkaXRvckNsYXNzbmFtZSIsImF1dG9Gb2N1c0FuZFNlbGVjdCIsImlucHV0Iiwic2VsZWN0IiwidGV4dFRleHRFZGl0b3IiLCJvbkJsdXIiLCJyZW5kZXJUZXh0RWRpdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-data-grid@7.0.0-beta._1cb3af74ea5d44e0cf5a6ce7b0adb28a/node_modules/react-data-grid/lib/index.js\n");

/***/ })

};
;