"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+search@6.6.0";
exports.ids = ["vendor-chunks/@codemirror+search@6.6.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@codemirror+search@6.6.0/node_modules/@codemirror/search/dist/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@codemirror+search@6.6.0/node_modules/@codemirror/search/dist/index.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpCursor: () => (/* binding */ RegExpCursor),\n/* harmony export */   SearchCursor: () => (/* binding */ SearchCursor),\n/* harmony export */   SearchQuery: () => (/* binding */ SearchQuery),\n/* harmony export */   closeSearchPanel: () => (/* binding */ closeSearchPanel),\n/* harmony export */   findNext: () => (/* binding */ findNext),\n/* harmony export */   findPrevious: () => (/* binding */ findPrevious),\n/* harmony export */   getSearchQuery: () => (/* binding */ getSearchQuery),\n/* harmony export */   gotoLine: () => (/* binding */ gotoLine),\n/* harmony export */   highlightSelectionMatches: () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   openSearchPanel: () => (/* binding */ openSearchPanel),\n/* harmony export */   replaceAll: () => (/* binding */ replaceAll),\n/* harmony export */   replaceNext: () => (/* binding */ replaceNext),\n/* harmony export */   search: () => (/* binding */ search),\n/* harmony export */   searchKeymap: () => (/* binding */ searchKeymap),\n/* harmony export */   searchPanelOpen: () => (/* binding */ searchPanelOpen),\n/* harmony export */   selectMatches: () => (/* binding */ selectMatches),\n/* harmony export */   selectNextOccurrence: () => (/* binding */ selectNextOccurrence),\n/* harmony export */   selectSelectionMatches: () => (/* binding */ selectSelectionMatches),\n/* harmony export */   setSearchQuery: () => (/* binding */ setSearchQuery)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/.pnpm/@codemirror+view@6.39.11/node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/.pnpm/@codemirror+state@6.5.4/node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/.pnpm/crelt@1.0.6/node_modules/crelt/index.js\");\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? (x)=>x.normalize(\"NFKD\") : (x)=>x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/ class SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */ constructor(text, query, from = 0, to = text.length, normalize, test){\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */ this.value = {\n            from: 0,\n            to: 0\n        };\n        /**\n        Whether the end of the iterated region has been reached.\n        */ this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? (x)=>normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done) return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */ next() {\n        while(this.matches.length)this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */ nextOverlapping() {\n        for(;;){\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            if (norm.length) for(let i = 0, pos = start;; i++){\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for(let i = 0; i < this.matches.length; i += 2){\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = {\n                        from: this.matches[i + 1],\n                        to: end\n                    };\n                } else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1) match = {\n                from: pos,\n                to: end\n            };\n            else this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function() {\n    return this;\n};\nconst empty = {\n    from: -1,\n    to: -1,\n    match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/ class RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */ constructor(text, query, options, from = 0, to = text.length){\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */ this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */ this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        } else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to) this.curLine = \"\";\n        else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */ next() {\n        for(let off = this.matchPos - this.curLineStart;;){\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length) this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            } else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            } else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/ new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text){\n        this.from = from;\n        this.text = text;\n    }\n    get to() {\n        return this.from + this.text.length;\n    }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to) return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to) text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to){\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */ ));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for(;;){\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length) return pos;\n    let line = text.lineAt(pos), next;\n    while(pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)pos++;\n    return pos;\n}\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/ const gotoLine = (view)=>{\n    let { state } = view;\n    let line = String(state.doc.lineAt(view.state.selection.main.head).number);\n    let { close, result } = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showDialog)(view, {\n        label: state.phrase(\"Go to line\"),\n        input: {\n            type: \"text\",\n            name: \"line\",\n            value: line\n        },\n        focus: true,\n        submitLabel: state.phrase(\"go\")\n    });\n    result.then((form)=>{\n        let match = form && /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(form.elements[\"line\"].value);\n        if (!match) {\n            view.dispatch({\n                effects: close\n            });\n            return;\n        }\n        let startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n            line = Math.round(state.doc.lines * pc);\n        } else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [\n                close,\n                _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, {\n                    y: \"center\"\n                })\n            ],\n            selection\n        });\n    });\n    return true;\n};\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b)=>a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/ function highlightSelectionMatches(options) {\n    let ext = [\n        defaultTheme,\n        matchHighlighter\n    ];\n    if (options) ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        } else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            } else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges){\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while(!cursor.next().done){\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nconst defaultTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#99ff7780\"\n    },\n    \".cm-searchMatch .cm-selectionMatch\": {\n        backgroundColor: \"transparent\"\n    }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch })=>{\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map((range)=>state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection)) return false;\n    dispatch(state.update({\n        selection: newSel\n    }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for(let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;){\n        cursor.next();\n        if (cursor.done) {\n            if (cycled) return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        } else {\n            if (cycled && ranges.some((r)=>r.from == cursor.value.from)) continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/ const selectNextOccurrence = ({ state, dispatch })=>{\n    let { ranges } = state.selection;\n    if (ranges.some((sel)=>sel.from === sel.to)) return selectWord({\n        state,\n        dispatch\n    });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some((r)=>state.sliceDoc(r.from, r.to) != searchedText)) return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range) return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\nconst searchConfigFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: (view)=>new SearchPanel(view),\n            scrollToMatch: (range)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/ function search(config) {\n    return config ? [\n        searchConfigFacet.of(config),\n        searchExtensions\n    ] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/ class SearchQuery {\n    /**\n    Create a query object.\n    */ constructor(config){\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n        this.test = config.test;\n    }\n    /**\n    @internal\n    */ unquote(text) {\n        return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, (_, ch)=>ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */ eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord && this.test == other.test;\n    }\n    /**\n    @internal\n    */ create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */ getCursor(state, from = 0, to) {\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n            doc: state\n        });\n        if (to == null) to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec){\n        this.spec = spec;\n    }\n}\nfunction wrapStringTest(test, state, inner) {\n    return (from, to, buffer, bufferPos)=>{\n        if (inner && !inner(from, to, buffer, bufferPos)) return false;\n        let match = from >= bufferPos && to <= bufferPos + buffer.length ? buffer.slice(from - bufferPos, to - bufferPos) : state.doc.sliceString(from, to);\n        return test(match, state, from, to);\n    };\n}\nfunction stringCursor(spec, state, from, to) {\n    let test;\n    if (spec.wholeWord) test = stringWordTest(state.doc, state.charCategorizer(state.selection.main.head));\n    if (spec.test) test = wrapStringTest(spec.test, state, test);\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : (x)=>x.toLowerCase(), test);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos)=>{\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec){\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) {\n            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);\n            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();\n        }\n        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for(let pos = to;;){\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */  - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while(!cursor.nextOverlapping().done)range = cursor.value;\n            if (range) return range;\n            if (start == from) return null;\n            pos -= 10000 /* FindPrev.ChunkSize */ ;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        let found = this.prevMatchInRange(state, 0, curFrom);\n        if (!found) found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);\n        return found && (found.from != curFrom || found.to != curTo) ? found : null;\n    }\n    getReplacement(_result) {\n        return this.spec.unquote(this.spec.replace);\n    }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction wrapRegexpTest(test, state, inner) {\n    return (from, to, match)=>{\n        return (!inner || inner(from, to, match)) && test(match[0], state, from, to);\n    };\n}\nfunction regexpCursor(spec, state, from, to) {\n    let test;\n    if (spec.wholeWord) test = regexpWordTest(state.charCategorizer(state.selection.main.head));\n    if (spec.test) test = wrapRegexpTest(spec.test, state, test);\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match)=>!match[0].length || (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for(let size = 1;; size++){\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */ );\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while(!cursor.next().done)range = cursor.value;\n            if (range && (start == from || range.from > start + 10)) return range;\n            if (start == from) return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&]|\\d+)/g, (m, i)=>{\n            if (i == \"&\") return result.match[0];\n            if (i == \"$\") return \"$\";\n            for(let l = i.length; l > 0; l--){\n                let n = +i.slice(0, l);\n                if (n > 0 && n < result.match.length) return result.match[n] + i.slice(l);\n            }\n            return m;\n        });\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */ ), Math.min(to + 250 /* RegExp.HighlightMargin */ , state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/ const setSearchQuery = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create (state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/ function getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/ function searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel){\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch\"\n}), selectedMatchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for(let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++){\n            let { from, to } = ranges[i];\n            while(i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */ )to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to)=>{\n                let selected = view.state.selection.ranges.some((r)=>r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nfunction searchCommand(f) {\n    return (view)=>{\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/ const findNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, next),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/ const findPrevious = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, prev),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/ const selectMatches = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length) return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/ const selectSelectionMatches = ({ state, dispatch })=>{\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty) return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for(let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;){\n        if (ranges.length > 1000) return false;\n        if (cur.value.from == from) main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/ const replaceNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly) return false;\n    let match = query.nextMatch(state, from, from);\n    if (!match) return false;\n    let next = match;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({\n            from: next.from,\n            to: next.to,\n            insert: replacement\n        });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    let changeSet = view.state.changes(changes);\n    if (next) {\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to).map(changeSet);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes: changeSet,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/ const replaceAll = /*@__PURE__*/ searchCommand((view, { query })=>{\n    if (view.state.readOnly) return false;\n    let changes = query.matchAll(view.state, 1e9).map((match)=>{\n        let { from, to } = match;\n        return {\n            from,\n            to,\n            insert: query.getReplacement(match)\n        };\n    });\n    if (!changes.length) return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText) return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement) input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/ const openSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid) view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n            searchInput.focus();\n            searchInput.select();\n        }\n    } else {\n        view.dispatch({\n            effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\n            ]\n        });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/ const closeSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel) return false;\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/ const searchKeymap = [\n    {\n        key: \"Mod-f\",\n        run: openSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"F3\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Mod-g\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Escape\",\n        run: closeSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"Mod-Shift-l\",\n        run: selectSelectionMatches\n    },\n    {\n        key: \"Mod-Alt-g\",\n        run: gotoLine\n    },\n    {\n        key: \"Mod-d\",\n        run: selectNextOccurrence,\n        preventDefault: true\n    }\n];\nclass SearchPanel {\n    constructor(view){\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                class: \"cm-button\",\n                name,\n                onclick,\n                type: \"button\"\n            }, content);\n        }\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            onkeydown: (e)=>this.keydown(e),\n            class: \"cm-search\"\n        }, [\n            this.searchField,\n            button(\"next\", ()=>findNext(view), [\n                phrase(view, \"next\")\n            ]),\n            button(\"prev\", ()=>findPrevious(view), [\n                phrase(view, \"previous\")\n            ]),\n            button(\"select\", ()=>selectMatches(view), [\n                phrase(view, \"all\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.caseField,\n                phrase(view, \"match case\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.reField,\n                phrase(view, \"regexp\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.wordField,\n                phrase(view, \"by word\")\n            ]),\n            ...view.state.readOnly ? [] : [\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n                this.replaceField,\n                button(\"replace\", ()=>replaceNext(view), [\n                    phrase(view, \"replace\")\n                ]),\n                button(\"replaceAll\", ()=>replaceAll(view), [\n                    phrase(view, \"replace all\")\n                ])\n            ],\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                name: \"close\",\n                onclick: ()=>closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\n                \"\\xd7\"\n            ])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n        }\n    }\n    keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        } else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        } else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)for (let effect of tr.effects){\n            if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n        }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() {\n        return 80;\n    }\n    get top() {\n        return this.view.state.facet(searchConfigFacet).top;\n    }\n}\nfunction phrase(view, phrase) {\n    return view.state.phrase(phrase);\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for(let i = 0; i < AnnounceMargin; i++)if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n            text = text.slice(i);\n            break;\n        }\n    }\n    if (end != lineEnd) {\n        for(let i = text.length - 1; i > text.length - AnnounceMargin; i--)if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n            text = text.slice(0, i);\n            break;\n        }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": {\n        backgroundColor: \"#ffff0054\"\n    },\n    \"&dark .cm-searchMatch\": {\n        backgroundColor: \"#00ffff8a\"\n    },\n    \"&light .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff6a0054\"\n    },\n    \"&dark .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff00ff8a\"\n    }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),\n    baseTheme\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3Irc2VhcmNoQDYuNi4wL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zZWFyY2gvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlIO0FBQ3lGO0FBQzFMO0FBRXhCLE1BQU1xQixpQkFBaUIsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxTQUFTLElBQUksYUFDdERDLENBQUFBLElBQUtBLEVBQUVELFNBQVMsQ0FBQyxVQUFVQyxDQUFBQSxJQUFLQTtBQUN0Qzs7O0FBR0EsR0FDQSxNQUFNQztJQUNGOzs7Ozs7Ozs7Ozs7SUFZQSxHQUNBQyxZQUFZQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTyxDQUFDLEVBQUVDLEtBQUtILEtBQUtJLE1BQU0sRUFBRVIsU0FBUyxFQUFFUyxJQUFJLENBQUU7UUFDbEUsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1o7Ozs7UUFJQSxHQUNBLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1lBQUVKLE1BQU07WUFBR0MsSUFBSTtRQUFFO1FBQzlCOztRQUVBLEdBQ0EsSUFBSSxDQUFDSSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxJQUFJLEdBQUdYLEtBQUtZLFNBQVMsQ0FBQ1YsTUFBTUM7UUFDakMsSUFBSSxDQUFDVSxXQUFXLEdBQUdYO1FBQ25CLElBQUksQ0FBQ04sU0FBUyxHQUFHQSxZQUFZQyxDQUFBQSxJQUFLRCxVQUFVSCxlQUFlSSxNQUFNSjtRQUNqRSxJQUFJLENBQUNRLEtBQUssR0FBRyxJQUFJLENBQUNMLFNBQVMsQ0FBQ0s7SUFDaEM7SUFDQWEsT0FBTztRQUNILElBQUksSUFBSSxDQUFDSixTQUFTLElBQUksSUFBSSxDQUFDRCxNQUFNLENBQUNMLE1B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MEI7WUFDdEJDLGFBQWE7UUFDakI7UUFDQSxXQUFXO1lBQ1BDLFVBQVU7WUFDVkMsWUFBWTtRQUNoQjtJQUNKO0lBQ0EsMEJBQTBCO1FBQUVoTCxpQkFBaUI7SUFBWTtJQUN6RCx5QkFBeUI7UUFBRUEsaUJBQWlCO0lBQVk7SUFDeEQsbUNBQW1DO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ2xFLGtDQUFrQztRQUFFQSxpQkFBaUI7SUFBWTtBQUNyRTtBQUNBLE1BQU0yQixtQkFBbUI7SUFDckJpRDtJQUNBLFdBQVcsR0FBRWhQLG1EQUFJQSxDQUFDcVYsR0FBRyxDQUFDcEY7SUFDdEI5RjtDQUNIO0FBRStTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VudGluZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3Irc2VhcmNoQDYuNi4wL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zZWFyY2gvZGlzdC9pbmRleC5qcz82MmI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNob3dEaWFsb2csIEVkaXRvclZpZXcsIERlY29yYXRpb24sIFZpZXdQbHVnaW4sIHNob3dQYW5lbCwgcnVuU2NvcGVIYW5kbGVycywgZ2V0UGFuZWwgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IGNvZGVQb2ludEF0LCBmcm9tQ29kZVBvaW50LCBjb2RlUG9pbnRTaXplLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBDaGFyQ2F0ZWdvcnksIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBSYW5nZVNldEJ1aWxkZXIsIFByZWMsIEVkaXRvclN0YXRlLCBmaW5kQ2x1c3RlckJyZWFrIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XG5cbmNvbnN0IGJhc2ljTm9ybWFsaXplID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplID09IFwiZnVuY3Rpb25cIlxuICAgID8geCA9PiB4Lm5vcm1hbGl6ZShcIk5GS0RcIikgOiB4ID0+IHg7XG4vKipcbkEgc2VhcmNoIGN1cnNvciBwcm92aWRlcyBhbiBpdGVyYXRvciBvdmVyIHRleHQgbWF0Y2hlcyBpbiBhXG5kb2N1bWVudC5cbiovXG5jbGFzcyBTZWFyY2hDdXJzb3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgY3Vyc29yLiBUaGUgcXVlcnkgaXMgdGhlIHNlYXJjaCBzdHJpbmcsIGBmcm9tYCB0b1xuICAgIGB0b2AgcHJvdmlkZXMgdGhlIHJlZ2lvbiB0byBzZWFyY2guXG4gICAgXG4gICAgV2hlbiBgbm9ybWFsaXplYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBjYWxsZWQsIG9uIGJvdGggdGhlIHF1ZXJ5XG4gICAgc3RyaW5nIGFuZCB0aGUgY29udGVudCBpdCBpcyBtYXRjaGVkIGFnYWluc3QsIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgWW91IGNhbiwgZm9yIGV4YW1wbGUsIGNyZWF0ZSBhIGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoIGJ5XG4gICAgcGFzc2luZyBgcyA9PiBzLnRvTG93ZXJDYXNlKClgLlxuICAgIFxuICAgIFRleHQgaXMgYWx3YXlzIG5vcm1hbGl6ZWQgd2l0aFxuICAgIFtgLm5vcm1hbGl6ZShcIk5GS0RcIilgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplKVxuICAgICh3aGVuIHN1cHBvcnRlZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgsIG5vcm1hbGl6ZSwgdGVzdCkge1xuICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGN1cnJlbnQgbWF0Y2ggKG9ubHkgaG9sZHMgYSBtZWFuaW5nZnVsIHZhbHVlIGFmdGVyXG4gICAgICAgIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5uZXh0KSBoYXMgYmVlbiBjYWxsZWQgYW5kIHdoZW5cbiAgICAgICAgYGRvbmVgIGlzIGZhbHNlKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbTogMCwgdG86IDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgaXRlcmF0ZWQgcmVnaW9uIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlclJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5idWZmZXJTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplID8geCA9PiBub3JtYWxpemUoYmFzaWNOb3JtYWxpemUoeCkpIDogYmFzaWNOb3JtYWxpemU7XG4gICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLm5vcm1hbGl6ZShxdWVyeSk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclBvcyA9PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgKz0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZVBvaW50QXQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgdGhlIG5leHQgbWF0Y2guIFVwZGF0ZXMgdGhlIGl0ZXJhdG9yJ3NcbiAgICBbYHZhbHVlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLnZhbHVlKSBhbmRcbiAgICBbYGRvbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IuZG9uZSkgcHJvcGVydGllcy4gU2hvdWxkIGJlIGNhbGxlZFxuICAgIGF0IGxlYXN0IG9uY2UgYmVmb3JlIHVzaW5nIHRoZSBjdXJzb3IuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5tYXRjaGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBgbmV4dGAgbWV0aG9kIHdpbGwgaWdub3JlIG1hdGNoZXMgdGhhdCBwYXJ0aWFsbHkgb3ZlcmxhcCBhXG4gICAgcHJldmlvdXMgbWF0Y2guIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSBgbmV4dGAsIGJ1dCBpbmNsdWRlc1xuICAgIHN1Y2ggbWF0Y2hlcy5cbiAgICAqL1xuICAgIG5leHRPdmVybGFwcGluZygpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RyID0gZnJvbUNvZGVQb2ludChuZXh0KSwgc3RhcnQgPSB0aGlzLmJ1ZmZlclN0YXJ0ICsgdGhpcy5idWZmZXJQb3M7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSB0aGlzLm5vcm1hbGl6ZShzdHIpO1xuICAgICAgICAgICAgaWYgKG5vcm0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IG5vcm0uY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaChjb2RlLCBwb3MsIHRoaXMuYnVmZmVyUG9zICsgdGhpcy5idWZmZXJTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IG5vcm0ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBpIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChpKSA9PSBjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoKGNvZGUsIHBvcywgZW5kKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm1hdGNoZXNbaV0sIGtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoaW5kZXgpID09IGNvZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5xdWVyeS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiB0aGlzLm1hdGNoZXNbaSArIDFdLCB0bzogZW5kIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNbaV0rKztcbiAgICAgICAgICAgICAgICAgICAga2VlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdCgwKSA9PSBjb2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogcG9zLCB0bzogZW5kIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnB1c2goMSwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggJiYgdGhpcy50ZXN0ICYmICF0aGlzLnRlc3QobWF0Y2guZnJvbSwgbWF0Y2gudG8sIHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlclN0YXJ0KSlcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpXG4gICAgU2VhcmNoQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuY29uc3QgZW1wdHkgPSB7IGZyb206IC0xLCB0bzogLTEsIG1hdGNoOiAvKkBfX1BVUkVfXyovLy4qLy5leGVjKFwiXCIpIH07XG5jb25zdCBiYXNlRmxhZ3MgPSBcImdtXCIgKyAoL3gvLnVuaWNvZGUgPT0gbnVsbCA/IFwiXCIgOiBcInVcIik7XG4vKipcblRoaXMgY2xhc3MgaXMgc2ltaWxhciB0byBbYFNlYXJjaEN1cnNvcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvcilcbmJ1dCBzZWFyY2hlcyBmb3IgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiBpbnN0ZWFkIG9mIGEgcGxhaW5cbnN0cmluZy5cbiovXG5jbGFzcyBSZWdFeHBDdXJzb3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciB0aGF0IHdpbGwgc2VhcmNoIHRoZSBnaXZlbiByYW5nZSBpbiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gYHF1ZXJ5YCBzaG91bGQgYmUgdGhlIHJhdyBwYXR0ZXJuIChhcyB5b3UnZCBwYXNzIGl0IHRvXG4gICAgYG5ldyBSZWdFeHBgKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBTZXQgdG8gYHRydWVgIHdoZW4gdGhlIGN1cnNvciBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZWFyY2hcbiAgICAgICAgcmFuZ2UuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2lsbCBjb250YWluIGFuIG9iamVjdCB3aXRoIHRoZSBleHRlbnQgb2YgdGhlIG1hdGNoIGFuZCB0aGVcbiAgICAgICAgbWF0Y2ggb2JqZWN0IHdoZW4gW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guUmVnRXhwQ3Vyc29yLm5leHQpXG4gICAgICAgIHN1Y2Vzc2Z1bGx5IGZpbmRzIGEgbWF0Y2guXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgaWYgKC9cXFxcW3NXRG5yXXxcXG58XFxyfFxcW1xcXi8udGVzdChxdWVyeSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpbGluZVJlZ0V4cEN1cnNvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlcigpO1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gdGV4dC5saW5lQXQoZnJvbSk7XG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gc3RhcnRMaW5lLmZyb207XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XG4gICAgICAgIHRoaXMuZ2V0TGluZSh0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgfVxuICAgIGdldExpbmUoc2tpcCkge1xuICAgICAgICB0aGlzLml0ZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKHRoaXMuaXRlci5saW5lQnJlYWspIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoID4gdGhpcy50bylcbiAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmN1ckxpbmUuc2xpY2UoMCwgdGhpcy50byAtIHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ID4gdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBtYXRjaCwgaWYgdGhlcmUgaXMgb25lLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaFBvcyA8PSB0aGlzLnRvICYmIHRoaXMucmUuZXhlYyh0aGlzLmN1ckxpbmUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLmN1ckxpbmVTdGFydCArIG1hdGNoLmluZGV4LCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICgoZnJvbSA8IHRvIHx8IGZyb20gPiB0aGlzLnZhbHVlLnRvKSAmJiAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIG9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZmxhdHRlbmVkID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBSZXVzYWJsZSAocGFydGlhbGx5KSBmbGF0dGVuZWQgZG9jdW1lbnQgc3RyaW5nc1xuY2xhc3MgRmxhdHRlbmVkRG9jIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBzdGF0aWMgZ2V0KGRvYywgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IGZsYXR0ZW5lZC5nZXQoZG9jKTtcbiAgICAgICAgaWYgKCFjYWNoZWQgfHwgY2FjaGVkLmZyb20gPj0gdG8gfHwgY2FjaGVkLnRvIDw9IGZyb20pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBmbGF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQuZnJvbSA9PSBmcm9tICYmIGNhY2hlZC50byA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb206IGNhY2hlZEZyb20gfSA9IGNhY2hlZDtcbiAgICAgICAgaWYgKGNhY2hlZEZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZG9jLnNsaWNlU3RyaW5nKGZyb20sIGNhY2hlZEZyb20pICsgdGV4dDtcbiAgICAgICAgICAgIGNhY2hlZEZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQudG8gPCB0bylcbiAgICAgICAgICAgIHRleHQgKz0gZG9jLnNsaWNlU3RyaW5nKGNhY2hlZC50bywgdG8pO1xuICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgbmV3IEZsYXR0ZW5lZERvYyhjYWNoZWRGcm9tLCB0ZXh0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIHRleHQuc2xpY2UoZnJvbSAtIGNhY2hlZEZyb20sIHRvIC0gY2FjaGVkRnJvbSkpO1xuICAgIH1cbn1cbmNsYXNzIE11bHRpbGluZVJlZ0V4cEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRleHQsIGZyb20sIHRoaXMuY2h1bmtFbmQoZnJvbSArIDUwMDAgLyogQ2h1bmsuQmFzZSAqLykpO1xuICAgIH1cbiAgICBjaHVua0VuZChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA+PSB0aGlzLnRvID8gdGhpcy50byA6IHRoaXMudGV4dC5saW5lQXQocG9zKS50bztcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG9mZiA9IHRoaXMucmUubGFzdEluZGV4ID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuZmxhdC5mcm9tO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgbWF0Y2hlcyBkaXJlY3RseSBhZnRlciB0aGUgbGFzdCBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoICYmICFtYXRjaFswXSAmJiBtYXRjaC5pbmRleCA9PSBvZmYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZiArIDE7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLmZsYXQuZnJvbSArIG1hdGNoLmluZGV4LCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtYXRjaCBnb2VzIGFsbW9zdCB0byB0aGUgZW5kIG9mIGEgbm9uY29tcGxldGUgY2h1bmssIHRyeVxuICAgICAgICAgICAgICAgIC8vIGFnYWluLCBzaW5jZSBpdCdsbCBsaWtlbHkgYmUgYWJsZSB0byBtYXRjaCBtb3JlXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLmZsYXQudG8gPj0gdGhpcy50byB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA8PSB0aGlzLmZsYXQudGV4dC5sZW5ndGggLSAxMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZsYXQudG8gPT0gdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHcm93IHRoZSBmbGF0dGVuZWQgZG9jXG4gICAgICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRoaXMudGV4dCwgdGhpcy5mbGF0LmZyb20sIHRoaXMuY2h1bmtFbmQodGhpcy5mbGF0LmZyb20gKyB0aGlzLmZsYXQudGV4dC5sZW5ndGggKiAyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gTXVsdGlsaW5lUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkUmVnRXhwKHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc291cmNlLCBiYXNlRmxhZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0NoYXJFbmQodGV4dCwgcG9zKSB7XG4gICAgaWYgKHBvcyA+PSB0ZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgbGluZSA9IHRleHQubGluZUF0KHBvcyksIG5leHQ7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudG8gJiYgKG5leHQgPSBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MgLSBsaW5lLmZyb20pKSA+PSAweERDMDAgJiYgbmV4dCA8IDB4RTAwMClcbiAgICAgICAgcG9zKys7XG4gICAgcmV0dXJuIHBvcztcbn1cblxuLyoqXG5Db21tYW5kIHRoYXQgc2hvd3MgYSBkaWFsb2cgYXNraW5nIHRoZSB1c2VyIGZvciBhIGxpbmUgbnVtYmVyLCBhbmRcbndoZW4gYSB2YWxpZCBwb3NpdGlvbiBpcyBwcm92aWRlZCwgbW92ZXMgdGhlIGN1cnNvciB0byB0aGF0IGxpbmUuXG5cblN1cHBvcnRzIGxpbmUgbnVtYmVycywgcmVsYXRpdmUgbGluZSBvZmZzZXRzIHByZWZpeGVkIHdpdGggYCtgIG9yXG5gLWAsIGRvY3VtZW50IHBlcmNlbnRhZ2VzIHN1ZmZpeGVkIHdpdGggYCVgLCBhbmQgYW4gb3B0aW9uYWxcbmNvbHVtbiBwb3NpdGlvbiBieSBhZGRpbmcgYDpgIGFuZCBhIHNlY29uZCBudW1iZXIgYWZ0ZXIgdGhlIGxpbmVcbm51bWJlci5cbiovXG5jb25zdCBnb3RvTGluZSA9IHZpZXcgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgIGxldCBsaW5lID0gU3RyaW5nKHN0YXRlLmRvYy5saW5lQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKS5udW1iZXIpO1xuICAgIGxldCB7IGNsb3NlLCByZXN1bHQgfSA9IHNob3dEaWFsb2codmlldywge1xuICAgICAgICBsYWJlbDogc3RhdGUucGhyYXNlKFwiR28gdG8gbGluZVwiKSxcbiAgICAgICAgaW5wdXQ6IHsgdHlwZTogXCJ0ZXh0XCIsIG5hbWU6IFwibGluZVwiLCB2YWx1ZTogbGluZSB9LFxuICAgICAgICBmb2N1czogdHJ1ZSxcbiAgICAgICAgc3VibWl0TGFiZWw6IHN0YXRlLnBocmFzZShcImdvXCIpLFxuICAgIH0pO1xuICAgIHJlc3VsdC50aGVuKGZvcm0gPT4ge1xuICAgICAgICBsZXQgbWF0Y2ggPSBmb3JtICYmIC9eKFsrLV0pPyhcXGQrKT8oOlxcZCspPyglKT8kLy5leGVjKGZvcm0uZWxlbWVudHNbXCJsaW5lXCJdLnZhbHVlKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgWywgc2lnbiwgbG4sIGNsLCBwZXJjZW50XSA9IG1hdGNoO1xuICAgICAgICBsZXQgY29sID0gY2wgPyArY2wuc2xpY2UoMSkgOiAwO1xuICAgICAgICBsZXQgbGluZSA9IGxuID8gK2xuIDogc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgaWYgKGxuICYmIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIGxldCBwYyA9IGxpbmUgLyAxMDA7XG4gICAgICAgICAgICBpZiAoc2lnbilcbiAgICAgICAgICAgICAgICBwYyA9IHBjICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgKHN0YXJ0TGluZS5udW1iZXIgLyBzdGF0ZS5kb2MubGluZXMpO1xuICAgICAgICAgICAgbGluZSA9IE1hdGgucm91bmQoc3RhdGUuZG9jLmxpbmVzICogcGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxuICYmIHNpZ24pIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9jTGluZSA9IHN0YXRlLmRvYy5saW5lKE1hdGgubWF4KDEsIE1hdGgubWluKHN0YXRlLmRvYy5saW5lcywgbGluZSkpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZG9jTGluZS5mcm9tICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29sLCBkb2NMaW5lLmxlbmd0aCkpKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBlZmZlY3RzOiBbY2xvc2UsIEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLmZyb20sIHsgeTogJ2NlbnRlcicgfSldLFxuICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRPcHRpb25zID0ge1xuICAgIGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3I6IGZhbHNlLFxuICAgIG1pblNlbGVjdGlvbkxlbmd0aDogMSxcbiAgICBtYXhNYXRjaGVzOiAxMDAsXG4gICAgd2hvbGVXb3JkczogZmFsc2Vcbn07XG5jb25zdCBoaWdobGlnaHRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcob3B0aW9ucywgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMsIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGIsXG4gICAgICAgICAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IE1hdGgubWluLFxuICAgICAgICAgICAgbWF4TWF0Y2hlczogTWF0aC5taW5cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblRoaXMgZXh0ZW5zaW9uIGhpZ2hsaWdodHMgdGV4dCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdGlvbi4gSXQgdXNlc1xudGhlIGBcImNtLXNlbGVjdGlvbk1hdGNoXCJgIGNsYXNzIGZvciB0aGUgaGlnaGxpZ2h0aW5nLiBXaGVuXG5gaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcmAgaXMgZW5hYmxlZCwgdGhlIHdvcmQgYXQgdGhlIGN1cnNvclxuaXRzZWxmIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgd2l0aCBgXCJjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCJgLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMob3B0aW9ucykge1xuICAgIGxldCBleHQgPSBbZGVmYXVsdFRoZW1lLCBtYXRjaEhpZ2hsaWdodGVyXTtcbiAgICBpZiAob3B0aW9ucylcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0Q29uZmlnLm9mKG9wdGlvbnMpKTtcbiAgICByZXR1cm4gZXh0O1xufVxuY29uc3QgbWF0Y2hEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlbGVjdGlvbk1hdGNoXCIgfSk7XG5jb25zdCBtYWluTWF0Y2hEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlbGVjdGlvbk1hdGNoIGNtLXNlbGVjdGlvbk1hdGNoLW1haW5cIiB9KTtcbi8vIFdoZXRoZXIgdGhlIGNoYXJhY3RlcnMgZGlyZWN0bHkgb3V0c2lkZSB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSBub24td29yZCBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIChmcm9tID09IDAgfHwgY2hlY2soc3RhdGUuc2xpY2VEb2MoZnJvbSAtIDEsIGZyb20pKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgKHRvID09IHN0YXRlLmRvYy5sZW5ndGggfHwgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgMSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbn1cbi8vIFdoZXRoZXIgdGhlIGNoYXJhY3RlcnMgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHBvc2l0aW9ucyBhcmUgd29yZCBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBpbnNpZGVXb3JkKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gY2hlY2soc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIDEpKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZFxuICAgICAgICAmJiBjaGVjayhzdGF0ZS5zbGljZURvYyh0byAtIDEsIHRvKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQ7XG59XG5jb25zdCBtYXRjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KGhpZ2hsaWdodENvbmZpZyk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWwubWFpbiwgcXVlcnksIGNoZWNrID0gbnVsbDtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBpZiAoIWNvbmYuaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBpZiAoIXdvcmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyh3b3JkLmZyb20sIHdvcmQudG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHJhbmdlLnRvIC0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGlmIChsZW4gPCBjb25mLm1pblNlbGVjdGlvbkxlbmd0aCB8fCBsZW4gPiAyMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGlmIChjb25mLndob2xlV29yZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKTsgLy8gVE9ETzogYWxsb3cgYW5kIGluY2x1ZGUgbGVhZGluZy90cmFpbGluZyBzcGFjZT9cbiAgICAgICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgICAgICBpZiAoIShpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICBpbnNpZGVXb3JkKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHBhcnQuZnJvbSwgcGFydC50byk7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjayB8fCBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIGZyb20sIHRvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgZnJvbSA8PSByYW5nZS5mcm9tICYmIHRvID49IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1haW5NYXRjaERlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjby5sZW5ndGggPiBjb25mLm1heE1hdGNoZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdFRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjOTlmZjc3ODBcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoIC5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiIH1cbn0pO1xuLy8gU2VsZWN0IHRoZSB3b3JkcyBhcm91bmQgdGhlIGN1cnNvcnMuXG5jb25zdCBzZWxlY3RXb3JkID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgIGxldCBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKSB8fCBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQpKSwgc2VsZWN0aW9uLm1haW5JbmRleCk7XG4gICAgaWYgKG5ld1NlbC5lcShzZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBuZXdTZWwgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgbmV4dCBvY2N1cnJlbmNlIG9mIHF1ZXJ5IHJlbGF0aXZlIHRvIGxhc3QgY3Vyc29yLiBXcmFwIGFyb3VuZFxuLy8gdGhlIGRvY3VtZW50IGlmIHRoZXJlIGFyZSBubyBtb3JlIG1hdGNoZXMuXG5mdW5jdGlvbiBmaW5kTmV4dE9jY3VycmVuY2Uoc3RhdGUsIHF1ZXJ5KSB7XG4gICAgbGV0IHsgbWFpbiwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQobWFpbi5oZWFkKSwgZnVsbFdvcmQgPSB3b3JkICYmIHdvcmQuZnJvbSA9PSBtYWluLmZyb20gJiYgd29yZC50byA9PSBtYWluLnRvO1xuICAgIGZvciAobGV0IGN5Y2xlZCA9IGZhbHNlLCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG8pOzspIHtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCAwLCBNYXRoLm1heCgwLCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLmZyb20gLSAxKSk7XG4gICAgICAgICAgICBjeWNsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZCAmJiByYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBjdXJzb3IudmFsdWUuZnJvbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoZnVsbFdvcmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChjdXJzb3IudmFsdWUuZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkIHx8IHdvcmQuZnJvbSAhPSBjdXJzb3IudmFsdWUuZnJvbSB8fCB3b3JkLnRvICE9IGN1cnNvci52YWx1ZS50bylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5TZWxlY3QgbmV4dCBvY2N1cnJlbmNlIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gRXhwYW5kIHNlbGVjdGlvblxudG8gdGhlIHN1cnJvdW5kaW5nIHdvcmQgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5LlxuKi9cbmNvbnN0IHNlbGVjdE5leHRPY2N1cnJlbmNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAocmFuZ2VzLnNvbWUoc2VsID0+IHNlbC5mcm9tID09PSBzZWwudG8pKVxuICAgICAgICByZXR1cm4gc2VsZWN0V29yZCh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBsZXQgc2VhcmNoZWRUZXh0ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2VzWzBdLmZyb20sIHJhbmdlc1swXS50byk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHN0YXRlLnNsaWNlRG9jKHIuZnJvbSwgci50bykgIT0gc2VhcmNoZWRUZXh0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCByYW5nZSA9IGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgc2VhcmNoZWRUZXh0KTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24uYWRkUmFuZ2UoRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20sIHJhbmdlLnRvKSwgZmFsc2UpLFxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlLnRvKVxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlYXJjaENvbmZpZ0ZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHRvcDogZmFsc2UsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgICAgICAgcmVnZXhwOiBmYWxzZSxcbiAgICAgICAgICAgIHdob2xlV29yZDogZmFsc2UsXG4gICAgICAgICAgICBjcmVhdGVQYW5lbDogdmlldyA9PiBuZXcgU2VhcmNoUGFuZWwodmlldyksXG4gICAgICAgICAgICBzY3JvbGxUb01hdGNoOiByYW5nZSA9PiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuQWRkIHNlYXJjaCBzdGF0ZSB0byB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24sIGFuZCBvcHRpb25hbGx5XG5jb25maWd1cmUgdGhlIHNlYXJjaCBleHRlbnNpb24uXG4oW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIHdpbGwgYXV0b21hdGljYWxseVxuZW5hYmxlIHRoaXMgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvbikuXG4qL1xuZnVuY3Rpb24gc2VhcmNoKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbc2VhcmNoQ29uZmlnRmFjZXQub2YoY29uZmlnKSwgc2VhcmNoRXh0ZW5zaW9uc10gOiBzZWFyY2hFeHRlbnNpb25zO1xufVxuLyoqXG5BIHNlYXJjaCBxdWVyeS4gUGFydCBvZiB0aGUgZWRpdG9yJ3Mgc2VhcmNoIHN0YXRlLlxuKi9cbmNsYXNzIFNlYXJjaFF1ZXJ5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBxdWVyeSBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBjb25maWcuc2VhcmNoO1xuICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSAhIWNvbmZpZy5jYXNlU2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLmxpdGVyYWwgPSAhIWNvbmZpZy5saXRlcmFsO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9ICEhY29uZmlnLnJlZ2V4cDtcbiAgICAgICAgdGhpcy5yZXBsYWNlID0gY29uZmlnLnJlcGxhY2UgfHwgXCJcIjtcbiAgICAgICAgdGhpcy52YWxpZCA9ICEhdGhpcy5zZWFyY2ggJiYgKCF0aGlzLnJlZ2V4cCB8fCB2YWxpZFJlZ0V4cCh0aGlzLnNlYXJjaCkpO1xuICAgICAgICB0aGlzLnVucXVvdGVkID0gdGhpcy51bnF1b3RlKHRoaXMuc2VhcmNoKTtcbiAgICAgICAgdGhpcy53aG9sZVdvcmQgPSAhIWNvbmZpZy53aG9sZVdvcmQ7XG4gICAgICAgIHRoaXMudGVzdCA9IGNvbmZpZy50ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVucXVvdGUodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsID8gdGV4dCA6XG4gICAgICAgICAgICB0ZXh0LnJlcGxhY2UoL1xcXFwoW25ydFxcXFxdKS9nLCAoXywgY2gpID0+IGNoID09IFwiblwiID8gXCJcXG5cIiA6IGNoID09IFwiclwiID8gXCJcXHJcIiA6IGNoID09IFwidFwiID8gXCJcXHRcIiA6IFwiXFxcXFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHF1ZXJ5IHRvIGFub3RoZXIgcXVlcnkuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2ggPT0gb3RoZXIuc2VhcmNoICYmIHRoaXMucmVwbGFjZSA9PSBvdGhlci5yZXBsYWNlICYmXG4gICAgICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPT0gb3RoZXIuY2FzZVNlbnNpdGl2ZSAmJiB0aGlzLnJlZ2V4cCA9PSBvdGhlci5yZWdleHAgJiZcbiAgICAgICAgICAgIHRoaXMud2hvbGVXb3JkID09IG90aGVyLndob2xlV29yZCAmJiB0aGlzLnRlc3QgPT0gb3RoZXIudGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IG5ldyBSZWdFeHBRdWVyeSh0aGlzKSA6IG5ldyBTdHJpbmdRdWVyeSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgc2VhcmNoIGN1cnNvciBmb3IgdGhpcyBxdWVyeSwgc2VhcmNoaW5nIHRocm91Z2ggdGhlIGdpdmVuXG4gICAgcmFuZ2UgaW4gdGhlIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0Q3Vyc29yKHN0YXRlLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgbGV0IHN0ID0gc3RhdGUuZG9jID8gc3RhdGUgOiBFZGl0b3JTdGF0ZS5jcmVhdGUoeyBkb2M6IHN0YXRlIH0pO1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gc3QuZG9jLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gcmVnZXhwQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0bykgOiBzdHJpbmdDdXJzb3IodGhpcywgc3QsIGZyb20sIHRvKTtcbiAgICB9XG59XG5jbGFzcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwU3RyaW5nVGVzdCh0ZXN0LCBzdGF0ZSwgaW5uZXIpIHtcbiAgICByZXR1cm4gKGZyb20sIHRvLCBidWZmZXIsIGJ1ZmZlclBvcykgPT4ge1xuICAgICAgICBpZiAoaW5uZXIgJiYgIWlubmVyKGZyb20sIHRvLCBidWZmZXIsIGJ1ZmZlclBvcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGZyb20gPj0gYnVmZmVyUG9zICYmIHRvIDw9IGJ1ZmZlclBvcyArIGJ1ZmZlci5sZW5ndGhcbiAgICAgICAgICAgID8gYnVmZmVyLnNsaWNlKGZyb20gLSBidWZmZXJQb3MsIHRvIC0gYnVmZmVyUG9zKVxuICAgICAgICAgICAgOiBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdGVzdChtYXRjaCwgc3RhdGUsIGZyb20sIHRvKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIGxldCB0ZXN0O1xuICAgIGlmIChzcGVjLndob2xlV29yZClcbiAgICAgICAgdGVzdCA9IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKTtcbiAgICBpZiAoc3BlYy50ZXN0KVxuICAgICAgICB0ZXN0ID0gd3JhcFN0cmluZ1Rlc3Qoc3BlYy50ZXN0LCBzdGF0ZSwgdGVzdCk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnVucXVvdGVkLCBmcm9tLCB0bywgc3BlYy5jYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogeCA9PiB4LnRvTG93ZXJDYXNlKCksIHRlc3QpO1xufVxuZnVuY3Rpb24gc3RyaW5nV29yZFRlc3QoZG9jLCBjYXRlZ29yaXplcikge1xuICAgIHJldHVybiAoZnJvbSwgdG8sIGJ1ZiwgYnVmUG9zKSA9PiB7XG4gICAgICAgIGlmIChidWZQb3MgPiBmcm9tIHx8IGJ1ZlBvcyArIGJ1Zi5sZW5ndGggPCB0bykge1xuICAgICAgICAgICAgYnVmUG9zID0gTWF0aC5tYXgoMCwgZnJvbSAtIDIpO1xuICAgICAgICAgICAgYnVmID0gZG9jLnNsaWNlU3RyaW5nKGJ1ZlBvcywgTWF0aC5taW4oZG9jLmxlbmd0aCwgdG8gKyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbiAgICB9O1xufVxuY2xhc3MgU3RyaW5nUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgfVxuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGN1ckZyb20gKyB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBlbmQpLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSB8fCBjdXJzb3IudmFsdWUuZnJvbSA9PSBjdXJGcm9tICYmIGN1cnNvci52YWx1ZS50byA9PSBjdXJUbyA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIC8vIFNlYXJjaGluZyBpbiByZXZlcnNlIGlzLCByYXRoZXIgdGhhbiBpbXBsZW1lbnRpbmcgYW4gaW52ZXJ0ZWQgc2VhcmNoXG4gICAgLy8gY3Vyc29yLCBkb25lIGJ5IHNjYW5uaW5nIGNodW5rIGFmdGVyIGNodW5rIGZvcndhcmQuXG4gICAgcHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdG87Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgcG9zIC0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIHN0YXJ0LCBwb3MpLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0T3ZlcmxhcHBpbmcoKS5kb25lKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcG9zIC09IDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSk7XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgTWF0aC5tYXgoMCwgY3VyVG8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKSwgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBmb3VuZCAmJiAoZm91bmQuZnJvbSAhPSBjdXJGcm9tIHx8IGZvdW5kLnRvICE9IGN1clRvKSA/IGZvdW5kIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0UmVwbGFjZW1lbnQoX3Jlc3VsdCkgeyByZXR1cm4gdGhpcy5zcGVjLnVucXVvdGUodGhpcy5zcGVjLnJlcGxhY2UpOyB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKSwgTWF0aC5taW4odG8gKyB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgYWRkKGN1cnNvci52YWx1ZS5mcm9tLCBjdXJzb3IudmFsdWUudG8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBSZWdleHBUZXN0KHRlc3QsIHN0YXRlLCBpbm5lcikge1xuICAgIHJldHVybiAoZnJvbSwgdG8sIG1hdGNoKSA9PiB7XG4gICAgICAgIHJldHVybiAoIWlubmVyIHx8IGlubmVyKGZyb20sIHRvLCBtYXRjaCkpICYmIHRlc3QobWF0Y2hbMF0sIHN0YXRlLCBmcm9tLCB0byk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cEN1cnNvcihzcGVjLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGVzdDtcbiAgICBpZiAoc3BlYy53aG9sZVdvcmQpXG4gICAgICAgIHRlc3QgPSByZWdleHBXb3JkVGVzdChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpO1xuICAgIGlmIChzcGVjLnRlc3QpXG4gICAgICAgIHRlc3QgPSB3cmFwUmVnZXhwVGVzdChzcGVjLnRlc3QsIHN0YXRlLCB0ZXN0KTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cEN1cnNvcihzdGF0ZS5kb2MsIHNwZWMuc2VhcmNoLCB7IGlnbm9yZUNhc2U6ICFzcGVjLmNhc2VTZW5zaXRpdmUsIHRlc3QgfSwgZnJvbSwgdG8pO1xufVxuZnVuY3Rpb24gY2hhckJlZm9yZShzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgsIGZhbHNlKSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gY2hhckFmdGVyKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4LCBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cFdvcmRUZXN0KGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChfZnJvbSwgX3RvLCBtYXRjaCkgPT4gIW1hdGNoWzBdLmxlbmd0aCB8fFxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKS5yZXBsYWNlKC9cXCQoWyQmXXxcXGQrKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXRjaFswXTtcbiAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSBpLmxlbmd0aDsgbCA+IDA7IGwtLSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gK2kuc2xpY2UoMCwgbCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIG4gPCByZXN1bHQubWF0Y2gubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hdGNoW25dICsgaS5zbGljZShsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8sIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuLyoqXG5BIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LiBOb3RlIHRoYXRcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbihieSBpbmNsdWRpbmcgW2BzZWFyY2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2gpIGluIHlvdXIgY29uZmlndXJhdGlvbiBvclxuYnkgcnVubmluZyBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgYXQgbGVhc3Rcbm9uY2UpLlxuKi9cbmNvbnN0IHNldFNlYXJjaFF1ZXJ5ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZWFyY2hTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKVxufSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gZ2V0U2VhcmNoUXVlcnkoc3RhdGUpIHtcbiAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xufVxuLyoqXG5RdWVyeSB3aGV0aGVyIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBpbiB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaFBhbmVsT3BlbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYW5lbCkgIT0gbnVsbDtcbn1cbmNsYXNzIFNlYXJjaFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoIGNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCIgfSk7XG5jb25zdCBzZWFyY2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQodmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzLCBsID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3LnN0YXRlLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHZpZXcuc3RhdGUsIHRvLCB0byk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgbmV4dCksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGluc3RhbmNlIG9mIHRoZSBzZWFyY2ggcXVlcnksXG5iZWZvcmUgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uIFdpbGwgd3JhcCBwYXN0IHRoZSBzdGFydFxub2YgdGhlIGRvY3VtZW50IHRvIHN0YXJ0IHNlYXJjaGluZyBhdCB0aGUgZW5kIGFnYWluLlxuKi9cbmNvbnN0IGZpbmRQcmV2aW91cyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgcHJldiA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFwcmV2KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUocHJldi5mcm9tLCBwcmV2LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgcHJldiksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoZXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuKi9cbmNvbnN0IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpOyAhY3VyLm5leHQoKS5kb25lOykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjdXIudmFsdWUuZnJvbSA9PSBmcm9tKVxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShjdXIudmFsdWUuZnJvbSwgY3VyLnZhbHVlLnRvKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBtYXRjaCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gbWF0Y2g7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgc2VsZWN0aW9uLCByZXBsYWNlbWVudDtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUudG9UZXh0KHF1ZXJ5LmdldFJlcGxhY2VtZW50KG5leHQpKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dC5mcm9tLCB0bzogbmV4dC50bywgaW5zZXJ0OiByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XG4gICAgfVxuICAgIGxldCBjaGFuZ2VTZXQgPSB2aWV3LnN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXh0LmZyb20sIG5leHQudG8pLm1hcChjaGFuZ2VTZXQpO1xuICAgICAgICBlZmZlY3RzLnB1c2goYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSk7XG4gICAgICAgIGVmZmVjdHMucHVzaChzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbiwgdmlldykpO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlczogY2hhbmdlU2V0LFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5SZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeSB3aXRoIHRoZSBnaXZlblxucmVwbGFjZW1lbnQuXG4qL1xuY29uc3QgcmVwbGFjZUFsbCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMWU5KS5tYXAobWF0Y2ggPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gbWF0Y2g7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCBpbnNlcnQ6IHF1ZXJ5LmdldFJlcGxhY2VtZW50KG1hdGNoKSB9O1xuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYW5ub3VuY2VUZXh0ID0gdmlldy5zdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCAkIG1hdGNoZXNcIiwgY2hhbmdlcy5sZW5ndGgpICsgXCIuXCI7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYW5ub3VuY2VUZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2UuYWxsXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFuZWwodmlldykge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5jcmVhdGVQYW5lbCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRRdWVyeShzdGF0ZSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgc2VsVGV4dCA9IHNlbC5lbXB0eSB8fCBzZWwudG8gPiBzZWwuZnJvbSArIDEwMCA/IFwiXCIgOiBzdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgc2VsLnRvKTtcbiAgICBpZiAoZmFsbGJhY2sgJiYgIXNlbFRleHQpXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICBsZXQgY29uZmlnID0gc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHJldHVybiBuZXcgU2VhcmNoUXVlcnkoe1xuICAgICAgICBzZWFyY2g6ICgoX2EgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uZmlnLmxpdGVyYWwpID8gc2VsVGV4dCA6IHNlbFRleHQucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksXG4gICAgICAgIGNhc2VTZW5zaXRpdmU6IChfYiA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5jYXNlU2Vuc2l0aXZlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb25maWcuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgbGl0ZXJhbDogKF9jID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbmZpZy5saXRlcmFsLFxuICAgICAgICByZWdleHA6IChfZCA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5yZWdleHApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGNvbmZpZy5yZWdleHAsXG4gICAgICAgIHdob2xlV29yZDogKF9lID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLndob2xlV29yZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogY29uZmlnLndob2xlV29yZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VhcmNoSW5wdXQodmlldykge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICByZXR1cm4gcGFuZWwgJiYgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbbWFpbi1maWVsZF1cIik7XG59XG5mdW5jdGlvbiBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KSB7XG4gICAgbGV0IGlucHV0ID0gZ2V0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgaWYgKGlucHV0ICYmIGlucHV0ID09IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KVxuICAgICAgICBpbnB1dC5zZWxlY3QoKTtcbn1cbi8qKlxuTWFrZSBzdXJlIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBhbmQgZm9jdXNlZC5cbiovXG5jb25zdCBvcGVuU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnBhbmVsKSB7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IGdldFNlYXJjaElucHV0KHZpZXcpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIE1vZC1BbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1nXCIsIHJ1bjogZ290b0xpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtZFwiLCBydW46IHNlbGVjdE5leHRPY2N1cnJlbmNlLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuXTtcbmNsYXNzIFNlYXJjaFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMucXVlcnkgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKS5xdWVyeS5zcGVjO1xuICAgICAgICB0aGlzLmNvbW1pdCA9IHRoaXMuY29tbWl0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkuc2VhcmNoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJzZWFyY2hcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBcIm1haW4tZmllbGRcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkucmVwbGFjZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY2FzZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5yZWdleHAsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29yZEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkud2hvbGVXb3JkLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBidXR0b24obmFtZSwgb25jbGljaywgY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCBuYW1lLCBvbmNsaWNrLCB0eXBlOiBcImJ1dHRvblwiIH0sIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgb25rZXlkb3duOiAoZSkgPT4gdGhpcy5rZXlkb3duKGUpLCBjbGFzczogXCJjbS1zZWFyY2hcIiB9LCBbXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLFxuICAgICAgICAgICAgYnV0dG9uKFwibmV4dFwiLCAoKSA9PiBmaW5kTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcIm5leHRcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInByZXZcIiwgKCkgPT4gZmluZFByZXZpb3VzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicHJldmlvdXNcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInNlbGVjdFwiLCAoKSA9PiBzZWxlY3RNYXRjaGVzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwiYWxsXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5jYXNlRmllbGQsIHBocmFzZSh2aWV3LCBcIm1hdGNoIGNhc2VcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLnJlRmllbGQsIHBocmFzZSh2aWV3LCBcInJlZ2V4cFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMud29yZEZpZWxkLCBwaHJhc2UodmlldywgXCJieSB3b3JkXCIpXSksXG4gICAgICAgICAgICAuLi52aWV3LnN0YXRlLnJlYWRPbmx5ID8gW10gOiBbXG4gICAgICAgICAgICAgICAgZWx0KFwiYnJcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQsXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZVwiLCAoKSA9PiByZXBsYWNlTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2VcIildKSxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlQWxsXCIsICgpID0+IHJlcGxhY2VBbGwodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlIGFsbFwiKV0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiY2xvc2VcIiksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICAgICAgfSwgW1wiw5dcIl0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0aGlzLmNhc2VGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVnZXhwOiB0aGlzLnJlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53b3JkRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFxdWVyeS5lcSh0aGlzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24oZSkge1xuICAgICAgICBpZiAocnVuU2NvcGVIYW5kbGVycyh0aGlzLnZpZXcsIGUsIFwic2VhcmNoLXBhbmVsXCIpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMuc2VhcmNoRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIChlLnNoaWZ0S2V5ID8gZmluZFByZXZpb3VzIDogZmluZE5leHQpKHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMucmVwbGFjZUZpZWxkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXBsYWNlTmV4dCh0aGlzLnZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkgJiYgIWVmZmVjdC52YWx1ZS5lcSh0aGlzLnF1ZXJ5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRRdWVyeShlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzZXRRdWVyeShxdWVyeSkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQudmFsdWUgPSBxdWVyeS5zZWFyY2g7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlID0gcXVlcnkucmVwbGFjZTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQuY2hlY2tlZCA9IHF1ZXJ5LmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMucmVGaWVsZC5jaGVja2VkID0gcXVlcnkucmVnZXhwO1xuICAgICAgICB0aGlzLndvcmRGaWVsZC5jaGVja2VkID0gcXVlcnkud2hvbGVXb3JkO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC5zZWxlY3QoKTtcbiAgICB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIDgwOyB9XG4gICAgZ2V0IHRvcCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkudG9wOyB9XG59XG5mdW5jdGlvbiBwaHJhc2UodmlldywgcGhyYXNlKSB7IHJldHVybiB2aWV3LnN0YXRlLnBocmFzZShwaHJhc2UpOyB9XG5jb25zdCBBbm5vdW5jZU1hcmdpbiA9IDMwO1xuY29uc3QgQnJlYWsgPSAvW1xcc1xcLiw6Oz8hXS87XG5mdW5jdGlvbiBhbm5vdW5jZU1hdGNoKHZpZXcsIHsgZnJvbSwgdG8gfSkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCBsaW5lRW5kID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bztcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIGZyb20gLSBBbm5vdW5jZU1hcmdpbiksIGVuZCA9IE1hdGgubWluKGxpbmVFbmQsIHRvICsgQW5ub3VuY2VNYXJnaW4pO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zdGF0ZS5zbGljZURvYyhzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RhcnQgIT0gbGluZS5mcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQW5ub3VuY2VNYXJnaW47IGkrKylcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgKyAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kICE9IGxpbmVFbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+IHRleHQubGVuZ3RoIC0gQW5ub3VuY2VNYXJnaW47IGktLSlcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgLSAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJvbiBsaW5lXCIpfSAke2xpbmUubnVtYmVyfS5gKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tc2VhcmNoXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXQsICYgYnV0dG9uLCAmIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIG1hcmdpbjogXCIuMmVtIC42ZW0gLjJlbSAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0W3R5cGU9Y2hlY2tib3hdXCI6IHtcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBcIi4yZW1cIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgbGFiZWxcIjoge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiODAlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZjAwNTRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMGZmZmY4YVwiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZjZhMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMDBmZjhhXCIgfVxufSk7XG5jb25zdCBzZWFyY2hFeHRlbnNpb25zID0gW1xuICAgIHNlYXJjaFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9QcmVjLmxvdyhzZWFyY2hIaWdobGlnaHRlciksXG4gICAgYmFzZVRoZW1lXG5dO1xuXG5leHBvcnQgeyBSZWdFeHBDdXJzb3IsIFNlYXJjaEN1cnNvciwgU2VhcmNoUXVlcnksIGNsb3NlU2VhcmNoUGFuZWwsIGZpbmROZXh0LCBmaW5kUHJldmlvdXMsIGdldFNlYXJjaFF1ZXJ5LCBnb3RvTGluZSwgaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcywgb3BlblNlYXJjaFBhbmVsLCByZXBsYWNlQWxsLCByZXBsYWNlTmV4dCwgc2VhcmNoLCBzZWFyY2hLZXltYXAsIHNlYXJjaFBhbmVsT3Blbiwgc2VsZWN0TWF0Y2hlcywgc2VsZWN0TmV4dE9jY3VycmVuY2UsIHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMsIHNldFNlYXJjaFF1ZXJ5IH07XG4iXSwibmFtZXMiOlsic2hvd0RpYWxvZyIsIkVkaXRvclZpZXciLCJEZWNvcmF0aW9uIiwiVmlld1BsdWdpbiIsInNob3dQYW5lbCIsInJ1blNjb3BlSGFuZGxlcnMiLCJnZXRQYW5lbCIsImNvZGVQb2ludEF0IiwiZnJvbUNvZGVQb2ludCIsImNvZGVQb2ludFNpemUiLCJFZGl0b3JTZWxlY3Rpb24iLCJGYWNldCIsImNvbWJpbmVDb25maWciLCJDaGFyQ2F0ZWdvcnkiLCJTdGF0ZUVmZmVjdCIsIlN0YXRlRmllbGQiLCJSYW5nZVNldEJ1aWxkZXIiLCJQcmVjIiwiRWRpdG9yU3RhdGUiLCJmaW5kQ2x1c3RlckJyZWFrIiwiZWx0IiwiYmFzaWNOb3JtYWxpemUiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJub3JtYWxpemUiLCJ4IiwiU2VhcmNoQ3Vyc29yIiwiY29uc3RydWN0b3IiLCJ0ZXh0IiwicXVlcnkiLCJmcm9tIiwidG8iLCJsZW5ndGgiLCJ0ZXN0IiwidmFsdWUiLCJkb25lIiwibWF0Y2hlcyIsImJ1ZmZlciIsImJ1ZmZlclBvcyIsIml0ZXIiLCJpdGVyUmFuZ2UiLCJidWZmZXJTdGFydCIsInBlZWsiLCJuZXh0IiwicG9wIiwibmV4dE92ZXJsYXBwaW5nIiwic3RyIiwic3RhcnQiLCJub3JtIiwiaSIsInBvcyIsImNvZGUiLCJjaGFyQ29kZUF0IiwibWF0Y2giLCJlbmQiLCJpbmRleCIsImtlZXAiLCJzcGxpY2UiLCJwdXNoIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJlbXB0eSIsImV4ZWMiLCJiYXNlRmxhZ3MiLCJ1bmljb2RlIiwiUmVnRXhwQ3Vyc29yIiwib3B0aW9ucyIsImN1ckxpbmUiLCJNdWx0aWxpbmVSZWdFeHBDdXJzb3IiLCJyZSIsIlJlZ0V4cCIsImlnbm9yZUNhc2UiLCJzdGFydExpbmUiLCJsaW5lQXQiLCJjdXJMaW5lU3RhcnQiLCJtYXRjaFBvcyIsInRvQ2hhckVuZCIsImdldExpbmUiLCJza2lwIiwibGluZUJyZWFrIiwic2xpY2UiLCJuZXh0TGluZSIsIm9mZiIsImxhc3RJbmRleCIsImZsYXR0ZW5lZCIsIldlYWtNYXAiLCJGbGF0dGVuZWREb2MiLCJnZXQiLCJkb2MiLCJjYWNoZWQiLCJmbGF0Iiwic2xpY2VTdHJpbmciLCJzZXQiLCJjYWNoZWRGcm9tIiwiY2h1bmtFbmQiLCJ2YWxpZFJlZ0V4cCIsInNvdXJjZSIsIl9hIiwibGluZSIsImdvdG9MaW5lIiwidmlldyIsInN0YXRlIiwic2VsZWN0aW9uIiwibWFpbiIsImhlYWQiLCJudW1iZXIiLCJjbG9zZSIsInJlc3VsdCIsImxhYmVsIiwicGhyYXNlIiwiaW5wdXQiLCJ0eXBlIiwibmFtZSIsImZvY3VzIiwic3VibWl0TGFiZWwiLCJ0aGVuIiwiZm9ybSIsImVsZW1lbnRzIiwiZGlzcGF0Y2giLCJlZmZlY3RzIiwic2lnbiIsImxuIiwiY2wiLCJwZXJjZW50IiwiY29sIiwicGMiLCJsaW5lcyIsIk1hdGgiLCJyb3VuZCIsImRvY0xpbmUiLCJtYXgiLCJtaW4iLCJjdXJzb3IiLCJzY3JvbGxJbnRvVmlldyIsInkiLCJkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyIsImhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IiLCJtaW5TZWxlY3Rpb25MZW5ndGgiLCJtYXhNYXRjaGVzIiwid2hvbGVXb3JkcyIsImhpZ2hsaWdodENvbmZpZyIsImRlZmluZSIsImNvbWJpbmUiLCJhIiwiYiIsImhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMiLCJleHQiLCJkZWZhdWx0VGhlbWUiLCJtYXRjaEhpZ2hsaWdodGVyIiwib2YiLCJtYXRjaERlY28iLCJtYXJrIiwiY2xhc3MiLCJtYWluTWF0Y2hEZWNvIiwiaW5zaWRlV29yZEJvdW5kYXJpZXMiLCJjaGVjayIsInNsaWNlRG9jIiwiV29yZCIsImluc2lkZVdvcmQiLCJmcm9tQ2xhc3MiLCJkZWNvcmF0aW9ucyIsImdldERlY28iLCJ1cGRhdGUiLCJzZWxlY3Rpb25TZXQiLCJkb2NDaGFuZ2VkIiwidmlld3BvcnRDaGFuZ2VkIiwiY29uZiIsImZhY2V0Iiwic2VsIiwicmFuZ2VzIiwibm9uZSIsInJhbmdlIiwid29yZCIsIndvcmRBdCIsImNoYXJDYXRlZ29yaXplciIsImxlbiIsImRlY28iLCJwYXJ0IiwidmlzaWJsZVJhbmdlcyIsInYiLCJiYXNlVGhlbWUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzZWxlY3RXb3JkIiwibmV3U2VsIiwiY3JlYXRlIiwibWFwIiwibWFpbkluZGV4IiwiZXEiLCJmaW5kTmV4dE9jY3VycmVuY2UiLCJmdWxsV29yZCIsImN5Y2xlZCIsInNvbWUiLCJyIiwic2VsZWN0TmV4dE9jY3VycmVuY2UiLCJzZWFyY2hlZFRleHQiLCJhZGRSYW5nZSIsInNlYXJjaENvbmZpZ0ZhY2V0IiwiY29uZmlncyIsInRvcCIsImNhc2VTZW5zaXRpdmUiLCJsaXRlcmFsIiwicmVnZXhwIiwid2hvbGVXb3JkIiwiY3JlYXRlUGFuZWwiLCJTZWFyY2hQYW5lbCIsInNjcm9sbFRvTWF0Y2giLCJzZWFyY2giLCJjb25maWciLCJzZWFyY2hFeHRlbnNpb25zIiwiU2VhcmNoUXVlcnkiLCJyZXBsYWNlIiwidmFsaWQiLCJ1bnF1b3RlZCIsInVucXVvdGUiLCJfIiwiY2giLCJvdGhlciIsIlJlZ0V4cFF1ZXJ5IiwiU3RyaW5nUXVlcnkiLCJnZXRDdXJzb3IiLCJzdCIsInJlZ2V4cEN1cnNvciIsInN0cmluZ0N1cnNvciIsIlF1ZXJ5VHlwZSIsInNwZWMiLCJ3cmFwU3RyaW5nVGVzdCIsImlubmVyIiwic3RyaW5nV29yZFRlc3QiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsImNhdGVnb3JpemVyIiwiYnVmIiwiYnVmUG9zIiwiY2hhckJlZm9yZSIsImNoYXJBZnRlciIsIm5leHRNYXRjaCIsImN1ckZyb20iLCJjdXJUbyIsInByZXZNYXRjaEluUmFuZ2UiLCJwcmV2TWF0Y2giLCJmb3VuZCIsImdldFJlcGxhY2VtZW50IiwiX3Jlc3VsdCIsIm1hdGNoQWxsIiwibGltaXQiLCJoaWdobGlnaHQiLCJhZGQiLCJ3cmFwUmVnZXhwVGVzdCIsInJlZ2V4cFdvcmRUZXN0IiwiX2Zyb20iLCJfdG8iLCJzaXplIiwibSIsImwiLCJuIiwic2V0U2VhcmNoUXVlcnkiLCJ0b2dnbGVQYW5lbCIsInNlYXJjaFN0YXRlIiwiU2VhcmNoU3RhdGUiLCJkZWZhdWx0UXVlcnkiLCJ0ciIsImVmZmVjdCIsImlzIiwicGFuZWwiLCJjcmVhdGVTZWFyY2hQYW5lbCIsInByb3ZpZGUiLCJmIiwidmFsIiwiZ2V0U2VhcmNoUXVlcnkiLCJjdXJTdGF0ZSIsImZpZWxkIiwic2VhcmNoUGFuZWxPcGVuIiwibWF0Y2hNYXJrIiwic2VsZWN0ZWRNYXRjaE1hcmsiLCJzZWFyY2hIaWdobGlnaHRlciIsInN0YXJ0U3RhdGUiLCJidWlsZGVyIiwic2VsZWN0ZWQiLCJmaW5pc2giLCJzZWFyY2hDb21tYW5kIiwib3BlblNlYXJjaFBhbmVsIiwiZmluZE5leHQiLCJzaW5nbGUiLCJhbm5vdW5jZU1hdGNoIiwidXNlckV2ZW50Iiwic2VsZWN0U2VhcmNoSW5wdXQiLCJmaW5kUHJldmlvdXMiLCJwcmV2Iiwic2VsZWN0TWF0Y2hlcyIsInNlbGVjdFNlbGVjdGlvbk1hdGNoZXMiLCJjdXIiLCJyZXBsYWNlTmV4dCIsInJlYWRPbmx5IiwiY2hhbmdlcyIsInJlcGxhY2VtZW50IiwidG9UZXh0IiwiaW5zZXJ0IiwiYW5ub3VuY2UiLCJjaGFuZ2VTZXQiLCJyZXBsYWNlQWxsIiwiYW5ub3VuY2VUZXh0IiwiZmFsbGJhY2siLCJfYiIsIl9jIiwiX2QiLCJfZSIsInNlbFRleHQiLCJnZXRTZWFyY2hJbnB1dCIsImRvbSIsInF1ZXJ5U2VsZWN0b3IiLCJyb290IiwiYWN0aXZlRWxlbWVudCIsInNlbGVjdCIsInNlYXJjaElucHV0IiwiYXBwZW5kQ29uZmlnIiwiY2xvc2VTZWFyY2hQYW5lbCIsImNvbnRhaW5zIiwic2VhcmNoS2V5bWFwIiwia2V5IiwicnVuIiwic2NvcGUiLCJzaGlmdCIsInByZXZlbnREZWZhdWx0IiwiY29tbWl0IiwiYmluZCIsInNlYXJjaEZpZWxkIiwicGxhY2Vob2xkZXIiLCJvbmNoYW5nZSIsIm9ua2V5dXAiLCJyZXBsYWNlRmllbGQiLCJjYXNlRmllbGQiLCJjaGVja2VkIiwicmVGaWVsZCIsIndvcmRGaWVsZCIsImJ1dHRvbiIsIm9uY2xpY2siLCJjb250ZW50Iiwib25rZXlkb3duIiwiZSIsImtleWRvd24iLCJrZXlDb2RlIiwidGFyZ2V0Iiwic2hpZnRLZXkiLCJ0cmFuc2FjdGlvbnMiLCJzZXRRdWVyeSIsIm1vdW50IiwiQW5ub3VuY2VNYXJnaW4iLCJCcmVhayIsImxpbmVFbmQiLCJwYWRkaW5nIiwicG9zaXRpb24iLCJyaWdodCIsImJvcmRlciIsImZvbnQiLCJtYXJnaW4iLCJtYXJnaW5SaWdodCIsImZvbnRTaXplIiwid2hpdGVTcGFjZSIsImxvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@codemirror+search@6.6.0/node_modules/@codemirror/search/dist/index.js\n");

/***/ })

};
;