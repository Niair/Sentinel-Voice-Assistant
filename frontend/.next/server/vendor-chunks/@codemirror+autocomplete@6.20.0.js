"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+autocomplete@6.20.0";
exports.ids = ["vendor-chunks/@codemirror+autocomplete@6.20.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@codemirror+autocomplete@6.20.0/node_modules/@codemirror/autocomplete/dist/index.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@codemirror+autocomplete@6.20.0/node_modules/@codemirror/autocomplete/dist/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletionContext: () => (/* binding */ CompletionContext),\n/* harmony export */   acceptCompletion: () => (/* binding */ acceptCompletion),\n/* harmony export */   autocompletion: () => (/* binding */ autocompletion),\n/* harmony export */   clearSnippet: () => (/* binding */ clearSnippet),\n/* harmony export */   closeBrackets: () => (/* binding */ closeBrackets),\n/* harmony export */   closeBracketsKeymap: () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   closeCompletion: () => (/* binding */ closeCompletion),\n/* harmony export */   completeAnyWord: () => (/* binding */ completeAnyWord),\n/* harmony export */   completeFromList: () => (/* binding */ completeFromList),\n/* harmony export */   completionKeymap: () => (/* binding */ completionKeymap),\n/* harmony export */   completionStatus: () => (/* binding */ completionStatus),\n/* harmony export */   currentCompletions: () => (/* binding */ currentCompletions),\n/* harmony export */   deleteBracketPair: () => (/* binding */ deleteBracketPair),\n/* harmony export */   hasNextSnippetField: () => (/* binding */ hasNextSnippetField),\n/* harmony export */   hasPrevSnippetField: () => (/* binding */ hasPrevSnippetField),\n/* harmony export */   ifIn: () => (/* binding */ ifIn),\n/* harmony export */   ifNotIn: () => (/* binding */ ifNotIn),\n/* harmony export */   insertBracket: () => (/* binding */ insertBracket),\n/* harmony export */   insertCompletionText: () => (/* binding */ insertCompletionText),\n/* harmony export */   moveCompletionSelection: () => (/* binding */ moveCompletionSelection),\n/* harmony export */   nextSnippetField: () => (/* binding */ nextSnippetField),\n/* harmony export */   pickedCompletion: () => (/* binding */ pickedCompletion),\n/* harmony export */   prevSnippetField: () => (/* binding */ prevSnippetField),\n/* harmony export */   selectedCompletion: () => (/* binding */ selectedCompletion),\n/* harmony export */   selectedCompletionIndex: () => (/* binding */ selectedCompletionIndex),\n/* harmony export */   setSelectedCompletion: () => (/* binding */ setSelectedCompletion),\n/* harmony export */   snippet: () => (/* binding */ snippet),\n/* harmony export */   snippetCompletion: () => (/* binding */ snippetCompletion),\n/* harmony export */   snippetKeymap: () => (/* binding */ snippetKeymap),\n/* harmony export */   startCompletion: () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/.pnpm/@codemirror+state@6.5.4/node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/.pnpm/@codemirror+view@6.39.11/node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/.pnpm/@codemirror+language@6.12.1/node_modules/@codemirror/language/dist/index.js\");\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/ class CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sourcesâ€”in the editor, the extension will create\n    these for you.)\n    */ constructor(/**\n    The editor state that the completion happens in.\n    */ state, /**\n    The position at which the completion is happening.\n    */ pos, /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */ explicit, /**\n    The editor view. May be undefined if the context was created\n    in a situation where there is no such view available, such as\n    in synchronous updates via\n    [`CompletionResult.update`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.update)\n    or when called by test code.\n    */ view){\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        this.view = view;\n        /**\n        @internal\n        */ this.abortListeners = [];\n        /**\n        @internal\n        */ this.abortOnDocChange = false;\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */ tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while(token && types.indexOf(token.name) < 0)token = token.parent;\n        return token ? {\n            from: token.from,\n            to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type\n        } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */ matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : {\n            from: start + found,\n            to: this.pos,\n            text: str.slice(found)\n        };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */ get aborted() {\n        return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    \n    By default, running queries will not be aborted for regular\n    typing or backspacing, on the assumption that they are likely to\n    return a result with a\n    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that\n    allows the result to be used after all. Passing `onDocChange:\n    true` will cause this query to be aborted for any document\n    change.\n    */ addEventListener(type, listener, options) {\n        if (type == \"abort\" && this.abortListeners) {\n            this.abortListeners.push(listener);\n            if (options && options.onDocChange) this.abortOnDocChange = true;\n        }\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words) flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options){\n        first[label[0]] = true;\n        for(let i = 1; i < label.length; i++)rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [\n        new RegExp(\"^\" + source),\n        new RegExp(source)\n    ];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/ function completeFromList(list) {\n    let options = list.map((o)=>typeof o == \"string\" ? {\n            label: o\n        } : o);\n    let [validFor, match] = options.every((o)=>/^\\w+$/.test(o.label)) ? [\n        /\\w*$/,\n        /\\w+$/\n    ] : prefixMatch(options);\n    return (context)=>{\n        let token = context.matchBefore(match);\n        return token || context.explicit ? {\n            from: token ? token.from : context.pos,\n            options,\n            validFor\n        } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return source(context);\n            if (pos.type.isTop) break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifNotIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return null;\n            if (pos.type.isTop) break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score){\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) {\n    return state.selection.main.from;\n}\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd) return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/ const pickedCompletion = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/ function insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return {\n        ...state.changeByRange((range)=>{\n            if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {\n                range\n            };\n            let lines = state.toText(text);\n            return {\n                changes: {\n                    from: range.from + fromOff,\n                    to: to == main.from ? range.to : range.from + toOff,\n                    insert: lines\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + lines.length)\n            };\n        }),\n        scrollIntoView: true,\n        userEvent: \"input.complete\"\n    };\n}\nconst SourceCache = /*@__PURE__*/ new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source)) return source;\n    let known = SourceCache.get(source);\n    if (!known) SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for(let p = 0; p < pattern.length;){\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return this;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0) return this.ret(-100 /* Penalty.NotFull */ , []);\n        if (word.length < this.pattern.length) return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);\n            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */ ;\n            if (first == chars[0]) ;\n            else if (first == folded[0]) score += -200 /* Penalty.CaseFold */ ;\n            else return null;\n            return this.ret(score, [\n                0,\n                firstSize\n            ]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ , [\n            0,\n            this.pattern.length\n        ]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for(let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;){\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len) return null;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for(let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */ ; i < e && byWordTo < len;){\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0) adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    } else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */  : next >= 65 && next <= 90 ? 1 /* Tp.Upper */  : 0 /* Tp.NonWord */  : (ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */  : ch != ch.toUpperCase() ? 2 /* Tp.Lower */  : 0 /* Tp.NonWord */ ;\n            if (!i || type == 1 /* Tp.Upper */  && hasLower || prevType == 0 /* Tp.NonWord */  && type != 0 /* Tp.NonWord */ ) {\n                if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;\n                else if (byWord.length) wordAdjacent = false;\n            }\n            prevType = type;\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 /* Penalty.CaseFold */  - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */ ), [\n            0,\n            adjacentEnd\n        ]);\n        if (direct > -1) return this.ret(-700 /* Penalty.NotStart */  - word.length, [\n            direct,\n            direct + this.pattern.length\n        ]);\n        if (adjacentTo == len) return this.ret(-200 /* Penalty.CaseFold */  + -700 /* Penalty.NotStart */  - word.length, [\n            adjacentStart,\n            adjacentEnd\n        ]);\n        if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0) + -700 /* Penalty.NotStart */  + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */ ), byWord, word);\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* Penalty.NotStart */  : 0) + -200 /* Penalty.CaseFold */  + -1100 /* Penalty.Gap */ , any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions){\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i && result[i - 1] == pos) result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\nclass StrictMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.matched = [];\n        this.score = 0;\n        this.folded = pattern.toLowerCase();\n    }\n    match(word) {\n        if (word.length < this.pattern.length) return null;\n        let start = word.slice(0, this.pattern.length);\n        let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 /* Penalty.CaseFold */  : null;\n        if (match == null) return null;\n        this.matched = [\n            0,\n            start.length\n        ];\n        this.score = match + (word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ );\n        return this;\n    }\n}\nconst completionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            activateOnTyping: true,\n            activateOnCompletion: ()=>false,\n            activateOnTypingDelay: 100,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: ()=>\"\",\n            optionClass: ()=>\"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            filterStrict: false,\n            compareCompletions: (a, b)=>(a.sortText || a.label).localeCompare(b.sortText || b.label),\n            interactionDelay: 75,\n            updateSyncTime: 100\n        }, {\n            defaultKeymap: (a, b)=>a && b,\n            closeOnBlur: (a, b)=>a && b,\n            icons: (a, b)=>a && b,\n            tooltipClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            optionClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            addToOptions: (a, b)=>a.concat(b),\n            filterStrict: (a, b)=>a || b\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Info.Width */ , left ? spaceLeft : spaceRight);\n    } else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Info.Width */ , (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */ );\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) {\n            offset = option.bottom - list.top;\n        } else {\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n    let scaleX = (list.right - list.left) / tooltip.offsetWidth;\n    return {\n        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,\n        class: \"cm-completionInfo-\" + (narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\")\n    };\n}\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons) content.push({\n        render (completion) {\n            let icon = document.createElement(\"div\");\n            icon.classList.add(\"cm-completionIcon\");\n            if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map((cls)=>\"cm-completionIcon-\" + cls));\n            icon.setAttribute(\"aria-hidden\", \"true\");\n            return icon;\n        },\n        position: 20\n    });\n    content.push({\n        render (completion, _s, _v, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for(let j = 0; j < match.length;){\n                let from = match[j++], to = match[j++];\n                if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render (completion) {\n            if (!completion.detail) return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b)=>a.position - b.position).map((a)=>a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max) return {\n        from: 0,\n        to: total\n    };\n    if (selected < 0) selected = 0;\n    if (selected <= total >> 1) {\n        let off = Math.floor(selected / max);\n        return {\n            from: off * max,\n            to: (off + 1) * max\n        };\n    }\n    let off = Math.floor((total - selected) / max);\n    return {\n        from: total - (off + 1) * max,\n        to: total - off * max\n    };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion){\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: ()=>this.measureInfo(),\n            write: (pos)=>this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e)=>{\n            let { options } = view.state.field(stateField).open;\n            for(let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode){\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e)=>{\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n        });\n        this.showOptions(options, cState.id);\n    }\n    mount() {\n        this.updateSel();\n    }\n    showOptions(options, id) {\n        if (this.list) this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n        this.list.addEventListener(\"scroll\", ()=>{\n            if (this.info) this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    update(update) {\n        var _a;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            let { options, selected, disabled } = cState.open;\n            if (!prevState.open || prevState.open.options != options) {\n                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);\n                this.showOptions(options, cState.id);\n            }\n            this.updateSel();\n            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))if (c) this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))if (c) this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info) this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.showOptions(open.options, cState.id);\n        }\n        let newSel = this.updateSelectedOption(open.selected);\n        if (newSel) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info) return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult) return;\n            if (\"then\" in infoResult) {\n                infoResult.then((obj)=>{\n                    if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);\n                }).catch((e)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n            } else {\n                this.addInfoPane(infoResult, completion);\n                newSel.setAttribute(\"aria-describedby\", this.info.id);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        wrap.id = \"cm-completionInfo-\" + Math.floor(Math.random() * 0xffff).toString(16);\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        } else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for(let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++){\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            } else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            } else {\n                if (opt.hasAttribute(\"aria-selected\")) {\n                    opt.removeAttribute(\"aria-selected\");\n                    opt.removeAttribute(\"aria-describedby\");\n                }\n            }\n        }\n        if (set) scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info) return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let docElt = this.dom.ownerDocument.documentElement;\n            space = {\n                left: 0,\n                top: 0,\n                right: docElt.clientWidth,\n                bottom: docElt.clientHeight\n            };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style) this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            } else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        ul.addEventListener(\"mousedown\", (e)=>{\n            // Prevent focus change when clicking the scrollbar\n            if (e.target == ul) e.preventDefault();\n        });\n        let curSection = null;\n        for(let i = range.from; i < range.to; i++){\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    } else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls) li.className = cls;\n            for (let source of this.optionContent){\n                let node = source(completion, this.view.state, this.view, match);\n                if (node) li.appendChild(node);\n            }\n        }\n        if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy) this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view)=>new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    let scaleY = parent.height / container.offsetHeight;\n    if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;\n    else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n}\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null, dynamicSectionScore = null;\n    let addOption = (option)=>{\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections) sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some((s)=>s.name == name)) sections.push(typeof section == \"string\" ? {\n                name\n            } : section);\n        }\n    };\n    let conf = state.facet(completionConfig);\n    for (let a of active)if (a.hasResult()) {\n        let getMatch = a.result.getMatch;\n        if (a.result.filter === false) {\n            for (let option of a.result.options){\n                addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n            }\n        } else {\n            let pattern = state.sliceDoc(a.from, a.to), match;\n            let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);\n            for (let option of a.result.options)if (match = matcher.match(option.label)) {\n                let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];\n                let score = match.score + (option.boost || 0);\n                addOption(new Option(option, a.source, matched, score));\n                if (typeof option.section == \"object\" && option.section.rank === \"dynamic\") {\n                    let { name } = option.section;\n                    if (!dynamicSectionScore) dynamicSectionScore = Object.create(null);\n                    dynamicSectionScore[name] = Math.max(score, dynamicSectionScore[name] || -1e9);\n                }\n            }\n        }\n    }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b)=>{\n            return (a.rank === \"dynamic\" && b.rank === \"dynamic\" ? dynamicSectionScore[b.name] - dynamicSectionScore[a.name] : 0) || (typeof a.rank == \"number\" ? a.rank : 1e9) - (typeof b.rank == \"number\" ? b.rank : 1e9) || (a.name < b.name ? -1 : 1);\n        };\n        for (let s of sections.sort(cmp)){\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options){\n            let { section } = option.completion;\n            if (section) option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = conf.compareCompletions;\n    for (let opt of options.sort((a, b)=>b.score - a.score || compare(a.completion, b.completion))){\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail || prev.type != null && cur.type != null && prev.type != cur.type || prev.apply != cur.apply || prev.boost != cur.boost) result.push(opt);\n        else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled){\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf, didSetActive) {\n        if (prev && !didSetActive && active.some((s)=>s.isPending)) return prev.setDisabled();\n        let options = sortOptions(active, state);\n        if (!options.length) return prev && active.some((a)=>a.isPending) ? prev.setDisabled() : null;\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for(let i = 0; i < options.length; i++)if (options[i].completion == selectedValue) {\n                selected = i;\n                break;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b)=>b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: createTooltip,\n            above: conf.aboveCursor\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, {\n            ...this.tooltip,\n            pos: changes.mapPos(this.tooltip.pos)\n        }, this.timestamp, this.selected, this.disabled);\n    }\n    setDisabled() {\n        return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open){\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map((source)=>{\n            let value = this.active.find((s)=>s.source == source) || new ActiveSource(source, this.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i)=>a == this.active[i])) active = this.active;\n        let open = this.open, didSet = tr.effects.some((e)=>e.is(setActiveEffect));\n        if (open && tr.docChanged) open = open.map(tr.changes);\n        if (tr.selection || active.some((a)=>a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet) open = CompletionDialog.build(active, state, this.id, open, conf, didSet);\n        else if (open && open.disabled && !active.some((a)=>a.isPending)) open = null;\n        if (!open && active.every((a)=>!a.isPending) && active.some((a)=>a.hasResult())) active = active.map((a)=>a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */ ) : a);\n        for (let effect of tr.effects)if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() {\n        return this.open ? this.open.tooltip : null;\n    }\n    get attrs() {\n        return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;\n    }\n}\nfunction sameResults(a, b) {\n    if (a == b) return true;\n    for(let iA = 0, iB = 0;;){\n        while(iA < a.length && !a[iA].hasResult())iA++;\n        while(iB < b.length && !b[iB].hasResult())iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB) return endA == endB;\n        if (a[iA++].result != b[iB++].result) return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nconst noAttrs = {};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUpdateType(tr, conf) {\n    if (tr.isUserEvent(\"input.complete\")) {\n        let completion = tr.annotation(pickedCompletion);\n        if (completion && conf.activateOnCompletion(completion)) return 4 /* UpdateType.Activate */  | 8 /* UpdateType.Reset */ ;\n    }\n    let typing = tr.isUserEvent(\"input.type\");\n    return typing && conf.activateOnTyping ? 4 /* UpdateType.Activate */  | 1 /* UpdateType.Typing */  : typing ? 1 /* UpdateType.Typing */  : tr.isUserEvent(\"delete.backward\") ? 2 /* UpdateType.Backspacing */  : tr.selection ? 8 /* UpdateType.Reset */  : tr.docChanged ? 16 /* UpdateType.ResetIfTouching */  : 0 /* UpdateType.None */ ;\n}\nclass ActiveSource {\n    constructor(source, state, explicit = false){\n        this.source = source;\n        this.state = state;\n        this.explicit = explicit;\n    }\n    hasResult() {\n        return false;\n    }\n    get isPending() {\n        return this.state == 1 /* State.Pending */ ;\n    }\n    update(tr, conf) {\n        let type = getUpdateType(tr, conf), value = this;\n        if (type & 8 /* UpdateType.Reset */  || type & 16 /* UpdateType.ResetIfTouching */  && this.touches(tr)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n        if (type & 4 /* UpdateType.Activate */  && value.state == 0 /* State.Inactive */ ) value = new ActiveSource(this.source, 1 /* State.Pending */ );\n        value = value.updateFor(tr, type);\n        for (let effect of tr.effects){\n            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */ , effect.value);\n            else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n            else if (effect.is(setActiveEffect)) {\n                for (let active of effect.value)if (active.source == value.source) value = active;\n            }\n        }\n        return value;\n    }\n    updateFor(tr, type) {\n        return this.map(tr.changes);\n    }\n    map(changes) {\n        return this;\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(cur(tr.state));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicit, limit, result, from, to){\n        super(source, 3 /* State.Result */ , explicit);\n        this.limit = limit;\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() {\n        return true;\n    }\n    updateFor(tr, type) {\n        var _a;\n        if (!(type & 3 /* UpdateType.SimpleInteraction */ )) return this.map(tr.changes);\n        let result = this.result;\n        if (result.map && !tr.changes.empty) result = result.map(result, tr.changes);\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if (pos > to || !result || type & 2 /* UpdateType.Backspacing */  && (cur(tr.startState) == this.from || pos < this.limit)) return new ActiveSource(this.source, type & 4 /* UpdateType.Activate */  ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n        let limit = tr.changes.mapPos(this.limit);\n        if (checkValid(result.validFor, tr.state, from, to)) return new ActiveResult(this.source, this.explicit, limit, result, from, to);\n        if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false)))) return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* State.Pending */ , this.explicit);\n    }\n    map(mapping) {\n        if (mapping.empty) return this;\n        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;\n        if (!result) return new ActiveSource(this.source, 0 /* State.Inactive */ );\n        return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(this.from, this.to);\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor) return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (sources, mapping) {\n        return sources.map((s)=>s.map(mapping));\n    }\n});\nconst setSelectedEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return CompletionState.start();\n    },\n    update (value, tr) {\n        return value.update(tr);\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, (val)=>val.tooltip),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, (state)=>state.attrs)\n        ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find((a)=>a.source == option.source);\n    if (!(result instanceof ActiveResult)) return false;\n    if (typeof apply == \"string\") view.dispatch({\n        ...insertCompletionText(view.state, apply, result.from, result.to),\n        annotations: pickedCompletion.of(option.completion)\n    });\n    else apply(view, option.completion, result.from, result.to);\n    return true;\n}\nconst createTooltip = /*@__PURE__*/ completionTooltip(completionState, applyCompletion);\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/ function moveCompletionSelection(forward, by = \"option\") {\n    return (view)=>{\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0) selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({\n            effects: setSelectedEffect.of(selected)\n        });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/ const acceptCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/ const startCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState) return false;\n    view.dispatch({\n        effects: startCompletionEffect.of(true)\n    });\n    return true;\n};\n/**\nClose the currently active completion.\n*/ const closeCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some((a)=>a.state != 0 /* State.Inactive */ )) return false;\n    view.dispatch({\n        effects: closeCompletionEffect.of(null)\n    });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context){\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.pendingStart = false;\n        this.composing = 0 /* CompositionState.None */ ;\n        for (let active of view.state.field(completionState).active)if (active.isPending) this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        let conf = update.state.facet(completionConfig);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n        let doesReset = update.transactions.some((tr)=>{\n            let type = getUpdateType(tr, conf);\n            return type & 8 /* UpdateType.Reset */  || (tr.selection || tr.docChanged) && !(type & 3 /* UpdateType.SimpleInteraction */ );\n        });\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners){\n                    try {\n                        handler();\n                    } catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            } else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n        if (update.transactions.some((tr)=>tr.effects.some((e)=>e.is(startCompletionEffect)))) this.pendingStart = true;\n        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;\n        this.debounceUpdate = cState.active.some((a)=>a.isPending && !this.running.some((q)=>q.active.source == a.source)) ? setTimeout(()=>this.startUpdate(), delay) : -1;\n        if (this.composing != 0 /* CompositionState.None */ ) for (let tr of update.transactions){\n            if (tr.isUserEvent(\"input.type\")) this.composing = 2 /* CompositionState.Changed */ ;\n            else if (this.composing == 2 /* CompositionState.Changed */  && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */ ;\n        }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        this.pendingStart = false;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active){\n            if (active.isPending && !this.running.some((r)=>r.active.source == active.source)) this.startQuery(active);\n        }\n        if (this.running.length && cState.open && cState.open.disabled) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicit, this.view);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then((result)=>{\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, (err)=>{\n            this.view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every((q)=>q.done !== undefined)) this.accept();\n        else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (query.done === undefined) continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);\n                let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));\n                let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : pos);\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = cState.active.find((a)=>a.source == query.active.source);\n            if (current && current.isPending) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */ );\n                    for (let tr of query.updates)active = active.update(tr, conf);\n                    if (!active.isPending) updated.push(active);\n                } else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length || cState.open && cState.open.disabled) this.view.dispatch({\n            effects: setActiveEffect.of(updated)\n        });\n    }\n}, {\n    eventHandlers: {\n        blur (event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(()=>this.view.dispatch({\n                        effects: closeCompletionEffect.of(null)\n                    }), 10);\n            }\n        },\n        compositionstart () {\n            this.composing = 1 /* CompositionState.Started */ ;\n        },\n        compositionend () {\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */ ) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(()=>this.view.dispatch({\n                        effects: startCompletionEffect.of(false)\n                    }), 20);\n            }\n            this.composing = 0 /* CompositionState.None */ ;\n        }\n    }\n});\nconst windows = typeof navigator == \"object\" && /*@__PURE__*/ /Win/.test(navigator.platform);\nconst commitCharacters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    keydown (event, view) {\n        let field = view.state.field(completionState, false);\n        if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey) return false;\n        let option = field.open.options[field.open.selected];\n        let result = field.active.find((a)=>a.source == option.source);\n        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;\n        if (commitChars && commitChars.indexOf(event.key) > -1) applyCompletion(view, option);\n        return false;\n    }\n}));\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\"\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\"\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\"\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\"\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\\xb7\\xb7\\xb7\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Info.Width */ }px`,\n        boxSizing: \"border-box\",\n        whiteSpace: \"pre-line\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": {\n        right: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-right\": {\n        left: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n        right: `${30 /* Info.Margin */ }px`\n    },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n        left: `${30 /* Info.Margin */ }px`\n    },\n    \"&light .cm-snippetField\": {\n        backgroundColor: \"#00000022\"\n    },\n    \"&dark .cm-snippetField\": {\n        backgroundColor: \"#ffffff22\"\n    },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": {\n            content: \"'Æ’'\"\n        }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": {\n            content: \"'â—‹'\"\n        }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": {\n            content: \"'â—Œ'\"\n        }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC65'\"\n        }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC36'\"\n        }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC61'\"\n        }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": {\n            content: \"'âˆª'\"\n        }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": {\n            content: \"'â–¡'\"\n        }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": {\n            content: \"'\\uD83D\\uDD11ï¸Ž'\"\n        } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": {\n            content: \"'â–¢'\"\n        }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": {\n            content: \"'abc'\",\n            fontSize: \"50%\",\n            verticalAlign: \"middle\"\n        }\n    }\n});\nclass FieldPos {\n    constructor(field, line, from, to){\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to){\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions){\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [\n            pos\n        ];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines){\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for(let i = 0; i < tabs; i++)indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map((pos)=>new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return {\n            text,\n            ranges\n        };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)){\n            while(m = /[#$]\\{(?:(\\d+)(?::([^{}]*))?|((?:\\\\[{}]|[^{}])*))\\}/.exec(line)){\n                let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || \"\", found = -1;\n                let name = rawName.replace(/\\\\[{}]/g, (m)=>m[1]);\n                for(let i = 0; i < fields.length; i++){\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while(i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))i++;\n                    fields.splice(i, 0, {\n                        seq,\n                        name\n                    });\n                    found = i;\n                    for (let pos of positions)if (pos.field >= found) pos.field++;\n                }\n                for (let pos of positions)if (pos.line == lines.length && pos.from > m.index) {\n                    let snip = m[2] ? 3 + (m[1] || \"\").length : 2;\n                    pos.from -= snip;\n                    pos.to -= snip;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);\n            }\n            line = line.replace(/\\\\([{}])/g, (_, brace, index)=>{\n                for (let pos of positions)if (pos.line == lines.length && pos.from > index) {\n                    pos.from--;\n                    pos.to--;\n                }\n                return brace;\n            });\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() {\n            return false;\n        }\n    }\n});\nlet fieldRange = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n    constructor(ranges, active){\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map((r)=>(r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)), true);\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges){\n            let mapped = r.map(changes);\n            if (!mapped) return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every((range)=>this.ranges.some((r)=>r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, changes) {\n        return value && value.map(changes);\n    }\n});\nconst moveToField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setActive)) return effect.value;\n            if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged) value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (val)=>val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter((r)=>r.field == field).map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/ function snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to)=>{\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let { main } = editor.state.selection;\n        let spec = {\n            changes: {\n                from,\n                to: to == main.from ? main.to : to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text)\n            },\n            scrollIntoView: true,\n            annotations: completion ? [\n                pickedCompletion.of(completion),\n                _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent.of(\"input.complete\")\n            ] : undefined\n        };\n        if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n        if (ranges.some((r)=>r.field > 0)) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [\n                setActive.of(active)\n            ];\n            if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n                snippetState,\n                addSnippetKeymap,\n                snippetPointerHandler,\n                baseTheme\n            ]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch })=>{\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0) return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some((r)=>r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n            scrollIntoView: true\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/ const clearSnippet = ({ state, dispatch })=>{\n    let active = state.field(snippetState, false);\n    if (!active) return false;\n    dispatch(state.update({\n        effects: setActive.of(null)\n    }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/ const nextSnippetField = /*@__PURE__*/ moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/ const prevSnippetField = /*@__PURE__*/ moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/ function hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some((r)=>r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/ function hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    {\n        key: \"Tab\",\n        run: nextSnippetField,\n        shift: prevSnippetField\n    },\n    {\n        key: \"Escape\",\n        run: clearSnippet\n    }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/ const snippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (maps) {\n        return maps.length ? maps[0] : defaultSnippetKeymap;\n    }\n});\nconst addSnippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([\n    snippetKeymap\n], (state)=>state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/ function snippetCompletion(template, completion) {\n    return {\n        ...completion,\n        apply: snippet(template)\n    };\n}\nconst snippetPointerHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    mousedown (event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({\n            x: event.clientX,\n            y: event.clientY\n        })) == null) return false;\n        let match = active.ranges.find((r)=>r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active) return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some((r)=>r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),\n            scrollIntoView: true\n        });\n        return true;\n    }\n});\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    } catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/ Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for(let lines = doc.iterLines(), pos = 0; !lines.next().done;){\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while(m = wordRE.exec(value)){\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({\n                    type: \"text\",\n                    label: m[0]\n                });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* C.MaxList */ ) return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* C.MinCacheLen */ ;\n    let cached = big && cache.get(doc);\n    if (cached) return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children){\n            if (ch.length >= 1000 /* C.MinCacheLen */ ) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)){\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            } else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    } else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* C.MaxList */ ) cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/ const completeAnyWord = (context)=>{\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, (s)=>s + \"$\"));\n    if (!token && !context.explicit) return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */ , from);\n    return {\n        from,\n        options,\n        validFor: mapRE(re, (s)=>\"^\" + s)\n    };\n};\nconst defaults = {\n    brackets: [\n        \"(\",\n        \"[\",\n        \"{\",\n        \"'\",\n        '\"'\n    ],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/ new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (value, tr) {\n        value = value.map(tr.changes);\n        if (tr.selection) {\n            let line = tr.state.doc.lineAt(tr.selection.main.head);\n            value = value.update({\n                filter: (from)=>from >= line.from && from <= line.to\n            });\n        }\n        for (let effect of tr.effects)if (effect.is(closeBracketEffect)) value = value.update({\n            add: [\n                closedBracket.range(effect.value, effect.value + 1)\n            ]\n        });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/ function closeBrackets() {\n    return [\n        inputHandler,\n        bracketState\n    ];\n}\nconst definedClosing = \"()[]{}<>\\xab\\xbb\\xbb\\xabï¼»ï¼½ï½›ï½\";\nfunction closing(ch) {\n    for(let i = 0; i < definedClosing.length; i += 2)if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr) return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/ const deleteBracketPair = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens){\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0))) return {\n                    changes: {\n                        from: range.head - token.length,\n                        to: range.head + token.length\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length)\n                };\n            }\n        }\n        return {\n            range: dont = range\n        };\n    });\n    if (!dont) dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"delete.backward\"\n    }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/ const closeBracketsKeymap = [\n    {\n        key: \"Backspace\",\n        run: deleteBracketPair\n    }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert bracketsâ€”the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/ function insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens){\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n        if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, (from)=>{\n        if (from == pos) found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: open,\n                    from: range.from\n                },\n                {\n                    insert: close,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n        };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n            changes: {\n                insert: open + close,\n                from: range.head\n            },\n            effects: closeBracketEffect.of(range.head + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length)\n        };\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty && nextChar(state.doc, range.head) == close) return {\n            changes: {\n                from: range.head,\n                to: range.head + close.length,\n                insert: close\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length)\n        };\n        return dont = {\n            range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: token,\n                    from: range.from\n                },\n                {\n                    insert: token,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + token.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n        };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return {\n                    changes: {\n                        insert: token + token,\n                        from: pos\n                    },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n                };\n            } else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return {\n                    changes: {\n                        from: pos,\n                        to: pos + content.length,\n                        insert: content\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length)\n                };\n            }\n        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n            return {\n                changes: {\n                    insert: token + token + token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        } else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n                changes: {\n                    insert: token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        }\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p)=>Math.max(m, p.length), 0);\n    for(let i = 0; i < 5; i++){\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while(first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos){\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent) break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return pos;\n    for (let prefix of prefixes){\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return start;\n    }\n    return -1;\n}\n/**\nReturns an extension that enables autocompletion.\n*/ function autocompletion(config = {}) {\n    return [\n        commitCharacters,\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space (and Alt-\\` or Alt-i on macOS): [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/ const completionKeymap = [\n    {\n        key: \"Ctrl-Space\",\n        run: startCompletion\n    },\n    {\n        mac: \"Alt-`\",\n        run: startCompletion\n    },\n    {\n        mac: \"Alt-i\",\n        run: startCompletion\n    },\n    {\n        key: \"Escape\",\n        run: closeCompletion\n    },\n    {\n        key: \"ArrowDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true)\n    },\n    {\n        key: \"ArrowUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false)\n    },\n    {\n        key: \"PageDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true, \"page\")\n    },\n    {\n        key: \"PageUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false, \"page\")\n    },\n    {\n        key: \"Enter\",\n        run: acceptCompletion\n    }\n];\nconst completionKeymapExt = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([\n    completionConfig\n], (state)=>state.facet(completionConfig).defaultKeymap ? [\n        completionKeymap\n    ] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/ function completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some((a)=>a.isPending) ? \"pending\" : cState && cState.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/ new WeakMap;\n/**\nReturns the available completions as an array.\n*/ function currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled) return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions) completionArrayCache.set(open.options, completions = open.options.map((o)=>o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/ function selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/ function selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/ function setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3IrYXV0b2NvbXBsZXRlQDYuMjAuMC9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdPO0FBQ3BGO0FBQzlFO0FBRTlEOztBQUVBLEdBQ0EsTUFBTTJCO0lBQ0Y7Ozs7SUFJQSxHQUNBQyxZQUNBOztJQUVBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7O0lBS0EsR0FDQUMsUUFBUSxFQUNSOzs7Ozs7SUFNQSxHQUNBQyxJQUFJLENBQUU7UUFDRixJQUFJLENBQUNILEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1o7O1FBRUEsR0FDQSxJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztJQUM1QjtJQUNBOzs7SUFHQSxHQUNBQyxZQUFZQyxLQUFLLEVBQUU7UUFDZixJQUFJQyxRQUFRWixnRUFBVUEsQ0FBQyxJQUFJLENBQUNJLEtBQUssRUFBRVMsWUFBWSxDQUFDLElBQUksQ0FBQ1IsR0FBRyxFQUFFLENBQUM7UUFDM0QsTUFBT08sU0FBU0QsTUFBTUcsT0FBTyxDQUFDRixNQUFNRyxJQUFJLElBQUksRUFDeENILFFBQVFBLE1BQU1JLE1BQU07UUFDeEIsT0FBT0osUUFBUTtZQUFFSyxNQUFNTCxNQUFNSyxJQUFJO1lBQUVDLElBQUksSUFBSSxDQUFDYixHQUFHO1lBQzNDYyxNQUFNLElBQUksQ0FBQ2YsS0FBSyxDQUFDZ0IsUUFBUSxDQUFDUixNQUFNSyxJQUFJLEVBQUUsSUFBSSxDQUFDWixHQUFHO1lBQzlDZ0IsTUFBTVQsTUFBTVMs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QUNoQztBQUU2aEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29kZW1pcnJvcithdXRvY29tcGxldGVANi4yMC4wL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5qcz84N2NlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFubm90YXRpb24sIFN0YXRlRWZmZWN0LCBFZGl0b3JTZWxlY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBmcm9tQ29kZVBvaW50LCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgUHJlYywgVGV4dCwgVHJhbnNhY3Rpb24sIE1hcE1vZGUsIFJhbmdlVmFsdWUsIFJhbmdlU2V0LCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBEaXJlY3Rpb24sIGxvZ0V4Y2VwdGlvbiwgc2hvd1Rvb2x0aXAsIEVkaXRvclZpZXcsIFZpZXdQbHVnaW4sIGdldFRvb2x0aXAsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGtleW1hcCB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcblxuLyoqXG5BbiBpbnN0YW5jZSBvZiB0aGlzIGlzIHBhc3NlZCB0byBjb21wbGV0aW9uIHNvdXJjZSBmdW5jdGlvbnMuXG4qL1xuY2xhc3MgQ29tcGxldGlvbkNvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBjb21wbGV0aW9uIGNvbnRleHQuIChNb3N0bHkgdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgY29tcGxldGlvbiBzb3VyY2Vz4oCUaW4gdGhlIGVkaXRvciwgdGhlIGV4dGVuc2lvbiB3aWxsIGNyZWF0ZVxuICAgIHRoZXNlIGZvciB5b3UuKVxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZSB0aGF0IHRoZSBjb21wbGV0aW9uIGhhcHBlbnMgaW4uXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBjb21wbGV0aW9uIGlzIGhhcHBlbmluZy5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgY29tcGxldGlvbiB3YXMgYWN0aXZhdGVkIGV4cGxpY2l0bHksIG9yXG4gICAgaW1wbGljaXRseSBieSB0eXBpbmcuIFRoZSB1c3VhbCB3YXkgdG8gcmVzcG9uZCB0byB0aGlzIGlzIHRvXG4gICAgb25seSByZXR1cm4gY29tcGxldGlvbnMgd2hlbiBlaXRoZXIgdGhlcmUgaXMgcGFydCBvZiBhXG4gICAgY29tcGxldGFibGUgZW50aXR5IGJlZm9yZSB0aGUgY3Vyc29yLCBvciBgZXhwbGljaXRgIGlzIHRydWUuXG4gICAgKi9cbiAgICBleHBsaWNpdCwgXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciB2aWV3LiBNYXkgYmUgdW5kZWZpbmVkIGlmIHRoZSBjb250ZXh0IHdhcyBjcmVhdGVkXG4gICAgaW4gYSBzaXR1YXRpb24gd2hlcmUgdGhlcmUgaXMgbm8gc3VjaCB2aWV3IGF2YWlsYWJsZSwgc3VjaCBhc1xuICAgIGluIHN5bmNocm9ub3VzIHVwZGF0ZXMgdmlhXG4gICAgW2BDb21wbGV0aW9uUmVzdWx0LnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25SZXN1bHQudXBkYXRlKVxuICAgIG9yIHdoZW4gY2FsbGVkIGJ5IHRlc3QgY29kZS5cbiAgICAqL1xuICAgIHZpZXcpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0T25Eb2NDaGFuZ2UgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQsIGNvbnRlbnQsIGFuZCAoaWYgdGhlcmUgaXMgYSB0b2tlbikgdHlwZSBvZiB0aGVcbiAgICB0b2tlbiBiZWZvcmUgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIHRva2VuQmVmb3JlKHR5cGVzKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHN5bnRheFRyZWUodGhpcy5zdGF0ZSkucmVzb2x2ZUlubmVyKHRoaXMucG9zLCAtMSk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAmJiB0eXBlcy5pbmRleE9mKHRva2VuLm5hbWUpIDwgMClcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4ucGFyZW50O1xuICAgICAgICByZXR1cm4gdG9rZW4gPyB7IGZyb206IHRva2VuLmZyb20sIHRvOiB0aGlzLnBvcyxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuc3RhdGUuc2xpY2VEb2ModG9rZW4uZnJvbSwgdGhpcy5wb3MpLFxuICAgICAgICAgICAgdHlwZTogdG9rZW4udHlwZSB9IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXRjaCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBkaXJlY3RseSBiZWZvcmUgdGhlXG4gICAgY3Vyc29yLlxuICAgICovXG4gICAgbWF0Y2hCZWZvcmUoZXhwcikge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgdGhpcy5wb3MgLSAyNTApO1xuICAgICAgICBsZXQgc3RyID0gbGluZS50ZXh0LnNsaWNlKHN0YXJ0IC0gbGluZS5mcm9tLCB0aGlzLnBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBmb3VuZCA9IHN0ci5zZWFyY2goZW5zdXJlQW5jaG9yKGV4cHIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogeyBmcm9tOiBzdGFydCArIGZvdW5kLCB0bzogdGhpcy5wb3MsIHRleHQ6IHN0ci5zbGljZShmb3VuZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgWWllbGRzIHRydWUgd2hlbiB0aGUgcXVlcnkgaGFzIGJlZW4gYWJvcnRlZC4gQ2FuIGJlIHVzZWZ1bCBpblxuICAgIGFzeW5jaHJvbm91cyBxdWVyaWVzIHRvIGF2b2lkIGRvaW5nIHdvcmsgdGhhdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHsgcmV0dXJuIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgYWJvcnQgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICB0aGUgcXVlcnkgaXNcbiAgICBbYWJvcnRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbkNvbnRleHQuYWJvcnRlZCkuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgcnVubmluZyBxdWVyaWVzIHdpbGwgbm90IGJlIGFib3J0ZWQgZm9yIHJlZ3VsYXJcbiAgICB0eXBpbmcgb3IgYmFja3NwYWNpbmcsIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhleSBhcmUgbGlrZWx5IHRvXG4gICAgcmV0dXJuIGEgcmVzdWx0IHdpdGggYVxuICAgIFtgdmFsaWRGb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uUmVzdWx0LnZhbGlkRm9yKSBmaWVsZCB0aGF0XG4gICAgYWxsb3dzIHRoZSByZXN1bHQgdG8gYmUgdXNlZCBhZnRlciBhbGwuIFBhc3NpbmcgYG9uRG9jQ2hhbmdlOlxuICAgIHRydWVgIHdpbGwgY2F1c2UgdGhpcyBxdWVyeSB0byBiZSBhYm9ydGVkIGZvciBhbnkgZG9jdW1lbnRcbiAgICBjaGFuZ2UuXG4gICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiYWJvcnRcIiAmJiB0aGlzLmFib3J0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vbkRvY0NoYW5nZSlcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0T25Eb2NDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TZXQoY2hhcnMpIHtcbiAgICBsZXQgZmxhdCA9IE9iamVjdC5rZXlzKGNoYXJzKS5qb2luKFwiXCIpO1xuICAgIGxldCB3b3JkcyA9IC9cXHcvLnRlc3QoZmxhdCk7XG4gICAgaWYgKHdvcmRzKVxuICAgICAgICBmbGF0ID0gZmxhdC5yZXBsYWNlKC9cXHcvZywgXCJcIik7XG4gICAgcmV0dXJuIGBbJHt3b3JkcyA/IFwiXFxcXHdcIiA6IFwiXCJ9JHtmbGF0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCBcIlxcXFwkJlwiKX1dYDtcbn1cbmZ1bmN0aW9uIHByZWZpeE1hdGNoKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlyc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByZXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCB7IGxhYmVsIH0gb2Ygb3B0aW9ucykge1xuICAgICAgICBmaXJzdFtsYWJlbFswXV0gPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdFtsYWJlbFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgc291cmNlID0gdG9TZXQoZmlyc3QpICsgdG9TZXQocmVzdCkgKyBcIiokXCI7XG4gICAgcmV0dXJuIFtuZXcgUmVnRXhwKFwiXlwiICsgc291cmNlKSwgbmV3IFJlZ0V4cChzb3VyY2UpXTtcbn1cbi8qKlxuR2l2ZW4gYSBhIGZpeGVkIGFycmF5IG9mIG9wdGlvbnMsIHJldHVybiBhbiBhdXRvY29tcGxldGVyIHRoYXRcbmNvbXBsZXRlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRlRnJvbUxpc3QobGlzdCkge1xuICAgIGxldCBvcHRpb25zID0gbGlzdC5tYXAobyA9PiB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8geyBsYWJlbDogbyB9IDogbyk7XG4gICAgbGV0IFt2YWxpZEZvciwgbWF0Y2hdID0gb3B0aW9ucy5ldmVyeShvID0+IC9eXFx3KyQvLnRlc3Qoby5sYWJlbCkpID8gWy9cXHcqJC8sIC9cXHcrJC9dIDogcHJlZml4TWF0Y2gob3B0aW9ucyk7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWF0Y2gpO1xuICAgICAgICByZXR1cm4gdG9rZW4gfHwgY29udGV4dC5leHBsaWNpdCA/IHsgZnJvbTogdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3MsIG9wdGlvbnMsIHZhbGlkRm9yIH0gOiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBvbmx5IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZkluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHBvcy50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBub3QgZmlyZSB3aGVuIHRoZVxuY3Vyc29yIGlzIGluIGEgc3ludGF4IG5vZGUgd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG5hbWVzLlxuKi9cbmZ1bmN0aW9uIGlmTm90SW4obm9kZXMsIHNvdXJjZSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKHBvcy50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UoY29udGV4dCk7XG4gICAgfTtcbn1cbmNsYXNzIE9wdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29tcGxldGlvbiwgc291cmNlLCBtYXRjaCwgc2NvcmUpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGN1cihzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbTsgfVxuLy8gTWFrZSBzdXJlIHRoZSBnaXZlbiByZWdleHAgaGFzIGEgJCBhdCBpdHMgZW5kIGFuZCwgaWYgYHN0YXJ0YCBpc1xuLy8gdHJ1ZSwgYSBeIGF0IGl0cyBzdGFydC5cbmZ1bmN0aW9uIGVuc3VyZUFuY2hvcihleHByLCBzdGFydCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBzb3VyY2UgfSA9IGV4cHI7XG4gICAgbGV0IGFkZFN0YXJ0ID0gc3RhcnQgJiYgc291cmNlWzBdICE9IFwiXlwiLCBhZGRFbmQgPSBzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9IFwiJFwiO1xuICAgIGlmICghYWRkU3RhcnQgJiYgIWFkZEVuZClcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYCR7YWRkU3RhcnQgPyBcIl5cIiA6IFwiXCJ9KD86JHtzb3VyY2V9KSR7YWRkRW5kID8gXCIkXCIgOiBcIlwifWAsIChfYSA9IGV4cHIuZmxhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChleHByLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpKTtcbn1cbi8qKlxuVGhpcyBhbm5vdGF0aW9uIGlzIGFkZGVkIHRvIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBwcm9kdWNlZCBieVxucGlja2luZyBhIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgcGlja2VkQ29tcGxldGlvbiA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJhbnNhY3Rpb24gc3BlYyB3aGljaCBpbnNlcnRzIGFcbmNvbXBsZXRpb24ncyB0ZXh0IGluIHRoZSBtYWluIHNlbGVjdGlvbiByYW5nZSwgYW5kIGFueSBvdGhlclxuc2VsZWN0aW9uIHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIHRleHQgaW4gZnJvbnQgb2YgaXQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0Q29tcGxldGlvblRleHQoc3RhdGUsIHRleHQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gc3RhdGUuc2VsZWN0aW9uLCBmcm9tT2ZmID0gZnJvbSAtIG1haW4uZnJvbSwgdG9PZmYgPSB0byAtIG1haW4uZnJvbTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGlmIChyYW5nZSAhPSBtYWluICYmIGZyb20gIT0gdG8gJiZcbiAgICAgICAgICAgICAgICBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tICsgZnJvbU9mZiwgcmFuZ2UuZnJvbSArIHRvT2ZmKSAhPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0YXRlLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tICsgZnJvbU9mZiwgdG86IHRvID09IG1haW4uZnJvbSA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSArIHRvT2ZmLCBpbnNlcnQ6IGxpbmVzIH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGZyb21PZmYgKyBsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiXG4gICAgfTtcbn1cbmNvbnN0IFNvdXJjZUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcbiAgICBpZiAoIWtub3duKVxuICAgICAgICBTb3VyY2VDYWNoZS5zZXQoc291cmNlLCBrbm93biA9IGNvbXBsZXRlRnJvbUxpc3Qoc291cmNlKSk7XG4gICAgcmV0dXJuIGtub3duO1xufVxuY29uc3Qgc3RhcnRDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY2xvc2VDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXG4vLyBvbmNlIGZvciBhIHBhdHRlcm4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIG1hdGNoIGFueSBudW1iZXIgb2Zcbi8vIGNvbXBsZXRpb25zLlxuY2xhc3MgRnV6enlNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBbXTtcbiAgICAgICAgLy8gQnVmZmVycyByZXVzZWQgYnkgY2FsbHMgdG8gYG1hdGNoYCB0byB0cmFjayBtYXRjaGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IFtdO1xuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xuICAgICAgICB0aGlzLnNjb3JlID0gMDtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0dGVybi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNvZGVQb2ludEF0KHBhdHRlcm4sIHApLCBzaXplID0gY29kZVBvaW50U2l6ZShjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gcGF0dGVybi5zbGljZShwLCBwICsgc2l6ZSksIHVwcGVyID0gcGFydC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkZWQucHVzaChjb2RlUG9pbnRBdCh1cHBlciA9PSBwYXJ0ID8gcGFydC50b0xvd2VyQ2FzZSgpIDogdXBwZXIsIDApKTtcbiAgICAgICAgICAgIHAgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzdHJhbCA9IHBhdHRlcm4ubGVuZ3RoICE9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICByZXQoc2NvcmUsIG1hdGNoZWQpIHtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBtYXRjaGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhIGdpdmVuIHdvcmQgKGNvbXBsZXRpb24pIGFnYWluc3QgdGhlIHBhdHRlcm4gKGlucHV0KS5cbiAgICAvLyBXaWxsIHJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIHdhcyBhIG1hdGNoIGFuZCxcbiAgICAvLyBvbiBzdWNjZXNzLCBzZXQgYHRoaXMuc2NvcmVgIHRvIHRoZSBzY29yZSwgYHRoaXMubWF0Y2hlZGAgdG8gYW5cbiAgICAvLyBhcnJheSBvZiBgZnJvbSwgdG9gIHBhaXJzIGluZGljYXRpbmcgdGhlIG1hdGNoZWQgcGFydHMgb2YgYHdvcmRgLlxuICAgIC8vXG4gICAgLy8gVGhlIHNjb3JlIGlzIGEgbnVtYmVyIHRoYXQgaXMgbW9yZSBuZWdhdGl2ZSB0aGUgd29yc2UgdGhlIG1hdGNoXG4gICAgLy8gaXMuIFNlZSBgUGVuYWx0eWAgYWJvdmUuXG4gICAgbWF0Y2god29yZCkge1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovLCBbXSk7XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgY2hhcnMsIGZvbGRlZCwgYW55LCBwcmVjaXNlLCBieVdvcmQgfSA9IHRoaXM7XG4gICAgICAgIC8vIEZvciBzaW5nbGUtY2hhcmFjdGVyIHF1ZXJpZXMsIG9ubHkgbWF0Y2ggd2hlbiB0aGV5IG9jY3VyIHJpZ2h0XG4gICAgICAgIC8vIGF0IHRoZSBzdGFydFxuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGNvZGVQb2ludEF0KHdvcmQsIDApLCBmaXJzdFNpemUgPSBjb2RlUG9pbnRTaXplKGZpcnN0KTtcbiAgICAgICAgICAgIGxldCBzY29yZSA9IGZpcnN0U2l6ZSA9PSB3b3JkLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLztcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PSBjaGFyc1swXSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPT0gZm9sZGVkWzBdKVxuICAgICAgICAgICAgICAgIHNjb3JlICs9IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldChzY29yZSwgWzAsIGZpcnN0U2l6ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXJlY3QgPSB3b3JkLmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRpcmVjdCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KHdvcmQubGVuZ3RoID09IHRoaXMucGF0dGVybi5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8sIFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgIGxldCBsZW4gPSBjaGFycy5sZW5ndGgsIGFueVRvID0gMDtcbiAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCk7IGkgPCBlICYmIGFueVRvIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYW55VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FueVRvXSlcbiAgICAgICAgICAgICAgICAgICAgYW55W2FueVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtYXRjaCwgZXhpdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGFueVRvIDwgbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgdHJhY2tzIHRoZSBleHRlbnQgb2YgdGhlIHByZWNpc2UgKG5vbi1mb2xkZWQsIG5vdFxuICAgICAgICAvLyBuZWNlc3NhcmlseSBhZGphY2VudCkgbWF0Y2hcbiAgICAgICAgbGV0IHByZWNpc2VUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZXJlIGlzIGEgbWF0Y2ggdGhhdCBoaXRzIG9ubHkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgIC8vIGFwcGVhciB0byBiZSBzdGFydGluZyB3b3Jkcy4gYGJ5V29yZEZvbGRlZGAgaXMgc2V0IHRvIHRydWUgd2hlblxuICAgICAgICAvLyBhIGNhc2UgZm9sZGVkIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBzdWNoIGEgbWF0Y2hcbiAgICAgICAgbGV0IGJ5V29yZFRvID0gMCwgYnlXb3JkRm9sZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIGEgcGFydGlhbCBhZGphY2VudCBtYXRjaCwgdGhlc2UgdHJhY2sgaXRzIHN0YXRlXG4gICAgICAgIGxldCBhZGphY2VudFRvID0gMCwgYWRqYWNlbnRTdGFydCA9IC0xLCBhZGphY2VudEVuZCA9IC0xO1xuICAgICAgICBsZXQgaGFzTG93ZXIgPSAvW2Etel0vLnRlc3Qod29yZCksIHdvcmRBZGphY2VudCA9IHRydWU7XG4gICAgICAgIC8vIEdvIG92ZXIgdGhlIG9wdGlvbidzIHRleHQsIHNjYW5uaW5nIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBtYXRjaGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCksIHByZXZUeXBlID0gMCAvKiBUcC5Ob25Xb3JkICovOyBpIDwgZSAmJiBieVdvcmRUbyA8IGxlbjspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNlVG8gPCBsZW4gJiYgbmV4dCA9PSBjaGFyc1twcmVjaXNlVG9dKVxuICAgICAgICAgICAgICAgICAgICBwcmVjaXNlW3ByZWNpc2VUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYWRqYWNlbnRUb10gfHwgbmV4dCA9PSBmb2xkZWRbYWRqYWNlbnRUb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudEVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2gsIHR5cGUgPSBuZXh0IDwgMHhmZlxuICAgICAgICAgICAgICAgID8gKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NyB8fCBuZXh0ID49IDk3ICYmIG5leHQgPD0gMTIyID8gMiAvKiBUcC5Mb3dlciAqLyA6IG5leHQgPj0gNjUgJiYgbmV4dCA8PSA5MCA/IDEgLyogVHAuVXBwZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pXG4gICAgICAgICAgICAgICAgOiAoKGNoID0gZnJvbUNvZGVQb2ludChuZXh0KSkgIT0gY2gudG9Mb3dlckNhc2UoKSA/IDEgLyogVHAuVXBwZXIgKi8gOiBjaCAhPSBjaC50b1VwcGVyQ2FzZSgpID8gMiAvKiBUcC5Mb3dlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLyk7XG4gICAgICAgICAgICBpZiAoIWkgfHwgdHlwZSA9PSAxIC8qIFRwLlVwcGVyICovICYmIGhhc0xvd2VyIHx8IHByZXZUeXBlID09IDAgLyogVHAuTm9uV29yZCAqLyAmJiB0eXBlICE9IDAgLyogVHAuTm9uV29yZCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyc1tieVdvcmRUb10gPT0gbmV4dCB8fCAoZm9sZGVkW2J5V29yZFRvXSA9PSBuZXh0ICYmIChieVdvcmRGb2xkZWQgPSB0cnVlKSkpXG4gICAgICAgICAgICAgICAgICAgIGJ5V29yZFtieVdvcmRUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnlXb3JkLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd29yZEFkamFjZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbiAmJiBieVdvcmRbMF0gPT0gMCAmJiB3b3JkQWRqYWNlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuICYmIGFkamFjZW50U3RhcnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gLSB3b3JkLmxlbmd0aCArIChhZGphY2VudEVuZCA9PSB3b3JkLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLyksIFswLCBhZGphY2VudEVuZF0pO1xuICAgICAgICBpZiAoZGlyZWN0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIFtkaXJlY3QsIGRpcmVjdCArIHRoaXMucGF0dGVybi5sZW5ndGhdKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBbYWRqYWNlbnRTdGFydCwgYWRqYWNlbnRFbmRdKTtcbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIFBlbmFsdHkuQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IDApICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovICtcbiAgICAgICAgICAgICAgICAod29yZEFkamFjZW50ID8gMCA6IC0xMTAwIC8qIFBlbmFsdHkuR2FwICovKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmxlbmd0aCA9PSAyID8gbnVsbFxuICAgICAgICAgICAgOiB0aGlzLnJlc3VsdCgoYW55WzBdID8gLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIDogMCkgKyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLywgYW55LCB3b3JkKTtcbiAgICB9XG4gICAgcmVzdWx0KHNjb3JlLCBwb3NpdGlvbnMsIHdvcmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucykge1xuICAgICAgICAgICAgbGV0IHRvID0gcG9zICsgKHRoaXMuYXN0cmFsID8gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdCh3b3JkLCBwb3MpKSA6IDEpO1xuICAgICAgICAgICAgaWYgKGkgJiYgcmVzdWx0W2kgLSAxXSA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2kgLSAxXSA9IHRvO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXQoc2NvcmUgLSB3b3JkLmxlbmd0aCwgcmVzdWx0KTtcbiAgICB9XG59XG5jbGFzcyBTdHJpY3RNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IFtdO1xuICAgICAgICB0aGlzLnNjb3JlID0gMDtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3RhcnQgPSB3b3JkLnNsaWNlKDAsIHRoaXMucGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzdGFydCA9PSB0aGlzLnBhdHRlcm4gPyAwIDogc3RhcnQudG9Mb3dlckNhc2UoKSA9PSB0aGlzLmZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IG51bGw7XG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IFswLCBzdGFydC5sZW5ndGhdO1xuICAgICAgICB0aGlzLnNjb3JlID0gbWF0Y2ggKyAod29yZC5sZW5ndGggPT0gdGhpcy5wYXR0ZXJuLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY29uc3QgY29tcGxldGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhY3RpdmF0ZU9uVHlwaW5nOiB0cnVlLFxuICAgICAgICAgICAgYWN0aXZhdGVPbkNvbXBsZXRpb246ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZ0RlbGF5OiAxMDAsXG4gICAgICAgICAgICBzZWxlY3RPbk9wZW46IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiB0cnVlLFxuICAgICAgICAgICAgbWF4UmVuZGVyZWRPcHRpb25zOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogW10sXG4gICAgICAgICAgICBwb3NpdGlvbkluZm86IGRlZmF1bHRQb3NpdGlvbkluZm8sXG4gICAgICAgICAgICBmaWx0ZXJTdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgY29tcGFyZUNvbXBsZXRpb25zOiAoYSwgYikgPT4gKGEuc29ydFRleHQgfHwgYS5sYWJlbCkubG9jYWxlQ29tcGFyZShiLnNvcnRUZXh0IHx8IGIubGFiZWwpLFxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EZWxheTogNzUsXG4gICAgICAgICAgICB1cGRhdGVTeW5jVGltZTogMTAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHRLZXltYXA6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIGljb25zOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiAoYSwgYikgPT4gYyA9PiBqb2luQ2xhc3MoYShjKSwgYihjKSksXG4gICAgICAgICAgICBvcHRpb25DbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgYWRkVG9PcHRpb25zOiAoYSwgYikgPT4gYS5jb25jYXQoYiksXG4gICAgICAgICAgICBmaWx0ZXJTdHJpY3Q6IChhLCBiKSA9PiBhIHx8IGIsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5mdW5jdGlvbiBkZWZhdWx0UG9zaXRpb25JbmZvKHZpZXcsIGxpc3QsIG9wdGlvbiwgaW5mbywgc3BhY2UsIHRvb2x0aXApIHtcbiAgICBsZXQgcnRsID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5SVEwsIGxlZnQgPSBydGwsIG5hcnJvdyA9IGZhbHNlO1xuICAgIGxldCBzaWRlID0gXCJ0b3BcIiwgb2Zmc2V0LCBtYXhXaWR0aDtcbiAgICBsZXQgc3BhY2VMZWZ0ID0gbGlzdC5sZWZ0IC0gc3BhY2UubGVmdCwgc3BhY2VSaWdodCA9IHNwYWNlLnJpZ2h0IC0gbGlzdC5yaWdodDtcbiAgICBsZXQgaW5mb1dpZHRoID0gaW5mby5yaWdodCAtIGluZm8ubGVmdCwgaW5mb0hlaWdodCA9IGluZm8uYm90dG9tIC0gaW5mby50b3A7XG4gICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgIGVsc2UgaWYgKCFsZWZ0ICYmIHNwYWNlUmlnaHQgPCBNYXRoLm1pbihpbmZvV2lkdGgsIHNwYWNlTGVmdCkpXG4gICAgICAgIGxlZnQgPSB0cnVlO1xuICAgIGlmIChpbmZvV2lkdGggPD0gKGxlZnQgPyBzcGFjZUxlZnQgOiBzcGFjZVJpZ2h0KSkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChzcGFjZS50b3AsIE1hdGgubWluKG9wdGlvbi50b3AsIHNwYWNlLmJvdHRvbSAtIGluZm9IZWlnaHQpKSAtIGxpc3QudG9wO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCBsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYXJyb3cgPSB0cnVlO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCAocnRsID8gbGlzdC5yaWdodCA6IHNwYWNlLnJpZ2h0IC0gbGlzdC5sZWZ0KSAtIDMwIC8qIEluZm8uTWFyZ2luICovKTtcbiAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBzcGFjZS5ib3R0b20gLSBsaXN0LmJvdHRvbTtcbiAgICAgICAgaWYgKHNwYWNlQmVsb3cgPj0gaW5mb0hlaWdodCB8fCBzcGFjZUJlbG93ID4gbGlzdC50b3ApIHsgLy8gQmVsb3cgdGhlIGNvbXBsZXRpb25cbiAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbi5ib3R0b20gLSBsaXN0LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQWJvdmUgaXRcbiAgICAgICAgICAgIHNpZGUgPSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbGlzdC5ib3R0b20gLSBvcHRpb24udG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzY2FsZVkgPSAobGlzdC5ib3R0b20gLSBsaXN0LnRvcCkgLyB0b29sdGlwLm9mZnNldEhlaWdodDtcbiAgICBsZXQgc2NhbGVYID0gKGxpc3QucmlnaHQgLSBsaXN0LmxlZnQpIC8gdG9vbHRpcC5vZmZzZXRXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogYCR7c2lkZX06ICR7b2Zmc2V0IC8gc2NhbGVZfXB4OyBtYXgtd2lkdGg6ICR7bWF4V2lkdGggLyBzY2FsZVh9cHhgLFxuICAgICAgICBjbGFzczogXCJjbS1jb21wbGV0aW9uSW5mby1cIiArIChuYXJyb3cgPyAocnRsID8gXCJsZWZ0LW5hcnJvd1wiIDogXCJyaWdodC1uYXJyb3dcIikgOiBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uQ29udGVudChjb25maWcpIHtcbiAgICBsZXQgY29udGVudCA9IGNvbmZpZy5hZGRUb09wdGlvbnMuc2xpY2UoKTtcbiAgICBpZiAoY29uZmlnLmljb25zKVxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkljb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb24udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKC4uLmNvbXBsZXRpb24udHlwZS5zcGxpdCgvXFxzKy9nKS5tYXAoY2xzID0+IFwiY20tY29tcGxldGlvbkljb24tXCIgKyBjbHMpKTtcbiAgICAgICAgICAgICAgICBpY29uLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogMjBcbiAgICAgICAgfSk7XG4gICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24sIF9zLCBfdiwgbWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcbiAgICAgICAgICAgIGxldCBsYWJlbCA9IGNvbXBsZXRpb24uZGlzcGxheUxhYmVsIHx8IGNvbXBsZXRpb24ubGFiZWwsIG9mZiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IG1hdGNoW2orK10sIHRvID0gbWF0Y2hbaisrXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IG9mZilcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmLCBmcm9tKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzcGFuID0gbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2UoZnJvbSwgdG8pKSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiO1xuICAgICAgICAgICAgICAgIG9mZiA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZiA8IGxhYmVsLmxlbmd0aClcbiAgICAgICAgICAgICAgICBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShvZmYpKSk7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA1MFxuICAgIH0sIHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgIGlmICghY29tcGxldGlvbi5kZXRhaWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgZGV0YWlsRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBkZXRhaWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uRGV0YWlsXCI7XG4gICAgICAgICAgICBkZXRhaWxFbHQudGV4dENvbnRlbnQgPSBjb21wbGV0aW9uLmRldGFpbDtcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA4MFxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50LnNvcnQoKGEsIGIpID0+IGEucG9zaXRpb24gLSBiLnBvc2l0aW9uKS5tYXAoYSA9PiBhLnJlbmRlcik7XG59XG5mdW5jdGlvbiByYW5nZUFyb3VuZFNlbGVjdGVkKHRvdGFsLCBzZWxlY3RlZCwgbWF4KSB7XG4gICAgaWYgKHRvdGFsIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogMCwgdG86IHRvdGFsIH07XG4gICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgc2VsZWN0ZWQgPSAwO1xuICAgIGlmIChzZWxlY3RlZCA8PSAodG90YWwgPj4gMSkpIHtcbiAgICAgICAgbGV0IG9mZiA9IE1hdGguZmxvb3Ioc2VsZWN0ZWQgLyBtYXgpO1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmYgKiBtYXgsIHRvOiAob2ZmICsgMSkgKiBtYXggfTtcbiAgICB9XG4gICAgbGV0IG9mZiA9IE1hdGguZmxvb3IoKHRvdGFsIC0gc2VsZWN0ZWQpIC8gbWF4KTtcbiAgICByZXR1cm4geyBmcm9tOiB0b3RhbCAtIChvZmYgKyAxKSAqIG1heCwgdG86IHRvdGFsIC0gb2ZmICogbWF4IH07XG59XG5jbGFzcyBDb21wbGV0aW9uVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhdGVGaWVsZCwgYXBwbHlDb21wbGV0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XG4gICAgICAgIHRoaXMuYXBwbHlDb21wbGV0aW9uID0gYXBwbHlDb21wbGV0aW9uO1xuICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmluZm9EZXN0cm95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGFjZUluZm9SZXEgPSB7XG4gICAgICAgICAgICByZWFkOiAoKSA9PiB0aGlzLm1lYXN1cmVJbmZvKCksXG4gICAgICAgICAgICB3cml0ZTogKHBvcykgPT4gdGhpcy5wbGFjZUluZm8ocG9zKSxcbiAgICAgICAgICAgIGtleTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3MgPSBcIlwiO1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgc2VsZWN0ZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25Db250ZW50ID0gb3B0aW9uQ29udGVudChjb25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbkNsYXNzID0gY29uZmlnLm9wdGlvbkNsYXNzO1xuICAgICAgICB0aGlzLnRvb2x0aXBDbGFzcyA9IGNvbmZpZy50b29sdGlwQ2xhc3M7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKS5vcGVuO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tID0gZS50YXJnZXQsIG1hdGNoOyBkb20gJiYgZG9tICE9IHRoaXMuZG9tOyBkb20gPSBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJMSVwiICYmIChtYXRjaCA9IC8tKFxcZCspJC8uZXhlYyhkb20uaWQpKSAmJiArbWF0Y2hbMV0gPCBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb25zWyttYXRjaFsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNsb3NlT25CbHVyICYmXG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgIH1cbiAgICBtb3VudCgpIHsgdGhpcy51cGRhdGVTZWwoKTsgfVxuICAgIHNob3dPcHRpb25zKG9wdGlvbnMsIGlkKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3QpXG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICBsZXQgcHJldlN0YXRlID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3ModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGNTdGF0ZSAhPSBwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkLCBkaXNhYmxlZCB9ID0gY1N0YXRlLm9wZW47XG4gICAgICAgICAgICBpZiAoIXByZXZTdGF0ZS5vcGVuIHx8IHByZXZTdGF0ZS5vcGVuLm9wdGlvbnMgIT0gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgdXBkYXRlLnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWwoKTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCAhPSAoKF9hID0gcHJldlN0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkXCIsICEhZGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVRvb2x0aXBDbGFzcyhzdGF0ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy50b29sdGlwQ2xhc3Moc3RhdGUpO1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY3VycmVudENsYXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuY3VycmVudENsYXNzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2xzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsKCkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCksIG9wZW4gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgaWYgKG9wZW4uc2VsZWN0ZWQgPiAtMSAmJiBvcGVuLnNlbGVjdGVkIDwgdGhpcy5yYW5nZS5mcm9tIHx8IG9wZW4uc2VsZWN0ZWQgPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlQXJvdW5kU2VsZWN0ZWQob3Blbi5vcHRpb25zLmxlbmd0aCwgb3Blbi5zZWxlY3RlZCwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNob3dPcHRpb25zKG9wZW4ub3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3U2VsID0gdGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihvcGVuLnNlbGVjdGVkKTtcbiAgICAgICAgaWYgKG5ld1NlbCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiB9ID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgbGV0IHsgaW5mbyB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaW5mb1Jlc3VsdCA9IHR5cGVvZiBpbmZvID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaW5mbykgOiBpbmZvKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKCFpbmZvUmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChcInRoZW5cIiBpbiBpbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW5mb1Jlc3VsdC50aGVuKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpID09IGNTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUob2JqLCBjb21wbGV0aW9uKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUoaW5mb1Jlc3VsdCwgY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgbmV3U2VsLnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgdGhpcy5pbmZvLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRJbmZvUGFuZShjb250ZW50LCBjb21wbGV0aW9uKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICAgICAgbGV0IHdyYXAgPSB0aGlzLmluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB3cmFwLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mb1wiO1xuICAgICAgICB3cmFwLmlkID0gXCJjbS1jb21wbGV0aW9uSW5mby1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoY29udGVudC5ub2RlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBkb20sIGRlc3Ryb3kgfSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICB0aGlzLmluZm9EZXN0cm95ID0gZGVzdHJveSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHdyYXApO1xuICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgIH1cbiAgICB1cGRhdGVTZWxlY3RlZE9wdGlvbihzZWxlY3RlZCkge1xuICAgICAgICBsZXQgc2V0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgb3B0ID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQsIGkgPSB0aGlzLnJhbmdlLmZyb207IG9wdDsgb3B0ID0gb3B0Lm5leHRTaWJsaW5nLCBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcHQubm9kZU5hbWUgIT0gXCJMSVwiIHx8ICFvcHQuaWQpIHtcbiAgICAgICAgICAgICAgICBpLS07IC8vIEEgc2VjdGlvbiBoZWFkZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3B0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgbGV0IGRvY0VsdCA9IHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgc3BhY2UgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IGRvY0VsdC5jbGllbnRXaWR0aCwgYm90dG9tOiBkb2NFbHQuY2xpZW50SGVpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbFJlY3QudG9wID4gTWF0aC5taW4oc3BhY2UuYm90dG9tLCBsaXN0UmVjdC5ib3R0b20pIC0gMTAgfHxcbiAgICAgICAgICAgIHNlbFJlY3QuYm90dG9tIDwgTWF0aC5tYXgoc3BhY2UudG9wLCBsaXN0UmVjdC50b3ApICsgMTApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5wb3NpdGlvbkluZm8odGhpcy52aWV3LCBsaXN0UmVjdCwgc2VsUmVjdCwgaW5mb1JlY3QsIHNwYWNlLCB0aGlzLmRvbSk7XG4gICAgfVxuICAgIHBsYWNlSW5mbyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChwb3Muc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gcG9zLnN0eWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm8gXCIgKyAocG9zLmNsYXNzIHx8IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLmNzc1RleHQgPSBcInRvcDogLTFlNnB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgcmFuZ2UpIHtcbiAgICAgICAgY29uc3QgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIHVsLmlkID0gaWQ7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiQ29tcGxldGlvbnNcIikpO1xuICAgICAgICB1bC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgICAgICAgICAgLy8gUHJldmVudCBmb2N1cyBjaGFuZ2Ugd2hlbiBjbGlja2luZyB0aGUgc2Nyb2xsYmFyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT0gdWwpXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGN1clNlY3Rpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8IHJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24sIG1hdGNoIH0gPSBvcHRpb25zW2ldLCB7IHNlY3Rpb24gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gY3VyU2VjdGlvbiAmJiAoaSA+IHJhbmdlLmZyb20gfHwgcmFuZ2UuZnJvbSA9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJTZWN0aW9uID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWN0aW9uICE9IFwic3RyaW5nXCIgJiYgc2VjdGlvbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVsLmFwcGVuZENoaWxkKHNlY3Rpb24uaGVhZGVyKHNlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29tcGxldGlvbi1zZWN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaSA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICBsaS5pZCA9IGlkICsgXCItXCIgKyBpO1xuICAgICAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGxldCBjbHMgPSB0aGlzLm9wdGlvbkNsYXNzKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBsaS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdGhpcy5vcHRpb25Db250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBzb3VyY2UoY29tcGxldGlvbiwgdGhpcy52aWV3LnN0YXRlLCB0aGlzLnZpZXcsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG4gICAgZGVzdHJveUluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9EZXN0cm95KVxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBsZXRpb25Ub29sdGlwKHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2NhbGVZID0gcGFyZW50LmhlaWdodCAvIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNlbGYudG9wIDwgcGFyZW50LnRvcClcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSAocGFyZW50LnRvcCAtIHNlbGYudG9wKSAvIHNjYWxlWTtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gKHNlbGYuYm90dG9tIC0gcGFyZW50LmJvdHRvbSkgLyBzY2FsZVk7XG59XG5cbi8vIFVzZWQgdG8gcGljayBhIHByZWZlcnJlZCBvcHRpb24gd2hlbiB0d28gb3B0aW9ucyB3aXRoIHRoZSBzYW1lXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gc2NvcmUob3B0aW9uKSB7XG4gICAgcmV0dXJuIChvcHRpb24uYm9vc3QgfHwgMCkgKiAxMDAgKyAob3B0aW9uLmFwcGx5ID8gMTAgOiAwKSArIChvcHRpb24uaW5mbyA/IDUgOiAwKSArXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGxldCBzZWN0aW9ucyA9IG51bGwsIGR5bmFtaWNTZWN0aW9uU2NvcmUgPSBudWxsO1xuICAgIGxldCBhZGRPcHRpb24gPSAob3B0aW9uKSA9PiB7XG4gICAgICAgIG9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgICBsZXQgeyBzZWN0aW9uIH0gPSBvcHRpb24uY29tcGxldGlvbjtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghc2VjdGlvbnMpXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICBpZiAoIXNlY3Rpb25zLnNvbWUocyA9PiBzLm5hbWUgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8geyBuYW1lIH0gOiBzZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICBmb3IgKGxldCBhIG9mIGFjdGl2ZSlcbiAgICAgICAgaWYgKGEuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgIGxldCBnZXRNYXRjaCA9IGEucmVzdWx0LmdldE1hdGNoO1xuICAgICAgICAgICAgaWYgKGEucmVzdWx0LmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcHRpb24obmV3IE9wdGlvbihvcHRpb24sIGEuc291cmNlLCBnZXRNYXRjaCA/IGdldE1hdGNoKG9wdGlvbikgOiBbXSwgMWU5IC0gb3B0aW9ucy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IHN0YXRlLnNsaWNlRG9jKGEuZnJvbSwgYS50byksIG1hdGNoO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVyID0gY29uZi5maWx0ZXJTdHJpY3QgPyBuZXcgU3RyaWN0TWF0Y2hlcihwYXR0ZXJuKSA6IG5ldyBGdXp6eU1hdGNoZXIocGF0dGVybik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IG1hdGNoZXIubWF0Y2gob3B0aW9uLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoZWQgPSAhb3B0aW9uLmRpc3BsYXlMYWJlbCA/IG1hdGNoLm1hdGNoZWQgOiBnZXRNYXRjaCA/IGdldE1hdGNoKG9wdGlvbiwgbWF0Y2gubWF0Y2hlZCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzY29yZSA9IG1hdGNoLnNjb3JlICsgKG9wdGlvbi5ib29zdCB8fCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGlvbihuZXcgT3B0aW9uKG9wdGlvbiwgYS5zb3VyY2UsIG1hdGNoZWQsIHNjb3JlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbi5zZWN0aW9uID09IFwib2JqZWN0XCIgJiYgb3B0aW9uLnNlY3Rpb24ucmFuayA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeyBuYW1lIH0gPSBvcHRpb24uc2VjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWR5bmFtaWNTZWN0aW9uU2NvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTZWN0aW9uU2NvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNTZWN0aW9uU2NvcmVbbmFtZV0gPSBNYXRoLm1heChzY29yZSwgZHluYW1pY1NlY3Rpb25TY29yZVtuYW1lXSB8fCAtMWU5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgaWYgKHNlY3Rpb25zKSB7XG4gICAgICAgIGxldCBzZWN0aW9uT3JkZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBwb3MgPSAwO1xuICAgICAgICBsZXQgY21wID0gKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoYS5yYW5rID09PSBcImR5bmFtaWNcIiAmJiBiLnJhbmsgPT09IFwiZHluYW1pY1wiID8gZHluYW1pY1NlY3Rpb25TY29yZVtiLm5hbWVdIC0gZHluYW1pY1NlY3Rpb25TY29yZVthLm5hbWVdIDogMCkgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGEucmFuayA9PSBcIm51bWJlclwiID8gYS5yYW5rIDogMWU5KSAtICh0eXBlb2YgYi5yYW5rID09IFwibnVtYmVyXCIgPyBiLnJhbmsgOiAxZTkpIHx8XG4gICAgICAgICAgICAgICAgKGEubmFtZSA8IGIubmFtZSA/IC0xIDogMSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IHMgb2Ygc2VjdGlvbnMuc29ydChjbXApKSB7XG4gICAgICAgICAgICBwb3MgLT0gMWU1O1xuICAgICAgICAgICAgc2VjdGlvbk9yZGVyW3MubmFtZV0gPSBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB7IHNlY3Rpb24gfSA9IG9wdGlvbi5jb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24pXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNjb3JlICs9IHNlY3Rpb25PcmRlclt0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8gc2VjdGlvbiA6IHNlY3Rpb24ubmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICBsZXQgY29tcGFyZSA9IGNvbmYuY29tcGFyZUNvbXBsZXRpb25zO1xuICAgIGZvciAobGV0IG9wdCBvZiBvcHRpb25zLnNvcnQoKGEsIGIpID0+IChiLnNjb3JlIC0gYS5zY29yZSkgfHwgY29tcGFyZShhLmNvbXBsZXRpb24sIGIuY29tcGxldGlvbikpKSB7XG4gICAgICAgIGxldCBjdXIgPSBvcHQuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKCFwcmV2IHx8IHByZXYubGFiZWwgIT0gY3VyLmxhYmVsIHx8IHByZXYuZGV0YWlsICE9IGN1ci5kZXRhaWwgfHxcbiAgICAgICAgICAgIChwcmV2LnR5cGUgIT0gbnVsbCAmJiBjdXIudHlwZSAhPSBudWxsICYmIHByZXYudHlwZSAhPSBjdXIudHlwZSkgfHxcbiAgICAgICAgICAgIHByZXYuYXBwbHkgIT0gY3VyLmFwcGx5IHx8IHByZXYuYm9vc3QgIT0gY3VyLmJvb3N0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0KTtcbiAgICAgICAgZWxzZSBpZiAoc2NvcmUob3B0LmNvbXBsZXRpb24pID4gc2NvcmUocHJldikpXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gb3B0O1xuICAgICAgICBwcmV2ID0gb3B0LmNvbXBsZXRpb247XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBDb21wbGV0aW9uRGlhbG9nIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhdHRycywgdG9vbHRpcCwgdGltZXN0YW1wLCBzZWxlY3RlZCwgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldFNlbGVjdGVkKHNlbGVjdGVkLCBpZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgPT0gdGhpcy5zZWxlY3RlZCB8fCBzZWxlY3RlZCA+PSB0aGlzLm9wdGlvbnMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCBzZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZChhY3RpdmUsIHN0YXRlLCBpZCwgcHJldiwgY29uZiwgZGlkU2V0QWN0aXZlKSB7XG4gICAgICAgIGlmIChwcmV2ICYmICFkaWRTZXRBY3RpdmUgJiYgYWN0aXZlLnNvbWUocyA9PiBzLmlzUGVuZGluZykpXG4gICAgICAgICAgICByZXR1cm4gcHJldi5zZXREaXNhYmxlZCgpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYgJiYgYWN0aXZlLnNvbWUoYSA9PiBhLmlzUGVuZGluZykgPyBwcmV2LnNldERpc2FibGVkKCkgOiBudWxsO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5zZWxlY3RPbk9wZW4gPyAwIDogLTE7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuc2VsZWN0ZWQgIT0gc2VsZWN0ZWQgJiYgcHJldi5zZWxlY3RlZCAhPSAtMSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWUgPSBwcmV2Lm9wdGlvbnNbcHJldi5zZWxlY3RlZF0uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1tpXS5jb21wbGV0aW9uID09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKG9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB7XG4gICAgICAgICAgICBwb3M6IGFjdGl2ZS5yZWR1Y2UoKGEsIGIpID0+IGIuaGFzUmVzdWx0KCkgPyBNYXRoLm1pbihhLCBiLmZyb20pIDogYSwgMWU4KSxcbiAgICAgICAgICAgIGNyZWF0ZTogY3JlYXRlVG9vbHRpcCxcbiAgICAgICAgICAgIGFib3ZlOiBjb25mLmFib3ZlQ3Vyc29yLFxuICAgICAgICB9LCBwcmV2ID8gcHJldi50aW1lc3RhbXAgOiBEYXRlLm5vdygpLCBzZWxlY3RlZCwgZmFsc2UpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCB7IC4uLnRoaXMudG9vbHRpcCwgcG9zOiBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvb2x0aXAucG9zKSB9LCB0aGlzLnRpbWVzdGFtcCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHNldERpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCB0aGlzLnNlbGVjdGVkLCB0cnVlKTtcbiAgICB9XG59XG5jbGFzcyBDb21wbGV0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgaWQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25TdGF0ZShub25lLCBcImNtLWFjLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMmU2KS50b1N0cmluZygzNiksIG51bGwpO1xuICAgIH1cbiAgICB1cGRhdGUodHIpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBzb3VyY2VzID0gY29uZi5vdmVycmlkZSB8fFxuICAgICAgICAgICAgc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJhdXRvY29tcGxldGVcIiwgY3VyKHN0YXRlKSkubWFwKGFzU291cmNlKTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmFjdGl2ZS5maW5kKHMgPT4gcy5zb3VyY2UgPT0gc291cmNlKSB8fFxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCB0aGlzLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCA9PSB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgYWN0aXZlLmV2ZXJ5KChhLCBpKSA9PiBhID09IHRoaXMuYWN0aXZlW2ldKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMub3BlbiwgZGlkU2V0ID0gdHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXRBY3RpdmVFZmZlY3QpKTtcbiAgICAgICAgaWYgKG9wZW4gJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIG9wZW4gPSBvcGVuLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbiB8fCBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoYS5mcm9tLCBhLnRvKSkgfHxcbiAgICAgICAgICAgICFzYW1lUmVzdWx0cyhhY3RpdmUsIHRoaXMuYWN0aXZlKSB8fCBkaWRTZXQpXG4gICAgICAgICAgICBvcGVuID0gQ29tcGxldGlvbkRpYWxvZy5idWlsZChhY3RpdmUsIHN0YXRlLCB0aGlzLmlkLCBvcGVuLCBjb25mLCBkaWRTZXQpO1xuICAgICAgICBlbHNlIGlmIChvcGVuICYmIG9wZW4uZGlzYWJsZWQgJiYgIWFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcpKVxuICAgICAgICAgICAgb3BlbiA9IG51bGw7XG4gICAgICAgIGlmICghb3BlbiAmJiBhY3RpdmUuZXZlcnkoYSA9PiAhYS5pc1BlbmRpbmcpICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSkpXG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUubWFwKGEgPT4gYS5oYXNSZXN1bHQoKSA/IG5ldyBBY3RpdmVTb3VyY2UoYS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogYSk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWxlY3RlZEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgb3BlbiA9IG9wZW4gJiYgb3Blbi5zZXRTZWxlY3RlZChlZmZlY3QudmFsdWUsIHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gYWN0aXZlID09IHRoaXMuYWN0aXZlICYmIG9wZW4gPT0gdGhpcy5vcGVuID8gdGhpcyA6IG5ldyBDb21wbGV0aW9uU3RhdGUoYWN0aXZlLCB0aGlzLmlkLCBvcGVuKTtcbiAgICB9XG4gICAgZ2V0IHRvb2x0aXAoKSB7IHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4udG9vbHRpcCA6IG51bGw7IH1cbiAgICBnZXQgYXR0cnMoKSB7IHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4uYXR0cnMgOiB0aGlzLmFjdGl2ZS5sZW5ndGggPyBiYXNlQXR0cnMgOiBub0F0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KCkpXG4gICAgICAgICAgICBpQSsrO1xuICAgICAgICB3aGlsZSAoaUIgPCBiLmxlbmd0aCAmJiAhYltpQl0uaGFzUmVzdWx0KCkpXG4gICAgICAgICAgICBpQisrO1xuICAgICAgICBsZXQgZW5kQSA9IGlBID09IGEubGVuZ3RoLCBlbmRCID0gaUIgPT0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRBIHx8IGVuZEIpXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xuICAgICAgICBpZiAoYVtpQSsrXS5yZXN1bHQgIT0gYltpQisrXS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgYmFzZUF0dHJzID0ge1xuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCJcbn07XG5jb25zdCBub0F0dHJzID0ge307XG5mdW5jdGlvbiBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcbiAgICB9O1xuICAgIGlmIChzZWxlY3RlZCA+IC0xKVxuICAgICAgICByZXN1bHRbXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIl0gPSBpZCArIFwiLVwiICsgc2VsZWN0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGdldFVwZGF0ZVR5cGUodHIsIGNvbmYpIHtcbiAgICBpZiAodHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSkge1xuICAgICAgICBsZXQgY29tcGxldGlvbiA9IHRyLmFubm90YXRpb24ocGlja2VkQ29tcGxldGlvbik7XG4gICAgICAgIGlmIChjb21wbGV0aW9uICYmIGNvbmYuYWN0aXZhdGVPbkNvbXBsZXRpb24oY29tcGxldGlvbikpXG4gICAgICAgICAgICByZXR1cm4gNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovIHwgOCAvKiBVcGRhdGVUeXBlLlJlc2V0ICovO1xuICAgIH1cbiAgICBsZXQgdHlwaW5nID0gdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpO1xuICAgIHJldHVybiB0eXBpbmcgJiYgY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovIHwgMSAvKiBVcGRhdGVUeXBlLlR5cGluZyAqL1xuICAgICAgICA6IHR5cGluZyA/IDEgLyogVXBkYXRlVHlwZS5UeXBpbmcgKi9cbiAgICAgICAgICAgIDogdHIuaXNVc2VyRXZlbnQoXCJkZWxldGUuYmFja3dhcmRcIikgPyAyIC8qIFVwZGF0ZVR5cGUuQmFja3NwYWNpbmcgKi9cbiAgICAgICAgICAgICAgICA6IHRyLnNlbGVjdGlvbiA/IDggLyogVXBkYXRlVHlwZS5SZXNldCAqL1xuICAgICAgICAgICAgICAgICAgICA6IHRyLmRvY0NoYW5nZWQgPyAxNiAvKiBVcGRhdGVUeXBlLlJlc2V0SWZUb3VjaGluZyAqLyA6IDAgLyogVXBkYXRlVHlwZS5Ob25lICovO1xufVxuY2xhc3MgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXRlLCBleHBsaWNpdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNQZW5kaW5nKCkgeyByZXR1cm4gdGhpcy5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi87IH1cbiAgICB1cGRhdGUodHIsIGNvbmYpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBnZXRVcGRhdGVUeXBlKHRyLCBjb25mKSwgdmFsdWUgPSB0aGlzO1xuICAgICAgICBpZiAoKHR5cGUgJiA4IC8qIFVwZGF0ZVR5cGUuUmVzZXQgKi8pIHx8ICh0eXBlICYgMTYgLyogVXBkYXRlVHlwZS5SZXNldElmVG91Y2hpbmcgKi8pICYmIHRoaXMudG91Y2hlcyh0cikpXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBBY3RpdmVTb3VyY2UodmFsdWUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgaWYgKCh0eXBlICYgNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovKSAmJiB2YWx1ZS5zdGF0ZSA9PSAwIC8qIFN0YXRlLkluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUZvcih0ciwgdHlwZSk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHVwZGF0ZUZvcih0ciwgdHlwZSkgeyByZXR1cm4gdGhpcy5tYXAodHIuY2hhbmdlcyk7IH1cbiAgICBtYXAoY2hhbmdlcykgeyByZXR1cm4gdGhpczsgfVxuICAgIHRvdWNoZXModHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGN1cih0ci5zdGF0ZSkpO1xuICAgIH1cbn1cbmNsYXNzIEFjdGl2ZVJlc3VsdCBleHRlbmRzIEFjdGl2ZVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBleHBsaWNpdCwgbGltaXQsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAzIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXQpO1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGhhc1Jlc3VsdCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB1cGRhdGVGb3IodHIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISh0eXBlICYgMyAvKiBVcGRhdGVUeXBlLlNpbXBsZUludGVyYWN0aW9uICovKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuICAgICAgICBpZiAocmVzdWx0Lm1hcCAmJiAhdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAocmVzdWx0LCB0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKHBvcyA+IHRvIHx8ICFyZXN1bHQgfHxcbiAgICAgICAgICAgICh0eXBlICYgMiAvKiBVcGRhdGVUeXBlLkJhY2tzcGFjaW5nICovKSAmJiAoY3VyKHRyLnN0YXJ0U3RhdGUpID09IHRoaXMuZnJvbSB8fCBwb3MgPCB0aGlzLmxpbWl0KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0eXBlICYgNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovID8gMSAvKiBTdGF0ZS5QZW5kaW5nICovIDogMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGxldCBsaW1pdCA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMubGltaXQpO1xuICAgICAgICBpZiAoY2hlY2tWYWxpZChyZXN1bHQudmFsaWRGb3IsIHRyLnN0YXRlLCBmcm9tLCB0bykpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdCwgbGltaXQsIHJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAocmVzdWx0LnVwZGF0ZSAmJlxuICAgICAgICAgICAgKHJlc3VsdCA9IHJlc3VsdC51cGRhdGUocmVzdWx0LCBmcm9tLCB0bywgbmV3IENvbXBsZXRpb25Db250ZXh0KHRyLnN0YXRlLCBwb3MsIGZhbHNlKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIHRoaXMuZXhwbGljaXQsIGxpbWl0LCByZXN1bHQsIHJlc3VsdC5mcm9tLCAoX2EgPSByZXN1bHQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCB0aGlzLmV4cGxpY2l0KTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVzdWx0Lm1hcCA/IHRoaXMucmVzdWx0Lm1hcCh0aGlzLnJlc3VsdCwgbWFwcGluZykgOiB0aGlzLnJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmxpbWl0KSwgdGhpcy5yZXN1bHQsIG1hcHBpbmcubWFwUG9zKHRoaXMuZnJvbSksIG1hcHBpbmcubWFwUG9zKHRoaXMudG8sIDEpKTtcbiAgICB9XG4gICAgdG91Y2hlcyh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHZhbGlkRm9yLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIXZhbGlkRm9yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWxpZEZvciA9PSBcImZ1bmN0aW9uXCIgPyB2YWxpZEZvcih0ZXh0LCBmcm9tLCB0bywgc3RhdGUpIDogZW5zdXJlQW5jaG9yKHZhbGlkRm9yLCB0cnVlKS50ZXN0KHRleHQpO1xufVxuY29uc3Qgc2V0QWN0aXZlRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHNvdXJjZXMsIG1hcHBpbmcpIHsgcmV0dXJuIHNvdXJjZXMubWFwKHMgPT4gcy5tYXAobWFwcGluZykpOyB9XG59KTtcbmNvbnN0IHNldFNlbGVjdGVkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY29tcGxldGlvblN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBDb21wbGV0aW9uU3RhdGUuc3RhcnQoKTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7IHJldHVybiB2YWx1ZS51cGRhdGUodHIpOyB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW1xuICAgICAgICBzaG93VG9vbHRpcC5mcm9tKGYsIHZhbCA9PiB2YWwudG9vbHRpcCksXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMuZnJvbShmLCBzdGF0ZSA9PiBzdGF0ZS5hdHRycylcbiAgICBdXG59KTtcbmZ1bmN0aW9uIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pIHtcbiAgICBjb25zdCBhcHBseSA9IG9wdGlvbi5jb21wbGV0aW9uLmFwcGx5IHx8IG9wdGlvbi5jb21wbGV0aW9uLmxhYmVsO1xuICAgIGxldCByZXN1bHQgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBvcHRpb24uc291cmNlKTtcbiAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBBY3RpdmVSZXN1bHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBhcHBseSA9PSBcInN0cmluZ1wiKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIC4uLmluc2VydENvbXBsZXRpb25UZXh0KHZpZXcuc3RhdGUsIGFwcGx5LCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKSxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBwaWNrZWRDb21wbGV0aW9uLm9mKG9wdGlvbi5jb21wbGV0aW9uKVxuICAgICAgICB9KTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGNyZWF0ZVRvb2x0aXAgPSAvKkBfX1BVUkVfXyovY29tcGxldGlvblRvb2x0aXAoY29tcGxldGlvblN0YXRlLCBhcHBseUNvbXBsZXRpb24pO1xuXG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgbW92ZXMgdGhlIGNvbXBsZXRpb24gc2VsZWN0aW9uIGZvcndhcmQgb3JcbmJhY2t3YXJkIGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4qL1xuZnVuY3Rpb24gbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZm9yd2FyZCwgYnkgPSBcIm9wdGlvblwiKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGVwID0gMSwgdG9vbHRpcDtcbiAgICAgICAgaWYgKGJ5ID09IFwicGFnZVwiICYmICh0b29sdGlwID0gZ2V0VG9vbHRpcCh2aWV3LCBjU3RhdGUub3Blbi50b29sdGlwKSkpXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcih0b29sdGlwLmRvbS5vZmZzZXRIZWlnaHQgL1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKS5vZmZzZXRIZWlnaHQpIC0gMSk7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gY1N0YXRlLm9wZW4ub3B0aW9ucztcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPiAtMSA/IGNTdGF0ZS5vcGVuLnNlbGVjdGVkICsgc3RlcCAqIChmb3J3YXJkID8gMSA6IC0xKSA6IGZvcndhcmQgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQgPj0gbGVuZ3RoKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VsZWN0ZWRFZmZlY3Qub2Yoc2VsZWN0ZWQpIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BY2NlcHQgdGhlIGN1cnJlbnQgY29tcGxldGlvbi5cbiovXG5jb25zdCBhY2NlcHRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSB8fCAhY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5zZWxlY3RlZCA8IDAgfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhcHBseUNvbXBsZXRpb24odmlldywgY1N0YXRlLm9wZW4ub3B0aW9uc1tjU3RhdGUub3Blbi5zZWxlY3RlZF0pO1xufTtcbi8qKlxuRXhwbGljaXRseSBzdGFydCBhdXRvY29tcGxldGlvbi5cbiovXG5jb25zdCBzdGFydENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZih0cnVlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgY2xvc2VDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY2xhc3MgUnVubmluZ1F1ZXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICAvLyBOb3RlIHRoYXQgJ3VuZGVmaW5lZCcgbWVhbnMgJ25vdCBkb25lIHlldCcsIHdoZXJlYXMgJ251bGwnIG1lYW5zXG4gICAgICAgIC8vICdxdWVyeSByZXR1cm5lZCBudWxsJy5cbiAgICAgICAgdGhpcy5kb25lID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IE1heFVwZGF0ZUNvdW50ID0gNTAsIE1pbkFib3J0VGltZSA9IDEwMDA7XG5jb25zdCBjb21wbGV0aW9uUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gW107XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLmlzUGVuZGluZylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgICAgICBpZiAoIXVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgIXVwZGF0ZS5kb2NDaGFuZ2VkICYmIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkgPT0gY1N0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9lc1Jlc2V0ID0gdXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gZ2V0VXBkYXRlVHlwZSh0ciwgY29uZik7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUgJiA4IC8qIFVwZGF0ZVR5cGUuUmVzZXQgKi8pIHx8ICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgISh0eXBlICYgMyAvKiBVcGRhdGVUeXBlLlNpbXBsZUludGVyYWN0aW9uICovKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAoZG9lc1Jlc2V0IHx8XG4gICAgICAgICAgICAgICAgcXVlcnkuY29udGV4dC5hYm9ydE9uRG9jQ2hhbmdlICYmIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5sZW5ndGggKyB1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aCA+IE1heFVwZGF0ZUNvdW50ICYmIERhdGUubm93KCkgLSBxdWVyeS50aW1lID4gTWluQWJvcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNvbnRleHQuYWJvcnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMucHVzaCguLi51cGRhdGUudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZVVwZGF0ZSA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VVcGRhdGUpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmVmZmVjdHMuc29tZShlID0+IGUuaXMoc3RhcnRDb21wbGV0aW9uRWZmZWN0KSkpKVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhcnQgPSB0cnVlO1xuICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLnBlbmRpbmdTdGFydCA/IDUwIDogY29uZi5hY3RpdmF0ZU9uVHlwaW5nRGVsYXk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLmlzUGVuZGluZyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUocSA9PiBxLmFjdGl2ZS5zb3VyY2UgPT0gYS5zb3VyY2UpKVxuICAgICAgICAgICAgPyBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRVcGRhdGUoKSwgZGVsYXkpIDogLTE7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyAhPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLylcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDIgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29tcG9zaW5nID09IDIgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkICovICYmIHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAzIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZEFuZE1vdmVkICovO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGFydCA9IGZhbHNlO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgY1N0YXRlLmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZS5pc1BlbmRpbmcgJiYgIXRoaXMucnVubmluZy5zb21lKHIgPT4gci5hY3RpdmUuc291cmNlID09IGFjdGl2ZS5zb3VyY2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShhY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcubGVuZ3RoICYmIGNTdGF0ZS5vcGVuICYmIGNTdGF0ZS5vcGVuLmRpc2FibGVkKVxuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnVwZGF0ZVN5bmNUaW1lKTtcbiAgICB9XG4gICAgc3RhcnRRdWVyeShhY3RpdmUpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgcG9zID0gY3VyKHN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgQ29tcGxldGlvbkNvbnRleHQoc3RhdGUsIHBvcywgYWN0aXZlLmV4cGxpY2l0LCB0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgcGVuZGluZyA9IG5ldyBSdW5uaW5nUXVlcnkoYWN0aXZlLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5ydW5uaW5nLnB1c2gocGVuZGluZyk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShhY3RpdmUuc291cmNlKGNvbnRleHQpKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoIXBlbmRpbmcuY29udGV4dC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZy5kb25lID0gcmVzdWx0IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUFjY2VwdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlQWNjZXB0KCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nLmV2ZXJ5KHEgPT4gcS5kb25lICE9PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWJvdW5jZUFjY2VwdCA8IDApXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjY2VwdCgpLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykudXBkYXRlU3luY1RpbWUpO1xuICAgIH1cbiAgICAvLyBGb3IgZWFjaCBmaW5pc2hlZCBxdWVyeSBpbiB0aGlzLnJ1bm5pbmcsIHRyeSB0byBjcmVhdGUgYSByZXN1bHRcbiAgICAvLyBvciwgaWYgYXBwcm9wcmlhdGUsIHJlc3RhcnQgdGhlIHF1ZXJ5LlxuICAgIGFjY2VwdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5kZWJvdW5jZUFjY2VwdCA+IC0xKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VBY2NlcHQpO1xuICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gLTE7XG4gICAgICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgICAgIGxldCBjb25mID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLCBjU3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBjdXIocXVlcnkudXBkYXRlcy5sZW5ndGggPyBxdWVyeS51cGRhdGVzWzBdLnN0YXJ0U3RhdGUgOiB0aGlzLnZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGxldCBsaW1pdCA9IE1hdGgubWluKHBvcywgcXVlcnkuZG9uZS5mcm9tICsgKHF1ZXJ5LmFjdGl2ZS5leHBsaWNpdCA/IDAgOiAxKSk7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVSZXN1bHQocXVlcnkuYWN0aXZlLnNvdXJjZSwgcXVlcnkuYWN0aXZlLmV4cGxpY2l0LCBsaW1pdCwgcXVlcnkuZG9uZSwgcXVlcnkuZG9uZS5mcm9tLCAoX2EgPSBxdWVyeS5kb25lLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3MpO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSB0aGUgdHJhbnNhY3Rpb25zIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgYW5kIHNlZSBpZiB0aGF0IHByZXNlcnZlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBjU3RhdGUuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBxdWVyeS5hY3RpdmUuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuaXNQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGZhaWxlZC4gU2hvdWxkIGNsZWFyIHRoZSBwZW5kaW5nIHN0YXR1cyBpZiBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBoYXNuJ3QgYmVlbiByZS1zZXQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNvdXJjZShxdWVyeS5hY3RpdmUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgcXVlcnkudXBkYXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS51cGRhdGUodHIsIGNvbmYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZS5pc1BlbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyZWQgYnkgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMuIFJlc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoIHx8IGNTdGF0ZS5vcGVuICYmIGNTdGF0ZS5vcGVuLmRpc2FibGVkKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0QWN0aXZlRWZmZWN0Lm9mKHVwZGF0ZWQpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGJsdXIoZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b29sdGlwICYmIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1cikge1xuICAgICAgICAgICAgICAgIGxldCBkaWFsb2cgPSBzdGF0ZS5vcGVuICYmIGdldFRvb2x0aXAodGhpcy52aWV3LCBzdGF0ZS5vcGVuLnRvb2x0aXApO1xuICAgICAgICAgICAgICAgIGlmICghZGlhbG9nIHx8ICFkaWFsb2cuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbnN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAxIC8qIENvbXBvc2l0aW9uU3RhdGUuU3RhcnRlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPT0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBjb21wb3NpdGlvbmVuZCBldmVudHMgc3luY2hyb25vdXNseSwgcG9zc2libHlcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGluc2lkZSBhbiB1cGRhdGUsIHNvIGRpc3BhdGNoIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZihmYWxzZSkgfSksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IHdpbmRvd3MgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgLypAX19QVVJFX18qLy9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IGNvbW1pdENoYXJhY3RlcnMgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFmaWVsZCB8fCAhZmllbGQub3BlbiB8fCBmaWVsZC5vcGVuLmRpc2FibGVkIHx8IGZpZWxkLm9wZW4uc2VsZWN0ZWQgPCAwIHx8XG4gICAgICAgICAgICBldmVudC5rZXkubGVuZ3RoID4gMSB8fCBldmVudC5jdHJsS2V5ICYmICEod2luZG93cyAmJiBldmVudC5hbHRLZXkpIHx8IGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBvcHRpb24gPSBmaWVsZC5vcGVuLm9wdGlvbnNbZmllbGQub3Blbi5zZWxlY3RlZF07XG4gICAgICAgIGxldCByZXN1bHQgPSBmaWVsZC5hY3RpdmUuZmluZChhID0+IGEuc291cmNlID09IG9wdGlvbi5zb3VyY2UpO1xuICAgICAgICBsZXQgY29tbWl0Q2hhcnMgPSBvcHRpb24uY29tcGxldGlvbi5jb21taXRDaGFyYWN0ZXJzIHx8IHJlc3VsdC5yZXN1bHQuY29tbWl0Q2hhcmFjdGVycztcbiAgICAgICAgaWYgKGNvbW1pdENoYXJzICYmIGNvbW1pdENoYXJzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xKVxuICAgICAgICAgICAgYXBwbHlDb21wbGV0aW9uKHZpZXcsIG9wdGlvbik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiOiB7XG4gICAgICAgIFwiJiA+IHVsXCI6IHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuIGF1dG9cIixcbiAgICAgICAgICAgIG1heFdpZHRoX2ZhbGxiYWNrOiBcIjcwMHB4XCIsXG4gICAgICAgICAgICBtYXhXaWR0aDogXCJtaW4oNzAwcHgsIDk1dncpXCIsXG4gICAgICAgICAgICBtaW5XaWR0aDogXCIyNTBweFwiLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwZW1cIixcbiAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIFwiJiA+IGxpLCAmID4gY29tcGxldGlvbi1zZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjFweCAzcHhcIixcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBsaVwiOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwibGlzdC1pdGVtXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMxN2NcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNDQ0XCIsXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcbiAgICAgICAgY29udGVudDogJ1wiwrfCt8K3XCInLFxuICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLmNtLWNvbXBsZXRpb25JbmZvXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgcGFkZGluZzogXCIzcHggOXB4XCIsXG4gICAgICAgIHdpZHRoOiBcIm1heC1jb250ZW50XCIsXG4gICAgICAgIG1heFdpZHRoOiBgJHs0MDAgLyogSW5mby5XaWR0aCAqL31weGAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLWxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdFwiOiB7IHJpZ2h0OiBcIjEwMCVcIiB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0XCI6IHsgbGVmdDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1sZWZ0LW5hcnJvd1wiOiB7IHJpZ2h0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodC1uYXJyb3dcIjogeyBsZWZ0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIiZsaWdodCAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMDAwMDAyMlwiIH0sXG4gICAgXCImZGFyayAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmZmYyMlwiIH0sXG4gICAgXCIuY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IFwiMS4xNWVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIC0wLjdweCAtLjdlbVwiLFxuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuNHB4IGRvdHRlZCAjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiOiB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uRGV0YWlsXCI6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiOTAlXCIsXG4gICAgICAgIHdpZHRoOiBcIi44ZW1cIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IFwiLjZlbVwiLFxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiLFxuICAgICAgICBib3hTaXppbmc6IFwiY29udGVudC1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifGkidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXiydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4wnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGlJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2QtidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4oiqJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4pahJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwn5SRXFx1RkUwRSdcIiB9IC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ2FiYydcIiwgZm9udFNpemU6IFwiNTAlXCIsIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIgfVxuICAgIH1cbn0pO1xuXG5jbGFzcyBGaWVsZFBvcyB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmNsYXNzIEZpZWxkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20sIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgbGV0IHRvID0gY2hhbmdlcy5tYXBQb3ModGhpcy50bywgMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIHJldHVybiBmcm9tID09IG51bGwgfHwgdG8gPT0gbnVsbCA/IG51bGwgOiBuZXcgRmllbGRSYW5nZSh0aGlzLmZpZWxkLCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIGZpZWxkUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5maWVsZFBvc2l0aW9ucyA9IGZpZWxkUG9zaXRpb25zO1xuICAgIH1cbiAgICBpbnN0YW50aWF0ZShzdGF0ZSwgcG9zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW10sIGxpbmVTdGFydCA9IFtwb3NdO1xuICAgICAgICBsZXQgbGluZU9iaiA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmFzZUluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lT2JqLnRleHQpWzBdO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSBiYXNlSW5kZW50LCB0YWJzID0gL15cXHQqLy5leGVjKGxpbmUpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydC5wdXNoKHBvcyArIGluZGVudC5sZW5ndGggLSB0YWJzKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gaW5kZW50ICsgbGluZS5zbGljZSh0YWJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMuZmllbGRQb3NpdGlvbnMubWFwKHBvcyA9PiBuZXcgRmllbGRSYW5nZShwb3MuZmllbGQsIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MuZnJvbSwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy50bykpO1xuICAgICAgICByZXR1cm4geyB0ZXh0LCByYW5nZXMgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVzID0gW10sIHBvc2l0aW9ucyA9IFtdLCBtO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRlbXBsYXRlLnNwbGl0KC9cXHJcXG4/fFxcbi8pKSB7XG4gICAgICAgICAgICB3aGlsZSAobSA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXnt9XSopKT98KCg/OlxcXFxbe31dfFtee31dKSopKVxcfS8uZXhlYyhsaW5lKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZXEgPSBtWzFdID8gK21bMV0gOiBudWxsLCByYXdOYW1lID0gbVsyXSB8fCBtWzNdIHx8IFwiXCIsIGZvdW5kID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSByYXdOYW1lLnJlcGxhY2UoL1xcXFxbe31dL2csIG0gPT4gbVsxXSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSAhPSBudWxsID8gZmllbGRzW2ldLnNlcSA9PSBzZXEgOiBuYW1lID8gZmllbGRzW2ldLm5hbWUgPT0gbmFtZSA6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoICYmIChzZXEgPT0gbnVsbCB8fCAoZmllbGRzW2ldLnNlcSAhPSBudWxsICYmIGZpZWxkc1tpXS5zZXEgPCBzZXEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNwbGljZShpLCAwLCB7IHNlcSwgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5maWVsZCA+PSBmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuZmllbGQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5saW5lID09IGxpbmVzLmxlbmd0aCAmJiBwb3MuZnJvbSA+IG0uaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzbmlwID0gbVsyXSA/IDMgKyAobVsxXSB8fCBcIlwiKS5sZW5ndGggOiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZyb20gLT0gc25pcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50byAtPSBzbmlwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IEZpZWxkUG9zKGZvdW5kLCBsaW5lcy5sZW5ndGgsIG0uaW5kZXgsIG0uaW5kZXggKyBuYW1lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG0uaW5kZXgpICsgcmF3TmFtZSArIGxpbmUuc2xpY2UobS5pbmRleCArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xcXFwoW3t9XSkvZywgKF8sIGJyYWNlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubGluZSA9PSBsaW5lcy5sZW5ndGggJiYgcG9zLmZyb20gPiBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZyb20tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50by0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyYWNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU25pcHBldChsaW5lcywgcG9zaXRpb25zKTtcbiAgICB9XG59XG5sZXQgZmllbGRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00oKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSB9KTtcbmxldCBmaWVsZFJhbmdlID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNuaXBwZXRGaWVsZFwiIH0pO1xuY2xhc3MgQWN0aXZlU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2VzLCBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmRlY28gPSBEZWNvcmF0aW9uLnNldChyYW5nZXMubWFwKHIgPT4gKHIuZnJvbSA9PSByLnRvID8gZmllbGRNYXJrZXIgOiBmaWVsZFJhbmdlKS5yYW5nZShyLmZyb20sIHIudG8pKSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHIubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCFtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIHRoaXMuYWN0aXZlKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uSW5zaWRlRmllbGQoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwucmFuZ2VzLmV2ZXJ5KHJhbmdlID0+IHRoaXMucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IHRoaXMuYWN0aXZlICYmIHIuZnJvbSA8PSByYW5nZS5mcm9tICYmIHIudG8gPj0gcmFuZ2UudG8pKTtcbiAgICB9XG59XG5jb25zdCBzZXRBY3RpdmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIGNoYW5nZXMpIHsgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm1hcChjaGFuZ2VzKTsgfVxufSk7XG5jb25zdCBtb3ZlVG9GaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNuaXBwZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMobW92ZVRvRmllbGQpICYmIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldCh2YWx1ZS5yYW5nZXMsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLnNlbGVjdGlvbiAmJiAhdmFsdWUuc2VsZWN0aW9uSW5zaWRlRmllbGQodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgdmFsID0+IHZhbCA/IHZhbC5kZWNvIDogRGVjb3JhdGlvbi5ub25lKVxufSk7XG5mdW5jdGlvbiBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIGZpZWxkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmZpbHRlcihyID0+IHIuZmllbGQgPT0gZmllbGQpLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSk7XG59XG4vKipcbkNvbnZlcnQgYSBzbmlwcGV0IHRlbXBsYXRlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW5cblthcHBseV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbi5hcHBseSkgaXQuIFNuaXBwZXRzIGFyZSB3cml0dGVuXG51c2luZyBzeW50YXggbGlrZSB0aGlzOlxuXG4gICAgXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtlbmR9OyAke2luZGV4fSsrKSB7XFxuXFx0JHt9XFxufVwiXG5cbkVhY2ggYCR7fWAgcGxhY2Vob2xkZXIgKHlvdSBtYXkgYWxzbyB1c2UgYCN7fWApIGluZGljYXRlcyBhIGZpZWxkXG50aGF0IHRoZSB1c2VyIGNhbiBmaWxsIGluLiBJdHMgbmFtZSwgaWYgYW55LCB3aWxsIGJlIHRoZSBkZWZhdWx0XG5jb250ZW50IGZvciB0aGUgZmllbGQuXG5cbldoZW4gdGhlIHNuaXBwZXQgaXMgYWN0aXZhdGVkIGJ5IGNhbGxpbmcgdGhlIHJldHVybmVkIGZ1bmN0aW9uLFxudGhlIGNvZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBOZXdsaW5lcyBpbiB0aGVcbnRlbXBsYXRlIGFyZSBpbmRlbnRlZCBieSB0aGUgaW5kZW50YXRpb24gb2YgdGhlIHN0YXJ0IGxpbmUsIHBsdXNcbm9uZSBbaW5kZW50IHVuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgcGVyIHRhYiBjaGFyYWN0ZXIgYWZ0ZXJcbnRoZSBuZXdsaW5lLlxuXG5PbiBhY3RpdmF0aW9uLCAoYWxsIGluc3RhbmNlcyBvZikgdGhlIGZpcnN0IGZpZWxkIGFyZSBzZWxlY3RlZC5cblRoZSB1c2VyIGNhbiBtb3ZlIGJldHdlZW4gZmllbGRzIHdpdGggVGFiIGFuZCBTaGlmdC1UYWIgYXMgbG9uZyBhc1xudGhlIGZpZWxkcyBhcmUgYWN0aXZlLiBNb3ZpbmcgdG8gdGhlIGxhc3QgZmllbGQgb3IgbW92aW5nIHRoZVxuY3Vyc29yIG91dCBvZiB0aGUgY3VycmVudCBmaWVsZCBkZWFjdGl2YXRlcyB0aGUgZmllbGRzLlxuXG5UaGUgb3JkZXIgb2YgZmllbGRzIGRlZmF1bHRzIHRvIHRleHR1YWwgb3JkZXIsIGJ1dCB5b3UgY2FuIGFkZFxubnVtYmVycyB0byBwbGFjZWhvbGRlcnMgKGAkezF9YCBvciBgJHsxOmRlZmF1bHRUZXh0fWApIHRvIHByb3ZpZGVcbmEgY3VzdG9tIG9yZGVyLlxuXG5UbyBpbmNsdWRlIGEgbGl0ZXJhbCBge2Agb3IgYH1gIGluIHlvdXIgdGVtcGxhdGUsIHB1dCBhIGJhY2tzbGFzaFxuaW4gZnJvbnQgb2YgaXQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgYnJhY2Ugd2lsbCBub3QgYmVcbmludGVycHJldGVkIGFzIGluZGljYXRpbmcgYSBwbGFjZWhvbGRlci5cbiovXG5mdW5jdGlvbiBzbmlwcGV0KHRlbXBsYXRlKSB7XG4gICAgbGV0IHNuaXBwZXQgPSBTbmlwcGV0LnBhcnNlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gKGVkaXRvciwgY29tcGxldGlvbiwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgbGV0IHsgdGV4dCwgcmFuZ2VzIH0gPSBzbmlwcGV0Lmluc3RhbnRpYXRlKGVkaXRvci5zdGF0ZSwgZnJvbSk7XG4gICAgICAgIGxldCB7IG1haW4gfSA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCBzcGVjID0ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tLCB0bzogdG8gPT0gbWFpbi5mcm9tID8gbWFpbi50byA6IHRvLCBpbnNlcnQ6IFRleHQub2YodGV4dCkgfSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGNvbXBsZXRpb24gPyBbcGlja2VkQ29tcGxldGlvbi5vZihjb21wbGV0aW9uKSwgVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKFwiaW5wdXQuY29tcGxldGVcIildIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYy5zZWxlY3Rpb24gPSBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIDApO1xuICAgICAgICBpZiAocmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gMCkpIHtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIDApO1xuICAgICAgICAgICAgbGV0IGVmZmVjdHMgPSBzcGVjLmVmZmVjdHMgPSBbc2V0QWN0aXZlLm9mKGFjdGl2ZSldO1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW3NuaXBwZXRTdGF0ZSwgYWRkU25pcHBldEtleW1hcCwgc25pcHBldFBvaW50ZXJIYW5kbGVyLCBiYXNlVGhlbWVdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGVkaXRvci5zdGF0ZS51cGRhdGUoc3BlYykpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtb3ZlRmllbGQoZGlyKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFhY3RpdmUgfHwgZGlyIDwgMCAmJiBhY3RpdmUuYWN0aXZlID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBuZXh0ID0gYWN0aXZlLmFjdGl2ZSArIGRpciwgbGFzdCA9IGRpciA+IDAgJiYgIWFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gbmV4dCArIGRpcik7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG5leHQpLFxuICAgICAgICAgICAgZWZmZWN0czogc2V0QWN0aXZlLm9mKGxhc3QgPyBudWxsIDogbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbmV4dCkpLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BIGNvbW1hbmQgdGhhdCBjbGVhcnMgdGhlIGFjdGl2ZSBzbmlwcGV0LCBpZiBhbnkuXG4qL1xuY29uc3QgY2xlYXJTbmlwcGV0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBlZmZlY3RzOiBzZXRBY3RpdmUub2YobnVsbCkgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0byB0aGUgbmV4dCBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgbmV4dFNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoMSk7XG4vKipcbk1vdmUgdG8gdGhlIHByZXZpb3VzIHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBwcmV2U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgtMSk7XG4vKipcbkNoZWNrIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzbmlwcGV0IHdpdGggYSBuZXh0IGZpZWxkIGZvclxuYG5leHRTbmlwcGV0RmllbGRgIHRvIG1vdmUgdG8uXG4qL1xuZnVuY3Rpb24gaGFzTmV4dFNuaXBwZXRGaWVsZChzdGF0ZSkge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gISEoYWN0aXZlICYmIGFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSArIDEpKTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzbmlwcGV0IGFuZCBhIHByZXZpb3VzIGZpZWxkXG5mb3IgYHByZXZTbmlwcGV0RmllbGRgIHRvIG1vdmUgdG8uXG4qL1xuZnVuY3Rpb24gaGFzUHJldlNuaXBwZXRGaWVsZChzdGF0ZSkge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gISEoYWN0aXZlICYmIGFjdGl2ZS5hY3RpdmUgPiAwKTtcbn1cbmNvbnN0IGRlZmF1bHRTbmlwcGV0S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIlRhYlwiLCBydW46IG5leHRTbmlwcGV0RmllbGQsIHNoaWZ0OiBwcmV2U25pcHBldEZpZWxkIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xlYXJTbmlwcGV0IH1cbl07XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgdGhlIGtleSBiaW5kaW5ncyB1c2VkIGJ5XG5zbmlwcGV0cy4gVGhlIGRlZmF1bHQgYmluZHMgVGFiIHRvXG5bYG5leHRTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5uZXh0U25pcHBldEZpZWxkKSwgU2hpZnQtVGFiIHRvXG5bYHByZXZTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5wcmV2U25pcHBldEZpZWxkKSwgYW5kIEVzY2FwZVxudG8gW2BjbGVhclNuaXBwZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbGVhclNuaXBwZXQpLlxuKi9cbmNvbnN0IHNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKG1hcHMpIHsgcmV0dXJuIG1hcHMubGVuZ3RoID8gbWFwc1swXSA6IGRlZmF1bHRTbmlwcGV0S2V5bWFwOyB9XG59KTtcbmNvbnN0IGFkZFNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZShbc25pcHBldEtleW1hcF0sIHN0YXRlID0+IHN0YXRlLmZhY2V0KHNuaXBwZXRLZXltYXApKSk7XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gZnJvbSBhIHNuaXBwZXQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlXG5wcm9wZXJ0aWVzIGZyb20gYGNvbXBsZXRpb25gLCBwbHVzIGFuIGBhcHBseWAgZnVuY3Rpb24gdGhhdFxuYXBwbGllcyB0aGUgc25pcHBldC5cbiovXG5mdW5jdGlvbiBzbmlwcGV0Q29tcGxldGlvbih0ZW1wbGF0ZSwgY29tcGxldGlvbikge1xuICAgIHJldHVybiB7IC4uLmNvbXBsZXRpb24sIGFwcGx5OiBzbmlwcGV0KHRlbXBsYXRlKSB9O1xufVxuY29uc3Qgc25pcHBldFBvaW50ZXJIYW5kbGVyID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgbW91c2Vkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB2aWV3LnN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpLCBwb3M7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IChwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoID0gYWN0aXZlLnJhbmdlcy5maW5kKHIgPT4gci5mcm9tIDw9IHBvcyAmJiByLnRvID49IHBvcyk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gbWF0Y2guZmllbGQpXG4gICAgICAgICAgICAgICAgPyBuZXcgQWN0aXZlU25pcHBldChhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCkgOiBudWxsKSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gd29yZFJFKHdvcmRDaGFycykge1xuICAgIGxldCBlc2NhcGVkID0gd29yZENoYXJzLnJlcGxhY2UoL1tcXF1cXC1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV8ke2VzY2FwZWR9XStgLCBcInVnXCIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXHcke2VzY2FwZWR9XWAsIFwiZ1wiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBSRShyZSwgZikge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGYocmUuc291cmNlKSwgcmUudW5pY29kZSA/IFwidVwiIDogXCJcIik7XG59XG5jb25zdCB3b3JkQ2FjaGVzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiB3b3JkQ2FjaGUod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIHdvcmRDYWNoZXNbd29yZENoYXJzXSB8fCAod29yZENhY2hlc1t3b3JkQ2hhcnNdID0gbmV3IFdlYWtNYXApO1xufVxuZnVuY3Rpb24gc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCkge1xuICAgIGZvciAobGV0IGxpbmVzID0gZG9jLml0ZXJMaW5lcygpLCBwb3MgPSAwOyAhbGluZXMubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSBsaW5lcywgbTtcbiAgICAgICAgd29yZFJFLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtID0gd29yZFJFLmV4ZWModmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5bbVswXV0gJiYgcG9zICsgbS5pbmRleCAhPSBpZ25vcmVBdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIGxhYmVsOiBtWzBdIH0pO1xuICAgICAgICAgICAgICAgIHNlZW5bbVswXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IHZhbHVlLmxlbmd0aCArIDE7XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFdvcmRzKGRvYywgY2FjaGUsIHdvcmRSRSwgdG8sIGlnbm9yZUF0KSB7XG4gICAgbGV0IGJpZyA9IGRvYy5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovO1xuICAgIGxldCBjYWNoZWQgPSBiaWcgJiYgY2FjaGUuZ2V0KGRvYyk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgcmVzdWx0ID0gW10sIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGRvYy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbGxlY3RXb3JkcyhjaCwgY2FjaGUsIHdvcmRSRSwgdG8gLSBwb3MsIGlnbm9yZUF0IC0gcG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYy5sYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5bYy5sYWJlbF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yZVdvcmRzKGNoLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQgLSBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGNoLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpO1xuICAgIH1cbiAgICBpZiAoYmlnICYmIHJlc3VsdC5sZW5ndGggPCAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgY2FjaGUuc2V0KGRvYywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5BIGNvbXBsZXRpb24gc291cmNlIHRoYXQgd2lsbCBzY2FuIHRoZSBkb2N1bWVudCBmb3Igd29yZHMgKHVzaW5nIGFcbltjaGFyYWN0ZXIgY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSksIGFuZFxucmV0dXJuIHRob3NlIGFzIGNvbXBsZXRpb25zLlxuKi9cbmNvbnN0IGNvbXBsZXRlQW55V29yZCA9IGNvbnRleHQgPT4ge1xuICAgIGxldCB3b3JkQ2hhcnMgPSBjb250ZXh0LnN0YXRlLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGNvbnRleHQucG9zKS5qb2luKFwiXCIpO1xuICAgIGxldCByZSA9IHdvcmRSRSh3b3JkQ2hhcnMpO1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWFwUkUocmUsIHMgPT4gcyArIFwiJFwiKSk7XG4gICAgaWYgKCF0b2tlbiAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcztcbiAgICBsZXQgb3B0aW9ucyA9IGNvbGxlY3RXb3Jkcyhjb250ZXh0LnN0YXRlLmRvYywgd29yZENhY2hlKHdvcmRDaGFycyksIHJlLCA1MDAwMCAvKiBDLlJhbmdlICovLCBmcm9tKTtcbiAgICByZXR1cm4geyBmcm9tLCBvcHRpb25zLCB2YWxpZEZvcjogbWFwUkUocmUsIHMgPT4gXCJeXCIgKyBzKSB9O1xufTtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJ10sXG4gICAgYmVmb3JlOiBcIildfTo7PlwiLFxuICAgIHN0cmluZ1ByZWZpeGVzOiBbXVxufTtcbmNvbnN0IGNsb3NlQnJhY2tldEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgbWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gbWFwcGluZy5tYXBQb3ModmFsdWUsIC0xLCBNYXBNb2RlLlRyYWNrQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09IG51bGwgPyB1bmRlZmluZWQgOiBtYXBwZWQ7XG4gICAgfVxufSk7XG5jb25zdCBjbG9zZWRCcmFja2V0ID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFJhbmdlVmFsdWUge1xufTtcbmNsb3NlZEJyYWNrZXQuc3RhcnRTaWRlID0gMTtcbmNsb3NlZEJyYWNrZXQuZW5kU2lkZSA9IC0xO1xuY29uc3QgYnJhY2tldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRyLnN0YXRlLmRvYy5saW5lQXQodHIuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGZpbHRlcjogZnJvbSA9PiBmcm9tID49IGxpbmUuZnJvbSAmJiBmcm9tIDw9IGxpbmUudG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlQnJhY2tldEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBhZGQ6IFtjbG9zZWRCcmFja2V0LnJhbmdlKGVmZmVjdC52YWx1ZSwgZWZmZWN0LnZhbHVlICsgMSldIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgYnJhY2tldC1jbG9zaW5nIGJlaGF2aW9yLiBXaGVuIGEgY2xvc2VhYmxlXG5icmFja2V0IGlzIHR5cGVkLCBpdHMgY2xvc2luZyBicmFja2V0IGlzIGltbWVkaWF0ZWx5IGluc2VydGVkXG5hZnRlciB0aGUgY3Vyc29yLiBXaGVuIGNsb3NpbmcgYSBicmFja2V0IGRpcmVjdGx5IGluIGZyb250IG9mIGFcbmNsb3NpbmcgYnJhY2tldCBpbnNlcnRlZCBieSB0aGUgZXh0ZW5zaW9uLCB0aGUgY3Vyc29yIG1vdmVzIG92ZXJcbnRoYXQgYnJhY2tldC5cbiovXG5mdW5jdGlvbiBjbG9zZUJyYWNrZXRzKCkge1xuICAgIHJldHVybiBbaW5wdXRIYW5kbGVyLCBicmFja2V0U3RhdGVdO1xufVxuY29uc3QgZGVmaW5lZENsb3NpbmcgPSBcIigpW117fTw+wqvCu8K7wqvvvLvvvL3vvZvvvZ1cIjtcbmZ1bmN0aW9uIGNsb3NpbmcoY2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluZWRDbG9zaW5nLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZGVmaW5lZENsb3NpbmcuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgIHJldHVybiBkZWZpbmVkQ2xvc2luZy5jaGFyQXQoaSArIDEpO1xuICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNoIDwgMTI4ID8gY2ggOiBjaCArIDEpO1xufVxuZnVuY3Rpb24gY29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICByZXR1cm4gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjbG9zZUJyYWNrZXRzXCIsIHBvcylbMF0gfHwgZGVmYXVsdHM7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIGluc2VydCkgPT4ge1xuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoaW5zZXJ0Lmxlbmd0aCA+IDIgfHwgaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQoaW5zZXJ0LCAwKSkgPT0gMSB8fFxuICAgICAgICBmcm9tICE9IHNlbC5mcm9tIHx8IHRvICE9IHNlbC50bylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ciA9IGluc2VydEJyYWNrZXQodmlldy5zdGF0ZSwgaW5zZXJ0KTtcbiAgICBpZiAoIXRyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IGltcGxlbWVudHMgZGVsZXRpbmcgYSBwYWlyIG9mIG1hdGNoaW5nIGJyYWNrZXRzIHdoZW5cbnRoZSBjdXJzb3IgaXMgYmV0d2VlbiB0aGVtLlxuKi9cbmNvbnN0IGRlbGV0ZUJyYWNrZXRQYWlyID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHRva2VucyA9IGNvbmYuYnJhY2tldHMgfHwgZGVmYXVsdHMuYnJhY2tldHM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHByZXZDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2tlbiwgMCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmhlYWQgLSB0b2tlbi5sZW5ndGgsIHRvOiByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoIWRvbnQpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmJhY2t3YXJkXCIgfSkpO1xuICAgIHJldHVybiAhZG9udDtcbn07XG4vKipcbkNsb3NlLWJyYWNrZXRzIHJlbGF0ZWQga2V5IGJpbmRpbmdzLiBCaW5kcyBCYWNrc3BhY2UgdG9cbltgZGVsZXRlQnJhY2tldFBhaXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5kZWxldGVCcmFja2V0UGFpcikuXG4qL1xuY29uc3QgY2xvc2VCcmFja2V0c0tleW1hcCA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVCcmFja2V0UGFpciB9XG5dO1xuLyoqXG5JbXBsZW1lbnRzIHRoZSBleHRlbnNpb24ncyBiZWhhdmlvciBvbiB0ZXh0IGluc2VydGlvbi4gSWYgdGhlXG5naXZlbiBzdHJpbmcgY291bnRzIGFzIGEgYnJhY2tldCBpbiB0aGUgbGFuZ3VhZ2UgYXJvdW5kIHRoZVxuc2VsZWN0aW9uLCBhbmQgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBpdCByZXF1aXJlcyBjdXN0b21cbmJlaGF2aW9yIChpbnNlcnRpbmcgYSBjbG9zaW5nIHZlcnNpb24gb3Igc2tpcHBpbmcgcGFzdCBhXG5wcmV2aW91c2x5LWNsb3NlZCBicmFja2V0KSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudGluZyB0aGF0IGN1c3RvbSBiZWhhdmlvci4gKFlvdSBvbmx5IG5lZWQgdGhpcyBpZiB5b3Ugd2FudFxudG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYnJhY2tldHPigJR0aGVcbltgY2xvc2VCcmFja2V0c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpIGV4dGVuc2lvbiB3aWxsXG50YWtlIGNhcmUgb2YgcnVubmluZyB0aGlzIGZvciB1c2VyIGlucHV0LilcbiovXG5mdW5jdGlvbiBpbnNlcnRCcmFja2V0KHN0YXRlLCBicmFja2V0KSB7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGZvciAobGV0IHRvayBvZiB0b2tlbnMpIHtcbiAgICAgICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcoY29kZVBvaW50QXQodG9rLCAwKSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IHRvaylcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSwgdG9rLCB0b2tlbnMuaW5kZXhPZih0b2sgKyB0b2sgKyB0b2spID4gLTEsIGNvbmYpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVPcGVuKHN0YXRlLCB0b2ssIGNsb3NlZCwgY29uZi5iZWZvcmUgfHwgZGVmYXVsdHMuYmVmb3JlKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gY2xvc2VkICYmIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xvc2Uoc3RhdGUsIHRvaywgY2xvc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIHN0YXRlLmZpZWxkKGJyYWNrZXRTdGF0ZSkuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCBmcm9tID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT0gcG9zKVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG5leHRDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IG5leHQgPSBkb2Muc2xpY2VTdHJpbmcocG9zLCBwb3MgKyAyKTtcbiAgICByZXR1cm4gbmV4dC5zbGljZSgwLCBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KG5leHQsIDApKSk7XG59XG5mdW5jdGlvbiBwcmV2Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBwcmV2ID0gZG9jLnNsaWNlU3RyaW5nKHBvcyAtIDIsIHBvcyk7XG4gICAgcmV0dXJuIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQocHJldiwgMCkpID09IHByZXYubGVuZ3RoID8gcHJldiA6IHByZXYuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcGVuKHN0YXRlLCBvcGVuLCBjbG9zZSwgY2xvc2VCZWZvcmUpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogb3BlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogY2xvc2UsIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIG9wZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IC9cXHMvLnRlc3QobmV4dCkgfHwgY2xvc2VCZWZvcmUuaW5kZXhPZihuZXh0KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IG9wZW4gKyBjbG9zZSwgZnJvbTogcmFuZ2UuaGVhZCB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbG9zZShzdGF0ZSwgX29wZW4sIGNsb3NlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkLCB0bzogcmFuZ2UuaGVhZCArIGNsb3NlLmxlbmd0aCwgaW5zZXJ0OiBjbG9zZSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG4vLyBIYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBvcGVuIGFuZCBjbG9zZSB0b2tlbiBhcmUgdGhlIHNhbWUsIGFuZFxuLy8gcG9zc2libHkgdHJpcGxlIHF1b3RlcyAoYXMgaW4gYFwiXCJcImFiY1wiXCJcImAtc3R5bGUgcXVvdGluZykuXG5mdW5jdGlvbiBoYW5kbGVTYW1lKHN0YXRlLCB0b2tlbiwgYWxsb3dUcmlwbGUsIGNvbmZpZykge1xuICAgIGxldCBzdHJpbmdQcmVmaXhlcyA9IGNvbmZpZy5zdHJpbmdQcmVmaXhlcyB8fCBkZWZhdWx0cy5zdHJpbmdQcmVmaXhlcztcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgdG9rZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcG9zKSwgc3RhcnQ7XG4gICAgICAgIGlmIChuZXh0ID09IHRva2VuKSB7XG4gICAgICAgICAgICBpZiAobm9kZVN0YXJ0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVHJpcGxlID0gYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyB0b2tlbi5sZW5ndGggKiAzKSA9PSB0b2tlbiArIHRva2VuICsgdG9rZW47XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBpc1RyaXBsZSA/IHRva2VuICsgdG9rZW4gKyB0b2tlbiA6IHRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcG9zLCB0bzogcG9zICsgY29udGVudC5sZW5ndGgsIGluc2VydDogY29udGVudCB9LFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyBjb250ZW50Lmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd1RyaXBsZSAmJiBzdGF0ZS5zbGljZURvYyhwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBwb3MpID09IHRva2VuICsgdG9rZW4gJiZcbiAgICAgICAgICAgIChzdGFydCA9IGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHN0cmluZ1ByZWZpeGVzKSkgPiAtMSAmJlxuICAgICAgICAgICAgbm9kZVN0YXJ0KHN0YXRlLCBzdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuICsgdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpKG5leHQpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICBpZiAoY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zLCBzdHJpbmdQcmVmaXhlcykgPiAtMSAmJiAhcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCB0b2tlbiwgc3RyaW5nUHJlZml4ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vZGVTdGFydChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zICsgMSk7XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIHRyZWUuZnJvbSA9PSBwb3M7XG59XG5mdW5jdGlvbiBwcm9iYWJseUluU3RyaW5nKHN0YXRlLCBwb3MsIHF1b3RlVG9rZW4sIHByZWZpeGVzKSB7XG4gICAgbGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XG4gICAgbGV0IG1heFByZWZpeCA9IHByZWZpeGVzLnJlZHVjZSgobSwgcCkgPT4gTWF0aC5tYXgobSwgcC5sZW5ndGgpLCAwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIE1hdGgubWluKG5vZGUudG8sIG5vZGUuZnJvbSArIHF1b3RlVG9rZW4ubGVuZ3RoICsgbWF4UHJlZml4KSk7XG4gICAgICAgIGxldCBxdW90ZVBvcyA9IHN0YXJ0LmluZGV4T2YocXVvdGVUb2tlbik7XG4gICAgICAgIGlmICghcXVvdGVQb3MgfHwgcXVvdGVQb3MgPiAtMSAmJiBwcmVmaXhlcy5pbmRleE9mKHN0YXJ0LnNsaWNlKDAsIHF1b3RlUG9zKSkgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGZpcnN0ICYmIGZpcnN0LmZyb20gPT0gbm9kZS5mcm9tICYmIGZpcnN0LnRvIC0gZmlyc3QuZnJvbSA+IHF1b3RlVG9rZW4ubGVuZ3RoICsgcXVvdGVQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2MoZmlyc3QudG8gLSBxdW90ZVRva2VuLmxlbmd0aCwgZmlyc3QudG8pID09IHF1b3RlVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZpcnN0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS50byA9PSBwb3MgJiYgbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgcHJlZml4ZXMpIHtcbiAgICBsZXQgY2hhckNhdCA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGlmIChjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGZvciAobGV0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2Moc3RhcnQsIHBvcykgPT0gcHJlZml4ICYmIGNoYXJDYXQoc3RhdGUuc2xpY2VEb2Moc3RhcnQgLSAxLCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGF1dG9jb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIGF1dG9jb21wbGV0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29tbWl0Q2hhcmFjdGVycyxcbiAgICAgICAgY29tcGxldGlvblN0YXRlLFxuICAgICAgICBjb21wbGV0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGNvbXBsZXRpb25QbHVnaW4sXG4gICAgICAgIGNvbXBsZXRpb25LZXltYXBFeHQsXG4gICAgICAgIGJhc2VUaGVtZVxuICAgIF07XG59XG4vKipcbkJhc2ljIGtleWJpbmRpbmdzIGZvciBhdXRvY29tcGxldGlvbi5cblxuIC0gQ3RybC1TcGFjZSAoYW5kIEFsdC1cXGAgb3IgQWx0LWkgb24gbWFjT1MpOiBbYHN0YXJ0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLnN0YXJ0Q29tcGxldGlvbilcbiAtIEVzY2FwZTogW2BjbG9zZUNvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUNvbXBsZXRpb24pXG4gLSBBcnJvd0Rvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUpYFxuIC0gQXJyb3dVcDogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAoZmFsc2UpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIFBhZ2VVcDogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAoZmFsc2UsIFwicGFnZVwiKWBcbiAtIEVudGVyOiBbYGFjY2VwdENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hY2NlcHRDb21wbGV0aW9uKVxuKi9cbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TcGFjZVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsgbWFjOiBcIkFsdC1gXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBtYWM6IFwiQWx0LWlcIiwgcnVuOiBzdGFydENvbXBsZXRpb24gfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZUNvbXBsZXRpb24gfSxcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSkgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlKSB9LFxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUsIFwicGFnZVwiKSB9LFxuICAgIHsga2V5OiBcIlBhZ2VVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBhY2NlcHRDb21wbGV0aW9uIH1cbl07XG5jb25zdCBjb21wbGV0aW9uS2V5bWFwRXh0ID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyova2V5bWFwLmNvbXB1dGVOKFtjb21wbGV0aW9uQ29uZmlnXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuZGVmYXVsdEtleW1hcCA/IFtjb21wbGV0aW9uS2V5bWFwXSA6IFtdKSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBjb21wbGV0aW9uIHN0YXR1cy4gV2hlbiBjb21wbGV0aW9ucyBhcmUgYXZhaWxhYmxlLFxudGhpcyB3aWxsIHJldHVybiBgXCJhY3RpdmVcImAuIFdoZW4gY29tcGxldGlvbnMgYXJlIHBlbmRpbmcgKGluIHRoZVxucHJvY2VzcyBvZiBiZWluZyBxdWVyaWVkKSwgdGhpcyByZXR1cm5zIGBcInBlbmRpbmdcImAuIE90aGVyd2lzZSwgaXRcbnJldHVybnMgYG51bGxgLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRpb25TdGF0dXMoc3RhdGUpIHtcbiAgICBsZXQgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLmlzUGVuZGluZykgPyBcInBlbmRpbmdcIlxuICAgICAgICA6IGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pID8gXCJhY3RpdmVcIiA6IG51bGw7XG59XG5jb25zdCBjb21wbGV0aW9uQXJyYXlDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcDtcbi8qKlxuUmV0dXJucyB0aGUgYXZhaWxhYmxlIGNvbXBsZXRpb25zIGFzIGFuIGFycmF5LlxuKi9cbmZ1bmN0aW9uIGN1cnJlbnRDb21wbGV0aW9ucyhzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICBpZiAoIW9wZW4gfHwgb3Blbi5kaXNhYmxlZClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBjb21wbGV0aW9ucyA9IGNvbXBsZXRpb25BcnJheUNhY2hlLmdldChvcGVuLm9wdGlvbnMpO1xuICAgIGlmICghY29tcGxldGlvbnMpXG4gICAgICAgIGNvbXBsZXRpb25BcnJheUNhY2hlLnNldChvcGVuLm9wdGlvbnMsIGNvbXBsZXRpb25zID0gb3Blbi5vcHRpb25zLm1hcChvID0+IG8uY29tcGxldGlvbikpO1xuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cbi8qKlxuUmV0dXJuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcGxldGlvbiwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF0uY29tcGxldGlvbiA6IG51bGw7XG59XG4vKipcblJldHVybnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwb3NpdGlvbiBpbiB0aGUgYWN0aXZlIGNvbXBsZXRpb25cbmxpc3QsIG9yIG51bGwgaWYgbm8gY29tcGxldGlvbnMgYXJlIGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb25JbmRleChzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLnNlbGVjdGVkIDogbnVsbDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGNoYW5nZVxudGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkQ29tcGxldGlvbihpbmRleCkge1xuICAgIHJldHVybiBzZXRTZWxlY3RlZEVmZmVjdC5vZihpbmRleCk7XG59XG5cbmV4cG9ydCB7IENvbXBsZXRpb25Db250ZXh0LCBhY2NlcHRDb21wbGV0aW9uLCBhdXRvY29tcGxldGlvbiwgY2xlYXJTbmlwcGV0LCBjbG9zZUJyYWNrZXRzLCBjbG9zZUJyYWNrZXRzS2V5bWFwLCBjbG9zZUNvbXBsZXRpb24sIGNvbXBsZXRlQW55V29yZCwgY29tcGxldGVGcm9tTGlzdCwgY29tcGxldGlvbktleW1hcCwgY29tcGxldGlvblN0YXR1cywgY3VycmVudENvbXBsZXRpb25zLCBkZWxldGVCcmFja2V0UGFpciwgaGFzTmV4dFNuaXBwZXRGaWVsZCwgaGFzUHJldlNuaXBwZXRGaWVsZCwgaWZJbiwgaWZOb3RJbiwgaW5zZXJ0QnJhY2tldCwgaW5zZXJ0Q29tcGxldGlvblRleHQsIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uLCBuZXh0U25pcHBldEZpZWxkLCBwaWNrZWRDb21wbGV0aW9uLCBwcmV2U25pcHBldEZpZWxkLCBzZWxlY3RlZENvbXBsZXRpb24sIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4LCBzZXRTZWxlY3RlZENvbXBsZXRpb24sIHNuaXBwZXQsIHNuaXBwZXRDb21wbGV0aW9uLCBzbmlwcGV0S2V5bWFwLCBzdGFydENvbXBsZXRpb24gfTtcbiJdLCJuYW1lcyI6WyJBbm5vdGF0aW9uIiwiU3RhdGVFZmZlY3QiLCJFZGl0b3JTZWxlY3Rpb24iLCJjb2RlUG9pbnRBdCIsImNvZGVQb2ludFNpemUiLCJmcm9tQ29kZVBvaW50IiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiU3RhdGVGaWVsZCIsIlByZWMiLCJUZXh0IiwiVHJhbnNhY3Rpb24iLCJNYXBNb2RlIiwiUmFuZ2VWYWx1ZSIsIlJhbmdlU2V0IiwiQ2hhckNhdGVnb3J5IiwiRGlyZWN0aW9uIiwibG9nRXhjZXB0aW9uIiwic2hvd1Rvb2x0aXAiLCJFZGl0b3JWaWV3IiwiVmlld1BsdWdpbiIsImdldFRvb2x0aXAiLCJEZWNvcmF0aW9uIiwiV2lkZ2V0VHlwZSIsImtleW1hcCIsInN5bnRheFRyZWUiLCJpbmRlbnRVbml0IiwiQ29tcGxldGlvbkNvbnRleHQiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwicG9zIiwiZXhwbGljaXQiLCJ2aWV3IiwiYWJvcnRMaXN0ZW5lcnMiLCJhYm9ydE9uRG9jQ2hhbmdlIiwidG9rZW5CZWZvcmUiLCJ0eXBlcyIsInRva2VuIiwicmVzb2x2ZUlubmVyIiwiaW5kZXhPZiIsIm5hbWUiLCJwYXJlbnQiLCJmcm9tIiwidG8iLCJ0ZXh0Iiwic2xpY2VEb2MiLCJ0eXBlIiwibWF0Y2hCZWZvcmUiLCJleHByIiwibGluZSIsImRvYyIsImxpbmVBdCIsInN0YXJ0IiwiTWF0aCIsIm1heCIsInN0ciIsInNsaWNlIiwiZm91bmQiLCJzZWFyY2giLCJlbnN1cmVBbmNob3IiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwib3B0aW9ucyIsInB1c2giLCJvbkRvY0NoYW5nZSIsInRvU2V0IiwiY2hhcnMiLCJmbGF0IiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJ3b3JkcyIsInRlc3QiLCJyZXBsYWNlIiwicHJlZml4TWF0Y2giLCJmaXJzdCIsImNyZWF0ZSIsInJlc3QiLCJsYWJlbCIsImkiLCJsZW5ndGgiLCJzb3VyY2UiLCJSZWdFeHAiLCJjb21wbGV0ZUZyb21MaXN0IiwibGlzdCIsIm1hcCIsIm8iLCJ2YWxpZEZvciIsIm1hdGNoIiwiZXZlcnkiLCJjb250ZXh0IiwiaWZJbiIsIm5vZGVzIiwiaXNUb3AiLCJpZk5vdEluIiwiT3B0aW9uIiwiY29tcGxldGlvbiIsInNjb3JlIiwiY3VyIiwic2VsZWN0aW9uIiwibWFpbiIsIl9hIiwiYWRkU3RhcnQiLCJhZGRFbmQiLCJmbGFncyIsImlnbm9yZUNhc2UiLCJwaWNrZWRDb21wbGV0aW9uIiwiZGVmaW5lIiwiaW5zZXJ0Q29tcGxldGlvblRleHQiLCJmcm9tT2ZmIiwidG9PZmYiLCJjaGFuZ2VCeVJhbmdlIiwicmFuZ2UiLCJsaW5lcyIsInRvVGV4dCIsImNoYW5nZXMiLCJpbnNlcnQiLCJjdXJzb3IiLCJzY3JvbGxJbnRvVmlldyIsInVzZXJFdmVudCIsIlNvdXJjZUNhY2hlIiwiV2Vha01hcCIsImFzU291cmNlIiwiQXJyYXkiLCJpc0FycmF5Iiwia25vd24iLCJnZXQiLCJzZXQiLCJzdGFydENvbXBsZXRpb25FZmZlY3QiLCJjbG9zZUNvbXBsZXRpb25FZmZlY3QiLCJGdXp6eU1hdGNoZXIiLCJwYXR0ZXJuIiwiZm9sZGVkIiwiYW55IiwicHJlY2lzZSIsImJ5V29yZCIsIm1hdGNoZWQiLCJwIiwiY2hhciIsInNpemUiLCJwYXJ0IiwidXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiYXN0cmFsIiwicmV0Iiwid29yZCIsImZpcnN0U2l6ZSIsImRpcmVjdCIsImxlbiIsImFueVRvIiwiZSIsIm1pbiIsIm5leHQiLCJwcmVjaXNlVG8iLCJieVdvcmRUbyIsImJ5V29yZEZvbGRlZCIsImFkamFjZW50VG8iLCJhZGphY2VudFN0YXJ0IiwiYWRqYWNlbnRFbmQiLCJoYXNMb3dlciIsIndvcmRBZGphY2VudCIsInByZXZUeXBlIiwiY2giLCJyZXN1bHQiLCJwb3NpdGlvbnMiLCJTdHJpY3RNYXRjaGVyIiwiY29tcGxldGlvbkNvbmZpZyIsImNvbWJpbmUiLCJjb25maWdzIiwiYWN0aXZhdGVPblR5cGluZyIsImFjdGl2YXRlT25Db21wbGV0aW9uIiwiYWN0aXZhdGVPblR5cGluZ0RlbGF5Iiwic2VsZWN0T25PcGVuIiwib3ZlcnJpZGUiLCJjbG9zZU9uQmx1ciIsIm1heFJlbmRlcmVkT3B0aW9ucyIsImRlZmF1bHRLZXltYXAiLCJ0b29sdGlwQ2xhc3MiLCJvcHRpb25DbGFzcyIsImFib3ZlQ3Vyc29yIiwiaWNvbnMiLCJhZGRUb09wdGlvbnMiLCJwb3NpdGlvbkluZm8iLCJkZWZhdWx0UG9zaXRpb25JbmZvIiwiZmlsdGVyU3RyaWN0IiwiY29tcGFyZUNvbXBsZXRpb25zIiwiYSIsImIiLCJzb3J0VGV4dCIsImxvY2FsZUNvbXBhcmUiLCJpbnRlcmFjdGlvbkRlbGF5IiwidXBkYXRlU3luY1RpbWUiLCJjIiwiam9pbkNsYXNzIiwiY29uY2F0Iiwib3B0aW9uIiwiaW5mbyIsInNwYWNlIiwidG9vbHRpcCIsInJ0bCIsInRleHREaXJlY3Rpb24iLCJSVEwiLCJsZWZ0IiwibmFycm93Iiwic2lkZSIsIm9mZnNldCIsIm1heFdpZHRoIiwic3BhY2VMZWZ0Iiwic3BhY2VSaWdodCIsInJpZ2h0IiwiaW5mb1dpZHRoIiwiaW5mb0hlaWdodCIsImJvdHRvbSIsInRvcCIsInNwYWNlQmVsb3ciLCJzY2FsZVkiLCJvZmZzZXRIZWlnaHQiLCJzY2FsZVgiLCJvZmZzZXRXaWR0aCIsInN0eWxlIiwiY2xhc3MiLCJvcHRpb25Db250ZW50IiwiY29uZmlnIiwiY29udGVudCIsInJlbmRlciIsImljb24iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJzcGxpdCIsImNscyIsInNldEF0dHJpYnV0ZSIsInBvc2l0aW9uIiwiX3MiLCJfdiIsImxhYmVsRWx0IiwiY2xhc3NOYW1lIiwiZGlzcGxheUxhYmVsIiwib2ZmIiwiaiIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJzcGFuIiwiZGV0YWlsIiwiZGV0YWlsRWx0IiwidGV4dENvbnRlbnQiLCJzb3J0IiwicmFuZ2VBcm91bmRTZWxlY3RlZCIsInRvdGFsIiwic2VsZWN0ZWQiLCJmbG9vciIsIkNvbXBsZXRpb25Ub29sdGlwIiwic3RhdGVGaWVsZCIsImFwcGx5Q29tcGxldGlvbiIsImluZm9EZXN0cm95IiwicGxhY2VJbmZvUmVxIiwicmVhZCIsIm1lYXN1cmVJbmZvIiwid3JpdGUiLCJwbGFjZUluZm8iLCJrZXkiLCJjdXJyZW50Q2xhc3MiLCJjU3RhdGUiLCJmaWVsZCIsIm9wZW4iLCJmYWNldCIsImRvbSIsInVwZGF0ZVRvb2x0aXBDbGFzcyIsInRhcmdldCIsInBhcmVudE5vZGUiLCJub2RlTmFtZSIsImV4ZWMiLCJpZCIsInByZXZlbnREZWZhdWx0IiwicmVsYXRlZFRhcmdldCIsImNvbnRlbnRET00iLCJkaXNwYXRjaCIsImVmZmVjdHMiLCJvZiIsInNob3dPcHRpb25zIiwibW91bnQiLCJ1cGRhdGVTZWwiLCJyZW1vdmUiLCJjcmVhdGVMaXN0Qm94IiwicmVxdWVzdE1lYXN1cmUiLCJ1cGRhdGUiLCJwcmV2U3RhdGUiLCJzdGFydFN0YXRlIiwiZGlzYWJsZWQiLCJ0b2dnbGUiLCJwb3NpdGlvbmVkIiwibmV3U2VsIiwidXBkYXRlU2VsZWN0ZWRPcHRpb24iLCJkZXN0cm95SW5mbyIsImluZm9SZXN1bHQiLCJ0aGVuIiwib2JqIiwiYWRkSW5mb1BhbmUiLCJjYXRjaCIsIndyYXAiLCJyYW5kb20iLCJ0b1N0cmluZyIsIm5vZGVUeXBlIiwiZGVzdHJveSIsIm9wdCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNlbCIsInF1ZXJ5U2VsZWN0b3IiLCJsaXN0UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImluZm9SZWN0Iiwic2VsUmVjdCIsImRvY0VsdCIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImNzc1RleHQiLCJ1bCIsInBocmFzZSIsImN1clNlY3Rpb24iLCJzZWN0aW9uIiwiaGVhZGVyIiwibGkiLCJub2RlIiwiY29tcGxldGlvblRvb2x0aXAiLCJjb250YWluZXIiLCJlbGVtZW50Iiwic2VsZiIsImhlaWdodCIsInNjcm9sbFRvcCIsImJvb3N0IiwiYXBwbHkiLCJzb3J0T3B0aW9ucyIsImFjdGl2ZSIsInNlY3Rpb25zIiwiZHluYW1pY1NlY3Rpb25TY29yZSIsImFkZE9wdGlvbiIsInNvbWUiLCJzIiwiY29uZiIsImhhc1Jlc3VsdCIsImdldE1hdGNoIiwiZmlsdGVyIiwibWF0Y2hlciIsInJhbmsiLCJzZWN0aW9uT3JkZXIiLCJjbXAiLCJwcmV2IiwiY29tcGFyZSIsIkNvbXBsZXRpb25EaWFsb2ciLCJhdHRycyIsInRpbWVzdGFtcCIsInNldFNlbGVjdGVkIiwibWFrZUF0dHJzIiwiYnVpbGQiLCJkaWRTZXRBY3RpdmUiLCJpc1BlbmRpbmciLCJzZXREaXNhYmxlZCIsInNlbGVjdGVkVmFsdWUiLCJyZWR1Y2UiLCJjcmVhdGVUb29sdGlwIiwiYWJvdmUiLCJEYXRlIiwibm93IiwibWFwUG9zIiwiQ29tcGxldGlvblN0YXRlIiwibm9uZSIsInRyIiwic291cmNlcyIsImxhbmd1YWdlRGF0YUF0IiwidmFsdWUiLCJmaW5kIiwiQWN0aXZlU291cmNlIiwiZGlkU2V0IiwiaXMiLCJzZXRBY3RpdmVFZmZlY3QiLCJkb2NDaGFuZ2VkIiwidG91Y2hlc1JhbmdlIiwic2FtZVJlc3VsdHMiLCJlZmZlY3QiLCJzZXRTZWxlY3RlZEVmZmVjdCIsImJhc2VBdHRycyIsIm5vQXR0cnMiLCJpQSIsImlCIiwiZW5kQSIsImVuZEIiLCJnZXRVcGRhdGVUeXBlIiwiaXNVc2VyRXZlbnQiLCJhbm5vdGF0aW9uIiwidHlwaW5nIiwidG91Y2hlcyIsInVwZGF0ZUZvciIsIkFjdGl2ZVJlc3VsdCIsImxpbWl0IiwiZW1wdHkiLCJjaGVja1ZhbGlkIiwibWFwcGluZyIsImNvbXBsZXRpb25TdGF0ZSIsInByb3ZpZGUiLCJmIiwidmFsIiwiY29udGVudEF0dHJpYnV0ZXMiLCJhbm5vdGF0aW9ucyIsIm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uIiwiZm9yd2FyZCIsImJ5Iiwic3RlcCIsImFjY2VwdENvbXBsZXRpb24iLCJyZWFkT25seSIsInN0YXJ0Q29tcGxldGlvbiIsImNsb3NlQ29tcGxldGlvbiIsIlJ1bm5pbmdRdWVyeSIsInRpbWUiLCJ1cGRhdGVzIiwiZG9uZSIsInVuZGVmaW5lZCIsIk1heFVwZGF0ZUNvdW50IiwiTWluQWJvcnRUaW1lIiwiY29tcGxldGlvblBsdWdpbiIsImZyb21DbGFzcyIsImRlYm91bmNlVXBkYXRlIiwicnVubmluZyIsImRlYm91bmNlQWNjZXB0IiwicGVuZGluZ1N0YXJ0IiwiY29tcG9zaW5nIiwic3RhcnRRdWVyeSIsInNlbGVjdGlvblNldCIsImRvZXNSZXNldCIsInRyYW5zYWN0aW9ucyIsInF1ZXJ5IiwiaGFuZGxlciIsInNwbGljZSIsImNsZWFyVGltZW91dCIsImRlbGF5IiwicSIsInNldFRpbWVvdXQiLCJzdGFydFVwZGF0ZSIsInIiLCJhY2NlcHQiLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzY2hlZHVsZUFjY2VwdCIsImVyciIsInVwZGF0ZWQiLCJjdXJyZW50IiwiZXZlbnRIYW5kbGVycyIsImJsdXIiLCJldmVudCIsImRpYWxvZyIsImNvbnRhaW5zIiwiY29tcG9zaXRpb25zdGFydCIsImNvbXBvc2l0aW9uZW5kIiwid2luZG93cyIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiY29tbWl0Q2hhcmFjdGVycyIsImhpZ2hlc3QiLCJkb21FdmVudEhhbmRsZXJzIiwia2V5ZG93biIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiY29tbWl0Q2hhcnMiLCJiYXNlVGhlbWUiLCJmb250RmFtaWx5Iiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwibWF4V2lkdGhfZmFsbGJhY2siLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsImxpc3RTdHlsZSIsIm1hcmdpbiIsInBhZGRpbmciLCJsaW5lSGVpZ2h0Iiwib3ZlcmZsb3dYIiwidGV4dE92ZXJmbG93IiwiZGlzcGxheSIsImJvcmRlckJvdHRvbSIsInBhZGRpbmdMZWZ0Iiwib3BhY2l0eSIsImJhY2tncm91bmQiLCJjb2xvciIsInRleHRBbGlnbiIsIndpZHRoIiwiYm94U2l6aW5nIiwiYmFja2dyb3VuZENvbG9yIiwidmVydGljYWxBbGlnbiIsImJvcmRlckxlZnQiLCJ0ZXh0RGVjb3JhdGlvbiIsIm1hcmdpbkxlZnQiLCJmb250U3R5bGUiLCJmb250U2l6ZSIsInBhZGRpbmdSaWdodCIsIkZpZWxkUG9zIiwiRmllbGRSYW5nZSIsIlRyYWNrRGVsIiwiU25pcHBldCIsImZpZWxkUG9zaXRpb25zIiwiaW5zdGFudGlhdGUiLCJsaW5lU3RhcnQiLCJsaW5lT2JqIiwiYmFzZUluZGVudCIsImluZGVudCIsInRhYnMiLCJyYW5nZXMiLCJwYXJzZSIsInRlbXBsYXRlIiwiZmllbGRzIiwibSIsInNlcSIsInJhd05hbWUiLCJpbmRleCIsInNuaXAiLCJfIiwiYnJhY2UiLCJmaWVsZE1hcmtlciIsIndpZGdldCIsInRvRE9NIiwiaWdub3JlRXZlbnQiLCJmaWVsZFJhbmdlIiwibWFyayIsIkFjdGl2ZVNuaXBwZXQiLCJkZWNvIiwibWFwcGVkIiwic2VsZWN0aW9uSW5zaWRlRmllbGQiLCJzZXRBY3RpdmUiLCJtb3ZlVG9GaWVsZCIsInNuaXBwZXRTdGF0ZSIsImRlY29yYXRpb25zIiwiZmllbGRTZWxlY3Rpb24iLCJzbmlwcGV0IiwiZWRpdG9yIiwic3BlYyIsImFwcGVuZENvbmZpZyIsImFkZFNuaXBwZXRLZXltYXAiLCJzbmlwcGV0UG9pbnRlckhhbmRsZXIiLCJtb3ZlRmllbGQiLCJkaXIiLCJsYXN0IiwiY2xlYXJTbmlwcGV0IiwibmV4dFNuaXBwZXRGaWVsZCIsInByZXZTbmlwcGV0RmllbGQiLCJoYXNOZXh0U25pcHBldEZpZWxkIiwiaGFzUHJldlNuaXBwZXRGaWVsZCIsImRlZmF1bHRTbmlwcGV0S2V5bWFwIiwicnVuIiwic2hpZnQiLCJzbmlwcGV0S2V5bWFwIiwibWFwcyIsImNvbXB1dGUiLCJzbmlwcGV0Q29tcGxldGlvbiIsIm1vdXNlZG93biIsInBvc0F0Q29vcmRzIiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsIndvcmRSRSIsIndvcmRDaGFycyIsImVzY2FwZWQiLCJtYXBSRSIsInJlIiwidW5pY29kZSIsIndvcmRDYWNoZXMiLCJ3b3JkQ2FjaGUiLCJzdG9yZVdvcmRzIiwic2VlbiIsImlnbm9yZUF0IiwiaXRlckxpbmVzIiwibGFzdEluZGV4IiwiY29sbGVjdFdvcmRzIiwiY2FjaGUiLCJiaWciLCJjYWNoZWQiLCJjaGlsZHJlbiIsImNvbXBsZXRlQW55V29yZCIsImRlZmF1bHRzIiwiYnJhY2tldHMiLCJiZWZvcmUiLCJzdHJpbmdQcmVmaXhlcyIsImNsb3NlQnJhY2tldEVmZmVjdCIsIlRyYWNrQWZ0ZXIiLCJjbG9zZWRCcmFja2V0Iiwic3RhcnRTaWRlIiwiZW5kU2lkZSIsImJyYWNrZXRTdGF0ZSIsImhlYWQiLCJjbG9zZUJyYWNrZXRzIiwiaW5wdXRIYW5kbGVyIiwiZGVmaW5lZENsb3NpbmciLCJjbG9zaW5nIiwiY2hhckNvZGVBdCIsImNoYXJBdCIsImFuZHJvaWQiLCJ1c2VyQWdlbnQiLCJjb21wb3NpdGlvblN0YXJ0ZWQiLCJpbnNlcnRCcmFja2V0IiwiZGVsZXRlQnJhY2tldFBhaXIiLCJ0b2tlbnMiLCJkb250IiwicHJldkNoYXIiLCJuZXh0Q2hhciIsImNsb3NlQnJhY2tldHNLZXltYXAiLCJicmFja2V0IiwidG9rIiwiY2xvc2VkIiwiaGFuZGxlU2FtZSIsImhhbmRsZU9wZW4iLCJjbG9zZWRCcmFja2V0QXQiLCJoYW5kbGVDbG9zZSIsImJldHdlZW4iLCJzbGljZVN0cmluZyIsImNsb3NlIiwiY2xvc2VCZWZvcmUiLCJhbmNob3IiLCJfb3BlbiIsImFsbG93VHJpcGxlIiwibm9kZVN0YXJ0IiwiaXNUcmlwbGUiLCJjYW5TdGFydFN0cmluZ0F0IiwiY2hhckNhdGVnb3JpemVyIiwiV29yZCIsInByb2JhYmx5SW5TdHJpbmciLCJ0cmVlIiwicXVvdGVUb2tlbiIsInByZWZpeGVzIiwibWF4UHJlZml4IiwicXVvdGVQb3MiLCJjaGFyQ2F0IiwicHJlZml4IiwiYXV0b2NvbXBsZXRpb24iLCJjb21wbGV0aW9uS2V5bWFwRXh0IiwiY29tcGxldGlvbktleW1hcCIsIm1hYyIsImNvbXB1dGVOIiwiY29tcGxldGlvblN0YXR1cyIsImNvbXBsZXRpb25BcnJheUNhY2hlIiwiY3VycmVudENvbXBsZXRpb25zIiwiY29tcGxldGlvbnMiLCJzZWxlY3RlZENvbXBsZXRpb24iLCJzZWxlY3RlZENvbXBsZXRpb25JbmRleCIsInNldFNlbGVjdGVkQ29tcGxldGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@codemirror+autocomplete@6.20.0/node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ })

};
;