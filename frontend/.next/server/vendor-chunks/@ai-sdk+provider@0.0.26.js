"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ai-sdk+provider@0.0.26";
exports.ids = ["vendor-chunks/@ai-sdk+provider@0.0.26"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n    /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */ constructor({ name: name14, message, cause }){\n        super(message);\n        this[_a] = true;\n        this.name = name14;\n        this.cause = cause;\n    }\n    /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */ static isInstance(error) {\n        return _AISDKError.hasMarker(error, marker);\n    }\n    static hasMarker(error, marker15) {\n        const markerSymbol = Symbol.for(marker15);\n        return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n    }\n    /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message\n        };\n    }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500), // server error\n    data }){\n        super({\n            name,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.requestBodyValues = requestBodyValues;\n        this.statusCode = statusCode;\n        this.responseHeaders = responseHeaders;\n        this.responseBody = responseBody;\n        this.isRetryable = isRetryable;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isAPICallError(error) {\n        return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            requestBodyValues: this.requestBodyValues,\n            statusCode: this.statusCode,\n            responseHeaders: this.responseHeaders,\n            responseBody: this.responseBody,\n            cause: this.cause,\n            isRetryable: this.isRetryable,\n            data: this.data\n        };\n    }\n};\n_a2 = symbol2;\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"Empty response body\" } = {}){\n        super({\n            name: name2,\n            message\n        });\n        this[_a3] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isEmptyResponseBodyError(error) {\n        return error instanceof Error && error.name === name2;\n    }\n};\n_a3 = symbol3;\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n    if (error == null) {\n        return \"unknown error\";\n    }\n    if (typeof error === \"string\") {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return JSON.stringify(error);\n}\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n    constructor({ message, cause, argument }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.argument = argument;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n    constructor({ prompt: prompt2, message, cause }){\n        super({\n            name: name4,\n            message: `Invalid prompt: ${message}`,\n            cause\n        });\n        this[_a5] = true;\n        this.prompt = prompt2;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidPromptError(error) {\n        return error instanceof Error && error.name === name4 && prompt != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            prompt: this.prompt\n        };\n    }\n};\n_a5 = symbol5;\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n    constructor({ data, message = `Invalid response data: ${JSON.stringify(data)}.` }){\n        super({\n            name: name5,\n            message\n        });\n        this[_a6] = true;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker6);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidResponseDataError(error) {\n        return error instanceof Error && error.name === name5 && error.data != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            data: this.data\n        };\n    }\n};\n_a6 = symbol6;\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n    constructor({ text, cause }){\n        super({\n            name: name6,\n            message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a7] = true;\n        this.text = text;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isJSONParseError(error) {\n        return error instanceof Error && error.name === name6 && \"text\" in error && typeof error.text === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            valueText: this.text\n        };\n    }\n};\n_a7 = symbol7;\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a8] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isLoadAPIKeyError(error) {\n        return error instanceof Error && error.name === name7;\n    }\n};\n_a8 = symbol8;\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name8,\n            message\n        });\n        this[_a9] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker9);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isLoadSettingError(error) {\n        return error instanceof Error && error.name === name8;\n    }\n};\n_a9 = symbol9;\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"No content generated.\" } = {}){\n        super({\n            name: name9,\n            message\n        });\n        this[_a10] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker10);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isNoContentGeneratedError(error) {\n        return error instanceof Error && error.name === name9;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            cause: this.cause,\n            message: this.message,\n            stack: this.stack\n        };\n    }\n};\n_a10 = symbol10;\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n    constructor({ errorName = name10, modelId, modelType, message = `No such ${modelType}: ${modelId}` }){\n        super({\n            name: errorName,\n            message\n        });\n        this[_a11] = true;\n        this.modelId = modelId;\n        this.modelType = modelType;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker11);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchModelError(error) {\n        return error instanceof Error && error.name === name10 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            modelId: this.modelId,\n            modelType: this.modelType\n        };\n    }\n};\n_a11 = symbol11;\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n    constructor(options){\n        super({\n            name: name11,\n            message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n        });\n        this[_a12] = true;\n        this.provider = options.provider;\n        this.modelId = options.modelId;\n        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n        this.values = options.values;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker12);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isTooManyEmbeddingValuesForCallError(error) {\n        return error instanceof Error && error.name === name11 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            provider: this.provider,\n            modelId: this.modelId,\n            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n            values: this.values\n        };\n    }\n};\n_a12 = symbol12;\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n    constructor({ value, cause }){\n        super({\n            name: name12,\n            message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a13] = true;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker13);\n    }\n    /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */ static wrap({ value, cause }) {\n        return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({\n            value,\n            cause\n        });\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isTypeValidationError(error) {\n        return error instanceof Error && error.name === name12;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            value: this.value\n        };\n    }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n    constructor({ functionality }){\n        super({\n            name: name13,\n            message: `'${functionality}' functionality not supported.`\n        });\n        this[_a14] = true;\n        this.functionality = functionality;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker14);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isUnsupportedFunctionalityError(error) {\n        return error instanceof Error && error.name === name13 && typeof error.functionality === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            functionality: this.functionality\n        };\n    }\n};\n_a14 = symbol14;\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n    if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.every(isJSONValue);\n    }\n    if (typeof value === \"object\") {\n        return Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n    }\n    return false;\n}\nfunction isJSONArray(value) {\n    return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n    return value != null && typeof value === \"object\" && Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFpLXNkaytwcm92aWRlckAwLjAuMjYvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBQzdCLElBQUlBLFNBQVM7QUFDYixJQUFJQyxTQUFTQyxPQUFPQyxHQUFHLENBQUNIO0FBQ3hCLElBQUlJO0FBQ0osSUFBSUMsY0FBYyxNQUFNQSxvQkFBb0JDO0lBQzFDOzs7Ozs7O0dBT0MsR0FDREMsWUFBWSxFQUNWQyxNQUFNQyxNQUFNLEVBQ1pDLE9BQU8sRUFDUEMsS0FBSyxFQUNOLENBQUU7UUFDRCxLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDTixHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNJLElBQUksR0FBR0M7UUFDWixJQUFJLENBQUNFLEtBQUssR0FBR0E7SUFDZjtJQUNBOzs7O0dBSUMsR0FDRCxPQUFPQyxXQUFXQyxLQUFLLEVBQUU7UUFDdkIsT0FBT1IsWUFBWVMsU0FBUyxDQUFDRCxPQUFPYjtJQUN0QztJQUNBLE9BQU9jLFVBQVVELEtBQUssRUFBRUUsUUFBUSxFQUFFO1FBQ2hDLE1BQU1DLGVBQWVkLE9BQU9DLEdBQUcsQ0FBQ1k7UUFDaEMsT0FBT0YsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWUcsZ0JBQWdCSCxTQUFTLE9BQU9BLEtBQUssQ0FBQ0csYUFBYSxLQUFLLGFBQWFILEtBQUssQ0FBQ0csYUFBYSxLQUFLO0lBQ3BKO0lBQ0E7Ozs7O0dBS0MsR0FDREMsU0FBUztRQUNQLE9BQU87WUFDTFQsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkUsU0FBUyxJQUFJLENBQUNBLE9BQU87UUFDdkI7SUFDRjtBQUNGO0FBQ0FOLEtBQUtIO0FBQ0wsSUFBSWlCLGFBQWFiO0FBRWpCLCtCQUErQjtBQUMvQixJQUFJRyxPQUFPO0FBQ1gsSUFBSVcsVUFBVSxDQUFDLGdCQUFnQixFQUFFWCxL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LFlBQVksT0FBT0EsVUFBVSxXQUFXO1FBQzFHLE9BQU87SUFDVDtJQUNBLElBQUlQLE1BQU1DLE9BQU8sQ0FBQ00sUUFBUTtRQUN4QixPQUFPQSxNQUFNWSxLQUFLLENBQUNEO0lBQ3JCO0lBQ0EsSUFBSSxPQUFPWCxVQUFVLFVBQVU7UUFDN0IsT0FBT2EsT0FBT0MsT0FBTyxDQUFDZCxPQUFPWSxLQUFLLENBQ2hDLENBQUMsQ0FBQ0csS0FBS0MsSUFBSSxHQUFLLE9BQU9ELFFBQVEsWUFBWUosWUFBWUs7SUFFM0Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTQyxZQUFZakIsS0FBSztJQUN4QixPQUFPUCxNQUFNQyxPQUFPLENBQUNNLFVBQVVBLE1BQU1ZLEtBQUssQ0FBQ0Q7QUFDN0M7QUFDQSxTQUFTTyxhQUFhbEIsS0FBSztJQUN6QixPQUFPQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZYSxPQUFPQyxPQUFPLENBQUNkLE9BQU9ZLEtBQUssQ0FDOUUsQ0FBQyxDQUFDRyxLQUFLQyxJQUFJLEdBQUssT0FBT0QsUUFBUSxZQUFZSixZQUFZSztBQUUzRDtBQW9CRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhaS1zZGsrcHJvdmlkZXJAMC4wLjI2L25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXgubWpzP2IzYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxNCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTE0O1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSkge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvci5cbiAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVycm9yJ3MgbmFtZSwgbWVzc2FnZSwgYW5kIGNhdXNlLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xudmFyIEFJU0RLRXJyb3IgPSBfQUlTREtFcnJvcjtcblxuLy8gc3JjL2Vycm9ycy9hcGktY2FsbC1lcnJvci50c1xudmFyIG5hbWUgPSBcIkFJX0FQSUNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBBUElDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICB1cmwsXG4gICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgcmVzcG9uc2VCb2R5LFxuICAgIGNhdXNlLFxuICAgIGlzUmV0cnlhYmxlID0gc3RhdHVzQ29kZSAhPSBudWxsICYmIChzdGF0dXNDb2RlID09PSA0MDggfHwgLy8gcmVxdWVzdCB0aW1lb3V0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDA5IHx8IC8vIGNvbmZsaWN0XG4gICAgc3RhdHVzQ29kZSA9PT0gNDI5IHx8IC8vIHRvbyBtYW55IHJlcXVlc3RzXG4gICAgc3RhdHVzQ29kZSA+PSA1MDApLFxuICAgIC8vIHNlcnZlciBlcnJvclxuICAgIGRhdGFcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzID0gcmVxdWVzdEJvZHlWYWx1ZXM7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycztcbiAgICB0aGlzLnJlc3BvbnNlQm9keSA9IHJlc3BvbnNlQm9keTtcbiAgICB0aGlzLmlzUmV0cnlhYmxlID0gaXNSZXRyeWFibGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNBUElDYWxsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lICYmIHR5cGVvZiBlcnJvci51cmwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnJlcXVlc3RCb2R5VmFsdWVzID09PSBcIm9iamVjdFwiICYmIChlcnJvci5zdGF0dXNDb2RlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnN0YXR1c0NvZGUgPT09IFwibnVtYmVyXCIpICYmIChlcnJvci5yZXNwb25zZUhlYWRlcnMgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IucmVzcG9uc2VIZWFkZXJzID09PSBcIm9iamVjdFwiKSAmJiAoZXJyb3IucmVzcG9uc2VCb2R5ID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnJlc3BvbnNlQm9keSA9PT0gXCJzdHJpbmdcIikgJiYgKGVycm9yLmNhdXNlID09IG51bGwgfHwgdHlwZW9mIGVycm9yLmNhdXNlID09PSBcIm9iamVjdFwiKSAmJiB0eXBlb2YgZXJyb3IuaXNSZXRyeWFibGUgPT09IFwiYm9vbGVhblwiICYmIChlcnJvci5kYXRhID09IG51bGwgfHwgdHlwZW9mIGVycm9yLmRhdGEgPT09IFwib2JqZWN0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB0aGlzLnJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzOiB0aGlzLnJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdGhpcy5yZXNwb25zZUJvZHksXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIGlzUmV0cnlhYmxlOiB0aGlzLmlzUmV0cnlhYmxlLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHNyYy9lcnJvcnMvZW1wdHktcmVzcG9uc2UtYm9keS1lcnJvci50c1xudmFyIG5hbWUyID0gXCJBSV9FbXB0eVJlc3BvbnNlQm9keUVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBFbXB0eVJlc3BvbnNlQm9keUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSA9IFwiRW1wdHkgcmVzcG9uc2UgYm9keVwiIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzRW1wdHlSZXNwb25zZUJvZHlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUyO1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcblxuLy8gc3JjL2Vycm9ycy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtYXJndW1lbnQtZXJyb3IudHNcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2UsXG4gICAgYXJndW1lbnRcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1wcm9tcHQtZXJyb3IudHNcbnZhciBuYW1lNCA9IFwiQUlfSW52YWxpZFByb21wdEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBJbnZhbGlkUHJvbXB0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcHJvbXB0OiBwcm9tcHQyLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2U6IGBJbnZhbGlkIHByb21wdDogJHttZXNzYWdlfWAsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5wcm9tcHQgPSBwcm9tcHQyO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkUHJvbXB0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNCAmJiBwcm9tcHQgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcHJvbXB0OiB0aGlzLnByb21wdFxuICAgIH07XG4gIH1cbn07XG5fYTUgPSBzeW1ib2w1O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcmVzcG9uc2UtZGF0YS1lcnJvci50c1xudmFyIG5hbWU1ID0gXCJBSV9JbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU1fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2O1xudmFyIEludmFsaWRSZXNwb25zZURhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCByZXNwb25zZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfS5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU1LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTUgJiYgZXJyb3IuZGF0YSAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcblxuLy8gc3JjL2Vycm9ycy9qc29uLXBhcnNlLWVycm9yLnRzXG52YXIgbmFtZTYgPSBcIkFJX0pTT05QYXJzZUVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBKU09OUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdGV4dCwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU2LFxuICAgICAgbWVzc2FnZTogYEpTT04gcGFyc2luZyBmYWlsZWQ6IFRleHQ6ICR7dGV4dH0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNKU09OUGFyc2VFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU2ICYmIFwidGV4dFwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci50ZXh0ID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHZhbHVlVGV4dDogdGhpcy50ZXh0XG4gICAgfTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1hcGkta2V5LWVycm9yLnRzXG52YXIgbmFtZTcgPSBcIkFJX0xvYWRBUElLZXlFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTG9hZEFQSUtleUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc0xvYWRBUElLZXlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU3O1xuICB9XG59O1xuX2E4ID0gc3ltYm9sODtcblxuLy8gc3JjL2Vycm9ycy9sb2FkLXNldHRpbmctZXJyb3IudHNcbnZhciBuYW1lOCA9IFwiQUlfTG9hZFNldHRpbmdFcnJvclwiO1xudmFyIG1hcmtlcjkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTh9YDtcbnZhciBzeW1ib2w5ID0gU3ltYm9sLmZvcihtYXJrZXI5KTtcbnZhciBfYTk7XG52YXIgTG9hZFNldHRpbmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNMb2FkU2V0dGluZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTg7XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBzcmMvZXJyb3JzL25vLWNvbnRlbnQtZ2VuZXJhdGVkLWVycm9yLnRzXG52YXIgbmFtZTkgPSBcIkFJX05vQ29udGVudEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyMTAgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTl9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGNvbnRlbnQgZ2VuZXJhdGVkLlwiXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEwXSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc05vQ29udGVudEdlbmVyYXRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gc3JjL2Vycm9ycy9uby1zdWNoLW1vZGVsLWVycm9yLnRzXG52YXIgbmFtZTEwID0gXCJBSV9Ob1N1Y2hNb2RlbEVycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExO1xudmFyIE5vU3VjaE1vZGVsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZXJyb3JOYW1lID0gbmFtZTEwLFxuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCAke21vZGVsVHlwZX06ICR7bW9kZWxJZH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IGVycm9yTmFtZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMubW9kZWxUeXBlID0gbW9kZWxUeXBlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzTm9TdWNoTW9kZWxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMCAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IubW9kZWxUeXBlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtb2RlbFR5cGU6IHRoaXMubW9kZWxUeXBlXG4gICAgfTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMSAmJiBcInByb3ZpZGVyXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnByb3ZpZGVyID09PSBcInN0cmluZ1wiICYmIFwibW9kZWxJZFwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5tb2RlbElkID09PSBcInN0cmluZ1wiICYmIFwibWF4RW1iZWRkaW5nc1BlckNhbGxcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubWF4RW1iZWRkaW5nc1BlckNhbGwgPT09IFwibnVtYmVyXCIgJiYgXCJ2YWx1ZXNcIiBpbiBlcnJvciAmJiBBcnJheS5pc0FycmF5KGVycm9yLnZhbHVlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzXG4gICAgfTtcbiAgfVxufTtcbl9hMTIgPSBzeW1ib2wxMjtcblxuLy8gc3JjL2Vycm9ycy90eXBlLXZhbGlkYXRpb24tZXJyb3IudHNcbnZhciBuYW1lMTIgPSBcIkFJX1R5cGVWYWxpZGF0aW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMyA9IFN5bWJvbC5mb3IobWFya2VyMTMpO1xudmFyIF9hMTM7XG52YXIgX1R5cGVWYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBfVHlwZVZhbGlkYXRpb25FcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEyLFxuICAgICAgbWVzc2FnZTogYFR5cGUgdmFsaWRhdGlvbiBmYWlsZWQ6IFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTEzXSA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGFuIGVycm9yIGludG8gYSBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKiBJZiB0aGUgY2F1c2UgaXMgYWxyZWFkeSBhIFR5cGVWYWxpZGF0aW9uRXJyb3Igd2l0aCB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyB0aGUgY2F1c2UuXG4gICAqIE90aGVyd2lzZSwgaXQgY3JlYXRlcyBhIG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHdyYXBwaW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMudmFsdWUgLSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMuY2F1c2UgLSBUaGUgb3JpZ2luYWwgZXJyb3Igb3IgY2F1c2Ugb2YgdGhlIHZhbGlkYXRpb24gZmFpbHVyZS5cbiAgICogQHJldHVybnMge1R5cGVWYWxpZGF0aW9uRXJyb3J9IEEgVHlwZVZhbGlkYXRpb25FcnJvciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKHtcbiAgICB2YWx1ZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgcmV0dXJuIF9UeXBlVmFsaWRhdGlvbkVycm9yLmlzSW5zdGFuY2UoY2F1c2UpICYmIGNhdXNlLnZhbHVlID09PSB2YWx1ZSA/IGNhdXNlIDogbmV3IF9UeXBlVmFsaWRhdGlvbkVycm9yKHsgdmFsdWUsIGNhdXNlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1R5cGVWYWxpZGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG59O1xuX2ExMyA9IHN5bWJvbDEzO1xudmFyIFR5cGVWYWxpZGF0aW9uRXJyb3IgPSBfVHlwZVZhbGlkYXRpb25FcnJvcjtcblxuLy8gc3JjL2Vycm9ycy91bnN1cHBvcnRlZC1mdW5jdGlvbmFsaXR5LWVycm9yLnRzXG52YXIgbmFtZTEzID0gXCJBSV9VbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclwiO1xudmFyIG1hcmtlcjE0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxM31gO1xudmFyIHN5bWJvbDE0ID0gU3ltYm9sLmZvcihtYXJrZXIxNCk7XG52YXIgX2ExNDtcbnZhciBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgZnVuY3Rpb25hbGl0eSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEzLFxuICAgICAgbWVzc2FnZTogYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExNF0gPSB0cnVlO1xuICAgIHRoaXMuZnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uYWxpdHk7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc1Vuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEzICYmIHR5cGVvZiBlcnJvci5mdW5jdGlvbmFsaXR5ID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBmdW5jdGlvbmFsaXR5OiB0aGlzLmZ1bmN0aW9uYWxpdHlcbiAgICB9O1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIGlzSlNPTlZhbHVlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJtYXJrZXIiLCJzeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJfYSIsIl9BSVNES0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJuYW1lMTQiLCJtZXNzYWdlIiwiY2F1c2UiLCJpc0luc3RhbmNlIiwiZXJyb3IiLCJoYXNNYXJrZXIiLCJtYXJrZXIxNSIsIm1hcmtlclN5bWJvbCIsInRvSlNPTiIsIkFJU0RLRXJyb3IiLCJtYXJrZXIyIiwic3ltYm9sMiIsIl9hMiIsIkFQSUNhbGxFcnJvciIsInVybCIsInJlcXVlc3RCb2R5VmFsdWVzIiwic3RhdHVzQ29kZSIsInJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlQm9keSIsImlzUmV0cnlhYmxlIiwiZGF0YSIsImlzQVBJQ2FsbEVycm9yIiwibmFtZTIiLCJtYXJrZXIzIiwic3ltYm9sMyIsIl9hMyIsIkVtcHR5UmVzcG9uc2VCb2R5RXJyb3IiLCJpc0VtcHR5UmVzcG9uc2VCb2R5RXJyb3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwibmFtZTMiLCJtYXJrZXI0Iiwic3ltYm9sNCIsIl9hNCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiYXJndW1lbnQiLCJuYW1lNCIsIm1hcmtlcjUiLCJzeW1ib2w1IiwiX2E1IiwiSW52YWxpZFByb21wdEVycm9yIiwicHJvbXB0IiwicHJvbXB0MiIsImlzSW52YWxpZFByb21wdEVycm9yIiwic3RhY2siLCJuYW1lNSIsIm1hcmtlcjYiLCJzeW1ib2w2IiwiX2E2IiwiSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yIiwiaXNJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IiLCJuYW1lNiIsIm1hcmtlcjciLCJzeW1ib2w3IiwiX2E3IiwiSlNPTlBhcnNlRXJyb3IiLCJ0ZXh0IiwiaXNKU09OUGFyc2VFcnJvciIsInZhbHVlVGV4dCIsIm5hbWU3IiwibWFya2VyOCIsInN5bWJvbDgiLCJfYTgiLCJMb2FkQVBJS2V5RXJyb3IiLCJpc0xvYWRBUElLZXlFcnJvciIsIm5hbWU4IiwibWFya2VyOSIsInN5bWJvbDkiLCJfYTkiLCJMb2FkU2V0dGluZ0Vycm9yIiwiaXNMb2FkU2V0dGluZ0Vycm9yIiwibmFtZTkiLCJtYXJrZXIxMCIsInN5bWJvbDEwIiwiX2ExMCIsIk5vQ29udGVudEdlbmVyYXRlZEVycm9yIiwiaXNOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciIsIm5hbWUxMCIsIm1hcmtlcjExIiwic3ltYm9sMTEiLCJfYTExIiwiTm9TdWNoTW9kZWxFcnJvciIsImVycm9yTmFtZSIsIm1vZGVsSWQiLCJtb2RlbFR5cGUiLCJpc05vU3VjaE1vZGVsRXJyb3IiLCJuYW1lMTEiLCJtYXJrZXIxMiIsInN5bWJvbDEyIiwiX2ExMiIsIlRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IiLCJvcHRpb25zIiwicHJvdmlkZXIiLCJtYXhFbWJlZGRpbmdzUGVyQ2FsbCIsInZhbHVlcyIsImxlbmd0aCIsImlzVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsIm5hbWUxMiIsIm1hcmtlcjEzIiwic3ltYm9sMTMiLCJfYTEzIiwiX1R5cGVWYWxpZGF0aW9uRXJyb3IiLCJ2YWx1ZSIsIndyYXAiLCJpc1R5cGVWYWxpZGF0aW9uRXJyb3IiLCJUeXBlVmFsaWRhdGlvbkVycm9yIiwibmFtZTEzIiwibWFya2VyMTQiLCJzeW1ib2wxNCIsIl9hMTQiLCJVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciIsImZ1bmN0aW9uYWxpdHkiLCJpc1Vuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIiwiaXNKU09OVmFsdWUiLCJldmVyeSIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJ2YWwiLCJpc0pTT05BcnJheSIsImlzSlNPTk9iamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n    /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */ constructor({ name: name14, message, cause }){\n        super(message);\n        this[_a] = true;\n        this.name = name14;\n        this.cause = cause;\n    }\n    /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */ static isInstance(error) {\n        return _AISDKError.hasMarker(error, marker);\n    }\n    static hasMarker(error, marker15) {\n        const markerSymbol = Symbol.for(marker15);\n        return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n    }\n    /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message\n        };\n    }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500), // server error\n    data }){\n        super({\n            name,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.requestBodyValues = requestBodyValues;\n        this.statusCode = statusCode;\n        this.responseHeaders = responseHeaders;\n        this.responseBody = responseBody;\n        this.isRetryable = isRetryable;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isAPICallError(error) {\n        return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            requestBodyValues: this.requestBodyValues,\n            statusCode: this.statusCode,\n            responseHeaders: this.responseHeaders,\n            responseBody: this.responseBody,\n            cause: this.cause,\n            isRetryable: this.isRetryable,\n            data: this.data\n        };\n    }\n};\n_a2 = symbol2;\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"Empty response body\" } = {}){\n        super({\n            name: name2,\n            message\n        });\n        this[_a3] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isEmptyResponseBodyError(error) {\n        return error instanceof Error && error.name === name2;\n    }\n};\n_a3 = symbol3;\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n    if (error == null) {\n        return \"unknown error\";\n    }\n    if (typeof error === \"string\") {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return JSON.stringify(error);\n}\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n    constructor({ message, cause, argument }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.argument = argument;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n    constructor({ prompt: prompt2, message, cause }){\n        super({\n            name: name4,\n            message: `Invalid prompt: ${message}`,\n            cause\n        });\n        this[_a5] = true;\n        this.prompt = prompt2;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidPromptError(error) {\n        return error instanceof Error && error.name === name4 && prompt != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            prompt: this.prompt\n        };\n    }\n};\n_a5 = symbol5;\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n    constructor({ data, message = `Invalid response data: ${JSON.stringify(data)}.` }){\n        super({\n            name: name5,\n            message\n        });\n        this[_a6] = true;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker6);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidResponseDataError(error) {\n        return error instanceof Error && error.name === name5 && error.data != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            data: this.data\n        };\n    }\n};\n_a6 = symbol6;\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n    constructor({ text, cause }){\n        super({\n            name: name6,\n            message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a7] = true;\n        this.text = text;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isJSONParseError(error) {\n        return error instanceof Error && error.name === name6 && \"text\" in error && typeof error.text === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            valueText: this.text\n        };\n    }\n};\n_a7 = symbol7;\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a8] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isLoadAPIKeyError(error) {\n        return error instanceof Error && error.name === name7;\n    }\n};\n_a8 = symbol8;\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name8,\n            message\n        });\n        this[_a9] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker9);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isLoadSettingError(error) {\n        return error instanceof Error && error.name === name8;\n    }\n};\n_a9 = symbol9;\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"No content generated.\" } = {}){\n        super({\n            name: name9,\n            message\n        });\n        this[_a10] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker10);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isNoContentGeneratedError(error) {\n        return error instanceof Error && error.name === name9;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            cause: this.cause,\n            message: this.message,\n            stack: this.stack\n        };\n    }\n};\n_a10 = symbol10;\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n    constructor({ errorName = name10, modelId, modelType, message = `No such ${modelType}: ${modelId}` }){\n        super({\n            name: errorName,\n            message\n        });\n        this[_a11] = true;\n        this.modelId = modelId;\n        this.modelType = modelType;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker11);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchModelError(error) {\n        return error instanceof Error && error.name === name10 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            modelId: this.modelId,\n            modelType: this.modelType\n        };\n    }\n};\n_a11 = symbol11;\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n    constructor(options){\n        super({\n            name: name11,\n            message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n        });\n        this[_a12] = true;\n        this.provider = options.provider;\n        this.modelId = options.modelId;\n        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n        this.values = options.values;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker12);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isTooManyEmbeddingValuesForCallError(error) {\n        return error instanceof Error && error.name === name11 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            provider: this.provider,\n            modelId: this.modelId,\n            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n            values: this.values\n        };\n    }\n};\n_a12 = symbol12;\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n    constructor({ value, cause }){\n        super({\n            name: name12,\n            message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a13] = true;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker13);\n    }\n    /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */ static wrap({ value, cause }) {\n        return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({\n            value,\n            cause\n        });\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isTypeValidationError(error) {\n        return error instanceof Error && error.name === name12;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            value: this.value\n        };\n    }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n    constructor({ functionality }){\n        super({\n            name: name13,\n            message: `'${functionality}' functionality not supported.`\n        });\n        this[_a14] = true;\n        this.functionality = functionality;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker14);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isUnsupportedFunctionalityError(error) {\n        return error instanceof Error && error.name === name13 && typeof error.functionality === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            functionality: this.functionality\n        };\n    }\n};\n_a14 = symbol14;\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n    if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.every(isJSONValue);\n    }\n    if (typeof value === \"object\") {\n        return Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n    }\n    return false;\n}\nfunction isJSONArray(value) {\n    return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n    return value != null && typeof value === \"object\" && Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AYWktc2RrK3Byb3ZpZGVyQDAuMC4yNi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsSUFBSUEsU0FBUztBQUNiLElBQUlDLFNBQVNDLE9BQU9DLEdBQUcsQ0FBQ0g7QUFDeEIsSUFBSUk7QUFDSixJQUFJQyxjQUFjLE1BQU1BLG9CQUFvQkM7SUFDMUM7Ozs7Ozs7R0FPQyxHQUNEQyxZQUFZLEVBQ1ZDLE1BQU1DLE1BQU0sRUFDWkMsT0FBTyxFQUNQQyxLQUFLLEVBQ04sQ0FBRTtRQUNELEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNOLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0ksSUFBSSxHQUFHQztRQUNaLElBQUksQ0FBQ0UsS0FBSyxHQUFHQTtJQUNmO0lBQ0E7Ozs7R0FJQyxHQUNELE9BQU9DLFdBQVdDLEtBQUssRUFBRTtRQUN2QixPQUFPUixZQUFZUyxTQUFTLENBQUNELE9BQU9iO0lBQ3RDO0lBQ0EsT0FBT2MsVUFBVUQsS0FBSyxFQUFFRSxRQUFRLEVBQUU7UUFDaEMsTUFBTUMsZUFBZWQsT0FBT0MsR0FBRyxDQUFDWTtRQUNoQyxPQUFPRixTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZRyxnQkFBZ0JILFNBQVMsT0FBT0EsS0FBSyxDQUFDRyxhQUFhLEtBQUssYUFBYUgsS0FBSyxDQUFDRyxhQUFhLEtBQUs7SUFDcEo7SUFDQTs7Ozs7R0FLQyxHQUNEQyxTQUFTO1FBQ1AsT0FBTztZQUNMVCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmRSxTQUFTLElBQUksQ0FBQ0EsT0FBTztRQUN2QjtJQUNGO0FBQ0Y7QUFDQU4sS0FBS0g7QUFDTCxJQUFJaUIsYUFBYWI7QUFFakIsK0JBQStCO0FBQy9CLElBQUlHLE9BQU87QUFDWCxJQUFJVyxVQUFVLENBQUMsZ0JB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LE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFdBQVc7UUFDMUcsT0FBTztJQUNUO0lBQ0EsSUFBSVAsTUFBTUMsT0FBTyxDQUFDTSxRQUFRO1FBQ3hCLE9BQU9BLE1BQU1ZLEtBQUssQ0FBQ0Q7SUFDckI7SUFDQSxJQUFJLE9BQU9YLFVBQVUsVUFBVTtRQUM3QixPQUFPYSxPQUFPQyxPQUFPLENBQUNkLE9BQU9ZLEtBQUssQ0FDaEMsQ0FBQyxDQUFDRyxLQUFLQyxJQUFJLEdBQUssT0FBT0QsUUFBUSxZQUFZSixZQUFZSztJQUUzRDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLFlBQVlqQixLQUFLO0lBQ3hCLE9BQU9QLE1BQU1DLE9BQU8sQ0FBQ00sVUFBVUEsTUFBTVksS0FBSyxDQUFDRDtBQUM3QztBQUNBLFNBQVNPLGFBQWFsQixLQUFLO0lBQ3pCLE9BQU9BLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVlhLE9BQU9DLE9BQU8sQ0FBQ2QsT0FBT1ksS0FBSyxDQUM5RSxDQUFDLENBQUNHLEtBQUtDLElBQUksR0FBSyxPQUFPRCxRQUFRLFlBQVlKLFlBQVlLO0FBRTNEO0FBb0JFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VudGluZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGFpLXNkaytwcm92aWRlckAwLjAuMjYvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanM/YjNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3JzL2FpLXNkay1lcnJvci50c1xudmFyIG1hcmtlciA9IFwidmVyY2VsLmFpLmVycm9yXCI7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIF9BSVNES0Vycm9yID0gY2xhc3MgX0FJU0RLRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEFJIFNESyBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5tZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gW3BhcmFtcy5jYXVzZV0gLSBUaGUgdW5kZXJseWluZyBjYXVzZSBvZiB0aGUgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTE0LFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lMTQ7XG4gICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGFuIEFJIFNESyBFcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gX0FJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIHN0YXRpYyBoYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE1KSB7XG4gICAgY29uc3QgbWFya2VyU3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIxNSk7XG4gICAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIG1hcmtlclN5bWJvbCBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gXCJib29sZWFuXCIgJiYgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXJyb3IncyBuYW1lLCBtZXNzYWdlLCBhbmQgY2F1c2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuX2EgPSBzeW1ib2w7XG52YXIgQUlTREtFcnJvciA9IF9BSVNES0Vycm9yO1xuXG4vLyBzcmMvZXJyb3JzL2FwaS1jYWxsLWVycm9yLnRzXG52YXIgbmFtZSA9IFwiQUlfQVBJQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIEFQSUNhbGxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHVybCxcbiAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICByZXNwb25zZUJvZHksXG4gICAgY2F1c2UsXG4gICAgaXNSZXRyeWFibGUgPSBzdGF0dXNDb2RlICE9IG51bGwgJiYgKHN0YXR1c0NvZGUgPT09IDQwOCB8fCAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICBzdGF0dXNDb2RlID09PSA0MDkgfHwgLy8gY29uZmxpY3RcbiAgICBzdGF0dXNDb2RlID09PSA0MjkgfHwgLy8gdG9vIG1hbnkgcmVxdWVzdHNcbiAgICBzdGF0dXNDb2RlID49IDUwMCksXG4gICAgLy8gc2VydmVyIGVycm9yXG4gICAgZGF0YVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMl0gPSB0cnVlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMucmVxdWVzdEJvZHlWYWx1ZXMgPSByZXF1ZXN0Qm9keVZhbHVlcztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzO1xuICAgIHRoaXMucmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5O1xuICAgIHRoaXMuaXNSZXRyeWFibGUgPSBpc1JldHJ5YWJsZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc0FQSUNhbGxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUgJiYgdHlwZW9mIGVycm9yLnVybCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IucmVxdWVzdEJvZHlWYWx1ZXMgPT09IFwib2JqZWN0XCIgJiYgKGVycm9yLnN0YXR1c0NvZGUgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzQ29kZSA9PT0gXCJudW1iZXJcIikgJiYgKGVycm9yLnJlc3BvbnNlSGVhZGVycyA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5yZXNwb25zZUhlYWRlcnMgPT09IFwib2JqZWN0XCIpICYmIChlcnJvci5yZXNwb25zZUJvZHkgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IucmVzcG9uc2VCb2R5ID09PSBcInN0cmluZ1wiKSAmJiAoZXJyb3IuY2F1c2UgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IuY2F1c2UgPT09IFwib2JqZWN0XCIpICYmIHR5cGVvZiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gXCJib29sZWFuXCIgJiYgKGVycm9yLmRhdGEgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IuZGF0YSA9PT0gXCJvYmplY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHRoaXMucmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICByZXNwb25zZUhlYWRlcnM6IHRoaXMucmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5OiB0aGlzLnJlc3BvbnNlQm9keSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgaXNSZXRyeWFibGU6IHRoaXMuaXNSZXRyeWFibGUsXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9O1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNFbXB0eVJlc3BvbnNlQm9keUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTI7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3JzL2dldC1lcnJvci1tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG59XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkQXJndW1lbnRFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgSW52YWxpZEFyZ3VtZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZSxcbiAgICBhcmd1bWVudFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjQpO1xuICB9XG59O1xuX2E0ID0gc3ltYm9sNDtcblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLXByb21wdC1lcnJvci50c1xudmFyIG5hbWU0ID0gXCJBSV9JbnZhbGlkUHJvbXB0RXJyb3JcIjtcbnZhciBtYXJrZXI1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNSA9IFN5bWJvbC5mb3IobWFya2VyNSk7XG52YXIgX2E1O1xudmFyIEludmFsaWRQcm9tcHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwcm9tcHQ6IHByb21wdDIsXG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZTogYEludmFsaWQgcHJvbXB0OiAke21lc3NhZ2V9YCwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnByb21wdCA9IHByb21wdDI7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRQcm9tcHRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU0ICYmIHByb21wdCAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwcm9tcHQ6IHRoaXMucHJvbXB0XG4gICAgfTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1yZXNwb25zZS1kYXRhLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNSAmJiBlcnJvci5kYXRhICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBzcmMvZXJyb3JzL2pzb24tcGFyc2UtZXJyb3IudHNcbnZhciBuYW1lNiA9IFwiQUlfSlNPTlBhcnNlRXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIEpTT05QYXJzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB0ZXh0LCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTYsXG4gICAgICBtZXNzYWdlOiBgSlNPTiBwYXJzaW5nIGZhaWxlZDogVGV4dDogJHt0ZXh0fS5cbkVycm9yIG1lc3NhZ2U6ICR7Z2V0RXJyb3JNZXNzYWdlKGNhdXNlKX1gLFxuICAgICAgY2F1c2VcbiAgICB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjcpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0pTT05QYXJzZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTYgJiYgXCJ0ZXh0XCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnRleHQgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgdmFsdWVUZXh0OiB0aGlzLnRleHRcbiAgICB9O1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gc3JjL2Vycm9ycy9sb2FkLWFwaS1rZXktZXJyb3IudHNcbnZhciBuYW1lNyA9IFwiQUlfTG9hZEFQSUtleUVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hODtcbnZhciBMb2FkQVBJS2V5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU3LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E4XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjgpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzTG9hZEFQSUtleUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTc7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtc2V0dGluZy1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Mb2FkU2V0dGluZ0Vycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBMb2FkU2V0dGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGlzSW5zdGFuY2UgaW5zdGVhZC5cbiAgICovXG4gIHN0YXRpYyBpc0xvYWRTZXR0aW5nRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lODtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tY29udGVudC1nZW5lcmF0ZWQtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzTm9Db250ZW50R2VuZXJhdGVkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICB9O1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBzcmMvZXJyb3JzL25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lMTAsXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hNb2RlbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEwICYmIHR5cGVvZiBlcnJvci5tb2RlbElkID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5tb2RlbFR5cGUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsVHlwZTogdGhpcy5tb2RlbFR5cGVcbiAgICB9O1xuICB9XG59O1xuX2ExMSA9IHN5bWJvbDExO1xuXG4vLyBzcmMvZXJyb3JzL3Rvby1tYW55LWVtYmVkZGluZy12YWx1ZXMtZm9yLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lMTEgPSBcIkFJX1Rvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTF9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTEsXG4gICAgICBtZXNzYWdlOiBgVG9vIG1hbnkgdmFsdWVzIGZvciBhIHNpbmdsZSBlbWJlZGRpbmcgY2FsbC4gVGhlICR7b3B0aW9ucy5wcm92aWRlcn0gbW9kZWwgXCIke29wdGlvbnMubW9kZWxJZH1cIiBjYW4gb25seSBlbWJlZCB1cCB0byAke29wdGlvbnMubWF4RW1iZWRkaW5nc1BlckNhbGx9IHZhbHVlcyBwZXIgY2FsbCwgYnV0ICR7b3B0aW9ucy52YWx1ZXMubGVuZ3RofSB2YWx1ZXMgd2VyZSBwcm92aWRlZC5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlciA9IG9wdGlvbnMucHJvdmlkZXI7XG4gICAgdGhpcy5tb2RlbElkID0gb3B0aW9ucy5tb2RlbElkO1xuICAgIHRoaXMubWF4RW1iZWRkaW5nc1BlckNhbGwgPSBvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTExICYmIFwicHJvdmlkZXJcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IucHJvdmlkZXIgPT09IFwic3RyaW5nXCIgJiYgXCJtb2RlbElkXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1vZGVsSWQgPT09IFwic3RyaW5nXCIgJiYgXCJtYXhFbWJlZGRpbmdzUGVyQ2FsbFwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5tYXhFbWJlZGRpbmdzUGVyQ2FsbCA9PT0gXCJudW1iZXJcIiAmJiBcInZhbHVlc1wiIGluIGVycm9yICYmIEFycmF5LmlzQXJyYXkoZXJyb3IudmFsdWVzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtYXhFbWJlZGRpbmdzUGVyQ2FsbDogdGhpcy5tYXhFbWJlZGRpbmdzUGVyQ2FsbCxcbiAgICAgIHZhbHVlczogdGhpcy52YWx1ZXNcbiAgICB9O1xuICB9XG59O1xuX2ExMiA9IHN5bWJvbDEyO1xuXG4vLyBzcmMvZXJyb3JzL3R5cGUtdmFsaWRhdGlvbi1lcnJvci50c1xudmFyIG5hbWUxMiA9IFwiQUlfVHlwZVZhbGlkYXRpb25FcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMn1gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBfVHlwZVZhbGlkYXRpb25FcnJvciA9IGNsYXNzIF9UeXBlVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdmFsdWUsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTIsXG4gICAgICBtZXNzYWdlOiBgVHlwZSB2YWxpZGF0aW9uIGZhaWxlZDogVmFsdWU6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfS5cbkVycm9yIG1lc3NhZ2U6ICR7Z2V0RXJyb3JNZXNzYWdlKGNhdXNlKX1gLFxuICAgICAgY2F1c2VcbiAgICB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEzKTtcbiAgfVxuICAvKipcbiAgICogV3JhcHMgYW4gZXJyb3IgaW50byBhIFR5cGVWYWxpZGF0aW9uRXJyb3IuXG4gICAqIElmIHRoZSBjYXVzZSBpcyBhbHJlYWR5IGEgVHlwZVZhbGlkYXRpb25FcnJvciB3aXRoIHRoZSBzYW1lIHZhbHVlLCBpdCByZXR1cm5zIHRoZSBjYXVzZS5cbiAgICogT3RoZXJ3aXNlLCBpdCBjcmVhdGVzIGEgbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3Igd3JhcHBpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBhcmFtcy52YWx1ZSAtIFRoZSB2YWx1ZSB0aGF0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBhcmFtcy5jYXVzZSAtIFRoZSBvcmlnaW5hbCBlcnJvciBvciBjYXVzZSBvZiB0aGUgdmFsaWRhdGlvbiBmYWlsdXJlLlxuICAgKiBAcmV0dXJucyB7VHlwZVZhbGlkYXRpb25FcnJvcn0gQSBUeXBlVmFsaWRhdGlvbkVycm9yIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIHdyYXAoe1xuICAgIHZhbHVlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICByZXR1cm4gX1R5cGVWYWxpZGF0aW9uRXJyb3IuaXNJbnN0YW5jZShjYXVzZSkgJiYgY2F1c2UudmFsdWUgPT09IHZhbHVlID8gY2F1c2UgOiBuZXcgX1R5cGVWYWxpZGF0aW9uRXJyb3IoeyB2YWx1ZSwgY2F1c2UgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzVHlwZVZhbGlkYXRpb25FcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbn07XG5fYTEzID0gc3ltYm9sMTM7XG52YXIgVHlwZVZhbGlkYXRpb25FcnJvciA9IF9UeXBlVmFsaWRhdGlvbkVycm9yO1xuXG4vLyBzcmMvZXJyb3JzL3Vuc3VwcG9ydGVkLWZ1bmN0aW9uYWxpdHktZXJyb3IudHNcbnZhciBuYW1lMTMgPSBcIkFJX1Vuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yXCI7XG52YXIgbWFya2VyMTQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEzfWA7XG52YXIgc3ltYm9sMTQgPSBTeW1ib2wuZm9yKG1hcmtlcjE0KTtcbnZhciBfYTE0O1xudmFyIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyBmdW5jdGlvbmFsaXR5IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTMsXG4gICAgICBtZXNzYWdlOiBgJyR7ZnVuY3Rpb25hbGl0eX0nIGZ1bmN0aW9uYWxpdHkgbm90IHN1cHBvcnRlZC5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTMgJiYgdHlwZW9mIGVycm9yLmZ1bmN0aW9uYWxpdHkgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IHRoaXMuZnVuY3Rpb25hbGl0eVxuICAgIH07XG4gIH1cbn07XG5fYTE0ID0gc3ltYm9sMTQ7XG5cbi8vIHNyYy9qc29uLXZhbHVlL2lzLWpzb24udHNcbmZ1bmN0aW9uIGlzSlNPTlZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuZXZlcnkoaXNKU09OVmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModmFsdWUpLmV2ZXJ5KFxuICAgICAgKFtrZXksIHZhbF0pID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgaXNKU09OVmFsdWUodmFsKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNKU09OQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzSlNPTk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmVudHJpZXModmFsdWUpLmV2ZXJ5KFxuICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgKTtcbn1cbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IsXG4gIEFQSUNhbGxFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBMb2FkU2V0dGluZ0Vycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgaXNKU09OVmFsdWVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIm1hcmtlciIsInN5bWJvbCIsIlN5bWJvbCIsImZvciIsIl9hIiwiX0FJU0RLRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm5hbWUxNCIsIm1lc3NhZ2UiLCJjYXVzZSIsImlzSW5zdGFuY2UiLCJlcnJvciIsImhhc01hcmtlciIsIm1hcmtlcjE1IiwibWFya2VyU3ltYm9sIiwidG9KU09OIiwiQUlTREtFcnJvciIsIm1hcmtlcjIiLCJzeW1ib2wyIiwiX2EyIiwiQVBJQ2FsbEVycm9yIiwidXJsIiwicmVxdWVzdEJvZHlWYWx1ZXMiLCJzdGF0dXNDb2RlIiwicmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VCb2R5IiwiaXNSZXRyeWFibGUiLCJkYXRhIiwiaXNBUElDYWxsRXJyb3IiLCJuYW1lMiIsIm1hcmtlcjMiLCJzeW1ib2wzIiwiX2EzIiwiRW1wdHlSZXNwb25zZUJvZHlFcnJvciIsImlzRW1wdHlSZXNwb25zZUJvZHlFcnJvciIsImdldEVycm9yTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJuYW1lMyIsIm1hcmtlcjQiLCJzeW1ib2w0IiwiX2E0IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJhcmd1bWVudCIsIm5hbWU0IiwibWFya2VyNSIsInN5bWJvbDUiLCJfYTUiLCJJbnZhbGlkUHJvbXB0RXJyb3IiLCJwcm9tcHQiLCJwcm9tcHQyIiwiaXNJbnZhbGlkUHJvbXB0RXJyb3IiLCJzdGFjayIsIm5hbWU1IiwibWFya2VyNiIsInN5bWJvbDYiLCJfYTYiLCJJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IiLCJpc0ludmFsaWRSZXNwb25zZURhdGFFcnJvciIsIm5hbWU2IiwibWFya2VyNyIsInN5bWJvbDciLCJfYTciLCJKU09OUGFyc2VFcnJvciIsInRleHQiLCJpc0pTT05QYXJzZUVycm9yIiwidmFsdWVUZXh0IiwibmFtZTciLCJtYXJrZXI4Iiwic3ltYm9sOCIsIl9hOCIsIkxvYWRBUElLZXlFcnJvciIsImlzTG9hZEFQSUtleUVycm9yIiwibmFtZTgiLCJtYXJrZXI5Iiwic3ltYm9sOSIsIl9hOSIsIkxvYWRTZXR0aW5nRXJyb3IiLCJpc0xvYWRTZXR0aW5nRXJyb3IiLCJuYW1lOSIsIm1hcmtlcjEwIiwic3ltYm9sMTAiLCJfYTEwIiwiTm9Db250ZW50R2VuZXJhdGVkRXJyb3IiLCJpc05vQ29udGVudEdlbmVyYXRlZEVycm9yIiwibmFtZTEwIiwibWFya2VyMTEiLCJzeW1ib2wxMSIsIl9hMTEiLCJOb1N1Y2hNb2RlbEVycm9yIiwiZXJyb3JOYW1lIiwibW9kZWxJZCIsIm1vZGVsVHlwZSIsImlzTm9TdWNoTW9kZWxFcnJvciIsIm5hbWUxMSIsIm1hcmtlcjEyIiwic3ltYm9sMTIiLCJfYTEyIiwiVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvciIsIm9wdGlvbnMiLCJwcm92aWRlciIsIm1heEVtYmVkZGluZ3NQZXJDYWxsIiwidmFsdWVzIiwibGVuZ3RoIiwiaXNUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwibmFtZTEyIiwibWFya2VyMTMiLCJzeW1ib2wxMyIsIl9hMTMiLCJfVHlwZVZhbGlkYXRpb25FcnJvciIsInZhbHVlIiwid3JhcCIsImlzVHlwZVZhbGlkYXRpb25FcnJvciIsIlR5cGVWYWxpZGF0aW9uRXJyb3IiLCJuYW1lMTMiLCJtYXJrZXIxNCIsInN5bWJvbDE0IiwiX2ExNCIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIiwiZnVuY3Rpb25hbGl0eSIsImlzVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IiLCJpc0pTT05WYWx1ZSIsImV2ZXJ5IiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInZhbCIsImlzSlNPTkFycmF5IiwiaXNKU09OT2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ })

};
;