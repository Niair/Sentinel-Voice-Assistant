"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-view@1.41.5";
exports.ids = ["vendor-chunks/prosemirror-view@1.41.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/prosemirror-view@1.41.5/node_modules/prosemirror-view/dist/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/prosemirror-view@1.41.5/node_modules/prosemirror-view/dist/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   DecorationSet: () => (/* binding */ DecorationSet),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   __endComposition: () => (/* binding */ __endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* binding */ __parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/.pnpm/prosemirror-state@1.4.4/node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/.pnpm/prosemirror-model@1.25.4/node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/.pnpm/prosemirror-transform@1.10.5/node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst domIndex = function(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n};\nconst parentNode = function(node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function(node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\nconst clearReusedRange = function() {\n    reusedRange = null;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function(node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    var _a;\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\") return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            let child = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (child.nodeType == 1 && child.contentEditable == \"false\") {\n                if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection) off += dir;\n                else return false;\n            } else {\n                node = child;\n                off = dir < 0 ? nodeSize(node) : 0;\n            }\n        } else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction textNodeBefore$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset) return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter$1(node, offset) {\n    for(;;){\n        if (node.nodeType == 3 && offset < node.nodeValue.length) return node;\n        if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        } else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction isOnEdge(node, offset, parent) {\n    for(let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;){\n        if (node == parent) return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node) return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for(let cur = dom; cur; cur = cur.parentNode)if (desc = cur.pmViewDesc) break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function(domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try {\n            let pos = doc.caretPositionFromPoint(x, y);\n            // Clip the offset, because Chrome will return a text offset\n            // into <input> nodes, which can't be treated as a regular DOM\n            // offset\n            if (pos) return {\n                node: pos.offsetNode,\n                offset: Math.min(nodeSize(pos.offsetNode), pos.offset)\n            };\n        } catch (_) {}\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range) return {\n            node: range.startContainer,\n            offset: Math.min(nodeSize(range.startContainer), range.startOffset)\n        };\n    }\n}\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = nav && nav.userAgent || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [\n    0,\n    0\n])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n    0,\n    0\n])[1] : 0;\nfunction windowRect(doc) {\n    let vp = doc.defaultView && doc.defaultView.visualViewport;\n    if (vp) return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n    };\n    return {\n        left: 0,\n        right: doc.documentElement.clientWidth,\n        top: 0,\n        bottom: doc.documentElement.clientHeight\n    };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = rect.width / node.offsetWidth || 1;\n    let scaleY = rect.height / node.offsetHeight || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return {\n        left: rect.left,\n        right: rect.left + node.clientWidth * scaleX,\n        top: rect.top,\n        bottom: rect.top + node.clientHeight * scaleY\n    };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for(let parent = startDOM || view.dom;;){\n        if (!parent) break;\n        if (parent.nodeType != 1) {\n            parent = parentNode(parent);\n            continue;\n        }\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\")) moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            } else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY) elt.scrollTop += moveY;\n                if (moveX) elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = {\n                    left: rect.left - dX,\n                    top: rect.top - dY,\n                    right: rect.right - dX,\n                    bottom: rect.bottom - dY\n                };\n            }\n        }\n        let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n        if (/^(fixed|sticky)$/.test(pos)) break;\n        parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for(let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5){\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return {\n        refDOM: refDOM,\n        refTop: refTop,\n        stack: scrollStack(view.dom)\n    };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for(let cur = dom; cur; cur = parentNode(cur)){\n        stack.push({\n            dom: cur,\n            top: cur.scrollTop,\n            left: cur.scrollLeft\n        });\n        if (dom == doc) break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for(let i = 0; i < stack.length; i++){\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left) dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for(let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++){\n        let rects;\n        if (child.nodeType == 1) rects = child.getClientRects();\n        else if (child.nodeType == 3) rects = textRange(child).getClientRects();\n        else continue;\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = {\n                    left: Math.max(rect.left, Math.min(rect.right, coords.left)),\n                    top: rect.top\n                };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n    if (!closest || dxClosest && closest.nodeType == 1) return {\n        node,\n        offset\n    };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange(), result;\n    for(let i = 0; i < len; i++){\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom) continue;\n        if (inRect(coords, rect)) {\n            result = {\n                node,\n                offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n            };\n            break;\n        }\n    }\n    range.detach();\n    return result || {\n        node,\n        offset: 0\n    };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for(let cur = node, sawBlock = false;;){\n        if (cur == view.dom) break;\n        let desc = view.docView.nearestDesc(cur, true), rect;\n        if (!desc) return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles\n        ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n            if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {\n                // Only apply the horizontal test to the innermost block. Vertical for any parent.\n                if (!sawBlock && rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;\n                else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;\n                sawBlock = true;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for(let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;){\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for(let j = 0; j < rects.length; j++){\n                    let rect = rects[j];\n                    if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI) break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret) ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box)) return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt) return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for(let p = elt; node && p; p = parentNode(p))if (p.draggable) node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top) offset++;\n            }\n        }\n        let prev;\n        // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.\n        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top) offset--;\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\") pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null) pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return {\n        pos,\n        inside: desc ? desc.posAtStart - desc.border : -1\n    };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first)) return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        } else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            } else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            } else if (side < 0) {\n                from--;\n            } else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target) return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while(after.pmViewDesc && after.pmViewDesc.ignoreForCoords)after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n        if (target) return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0) return rect;\n    let x = left ? rect.left : rect.right;\n    return {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: x,\n        right: x\n    };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0) return rect;\n    let y = top ? rect.top : rect.bottom;\n    return {\n        top: y,\n        bottom: y,\n        left: rect.left,\n        right: rect.right\n    };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state) view.updateState(state);\n    if (active != view.dom) view.focus();\n    try {\n        return f();\n    } finally{\n        if (viewState != state) view.updateState(viewState);\n        if (active != view.dom && active) active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, ()=>{\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for(;;){\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest) break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for(let child = dom.firstChild; child; child = child.nextSibling){\n            let boxes;\n            if (child.nodeType == 1) boxes = child.getClientRects();\n            else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else continue;\n            for(let i = 0; i < boxes.length; i++){\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock) return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    if (!sel) return $head.pos == $head.start() || $head.pos == $head.end();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, ()=>{\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);\n        } catch (_) {}\n        if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir) return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM){\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) {\n        return false;\n    }\n    matchesMark(mark) {\n        return false;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return false;\n    }\n    matchesHack(nodeName) {\n        return false;\n    }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() {\n        return null;\n    }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) {\n        return false;\n    }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for(let i = 0; i < this.children.length; i++)size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() {\n        return 0;\n    }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;\n        for(let i = 0; i < this.children.length; i++)this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for(let i = 0, pos = this.posAtStart;; i++){\n            let cur = this.children[i];\n            if (cur == child) return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while(domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            } else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while(domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        } else if (this.dom.firstChild) {\n            if (offset == 0) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = false;\n                    break;\n                }\n                if (search.previousSibling) break;\n            }\n            if (atEnd == null && offset == dom.childNodes.length) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = true;\n                    break;\n                }\n                if (search.nextSibling) break;\n            }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for(let first = true, cur = dom; cur; cur = cur.parentNode){\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;\n                else return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for(let cur = desc; cur; cur = cur.parent)if (cur == this) return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for(let scan = dom; scan; scan = scan.parentNode){\n            let desc = this.getDesc(scan);\n            if (desc) return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while(!child.border && child.children.length){\n                    for(let i = 0; i < child.children.length; i++){\n                        let inner = child.children[i];\n                        if (inner.size) {\n                            child = inner;\n                            break;\n                        }\n                    }\n                }\n                return child;\n            }\n            if (pos < end) return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM) return {\n            node: this.dom,\n            offset: 0,\n            atom: pos + 1\n        };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for(let curPos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for(let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--){}\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for(;; i--, enter = false){\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM) break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom) return prev.domFromPos(prev.size, side);\n            return {\n                node: this.contentDOM,\n                offset: prev ? domIndex(prev.dom) + 1 : 0\n            };\n        } else {\n            let next, enter = true;\n            for(;; i++, enter = false){\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM) break;\n            }\n            if (next && enter && !next.border && !next.domAtom) return next.domFromPos(0, side);\n            return {\n                node: this.contentDOM,\n                offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length\n            };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0) return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset: 0,\n            toOffset: this.contentDOM.childNodes.length\n        };\n        let fromOffset = -1, toOffset = -1;\n        for(let offset = base, i = 0;; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);\n                from = offset;\n                for(let j = i; j > 0; j--){\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1) fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for(let j = i + 1; j < this.children.length; j++){\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset,\n            toOffset\n        };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length) return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, view, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = view.root.getSelection();\n        let selRange = view.domSelectionRange();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for(let scan = node, after; scan; scan = scan.parentNode){\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\") anchorDOM = headDOM = {\n                                node: after.parentNode,\n                                offset: domIndex(after) + 1\n                            };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock) break;\n                    }\n                }\n            } else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n            let after = selRange.focusNode.childNodes[selRange.focusOffset];\n            if (after && after.contentEditable == \"false\") force = true;\n        }\n        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset)) return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            } catch (_) {\n            // In some cases with Chrome the selection is empty after calling\n            // collapse, even when it should be valid. This appears to be a bug, but\n            // it is difficult to isolate. If this happens fallback to the old path\n            // without using extend.\n            // Similarly, this could crash on Safari if the editor is hidden, and\n            // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for(let offset = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;\n                    else child.markDirty(from - startInside, to - startInside);\n                    return;\n                } else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for(let node = this.parent; node; node = node.parent, level++){\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty) node.dirty = dirty;\n        }\n    }\n    get domAtom() {\n        return false;\n    }\n    get ignoreForCoords() {\n        return false;\n    }\n    get ignoreForSelection() {\n        return false;\n    }\n    isText(text) {\n        return false;\n    }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos){\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\") dom = dom(view, ()=>{\n            if (!self) return pos;\n            if (self.parent) return self.parent.posBeforeChild(self);\n        });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() {\n        return true;\n    }\n    get ignoreForSelection() {\n        return !!this.widget.type.spec.relaxedSide;\n    }\n    get side() {\n        return this.widget.type.side;\n    }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text){\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() {\n        return this.text.length;\n    }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.textDOM,\n            offset: pos\n        };\n    }\n    ignoreMutation(mut) {\n        return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM, spec){\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n        this.spec = spec;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom) spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n    }\n    parseRule() {\n        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;\n        return {\n            mark: this.mark.type.name,\n            attrs: this.mark.attrs,\n            contentElement: this.contentDOM\n        };\n    }\n    matchesMark(mark) {\n        return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while(!parent.node)parent = parent.parent;\n            if (parent.dirty < this.dirty) parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size) nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0) nodes = replaceNodes(nodes, 0, from, view);\n        for(let i = 0; i < nodes.length; i++)nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos){\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, ()=>{\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj) return pos;\n            if (descObj.parent) return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom) dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\");\n        } else if (!dom) {\n            let spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n            ({ dom, contentDOM } = spec);\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n            if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = \"false\";\n            if (node.type.spec.draggable) dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView) return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = {\n            node: this.node.type.name,\n            attrs: this.node.attrs\n        };\n        if (this.node.type.whitespace == \"pre\") rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = ()=>this.node.content;\n        } else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        } else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for(let i = this.children.length - 1; i >= 0; i--){\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement) rule.getContent = ()=>prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get border() {\n        return this.node.isLeaf ? 0 : 1;\n    }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode)=>{\n            if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view, i);\n            else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view, i);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i)=>{\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view, i);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view, 0);\n        if (this.node.isTextblock) updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition) this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios) iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size) return null;\n        let textNode = view.input.compositionNode;\n        if (!textNode || !this.dom.contains(textNode.parentNode)) return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : {\n                node: textNode,\n                pos: textPos,\n                text\n            };\n        } else {\n            return {\n                node: textNode,\n                pos: -1,\n                text: \"\"\n            };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node)) return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for(;; topNode = topNode.parentNode){\n            if (topNode.parentNode == this.contentDOM) break;\n            while(topNode.previousSibling)topNode.parentNode.removeChild(topNode.previousSibling);\n            while(topNode.nextSibling)topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM) this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco)) return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable) this.nodeDOM.draggable = true;\n        }\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable) this.nodeDOM.removeAttribute(\"draggable\");\n        }\n    }\n    get domAtom() {\n        return this.node.isAtom;\n    }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM) docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view){\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while(skip && skip != this.dom && !skip.pmIsDeco)skip = skip.parentNode;\n        return {\n            skip: skip || true\n        };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM) view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for(let n = this.nodeDOM; n; n = n.parentNode)if (n == parentDOM) return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.nodeDOM,\n            offset: pos\n        };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;\n    }\n    get domAtom() {\n        return false;\n    }\n    isText(text) {\n        return this.node.text == text;\n    }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    matchesHack(nodeName) {\n        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n    get domAtom() {\n        return true;\n    }\n    get ignoreForCoords() {\n        return this.dom.nodeName == \"IMG\";\n    }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos){\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY) return false;\n        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result) this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        } else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        } else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, view, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for(let i = 0; i < descs.length; i++){\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while(childDOM != dom){\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        } else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while(dom){\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM) view.trackWrites = null;\n}\nconst OuterDecoLevel = function(nodeName) {\n    if (nodeName) this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [\n    new OuterDecoLevel\n];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0) return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [\n        top\n    ];\n    for(let i = 0; i < outerDeco.length; i++){\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs) continue;\n        if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for(let name in attrs){\n            let val = attrs[name];\n            if (val == null) continue;\n            if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\") top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;\n    let curDOM = nodeDOM;\n    for(let i = 0; i < curComputed.length; i++){\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            } else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for(let name in prev)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur)) dom.removeAttribute(name);\n    for(let name in cur)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name]) dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for(let i = 0; i < prevList.length; i++)if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);\n        for(let i = 0; i < curList.length; i++)if (prevList.indexOf(curList[i]) == -1) dom.classList.add(curList[i]);\n        if (dom.classList.length == 0) dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while(m = prop.exec(prev.style))dom.style.removeProperty(m[1]);\n        }\n        if (cur.style) dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].type.eq(b[i].type)) return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view){\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end) return;\n        for(let i = start; i < end; i++)this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view, parentIndex) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while(keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)keep++;\n        while(keep < depth){\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while(depth < marks.length){\n            this.stack.push(this.top, this.index + 1);\n            let found = -1, scanTo = this.top.children.length;\n            if (parentIndex < this.preMatch.index) scanTo = Math.min(this.index + 3, scanTo);\n            for(let i = this.index; i < scanTo; i++){\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            } else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        } else {\n            for(let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++){\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0) return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view)) return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for(;;){\n            let parent = domNode.parentNode;\n            if (!parent) return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc) for(let i = this.index; i < this.top.children.length; i++){\n                    if (this.top.children[i] == desc) return i;\n                }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for(let i = this.index; i < this.top.children.length; i++){\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index) return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM) this.changed = true;\n                    this.index++;\n                    return true;\n                } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.destroyBetween(this.index, i);\n                    this.top.children[this.index] = updated;\n                    if (updated.contentDOM) {\n                        updated.dirty = CONTENT_DIRTY;\n                        updated.updateChildren(view, pos + 1);\n                        updated.dirty = NOT_DIRTY;\n                    }\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco)) return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (wrapper.contentDOM) {\n            wrapper.children = next.children;\n            next.children = [];\n            for (let ch of wrapper.children)ch.parent = wrapper;\n        }\n        next.destroy();\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM) desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        } else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while(lastChild instanceof MarkViewDesc){\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\") this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        } else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\") dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top) parent.children.push(hack);\n            else parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while(fI > 0){\n        let desc;\n        for(;;){\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                } else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            } else if (curDesc == parentDesc) {\n                break outer;\n            } else {\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node) continue;\n        if (node != frag.child(fI - 1)) break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return {\n        index: fI,\n        matched,\n        matches: matches.reverse()\n    };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for(let i = 0; i < parent.childCount; i++){\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for(let parentIndex = 0;;){\n        let widget, widgets;\n        while(decoIndex < locals.length && locals[decoIndex].to == offset){\n            let next = locals[decoIndex++];\n            if (next.widget) {\n                if (!widget) widget = next;\n                else (widgets || (widgets = [\n                    widget\n                ])).push(next);\n            }\n        }\n        if (widget) {\n            if (widgets) {\n                widgets.sort(compareSide);\n                for(let i = 0; i < widgets.length; i++)onWidget(widgets[i], parentIndex, !!restNode);\n            } else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        } else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        } else {\n            break;\n        }\n        for(let i = 0; i < active.length; i++)if (active[i].to <= offset) active.splice(i--, 1);\n        while(decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;\n            for(let i = 0; i < active.length; i++)if (active[i].to < cutAt) cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        } else {\n            while(decoIndex < locals.length && locals[decoIndex].to < end)decoIndex++;\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter((d)=>!d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for(let i = 0, pos = 0; i < frag.childCount && pos <= to;){\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText) continue;\n        let str = child.text;\n        while(i < frag.childCount){\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText) break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from) return childStart + found;\n            if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for(let i = 0, off = 0; i < nodes.length; i++){\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        } else {\n            if (start < from) result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to) result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode) return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0) return null;\n    let $head = doc.resolve(head), anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        anchor = head;\n        while(nearestDesc && !nearestDesc.node)nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    } else {\n        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n            let min = head, max = head;\n            for(let i = 0; i < domSel.rangeCount; i++){\n                let range = domSel.getRangeAt(i);\n                min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n                max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n            }\n            if (min < 0) return null;\n            [anchor, head] = max == view.state.selection.anchor ? [\n                max,\n                min\n            ] : [\n                min,\n                max\n            ];\n            $head = doc.resolve(head);\n        } else {\n            anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        }\n        if (anchor < 0) return null;\n    }\n    let $anchor = doc.resolve(anchor);\n    if (!selection) {\n        let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view)) return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    } else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom) resetEditable(resetEditableFrom);\n            if (resetEditableTo) resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        } else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document) removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\") return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n        if (after) return setEditable(after);\n        else if (before) return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = ()=>{\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(()=>{\n                if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection();\n    if (!domSel) return;\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img) domSel.collapse(node.parentNode, domIndex(node) + 1);\n    else domSel.collapse(node, 0);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc) desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    } else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", (f)=>f(view, $anchor, $head)) || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus()) return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    } catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (mods.indexOf(\"s\") > -1) {\n            let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n            if (!node || node.isText || !node.isLeaf) return false;\n            let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n            return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));\n        } else if (!sel.empty) {\n            return false;\n        } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n            return false;\n        } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText) return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            } else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            } else {\n                return false;\n            }\n        }\n    } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    } else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next) return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;\n    for(;;){\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            } else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before, -1)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                } else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                } else break;\n            }\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let prev = node.previousSibling;\n            while(prev && isIgnorable(prev, -1)){\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = 0;\n            } else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force) setSelFocus(view, node, offset);\n    else if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for(;;){\n        if (offset < len) {\n            if (node.nodeType != 1) break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after, 1)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            } else break;\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let next = node.nextSibling;\n            while(next && isIgnorable(next, 1)){\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = len = 0;\n            } else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while(node && offset == node.childNodes.length && !hasBlockDesc(node)){\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while(node && offset < node.childNodes.length){\n        let next = node.childNodes[offset];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while(node && !offset && !hasBlockDesc(node)){\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while(node && offset){\n        let next = node.childNodes[offset - 1];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        } else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (!sel) return;\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    } else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(()=>{\n        if (view.state == state) selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false;\n    if (mac && mods.indexOf(\"m\") > -1) return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor)) return true;\n    if (!empty) return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0) return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(()=>switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey) result += \"c\";\n    if (event.metaKey) result += \"m\";\n    if (event.altKey) result += \"a\";\n    if (event.shiftKey) result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || mac && code == 72 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    } else if (code == 13 || code == 27) {\n        return true;\n    } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n        let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n        let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n        return true;\n    }\n    return false;\n}\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", (f)=>{\n        slice = f(slice, view);\n    });\n    let context = [], { content, openStart, openEnd } = slice;\n    while(openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1){\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, {\n        document: doc\n    }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while(firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])){\n        for(let i = needsWrap.length - 1; i >= 0; i--){\n            let wrapper = doc.createElement(needsWrap[i]);\n            while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", (f)=>f(slice, view)) || slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return {\n        dom: wrap,\n        text,\n        slice\n    };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text) return null;\n    let asText = !!text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", (f)=>{\n            text = f(text, inCode || plainText, view);\n        });\n        if (inCode) {\n            slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0);\n            view.someProp(\"transformPasted\", (f)=>{\n                slice = f(slice, view, true);\n            });\n            return slice;\n        }\n        let parsed = view.someProp(\"clipboardTextParser\", (f)=>f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        } else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach((block)=>{\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    } else {\n        view.someProp(\"transformPastedHTML\", (f)=>{\n            html = f(html, view);\n        });\n        dom = readHTML(html);\n        if (webkit) restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3]) for(let i = +sliceData[3]; i > 0; i--){\n        let child = dom.firstChild;\n        while(child && child.nodeType != 1)child = child.nextSibling;\n        if (!child) break;\n        dom = child;\n    }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode (dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {\n                    ignore: true\n                };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    } else {\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for(let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild){}\n            for(let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild){}\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", (f)=>{\n        slice = f(slice, view, asText);\n    });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2) return fragment;\n    for(let d = $context.depth; d >= 0; d--){\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach((node)=>{\n            if (!result) return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap) return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            } else {\n                if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result) return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for(let i = wrap.length - 1; i >= from; i--)node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0) return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1) openEnd = 0;\n    if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\n        \"table\"\n    ],\n    tbody: [\n        \"table\"\n    ],\n    tfoot: [\n        \"table\"\n    ],\n    caption: [\n        \"table\"\n    ],\n    colgroup: [\n        \"table\"\n    ],\n    col: [\n        \"table\",\n        \"colgroup\"\n    ],\n    tr: [\n        \"table\",\n        \"tbody\"\n    ],\n    td: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ],\n    th: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nlet _policy = null;\nfunction maybeWrapTrusted(html) {\n    let trustedTypes = window.trustedTypes;\n    if (!trustedTypes) return html;\n    // With the require-trusted-types-for CSP, Chrome will block\n    // innerHTML, even on a detached document. This wraps the string in\n    // a way that makes the browser allow us to use its parser again.\n    if (!_policy) _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy(\"ProseMirrorClipboard\", {\n        createHTML: (s)=>s\n    });\n    return _policy.createHTML(html);\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas) html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map((n)=>\"<\" + n + \">\").join(\"\") + html + wrap.map((n)=>\"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = maybeWrapTrusted(html);\n    if (wrap) for(let i = 0; i < wrap.length; i++)elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for(let i = 0; i < nodes.length; i++){\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\xa0\" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size) return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    } catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for(let i = array.length - 2; i >= 0; i -= 2){\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs()) break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = {\n    touchstart: true,\n    touchmove: true\n};\nclass InputState {\n    constructor(){\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = {\n            time: 0,\n            x: 0,\n            y: 0,\n            type: \"\",\n            button: 0\n        };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastChromeDelete = 0;\n        this.composing = false;\n        this.compositionNode = null;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        this.badSafariComposition = false;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for(let event in handlers){\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event)=>{\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);\n        }, passiveHandlers[event] ? {\n            passive: true\n        } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari) view.dom.addEventListener(\"input\", ()=>null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for(let type in view.input.eventHandlers)view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", (currentHandlers)=>{\n        for(let type in currentHandlers)if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = (event)=>runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", (handlers)=>{\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target; node != view.dom; node = node.parentNode)if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event)) return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13) return;\n    if (event.keyCode != 229) view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(()=>{\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    } else if (view.someProp(\"handleKeyDown\", (f)=>f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event)=>{\n    if (event.keyCode == 16) view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event)=>{\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;\n    if (view.someProp(\"handleKeyPress\", (f)=>f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        let deflt = ()=>view.state.tr.insertText(text).scrollIntoView();\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", (f)=>f(view, sel.$from.pos, sel.$to.pos, text, deflt))) view.dispatch(deflt());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) {\n    return {\n        left: event.clientX,\n        top: event.clientY\n    };\n}\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        if (view.someProp(propName, (f)=>i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false))) return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused) view.focus();\n    if (view.state.selection.eq(selection)) return;\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1) return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);\n            else selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f)=>f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f)=>f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f)=>f(view, pos, event)) || defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0) return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {\n        if (view.input.lastClick.type == \"singleClick\") type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\") type = \"tripleClick\";\n    }\n    view.input.lastClick = {\n        time: now,\n        x: event.clientX,\n        y: event.clientY,\n        type,\n        button: event.button\n    };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos) return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown) view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed){\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        } else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;\n        let { selection } = view.state;\n        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {\n            node: targetNode,\n            pos: targetPos,\n            addAttr: !!(this.target && !this.target.draggable),\n            setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n        };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.draggable = true;\n            if (this.mightDrag.setUneditable) setTimeout(()=>{\n                if (this.view.input.mouseDown == this) this.target.setAttribute(\"contentEditable\", \"false\");\n            }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync) setTimeout(()=>selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target)) return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements\n        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a\n        // cursor, but still report that the node is selected\n        // when asked through getSelection. You'll then get a\n        // situation where clicking at the point where that\n        // (hidden) cursor is doesn't change the selection, and\n        // thus doesn't get a reaction from ProseMirror. This\n        // works around that.\n        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        } else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0) this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;\n    }\n}\nhandlers.touchstart = (view)=>{\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = (view)=>{\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = (view)=>forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing) return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = (view)=>{\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$to;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m)=>m.type.spec.inclusive === false) || chrome && windows && selectionBeforeUneditable(view))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        } else {\n            endComposition(view, !state.selection.empty);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for(let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;){\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before) break;\n                    if (before.nodeType == 3) {\n                        let sel = view.domSelection();\n                        if (sel) sel.collapse(before, before.nodeValue.length);\n                        break;\n                    } else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\nfunction selectionBeforeUneditable(view) {\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (!focusNode || focusNode.nodeType != 1 || focusOffset >= focusNode.childNodes.length) return false;\n    let next = focusNode.childNodes[focusOffset];\n    return next.nodeType == 1 && next.contentEditable == \"false\";\n}\neditHandlers.compositionend = (view, event)=>{\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        view.input.compositionNode = null;\n        if (view.input.badSafariComposition) view.domObserver.forceFlush();\n        else if (view.input.compositionPendingChanges) Promise.resolve().then(()=>view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1) view.input.composingTimeout = setTimeout(()=>endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while(view.input.compositionNodes.length > 0)view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode) return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n        if (textBefore == lastChanged || textAfter == lastChanged) return lastChanged;\n        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n            return textAfter;\n        } else if (view.input.compositionNode == textAfter) {\n            let descBefore = textBefore.pmViewDesc;\n            if (!(!descBefore || !descBefore.isText(textBefore.nodeValue))) return textAfter;\n        }\n    }\n    return textBefore || textAfter;\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/ function endComposition(view, restarting = false) {\n    if (android && view.domObserver.flushingSoon >= 0) return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (restarting || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view), cur = view.state.selection;\n        if (sel && !sel.eq(cur)) view.dispatch(view.state.tr.setSelection(sel));\n        else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent) view.dispatch(view.state.tr.deleteSelection());\n        else view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode) return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(()=>{\n        if (wrap.parentNode) wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\nhandlers.copy = editHandlers.cut = (view, _event)=>{\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty) return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    } else {\n        captureCopy(view, dom);\n    }\n    if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode) return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText) target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(()=>{\n        view.focus();\n        if (target.parentNode) target.parentNode.removeChild(target);\n        if (plainText) doPaste(view, target.value, null, plain, event);\n        else doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty))) return true;\n    if (!slice) return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\nfunction getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text) return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event)=>{\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android) return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event)) event.preventDefault();\n    else capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move, node){\n        this.slice = slice;\n        this.move = move;\n        this.node = node;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nfunction dragMoves(view, event) {\n    let moves = view.someProp(\"dragCopies\", (test)=>!test(event));\n    return moves != null ? moves : !event[dragCopyModifier];\n}\nhandlers.dragstart = (view, _event)=>{\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown) mouseDown.done();\n    if (!event.dataTransfer) return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    } else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView) node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text, slice } = serializeForClipboard(view, draggedSlice);\n    // Pre-120 Chrome versions clear files when calling `clearData` (#1472)\n    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120) event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI) event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, dragMoves(view, event), node);\n};\nhandlers.dragend = (view)=>{\n    let dragging = view.dragging;\n    window.setTimeout(()=>{\n        if (view.dragging == dragging) view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e)=>e.preventDefault();\neditHandlers.drop = (view, event)=>{\n    try {\n        handleDrop(view, event, view.dragging);\n    } finally{\n        view.dragging = null;\n    }\n};\nfunction handleDrop(view, event, dragging) {\n    if (!event.dataTransfer) return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos) return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", (f)=>{\n            slice = f(slice, view, false);\n        });\n    } else {\n        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && dragMoves(view, event));\n    if (view.someProp(\"handleDrop\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice) return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null) insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n        let { node } = dragging;\n        if (node) node.replace(tr);\n        else tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert)) return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    } else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo)=>end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n}\nhandlers.focus = (view)=>{\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(()=>{\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event)=>{\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event)=>{\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(()=>{\n            if (view.input.domChangeCount != domChangeCount) return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor(let prop in editHandlers)handlers[prop] = editHandlers[prop];\nfunction compareObjs(a, b) {\n    if (a == b) return true;\n    for(let p in a)if (a[p] !== b[p]) return false;\n    for(let p in b)if (!(p in a)) return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec){\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() {\n        return true;\n    }\n    eq(other) {\n        return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n    destroy(node) {\n        if (this.spec.destroy) this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) {\n        return span.from < span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    static is(span) {\n        return span.type instanceof InlineType;\n    }\n    destroy() {}\n}\nclass NodeType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted) return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos) return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    destroy() {}\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variantssee the static members of this class for details.\n*/ class Decoration {\n    /**\n    @internal\n    */ constructor(/**\n    The start position of the decoration.\n    */ from, /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */ to, /**\n    @internal\n    */ type){\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */ copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */ eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */ map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */ static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */ static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */ static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */ get spec() {\n        return this.type.spec;\n    }\n    /**\n    @internal\n    */ get inline() {\n        return this.type instanceof InlineType;\n    }\n    /**\n    @internal\n    */ get widget() {\n        return this.type instanceof WidgetType;\n    }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structureit is not modified,\nupdates create a new value.\n*/ class DecorationSet {\n    /**\n    @internal\n    */ constructor(local, children){\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */ static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */ find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for(let i = 0; i < this.local.length; i++){\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for(let i = 0; i < this.children.length; i += 3){\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */ map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0) return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */ mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for(let i = 0; i < this.local.length; i++){\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove) options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */ add(doc, decorations) {\n        if (!decorations.length) return this;\n        if (this == empty) return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset)=>{\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;\n            if (!children) children = this.children.slice();\n            while(childIndex < children.length && children[childIndex] < childOffset)childIndex += 3;\n            if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for(let i = 0; i < local.length; i++)if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */ remove(decorations) {\n        if (decorations.length == 0 || this == empty) return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for(let i = 0; i < children.length; i += 3){\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for(let j = 0, span; j < decorations.length; j++)if (span = decorations[j]) {\n                if (span.from > from && span.to < to) {\n                    decorations[j] = null;\n                    (found || (found = [])).push(span);\n                }\n            }\n            if (!found) continue;\n            if (children == this.children) children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            } else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length) {\n            for(let i = 0, span; i < decorations.length; i++)if (span = decorations[i]) {\n                for(let j = 0; j < local.length; j++)if (local[j].eq(span, offset)) {\n                    if (local == this.local) local = this.local.slice();\n                    local.splice(j--, 1);\n                }\n            }\n        }\n        if (children == this.children && local == this.local) return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n        if (this == empty) return this;\n        if (node.isLeaf) return DecorationSet.empty;\n        let child, local;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] >= offset) {\n            if (this.children[i] == offset) child = this.children[i + 2];\n            break;\n        }\n        let start = offset + 1, end = start + node.content.size;\n        for(let i = 0; i < this.local.length; i++){\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to) (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([\n                localSet,\n                child\n            ]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */ eq(other) {\n        if (this == other) return true;\n        if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;\n        for(let i = 0; i < this.local.length; i++)if (!this.local[i].eq(other.local[i])) return false;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2])) return false;\n        return true;\n    }\n    /**\n    @internal\n    */ locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */ localsInner(node) {\n        if (this == empty) return none;\n        if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;\n        let result = [];\n        for(let i = 0; i < this.local.length; i++){\n            if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);\n        }\n        return result;\n    }\n    forEachSet(f) {\n        f(this);\n    }\n}\n/**\nThe empty set of decorations.\n*/ DecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/ DecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members){\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map((member)=>member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf) return DecorationSet.empty;\n        let found = [];\n        for(let i = 0; i < this.members.length; i++){\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty) continue;\n            if (result instanceof DecorationGroup) found = found.concat(result.members);\n            else found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;\n        for(let i = 0; i < this.members.length; i++)if (!this.members[i].eq(other.members[i])) return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for(let i = 0; i < this.members.length; i++){\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length) continue;\n            if (!result) {\n                result = locals;\n            } else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for(let j = 0; j < locals.length; j++)result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch(members.length){\n            case 0:\n                return empty;\n            case 1:\n                return members[0];\n            default:\n                return new DecorationGroup(members.every((m)=>m instanceof DecorationSet) ? members : members.reduce((r, m)=>r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n    forEachSet(f) {\n        for(let i = 0; i < this.members.length; i++)this.members[i].forEachSet(f);\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for(let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++){\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd)=>{\n            let dSize = newEnd - newStart - (oldEnd - oldStart);\n            for(let i = 0; i < children.length; i += 3){\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved) continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                } else if (oldStart >= baseOffset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n        if (children[i + 1] == -2) {\n            mustRebuild = true;\n            children[i + 1] = -1;\n            continue;\n        }\n        let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n        if (fromLocal < 0 || fromLocal >= node.content.size) {\n            mustRebuild = true;\n            continue;\n        }\n        // Must read oldChildren because children was tagged with -1\n        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n        let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n        let childNode = node.maybeChild(index);\n        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n            let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n            if (mapped != empty) {\n                children[i] = fromLocal;\n                children[i + 1] = toLocal;\n                children[i + 2] = mapped;\n            } else {\n                children[i + 1] = -2;\n                mustRebuild = true;\n            }\n        } else {\n            mustRebuild = true;\n        }\n    }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n            children.splice(i, 3);\n            i -= 3;\n        }\n        for(let i = 0, j = 0; i < built.children.length; i += 3){\n            let from = built.children[i];\n            while(j < children.length && children[j] < from)j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length) return spans;\n    let result = [];\n    for(let i = 0; i < spans.length; i++){\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for(let i = 0; i < set.local.length; i++){\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped) decorations.push(mapped);\n            else if (options.onRemove) options.onRemove(set.local[i].spec);\n        }\n        for(let i = 0; i < set.children.length; i += 3)gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf) return null;\n    let end = offset + node.nodeSize, found = null;\n    for(let i = 0, span; i < spans.length; i++){\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for(let i = 0; i < array.length; i++)if (array[i] != null) result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart)=>{\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for(let i = 0; i < locals.length; i++)if (!locals[i].type.valid(node, locals[i])) {\n        if (options.onRemove) options.onRemove(locals[i].spec);\n        locals.splice(i--, 1);\n    }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for(let i = 0; i < working.length - 1; i++){\n        let span = working[i];\n        if (span.from != span.to) for(let j = i + 1; j < working.length; j++){\n            let next = working[j];\n            if (next.from == span.from) {\n                if (next.to != span.to) {\n                    if (working == spans) working = spans.slice();\n                    // Followed by a partially overlapping larger span. Split that\n                    // span.\n                    working[j] = next.copy(next.from, span.to);\n                    insertAhead(working, j + 1, next.copy(span.to, next.to));\n                }\n                continue;\n            } else {\n                if (next.from < span.to) {\n                    if (working == spans) working = spans.slice();\n                    // The end of this one overlaps with a subsequent span. Split\n                    // this one.\n                    working[i] = span.copy(span.from, next.from);\n                    insertAhead(working, j, span.copy(next.from, span.to));\n                }\n                break;\n            }\n        }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while(i < array.length && byPos(deco, array[i]) > 0)i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", (f)=>{\n        let result = f(view.state);\n        if (result && result != empty) found.push(result);\n    });\n    if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [\n        view.cursorWrapper.deco\n    ]));\n    return DecorationGroup.from(found);\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange){\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.lastChangedTextNode = null;\n        this.observer = window.MutationObserver && new window.MutationObserver((mutations)=>{\n            for(let i = 0; i < mutations.length; i++)this.queue.push(mutations[i]);\n            if (ie && ie_version <= 11 && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) {\n                // IE11 will sometimes (on backspacing out a single character\n                // text node after a BR node) call the observer callback\n                // before actually updating the DOM, which will cause\n                // ProseMirror to miss the change (see #930)\n                this.flushSoon();\n            } else if (safari && view.composing && mutations.some((m)=>m.type == \"childList\" && m.target.nodeName == \"TR\")) {\n                // Safari does weird stuff when finishing a composition in a\n                // table cell, which tends to involve inserting inappropriate\n                // nodes in the table row.\n                view.input.badSafariComposition = true;\n                this.flushSoon();\n            } else {\n                this.flush();\n            }\n        });\n        if (useCharData) {\n            this.onCharData = (e)=>{\n                this.queue.push({\n                    target: e.target,\n                    type: \"characterData\",\n                    oldValue: e.prevValue\n                });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(()=>{\n            this.flushingSoon = -1;\n            this.flush();\n        }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData) this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for(let i = 0; i < take.length; i++)this.queue.push(take[i]);\n                window.setTimeout(()=>this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(()=>this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view)) return;\n        if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode) return true;\n        let ancestors = new Set, container;\n        for(let scan = sel.focusNode; scan; scan = parentNode(scan))ancestors.add(scan);\n        for(let scan = sel.anchorNode; scan; scan = parentNode(scan))if (ancestors.has(scan)) {\n            container = scan;\n            break;\n        }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer) for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1) return;\n        let mutations = this.pendingRecords();\n        if (mutations.length) this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for(let i = 0; i < mutations.length; i++){\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver) typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length) {\n            let brs = added.filter((n)=>n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let [a, b] = brs;\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();\n                else a.remove();\n            } else {\n                let { focusNode } = this.currentSelection;\n                for (let br of brs){\n                    let parent = br.parentNode;\n                    if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent)) br.remove();\n                }\n            }\n        } else if ((chrome || safari) && added.some((n)=>n.nodeName == \"BR\") && (view.input.lastKeyCode == 8 || view.input.lastKeyCode == 46)) {\n            // Chrome/Safari sometimes insert a bogus break node if you\n            // backspace out the last bit of text before an inline-flex node (#1552)\n            for (let node of added)if (node.nodeName == \"BR\" && node.parentNode) {\n                let after = node.nextSibling;\n                if (after && after.nodeType == 1 && after.contentEditable == \"false\") node.parentNode.removeChild(node);\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        } else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            if (view.input.badSafariComposition) {\n                view.input.badSafariComposition = false;\n                fixUpBadSafariComposition(view, added);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty) view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel)) selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1) return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || // Firefox sometimes fires spurious events for null/empty styles\n        mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))) return null;\n        if (!desc || desc.ignoreMutation(mut)) return null;\n        if (mut.type == \"childList\") {\n            for(let i = 0; i < mut.addedNodes.length; i++){\n                let node = mut.addedNodes[i];\n                added.push(node);\n                if (node.nodeType == 3) this.lastChangedTextNode = node;\n            }\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {\n                from: desc.posBefore,\n                to: desc.posAfter\n            };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for(let i = 0; i < mut.addedNodes.length; i++){\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return {\n                from,\n                to\n            };\n        } else if (mut.type == \"attributes\") {\n            return {\n                from: desc.posAtStart - desc.border,\n                to: desc.posAtEnd + desc.border\n            };\n        } else {\n            this.lastChangedTextNode = mut.target;\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view)) return;\n    cssChecked.set(view, null);\n    if ([\n        \"normal\",\n        \"nowrap\",\n        \"pre-line\"\n    ].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned) return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\nfunction rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range) return rangeToSelectionRange(view, range);\n    }\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at itusing `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found ? rangeToSelectionRange(view, found) : null;\n}\nfunction blockParent(view, node) {\n    for(let p = node.parentNode; p && p != view.dom; p = p.parentNode){\n        let desc = view.docView.nearestDesc(p, true);\n        if (desc && desc.node.isBlock) return p;\n    }\n    return null;\n}\n// Kludge for a Safari bug where, on ending a composition in an\n// otherwise empty table cell, it randomly moves the composed text\n// into the table row around that cell, greatly confusing everything\n// (#188).\nfunction fixUpBadSafariComposition(view, addedNodes) {\n    var _a;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    for (let node of addedNodes){\n        if (((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName) == \"TR\") {\n            let nextCell = node.nextSibling;\n            while(nextCell && nextCell.nodeName != \"TD\" && nextCell.nodeName != \"TH\")nextCell = nextCell.nextSibling;\n            if (nextCell) {\n                let parent = nextCell;\n                for(;;){\n                    let first = parent.firstChild;\n                    if (!first || first.nodeType != 1 || first.contentEditable == \"false\" || /^(BR|IMG)$/.test(first.nodeName)) break;\n                    parent = first;\n                }\n                parent.insertBefore(node, parent.firstChild);\n                if (focusNode == node) view.domSelection().collapse(node, focusOffset);\n            } else {\n                node.parentNode.removeChild(node);\n            }\n        }\n    }\n}\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [\n            {\n                node: anchor,\n                offset: domSel.anchorOffset\n            }\n        ];\n        if (!selectionCollapsed(domSel)) find.push({\n            node: domSel.focusNode,\n            offset: domSel.focusOffset\n        });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for(let off = toOffset; off > fromOffset; off--){\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size) break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null) head = anchor;\n        sel = {\n            anchor: anchor + from,\n            head: head + from\n        };\n    }\n    return {\n        doc,\n        sel,\n        from,\n        to\n    };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return {\n                skip\n            };\n        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return {\n                ignore: true\n            };\n        }\n    } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return {\n            ignore: true\n        };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\") tr.scrollIntoView();\n            if (compositionID) tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    } else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if (change) view.input.domChangeCount++;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n)=>n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = {\n                start: sel.from,\n                endA: sel.to,\n                endB: sel.to\n            };\n        } else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID) tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n            change.endB += view.state.selection.to - change.endA;\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xa0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n)=>n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\\S/.test(parse.doc.textBetween($from.pos, $to.pos, \"\", \"\"))) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome) view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && change.endB == change.start) view.input.lastChromeDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(()=>{\n            view.someProp(\"handleKeyDown\", function(f) {\n                return f(view, keyEvent(13, \"Enter\"));\n            });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let mkTr = (base)=>{\n        let tr = base || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n        if (parse.sel) {\n            let sel = resolveSelection(view, tr.doc, parse.sel);\n            // Chrome will sometimes, during composition, report the\n            // selection in the wrong place. If it looks like that is\n            // happening, don't update the selection.\n            // Edge just doesn't move the cursor forward when you start typing\n            // in an empty block or between br nodes.\n            if (sel && !(chrome && view.composing && sel.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) || ie && sel.empty && sel.head == chFrom)) tr.setSelection(sel);\n        }\n        if (compositionID) tr.setMeta(\"composition\", compositionID);\n        return tr.scrollIntoView();\n    };\n    let markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) {\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(()=>selectionToDOM(view), 20);\n            }\n            let tr = mkTr(view.state.tr.delete(chFrom, chTo));\n            let marks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n            if (marks) tr.ensureMarks(marks);\n            view.dispatch(tr);\n        } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            let tr = mkTr(view.state.tr);\n            if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark);\n            else tr.removeMark(chFrom, chTo, markChange.mark);\n            view.dispatch(tr);\n        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            let deflt = ()=>mkTr(view.state.tr.insertText(text, chFrom, chTo));\n            if (!view.someProp(\"handleTextInput\", (f)=>f(view, chFrom, chTo, text, deflt))) view.dispatch(deflt());\n        } else {\n            view.dispatch(mkTr());\n        }\n    } else {\n        view.dispatch(mkTr());\n    }\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for(let i = 0; i < prevMarks.length; i++)added = prevMarks[i].removeFromSet(added);\n    for(let i = 0; i < curMarks.length; i++)removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node)=>node.mark(mark.addToSet(node.marks));\n    } else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node)=>node.mark(mark.removeFromSet(node.marks));\n    } else {\n        return null;\n    }\n    let updated = [];\n    for(let i = 0; i < prev.childCount; i++)updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur)) return {\n        mark,\n        type\n    };\n}\nfunction looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if (end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into\n    skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;\n    let $start = old.resolve(start);\n    // Handle the case where, rather than joining blocks, the change just removed an entire block\n    if (!$newStart.parent.isTextblock) {\n        let after = $start.nodeAfter;\n        return after != null && end == start + after.nodeSize;\n    }\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while(depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)){\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while(next && !next.isLeaf){\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null) return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endB = start + (endB - endA);\n        endA = start;\n    } else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return {\n        start,\n        endA,\n        endB\n    };\n}\nfunction isSurrogatePair(str) {\n    if (str.length != 2) return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;\n}\n/**\n@internal\n*/ const __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/ const __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/ class EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */ constructor(place, props){\n        this._root = null;\n        /**\n        @internal\n        */ this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */ this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */ this.markCursor = null;\n        /**\n        @internal\n        */ this.cursorWrapper = null;\n        /**\n        @internal\n        */ this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */ this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */ this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */ this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = place && place.mount || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild) place.appendChild(this.dom);\n            else if (typeof place == \"function\") place(this.dom);\n            else if (place.mount) this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added)=>readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */ get composing() {\n        return this.input.composing;\n    }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */ get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for(let name in prev)this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */ update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */ setProps(props) {\n        let updated = {};\n        for(let name in this._props)updated[name] = this._props[name];\n        updated.state = this.state;\n        for(let name in props)updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */ updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        var _a;\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n                if (this.composing) this.input.compositionNode = findCompositionNode(this);\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco(outerDeco);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && (!this.trackWrites || !this.dom.contains(this.trackWrites))) forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            } else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc)) this.updateDraggedNode(this.dragging, prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        } else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        } else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */ scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;\n        else if (this.someProp(\"handleScrollToSelection\", (f)=>f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        } else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while(view = this.pluginViews.pop())if (view.destroy) view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for(let i = 0; i < this.directPlugins.length; i++){\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n            for(let i = 0; i < this.state.plugins.length; i++){\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n        } else {\n            for(let i = 0; i < this.pluginViews.length; i++){\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update) pluginView.update(this, prevState);\n            }\n        }\n    }\n    updateDraggedNode(dragging, prev) {\n        let sel = dragging.node, found = -1;\n        if (this.state.doc.nodeAt(sel.from) == sel.node) {\n            found = sel.from;\n        } else {\n            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n            let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n            if (moved == sel.node) found = movedPos;\n        }\n        this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop)) return value;\n        for(let i = 0; i < this.directPlugins.length; i++){\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins) for(let i = 0; i < plugins.length; i++){\n            let prop = plugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n    }\n    /**\n    Query whether the view has focus.\n    */ hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom) return true;\n            if (!node || !this.dom.contains(node)) return false;\n            while(node && this.dom != node && this.dom.contains(node)){\n                if (node.contentEditable == \"false\") return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */ focus() {\n        this.domObserver.stop();\n        if (this.editable) focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */ get root() {\n        let cached = this._root;\n        if (cached == null) for(let search = this.dom.parentNode; search; search = search.parentNode){\n            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n                if (!search.getSelection) Object.getPrototypeOf(search).getSelection = ()=>search.ownerDocument.getSelection();\n                return this._root = search;\n            }\n        }\n        return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */ updateRoot() {\n        this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */ posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */ coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */ domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */ nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimesfor example when interpreting an event\n    targetyou don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */ posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null) throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */ endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */ pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */ pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Serialize the given slice as it would be if it was copied from\n    this editor. Returns a DOM element that contains a\n    representation of the slice as its children, a textual\n    representation, and the transformed slice (which can be\n    different from the given input due to hooks like\n    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).\n    */ serializeForClipboard(slice) {\n        return serializeForClipboard(this, slice);\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */ destroy() {\n        if (!this.docView) return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        } else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n        clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */ get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */ dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    @internal\n    */ domSelectionRange() {\n        let sel = this.domSelection();\n        if (!sel) return {\n            focusNode: null,\n            focusOffset: 0,\n            anchorNode: null,\n            anchorOffset: 0\n        };\n        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */ domSelection() {\n        return this.root.getSelection();\n    }\n}\nEditorView.prototype.dispatch = function(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction;\n    if (dispatchTransaction) dispatchTransaction.call(this, tr);\n    else this.updateState(this.state.apply(tr));\n};\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", (value)=>{\n        if (typeof value == \"function\") value = value(view.state);\n        if (value) for(let attr in value){\n            if (attr == \"class\") attrs.class += \" \" + value[attr];\n            else if (attr == \"style\") attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n            else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\") attrs[attr] = String(value[attr]);\n        }\n    });\n    if (!attrs.translate) attrs.translate = \"no\";\n    return [\n        Decoration.node(0, view.state.doc.content.size, attrs)\n    ];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = {\n            dom,\n            deco: Decoration.widget(view.state.selection.from, dom, {\n                raw: true,\n                marks: view.markCursor\n            })\n        };\n    } else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", (value)=>value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for(let prop in obj)if (!Object.prototype.hasOwnProperty.call(result, prop)) result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for(let prop in a){\n        if (a[prop] != b[prop]) return true;\n        nA++;\n    }\n    for(let _ in b)nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3Itdmlld0AxLjQxLjUvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXZpZXcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRjtBQUNOO0FBQ2xDO0FBRWxELE1BQU1VLFdBQVcsU0FBVUMsSUFBSTtJQUMzQixJQUFLLElBQUlDLFFBQVEsSUFBSUEsUUFBUztRQUMxQkQsT0FBT0EsS0FBS0UsZUFBZTtRQUMzQixJQUFJLENBQUNGLE1BQ0QsT0FBT0M7SUFDZjtBQUNKO0FBQ0EsTUFBTUUsYUFBYSxTQUFVSCxJQUFJO0lBQzdCLElBQUlJLFNBQVNKLEtBQUtLLFlBQVksSUFBSUwsS0FBS0csVUFBVTtJQUNqRCxPQUFPQyxVQUFVQSxPQUFPRSxRQUFRLElBQUksS0FBS0YsT0FBT0csSUFBSSxHQUFHSDtBQUMzRDtBQUNBLElBQUlJLGNBQWM7QUFDbEIsc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSw0QkFBNEI7QUFDNUIsTUFBTUMsWUFBWSxTQUFVVCxJQUFJLEVBQUVVLElBQUksRUFBRUMsRUFBRTtJQUN0QyxJQUFJQyxRQUFRSixlQUFnQkEsQ0FBQUEsY0FBY0ssU0FBU0MsV0FBVyxFQUFDO0lBQy9ERixNQUFNRyxNQUFNLENBQUNmLE1BQU1XLE1BQU0sT0FBT1gsS0FBS2dCLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHTjtJQUN4REMsTUFBTU0sUUFBUSxDQUFDbEIsTUFBTVUsUUFBUTtJQUM3QixPQUFPRTtBQUNYO0FBQ0EsTUFBTU8sbUJBQW1CO0lBQ3JCWCxjQUFjO0FBQ2xCO0FBQ0EscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNsRSw2Q0FBNkM7QUFDN0MsTUFBTVksdUJBQXVCLFNBQVVwQixJQUFJLEVBQUVxQixHQUFHLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUNuRSxPQUFPRCxjQUFlRSxDQUFBQSxRQUFReEIsTUFBTXFCLEtBQUtDLFlBQVlDLFdBQVcsQ0FBQyxNQUM3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QUksQ0FBQ3hJLEtBQUssSUFBSTYzQixPQUFPcnZCLElBQUksQ0FBQzJ3QixpQkFBaUIsSUFBSXRCLE9BQU9ydkIsSUFBSSxDQUFDNHdCLGlCQUFpQixFQUNuRixNQUFNLElBQUl0eUIsV0FBVztBQUM3QjtBQUV5RiIsInNvdXJjZXMiOlsid2VicGFjazovL3NlbnRpbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLXZpZXdAMS40MS41L25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguanM/MDU3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBTbGljZSwgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgZG9tSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbmNvbnN0IHBhcmVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5sZXQgcmV1c2VkUmFuZ2UgPSBudWxsO1xuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHJhbmdlLCBiZWNhdXNlIERPTSByYW5nZVxuLy8gb2JqZWN0cyBhcmUgZXZlcnkgZXhwZW5zaXZlLCBhbmQga2VlcCBzbG93aW5nIGRvd24gc3Vic2VxdWVudCBET01cbi8vIHVwZGF0ZXMsIGZvciBzb21lIHJlYXNvbi5cbmNvbnN0IHRleHRSYW5nZSA9IGZ1bmN0aW9uIChub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZSA9IHJldXNlZFJhbmdlIHx8IChyZXVzZWRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcbmNvbnN0IGNsZWFyUmV1c2VkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV1c2VkUmFuZ2UgPSBudWxsO1xufTtcbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmNvbnN0IGlzRXF1aXZhbGVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgJiYgKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSk7XG59O1xuY29uc3QgYXRvbUVsZW1lbnRzID0gL14oaW1nfGJyfGlucHV0fHRleHRhcmVhfGhyKSQvaTtcbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEgJiYgY2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBjaGlsZC5wbVZpZXdEZXNjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWdub3JlRm9yU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBub2RlU2l6ZShub2RlKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBub2RlU2l6ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZSQxKG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGVTaXplKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIkMShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT25FZGdlKG5vZGUsIG9mZnNldCwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGF0U3RhcnQgPSBhdFN0YXJ0ICYmIGluZGV4ID09IDA7XG4gICAgICAgIGF0RW5kID0gYXRFbmQgJiYgaW5kZXggPT0gbm9kZVNpemUobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQmxvY2tEZXNjKGRvbSkge1xuICAgIGxldCBkZXNjO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGRlc2MgPSBjdXIucG1WaWV3RGVzYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jayAmJiAoZGVzYy5kb20gPT0gZG9tIHx8IGRlc2MuY29udGVudERPTSA9PSBkb20pO1xufVxuLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuLy8gKGlzQ29sbGFwc2VkIGluYXBwcm9wcmlhdGVseSByZXR1cm5zIHRydWUgaW4gc2hhZG93IGRvbSlcbmNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uIChkb21TZWwpIHtcbiAgICByZXR1cm4gZG9tU2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn07XG5mdW5jdGlvbiBrZXlFdmVudChrZXlDb2RlLCBrZXkpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImtleWRvd25cIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG4gICAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gY2FyZXRGcm9tUG9pbnQoZG9jLCB4LCB5KSB7XG4gICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgIHRyeSB7IC8vIEZpcmVmb3ggdGhyb3dzIGZvciB0aGlzIGNhbGwgaW4gaGFyZC10by1wcmVkaWN0IGNpcmN1bXN0YW5jZXMgKCM5OTQpXG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAvLyBDbGlwIHRoZSBvZmZzZXQsIGJlY2F1c2UgQ2hyb21lIHdpbGwgcmV0dXJuIGEgdGV4dCBvZmZzZXRcbiAgICAgICAgICAgIC8vIGludG8gPGlucHV0PiBub2Rlcywgd2hpY2ggY2FuJ3QgYmUgdHJlYXRlZCBhcyBhIHJlZ3VsYXIgRE9NXG4gICAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcG9zLm9mZnNldE5vZGUsIG9mZnNldDogTWF0aC5taW4obm9kZVNpemUocG9zLm9mZnNldE5vZGUpLCBwb3Mub2Zmc2V0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICB9XG4gICAgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiByYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiBNYXRoLm1pbihub2RlU2l6ZShyYW5nZS5zdGFydENvbnRhaW5lciksIHJhbmdlLnN0YXJ0T2Zmc2V0KSB9O1xuICAgIH1cbn1cblxuY29uc3QgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogbnVsbDtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgYWdlbnQgPSAobmF2ICYmIG5hdi51c2VyQWdlbnQpIHx8IFwiXCI7XG5jb25zdCBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gL01TSUUgXFxkLy5leGVjKGFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGllX3ZlcnNpb24gPSBpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChhZ2VudCk7XG5nZWNrbyAmJiArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKGFnZW50KSB8fCBbMCwgMF0pWzFdO1xuY29uc3QgX2Nocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICEhX2Nocm9tZTtcbmNvbnN0IGNocm9tZV92ZXJzaW9uID0gX2Nocm9tZSA/ICtfY2hyb21lWzFdIDogMDtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAhIW5hdiAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG4vLyBJcyB0cnVlIGZvciBib3RoIGlPUyBhbmQgaVBhZE9TIGZvciBjb252ZW5pZW5jZVxuY29uc3QgaW9zID0gc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudCkgfHwgISFuYXYgJiYgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG5jb25zdCBtYWMgPSBpb3MgfHwgKG5hdiA/IC9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlKTtcbmNvbnN0IHdpbmRvd3MgPSBuYXYgPyAvV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZTtcbmNvbnN0IGFuZHJvaWQgPSAvQW5kcm9pZCBcXGQvLnRlc3QoYWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gISFkb2MgJiYgXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHdlYmtpdF92ZXJzaW9uID0gd2Via2l0ID8gKygvXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDA7XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gICAgbGV0IHZwID0gZG9jLmRlZmF1bHRWaWV3ICYmIGRvYy5kZWZhdWx0Vmlldy52aXN1YWxWaWV3cG9ydDtcbiAgICBpZiAodnApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAwLCByaWdodDogdnAud2lkdGgsXG4gICAgICAgICAgICB0b3A6IDAsIGJvdHRvbTogdnAuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2lkZSh2YWx1ZSwgc2lkZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV07XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0KG5vZGUpIHtcbiAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgICBsZXQgc2NhbGVYID0gKHJlY3Qud2lkdGggLyBub2RlLm9mZnNldFdpZHRoKSB8fCAxO1xuICAgIGxldCBzY2FsZVkgPSAocmVjdC5oZWlnaHQgLyBub2RlLm9mZnNldEhlaWdodCkgfHwgMTtcbiAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbm9kZS5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyh2aWV3LCByZWN0LCBzdGFydERPTSkge1xuICAgIGxldCBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBzdGFydERPTSB8fCB2aWV3LmRvbTs7KSB7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgbGV0IGF0VG9wID0gZWx0ID09IGRvYy5ib2R5O1xuICAgICAgICBsZXQgYm91bmRpbmcgPSBhdFRvcCA/IHdpbmRvd1JlY3QoZG9jKSA6IGNsaWVudFJlY3QoZWx0KTtcbiAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgID8gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikgLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA6IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImxlZnRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwicmlnaHRcIik7XG4gICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsIHN0YXJ0WSA9IGVsdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgbGV0IGRYID0gZWx0LnNjcm9sbExlZnQgLSBzdGFydFgsIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBkWCwgdG9wOiByZWN0LnRvcCAtIGRZLCByaWdodDogcmVjdC5yaWdodCAtIGRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gZFkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gYXRUb3AgPyBcImZpeGVkXCIgOiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb247XG4gICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChwb3MpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHBvcyA9PSBcImFic29sdXRlXCIgPyBwYXJlbnQub2Zmc2V0UGFyZW50IDogcGFyZW50Tm9kZShwYXJlbnQpO1xuICAgIH1cbn1cbi8vIFN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcywgYWxvbmcgd2l0aFxuLy8gdGhlIHRvcCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IG5lYXIgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCB3aGljaFxuLy8gd2lsbCBiZSB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgdmlzaWJsZSB2aWV3cG9ydCByZW1haW5zIHN0YWJsZSBldmVuXG4vLyB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGFib3ZlIGNoYW5nZXMuXG5mdW5jdGlvbiBzdG9yZVNjcm9sbFBvcyh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICAgIGxldCByZWZET00sIHJlZlRvcDtcbiAgICBmb3IgKGxldCB4ID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgeSA9IHN0YXJ0WSArIDE7IHkgPCBNYXRoLm1pbihpbm5lckhlaWdodCwgcmVjdC5ib3R0b20pOyB5ICs9IDUpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoIWRvbSB8fCBkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGxvY2FsUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgICAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgICAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZET006IHJlZkRPTSwgcmVmVG9wOiByZWZUb3AsIHN0YWNrOiBzY3JvbGxTdGFjayh2aWV3LmRvbSkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFN0YWNrKGRvbSkge1xuICAgIGxldCBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gcGFyZW50Tm9kZShjdXIpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyBkb206IGN1ciwgdG9wOiBjdXIuc2Nyb2xsVG9wLCBsZWZ0OiBjdXIuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgaWYgKGRvbSA9PSBkb2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuLy8gUmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzIHRvIHRoYXQgd2hhdFxuLy8gaXQgd2FzIGJlZm9yZSwgd2hlbiBzdG9yZVNjcm9sbFBvcyB3YXMgY2FsbGVkLlxuZnVuY3Rpb24gcmVzZXRTY3JvbGxQb3MoeyByZWZET00sIHJlZlRvcCwgc3RhY2sgfSkge1xuICAgIGxldCBuZXdSZWZUb3AgPSByZWZET00gPyByZWZET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcbiAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIG5ld1JlZlRvcCA9PSAwID8gMCA6IG5ld1JlZlRvcCAtIHJlZlRvcCk7XG59XG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIGRUb3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGRvbSwgdG9wLCBsZWZ0IH0gPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxUb3AgIT0gdG9wICsgZFRvcClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdG9yZWQsIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJbk5vZGUobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcm93Qm90ID0gY29vcmRzLnRvcCwgcm93VG9wID0gY29vcmRzLnRvcDtcbiAgICBsZXQgZmlyc3RCZWxvdywgY29vcmRzQmVsb3c7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGNoaWxkSW5kZXggPSAwOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZywgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgIGxldCByZWN0cztcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZWN0cyA9IHRleHRSYW5nZShjaGlsZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPD0gcm93Qm90ICYmIHJlY3QuYm90dG9tID49IHJvd1RvcCkge1xuICAgICAgICAgICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICAgICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gcmVjdC5sZWZ0IC0gY29vcmRzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8IGR4Q2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNDbG9zZXN0ID0gZHggJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY29vcmRzLnRvcFxuICAgICAgICAgICAgICAgICAgICB9IDogY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC50b3AgPiBjb29yZHMudG9wICYmICFmaXJzdEJlbG93ICYmIHJlY3QubGVmdCA8PSBjb29yZHMubGVmdCAmJiByZWN0LnJpZ2h0ID49IGNvb3Jkcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RCZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvb3Jkc0JlbG93ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIE1hdGgubWluKHJlY3QucmlnaHQsIGNvb3Jkcy5sZWZ0KSksIHRvcDogcmVjdC50b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xvc2VzdCAmJiAoY29vcmRzLmxlZnQgPj0gcmVjdC5yaWdodCAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIHx8XG4gICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC5ib3R0b20pKVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdCAmJiBmaXJzdEJlbG93KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBmaXJzdEJlbG93O1xuICAgICAgICBjb29yZHNDbG9zZXN0ID0gY29vcmRzQmVsb3c7XG4gICAgICAgIGR4Q2xvc2VzdCA9IDA7XG4gICAgfVxuICAgIGlmIChjbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGZpbmRPZmZzZXRJblRleHQoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG4gICAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSlcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0IH07XG4gICAgcmV0dXJuIGZpbmRPZmZzZXRJbk5vZGUoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5UZXh0KG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIGkgKyAxKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgaSk7XG4gICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJhbmdlLmRldGFjaCgpO1xuICAgIHJldHVybiByZXN1bHQgfHwgeyBub2RlLCBvZmZzZXQ6IDAgfTtcbn1cbmZ1bmN0aW9uIGluUmVjdChjb29yZHMsIHJlY3QpIHtcbiAgICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSAmJlxuICAgICAgICBjb29yZHMudG9wID49IHJlY3QudG9wIC0gMSAmJiBjb29yZHMudG9wIDw9IHJlY3QuYm90dG9tICsgMTtcbn1cbmZ1bmN0aW9uIHRhcmdldEtsdWRnZShkb20sIGNvb3Jkcykge1xuICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICYmIC9ebGkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpICYmIGNvb3Jkcy5sZWZ0IDwgZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBmaW5kT2Zmc2V0SW5Ob2RlKGVsdCwgY29vcmRzKSwgYmlhcyA9IC0xO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xufVxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gICAgLy8gQnJvd3NlciAoaW4gY2FyZXRQb3NpdGlvbi9SYW5nZUZyb21Qb2ludCkgd2lsbCBhZ3Jlc3NpdmVseVxuICAgIC8vIG5vcm1hbGl6ZSB0b3dhcmRzIG5lYXJieSBpbmxpbmUgbm9kZXMuIFNpbmNlIHdlIGFyZSBpbnRlcmVzdGVkIGluXG4gICAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgICAvLyBvZiBub2RlcyB0byBzZWUgaWYgdGhlcmUgYXJlIGJsb2NrIG5vZGVzIHRoYXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgLy8gZmFsbCBvdXRzaWRlIG9mLiBJZiBzbywgd2UgdGFrZSB0aGUgcG9zaXRpb24gYmVmb3JlL2FmdGVyIHRoYXRcbiAgICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICAgIGxldCBvdXRzaWRlQmxvY2sgPSAtMTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlLCBzYXdCbG9jayA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGN1ciA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpLCByZWN0O1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGRlc2MuZG9tLm5vZGVUeXBlID09IDEgJiYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50IHx8ICFkZXNjLmNvbnRlbnRET00pICYmXG4gICAgICAgICAgICAvLyBJZ25vcmUgZWxlbWVudHMgd2l0aCB6ZXJvLXNpemUgYm91bmRpbmcgcmVjdGFuZ2xlc1xuICAgICAgICAgICAgKChyZWN0ID0gZGVzYy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLndpZHRoIHx8IHJlY3QuaGVpZ2h0KSkge1xuICAgICAgICAgICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICEvXlQoUnxCT0RZfEhFQUR8Rk9PVCkkLy50ZXN0KGRlc2MuZG9tLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgdGhlIGhvcml6b250YWwgdGVzdCB0byB0aGUgaW5uZXJtb3N0IGJsb2NrLiBWZXJ0aWNhbCBmb3IgYW55IHBhcmVudC5cbiAgICAgICAgICAgICAgICBpZiAoIXNhd0Jsb2NrICYmIHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNhd0Jsb2NrICYmIHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICAgICAgc2F3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCAmJiAhZGVzYy5ub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIGFib3ZlIHRoZSByaWdodCBzaWRlIG9mIGFuIHVuZWRpdGFibGUgbm9kZSwgQ2hyb21lIHdpbGwgcmVwb3J0IGEgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS5cbiAgICAgICAgaWYgKHdlYmtpdCAmJiBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIChwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdKS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgJiYgcHJldi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPj0gY29vcmRzLnRvcClcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpXG4gICAgICAgIHJldHVybiAkaGVhZC5wb3MgPT0gJGhlYWQuc3RhcnQoKSB8fCAkaGVhZC5wb3MgPT0gJGhlYWQuZW5kKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNoaWxkLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHZpZXcsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNlbFJhbmdlID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYnJLbHVkZ2UgPSBmYWxzZTtcbiAgICAgICAgLy8gT24gRmlyZWZveCwgdXNpbmcgU2VsZWN0aW9uLmNvbGxhcHNlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGFcbiAgICAgICAgLy8gQlIgbm9kZSBmb3Igc29tZSByZWFzb24gZG9lc24ndCBhbHdheXMgd29yayAoIzEwNzMpLiBPbiBTYWZhcmksXG4gICAgICAgIC8vIHRoZSBjdXJzb3Igc29tZXRpbWVzIGluZXhwbGljYWJsZSB2aXN1YWxseSBsYWdzIGJlaGluZCBpdHNcbiAgICAgICAgLy8gcmVwb3J0ZWQgcG9zaXRpb24gaW4gc3VjaCBzaXR1YXRpb25zICgjMTA5MikuXG4gICAgICAgIGlmICgoZ2Vja28gfHwgc2FmYXJpKSAmJiBhbmNob3IgPT0gaGVhZCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBhbmNob3JET007XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSAhIShvZmZzZXQgJiYgbm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0gPT0gXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgLy8gSXNzdWUgIzExMjhcbiAgICAgICAgICAgICAgICBpZiAoYnJLbHVkZ2UgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgYWZ0ZXI7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9IHNjYW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NID0geyBub2RlOiBhZnRlci5wYXJlbnROb2RlLCBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjID0gc2Nhbi5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSBwcmV2ICYmIChwcmV2Lm5vZGVOYW1lID09IFwiQlJcIiB8fCBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3ggY2FuIGFjdCBzdHJhbmdlbHkgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGZyb250IG9mIGFuXG4gICAgICAgIC8vIHVuZWRpdGFibGUgbm9kZS4gU2VlICMxMTYzIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA5NTM2XG4gICAgICAgIGlmIChnZWNrbyAmJiBzZWxSYW5nZS5mb2N1c05vZGUgJiYgc2VsUmFuZ2UuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBzZWxSYW5nZS5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gc2VsUmFuZ2UuZm9jdXNOb2RlLmNoaWxkTm9kZXNbc2VsUmFuZ2UuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBzZWxSYW5nZS5hbmNob3JOb2RlLCBzZWxSYW5nZS5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBzZWxSYW5nZS5mb2N1c05vZGUsIHNlbFJhbmdlLmZvY3VzT2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgbGV0IGRvbVNlbEV4dGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZG9tU2VsLmV4dGVuZCB8fCBhbmNob3IgPT0gaGVhZCkgJiYgIShicktsdWRnZSAmJiBnZWNrbykpIHtcbiAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgIT0gaGVhZClcbiAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkb21TZWxFeHRlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2l0aCBDaHJvbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhZnRlciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UsIGV2ZW4gd2hlbiBpdCBzaG91bGQgYmUgdmFsaWQuIFRoaXMgYXBwZWFycyB0byBiZSBhIGJ1ZywgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHVzaW5nIGV4dGVuZC5cbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIHRoaXMgY291bGQgY3Jhc2ggb24gU2FmYXJpIGlmIHRoZSBlZGl0b3IgaXMgaGlkZGVuLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSB3YXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IgPiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NO1xuICAgICAgICAgICAgICAgIGhlYWRET00gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldCBjb250ZW50TG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAvLyBieSBhIERPTSBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcmVkcmF3IGl0LlxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IGVuZCA/IGZyb20gPD0gZW5kICYmIHRvID49IG9mZnNldCA6IGZyb20gPCBlbmQgJiYgdG8gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbnNpZGUgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXIsIGVuZEluc2lkZSA9IGVuZCAtIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5KGZyb20gLSBzdGFydEluc2lkZSwgdG8gLSBzdGFydEluc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5wYXJlbnQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCwgbGV2ZWwrKykge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpXG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yU2VsZWN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc1RleHQodGV4dCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgd2lkZ2V0IGRlc2MgcmVwcmVzZW50cyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlXG4vLyBkcmF3biBiZXR3ZWVuIHRoZSBkb2N1bWVudCBub2Rlcy5cbmNsYXNzIFdpZGdldFZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgICAgICBpZiAodHlwZW9mIGRvbSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBkb20gPSBkb20odmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgICByZXR1cm4gc3RvcCA/IHN0b3AoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvclNlbGVjdGlvbigpIHsgcmV0dXJuICEhdGhpcy53aWRnZXQudHlwZS5zcGVjLnJlbGF4ZWRTaWRlOyB9XG4gICAgZ2V0IHNpZGUoKSB7IHJldHVybiB0aGlzLndpZGdldC50eXBlLnNpZGU7IH1cbn1cbmNsYXNzIENvbXBvc2l0aW9uVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBkb20sIHRleHRET00sIHRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy50ZXh0RE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlO1xuICAgIH1cbn1cbi8vIEEgbWFyayBkZXNjIHJlcHJlc2VudHMgYSBtYXJrLiBNYXkgaGF2ZSBtdWx0aXBsZSBjaGlsZHJlbixcbi8vIGRlcGVuZGluZyBvbiBob3cgdGhlIG1hcmsgaXMgc3BsaXQuIE5vdGUgdGhhdCBtYXJrcyBhcmUgZHJhd24gdXNpbmdcbi8vIGEgZml4ZWQgbmVzdGluZyBvcmRlciwgZm9yIHNpbXBsaWNpdHkgYW5kIHByZWRpY3RhYmlsaXR5LCBzbyBpblxuLy8gc29tZSBjYXNlcyB0aGV5IHdpbGwgYmUgc3BsaXQgbW9yZSBvZnRlbiB0aGFuIHdvdWxkIGFwcGVhclxuLy8gbmVjZXNzYXJ5LlxuY2xhc3MgTWFya1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NLCBzcGVjKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG1hcmssIHZpZXcsIGlubGluZSk7XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICAgICAgICBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpLCBudWxsLCBtYXJrLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tLCBzcGVjKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZKSB8fCB0aGlzLm1hcmsudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbWFyazogdGhpcy5tYXJrLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubWFyay5hdHRycywgY29udGVudEVsZW1lbnQ6IHRoaXMuY29udGVudERPTSB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24gPyB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24obXV0YXRpb24pIDogc3VwZXIuaWdub3JlTXV0YXRpb24obXV0YXRpb24pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVzdHJveSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgIGxldCBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSwgbnVsbCwgbm9kZS5hdHRycyk7XG4gICAgICAgICAgICAoeyBkb20sIGNvbnRlbnRET00gfSA9IHNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3LCBpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldywgaSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3LCBpKTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldywgMCk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlO1xuICAgICAgICBpZiAoIXRleHROb2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyh0ZXh0Tm9kZS5wYXJlbnROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRleHQgaW4gdGhlIGZvY3VzZWQgbm9kZSBpbiB0aGUgbm9kZSwgc3RvcCBpZiBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gdGhlcmUgKG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgdGhyb3VnaCBvdGhlciBtZWFucywgaW4gd2hpY2hcbiAgICAgICAgICAgIC8vIGNhc2UgaXQgc2hvdWxkIG92ZXJ3cml0dGVuKVxuICAgICAgICAgICAgbGV0IHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICBsZXQgdGV4dFBvcyA9IGZpbmRUZXh0SW5GcmFnbWVudCh0aGlzLm5vZGUuY29udGVudCwgdGV4dCwgZnJvbSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHRQb3MgPCAwID8gbnVsbCA6IHsgbm9kZTogdGV4dE5vZGUsIHBvczogdGV4dFBvcywgdGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGV4dE5vZGUsIHBvczogLTEsIHRleHQ6IFwiXCIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCB7IG5vZGUsIHBvcywgdGV4dCB9KSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIGFscmVhZHkgcGFydCBvZiBhIGxvY2FsIHZpZXcgZGVzYywgbGVhdmUgaXQgdGhlcmVcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGVzYyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29tcG9zaXRpb24gdmlldyBmb3IgdGhlIG9ycGhhbmVkIG5vZGVzXG4gICAgICAgIGxldCB0b3BOb2RlID0gbm9kZTtcbiAgICAgICAgZm9yICg7OyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucG1WaWV3RGVzYylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBuZXcgQ29tcG9zaXRpb25WaWV3RGVzYyh0aGlzLCB0b3BOb2RlLCBub2RlLCB0ZXh0KTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnB1c2goZGVzYyk7XG4gICAgICAgIC8vIFBhdGNoIHVwIHRoaXMuY2hpbGRyZW4gdG8gY29udGFpbiB0aGUgY29tcG9zaXRpb24gdmlld1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gcmVwbGFjZU5vZGVzKHRoaXMuY2hpbGRyZW4sIHBvcywgcG9zICsgdGV4dC5sZW5ndGgsIHZpZXcsIGRlc2MpO1xuICAgIH1cbiAgICAvLyBJZiB0aGlzIGRlc2MgbXVzdCBiZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBnaXZlbiBub2RlIGRlY29yYXRpb24sXG4gICAgLy8gZG8gc28gYW5kIHJldHVybiB0cnVlLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICAgIHVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pIHtcbiAgICAgICAgaWYgKHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICAgICAgbGV0IG9sZERPTSA9IHRoaXMuZG9tO1xuICAgICAgICB0aGlzLmRvbSA9IHBhdGNoT3V0ZXJEZWNvKHRoaXMuZG9tLCB0aGlzLm5vZGVET00sIGNvbXB1dGVPdXRlckRlY28odGhpcy5vdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSwgY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSBvbGRET00pIHtcbiAgICAgICAgICAgIG9sZERPTS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgfVxuICAgIC8vIE1hcmsgdGhpcyBub2RlIGFzIGJlaW5nIHRoZSBzZWxlY3RlZCBub2RlLlxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVET00uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgbm9kZSBtYXJraW5nIGZyb20gdGhpcyBub2RlLlxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZURPTS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiB0aGlzLm5vZGUudGV4dCA9PSB0ZXh0OyB9XG59XG4vLyBBIGR1bW15IGRlc2MgdXNlZCB0byB0YWcgdHJhaWxpbmcgQlIgb3IgSU1HIG5vZGVzIGNyZWF0ZWQgdG8gd29ya1xuLy8gYXJvdW5kIGNvbnRlbnRFZGl0YWJsZSB0ZXJyaWJsZW5lc3MuXG5jbGFzcyBUcmFpbGluZ0hhY2tWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lOyB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7IH1cbn1cbi8vIEEgc2VwYXJhdGUgc3ViY2xhc3MgaXMgdXNlZCBmb3IgY3VzdG9taXplZCBub2RlIHZpZXdzLCBzbyB0aGF0IHRoZVxuLy8gZXh0cmEgY2hlY2tzIG9ubHkgaGF2ZSB0byBiZSBtYWRlIGZvciBub2RlcyB0aGF0IGFyZSBhY3R1YWxseVxuLy8gY3VzdG9taXplZC5cbmNsYXNzIEN1c3RvbU5vZGVWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvLyBBIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgZ2V0cyB0byBkZWNpZGUgd2hldGhlciB0aGUgdXBkYXRlIGdvZXNcbiAgICAvLyB0aHJvdWdoLiBJZiBpdCBkb2VzLCBhbmQgdGhlcmUncyBhIGBjb250ZW50RE9NYCBub2RlLCBvdXIgbG9naWNcbiAgICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUgJiYgKHRoaXMubm9kZS50eXBlID09IG5vZGUudHlwZSB8fCB0aGlzLnNwZWMubXVsdGlUeXBlKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3BlYy51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudERPTSAmJiAhbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZWxlY3ROb2RlID8gdGhpcy5zcGVjLnNlbGVjdE5vZGUoKSA6IHN1cGVyLnNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlID8gdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSgpIDogc3VwZXIuZGVzZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24gPyB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldy5yb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldywgcGFyZW50SW5kZXgpIHtcbiAgICAgICAgbGV0IGtlZXAgPSAwLCBkZXB0aCA9IHRoaXMuc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIGxldCBtYXhLZWVwID0gTWF0aC5taW4oZGVwdGgsIG1hcmtzLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgbWF4S2VlcCAmJlxuICAgICAgICAgICAgKGtlZXAgPT0gZGVwdGggLSAxID8gdGhpcy50b3AgOiB0aGlzLnN0YWNrWyhrZWVwICsgMSkgPDwgMV0pXG4gICAgICAgICAgICAgICAgLm1hdGNoZXNNYXJrKG1hcmtzW2tlZXBdKSAmJiBtYXJrc1trZWVwXS50eXBlLnNwZWMuc3Bhbm5pbmcgIT09IGZhbHNlKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IGRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lSZXN0KCk7XG4gICAgICAgICAgICB0aGlzLnRvcC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZGVwdGggPCBtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnRvcCwgdGhpcy5pbmRleCArIDEpO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gLTEsIHNjYW5UbyA9IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXJlbnRJbmRleCA8IHRoaXMucHJlTWF0Y2guaW5kZXgpXG4gICAgICAgICAgICAgICAgc2NhblRvID0gTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHNjYW5Ubyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHNjYW5UbzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pICYmICF0aGlzLmlzTG9ja2VkKG5leHQuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMCwgbWFya0Rlc2MpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gbWFya0Rlc2M7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIG5vZGUgZGVzYyBtYXRjaGluZyB0aGUgZ2l2ZW4gZGF0YS4gU2tpcCBvdmVyIGl0IGFuZFxuICAgIC8vIHJldHVybiB0cnVlIHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICBmaW5kTm9kZU1hdGNoKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSAtMSwgdGFyZ2V0RGVzYztcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXggJiZcbiAgICAgICAgICAgICh0YXJnZXREZXNjID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVzW2luZGV4IC0gdGhpcy5wcmVNYXRjaC5pbmRleF0pLnBhcmVudCA9PSB0aGlzLnRvcCAmJlxuICAgICAgICAgICAgdGFyZ2V0RGVzYy5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy50b3AuY2hpbGRyZW4uaW5kZXhPZih0YXJnZXREZXNjLCB0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4LCBlID0gTWF0aC5taW4odGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoLCBpICsgNSk7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pICYmICF0aGlzLnByZU1hdGNoLm1hdGNoZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlTm9kZUF0KG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCwgdmlldykge1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIGlmIChjaGlsZC5kaXJ0eSA9PSBOT0RFX0RJUlRZICYmIGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NKVxuICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5kSW5kZXhXaXRoQ2hpbGQoZG9tTm9kZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBkb21Ob2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXSA9PSBkZXNjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tTm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gdXBkYXRlIHRoZSBuZXh0IG5vZGUsIGlmIGFueSwgdG8gdGhlIGdpdmVuIGRhdGEuIENoZWNrc1xuICAgIC8vIHByZS1tYXRjaGVzIHRvIGF2b2lkIG92ZXJ3cml0aW5nIG5vZGVzIHRoYXQgY291bGQgc3RpbGwgYmUgdXNlZC5cbiAgICB1cGRhdGVOZXh0Tm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaW5kZXgsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBOb2RlVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlTWF0Y2ggPSB0aGlzLnByZU1hdGNoLm1hdGNoZWQuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVNYXRjaCAhPSBudWxsICYmIHByZU1hdGNoICE9IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRET00gPSBuZXh0LmRvbSwgdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB1cGRhdGUgaWYgbmV4dERPTSBpcyBvciBjb250YWlucyB0aGlzLmxvY2ssIGV4Y2VwdCBpZlxuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSB0ZXh0IG5vZGUgd2hvc2UgY29udGVudCBhbHJlYWR5IG1hdGNoZXMgdGhlIG5ldyB0ZXh0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHdob3NlIGRlY29yYXRpb25zIG1hdGNoIHRoZSBuZXcgb25lcy5cbiAgICAgICAgICAgICAgICBsZXQgbG9ja2VkID0gdGhpcy5pc0xvY2tlZChuZXh0RE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGUuaXNUZXh0ICYmIG5leHQubm9kZSAmJiBuZXh0Lm5vZGUuaXNUZXh0ICYmIG5leHQubm9kZURPTS5ub2RlVmFsdWUgPT0gbm9kZS50ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRpcnR5ICE9IE5PREVfRElSVFkgJiYgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIG5leHQub3V0ZXJEZWNvKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWxvY2tlZCAmJiAodXBkYXRlZCA9IHRoaXMucmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgbm9kZSB3aXRoIGNvbnRlbnQgaXMgcmVwbGFjZWQgYnkgYSBkaWZmZXJlbnQgbm9kZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGNvbnRlbnQsIG1vdmUgb3ZlciBpdHMgY2hpbGRyZW4uXG4gICAgcmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgaWYgKG5leHQuZGlydHkgfHwgbm9kZS5pc0F0b20gfHwgIW5leHQuY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAhbmV4dC5ub2RlLmNvbnRlbnQuZXEobm9kZS5jb250ZW50KSB8fFxuICAgICAgICAgICAgIXNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykgfHwgIWlubmVyRGVjby5lcShuZXh0LmlubmVyRGVjbykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKHdyYXBwZXIuY29udGVudERPTSkge1xuICAgICAgICAgICAgd3JhcHBlci5jaGlsZHJlbiA9IG5leHQuY2hpbGRyZW47XG4gICAgICAgICAgICBuZXh0LmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiB3cmFwcGVyLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLnBhcmVudCA9IHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cbiAgICBhZGROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSlcbiAgICAgICAgICAgIGRlc2MudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmXG4gICAgICAgICAgICAod2lkZ2V0ID09IG5leHQud2lkZ2V0IHx8ICFuZXh0LndpZGdldC50eXBlLnRvRE9NLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IG5ldyBXaWRnZXRWaWV3RGVzYyh0aGlzLnRvcCwgd2lkZ2V0LCB2aWV3LCBwb3MpO1xuICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhIHRleHRibG9jayBsb29rcyBhbmQgYmVoYXZlcyBjb3JyZWN0bHkgaW5cbiAgICAvLyBjb250ZW50RWRpdGFibGUuXG4gICAgYWRkVGV4dGJsb2NrSGFja3MoKSB7XG4gICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0sIHBhcmVudCA9IHRoaXMudG9wO1xuICAgICAgICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFzdENoaWxkIHx8IC8vIEVtcHR5IHRleHRibG9ja1xuICAgICAgICAgICAgIShsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Vmlld0Rlc2MpIHx8XG4gICAgICAgICAgICAvXFxuJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMudmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgJiYgL1xccyQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgICAgICAgICBpZiAoKHNhZmFyaSB8fCBjaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIklNR1wiLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIkJSXCIsIHRoaXMudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIYWNrTm9kZShub2RlTmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AgJiYgdGhpcy5pbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggJiYgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdLm1hdGNoZXNIYWNrKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgICAgICAgICBkb20uYWx0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiO1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBuZXcgVHJhaWxpbmdIYWNrVmlld0Rlc2ModGhpcy50b3AsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSB0aGlzLnRvcClcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChoYWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgaGFjayk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jayAmJiAobm9kZSA9PSB0aGlzLmxvY2sgfHwgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGFpbnModGhpcy5sb2NrLnBhcmVudE5vZGUpKTtcbiAgICB9XG59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy5cbmZ1bmN0aW9uIHByZU1hdGNoKGZyYWcsIHBhcmVudERlc2MpIHtcbiAgICBsZXQgY3VyRGVzYyA9IHBhcmVudERlc2MsIGRlc2NJID0gY3VyRGVzYy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGZJID0gZnJhZy5jaGlsZENvdW50LCBtYXRjaGVkID0gbmV3IE1hcCwgbWF0Y2hlcyA9IFtdO1xuICAgIG91dGVyOiB3aGlsZSAoZkkgPiAwKSB7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoZGVzY0kpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGN1ckRlc2MuY2hpbGRyZW5bZGVzY0kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgICAgICBjdXJEZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0kgPSBuZXh0LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJEZXNjID09IHBhcmVudERlc2MpIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc2NJID0gY3VyRGVzYy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjdXJEZXNjKTtcbiAgICAgICAgICAgICAgICBjdXJEZXNjID0gY3VyRGVzYy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLS1mSTtcbiAgICAgICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICAgICAgICBtYXRjaGVzLnB1c2goZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBmSSwgbWF0Y2hlZCwgbWF0Y2hlczogbWF0Y2hlcy5yZXZlcnNlKCkgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYS50eXBlLnNpZGUgLSBiLnR5cGUuc2lkZTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gYWJzdHJhY3RzIGl0ZXJhdGluZyBvdmVyIHRoZSBub2RlcyBhbmQgZGVjb3JhdGlvbnMgaW5cbi8vIGEgZnJhZ21lbnQuIENhbGxzIGBvbk5vZGVgIGZvciBlYWNoIG5vZGUsIHdpdGggaXRzIGxvY2FsIGFuZCBjaGlsZFxuLy8gZGVjb3JhdGlvbnMuIFNwbGl0cyB0ZXh0IG5vZGVzIHdoZW4gdGhlcmUgaXMgYSBkZWNvcmF0aW9uIHN0YXJ0aW5nXG4vLyBvciBlbmRpbmcgaW5zaWRlIG9mIHRoZW0uIENhbGxzIGBvbldpZGdldGAgZm9yIGVhY2ggd2lkZ2V0LlxuZnVuY3Rpb24gaXRlckRlY28ocGFyZW50LCBkZWNvLCBvbldpZGdldCwgb25Ob2RlKSB7XG4gICAgbGV0IGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gICAgLy8gU2ltcGxlLCBjaGVhcCB2YXJpYW50IGZvciB3aGVuIHRoZXJlIGFyZSBubyBsb2NhbCBkZWNvcmF0aW9uc1xuICAgIGlmIChsb2NhbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaSk7XG4gICAgICAgICAgICBvbk5vZGUoY2hpbGQsIGxvY2FscywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVjb0luZGV4ID0gMCwgYWN0aXZlID0gW10sIHJlc3ROb2RlID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgICAgICBsZXQgd2lkZ2V0LCB3aWRnZXRzO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbG9jYWxzW2RlY29JbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChuZXh0LndpZGdldCkge1xuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbd2lkZ2V0XSkpLnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRzLnNvcnQoY29tcGFyZVNpZGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0c1tpXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0LCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkLCBpbmRleDtcbiAgICAgICAgaWYgKHJlc3ROb2RlKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY2hpbGQgPSByZXN0Tm9kZTtcbiAgICAgICAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQocGFyZW50SW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8PSBvZmZzZXQgJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPiBvZmZzZXQpXG4gICAgICAgICAgICBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgY3V0QXQgPSBlbmQ7XG4gICAgICAgICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8IGN1dEF0KVxuICAgICAgICAgICAgICAgICAgICBjdXRBdCA9IGFjdGl2ZVtpXS50bztcbiAgICAgICAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3ROb2RlID0gY2hpbGQuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dCgwLCBjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvIDwgZW5kKVxuICAgICAgICAgICAgICAgIGRlY29JbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRlckRlY28gPSBjaGlsZC5pc0lubGluZSAmJiAhY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihkID0+ICFkLmlubGluZSkgOiBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgb25Ob2RlKGNoaWxkLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGluZGV4KTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbn1cbi8vIExpc3QgbWFya2VycyBpbiBNb2JpbGUgU2FmYXJpIHdpbGwgbXlzdGVyaW91c2x5IGRpc2FwcGVhclxuLy8gc29tZXRpbWVzLiBUaGlzIHdvcmtzIGFyb3VuZCB0aGF0LlxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgICAgICBsZXQgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICB9XG59XG4vLyBGaW5kIGEgcGllY2Ugb2YgdGV4dCBpbiBhbiBpbmxpbmUgZnJhZ21lbnQsIG92ZXJsYXBwaW5nIGZyb20tdG9cbmZ1bmN0aW9uIGZpbmRUZXh0SW5GcmFnbWVudChmcmFnLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgZnJhZy5jaGlsZENvdW50ICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZy5jaGlsZChpKyspLCBjaGlsZFN0YXJ0ID0gcG9zO1xuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmICghY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzdHIgPSBjaGlsZC50ZXh0O1xuICAgICAgICB3aGlsZSAoaSA8IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnLmNoaWxkKGkrKyk7XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmICghbmV4dC5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdHIgKz0gbmV4dC50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0byAmJiBzdHIuc2xpY2UodG8gLSB0ZXh0Lmxlbmd0aCAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCkgPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdG8gLSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGNoaWxkU3RhcnQgPCB0byA/IHN0ci5sYXN0SW5kZXhPZih0ZXh0LCB0byAtIGNoaWxkU3RhcnQgLSAxKSA6IC0xO1xuICAgICAgICAgICAgaWYgKGZvdW5kID49IDAgJiYgZm91bmQgKyB0ZXh0Lmxlbmd0aCArIGNoaWxkU3RhcnQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRTdGFydCArIGZvdW5kO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgc3RyLmxlbmd0aCA+PSAodG8gKyB0ZXh0Lmxlbmd0aCkgLSBjaGlsZFN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgc3RyLnNsaWNlKHRvIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0ICsgdGV4dC5sZW5ndGgpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8vIFJlcGxhY2UgcmFuZ2UgZnJvbS10byBpbiBhbiBhcnJheSBvZiB2aWV3IGRlc2NzIHdpdGggcmVwbGFjZW1lbnRcbi8vIChtYXkgYmUgbnVsbCB0byBqdXN0IGRlbGV0ZSkuIFRoaXMgZ29lcyB2ZXJ5IG11Y2ggYWdhaW5zdCB0aGUgZ3JhaW5cbi8vIG9mIHRoZSByZXN0IG9mIHRoaXMgY29kZSwgd2hpY2ggdGVuZHMgdG8gY3JlYXRlIG5vZGVzIHdpdGggdGhlXG4vLyByaWdodCBzaGFwZSBpbiBvbmUgZ28sIHJhdGhlciB0aGFuIG1lc3Npbmcgd2l0aCB0aGVtIGFmdGVyXG4vLyBjcmVhdGlvbiwgYnV0IGlzIG5lY2Vzc2FyeSBpbiB0aGUgY29tcG9zaXRpb24gaGFjay5cbmZ1bmN0aW9uIHJlcGxhY2VOb2Rlcyhub2RlcywgZnJvbSwgdG8sIHZpZXcsIHJlcGxhY2VtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZXNbaV0sIHN0YXJ0ID0gb2ZmLCBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKDAsIGZyb20gLSBzdGFydCwgdmlldykpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKHRvIC0gc3RhcnQsIGNoaWxkLnNpemUsIHZpZXcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbiA9IG51bGwpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBuZWFyZXN0RGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb21TZWwuZm9jdXNOb2RlKSwgaW5XaWRnZXQgPSBuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzYy5zaXplID09IDA7XG4gICAgbGV0IGhlYWQgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIDEpO1xuICAgIGlmIChoZWFkIDwgMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUoaGVhZCksIGFuY2hvciwgc2VsZWN0aW9uO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSkge1xuICAgICAgICBhbmNob3IgPSBoZWFkO1xuICAgICAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpXG4gICAgICAgICAgICBuZWFyZXN0RGVzYyA9IG5lYXJlc3REZXNjLnBhcmVudDtcbiAgICAgICAgbGV0IG5lYXJlc3REZXNjTm9kZSA9IG5lYXJlc3REZXNjLm5vZGU7XG4gICAgICAgIGlmIChuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzY05vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5lYXJlc3REZXNjTm9kZSkgJiYgbmVhcmVzdERlc2MucGFyZW50XG4gICAgICAgICAgICAmJiAhKG5lYXJlc3REZXNjTm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3IE5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tU2VsIGluc3RhbmNlb2Ygdmlldy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5TZWxlY3Rpb24gJiYgZG9tU2VsLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBsZXQgbWluID0gaGVhZCwgbWF4ID0gaGVhZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tU2VsLnJhbmdlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvbVNlbC5nZXRSYW5nZUF0KGkpO1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmlldy5kb2NWaWV3LnBvc0Zyb21ET00ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCAxKSk7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW4gPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgW2FuY2hvciwgaGVhZF0gPSBtYXggPT0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID8gW21heCwgbWluXSA6IFttaW4sIG1heF07XG4gICAgICAgICAgICAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNob3IgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYmlhcyA9IG9yaWdpbiA9PSBcInBvaW50ZXJcIiB8fCAodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCA8ICRoZWFkLnBvcyAmJiAhaW5XaWRnZXQpID8gMSA6IC0xO1xuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGVkaXRvck93bnNTZWxlY3Rpb24odmlldykge1xuICAgIHJldHVybiB2aWV3LmVkaXRhYmxlID8gdmlldy5oYXNGb2N1cygpIDpcbiAgICAgICAgaGFzU2VsZWN0aW9uKHZpZXcpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250YWlucyh2aWV3LmRvbSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0RPTSh2aWV3LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCk7XG4gICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gVGhlIGRlbGF5ZWQgZHJhZyBzZWxlY3Rpb24gY2F1c2VzIGlzc3VlcyB3aXRoIENlbGwgU2VsZWN0aW9uc1xuICAgIC8vIGluIFNhZmFyaS4gQW5kIHRoZSBkcmFnIHNlbGVjdGlvbiBkZWxheSBpcyB0byB3b3JrYXJvbmQgaXNzdWVzXG4gICAgLy8gd2hpY2ggb25seSBwcmVzZW50IGluIENocm9tZS5cbiAgICBpZiAoIWZvcmNlICYmIHZpZXcuaW5wdXQubW91c2VEb3duICYmIHZpZXcuaW5wdXQubW91c2VEb3duLmFsbG93RGVmYXVsdCAmJiBjaHJvbWUpIHtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgY3VyU2VsID0gdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgJiYgY3VyU2VsLmFuY2hvck5vZGUgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCBjdXJTZWwuYW5jaG9yTm9kZSwgY3VyU2VsLmFuY2hvck9mZnNldCkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcikge1xuICAgICAgICBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgYW5jaG9yLCBoZWFkIH0gPSBzZWwsIHJlc2V0RWRpdGFibGVGcm9tLCByZXNldEVkaXRhYmxlVG87XG4gICAgICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSAmJiAhKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAoIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlRnJvbSA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC5mcm9tKTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5ICYmICFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZVRvID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLnRvKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRvY1ZpZXcuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UpO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSlcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlVG8pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlVG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChcIm9uc2VsZWN0aW9uY2hhbmdlXCIgaW4gZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY29ubmVjdFNlbGVjdGlvbigpO1xufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIFdlYmtpdCBub3QgYWxsb3dpbmcgYSBzZWxlY3Rpb24gdG8gc3RhcnQvZW5kXG4vLyBiZXR3ZWVuIG5vbi1lZGl0YWJsZSBibG9jayBub2Rlcy4gV2UgYnJpZWZseSBtYWtlIHNvbWV0aGluZ1xuLy8gZWRpdGFibGUsIHNldCB0aGUgc2VsZWN0aW9uLCB0aGVuIHNldCBpdCB1bmVkaXRhYmxlIGFnYWluLlxuY29uc3QgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSBzYWZhcmkgfHwgY2hyb21lICYmIGNocm9tZV92ZXJzaW9uIDwgNjM7XG5mdW5jdGlvbiB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBwb3MpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgbGV0IGFmdGVyID0gb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIDogbnVsbDtcbiAgICBsZXQgYmVmb3JlID0gb2Zmc2V0ID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdIDogbnVsbDtcbiAgICBpZiAoc2FmYXJpICYmIGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKCFiZWZvcmUgfHwgYmVmb3JlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpKSB7XG4gICAgICAgIGlmIChhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSlcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIGlmIChzYWZhcmkgJiYgZWxlbWVudC5kcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIHJlc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IGRvbVNlbC5hbmNob3JOb2RlLCBvZmZzZXQgPSBkb21TZWwuYW5jaG9yT2Zmc2V0O1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkID0gKCkgPT4ge1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBkb21TZWwuYW5jaG9yT2Zmc2V0ICE9IG9mZnNldCkge1xuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICBpZiAoIWRvbVNlbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBub2RlID0gdmlldy5jdXJzb3JXcmFwcGVyLmRvbSwgaW1nID0gbm9kZS5ub2RlTmFtZSA9PSBcIklNR1wiO1xuICAgIGlmIChpbWcpXG4gICAgICAgIGRvbVNlbC5jb2xsYXBzZShub2RlLnBhcmVudE5vZGUsIGRvbUluZGV4KG5vZGUpICsgMSk7XG4gICAgZWxzZVxuICAgICAgICBkb21TZWwuY29sbGFwc2Uobm9kZSwgMCk7XG4gICAgLy8gS2x1ZGdlIHRvIGtpbGwgJ2NvbnRyb2wgc2VsZWN0aW9uJyBpbiBJRTExIHdoZW4gc2VsZWN0aW5nIGFuXG4gICAgLy8gaW52aXNpYmxlIGN1cnNvciB3cmFwcGVyLCBzaW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBpbiB0aG9zZSB3ZWlyZFxuICAgIC8vIHJlc2l6ZSBoYW5kbGVzIGFuZCBhIHNlbGVjdGlvbiB0aGF0IGNvbnNpZGVycyB0aGUgYWJzb2x1dGVseVxuICAgIC8vIHBvc2l0aW9uZWQgd3JhcHBlciwgcmF0aGVyIHRoYW4gdGhlIHJvb3QgZWRpdGFibGUgbm9kZSwgdGhlXG4gICAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICAgIGlmICghaW1nICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmIGllICYmIGllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpIHtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQoc2VsLmZyb20pO1xuICAgICAgICBpZiAoZGVzYyAhPSB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICBkZXNjLnNlbGVjdE5vZGUoKTtcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSBkZXNjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgfVxufVxuLy8gQ2xlYXIgYWxsIERPTSBzdGF0ZWZ1bG5lc3Mgb2YgdGhlIGxhc3Qgbm9kZSBzZWxlY3Rpb24uXG5mdW5jdGlvbiBjbGVhck5vZGVTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLnBhcmVudClcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MuZGVzZWxlY3ROb2RlKCk7XG4gICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiY3JlYXRlU2VsZWN0aW9uQmV0d2VlblwiLCBmID0+IGYodmlldywgJGFuY2hvciwgJGhlYWQpKVxuICAgICAgICB8fCBUZXh0U2VsZWN0aW9uLmJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xufVxuZnVuY3Rpb24gaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3LmVkaXRhYmxlICYmICF2aWV3Lmhhc0ZvY3VzKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaGFzU2VsZWN0aW9uKHZpZXcpO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuYW5jaG9yTm9kZS5wYXJlbnROb2RlIDogc2VsLmFuY2hvck5vZGUpICYmXG4gICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCB2aWV3LmRvbS5jb250YWlucyhzZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUgOiBzZWwuZm9jdXNOb2RlKSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhbmNob3JJblJpZ2h0UGxhY2Uodmlldykge1xuICAgIGxldCBhbmNob3JET00gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIDApO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgcmV0dXJuIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CbG9jayhzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHsgJGFuY2hvciwgJGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgJHNpZGUgPSBkaXIgPiAwID8gJGFuY2hvci5tYXgoJGhlYWQpIDogJGFuY2hvci5taW4oJGhlYWQpO1xuICAgIGxldCAkc3RhcnQgPSAhJHNpZGUucGFyZW50LmlubGluZUNvbnRlbnQgPyAkc2lkZSA6ICRzaWRlLmRlcHRoID8gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzaWRlLmFmdGVyKCkgOiAkc2lkZS5iZWZvcmUoKSkgOiBudWxsO1xuICAgIHJldHVybiAkc3RhcnQgJiYgU2VsZWN0aW9uLmZpbmRGcm9tKCRzdGFydCwgZGlyKTtcbn1cbmZ1bmN0aW9uIGFwcGx5KHZpZXcsIHNlbCkge1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgJGhlYWQgfSA9IHNlbCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQgfHwgIW5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkbmV3SGVhZCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zICsgbm9kZS5ub2RlU2l6ZSAqIChkaXIgPCAwID8gLTEgOiAxKSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oc2VsLiRhbmNob3IsICRuZXdIZWFkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlbC5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSkpIHtcbiAgICAgICAgICAgIGxldCAkaGVhZCA9IHNlbC4kaGVhZCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgICAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKGRpciA8IDAgPyB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUpIDogJGhlYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdlYmtpdCkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIHdpbGwgaW50cm9kdWNlIGV4dHJhIHBvaW50bGVzcyBjdXJzb3JcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbnMgYXJvdW5kIGlubGluZSB1bmVkaXRhYmxlIG5vZGVzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gdGFrZSBvdmVyIGFuZCBtb3ZlIHRoZSBjdXJzb3IgcGFzdCB0aGVtICgjOTM3KVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGRpciA8IDAgPyBub2RlUG9zIDogbm9kZVBvcyArIG5vZGUubm9kZVNpemUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWwubm9kZS5pc0lubGluZSkge1xuICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZUxlbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0lnbm9yYWJsZShkb20sIGRpcikge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5zaXplID09IDAgJiYgKGRpciA8IDAgfHwgZG9tLm5leHRTaWJsaW5nIHx8IGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpO1xufVxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpIHtcbiAgICByZXR1cm4gZGlyIDwgMCA/IHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykgOiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldyk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBhZnRlciBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcywgd2hpY2ggd2lsbCBjb25mdXNlIHRoZSBicm93c2VyJ3MgY3Vyc29yIG1vdGlvbiBsb2dpYy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlO1xuICAgIC8vIEdlY2tvIHdpbGwgZG8gb2RkIHRoaW5ncyB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZGlyZWN0bHkgaW4gZnJvbnRcbiAgICAvLyBvZiBhIG5vbi1lZGl0YWJsZSBub2RlLCBzbyBpbiB0aGF0IGNhc2UsIG1vdmUgaXQgaW50byB0aGUgbmV4dFxuICAgIC8vIG5vZGUgaWYgcG9zc2libGUuIElzc3VlIHByb3NlbWlycm9yL3Byb3NlbWlycm9yIzgzMi5cbiAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGVMZW4obm9kZSkgJiYgaXNJZ25vcmFibGUobm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIC0xKSlcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSwgLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYsIC0xKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yY2UpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGJlZm9yZSBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYWZ0ZXIsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSArK29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0LCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbmV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChuZXh0KSArIDE7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuZnVuY3Rpb24gaXNCbG9ja05vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2s7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW9mZnNldCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMykge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGFmdGVyID0gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYWZ0ZXI7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSA9IHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICBvZmZzZXQgPSBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWwuZXh0ZW5kKSB7XG4gICAgICAgIHNlbC5leHRlbmQobm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgZW5kcyB1cCBoYXBwZW5pbmcsIHJlc2V0IHRoZSBzZWxlY3Rpb24uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlID09IHN0YXRlKVxuICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZmluZERpcmVjdGlvbih2aWV3LCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIShjaHJvbWUgfHwgd2luZG93cykgJiYgJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgY29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAocG9zID4gJHBvcy5zdGFydCgpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdmlldy5jb29yZHNBdFBvcyhwb3MgLSAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYmVmb3JlLnRvcCArIGJlZm9yZS5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYmVmb3JlLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUubGVmdCA8IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8ICRwb3MuZW5kKCkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHZpZXcuY29vcmRzQXRQb3MocG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGFmdGVyLnRvcCArIGFmdGVyLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhhZnRlci5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3LmRvbSkuZGlyZWN0aW9uO1xuICAgIHJldHVybiBjb21wdXRlZCA9PSBcInJ0bFwiID8gXCJydGxcIiA6IFwibHRyXCI7XG59XG4vLyBDaGVjayB3aGV0aGVyIHZlcnRpY2FsIHNlbGVjdGlvbiBtb3Rpb24gd291bGQgaW52b2x2ZSBub2RlXG4vLyBzZWxlY3Rpb25zLiBJZiBzbywgYXBwbHkgaXQgKGlmIG5vdCwgdGhlIHJlc3VsdCBpcyBsZWZ0IHRvIHRoZVxuLy8gYnJvd3NlcilcbmZ1bmN0aW9uIHNlbGVjdFZlcnRpY2FsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA8IDAgPyBcInVwXCIgOiBcImRvd25cIikpIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICB9XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICAgICAgbGV0IGJleW9uZCA9IHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiA/IFNlbGVjdGlvbi5uZWFyKHNpZGUsIGRpcikgOiBTZWxlY3Rpb24uZmluZEZyb20oc2lkZSwgZGlyKTtcbiAgICAgICAgcmV0dXJuIGJleW9uZCA/IGFwcGx5KHZpZXcsIGJleW9uZCkgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IsIGVtcHR5IH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuICAgIGlmIChuZXh0Tm9kZSAmJiAhbmV4dE5vZGUuaXNUZXh0KSB7XG4gICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zLCAkaGVhZC5wb3MgKyBuZXh0Tm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3dpdGNoRWRpdGFibGUodmlldywgbm9kZSwgc3RhdGUpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbn1cbi8vIElzc3VlICM4NjcgLyAjMTA5MCAvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkwMzgyMVxuLy8gSW4gd2hpY2ggU2FmYXJpIChhbmQgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdCwgQ2hyb21lKSBkb2VzIHJlYWxseVxuLy8gd3JvbmcgdGhpbmdzIHdoZW4gdGhlIGRvd24gYXJyb3cgaXMgcHJlc3NlZCB3aGVuIHRoZSBjdXJzb3IgaXNcbi8vIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBhbmQgaGFzIGFuIHVuZWRpdGFibGUgbm9kZVxuLy8gYWZ0ZXIgaXRcbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gICAgaWYgKCFzYWZhcmkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoZm9jdXNOb2RlICYmIGZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxICYmIGZvY3VzT2Zmc2V0ID09IDAgJiZcbiAgICAgICAgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICBsZXQgY2hpbGQgPSBmb2N1c05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwidHJ1ZVwiKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJmYWxzZVwiKSwgMjApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBBIGJhY2tkcm9wIGtleSBtYXBwaW5nIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBzdXBwcmVzcyBrZXlzXG4vLyB0aGF0IGhhdmUgYSBkYW5nZXJvdXMgZGVmYXVsdCBlZmZlY3QsIGV2ZW4gaWYgdGhlIGNvbW1hbmRzIHRoZXkgYXJlXG4vLyBib3VuZCB0byByZXR1cm4gZmFsc2UsIGFuZCB0byBtYWtlIHN1cmUgdGhhdCBjdXJzb3ItbW90aW9uIGtleXNcbi8vIGZpbmQgYSBjdXJzb3IgKGFzIG9wcG9zZWQgdG8gYSBub2RlIHNlbGVjdGlvbikgd2hlbiBwcmVzc2VkLiBGb3Jcbi8vIGN1cnNvci1tb3Rpb24ga2V5cywgdGhlIGNvZGUgaW4gdGhlIGhhbmRsZXJzIGFsc28gdGFrZXMgY2FyZSBvZlxuLy8gYmxvY2sgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGdldE1vZHMoZXZlbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiY1wiO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJtXCI7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiYVwiO1xuICAgIGlmIChldmVudC5zaGlmdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwic1wiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgIGxldCBjb2RlID0gZXZlbnQua2V5Q29kZSwgbW9kcyA9IGdldE1vZHMoZXZlbnQpO1xuICAgIGlmIChjb2RlID09IDggfHwgKG1hYyAmJiBjb2RlID09IDcyICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIEJhY2tzcGFjZSwgQ3RybC1oIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZSA9PSA0NiAmJiAhZXZlbnQuc2hpZnRLZXkpIHx8IChtYWMgJiYgY29kZSA9PSA2OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEZWxldGUsIEN0cmwtZCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIDEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMTMgfHwgY29kZSA9PSAyNykgeyAvLyBFbnRlciwgRXNjXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM3IHx8IChtYWMgJiYgY29kZSA9PSA2NiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBMZWZ0IGFycm93LCBDdHJsLWIgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM3ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IC0xIDogMSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOSB8fCAobWFjICYmIGNvZGUgPT0gNzAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gUmlnaHQgYXJyb3csIEN0cmwtZiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzkgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gMSA6IC0xKSA6IDE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzggfHwgKG1hYyAmJiBjb2RlID09IDgwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFVwIGFycm93LCBDdHJsLXAgb24gTWFjXG4gICAgICAgIHJldHVybiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIC0xLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSA0MCB8fCAobWFjICYmIGNvZGUgPT0gNzggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRG93biBhcnJvdywgQ3RybC1uIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHx8IHNlbGVjdFZlcnRpY2FsbHkodmlldywgMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9kcyA9PSAobWFjID8gXCJtXCIgOiBcImNcIikgJiZcbiAgICAgICAgKGNvZGUgPT0gNjYgfHwgY29kZSA9PSA3MyB8fCBjb2RlID09IDg5IHx8IGNvZGUgPT0gOTApKSB7IC8vIE1vZC1bYml5el1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybUNvcGllZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgbGV0IGNvbnRleHQgPSBbXSwgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIHdoaWxlIChvcGVuU3RhcnQgPiAxICYmIG9wZW5FbmQgPiAxICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxICYmIGNvbnRlbnQuZmlyc3RDaGlsZC5jaGlsZENvdW50ID09IDEpIHtcbiAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRleHQucHVzaChub2RlLnR5cGUubmFtZSwgbm9kZS5hdHRycyAhPSBub2RlLnR5cGUuZGVmYXVsdEF0dHJzID8gbm9kZS5hdHRycyA6IG51bGwpO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICBsZXQgc2VyaWFsaXplciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRTZXJpYWxpemVyXCIpIHx8IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0IGRvYyA9IGRldGFjaGVkRG9jKCksIHdyYXAgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQoY29udGVudCwgeyBkb2N1bWVudDogZG9jIH0pKTtcbiAgICBsZXQgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZCwgbmVlZHNXcmFwLCB3cmFwcGVycyA9IDA7XG4gICAgd2hpbGUgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmIChuZWVkc1dyYXAgPSB3cmFwTWFwW2ZpcnN0Q2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBuZWVkc1dyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQobmVlZHNXcmFwW2ldKTtcbiAgICAgICAgICAgIHdoaWxlICh3cmFwLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh3cmFwLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgIHdyYXBwZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICBmaXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIiwgYCR7b3BlblN0YXJ0fSAke29wZW5FbmR9JHt3cmFwcGVycyA/IGAgLSR7d3JhcHBlcnN9YCA6IFwiXCJ9ICR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCl9YCk7XG4gICAgbGV0IHRleHQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXJcIiwgZiA9PiBmKHNsaWNlLCB2aWV3KSkgfHxcbiAgICAgICAgc2xpY2UuY29udGVudC50ZXh0QmV0d2VlbigwLCBzbGljZS5jb250ZW50LnNpemUsIFwiXFxuXFxuXCIpO1xuICAgIHJldHVybiB7IGRvbTogd3JhcCwgdGV4dCwgc2xpY2UgfTtcbn1cbi8vIFJlYWQgYSBzbGljZSBvZiBjb250ZW50IGZyb20gdGhlIGNsaXBib2FyZCAob3IgZHJvcCBkYXRhKS5cbmZ1bmN0aW9uIHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwbGFpblRleHQsICRjb250ZXh0KSB7XG4gICAgbGV0IGluQ29kZSA9ICRjb250ZXh0LnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgZG9tLCBzbGljZTtcbiAgICBpZiAoIWh0bWwgJiYgIXRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhc1RleHQgPSAhIXRleHQgJiYgKHBsYWluVGV4dCB8fCBpbkNvZGUgfHwgIWh0bWwpO1xuICAgIGlmIChhc1RleHQpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFRleHRcIiwgZiA9PiB7IHRleHQgPSBmKHRleHQsIGluQ29kZSB8fCBwbGFpblRleHQsIHZpZXcpOyB9KTtcbiAgICAgICAgaWYgKGluQ29kZSkge1xuICAgICAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKTtcbiAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldywgdHJ1ZSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFBhcnNlclwiLCBmID0+IGYodGV4dCwgJGNvbnRleHQsIHBsYWluVGV4dCwgdmlldykpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBzbGljZSA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9ICRjb250ZXh0Lm1hcmtzKCk7XG4gICAgICAgICAgICBsZXQgeyBzY2hlbWEgfSA9IHZpZXcuc3RhdGUsIHNlcmlhbGl6ZXIgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZXh0LnNwbGl0KC8oPzpcXHJcXG4/fFxcbikrLykuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBkb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikpO1xuICAgICAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZU5vZGUoc2NoZW1hLnRleHQoYmxvY2ssIG1hcmtzKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGYgPT4geyBodG1sID0gZihodG1sLCB2aWV3KTsgfSk7XG4gICAgICAgIGRvbSA9IHJlYWRIVE1MKGh0bWwpO1xuICAgICAgICBpZiAod2Via2l0KVxuICAgICAgICAgICAgcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSk7XG4gICAgfVxuICAgIGxldCBjb250ZXh0Tm9kZSA9IGRvbSAmJiBkb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLXBtLXNsaWNlXVwiKTtcbiAgICBsZXQgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspKD86IC0oXFxkKykpPyAoLiopLy5leGVjKGNvbnRleHROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIikgfHwgXCJcIik7XG4gICAgaWYgKHNsaWNlRGF0YSAmJiBzbGljZURhdGFbM10pXG4gICAgICAgIGZvciAobGV0IGkgPSArc2xpY2VEYXRhWzNdOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZG9tID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICBpZiAoIXNsaWNlKSB7XG4gICAgICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkUGFyc2VyXCIpIHx8IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgICAgICBzbGljZSA9IHBhcnNlci5wYXJzZVNsaWNlKGRvbSwge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAhIShhc1RleHQgfHwgc2xpY2VEYXRhKSxcbiAgICAgICAgICAgIGNvbnRleHQ6ICRjb250ZXh0LFxuICAgICAgICAgICAgcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkb20ubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudE5vZGUgJiYgIWlubGluZVBhcmVudHMudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNsaWNlRGF0YSkge1xuICAgICAgICBzbGljZSA9IGFkZENvbnRleHQoY2xvc2VTbGljZShzbGljZSwgK3NsaWNlRGF0YVsxXSwgK3NsaWNlRGF0YVsyXSksIHNsaWNlRGF0YVs0XSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBIVE1MIHdhc24ndCBjcmVhdGVkIGJ5IFByb3NlTWlycm9yLiBNYWtlIHN1cmUgdG9wLWxldmVsIHNpYmxpbmdzIGFyZSBjb2hlcmVudFxuICAgICAgICBzbGljZSA9IFNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcbiAgICAgICAgaWYgKHNsaWNlLm9wZW5TdGFydCB8fCBzbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkOyBvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlblN0YXJ0KyssIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQubGFzdENoaWxkOyBvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuRW5kKyssIG5vZGUgPSBub2RlLmxhc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBzbGljZSA9IGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3LCBhc1RleHQpOyB9KTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBpbmxpbmVQYXJlbnRzID0gL14oYXxhYmJyfGFjcm9ueW18YnxjaXRlfGNvZGV8ZGVsfGVtfGl8aW5zfGtiZHxsYWJlbHxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzcGFufHN0cm9uZ3xzdWJ8c3VwfHRpbWV8dXx0dHx2YXIpJC9pO1xuLy8gVGFrZXMgYSBzbGljZSBwYXJzZWQgd2l0aCBwYXJzZVNsaWNlLCB3aGljaCBtZWFucyB0aGVyZSBoYXNuJ3QgYmVlblxuLy8gYW55IGNvbnRlbnQtZXhwcmVzc2lvbiBjaGVja2luZyBkb25lIG9uIHRoZSB0b3Agbm9kZXMsIHRyaWVzIHRvXG4vLyBmaW5kIGEgcGFyZW50IG5vZGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dCB0aGF0IG1pZ2h0IGZpdCB0aGUgbm9kZXMsXG4vLyBhbmQgaWYgc3VjY2Vzc2Z1bCwgcmVidWlsZHMgdGhlIHNsaWNlIHNvIHRoYXQgaXQgZml0cyBpbnRvIHRoYXQgcGFyZW50LlxuLy9cbi8vIFRoaXMgYWRkcmVzc2VzIHRoZSBwcm9ibGVtIHRoYXQgVHJhbnNmb3JtLnJlcGxhY2UgZXhwZWN0cyBhXG4vLyBjb2hlcmVudCBzbGljZSwgYW5kIHdpbGwgZmFpbCB0byBwbGFjZSBhIHNldCBvZiBzaWJsaW5ncyB0aGF0IGRvbid0XG4vLyBmaXQgYW55d2hlcmUgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpYmxpbmdzKGZyYWdtZW50LCAkY29udGV4dCkge1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50IDwgMilcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRjb250ZXh0Lm5vZGUoZCk7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleChkKSk7XG4gICAgICAgIGxldCBsYXN0V3JhcCwgcmVzdWx0ID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgd3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpLCBpbkxhc3Q7XG4gICAgICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5MYXN0ID0gcmVzdWx0Lmxlbmd0aCAmJiBsYXN0V3JhcC5sZW5ndGggJiYgYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCAwKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBpbkxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGNsb3NlUmlnaHQocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbGFzdFdyYXAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlZCA9IHdpdGhXcmFwcGVycyhub2RlLCB3cmFwKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3cmFwcGVkKTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh3cmFwcGVkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxhc3RXcmFwID0gd3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZnJvbSA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IGZyb207IGktLSlcbiAgICAgICAgbm9kZSA9IHdyYXBbaV0uY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiBub2RlO1xufVxuLy8gVXNlZCB0byBncm91cCBhZGphY2VudCBub2RlcyB3cmFwcGVkIGluIHNpbWlsYXIgcGFyZW50cyBieVxuLy8gbm9ybWFsaXplU2libGluZ3MgaW50byB0aGUgc2FtZSBwYXJlbnQgbm9kZVxuZnVuY3Rpb24gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA8IHdyYXAubGVuZ3RoICYmIGRlcHRoIDwgbGFzdFdyYXAubGVuZ3RoICYmIHdyYXBbZGVwdGhdID09IGxhc3RXcmFwW2RlcHRoXSkge1xuICAgICAgICBsZXQgaW5uZXIgPSBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcubGFzdENoaWxkLCBkZXB0aCArIDEpO1xuICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5yZXBsYWNlQ2hpbGQoc2libGluZy5jaGlsZENvdW50IC0gMSwgaW5uZXIpKTtcbiAgICAgICAgbGV0IG1hdGNoID0gc2libGluZy5jb250ZW50TWF0Y2hBdChzaWJsaW5nLmNoaWxkQ291bnQpO1xuICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKGRlcHRoID09IHdyYXAubGVuZ3RoIC0gMSA/IG5vZGUudHlwZSA6IHdyYXBbZGVwdGggKyAxXSkpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZGVwdGggKyAxKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZVJpZ2h0KG5vZGUsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnbWVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQobm9kZS5jaGlsZENvdW50IC0gMSwgY2xvc2VSaWdodChub2RlLmxhc3RDaGlsZCwgZGVwdGggLSAxKSk7XG4gICAgbGV0IGZpbGwgPSBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnbWVudC5hcHBlbmQoZmlsbCkpO1xufVxuZnVuY3Rpb24gY2xvc2VSYW5nZShmcmFnbWVudCwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoLCBvcGVuRW5kKSB7XG4gICAgbGV0IG5vZGUgPSBzaWRlIDwgMCA/IGZyYWdtZW50LmZpcnN0Q2hpbGQgOiBmcmFnbWVudC5sYXN0Q2hpbGQsIGlubmVyID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgaWYgKGRlcHRoIDwgdG8gLSAxKVxuICAgICAgICBpbm5lciA9IGNsb3NlUmFuZ2UoaW5uZXIsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCArIDEsIG9wZW5FbmQpO1xuICAgIGlmIChkZXB0aCA+PSBmcm9tKVxuICAgICAgICBpbm5lciA9IHNpZGUgPCAwID8gbm9kZS5jb250ZW50TWF0Y2hBdCgwKS5maWxsQmVmb3JlKGlubmVyLCBvcGVuRW5kIDw9IGRlcHRoKS5hcHBlbmQoaW5uZXIpXG4gICAgICAgICAgICA6IGlubmVyLmFwcGVuZChub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoc2lkZSA8IDAgPyAwIDogZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIG5vZGUuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAtMSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuU3RhcnQsIDAsIHNsaWNlLm9wZW5FbmQpLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpO1xuICAgIGlmIChvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG4vLyBUcmljayBmcm9tIGpRdWVyeSAtLSBzb21lIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBvdGhlclxuLy8gZWxlbWVudHMgZm9yIGlubmVySFRNTCB0byB3b3JrLiBJLmUuIGlmIHlvdSBkbyBgZGl2LmlubmVySFRNTCA9XG4vLyBcIjx0ZD4uLjwvdGQ+XCJgIHRoZSB0YWJsZSBjZWxscyBhcmUgaWdub3JlZC5cbmNvbnN0IHdyYXBNYXAgPSB7XG4gICAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICAgIHRib2R5OiBbXCJ0YWJsZVwiXSxcbiAgICB0Zm9vdDogW1widGFibGVcIl0sXG4gICAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gICAgY29sZ3JvdXA6IFtcInRhYmxlXCJdLFxuICAgIGNvbDogW1widGFibGVcIiwgXCJjb2xncm91cFwiXSxcbiAgICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgICB0ZDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdLFxuICAgIHRoOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl1cbn07XG5sZXQgX2RldGFjaGVkRG9jID0gbnVsbDtcbmZ1bmN0aW9uIGRldGFjaGVkRG9jKCkge1xuICAgIHJldHVybiBfZGV0YWNoZWREb2MgfHwgKF9kZXRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRpdGxlXCIpKTtcbn1cbmxldCBfcG9saWN5ID0gbnVsbDtcbmZ1bmN0aW9uIG1heWJlV3JhcFRydXN0ZWQoaHRtbCkge1xuICAgIGxldCB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuICAgIGlmICghdHJ1c3RlZFR5cGVzKVxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAvLyBXaXRoIHRoZSByZXF1aXJlLXRydXN0ZWQtdHlwZXMtZm9yIENTUCwgQ2hyb21lIHdpbGwgYmxvY2tcbiAgICAvLyBpbm5lckhUTUwsIGV2ZW4gb24gYSBkZXRhY2hlZCBkb2N1bWVudC4gVGhpcyB3cmFwcyB0aGUgc3RyaW5nIGluXG4gICAgLy8gYSB3YXkgdGhhdCBtYWtlcyB0aGUgYnJvd3NlciBhbGxvdyB1cyB0byB1c2UgaXRzIHBhcnNlciBhZ2Fpbi5cbiAgICBpZiAoIV9wb2xpY3kpXG4gICAgICAgIF9wb2xpY3kgPSB0cnVzdGVkVHlwZXMuZGVmYXVsdFBvbGljeSB8fCB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KFwiUHJvc2VNaXJyb3JDbGlwYm9hcmRcIiwgeyBjcmVhdGVIVE1MOiAocykgPT4gcyB9KTtcbiAgICByZXR1cm4gX3BvbGljeS5jcmVhdGVIVE1MKGh0bWwpO1xufVxuZnVuY3Rpb24gcmVhZEhUTUwoaHRtbCkge1xuICAgIGxldCBtZXRhcyA9IC9eKFxccyo8bWV0YSBbXj5dKj4pKi8uZXhlYyhodG1sKTtcbiAgICBpZiAobWV0YXMpXG4gICAgICAgIGh0bWwgPSBodG1sLnNsaWNlKG1ldGFzWzBdLmxlbmd0aCk7XG4gICAgbGV0IGVsdCA9IGRldGFjaGVkRG9jKCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBsZXQgZmlyc3RUYWcgPSAvPChbYS16XVtePlxcc10rKS9pLmV4ZWMoaHRtbCksIHdyYXA7XG4gICAgaWYgKHdyYXAgPSBmaXJzdFRhZyAmJiB3cmFwTWFwW2ZpcnN0VGFnWzFdLnRvTG93ZXJDYXNlKCldKVxuICAgICAgICBodG1sID0gd3JhcC5tYXAobiA9PiBcIjxcIiArIG4gKyBcIj5cIikuam9pbihcIlwiKSArIGh0bWwgKyB3cmFwLm1hcChuID0+IFwiPC9cIiArIG4gKyBcIj5cIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgZWx0LmlubmVySFRNTCA9IG1heWJlV3JhcFRydXN0ZWQoaHRtbCk7XG4gICAgaWYgKHdyYXApXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVsdCA9IGVsdC5xdWVyeVNlbGVjdG9yKHdyYXBbaV0pIHx8IGVsdDtcbiAgICByZXR1cm4gZWx0O1xufVxuLy8gV2Via2l0IGJyb3dzZXJzIGRvIHNvbWUgaGFyZC10by1wcmVkaWN0IHJlcGxhY2VtZW50IG9mIHJlZ3VsYXJcbi8vIHNwYWNlcyB3aXRoIG5vbi1icmVha2luZyBzcGFjZXMgd2hlbiBwdXR0aW5nIGNvbnRlbnQgb24gdGhlXG4vLyBjbGlwYm9hcmQuIFRoaXMgdHJpZXMgdG8gY29udmVydCBzdWNoIG5vbi1icmVha2luZyBzcGFjZXMgKHdoaWNoXG4vLyB3aWxsIGJlIHdyYXBwZWQgaW4gYSBwbGFpbiBzcGFuIG9uIENocm9tZSwgYSBzcGFuIHdpdGggY2xhc3Ncbi8vIEFwcGxlLWNvbnZlcnRlZC1zcGFjZSBvbiBTYWZhcmkpIGJhY2sgdG8gcmVndWxhciBzcGFjZXMuXG5mdW5jdGlvbiByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKSB7XG4gICAgbGV0IG5vZGVzID0gZG9tLnF1ZXJ5U2VsZWN0b3JBbGwoY2hyb21lID8gXCJzcGFuOm5vdChbY2xhc3NdKTpub3QoW3N0eWxlXSlcIiA6IFwic3Bhbi5BcHBsZS1jb252ZXJ0ZWQtc3BhY2VcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUudGV4dENvbnRlbnQgPT0gXCJcXHUwMGEwXCIgJiYgbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIiksIG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZENvbnRleHQoc2xpY2UsIGNvbnRleHQpIHtcbiAgICBpZiAoIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICBsZXQgc2NoZW1hID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkLnR5cGUuc2NoZW1hLCBhcnJheTtcbiAgICB0cnkge1xuICAgICAgICBhcnJheSA9IEpTT04ucGFyc2UoY29udGV4dCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICB9XG4gICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEubm9kZXNbYXJyYXlbaV1dO1xuICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXJyYXlbaSArIDFdLCBjb250ZW50KSk7XG4gICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBvcGVuRW5kKys7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxuLy8gQSBjb2xsZWN0aW9uIG9mIERPTSBldmVudHMgdGhhdCBvY2N1ciB3aXRoaW4gdGhlIGVkaXRvciwgYW5kIGNhbGxiYWNrIGZ1bmN0aW9uc1xuLy8gdG8gaW52b2tlIHdoZW4gdGhlIGV2ZW50IGZpcmVzLlxuY29uc3QgaGFuZGxlcnMgPSB7fTtcbmNvbnN0IGVkaXRIYW5kbGVycyA9IHt9O1xuY29uc3QgcGFzc2l2ZUhhbmRsZXJzID0geyB0b3VjaHN0YXJ0OiB0cnVlLCB0b3VjaG1vdmU6IHRydWUgfTtcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q2xpY2sgPSB7IHRpbWU6IDAsIHg6IDAsIHk6IDAsIHR5cGU6IFwiXCIsIGJ1dHRvbjogMCB9O1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RGb2N1cyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q2hyb21lRGVsZXRlID0gMDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbk5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvc2luZ1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbk5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbklEID0gMTtcbiAgICAgICAgdGhpcy5iYWRTYWZhcmlDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZXQgdG8gYSBjb21wb3NpdGlvbiBJRCB3aGVuIHRoZXJlIGFyZSBwZW5kaW5nIGNoYW5nZXMgYXQgY29tcG9zaXRpb25lbmRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuaGlkZVNlbGVjdGlvbkd1YXJkID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0SW5wdXQodmlldykge1xuICAgIGZvciAobGV0IGV2ZW50IGluIGhhbmRsZXJzKSB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSAmJiAhcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiZcbiAgICAgICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICAgIH0sIHBhc3NpdmVIYW5kbGVyc1tldmVudF0gPyB7IHBhc3NpdmU6IHRydWUgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIE9uIFNhZmFyaSwgZm9yIHJlYXNvbnMgYmV5b25kIG15IHVuZGVyc3RhbmRpbmcsIGFkZGluZyBhbiBpbnB1dFxuICAgIC8vIGV2ZW50IGhhbmRsZXIgbWFrZXMgYW4gaXNzdWUgd2hlcmUgdGhlIGNvbXBvc2l0aW9uIHZhbmlzaGVzIHdoZW5cbiAgICAvLyB5b3UgcHJlc3MgZW50ZXIgZ28gYXdheS5cbiAgICBpZiAoc2FmYXJpKVxuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgZW5zdXJlTGlzdGVuZXJzKHZpZXcpO1xufVxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIG9yaWdpbikge1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lJbnB1dCh2aWV3KSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgZm9yIChsZXQgdHlwZSBpbiB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnMpXG4gICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQpO1xufVxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuZXJzKHZpZXcpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGN1cnJlbnRIYW5kbGVycyA9PiB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gY3VycmVudEhhbmRsZXJzKVxuICAgICAgICAgICAgaWYgKCF2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pXG4gICAgICAgICAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0gPSBldmVudCA9PiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgaGFuZGxlcnMgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICByZXR1cm4gaGFuZGxlciA/IGhhbmRsZXIodmlldywgZXZlbnQpIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0OyBub2RlICE9IHZpZXcuZG9tOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAgICAgKG5vZGUucG1WaWV3RGVzYyAmJiBub2RlLnBtVmlld0Rlc2Muc3RvcEV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJiBoYW5kbGVyc1tldmVudC50eXBlXSAmJlxuICAgICAgICAodmlldy5lZGl0YWJsZSB8fCAhKGV2ZW50LnR5cGUgaW4gZWRpdEhhbmRsZXJzKSkpXG4gICAgICAgIGhhbmRsZXJzW2V2ZW50LnR5cGVdKHZpZXcsIGV2ZW50KTtcbn1cbmVkaXRIYW5kbGVycy5rZXlkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQua2V5Q29kZSA9PSAxNiB8fCBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gU3VwcHJlc3MgZW50ZXIga2V5IGV2ZW50cyBvbiBDaHJvbWUgQW5kcm9pZCwgYmVjYXVzZSB0aG9zZSB0ZW5kXG4gICAgLy8gdG8gYmUgcGFydCBvZiBhIGNvbmZ1c2VkIHNlcXVlbmNlIG9mIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlZCxcbiAgICAvLyBhbmQgaGFuZGxpbmcgdGhlbSBlYWdlcmx5IHRlbmRzIHRvIGNvcnJ1cHQgdGhlIGlucHV0LlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiBldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gMjI5KVxuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAvLyBPbiBpT1MsIGlmIHdlIHByZXZlbnREZWZhdWx0IGVudGVyIGtleSBwcmVzc2VzLCB0aGUgdmlydHVhbFxuICAgIC8vIGtleWJvYXJkIGdldHMgY29uZnVzZWQuIFNvIHRoZSBoYWNrIGhlcmUgaXMgdG8gc2V0IGEgZmxhZyB0aGF0XG4gICAgLy8gbWFrZXMgdGhlIERPTSBjaGFuZ2UgY29kZSByZWNvZ25pemUgdGhhdCB3aGF0IGp1c3QgaGFwcGVucyBzaG91bGRcbiAgICAvLyBiZSByZXBsYWNlZCBieSB3aGF0ZXZlciB0aGUgRW50ZXIga2V5IGhhbmRsZXJzIGRvLlxuICAgIGlmIChpb3MgJiYgZXZlbnQua2V5Q29kZSA9PSAxMyAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IG5vdztcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9PSBub3cpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKTtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBldmVudCkpIHx8IGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwia2V5XCIpO1xuICAgIH1cbn07XG5lZGl0SGFuZGxlcnMua2V5dXAgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxNilcbiAgICAgICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGZhbHNlO1xufTtcbmVkaXRIYW5kbGVycy5rZXlwcmVzcyA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHx8ICFldmVudC5jaGFyQ29kZSB8fFxuICAgICAgICBldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHwgbWFjICYmIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleVByZXNzXCIsIGYgPT4gZih2aWV3LCBldmVudCkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8ICFzZWwuJGZyb20uc2FtZVBhcmVudChzZWwuJHRvKSkge1xuICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgICAgICBsZXQgZGVmbHQgPSAoKSA9PiB2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCkuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgaWYgKCEvW1xcclxcbl0vLnRlc3QodGV4dCkgJiYgIXZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIHNlbC4kZnJvbS5wb3MsIHNlbC4kdG8ucG9zLCB0ZXh0LCBkZWZsdCkpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaChkZWZsdCgpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZXZlbnRDb29yZHMoZXZlbnQpIHsgcmV0dXJuIHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH07IH1cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgICBsZXQgZHggPSBjbGljay54IC0gZXZlbnQuY2xpZW50WCwgZHkgPSBjbGljay55IC0gZXZlbnQuY2xpZW50WTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPCAxMDA7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIHByb3BOYW1lLCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKHByb3BOYW1lLCBmID0+IGkgPiAkcG9zLmRlcHRoID8gZih2aWV3LCBwb3MsICRwb3Mubm9kZUFmdGVyLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIHRydWUpXG4gICAgICAgICAgICA6IGYodmlldywgcG9zLCAkcG9zLm5vZGUoaSksICRwb3MuYmVmb3JlKGkpLCBldmVudCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24odmlldywgc2VsZWN0aW9uLCBvcmlnaW4pIHtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZClcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIGlmIChub2RlICYmIG5vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0ZWROb2RlLCBzZWxlY3RBdDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbilcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gc2VsLm5vZGU7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlICYmIHNlbC4kZnJvbS5kZXB0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBpID49IHNlbC4kZnJvbS5kZXB0aCAmJiAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGggKyAxKSA9PSBzZWwuJGZyb20ucG9zKVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdEF0ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBzZWxlY3RBdCksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50LCBzZWxlY3ROb2RlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgKHNlbGVjdE5vZGUgPyBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIDogc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVEb3VibGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZURvdWJsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRG91YmxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlVHJpcGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVUcmlwbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUcmlwbGVDbGljayh2aWV3LCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGlmIChpbnNpZGUgPT0gLTEpIHtcbiAgICAgICAgaWYgKGRvYy5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCAwLCBkb2MuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gaSA+ICRwb3MuZGVwdGggPyAkcG9zLm5vZGVBZnRlciA6ICRwb3Mubm9kZShpKTtcbiAgICAgICAgbGV0IG5vZGVQb3MgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MgKyAxLCBub2RlUG9zICsgMSArIG5vZGUuY29udGVudC5zaXplKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIG5vZGVQb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JjZURPTUZsdXNoKHZpZXcpIHtcbiAgICByZXR1cm4gZW5kQ29tcG9zaXRpb24odmlldyk7XG59XG5jb25zdCBzZWxlY3ROb2RlTW9kaWZpZXIgPSBtYWMgPyBcIm1ldGFLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgbGV0IGZsdXNoZWQgPSBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIGxldCBub3cgPSBEYXRlLm5vdygpLCB0eXBlID0gXCJzaW5nbGVDbGlja1wiO1xuICAgIGlmIChub3cgLSB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lIDwgNTAwICYmIGlzTmVhcihldmVudCwgdmlldy5pbnB1dC5sYXN0Q2xpY2spICYmICFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdICYmXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdENsaWNrLmJ1dHRvbiA9PSBldmVudC5idXR0b24pIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwiZG91YmxlQ2xpY2tcIjtcbiAgICAgICAgZWxzZSBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcImRvdWJsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJ0cmlwbGVDbGlja1wiO1xuICAgIH1cbiAgICB2aWV3LmlucHV0Lmxhc3RDbGljayA9IHsgdGltZTogbm93LCB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0eXBlLCBidXR0b246IGV2ZW50LmJ1dHRvbiB9O1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFwb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubW91c2VEb3duKVxuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZG9uZSgpO1xuICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93biA9IG5ldyBNb3VzZURvd24odmlldywgcG9zLCBldmVudCwgISFmbHVzaGVkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHR5cGUgPT0gXCJkb3VibGVDbGlja1wiID8gaGFuZGxlRG91YmxlQ2xpY2sgOiBoYW5kbGVUcmlwbGVDbGljaykodmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbn07XG5jbGFzcyBNb3VzZURvd24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHBvcywgZXZlbnQsIGZsdXNoZWQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5mbHVzaGVkID0gZmx1c2hlZDtcbiAgICAgICAgdGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlID0gISFldmVudFtzZWxlY3ROb2RlTW9kaWZpZXJdO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSwgdGFyZ2V0UG9zO1xuICAgICAgICBpZiAocG9zLmluc2lkZSA+IC0xKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gdmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gcG9zLmluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSAkcG9zLnBhcmVudDtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9ICRwb3MuZGVwdGggPyAkcG9zLmJlZm9yZSgpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBmbHVzaGVkID8gbnVsbCA6IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGVzYyA9IHRhcmdldCA/IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyh0YXJnZXQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXREZXNjICYmIHRhcmdldERlc2Mubm9kZURPTS5ub2RlVHlwZSA9PSAxID8gdGFyZ2V0RGVzYy5ub2RlRE9NIDogbnVsbDtcbiAgICAgICAgbGV0IHsgc2VsZWN0aW9uIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgIHRhcmdldE5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiB0YXJnZXROb2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZSB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb24uZnJvbSA8PSB0YXJnZXRQb3MgJiYgc2VsZWN0aW9uLnRvID4gdGFyZ2V0UG9zKVxuICAgICAgICAgICAgdGhpcy5taWdodERyYWcgPSB7XG4gICAgICAgICAgICAgICAgbm9kZTogdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICBwb3M6IHRhcmdldFBvcyxcbiAgICAgICAgICAgICAgICBhZGRBdHRyOiAhISh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZHJhZ2dhYmxlKSxcbiAgICAgICAgICAgICAgICBzZXRVbmVkaXRhYmxlOiAhISh0aGlzLnRhcmdldCAmJiBnZWNrbyAmJiAhdGhpcy50YXJnZXQuaGFzQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMubWlnaHREcmFnICYmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyIHx8IHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwiZmFsc2VcIik7XG4gICAgICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxuICAgIGRvbmUoKSB7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZyAmJiB0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9IG51bGw7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMudmlldy5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyAhPSB0aGlzLnN0YXJ0RG9jKVxuICAgICAgICAgICAgcG9zID0gdGhpcy52aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dEZWZhdWx0IHx8ICFwb3MpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGVTaW5nbGVDbGljayh0aGlzLnZpZXcsIHBvcy5wb3MsIHBvcy5pbnNpZGUsIGV2ZW50LCB0aGlzLnNlbGVjdE5vZGUpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICAodGhpcy5mbHVzaGVkIHx8XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGlnbm9yZXMgY2xpY2tzIG9uIGRyYWdnYWJsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIChzYWZhcmkgJiYgdGhpcy5taWdodERyYWcgJiYgIXRoaXMubWlnaHREcmFnLm5vZGUuaXNBdG9tKSB8fFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcyB0cmVhdCBhIG5vZGUgc2VsZWN0aW9uIGFzIGFcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IsIGJ1dCBzdGlsbCByZXBvcnQgdGhhdCB0aGUgbm9kZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYXNrZWQgdGhyb3VnaCBnZXRTZWxlY3Rpb24uIFlvdSdsbCB0aGVuIGdldCBhXG4gICAgICAgICAgICAgICAgLy8gc2l0dWF0aW9uIHdoZXJlIGNsaWNraW5nIGF0IHRoZSBwb2ludCB3aGVyZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gKGhpZGRlbikgY3Vyc29yIGlzIGRvZXNuJ3QgY2hhbmdlIHRoZSBzZWxlY3Rpb24sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgZG9lc24ndCBnZXQgYSByZWFjdGlvbiBmcm9tIFByb3NlTWlycm9yLiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gd29ya3MgYXJvdW5kIHRoYXQuXG4gICAgICAgICAgICAgICAgKGNocm9tZSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pLCBNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi50bykpIDw9IDIpKSkge1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHRoaXMudmlldywgU2VsZWN0aW9uLm5lYXIodGhpcy52aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFsbG93RGVmYXVsdChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEZWZhdWx0ICYmIChNYXRoLmFicyh0aGlzLmV2ZW50LnggLSBldmVudC5jbGllbnRYKSA+IDQgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZXZlbnQueSAtIGV2ZW50LmNsaWVudFkpID4gNCkpXG4gICAgICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IHRydWU7XG4gICAgfVxufVxuaGFuZGxlcnMudG91Y2hzdGFydCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IGZvcmNlRE9NRmx1c2godmlldyk7XG5mdW5jdGlvbiBpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgLy8gT24gSmFwYW5lc2UgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG8gY29uZmlybSBjaGFyYWN0ZXJcbiAgICAvLyBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLCBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlXG4gICAgLy8gZW1pdHRlZC4gVGhlIGtleWRvd24gZXZlbnQgdHJpZ2dlcnMgbmV3bGluZSBpbnNlcnRpb24sIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBrZXlkb3duIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkLlxuICAgIC8vIFdlIG9ubHkgaWdub3JlIGl0IG9uY2UsIGFzIHByZXNzaW5nIEVudGVyIGEgc2Vjb25kIHRpbWUgKnNob3VsZCogaW5zZXJ0IGEgbmV3bGluZS5cbiAgICAvLyBGdXJ0aGVybW9yZSwgdGhlIGtleWRvd24gZXZlbnQgdGltZXN0YW1wIG11c3QgYmUgY2xvc2UgdG8gdGhlIGNvbXBvc2l0aW9uRW5kZWRBdCB0aW1lc3RhbXAuXG4gICAgLy8gVGhpcyBndWFyZHMgYWdhaW5zdCB0aGUgY2FzZSB3aGVyZSBjb21wb3NpdGlvbmVuZCBpcyB0cmlnZ2VyZWQgd2l0aG91dCB0aGUga2V5Ym9hcmRcbiAgICAvLyAoZS5nLiBjaGFyYWN0ZXIgY29uZmlybWF0aW9uIG1heSBiZSBkb25lIHdpdGggdGhlIG1vdXNlKSwgYW5kIGtleWRvd24gaXMgdHJpZ2dlcmVkXG4gICAgLy8gYWZ0ZXJ3YXJkcy0gd2Ugd291bGRuJ3Qgd2FudCB0byBpZ25vcmUgdGhlIGtleWRvd24gZXZlbnQgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChzYWZhcmkgJiYgTWF0aC5hYnMoZXZlbnQudGltZVN0YW1wIC0gdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQpIDwgNTAwKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIERyb3AgYWN0aXZlIGNvbXBvc2l0aW9uIGFmdGVyIDUgc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIEFuZHJvaWRcbmNvbnN0IHRpbWVvdXRDb21wb3NpdGlvbiA9IGFuZHJvaWQgPyA1MDAwIDogLTE7XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mbHVzaCgpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kdG87XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmXG4gICAgICAgICAgICAoc3RhdGUuc3RvcmVkTWFya3MgfHxcbiAgICAgICAgICAgICAgICAoISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3Muc29tZShtID0+IG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UpKSB8fFxuICAgICAgICAgICAgICAgIGNocm9tZSAmJiB3aW5kb3dzICYmIHNlbGVjdGlvbkJlZm9yZVVuZWRpdGFibGUodmlldykpKSB7IC8vIElzc3VlICMxNTAwXG4gICAgICAgICAgICAvLyBOZWVkIHRvIHdyYXAgdGhlIGN1cnNvciBpbiBtYXJrIG5vZGVzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmVzIGluIHRoZSBET00gY29udGV4dFxuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gdmlldy5zdGF0ZS5zdG9yZWRNYXJrcyB8fCAkcG9zLm1hcmtzKCk7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3LCB0cnVlKTtcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3LCAhc3RhdGUuc2VsZWN0aW9uLmVtcHR5KTtcbiAgICAgICAgICAgIC8vIEluIGZpcmVmb3gsIGlmIHRoZSBjdXJzb3IgaXMgYWZ0ZXIgYnV0IG91dHNpZGUgYSBtYXJrZWQgbm9kZSxcbiAgICAgICAgICAgIC8vIHRoZSBpbnNlcnRlZCB0ZXh0IHdvbid0IGluaGVyaXQgdGhlIG1hcmtzLiBTbyB0aGlzIG1vdmVzIGl0XG4gICAgICAgICAgICAvLyBpbnNpZGUgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAhJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7IG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCAhPSAwOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gb2Zmc2V0IDwgMCA/IG5vZGUubGFzdENoaWxkIDogbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwuY29sbGFwc2UoYmVmb3JlLCBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IHRydWU7XG4gICAgfVxuICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCB0aW1lb3V0Q29tcG9zaXRpb24pO1xufTtcbmZ1bmN0aW9uIHNlbGVjdGlvbkJlZm9yZVVuZWRpdGFibGUodmlldykge1xuICAgIGxldCB7IGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIWZvY3VzTm9kZSB8fCBmb2N1c05vZGUubm9kZVR5cGUgIT0gMSB8fCBmb2N1c09mZnNldCA+PSBmb2N1c05vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbmV4dCA9IGZvY3VzTm9kZS5jaGlsZE5vZGVzW2ZvY3VzT2Zmc2V0XTtcbiAgICByZXR1cm4gbmV4dC5ub2RlVHlwZSA9PSAxICYmIG5leHQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIjtcbn1cbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbmVuZCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gdmlldy5kb21PYnNlcnZlci5wZW5kaW5nUmVjb3JkcygpLmxlbmd0aCA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDA7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQuYmFkU2FmYXJpQ29tcG9zaXRpb24pXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgZWxzZSBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCkpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQrKztcbiAgICAgICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgaWYgKGRlbGF5ID4gLTEpXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZW5kQ29tcG9zaXRpb24odmlldyksIGRlbGF5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29tcG9zaXRpb24odmlldykge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpO1xuICAgIH1cbiAgICB3aGlsZSAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wb3AoKS5tYXJrUGFyZW50c0RpcnR5KCk7XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRleHRCZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZSQxKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHRBZnRlciA9IHRleHROb2RlQWZ0ZXIkMShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmICh0ZXh0QmVmb3JlICYmIHRleHRBZnRlciAmJiB0ZXh0QmVmb3JlICE9IHRleHRBZnRlcikge1xuICAgICAgICBsZXQgZGVzY0FmdGVyID0gdGV4dEFmdGVyLnBtVmlld0Rlc2MsIGxhc3RDaGFuZ2VkID0gdmlldy5kb21PYnNlcnZlci5sYXN0Q2hhbmdlZFRleHROb2RlO1xuICAgICAgICBpZiAodGV4dEJlZm9yZSA9PSBsYXN0Q2hhbmdlZCB8fCB0ZXh0QWZ0ZXIgPT0gbGFzdENoYW5nZWQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdENoYW5nZWQ7XG4gICAgICAgIGlmICghZGVzY0FmdGVyIHx8ICFkZXNjQWZ0ZXIuaXNUZXh0KHRleHRBZnRlci5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlID09IHRleHRBZnRlcikge1xuICAgICAgICAgICAgbGV0IGRlc2NCZWZvcmUgPSB0ZXh0QmVmb3JlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICBpZiAoISghZGVzY0JlZm9yZSB8fCAhZGVzY0JlZm9yZS5pc1RleHQodGV4dEJlZm9yZS5ub2RlVmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0QmVmb3JlIHx8IHRleHRBZnRlcjtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImV2ZW50XCIsIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXA7XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcsIHJlc3RhcnRpbmcgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChyZXN0YXJ0aW5nIHx8IHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpIHtcbiAgICAgICAgbGV0IHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyksIGN1ciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEoY3VyKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKSk7XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3Lm1hcmtDdXJzb3IgfHwgcmVzdGFydGluZykgJiYgIWN1ci4kZnJvbS5ub2RlKGN1ci4kZnJvbS5zaGFyZWREZXB0aChjdXIudG8pKS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUEnigJRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBsYWluVGV4dClcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBwbGFpbiwgZXZlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgcGxhaW4sIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHByZWZlclBsYWluKVxuICAgICAgICA6IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFRleHQoY2xpcGJvYXJkRGF0YSkge1xuICAgIGxldCB0ZXh0ID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmICh0ZXh0KVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBsZXQgdXJpcyA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvdXJpLWxpc3RcIik7XG4gICAgcmV0dXJuIHVyaXMgPyB1cmlzLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpIDogXCJcIjtcbn1cbmVkaXRIYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gSGFuZGxpbmcgcGFzdGUgZnJvbSBKYXZhU2NyaXB0IGR1cmluZyBjb21wb3NpdGlvbiBpcyB2ZXJ5IHBvb3JseVxuICAgIC8vIGhhbmRsZWQgYnkgYnJvd3NlcnMsIHNvIGFzIGEgZG9kZ3kgYnV0IHByZWZlcmFibGUga2x1ZGdlLCB3ZSBqdXN0XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRvIGl0cyBuYXRpdmUgdGhpbmcgdGhlcmUsIGV4Y2VwdCBvbiBBbmRyb2lkLFxuICAgIC8vIHdoZXJlIHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyBjb21wb3NpbmcuXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nICYmICFhbmRyb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBnZXRUZXh0KGRhdGEpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHBsYWluLCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSwgbm9kZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmZ1bmN0aW9uIGRyYWdNb3Zlcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBtb3ZlcyA9IHZpZXcuc29tZVByb3AoXCJkcmFnQ29waWVzXCIsIHRlc3QgPT4gIXRlc3QoZXZlbnQpKTtcbiAgICByZXR1cm4gbW92ZXMgIT0gbnVsbCA/IG1vdmVzIDogIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdO1xufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgbW91c2VEb3duID0gdmlldy5pbnB1dC5tb3VzZURvd247XG4gICAgaWYgKG1vdXNlRG93bilcbiAgICAgICAgbW91c2VEb3duLmRvbmUoKTtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcG9zID0gc2VsLmVtcHR5ID8gbnVsbCA6IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAocG9zICYmIHBvcy5wb3MgPj0gc2VsLmZyb20gJiYgcG9zLnBvcyA8PSAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiA/IHNlbC50byAtIDEgOiBzZWwudG8pKSA7XG4gICAgZWxzZSBpZiAobW91c2VEb3duICYmIG1vdXNlRG93bi5taWdodERyYWcpIHtcbiAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBtb3VzZURvd24ubWlnaHREcmFnLnBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhldmVudC50YXJnZXQsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiBkZXNjICE9IHZpZXcuZG9jVmlldylcbiAgICAgICAgICAgIG5vZGUgPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpO1xuICAgIH1cbiAgICBsZXQgZHJhZ2dlZFNsaWNlID0gKG5vZGUgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24pLmNvbnRlbnQoKTtcbiAgICBsZXQgeyBkb20sIHRleHQsIHNsaWNlIH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgZHJhZ2dlZFNsaWNlKTtcbiAgICAvLyBQcmUtMTIwIENocm9tZSB2ZXJzaW9ucyBjbGVhciBmaWxlcyB3aGVuIGNhbGxpbmcgYGNsZWFyRGF0YWAgKCMxNDcyKVxuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCB8fCAhY2hyb21lIHx8IGNocm9tZV92ZXJzaW9uID4gMTIwKVxuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCBkcmFnTW92ZXModmlldywgZXZlbnQpLCBub2RlKTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LmRyYWdnaW5nID09IGRyYWdnaW5nKVxuICAgICAgICAgICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgfSwgNTApO1xufTtcbmVkaXRIYW5kbGVycy5kcmFnb3ZlciA9IGVkaXRIYW5kbGVycy5kcmFnZW50ZXIgPSAoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuZWRpdEhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBoYW5kbGVEcm9wKHZpZXcsIGV2ZW50LCB2aWV3LmRyYWdnaW5nKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICAgIH1cbn07XG5mdW5jdGlvbiBoYW5kbGVEcm9wKHZpZXcsIGV2ZW50LCBkcmFnZ2luZykge1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGV2ZW50UG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGlmICghZXZlbnRQb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJG1vdXNlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShldmVudFBvcy5wb3MpO1xuICAgIGxldCBzbGljZSA9IGRyYWdnaW5nICYmIGRyYWdnaW5nLnNsaWNlO1xuICAgIGlmIChzbGljZSkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcsIGZhbHNlKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBnZXRUZXh0KGV2ZW50LmRhdGFUcmFuc2ZlciksIGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZmFsc2UsICRtb3VzZSk7XG4gICAgfVxuICAgIGxldCBtb3ZlID0gISEoZHJhZ2dpbmcgJiYgZHJhZ01vdmVzKHZpZXcsIGV2ZW50KSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVEcm9wXCIsIGYgPT4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgU2xpY2UuZW1wdHksIG1vdmUpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBpbnNlcnRQb3MgPSBzbGljZSA/IGRyb3BQb2ludCh2aWV3LnN0YXRlLmRvYywgJG1vdXNlLnBvcywgc2xpY2UpIDogJG1vdXNlLnBvcztcbiAgICBpZiAoaW5zZXJ0UG9zID09IG51bGwpXG4gICAgICAgIGluc2VydFBvcyA9ICRtb3VzZS5wb3M7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICBpZiAobW92ZSkge1xuICAgICAgICBsZXQgeyBub2RlIH0gPSBkcmFnZ2luZztcbiAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICBub2RlLnJlcGxhY2UodHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgbGV0IHBvcyA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgbGV0IGlzTm9kZSA9IHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMTtcbiAgICBsZXQgYmVmb3JlSW5zZXJ0ID0gdHIuZG9jO1xuICAgIGlmIChpc05vZGUpXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgocG9zLCBwb3MsIHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgZWxzZVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2UocG9zLCBwb3MsIHNsaWNlKTtcbiAgICBpZiAodHIuZG9jLmVxKGJlZm9yZUluc2VydCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKGlzTm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpICYmXG4gICAgICAgICRwb3Mubm9kZUFmdGVyICYmICRwb3Mubm9kZUFmdGVyLnNhbWVNYXJrdXAoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24oJHBvcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGVuZCA9IHRyLm1hcHBpbmcubWFwKGluc2VydFBvcyk7XG4gICAgICAgIHRyLm1hcHBpbmcubWFwc1t0ci5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV0uZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiBlbmQgPSBuZXdUbyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRwb3MsIHRyLmRvYy5yZXNvbHZlKGVuZCkpKTtcbiAgICB9XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJkcm9wXCIpKTtcbn1cbmhhbmRsZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPSBEYXRlLm5vdygpO1xuICAgIGlmICghdmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5oYXNGb2N1cygpICYmICF2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbn07XG5oYW5kbGVycy5ibHVyID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAodmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCAmJiB2aWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIC8vIFdlIHNob3VsZCBwcm9iYWJseSBkbyBtb3JlIHdpdGggYmVmb3JlaW5wdXQgZXZlbnRzLCBidXQgc3VwcG9ydFxuICAgIC8vIGlzIHNvIHNwb3R0eSB0aGF0IEknbSBzdGlsbCB3YWl0aW5nIHRvIHNlZSB3aGVyZSB0aGV5IGFyZSBnb2luZy5cbiAgICAvLyBWZXJ5IHNwZWNpZmljIGhhY2sgdG8gZGVhbCB3aXRoIGJhY2tzcGFjZSBzb21ldGltZXMgZmFpbGluZyBvblxuICAgIC8vIENocm9tZSBBbmRyb2lkIHdoZW4gYWZ0ZXIgYW4gdW5lZGl0YWJsZSBub2RlLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJkZWxldGVDb250ZW50QmFja3dhcmRcIikge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgICAgICBsZXQgeyBkb21DaGFuZ2VDb3VudCB9ID0gdmlldy5pbnB1dDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCAhPSBkb21DaGFuZ2VDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEV2ZW50IGFscmVhZHkgaGFkIHNvbWUgZWZmZWN0XG4gICAgICAgICAgICAvLyBUaGlzIGJ1ZyB0ZW5kcyB0byBjbG9zZSB0aGUgdmlydHVhbCBrZXlib2FyZCwgc28gd2UgcmVmb2N1c1xuICAgICAgICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgLy8gQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiBiYWNrc3BhY2UgYmVoYXZpb3Igd2hlbiBubyBjb21tYW5kIGhhbmRsZWQgaXRcbiAgICAgICAgICAgIGlmICgkY3Vyc29yICYmICRjdXJzb3IucG9zID4gMClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlKCRjdXJzb3IucG9zIC0gMSwgJGN1cnNvci5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbi8vIE1ha2Ugc3VyZSBhbGwgaGFuZGxlcnMgZ2V0IHJlZ2lzdGVyZWRcbmZvciAobGV0IHByb3AgaW4gZWRpdEhhbmRsZXJzKVxuICAgIGhhbmRsZXJzW3Byb3BdID0gZWRpdEhhbmRsZXJzW3Byb3BdO1xuXG5mdW5jdGlvbiBjb21wYXJlT2JqcyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b0RPTSwgc3BlYykge1xuICAgICAgICB0aGlzLnRvRE9NID0gdG9ET007XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLnNwZWMuc2lkZSB8fCAwO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgcG9zLCBkZWxldGVkIH0gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihwb3MgLSBvZmZzZXQsIHBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRUeXBlICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BlYy5rZXkgJiYgdGhpcy5zcGVjLmtleSA9PSBvdGhlci5zcGVjLmtleSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvRE9NID09IG90aGVyLnRvRE9NICYmIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpKTtcbiAgICB9XG4gICAgZGVzdHJveShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KG5vZGUpO1xuICAgIH1cbn1cbmNsYXNzIElubGluZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZVN0YXJ0ID8gLTEgOiAxKSAtIG9mZnNldDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXAoc3Bhbi50byArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZUVuZCA/IDEgOiAtMSkgLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBmcm9tID49IHRvID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoXywgc3BhbikgeyByZXR1cm4gc3Bhbi5mcm9tIDwgc3Bhbi50bzsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBJbmxpbmVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXMoc3BhbikgeyByZXR1cm4gc3Bhbi50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycywgc3BlYykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIDEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4udG8gKyBvbGRPZmZzZXQsIC0xKTtcbiAgICAgICAgaWYgKHRvLmRlbGV0ZWQgfHwgdG8ucG9zIDw9IGZyb20ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLnBvcyAtIG9mZnNldCwgdG8ucG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQobm9kZSwgc3Bhbikge1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHNwYW4uZnJvbSksIGNoaWxkO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09IHNwYW4uZnJvbSAmJiAhKGNoaWxkID0gbm9kZS5jaGlsZChpbmRleCkpLmlzVGV4dCAmJiBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZSA9PSBzcGFuLnRvO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgTm9kZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbi8qKlxuRGVjb3JhdGlvbiBvYmplY3RzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgdmlldyB0aHJvdWdoIHRoZVxuW2BkZWNvcmF0aW9uc2AgcHJvcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuZGVjb3JhdGlvbnMpLiBUaGV5IGNvbWUgaW5cbnNldmVyYWwgdmFyaWFudHPigJRzZWUgdGhlIHN0YXRpYyBtZW1iZXJzIG9mIHRoaXMgY2xhc3MgZm9yIGRldGFpbHMuXG4qL1xuY2xhc3MgRGVjb3JhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uLiBXaWxsIGJlIHRoZSBzYW1lIGFzIGBmcm9tYCBmb3IgW3dpZGdldFxuICAgIGRlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXndpZGdldCkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb3B5KGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgdGhpcy50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlciwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmVxKG90aGVyLnR5cGUpICYmIHRoaXMuZnJvbSArIG9mZnNldCA9PSBvdGhlci5mcm9tICYmIHRoaXMudG8gKyBvZmZzZXQgPT0gb3RoZXIudG87XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUubWFwKG1hcHBpbmcsIHRoaXMsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlIHRoYXQncyBzaG93biBpblxuICAgIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91XG4gICAgZGVsYXkgcmVuZGVyaW5nIHRoZSB3aWRnZXQgYnkgcGFzc2luZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgIGNhbGxlZCB3aGVuIHRoZSB3aWRnZXQgaXMgYWN0dWFsbHkgZHJhd24gaW4gYSB2aWV3LCBidXQgeW91IGNhblxuICAgIGFsc28gZGlyZWN0bHkgcGFzcyBhIERPTSBub2RlLiBgZ2V0UG9zYCBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZVxuICAgIHdpZGdldCdzIGN1cnJlbnQgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHBvcywgdG9ET00sIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKHBvcywgcG9zLCBuZXcgV2lkZ2V0VHlwZSh0b0RPTSwgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGFuIGlubGluZSBkZWNvcmF0aW9uLCB3aGljaCBhZGRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvXG4gICAgZWFjaCBpbmxpbmUgbm9kZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpbmxpbmUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IElubGluZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIG5vZGUgZGVjb3JhdGlvbi4gYGZyb21gIGFuZCBgdG9gIHNob3VsZCBwb2ludCBwcmVjaXNlbHlcbiAgICBiZWZvcmUgYW5kIGFmdGVyIGEgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFRoYXQgbm9kZSwgYW5kIG9ubHkgdGhhdFxuICAgIG5vZGUsIHdpbGwgcmVjZWl2ZSB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBub2RlKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBOb2RlVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3BlYyBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIHRoaXMgZGVjb3JhdGlvbi4gQ2FuIGJlIHVzZWZ1bFxuICAgIGlmIHlvdSd2ZSBzdG9yZWQgZXh0cmEgaW5mb3JtYXRpb24gaW4gdGhhdCBvYmplY3QuXG4gICAgKi9cbiAgICBnZXQgc3BlYygpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHsgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIFdpZGdldFR5cGU7IH1cbn1cbmNvbnN0IG5vbmUgPSBbXSwgbm9TcGVjID0ge307XG4vKipcbkEgY29sbGVjdGlvbiBvZiBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pLCBvcmdhbml6ZWQgaW4gc3VjaFxuYSB3YXkgdGhhdCB0aGUgZHJhd2luZyBhbGdvcml0aG0gY2FuIGVmZmljaWVudGx5IHVzZSBhbmQgY29tcGFyZVxudGhlbS4gVGhpcyBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmXigJRpdCBpcyBub3QgbW9kaWZpZWQsXG51cGRhdGVzIGNyZWF0ZSBhIG5ldyB2YWx1ZS5cbiovXG5jbGFzcyBEZWNvcmF0aW9uU2V0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwubGVuZ3RoID8gbG9jYWwgOiBub25lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW4gOiBub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMsIHVzaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIFRoaXMgd2lsbCBjb25zdW1lIChtb2RpZnkpIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LCBzb1xuICAgIHlvdSBtdXN0IG1ha2UgYSBjb3B5IGlmIHlvdSB3YW50IG5lZWQgdG8gcHJlc2VydmUgdGhhdC5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVjb3JhdGlvbnMubGVuZ3RoID8gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBkb2MsIDAsIG5vU3BlYykgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhbGwgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQgd2hpY2ggdG91Y2ggdGhlIGdpdmVuIHJhbmdlXG4gICAgKGluY2x1ZGluZyBkZWNvcmF0aW9ucyB0aGF0IHN0YXJ0IG9yIGVuZCBkaXJlY3RseSBhdCB0aGVcbiAgICBib3VuZGFyaWVzKSBhbmQgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZSBvbiB0aGVpciBzcGVjLiBXaGVuXG4gICAgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIG9taXR0ZWQsIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGUgc2V0IGFyZVxuICAgIGNvbnNpZGVyZWQuIFdoZW4gYHByZWRpY2F0ZWAgaXNuJ3QgZ2l2ZW4sIGFsbCBkZWNvcmF0aW9ucyBhcmVcbiAgICBhc3N1bWVkIHRvIG1hdGNoLlxuICAgICovXG4gICAgZmluZChzdGFydCwgZW5kLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZpbmRJbm5lcihzdGFydCA9PSBudWxsID8gMCA6IHN0YXJ0LCBlbmQgPT0gbnVsbCA/IDFlOSA6IGVuZCwgcmVzdWx0LCAwLCBwcmVkaWNhdGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmaW5kSW5uZXIoc3RhcnQsIGVuZCwgcmVzdWx0LCBvZmZzZXQsIHByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gZW5kICYmIHNwYW4udG8gPj0gc3RhcnQgJiYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHNwYW4uc3BlYykpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYW4uY29weShzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIDwgZW5kICYmIHRoaXMuY2hpbGRyZW5baSArIDFdID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRPZmYgPSB0aGlzLmNoaWxkcmVuW2ldICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAyXS5maW5kSW5uZXIoc3RhcnQgLSBjaGlsZE9mZiwgZW5kIC0gY2hpbGRPZmYsIHJlc3VsdCwgb2Zmc2V0ICsgY2hpbGRPZmYsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoZSBzZXQgb2YgZGVjb3JhdGlvbnMgaW4gcmVzcG9uc2UgdG8gYSBjaGFuZ2UgaW4gdGhlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5IHx8IG1hcHBpbmcubWFwcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBJbm5lcihtYXBwaW5nLCBkb2MsIDAsIDAsIG9wdGlvbnMgfHwgbm9TcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXBJbm5lcihtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgbmV3TG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQgJiYgbWFwcGVkLnR5cGUudmFsaWQobm9kZSwgbWFwcGVkKSlcbiAgICAgICAgICAgICAgICAobmV3TG9jYWwgfHwgKG5ld0xvY2FsID0gW10pKS5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUodGhpcy5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbWFwQ2hpbGRyZW4odGhpcy5jaGlsZHJlbiwgbmV3TG9jYWwgfHwgW10sIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ld0xvY2FsID8gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIG5vbmUpIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbnMgdG8gdGhlIG9uZXMgaW4gdGhlIHNldCxcbiAgICBwcm9kdWNpbmcgYSBuZXcgc2V0LiBDb25zdW1lcyB0aGUgYGRlY29yYXRpb25zYCBhcnJheS4gTmVlZHNcbiAgICBhY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQgdG8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0cmVlXG4gICAgc3RydWN0dXJlLlxuICAgICovXG4gICAgYWRkKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkZWNvcmF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICBhZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuLCBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgZG9jLmZvckVhY2goKGNoaWxkTm9kZSwgY2hpbGRPZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGxldCBiYXNlT2Zmc2V0ID0gY2hpbGRPZmZzZXQgKyBvZmZzZXQsIGZvdW5kO1xuICAgICAgICAgICAgaWYgKCEoZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKGRlY29yYXRpb25zLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkSW5kZXggPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bY2hpbGRJbmRleF0gPCBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5bY2hpbGRJbmRleF0gPT0gY2hpbGRPZmZzZXQpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdID0gY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdLmFkZElubmVyKGNoaWxkTm9kZSwgZm91bmQsIGJhc2VPZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGRPZmZzZXQsIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCArIDEsIG5vU3BlYykpO1xuICAgICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxvY2FsID0gbW92ZVNwYW5zKGNoaWxkSW5kZXggPyB3aXRob3V0TnVsbHMoZGVjb3JhdGlvbnMpIDogZGVjb3JhdGlvbnMsIC1vZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFsb2NhbFtpXS50eXBlLnZhbGlkKGRvYywgbG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShpLS0sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobG9jYWwubGVuZ3RoID8gdGhpcy5sb2NhbC5jb25jYXQobG9jYWwpLnNvcnQoYnlQb3MpIDogdGhpcy5sb2NhbCwgY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzZXQgdGhhdCBjb250YWlucyB0aGUgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQsIG1pbnVzXG4gICAgdGhlIG9uZXMgaW4gdGhlIGdpdmVuIGFycmF5LlxuICAgICovXG4gICAgcmVtb3ZlKGRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmIChkZWNvcmF0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUlubmVyKGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gICAgcmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsb2NhbCA9IHRoaXMubG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY2hpbGRyZW5baV0gKyBvZmZzZXQsIHRvID0gY2hpbGRyZW5baSArIDFdICsgb2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHNwYW47IGogPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPiBmcm9tICYmIHNwYW4udG8gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnNbal0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gY2hpbGRyZW5baSArIDJdLnJlbW92ZUlubmVyKGZvdW5kLCBmcm9tICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IHJlbW92ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbC5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc3BhbjsgaSA8IGRlY29yYXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFtqXS5lcShzcGFuLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsID09IHRoaXMubG9jYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5sb2NhbC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4gJiYgbG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbG9jYWwubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikgOiBlbXB0eTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgY2hpbGQsIGxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpICsgMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IG9mZnNldCArIDEsIGVuZCA9IHN0YXJ0ICsgbm9kZS5jb250ZW50LnNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGRlYyA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgICAgICBpZiAoZGVjLmZyb20gPCBlbmQgJiYgZGVjLnRvID4gc3RhcnQgJiYgKGRlYy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHN0YXJ0LCBkZWMuZnJvbSkgLSBzdGFydCwgdG8gPSBNYXRoLm1pbihlbmQsIGRlYy50bykgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAobG9jYWwgfHwgKGxvY2FsID0gW10pKS5wdXNoKGRlYy5jb3B5KGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxTZXQgPSBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPyBuZXcgRGVjb3JhdGlvbkdyb3VwKFtsb2NhbFNldCwgY2hpbGRdKSA6IGxvY2FsU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PSBvdGhlcilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpIHx8XG4gICAgICAgICAgICB0aGlzLmxvY2FsLmxlbmd0aCAhPSBvdGhlci5sb2NhbC5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9IG90aGVyLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvY2FsW2ldLmVxKG90aGVyLmxvY2FsW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldICE9IG90aGVyLmNoaWxkcmVuW2ldIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpICsgMV0gIT0gb3RoZXIuY2hpbGRyZW5baSArIDFdIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuY2hpbGRyZW5baSArIDJdLmVxKG90aGVyLmNoaWxkcmVuW2kgKyAyXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlT3ZlcmxhcCh0aGlzLmxvY2Fsc0lubmVyKG5vZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHNJbm5lcihub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG5vbmU7XG4gICAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQgfHwgIXRoaXMubG9jYWwuc29tZShJbmxpbmVUeXBlLmlzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5sb2NhbFtpXS50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sb2NhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9yRWFjaFNldChmKSB7IGYodGhpcyk7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uU2V0LmVtcHR5ID0gbmV3IERlY29yYXRpb25TZXQoW10sIFtdKTtcbi8qKlxuQGludGVybmFsXG4qL1xuRGVjb3JhdGlvblNldC5yZW1vdmVPdmVybGFwID0gcmVtb3ZlT3ZlcmxhcDtcbmNvbnN0IGVtcHR5ID0gRGVjb3JhdGlvblNldC5lbXB0eTtcbi8vIEFuIGFic3RyYWN0aW9uIHRoYXQgYWxsb3dzIHRoZSBjb2RlIGRlYWxpbmcgd2l0aCBkZWNvcmF0aW9ucyB0b1xuLy8gdHJlYXQgbXVsdGlwbGUgRGVjb3JhdGlvblNldCBvYmplY3RzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUgb2JqZWN0XG4vLyB3aXRoIChhIHN1YnNldCBvZikgdGhlIHNhbWUgaW50ZXJmYWNlLlxuY2xhc3MgRGVjb3JhdGlvbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBkb2MpIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGVjb3MgPSB0aGlzLm1lbWJlcnMubWFwKG1lbWJlciA9PiBtZW1iZXIubWFwKG1hcHBpbmcsIGRvYywgbm9TcGVjKSk7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShtYXBwZWREZWNvcyk7XG4gICAgfVxuICAgIGZvckNoaWxkKG9mZnNldCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgZm91bmQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1lbWJlcnNbaV0uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLmNvbmNhdChyZXN1bHQubWVtYmVycyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKSB8fFxuICAgICAgICAgICAgb3RoZXIubWVtYmVycy5sZW5ndGggIT0gdGhpcy5tZW1iZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubWVtYmVyc1tpXS5lcShvdGhlci5tZW1iZXJzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICBsZXQgcmVzdWx0LCBzb3J0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxvY2FscyA9IHRoaXMubWVtYmVyc1tpXS5sb2NhbHNJbm5lcihub2RlKTtcbiAgICAgICAgICAgIGlmICghbG9jYWxzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbG9jYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYWxzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsb2NhbHNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZW1vdmVPdmVybGFwKHNvcnRlZCA/IHJlc3VsdCA6IHJlc3VsdC5zb3J0KGJ5UG9zKSkgOiBub25lO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBncm91cCBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGRlY29yYXRpb24gc2V0cywgb3IgcmV0dXJuXG4gICAgLy8gYSBzaW5nbGUgc2V0IHdoZW4gcG9zc2libGUuXG4gICAgc3RhdGljIGZyb20obWVtYmVycykge1xuICAgICAgICBzd2l0Y2ggKG1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBlbXB0eTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG1lbWJlcnNbMF07XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gbmV3IERlY29yYXRpb25Hcm91cChtZW1iZXJzLmV2ZXJ5KG0gPT4gbSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpID8gbWVtYmVycyA6XG4gICAgICAgICAgICAgICAgbWVtYmVycy5yZWR1Y2UoKHIsIG0pID0+IHIuY29uY2F0KG0gaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0ID8gbSA6IG0ubWVtYmVycyksIFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaFNldChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5tZW1iZXJzW2ldLmZvckVhY2hTZXQoZik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4ob2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IG9sZENoaWxkcmVuLnNsaWNlKCk7XG4gICAgLy8gTWFyayB0aGUgY2hpbGRyZW4gdGhhdCBhcmUgZGlyZWN0bHkgdG91Y2hlZCBieSBjaGFuZ2VzLCBhbmRcbiAgICAvLyBtb3ZlIHRob3NlIHRoYXQgYXJlIGFmdGVyIHRoZSBjaGFuZ2VzLlxuICAgIGZvciAobGV0IGkgPSAwLCBiYXNlT2Zmc2V0ID0gb2xkT2Zmc2V0OyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IDA7XG4gICAgICAgIG1hcHBpbmcubWFwc1tpXS5mb3JFYWNoKChvbGRTdGFydCwgb2xkRW5kLCBuZXdTdGFydCwgbmV3RW5kKSA9PiB7XG4gICAgICAgICAgICBsZXQgZFNpemUgPSAobmV3RW5kIC0gbmV3U3RhcnQpIC0gKG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPCAwIHx8IG9sZFN0YXJ0ID4gZW5kICsgYmFzZU9mZnNldCAtIG1vdmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjaGlsZHJlbltpXSArIGJhc2VPZmZzZXQgLSBtb3ZlZDtcbiAgICAgICAgICAgICAgICBpZiAob2xkRW5kID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IG9sZFN0YXJ0IDw9IHN0YXJ0ID8gLTIgOiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkU3RhcnQgPj0gYmFzZU9mZnNldCAmJiBkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdICs9IGRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVkICs9IGRTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFzZU9mZnNldCA9IG1hcHBpbmcubWFwc1tpXS5tYXAoYmFzZU9mZnNldCwgLTEpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgICAvLyByZWN1cnNpdmVseSBjYWxsIG1hcElubmVyIG9uIHRoZW0gYW5kIHVwZGF0ZSB0aGVpciBwb3NpdGlvbnMuXG4gICAgbGV0IG11c3RSZWJ1aWxkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMikge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQpLCBmcm9tTG9jYWwgPSBmcm9tIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCByZWFkIG9sZENoaWxkcmVuIGJlY2F1c2UgY2hpbGRyZW4gd2FzIHRhZ2dlZCB3aXRoIC0xXG4gICAgICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpICsgMV0gKyBvbGRPZmZzZXQsIC0xKSwgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldDogY2hpbGRPZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE9mZnNldCA9PSBmcm9tTG9jYWwgJiYgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUgPT0gdG9Mb2NhbCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGlsZHJlbltpICsgMl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gdG9Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gICAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVpbHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltqXSA8IGZyb20pXG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW2ldLCBidWlsdC5jaGlsZHJlbltpICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzcGFucztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRGVjb3JhdGlvbihzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQsIHNwYW4udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBkZWNvcmF0aW9ucywgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBHYXRoZXIgYWxsIGRlY29yYXRpb25zIGZyb20gdGhlIHJlbWFpbmluZyBtYXJrZWQgY2hpbGRyZW5cbiAgICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBzZXQubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHNldC5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5baSArIDJdLCBzZXQuY2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSlcbiAgICAgICAgICAgIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSwgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIGhhc051bGxzID0gZmFsc2U7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgY2hpbGROb2RlLCBsb2NhbFN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICAgICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbG9jYWxzLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbHMsIGNoaWxkcmVuKSA6IGVtcHR5O1xufVxuLy8gVXNlZCB0byBzb3J0IGRlY29yYXRpb25zIHNvIHRoYXQgb25lcyB3aXRoIGEgbG93IHN0YXJ0IHBvc2l0aW9uXG4vLyBjb21lIGZpcnN0LCBhbmQgd2l0aGluIGEgc2V0IHdpdGggdGhlIHNhbWUgc3RhcnQgcG9zaXRpb24sIHRob3NlXG4vLyB3aXRoIGFuIHNtYWxsZXIgZW5kIHBvc2l0aW9uIGNvbWUgZmlyc3QuXG5mdW5jdGlvbiBieVBvcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgICBsZXQgd29ya2luZyA9IHNwYW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSB3b3JraW5nW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tpXSA9IHNwYW4uY29weShzcGFuLmZyb20sIG5leHQuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29ya2luZztcbn1cbmZ1bmN0aW9uIGluc2VydEFoZWFkKGFycmF5LCBpLCBkZWNvKSB7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMClcbiAgICAgICAgaSsrO1xuICAgIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cbi8vIEdldCB0aGUgZGVjb3JhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHByb3BzIG9mIGEgdmlldy5cbmZ1bmN0aW9uIHZpZXdEZWNvcmF0aW9ucyh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGYgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZih2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcilcbiAgICAgICAgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpO1xuICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxuY29uc3QgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIHNldChzZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlcShzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmXG4gICAgICAgICAgICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IG5vZGUgYWZ0ZXIgYSBCUiBub2RlKSBjYWxsIHRoZSBvYnNlcnZlciBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTSwgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBQcm9zZU1pcnJvciB0byBtaXNzIHRoZSBjaGFuZ2UgKHNlZSAjOTMwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzYWZhcmkgJiYgdmlldy5jb21wb3NpbmcgJiYgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnRhcmdldC5ub2RlTmFtZSA9PSBcIlRSXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBkb2VzIHdlaXJkIHN0dWZmIHdoZW4gZmluaXNoaW5nIGEgY29tcG9zaXRpb24gaW4gYVxuICAgICAgICAgICAgICAgICAgICAvLyB0YWJsZSBjZWxsLCB3aGljaCB0ZW5kcyB0byBpbnZvbHZlIGluc2VydGluZyBpbmFwcHJvcHJpYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGVzIGluIHRoZSB0YWJsZSByb3cuXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQuYmFkU2FmYXJpQ29tcG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZS50YXJnZXQsIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLCBvbGRWYWx1ZTogZS5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPCAwKVxuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZmx1c2hpbmdTb29uID0gLTE7IHRoaXMuZmx1c2goKTsgfSwgMjApO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPiAtMSkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmZsdXNoaW5nU29vbik7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMudmlldy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgbGV0IHRha2UgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICBpZiAodGFrZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2UubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh0YWtlW2ldKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoKCksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGNvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCkge1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZSwgNTApO1xuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCFoYXNGb2N1c0FuZFNlbGVjdGlvbih0aGlzLnZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMpXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KTtcbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFXG4gICAgICAgICAgICBpZiAoc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIHNldEN1clNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldCh0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgfVxuICAgIGlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpIHtcbiAgICAgICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBhbmNlc3RvcnMgPSBuZXcgU2V0LCBjb250YWluZXI7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuZm9jdXNOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGFuY2VzdG9ycy5hZGQoc2Nhbik7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuYW5jaG9yTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyhzY2FuKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHNjYW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkZXNjID0gY29udGFpbmVyICYmIHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2MuaWdub3JlTXV0YXRpb24oe1xuICAgICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICAgIHRhcmdldDogY29udGFpbmVyLm5vZGVUeXBlID09IDMgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lclxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdSZWNvcmRzKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcilcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlO1xuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF2aWV3LmRvY1ZpZXcgfHwgdGhpcy5mbHVzaGluZ1Nvb24gPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG11dGF0aW9ucyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSAhdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgJiYgIXRoaXMuY3VycmVudFNlbGVjdGlvbi5lcShzZWwpICYmIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpICYmICF0aGlzLmlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlLCBhZGRlZCA9IFtdO1xuICAgICAgICBpZiAodmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZWdpc3Rlck11dGF0aW9uKG11dGF0aW9uc1tpXSwgYWRkZWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGZyb20gPCAwID8gcmVzdWx0LmZyb20gOiBNYXRoLm1pbihyZXN1bHQuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gdG8gPCAwID8gcmVzdWx0LnRvIDogTWF0aC5tYXgocmVzdWx0LnRvLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnZWNrbyAmJiBhZGRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBicnMgPSBhZGRlZC5maWx0ZXIobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIik7XG4gICAgICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IFthLCBiXSA9IGJycztcbiAgICAgICAgICAgICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGEucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmb2N1c05vZGUgfSA9IHRoaXMuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiciBvZiBicnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGJyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lID09IFwiTElcIiAmJiAoIWZvY3VzTm9kZSB8fCBibG9ja1BhcmVudCh2aWV3LCBmb2N1c05vZGUpICE9IHBhcmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBici5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGNocm9tZSB8fCBzYWZhcmkpICYmIGFkZGVkLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIikgJiZcbiAgICAgICAgICAgICh2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09IDggfHwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PSA0NikpIHtcbiAgICAgICAgICAgIC8vIENocm9tZS9TYWZhcmkgc29tZXRpbWVzIGluc2VydCBhIGJvZ3VzIGJyZWFrIG5vZGUgaWYgeW91XG4gICAgICAgICAgICAvLyBiYWNrc3BhY2Ugb3V0IHRoZSBsYXN0IGJpdCBvZiB0ZXh0IGJlZm9yZSBhbiBpbmxpbmUtZmxleCBub2RlICgjMTU1MilcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgYWRkZWQpXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgJiYgYWZ0ZXIubm9kZVR5cGUgPT0gMSAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVhZFNlbCA9IG51bGw7XG4gICAgICAgIC8vIElmIGl0IGxvb2tzIGxpa2UgdGhlIGJyb3dzZXIgaGFzIHJlc2V0IHRoZSBzZWxlY3Rpb24gdG8gdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCBhZnRlciBmb2N1cywgcmVzdG9yZSB0aGUgc2VsZWN0aW9uIGZyb21cbiAgICAgICAgLy8gdGhlIHN0YXRlXG4gICAgICAgIGlmIChmcm9tIDwgMCAmJiBuZXdTZWwgJiYgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPiBEYXRlLm5vdygpIC0gMjAwICYmXG4gICAgICAgICAgICBNYXRoLm1heCh2aWV3LmlucHV0Lmxhc3RUb3VjaCwgdmlldy5pbnB1dC5sYXN0Q2xpY2sudGltZSkgPCBEYXRlLm5vdygpIC0gMzAwICYmXG4gICAgICAgICAgICBzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSAmJiAocmVhZFNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldykpICYmXG4gICAgICAgICAgICByZWFkU2VsLmVxKFNlbGVjdGlvbi5uZWFyKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoMCksIDEpKSkge1xuICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPSAwO1xuICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgICAgICB2aWV3LnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnJvbSA+IC0xIHx8IG5ld1NlbCkge1xuICAgICAgICAgICAgaWYgKGZyb20gPiAtMSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9jVmlldy5tYXJrRGlydHkoZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIGNoZWNrQ1NTKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQuYmFkU2FmYXJpQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0LmJhZFNhZmFyaUNvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZml4VXBCYWRTYWZhcmlDb21wb3NpdGlvbih2aWV3LCBhZGRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00gJiYgZGVzYy5jb250ZW50RE9NICE9IGRlc2MuZG9tICYmICFkZXNjLmNvbnRlbnRET00uY29udGFpbnMobXV0LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NCZWZvcmUsIHRvOiBkZXNjLnBvc0FmdGVyIH07XG4gICAgICAgICAgICBsZXQgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExIGdpdmVzIHVzIGluY29ycmVjdCBuZXh0L3ByZXYgc2libGluZ3MgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb25zLCBzbyBpZiB0aGVyZSBhcmUgYWRkZWQgbm9kZXMsIHJlY29tcHV0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZyB9ID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIHByZXZpb3VzU2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBuZXh0U2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gXCJjaGFyYWN0ZXJEYXRhXCJcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZWRUZXh0Tm9kZSA9IG11dC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGxldCBhbmNob3JOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSByYW5nZS5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJyZW50QW5jaG9yID0gdmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1cnJlbnRBbmNob3Iubm9kZSwgY3VycmVudEFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWdcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0IGZpeFxuZnVuY3Rpb24gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2Uodmlldywgc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXModmlldy5yb290KVswXTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZDtcbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIyKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd1Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHJldHVybiBmb3VuZCA/IHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuZnVuY3Rpb24gYmxvY2tQYXJlbnQodmlldywgbm9kZSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudE5vZGU7IHAgJiYgcCAhPSB2aWV3LmRvbTsgcCA9IHAucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhwLCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBLbHVkZ2UgZm9yIGEgU2FmYXJpIGJ1ZyB3aGVyZSwgb24gZW5kaW5nIGEgY29tcG9zaXRpb24gaW4gYW5cbi8vIG90aGVyd2lzZSBlbXB0eSB0YWJsZSBjZWxsLCBpdCByYW5kb21seSBtb3ZlcyB0aGUgY29tcG9zZWQgdGV4dFxuLy8gaW50byB0aGUgdGFibGUgcm93IGFyb3VuZCB0aGF0IGNlbGwsIGdyZWF0bHkgY29uZnVzaW5nIGV2ZXJ5dGhpbmdcbi8vICgjMTg4KS5cbmZ1bmN0aW9uIGZpeFVwQmFkU2FmYXJpQ29tcG9zaXRpb24odmlldywgYWRkZWROb2Rlcykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgZm9yIChsZXQgbm9kZSBvZiBhZGRlZE5vZGVzKSB7XG4gICAgICAgIGlmICgoKF9hID0gbm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZU5hbWUpID09IFwiVFJcIikge1xuICAgICAgICAgICAgbGV0IG5leHRDZWxsID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0Q2VsbCAmJiAobmV4dENlbGwubm9kZU5hbWUgIT0gXCJURFwiICYmIG5leHRDZWxsLm5vZGVOYW1lICE9IFwiVEhcIikpXG4gICAgICAgICAgICAgICAgbmV4dENlbGwgPSBuZXh0Q2VsbC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0Q2VsbCkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBuZXh0Q2VsbDtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0IHx8IGZpcnN0Lm5vZGVUeXBlICE9IDEgfHwgZmlyc3QuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgL14oQlJ8SU1HKSQvLnRlc3QoZmlyc3Qubm9kZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9jdXNOb2RlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tU2VsZWN0aW9uKCkuY29sbGFwc2Uobm9kZSwgZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBOb3RlIHRoYXQgYWxsIHJlZmVyZW5jaW5nIGFuZCBwYXJzaW5nIGlzIGRvbmUgd2l0aCB0aGVcbi8vIHN0YXJ0LW9mLW9wZXJhdGlvbiBzZWxlY3Rpb24gYW5kIGRvY3VtZW50LCBzaW5jZSB0aGF0J3MgdGhlIG9uZVxuLy8gdGhhdCB0aGUgRE9NIHJlcHJlc2VudHMuIElmIGFueSBjaGFuZ2VzIGNhbWUgaW4gaW4gdGhlIG1lYW50aW1lLFxuLy8gdGhlIG1vZGlmaWNhdGlvbiBpcyBtYXBwZWQgb3ZlciB0aG9zZSBiZWZvcmUgaXQgaXMgYXBwbGllZCwgaW5cbi8vIHJlYWRET01DaGFuZ2UuXG5mdW5jdGlvbiBwYXJzZUJldHdlZW4odmlldywgZnJvbV8sIHRvXykge1xuICAgIGxldCB7IG5vZGU6IHBhcmVudCwgZnJvbU9mZnNldCwgdG9PZmZzZXQsIGZyb20sIHRvIH0gPSB2aWV3LmRvY1ZpZXcucGFyc2VSYW5nZShmcm9tXywgdG9fKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBmaW5kO1xuICAgIGxldCBhbmNob3IgPSBkb21TZWwuYW5jaG9yTm9kZTtcbiAgICBpZiAoYW5jaG9yICYmIHZpZXcuZG9tLmNvbnRhaW5zKGFuY2hvci5ub2RlVHlwZSA9PSAxID8gYW5jaG9yIDogYW5jaG9yLnBhcmVudE5vZGUpKSB7XG4gICAgICAgIGZpbmQgPSBbeyBub2RlOiBhbmNob3IsIG9mZnNldDogZG9tU2VsLmFuY2hvck9mZnNldCB9XTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSlcbiAgICAgICAgICAgIGZpbmQucHVzaCh7IG5vZGU6IGRvbVNlbC5mb2N1c05vZGUsIG9mZnNldDogZG9tU2VsLmZvY3VzT2Zmc2V0IH0pO1xuICAgIH1cbiAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSBpbiBDaHJvbWUgd2hlcmUgYmFja3NwYWNpbmcgc29tZXRpbWVzIHJlcGxhY2VzXG4gICAgLy8gdGhlIGRlbGV0ZWQgY29udGVudCB3aXRoIGEgcmFuZG9tIEJSIG5vZGUgKGlzc3VlcyAjNzk5LCAjODMxKVxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0b09mZnNldDsgb2ZmID4gZnJvbU9mZnNldDsgb2ZmLS0pIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gcGFyZW50LmNoaWxkTm9kZXNbb2ZmIC0gMV0sIGRlc2MgPSBub2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRlc2MpIHtcbiAgICAgICAgICAgICAgICB0b09mZnNldCA9IG9mZjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCBkZXNjLnNpemUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgbGV0IHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCAkZnJvbSA9IHN0YXJ0RG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNlbCA9IG51bGwsIGRvYyA9IHBhcnNlci5wYXJzZShwYXJlbnQsIHtcbiAgICAgICAgdG9wTm9kZTogJGZyb20ucGFyZW50LFxuICAgICAgICB0b3BNYXRjaDogJGZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4KCkpLFxuICAgICAgICB0b3BPcGVuOiB0cnVlLFxuICAgICAgICBmcm9tOiBmcm9tT2Zmc2V0LFxuICAgICAgICB0bzogdG9PZmZzZXQsXG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJGZyb20ucGFyZW50LnR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gXCJmdWxsXCIgOiB0cnVlLFxuICAgICAgICBmaW5kUG9zaXRpb25zOiBmaW5kLFxuICAgICAgICBydWxlRnJvbU5vZGUsXG4gICAgICAgIGNvbnRleHQ6ICRmcm9tXG4gICAgfSk7XG4gICAgaWYgKGZpbmQgJiYgZmluZFswXS5wb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgYW5jaG9yID0gZmluZFswXS5wb3MsIGhlYWQgPSBmaW5kWzFdICYmIGZpbmRbMV0ucG9zO1xuICAgICAgICBpZiAoaGVhZCA9PSBudWxsKVxuICAgICAgICAgICAgaGVhZCA9IGFuY2hvcjtcbiAgICAgICAgc2VsID0geyBhbmNob3I6IGFuY2hvciArIGZyb20sIGhlYWQ6IGhlYWQgKyBmcm9tIH07XG4gICAgfVxuICAgIHJldHVybiB7IGRvYywgc2VsLCBmcm9tLCB0byB9O1xufVxuZnVuY3Rpb24gcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgaWYgKGRlc2MpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MucGFyc2VSdWxlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgLy8gU2FmYXJpIHJlcGxhY2VzIHRoZSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCB3aXRoIGEgQlJcbiAgICAgICAgLy8gZGlyZWN0bHkgaW4gdGhlIGxpc3Qgbm9kZSAoPyEpIGlmIHlvdSBkZWxldGUgdGhlIGxhc3RcbiAgICAgICAgLy8gY2hhcmFjdGVyIGluIGEgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgKCM3MDgsICM4NjIpXG4gICAgICAgIGlmIChzYWZhcmkgJiYgL14odWx8b2wpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgc2tpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBza2lwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICByZXR1cm4geyBza2lwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9tLnBhcmVudE5vZGUubGFzdENoaWxkID09IGRvbSB8fCBzYWZhcmkgJiYgL14odHJ8dGFibGUpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBkb20uZ2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiKSkge1xuICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBpc0lubGluZSA9IC9eKGF8YWJicnxhY3JvbnltfGJ8YmRbaW9dfGJpZ3xicnxidXR0b258Y2l0ZXxjb2RlfGRhdGEobGlzdCk/fGRlbHxkZm58ZW18aXxpbWd8aW5zfGtiZHxsYWJlbHxtYXB8bWFya3xtZXRlcnxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzbWFsbHxzcGFufHN0cm9uZ3xzdVticF18dGltZXx1fHR0fHZhcikkL2k7XG5mdW5jdGlvbiByZWFkRE9NQ2hhbmdlKHZpZXcsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWROb2Rlcykge1xuICAgIGxldCBjb21wb3NpdGlvbklEID0gdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIHx8ICh2aWV3LmNvbXBvc2luZyA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDApO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmIChjaGFuZ2UpXG4gICAgICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICBpZiAoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgfHwgYW5kcm9pZCkgJiZcbiAgICAgICAgYWRkZWROb2Rlcy5zb21lKG4gPT4gbi5ub2RlVHlwZSA9PSAxICYmICFpc0lubGluZS50ZXN0KG4ubm9kZU5hbWUpKSAmJlxuICAgICAgICAoIWNoYW5nZSB8fCBjaGFuZ2UuZW5kQSA+PSBjaGFuZ2UuZW5kQikgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIGlmICh0eXBlT3ZlciAmJiBzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgJiYgc2VsLiRoZWFkLnNhbWVQYXJlbnQoc2VsLiRhbmNob3IpICYmXG4gICAgICAgICAgICAhdmlldy5jb21wb3NpbmcgJiYgIShwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciAhPSBwYXJzZS5zZWwuaGVhZCkpIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgc3RhcnQ6IHNlbC5mcm9tLCBlbmRBOiBzZWwudG8sIGVuZEI6IHNlbC50byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmXG4gICAgICAgICAgICAoISRmcm9tLnNhbWVQYXJlbnQoJHRvKSB8fCAhJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpICYmXG4gICAgICAgICAgICAkZnJvbS5wb3MgPCAkdG8ucG9zICYmICEvXFxTLy50ZXN0KHBhcnNlLmRvYy50ZXh0QmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIFwiXCIsIFwiXCIpKSkpICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKSB7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTYW1lIGZvciBiYWNrc3BhY2VcbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID4gY2hhbmdlLnN0YXJ0ICYmXG4gICAgICAgIGxvb2tzTGlrZUJhY2tzcGFjZShkb2MsIGNoYW5nZS5zdGFydCwgY2hhbmdlLmVuZEEsICRmcm9tLCAkdG8pICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKSB7XG4gICAgICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IC8vICM4MjBcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgd2lsbCBvY2Nhc2lvbmFsbHksIGR1cmluZyBjb21wb3NpdGlvbiwgZGVsZXRlIHRoZVxuICAgIC8vIGVudGlyZSBjb21wb3NpdGlvbiBhbmQgdGhlbiBpbW1lZGlhdGVseSBpbnNlcnQgaXQgYWdhaW4uIFRoaXMgaXNcbiAgICAvLyB1c2VkIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICBpZiAoY2hyb21lICYmIGNoYW5nZS5lbmRCID09IGNoYW5nZS5zdGFydClcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0Q2hyb21lRGVsZXRlID0gRGF0ZS5ub3coKTtcbiAgICAvLyBUaGlzIHRyaWVzIHRvIGRldGVjdCBBbmRyb2lkIHZpcnR1YWwga2V5Ym9hcmRcbiAgICAvLyBlbnRlci1hbmQtcGljay1zdWdnZXN0aW9uIGFjdGlvbi4gVGhhdCBzb21ldGltZXMgKHNlZSBpc3N1ZVxuICAgIC8vICMxMDU5KSBmaXJzdCBmaXJlcyBhIERPTSBtdXRhdGlvbiwgYmVmb3JlIG1vdmluZyB0aGUgc2VsZWN0aW9uIHRvXG4gICAgLy8gdGhlIG5ld2x5IGNyZWF0ZWQgYmxvY2suIEFuZCB0aGVuLCBiZWNhdXNlIFByb3NlTWlycm9yIGNsZWFucyB1cFxuICAgIC8vIHRoZSBET00gc2VsZWN0aW9uLCBpdCBnaXZlcyB1cCBtb3ZpbmcgdGhlIHNlbGVjdGlvbiBlbnRpcmVseSxcbiAgICAvLyBsZWF2aW5nIHRoZSBjdXJzb3IgaW4gdGhlIHdyb25nIHBsYWNlLiBXaGVuIHRoYXQgaGFwcGVucywgd2UgZHJvcFxuICAgIC8vIHRoZSBuZXcgcGFyYWdyYXBoIGZyb20gdGhlIGluaXRpYWwgY2hhbmdlLCBhbmQgZmlyZSBhIHNpbXVsYXRlZFxuICAgIC8vIGVudGVyIGtleSBhZnRlcndhcmRzLlxuICAgIGlmIChhbmRyb2lkICYmICFpbmxpbmVDaGFuZ2UgJiYgJGZyb20uc3RhcnQoKSAhPSAkdG8uc3RhcnQoKSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09IDAgJiYgJGZyb20uZGVwdGggPT0gJHRvLmRlcHRoICYmXG4gICAgICAgIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHBhcnNlLnNlbC5oZWFkICYmIHBhcnNlLnNlbC5oZWFkID09IGNoYW5nZS5lbmRBKSB7XG4gICAgICAgIGNoYW5nZS5lbmRCIC09IDI7XG4gICAgICAgICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTsgfSk7XG4gICAgICAgIH0sIDIwKTtcbiAgICB9XG4gICAgbGV0IGNoRnJvbSA9IGNoYW5nZS5zdGFydCwgY2hUbyA9IGNoYW5nZS5lbmRBO1xuICAgIGxldCBta1RyID0gKGJhc2UpID0+IHtcbiAgICAgICAgbGV0IHRyID0gYmFzZSB8fCB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoY2hGcm9tLCBjaFRvLCBwYXJzZS5kb2Muc2xpY2UoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSwgY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKSk7XG4gICAgICAgIGlmIChwYXJzZS5zZWwpIHtcbiAgICAgICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHRyLmRvYywgcGFyc2Uuc2VsKTtcbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcywgZHVyaW5nIGNvbXBvc2l0aW9uLCByZXBvcnQgdGhlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIHdyb25nIHBsYWNlLiBJZiBpdCBsb29rcyBsaWtlIHRoYXQgaXNcbiAgICAgICAgICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAvLyBFZGdlIGp1c3QgZG9lc24ndCBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCB3aGVuIHlvdSBzdGFydCB0eXBpbmdcbiAgICAgICAgICAgIC8vIGluIGFuIGVtcHR5IGJsb2NrIG9yIGJldHdlZW4gYnIgbm9kZXMuXG4gICAgICAgICAgICBpZiAoc2VsICYmICEoY2hyb21lICYmIHZpZXcuY29tcG9zaW5nICYmIHNlbC5lbXB0eSAmJlxuICAgICAgICAgICAgICAgIChjaGFuZ2Uuc3RhcnQgIT0gY2hhbmdlLmVuZEIgfHwgdmlldy5pbnB1dC5sYXN0Q2hyb21lRGVsZXRlIDwgRGF0ZS5ub3coKSAtIDEwMCkgJiZcbiAgICAgICAgICAgICAgICAoc2VsLmhlYWQgPT0gY2hGcm9tIHx8IHNlbC5oZWFkID09IHRyLm1hcHBpbmcubWFwKGNoVG8pIC0gMSkgfHxcbiAgICAgICAgICAgICAgICBpZSAmJiBzZWwuZW1wdHkgJiYgc2VsLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgcmV0dXJuIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfTtcbiAgICBsZXQgbWFya0NoYW5nZTtcbiAgICBpZiAoaW5saW5lQ2hhbmdlKSB7XG4gICAgICAgIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcykgeyAvLyBEZWxldGlvblxuICAgICAgICAgICAgLy8gSUUxMSBzb21ldGltZXMgd2VpcmRseSBtb3ZlcyB0aGUgRE9NIHNlbGVjdGlvbiBhcm91bmQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHRleHRibG9ja1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odmlldyksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0ciA9IG1rVHIodmlldy5zdGF0ZS50ci5kZWxldGUoY2hGcm9tLCBjaFRvKSk7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpLm1hcmtzQWNyb3NzKGRvYy5yZXNvbHZlKGNoYW5nZS5lbmRBKSk7XG4gICAgICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIC8vIEFkZGluZyBvciByZW1vdmluZyBhIG1hcmtcbiAgICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgICAgIChtYXJrQ2hhbmdlID0gaXNNYXJrQ2hhbmdlKCRmcm9tLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpLCAkZnJvbUEucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tQS5wYXJlbnRPZmZzZXQsIGNoYW5nZS5lbmRBIC0gJGZyb21BLnN0YXJ0KCkpKSkpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IG1rVHIodmlldy5zdGF0ZS50cik7XG4gICAgICAgICAgICBpZiAobWFya0NoYW5nZS50eXBlID09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkZnJvbS5wYXJlbnQuY2hpbGQoJGZyb20uaW5kZXgoKSkuaXNUZXh0ICYmICRmcm9tLmluZGV4KCkgPT0gJHRvLmluZGV4KCkgLSAoJHRvLnRleHRPZmZzZXQgPyAwIDogMSkpIHtcbiAgICAgICAgICAgIC8vIEJvdGggcG9zaXRpb25zIGluIHRoZSBzYW1lIHRleHQgbm9kZSAtLSBzaW1wbHkgaW5zZXJ0IHRleHRcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gJGZyb20ucGFyZW50LnRleHRCZXR3ZWVuKCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBsZXQgZGVmbHQgPSAoKSA9PiBta1RyKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0LCBjaEZyb20sIGNoVG8pKTtcbiAgICAgICAgICAgIGlmICghdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgY2hGcm9tLCBjaFRvLCB0ZXh0LCBkZWZsdCkpKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goZGVmbHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKG1rVHIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2gobWtUcigpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gICAgaWYgKE1hdGgubWF4KHBhcnNlZFNlbC5hbmNob3IsIHBhcnNlZFNlbC5oZWFkKSA+IGRvYy5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICAgIGxldCBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLCBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gICAgbGV0IGFkZGVkID0gY3VyTWFya3MsIHJlbW92ZWQgPSBwcmV2TWFya3MsIHR5cGUsIG1hcmssIHVwZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVtb3ZlZCA9IGN1ck1hcmtzW2ldLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgbWFyayA9IGFkZGVkWzBdO1xuICAgICAgICB0eXBlID0gXCJhZGRcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgICAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICAgICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChpKSkpO1xuICAgIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpXG4gICAgICAgIHJldHVybiB7IG1hcmssIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZUJhY2tzcGFjZShvbGQsIHN0YXJ0LCBlbmQsICRuZXdTdGFydCwgJG5ld0VuZCkge1xuICAgIGlmICggLy8gVGhlIGNvbnRlbnQgbXVzdCBoYXZlIHNocnVua1xuICAgIGVuZCAtIHN0YXJ0IDw9ICRuZXdFbmQucG9zIC0gJG5ld1N0YXJ0LnBvcyB8fFxuICAgICAgICAvLyBuZXdFbmQgbXVzdCBwb2ludCBkaXJlY3RseSBhdCBvciBhZnRlciB0aGUgZW5kIG9mIHRoZSBibG9jayB0aGF0IG5ld1N0YXJ0IHBvaW50cyBpbnRvXG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV3U3RhcnQsIHRydWUsIGZhbHNlKSA8ICRuZXdFbmQucG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRzdGFydCA9IG9sZC5yZXNvbHZlKHN0YXJ0KTtcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUsIHJhdGhlciB0aGFuIGpvaW5pbmcgYmxvY2tzLCB0aGUgY2hhbmdlIGp1c3QgcmVtb3ZlZCBhbiBlbnRpcmUgYmxvY2tcbiAgICBpZiAoISRuZXdTdGFydC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgbGV0IGFmdGVyID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICAgICAgcmV0dXJuIGFmdGVyICE9IG51bGwgJiYgZW5kID09IHN0YXJ0ICsgYWZ0ZXIubm9kZVNpemU7XG4gICAgfVxuICAgIC8vIFN0YXJ0IG11c3QgYmUgYXQgdGhlIGVuZCBvZiBhIGJsb2NrXG4gICAgaWYgKCRzdGFydC5wYXJlbnRPZmZzZXQgPCAkc3RhcnQucGFyZW50LmNvbnRlbnQuc2l6ZSB8fCAhJHN0YXJ0LnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkbmV4dCA9IG9sZC5yZXNvbHZlKHNraXBDbG9zaW5nQW5kT3BlbmluZygkc3RhcnQsIHRydWUsIHRydWUpKTtcbiAgICAvLyBUaGUgbmV4dCB0ZXh0YmxvY2sgbXVzdCBzdGFydCBiZWZvcmUgZW5kIGFuZCBlbmQgbmVhciBpdFxuICAgIGlmICghJG5leHQucGFyZW50LmlzVGV4dGJsb2NrIHx8ICRuZXh0LnBvcyA+IGVuZCB8fFxuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5leHQsIHRydWUsIGZhbHNlKSA8IGVuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFRoZSBmcmFnbWVudHMgYWZ0ZXIgdGhlIGpvaW4gcG9pbnQgbXVzdCBtYXRjaFxuICAgIHJldHVybiAkbmV3U3RhcnQucGFyZW50LmNvbnRlbnQuY3V0KCRuZXdTdGFydC5wYXJlbnRPZmZzZXQpLmVxKCRuZXh0LnBhcmVudC5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aCwgZW5kID0gZnJvbUVuZCA/ICRwb3MuZW5kKCkgOiAkcG9zLnBvcztcbiAgICB3aGlsZSAoZGVwdGggPiAwICYmIChmcm9tRW5kIHx8ICRwb3MuaW5kZXhBZnRlcihkZXB0aCkgPT0gJHBvcy5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBlbmQrKztcbiAgICAgICAgZnJvbUVuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobWF5T3Blbikge1xuICAgICAgICBsZXQgbmV4dCA9ICRwb3Mubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgIW5leHQuaXNMZWFmKSB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHBvcywgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IHN0YXJ0ID0gYS5maW5kRGlmZlN0YXJ0KGIsIHBvcyk7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IGE6IGVuZEEsIGI6IGVuZEIgfSA9IGEuZmluZERpZmZFbmQoYiwgcG9zICsgYS5zaXplLCBwb3MgKyBiLnNpemUpO1xuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIHN0YXJ0IC0gTWF0aC5taW4oZW5kQSwgZW5kQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gZW5kQSArIGFkanVzdCAtIHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQSA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYi5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihiLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRCID0gc3RhcnQgKyAoZW5kQiAtIGVuZEEpO1xuICAgICAgICBlbmRBID0gc3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEIgPCBzdGFydCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYS5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihhLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRBID0gc3RhcnQgKyAoZW5kQSAtIGVuZEIpO1xuICAgICAgICBlbmRCID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmRBLCBlbmRCIH07XG59XG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoc3RyKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggIT0gMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhID0gc3RyLmNoYXJDb2RlQXQoMCksIGIgPSBzdHIuY2hhckNvZGVBdCgxKTtcbiAgICByZXR1cm4gYSA+PSAweERDMDAgJiYgYSA8PSAweERGRkYgJiYgYiA+PSAweEQ4MDAgJiYgYiA8PSAweERCRkY7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19wYXJzZUZyb21DbGlwYm9hcmQgPSBwYXJzZUZyb21DbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fZW5kQ29tcG9zaXRpb24gPSBlbmRDb21wb3NpdGlvbjtcbi8qKlxuQW4gZWRpdG9yIHZpZXcgbWFuYWdlcyB0aGUgRE9NIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgYW5cbmVkaXRhYmxlIGRvY3VtZW50LiBJdHMgc3RhdGUgYW5kIGJlaGF2aW9yIGFyZSBkZXRlcm1pbmVkIGJ5IGl0c1xuW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcykuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdmlldy4gYHBsYWNlYCBtYXkgYmUgYSBET00gbm9kZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkXG4gICAgYmUgYXBwZW5kZWQgdG8sIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHBsYWNlIGl0IGludG8gdGhlIGRvY3VtZW50LFxuICAgIG9yIGFuIG9iamVjdCB3aG9zZSBgbW91bnRgIHByb3BlcnR5IGhvbGRzIHRoZSBub2RlIHRvIHVzZSBhcyB0aGVcbiAgICBkb2N1bWVudCBjb250YWluZXIuIElmIGl0IGlzIGBudWxsYCwgdGhlIGVkaXRvciB3aWxsIG5vdCBiZVxuICAgIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlLCBwcm9wcykge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXRTdGF0ZTtcbiAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpblZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhIGhhY2sgbm9kZSBpcyBuZWVkZWQgaW4gRmlyZWZveCB0byBwcmV2ZW50IHRoZVxuICAgICAgICBbc3BhY2UgaXMgZWF0ZW4gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvNjUxKVxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZWRpdG9yIGNvbnRlbnQgaXMgYmVpbmcgZHJhZ2dlZCwgdGhpcyBvYmplY3QgY29udGFpbnNcbiAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyYWdnZWQgc2xpY2UgYW5kIHdoZXRoZXIgaXQgaXMgYmVpbmdcbiAgICAgICAgY29waWVkIG9yIG1vdmVkLiBBdCBhbnkgb3RoZXIgdGltZSwgaXQgaXMgbnVsbC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tID0gKHBsYWNlICYmIHBsYWNlLm1vdW50KSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAocGxhY2UpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZClcbiAgICAgICAgICAgICAgICBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGxhY2UgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHBsYWNlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlLm1vdW50KVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyh0aGlzLnN0YXRlLmRvYywgY29tcHV0ZURvY0RlY28odGhpcyksIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMsIChmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSA9PiByZWFkRE9NQ2hhbmdlKHRoaXMsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpbml0SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSG9sZHMgYHRydWVgIHdoZW4gYVxuICAgIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHMpXG4gICAgaXMgYWN0aXZlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXQuY29tcG9zaW5nOyB9XG4gICAgLyoqXG4gICAgVGhlIHZpZXcncyBjdXJyZW50IFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpLlxuICAgICovXG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcHMuc3RhdGUgIT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSBwcmV2W25hbWVdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3J3MgcHJvcHMuIFdpbGwgaW1tZWRpYXRlbHkgY2F1c2UgYW4gdXBkYXRlIHRvXG4gICAgdGhlIERPTS5cbiAgICAqL1xuICAgIHVwZGF0ZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cylcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAocHJvcHMucGx1Z2lucykge1xuICAgICAgICAgICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIocHJvcHMuc3RhdGUsIHByZXZQcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4gICAgZ2l2ZW4gYXMgYXJndW1lbnQuIEVxdWl2YWxlbnQgdG8gYHZpZXcudXBkYXRlKE9iamVjdC5hc3NpZ24oe30sXG4gICAgdmlldy5wcm9wcywgcHJvcHMpKWAuXG4gICAgKi9cbiAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX3Byb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuICAgICAgICB1cGRhdGVkLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgdGhpcy51cGRhdGUodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgZWRpdG9yJ3MgYHN0YXRlYCBwcm9wLCB3aXRob3V0IHRvdWNoaW5nIGFueSBvZiB0aGVcbiAgICBvdGhlciBwcm9wcy5cbiAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgdGhpcy5fcHJvcHMpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGUsIHJlZHJhdyA9IGZhbHNlLCB1cGRhdGVTZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gV2hlbiBzdG9yZWQgbWFya3MgYXJlIGFkZGVkLCBzdG9wIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGRpc3BsYXllZC5cbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGxldCBwbHVnaW5zQ2hhbmdlZCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLm5vZGVWaWV3cyAhPSBwcmV2UHJvcHMubm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVWaWV3cyhub2RlVmlld3MsIHRoaXMubm9kZVZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHByZXZQcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSB7XG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsZXQgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgICAgbGV0IHNjcm9sbCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpID8gXCJyZXNldFwiXG4gICAgICAgICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gICAgICAgIGxldCB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIGxldCBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuICAgICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGFuIGlzc3VlIGluIENocm9tZSwgSUUsIGFuZCBFZGdlIHdoZXJlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgRE9NIGFyb3VuZCBhbiBhY3RpdmUgc2VsZWN0aW9uIHB1dHMgaXQgaW50byBhIGJyb2tlblxuICAgICAgICAgICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHJlcG9ydGVkIGJ5IHRoZSBTZWxlY3Rpb24gb2JqZWN0ICgjNzEwLCAjOTczLFxuICAgICAgICAgICAgLy8gIzEwMTEsICMxMDEzLCAjMTAzNSkuXG4gICAgICAgICAgICBsZXQgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBzdGFydHMgbWlzcmVwb3J0aW5nIHRoZSBzZWxlY3Rpb24sIHNvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFja3MgdGhhdCBhbmQgZm9yY2VzIGEgc2VsZWN0aW9uIHJlc2V0IHdoZW4gb3VyIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmNvbXBvc2l0aW9uTm9kZSA9IGZpbmRDb21wb3NpdGlvbk5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3LnVwZGF0ZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNocm9tZUtsdWRnZSAmJiAoIXRoaXMudHJhY2tXcml0ZXMgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMudHJhY2tXcml0ZXMpKSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTZWxVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZm9yIGFuIGlzc3VlIHdoZXJlIGFuIHVwZGF0ZSBhcnJpdmluZyByaWdodCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBhIERPTSBzZWxlY3Rpb24gY2hhbmdlIGFuZCB0aGUgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCBmb3IgaXRcbiAgICAgICAgICAgIC8vIGNhbiBjYXVzZSBhIHNwdXJpb3VzIERPTSBzZWxlY3Rpb24gdXBkYXRlLCBkaXNydXB0aW5nIG1vdXNlXG4gICAgICAgICAgICAvLyBkcmFnIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChmb3JjZVNlbFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICEodGhpcy5pbnB1dC5tb3VzZURvd24gJiYgdGhpcy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9ySW5SaWdodFBsYWNlKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmNOb2RlU2VsZWN0aW9uKHRoaXMsIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKHByZXYpO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuZHJhZ2dpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlKSAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRHJhZ2dlZE5vZGUodGhpcy5kcmFnZ2luZywgcHJldik7XG4gICAgICAgIGlmIChzY3JvbGwgPT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2Nyb2xsVG9TZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBzdGFydERPTSA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGU7XG4gICAgICAgIGlmICghc3RhcnRET00gfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHN0YXJ0RE9NLm5vZGVUeXBlID09IDEgPyBzdGFydERPTSA6IHN0YXJ0RE9NLnBhcmVudE5vZGUpKSA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc29tZVByb3AoXCJoYW5kbGVTY3JvbGxUb1NlbGVjdGlvblwiLCBmID0+IGYodGhpcykpKSA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZG9jVmlldy5kb21BZnRlclBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5mcm9tKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGhpcy5jb29yZHNBdFBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5oZWFkLCAxKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lQbHVnaW5WaWV3cygpIHtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIHdoaWxlICh2aWV3ID0gdGhpcy5wbHVnaW5WaWV3cy5wb3AoKSlcbiAgICAgICAgICAgIGlmICh2aWV3LmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHVwZGF0ZVBsdWdpblZpZXdzKHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAoIXByZXZTdGF0ZSB8fCBwcmV2U3RhdGUucGx1Z2lucyAhPSB0aGlzLnN0YXRlLnBsdWdpbnMgfHwgdGhpcy5kaXJlY3RQbHVnaW5zICE9IHRoaXMucHJldkRpcmVjdFBsdWdpbnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSB0aGlzLmRpcmVjdFBsdWdpbnM7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnN0YXRlLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5WaWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW5WaWV3ID0gdGhpcy5wbHVnaW5WaWV3c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpblZpZXcudXBkYXRlKHRoaXMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRHJhZ2dlZE5vZGUoZHJhZ2dpbmcsIHByZXYpIHtcbiAgICAgICAgbGV0IHNlbCA9IGRyYWdnaW5nLm5vZGUsIGZvdW5kID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRvYy5ub2RlQXQoc2VsLmZyb20pID09IHNlbC5ub2RlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHNlbC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdmVkUG9zID0gc2VsLmZyb20gKyAodGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gcHJldi5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IG1vdmVkUG9zID4gMCAmJiB0aGlzLnN0YXRlLmRvYy5ub2RlQXQobW92ZWRQb3MpO1xuICAgICAgICAgICAgaWYgKG1vdmVkID09IHNlbC5ub2RlKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gbW92ZWRQb3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG5ldyBEcmFnZ2luZyhkcmFnZ2luZy5zbGljZSwgZHJhZ2dpbmcubW92ZSwgZm91bmQgPCAwID8gdW5kZWZpbmVkIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodGhpcy5zdGF0ZS5kb2MsIGZvdW5kKSk7XG4gICAgfVxuICAgIHNvbWVQcm9wKHByb3BOYW1lLCBmKSB7XG4gICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBJRSBub3QgaGFuZGxpbmcgZm9jdXMgY29ycmVjdGx5IGlmIHJlc2l6ZSBoYW5kbGVzIGFyZSBzaG93bi5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHJlc2l6ZSBoYW5kbGVzLCBhY3RpdmVFbGVtZW50XG4gICAgICAgIC8vIHdpbGwgYmUgdGhhdCBlbGVtZW50IGluc3RlYWQgb2YgdGhpcy5kb20uXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgLy8gSWYgYWN0aXZlRWxlbWVudCBpcyB3aXRoaW4gdGhpcy5kb20sIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGNvbnRlbnRlZGl0YWJsZWAgdG8gZmFsc2UgaW4gYmV0d2VlbiwgdHJlYXQgaXQgYXMgZm9jdXNlZC5cbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgJiYgdGhpcy5kb20gIT0gbm9kZSAmJiB0aGlzLmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgRm9jdXMgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpXG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pO1xuICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRvY3VtZW50IHJvb3QgaW4gd2hpY2ggdGhlIGVkaXRvciBleGlzdHMuIFRoaXMgd2lsbFxuICAgIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4gICAgRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJfQ29tcG9uZW50cy9TaGFkb3dfRE9NKVxuICAgIHJvb3QgaWYgdGhlIGVkaXRvciBpcyBpbnNpZGUgb25lLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yb290O1xuICAgICAgICBpZiAoY2FjaGVkID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSB0aGlzLmRvbS5wYXJlbnROb2RlOyBzZWFyY2g7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5ub2RlVHlwZSA9PSA5IHx8IChzZWFyY2gubm9kZVR5cGUgPT0gMTEgJiYgc2VhcmNoLmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWFyY2gpLmdldFNlbGVjdGlvbiA9ICgpID0+IHNlYXJjaC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IHNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gYW4gZXhpc3RpbmcgZWRpdG9yIHZpZXcgaXMgbW92ZWQgdG8gYSBuZXcgZG9jdW1lbnQgb3JcbiAgICBzaGFkb3cgdHJlZSwgY2FsbCB0aGlzIHRvIG1ha2UgaXQgcmVjb21wdXRlIGl0cyByb290LlxuICAgICovXG4gICAgdXBkYXRlUm9vdCgpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgcGFpciBvZiB2aWV3cG9ydCBjb29yZGluYXRlcywgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuICAgIGNvb3JkaW5hdGVzIGFyZW4ndCBpbnNpZGUgb2YgdGhlIGVkaXRvci4gV2hlbiBhbiBvYmplY3QgaXNcbiAgICByZXR1cm5lZCwgaXRzIGBwb3NgIHByb3BlcnR5IGlzIHRoZSBwb3NpdGlvbiBuZWFyZXN0IHRvIHRoZVxuICAgIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICBpbm5lciBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIGZhbGxzIGluc2lkZSBvZiwgb3IgLTEgaWYgaXQgaXMgYXRcbiAgICB0aGUgdG9wIGxldmVsLCBub3QgaW4gYW55IG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBsZWZ0YCBhbmQgYHJpZ2h0YCB3aWxsIGJlIHRoZSBzYW1lIG51bWJlciwgYXMgdGhpcyByZXR1cm5zIGFcbiAgICBmbGF0IGN1cnNvci1pc2ggcmVjdGFuZ2xlLiBJZiB0aGUgcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gdGhpbmdzXG4gICAgdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnRcbiAgICBpcyB1c2VkLiBXaGVuIDwgMCwgdGhlIGVsZW1lbnQgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyB1c2VkLFxuICAgIG90aGVyd2lzZSB0aGUgZWxlbWVudCBhZnRlci5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbiAgICBwb3NzaWJsZSB0byB0aGUgY29udGVudCBiZWZvcmUgdGhlIHBvc2l0aW9uLiBXaGVuIHBvc2l0aXZlLFxuICAgIHByZWZlciBwb3NpdGlvbnMgY2xvc2UgdG8gdGhlIGNvbnRlbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLiBXaGVuXG4gICAgemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbiAgICBcbiAgICBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuICAgIG9ubHkgaW5zcGVjdCBpdCAoYW5kIGV2ZW4gdGhhdCBpcyB1c3VhbGx5IG5vdCBuZWNlc3NhcnkpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlIGFmdGVyIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLiBNYXkgcmV0dXJuIGBudWxsYCB3aGVuIHRoZSBwb3NpdGlvbiBkb2Vzbid0IHBvaW50XG4gICAgaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuICAgIFxuICAgIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4gICAgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgb24gdGhhdCBET00gbm9kZS4gRG8gKipub3QqKiBtdXRhdGUgdGhlXG4gICAgZWRpdG9yIERPTSBkaXJlY3RseSwgb3IgYWRkIHN0eWxpbmcgdGhpcyB3YXksIHNpbmNlIHRoYXQgd2lsbCBiZVxuICAgIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBub2RlRE9NKHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZG9jVmlldy5kZXNjQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGRlc2MgPyBkZXNjLm5vZGVET00gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4gICAgcG9zaXRpb24uIChXaGVuZXZlciBwb3NzaWJsZSwgaXQgaXMgcHJlZmVyYWJsZSB0byBpbnNwZWN0IHRoZVxuICAgIGRvY3VtZW50IHN0cnVjdHVyZSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gcG9raW5nIGFyb3VuZCBpbiB0aGVcbiAgICBET00sIGJ1dCBzb21ldGltZXPigJRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuICAgIHRhcmdldOKAlHlvdSBkb24ndCBoYXZlIGEgY2hvaWNlLilcbiAgICBcbiAgICBUaGUgYGJpYXNgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBpbmZsdWVuY2Ugd2hpY2ggc2lkZSBvZiBhIERPTVxuICAgIG5vZGUgdG8gdXNlIHdoZW4gdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCwgYmlhcyA9IC0xKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRPTSBwb3NpdGlvbiBub3QgaW5zaWRlIHRoZSBlZGl0b3JcIik7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrIHdoZW5cbiAgICBtb3ZpbmcgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFdoZW4sIGZvciBleGFtcGxlLCBnaXZlbiBgXCJsZWZ0XCJgLFxuICAgIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3JcbiAgICBwb3NpdGlvbiB3b3VsZCBsZWF2ZSB0aGF0IHBvc2l0aW9uJ3MgcGFyZW50IHRleHRibG9jay4gV2lsbCBhcHBseVxuICAgIHRvIHRoZSB2aWV3J3MgY3VycmVudCBzdGF0ZSBieSBkZWZhdWx0LCBidXQgaXQgaXMgcG9zc2libGUgdG9cbiAgICBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICovXG4gICAgZW5kT2ZUZXh0YmxvY2soZGlyLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZW5kT2ZUZXh0YmxvY2sodGhpcywgc3RhdGUgfHwgdGhpcy5zdGF0ZSwgZGlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBIVE1MIHN0cmluZy4gVGhlXG4gICAgYGV2ZW50YCwgaWYgZ2l2ZW4sIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgIFtgaGFuZGxlUGFzdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVQYXN0ZSkgaG9vay5cbiAgICAqL1xuICAgIHBhc3RlSFRNTChodG1sLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCBcIlwiLCBodG1sLCBmYWxzZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIHBsYWluLXRleHQgaW5wdXQuXG4gICAgKi9cbiAgICBwYXN0ZVRleHQodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgdGV4dCwgbnVsbCwgdHJ1ZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGdpdmVuIHNsaWNlIGFzIGl0IHdvdWxkIGJlIGlmIGl0IHdhcyBjb3BpZWQgZnJvbVxuICAgIHRoaXMgZWRpdG9yLiBSZXR1cm5zIGEgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyBhXG4gICAgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNsaWNlIGFzIGl0cyBjaGlsZHJlbiwgYSB0ZXh0dWFsXG4gICAgcmVwcmVzZW50YXRpb24sIGFuZCB0aGUgdHJhbnNmb3JtZWQgc2xpY2UgKHdoaWNoIGNhbiBiZVxuICAgIGRpZmZlcmVudCBmcm9tIHRoZSBnaXZlbiBpbnB1dCBkdWUgdG8gaG9va3MgbGlrZVxuICAgIFtgdHJhbnNmb3JtQ29waWVkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMudHJhbnNmb3JtQ29waWVkKSkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGb3JDbGlwYm9hcmQoc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh0aGlzLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIGVkaXRvciBmcm9tIHRoZSBET00gYW5kIGRlc3Ryb3lzIGFsbCBbbm9kZVxuICAgIHZpZXdzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5Ob2RlVmlldykuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9jVmlldylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVzdHJveUlucHV0KHRoaXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlKHRoaXMuc3RhdGUuZG9jLCBbXSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBudWxsO1xuICAgICAgICBjbGVhclJldXNlZFJhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgdHJ1ZSB3aGVuIHRoZSB2aWV3IGhhcyBiZWVuXG4gICAgW2Rlc3Ryb3llZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kZXN0cm95KSAoYW5kIHRodXMgc2hvdWxkIG5vdCBiZVxuICAgIHVzZWQgYW55bW9yZSkuXG4gICAgKi9cbiAgICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcgPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBmb3IgdGVzdGluZy5cbiAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb21TZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzZWwpXG4gICAgICAgICAgICByZXR1cm4geyBmb2N1c05vZGU6IG51bGwsIGZvY3VzT2Zmc2V0OiAwLCBhbmNob3JOb2RlOiBudWxsLCBhbmNob3JPZmZzZXQ6IDAgfTtcbiAgICAgICAgcmV0dXJuIHNhZmFyaSAmJiB0aGlzLnJvb3Qubm9kZVR5cGUgPT09IDExICYmXG4gICAgICAgICAgICBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbSAmJiBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh0aGlzLCBzZWwpIHx8IHNlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21TZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxufVxuRWRpdG9yVmlldy5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAodHIpIHtcbiAgICBsZXQgZGlzcGF0Y2hUcmFuc2FjdGlvbiA9IHRoaXMuX3Byb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb247XG4gICAgaWYgKGRpc3BhdGNoVHJhbnNhY3Rpb24pXG4gICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB0cik7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUuYXBwbHkodHIpKTtcbn07XG5mdW5jdGlvbiBjb21wdXRlRG9jRGVjbyh2aWV3KSB7XG4gICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBhdHRycy5jbGFzcyA9IFwiUHJvc2VNaXJyb3JcIjtcbiAgICBhdHRycy5jb250ZW50ZWRpdGFibGUgPSBTdHJpbmcodmlldy5lZGl0YWJsZSk7XG4gICAgdmlldy5zb21lUHJvcChcImF0dHJpYnV0ZXNcIiwgdmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUodmlldy5zdGF0ZSk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGZvciAobGV0IGF0dHIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLmNsYXNzICs9IFwiIFwiICsgdmFsdWVbYXR0cl07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ciA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnN0eWxlID0gKGF0dHJzLnN0eWxlID8gYXR0cnMuc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsdWVbYXR0cl07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWF0dHJzW2F0dHJdICYmIGF0dHIgIT0gXCJjb250ZW50ZWRpdGFibGVcIiAmJiBhdHRyICE9IFwibm9kZU5hbWVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNbYXR0cl0gPSBTdHJpbmcodmFsdWVbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYXR0cnMudHJhbnNsYXRlKVxuICAgICAgICBhdHRycy50cmFuc2xhdGUgPSBcIm5vXCI7XG4gICAgcmV0dXJuIFtEZWNvcmF0aW9uLm5vZGUoMCwgdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLCBhdHRycyldO1xufVxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgaWYgKHZpZXcubWFya0N1cnNvcikge1xuICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImFsdFwiLCBcIlwiKTtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0geyBkb20sIGRlY286IERlY29yYXRpb24ud2lkZ2V0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20sIGRvbSwgeyByYXc6IHRydWUsIG1hcmtzOiB2aWV3Lm1hcmtDdXJzb3IgfSkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RWRpdGFibGUodmlldykge1xuICAgIHJldHVybiAhdmlldy5zb21lUHJvcChcImVkaXRhYmxlXCIsIHZhbHVlID0+IHZhbHVlKHZpZXcuc3RhdGUpID09PSBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChzZWwxLCBzZWwyKSB7XG4gICAgbGV0IGRlcHRoID0gTWF0aC5taW4oc2VsMS4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDEuaGVhZCksIHNlbDIuJGFuY2hvci5zaGFyZWREZXB0aChzZWwyLmhlYWQpKTtcbiAgICByZXR1cm4gc2VsMS4kYW5jaG9yLnN0YXJ0KGRlcHRoKSAhPSBzZWwyLiRhbmNob3Iuc3RhcnQoZGVwdGgpO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlVmlld3Modmlldykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIGFkZChvYmopIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHByb3ApKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcIm5vZGVWaWV3c1wiLCBhZGQpO1xuICAgIHZpZXcuc29tZVByb3AoXCJtYXJrVmlld3NcIiwgYWRkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hhbmdlZE5vZGVWaWV3cyhhLCBiKSB7XG4gICAgbGV0IG5BID0gMCwgbkIgPSAwO1xuICAgIGZvciAobGV0IHByb3AgaW4gYSkge1xuICAgICAgICBpZiAoYVtwcm9wXSAhPSBiW3Byb3BdKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIG5BKys7XG4gICAgfVxuICAgIGZvciAobGV0IF8gaW4gYilcbiAgICAgICAgbkIrKztcbiAgICByZXR1cm4gbkEgIT0gbkI7XG59XG5mdW5jdGlvbiBjaGVja1N0YXRlQ29tcG9uZW50KHBsdWdpbikge1xuICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSB8fCBwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiB8fCBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQbHVnaW5zIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgdmlldyBtdXN0IG5vdCBoYXZlIGEgc3RhdGUgY29tcG9uZW50XCIpO1xufVxuXG5leHBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0LCBFZGl0b3JWaWV3LCBfX2VuZENvbXBvc2l0aW9uLCBfX3BhcnNlRnJvbUNsaXBib2FyZCB9O1xuIl0sIm5hbWVzIjpbIlRleHRTZWxlY3Rpb24iLCJOb2RlU2VsZWN0aW9uIiwiQWxsU2VsZWN0aW9uIiwiU2VsZWN0aW9uIiwiRE9NU2VyaWFsaXplciIsIkZyYWdtZW50IiwiTWFyayIsIlNsaWNlIiwiRE9NUGFyc2VyIiwiZHJvcFBvaW50IiwiZG9tSW5kZXgiLCJub2RlIiwiaW5kZXgiLCJwcmV2aW91c1NpYmxpbmciLCJwYXJlbnROb2RlIiwicGFyZW50IiwiYXNzaWduZWRTbG90Iiwibm9kZVR5cGUiLCJob3N0IiwicmV1c2VkUmFuZ2UiLCJ0ZXh0UmFuZ2UiLCJmcm9tIiwidG8iLCJyYW5nZSIsImRvY3VtZW50IiwiY3JlYXRlUmFuZ2UiLCJzZXRFbmQiLCJub2RlVmFsdWUiLCJsZW5ndGgiLCJzZXRTdGFydCIsImNsZWFyUmV1c2VkUmFuZ2UiLCJpc0VxdWl2YWxlbnRQb3NpdGlvbiIsIm9mZiIsInRhcmdldE5vZGUiLCJ0YXJnZXRPZmYiLCJzY2FuRm9yIiwiYXRvbUVsZW1lbnRzIiwiZGlyIiwiX2EiLCJub2RlU2l6ZSIsImhhc0Jsb2NrRGVzYyIsInRlc3QiLCJub2RlTmFtZSIsImNvbnRlbnRFZGl0YWJsZSIsImNoaWxkIiwiY2hpbGROb2RlcyIsInBtVmlld0Rlc2MiLCJpZ25vcmVGb3JTZWxlY3Rpb24iLCJ0ZXh0Tm9kZUJlZm9yZSQxIiwib2Zmc2V0IiwidGV4dE5vZGVBZnRlciQxIiwiaXNPbkVkZ2UiLCJhdFN0YXJ0IiwiYXRFbmQiLCJkb20iLCJkZXNjIiwiY3VyIiwiaXNCbG9jayIsImNvbnRlbnRET00iLCJzZWxlY3Rpb25Db2xsYXBzZWQiLCJkb21TZWwiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJrZXlFdmVudCIsImtleUNvZGUiLCJrZXkiLCJldmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiY29kZSIsImRlZXBBY3RpdmVFbGVtZW50IiwiZG9jIiwiZWx0IiwiYWN0aXZlRWxlbWVudCIsInNoYWRvd1Jvb3QiLCJjYXJldEZyb21Qb2ludCIsIngiLCJ5IiwiY2FyZXRQb3NpdGlvbkZyb21Qb2ludCIsInBvcyIsIm9mZnNldE5vZGUiLCJNYXRoIiwibWluIiwiXyIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwibmF2IiwibmF2aWdhdG9yIiwiYWdlbnQiLCJ1c2VyQWdlbnQiLCJpZV9lZGdlIiwiZXhlYyIsImllX3VwdG8xMCIsImllXzExdXAiLCJpZSIsImllX3ZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJnZWNrbyIsIl9jaHJvbWUiLCJjaHJvbWUiLCJjaHJvbWVfdmVyc2lvbiIsInNhZmFyaSIsInZlbmRvciIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwibWFjIiwicGxhdGZvcm0iLCJ3aW5kb3dzIiwiYW5kcm9pZCIsIndlYmtpdCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwid2Via2l0X3ZlcnNpb24iLCJ3aW5kb3dSZWN0IiwidnAiLCJkZWZhdWx0VmlldyIsInZpc3VhbFZpZXdwb3J0IiwibGVmdCIsInJpZ2h0Iiwid2lkdGgiLCJ0b3AiLCJib3R0b20iLCJoZWlnaHQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImdldFNpZGUiLCJ2YWx1ZSIsInNpZGUiLCJjbGllbnRSZWN0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjYWxlWCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsUmVjdEludG9WaWV3IiwidmlldyIsInN0YXJ0RE9NIiwic2Nyb2xsVGhyZXNob2xkIiwic29tZVByb3AiLCJzY3JvbGxNYXJnaW4iLCJvd25lckRvY3VtZW50IiwiYXRUb3AiLCJib2R5IiwiYm91bmRpbmciLCJtb3ZlWCIsIm1vdmVZIiwic2Nyb2xsQnkiLCJzdGFydFgiLCJzY3JvbGxMZWZ0Iiwic3RhcnRZIiwic2Nyb2xsVG9wIiwiZFgiLCJkWSIsImdldENvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsIm9mZnNldFBhcmVudCIsInN0b3JlU2Nyb2xsUG9zIiwibWF4IiwicmVmRE9NIiwicmVmVG9wIiwiaW5uZXJIZWlnaHQiLCJyb290IiwiZWxlbWVudEZyb21Qb2ludCIsImNvbnRhaW5zIiwibG9jYWxSZWN0Iiwic3RhY2siLCJzY3JvbGxTdGFjayIsInB1c2giLCJyZXNldFNjcm9sbFBvcyIsIm5ld1JlZlRvcCIsInJlc3RvcmVTY3JvbGxTdGFjayIsImRUb3AiLCJpIiwicHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImZvY3VzUHJldmVudFNjcm9sbCIsInNldEFjdGl2ZSIsImZvY3VzIiwic3RvcmVkIiwicHJldmVudFNjcm9sbCIsInVuZGVmaW5lZCIsImZpbmRPZmZzZXRJbk5vZGUiLCJjb29yZHMiLCJjbG9zZXN0IiwiZHhDbG9zZXN0IiwiY29vcmRzQ2xvc2VzdCIsInJvd0JvdCIsInJvd1RvcCIsImZpcnN0QmVsb3ciLCJjb29yZHNCZWxvdyIsImZpcnN0Q2hpbGQiLCJjaGlsZEluZGV4IiwibmV4dFNpYmxpbmciLCJyZWN0cyIsImdldENsaWVudFJlY3RzIiwiZHgiLCJmaW5kT2Zmc2V0SW5UZXh0IiwibGVuIiwicmVzdWx0Iiwic2luZ2xlUmVjdCIsImluUmVjdCIsImRldGFjaCIsInRhcmdldEtsdWRnZSIsInBvc0Zyb21FbGVtZW50IiwiYmlhcyIsImRvY1ZpZXciLCJwb3NGcm9tRE9NIiwicG9zRnJvbUNhcmV0Iiwib3V0c2lkZUJsb2NrIiwic2F3QmxvY2siLCJuZWFyZXN0RGVzYyIsInBvc0JlZm9yZSIsInBvc0FmdGVyIiwiaXNUZXh0IiwiYmVmb3JlIiwiZWxlbWVudCIsImJveCIsInN0YXJ0SSIsImZsb29yIiwiaiIsInBvc0F0Q29vcmRzIiwiY2FyZXQiLCJwIiwiZHJhZ2dhYmxlIiwibmV4dCIsInByZXYiLCJsYXN0Q2hpbGQiLCJzdGF0ZSIsImNvbnRlbnQiLCJzaXplIiwiaW5zaWRlIiwicG9zQXRTdGFydCIsImJvcmRlciIsIm5vblplcm8iLCJ0YXJnZXQiLCJmaXJzdCIsIkFycmF5IiwicHJvdG90eXBlIiwiZmluZCIsImNhbGwiLCJCSURJIiwiY29vcmRzQXRQb3MiLCJhdG9tIiwiZG9tRnJvbVBvcyIsInN1cHBvcnRFbXB0eVJhbmdlIiwicmVjdEJlZm9yZSIsInJlY3RBZnRlciIsImZsYXR0ZW5WIiwidGFrZVNpZGUiLCIkZG9tIiwicmVzb2x2ZSIsImlubGluZUNvbnRlbnQiLCJmbGF0dGVuSCIsImFmdGVyIiwiaWdub3JlRm9yQ29vcmRzIiwid2l0aEZsdXNoZWRTdGF0ZSIsImYiLCJ2aWV3U3RhdGUiLCJhY3RpdmUiLCJ1cGRhdGVTdGF0ZSIsImVuZE9mVGV4dGJsb2NrVmVydGljYWwiLCJzZWwiLCJzZWxlY3Rpb24iLCIkcG9zIiwiJGZyb20iLCIkdG8iLCJuZWFyZXN0IiwiYm94ZXMiLCJtYXliZVJUTCIsImVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCIsIiRoZWFkIiwiaXNUZXh0YmxvY2siLCJwYXJlbnRPZmZzZXQiLCJkb21TZWxlY3Rpb24iLCJzdGFydCIsImVuZCIsInRleHRDb250ZW50IiwibW9kaWZ5Iiwib2xkTm9kZSIsIm9sZE9mZiIsImRvbVNlbGVjdGlvblJhbmdlIiwib2xkQmlkaUxldmVsIiwiY2FyZXRCaWRpTGV2ZWwiLCJwYXJlbnRET00iLCJkZXB0aCIsImRvbUFmdGVyUG9zIiwibmV3Tm9kZSIsIm5ld09mZiIsImNvbGxhcHNlIiwiZXh0ZW5kIiwiY2FjaGVkU3RhdGUiLCJjYWNoZWREaXIiLCJjYWNoZWRSZXN1bHQiLCJlbmRPZlRleHRibG9jayIsIk5PVF9ESVJUWSIsIkNISUxEX0RJUlRZIiwiQ09OVEVOVF9ESVJUWSIsIk5PREVfRElSVFkiLCJWaWV3RGVzYyIsImNvbnN0cnVjdG9yIiwiY2hpbGRyZW4iLCJkaXJ0eSIsIm1hdGNoZXNXaWRnZXQiLCJ3aWRnZXQiLCJtYXRjaGVzTWFyayIsIm1hcmsiLCJtYXRjaGVzTm9kZSIsIm91dGVyRGVjbyIsImlubmVyRGVjbyIsIm1hdGNoZXNIYWNrIiwicGFyc2VSdWxlIiwic3RvcEV2ZW50IiwiZGVzdHJveSIsInBvc0JlZm9yZUNoaWxkIiwicG9zQXRFbmQiLCJsb2NhbFBvc0Zyb21ET00iLCJkb21CZWZvcmUiLCJkb21BZnRlciIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwic2VhcmNoIiwib25seU5vZGVzIiwiZ2V0RGVzYyIsIm5vZGVET00iLCJzY2FuIiwiZGVzY0F0IiwiaW5uZXIiLCJjdXJQb3MiLCJUcmFpbGluZ0hhY2tWaWV3RGVzYyIsIldpZGdldFZpZXdEZXNjIiwiZW50ZXIiLCJkb21BdG9tIiwicGFyc2VSYW5nZSIsImJhc2UiLCJmcm9tT2Zmc2V0IiwidG9PZmZzZXQiLCJjaGlsZEJhc2UiLCJlbXB0eUNoaWxkQXQiLCJSYW5nZUVycm9yIiwic2V0U2VsZWN0aW9uIiwiYW5jaG9yIiwiaGVhZCIsImZvcmNlIiwiYW5jaG9yRE9NIiwiaGVhZERPTSIsImdldFNlbGVjdGlvbiIsInNlbFJhbmdlIiwiYnJLbHVkZ2UiLCJkb21TZWxFeHRlbmRlZCIsInRtcCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwiaWdub3JlTXV0YXRpb24iLCJtdXRhdGlvbiIsInR5cGUiLCJjb250ZW50TG9zdCIsIm1hcmtEaXJ0eSIsInN0YXJ0SW5zaWRlIiwiZW5kSW5zaWRlIiwibWFya1BhcmVudHNEaXJ0eSIsImxldmVsIiwidGV4dCIsInNlbGYiLCJ0b0RPTSIsInNwZWMiLCJyYXciLCJ3cmFwIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwiY2xhc3NMaXN0IiwiYWRkIiwiZXEiLCJpZ25vcmUiLCJzdG9wIiwiaWdub3JlU2VsZWN0aW9uIiwicmVsYXhlZFNpZGUiLCJDb21wb3NpdGlvblZpZXdEZXNjIiwidGV4dERPTSIsIm11dCIsIm9sZFZhbHVlIiwiTWFya1ZpZXdEZXNjIiwiY3JlYXRlIiwiaW5saW5lIiwiY3VzdG9tIiwibm9kZVZpZXdzIiwibmFtZSIsInJlbmRlclNwZWMiLCJhdHRycyIsInJlcGFyc2VJblZpZXciLCJjb250ZW50RWxlbWVudCIsInNsaWNlIiwiY29weSIsIm5vZGVzIiwicmVwbGFjZU5vZGVzIiwiTm9kZVZpZXdEZXNjIiwiZGVzY09iaiIsImNyZWF0ZVRleHROb2RlIiwiaGFzQXR0cmlidXRlIiwiYXBwbHlPdXRlckRlY28iLCJDdXN0b21Ob2RlVmlld0Rlc2MiLCJUZXh0Vmlld0Rlc2MiLCJydWxlIiwid2hpdGVzcGFjZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsImdldENvbnRlbnQiLCJlbXB0eSIsInNhbWVPdXRlckRlY28iLCJpc0xlYWYiLCJ1cGRhdGVDaGlsZHJlbiIsImNvbXBvc2l0aW9uIiwiY29tcG9zaW5nIiwibG9jYWxDb21wb3NpdGlvbkluZm8iLCJsb2NhbENvbXBvc2l0aW9uIiwiY29tcG9zaXRpb25JbkNoaWxkIiwidXBkYXRlciIsIlZpZXdUcmVlVXBkYXRlciIsIml0ZXJEZWNvIiwiaW5zaWRlTm9kZSIsIm1hcmtzIiwic3luY1RvTWFya3MiLCJjaGlsZENvdW50Iiwibm9uZSIsInBsYWNlV2lkZ2V0IiwiY29tcEluZGV4IiwiZmluZE5vZGVNYXRjaCIsImZpbmRJbmRleFdpdGhDaGlsZCIsInVwZGF0ZU5vZGVBdCIsInVwZGF0ZU5leHROb2RlIiwiYWRkTm9kZSIsImFkZFRleHRibG9ja0hhY2tzIiwiZGVzdHJveVJlc3QiLCJjaGFuZ2VkIiwicHJvdGVjdExvY2FsQ29tcG9zaXRpb24iLCJyZW5kZXJEZXNjcyIsImlvc0hhY2tzIiwidGV4dE5vZGUiLCJpbnB1dCIsImNvbXBvc2l0aW9uTm9kZSIsInRleHRQb3MiLCJmaW5kVGV4dEluRnJhZ21lbnQiLCJ0b3BOb2RlIiwicmVtb3ZlQ2hpbGQiLCJjb21wb3NpdGlvbk5vZGVzIiwidXBkYXRlIiwic2FtZU1hcmt1cCIsInVwZGF0ZUlubmVyIiwidXBkYXRlT3V0ZXJEZWNvIiwibmVlZHNXcmFwIiwib2xkRE9NIiwicGF0Y2hPdXRlckRlY28iLCJjb21wdXRlT3V0ZXJEZWNvIiwic2VsZWN0Tm9kZSIsImRlc2VsZWN0Tm9kZSIsInJlbW92ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImlzQXRvbSIsImRvY1ZpZXdEZXNjIiwic2tpcCIsInBtSXNEZWNvIiwiaW5QYXJlbnQiLCJ0cmFja1dyaXRlcyIsIm4iLCJjdXQiLCJtdWx0aVR5cGUiLCJkZXNjcyIsIndyaXR0ZW4iLCJjaGlsZERPTSIsInJtIiwiaW5zZXJ0QmVmb3JlIiwiT3V0ZXJEZWNvTGV2ZWwiLCJPYmplY3QiLCJub0RlY28iLCJ2YWwiLCJpc0lubGluZSIsImNsYXNzIiwib3V0ZXJET00iLCJwcmV2Q29tcHV0ZWQiLCJjdXJDb21wdXRlZCIsImN1ckRPTSIsImRlY28iLCJ0b0xvd2VyQ2FzZSIsInBhdGNoQXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsInByZXZMaXN0Iiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3VyTGlzdCIsImluZGV4T2YiLCJwcm9wIiwibSIsInJlbW92ZVByb3BlcnR5IiwiY3NzVGV4dCIsImEiLCJiIiwibG9jayIsInByZU1hdGNoIiwiZGVzdHJveUJldHdlZW4iLCJzcGxpY2UiLCJwYXJlbnRJbmRleCIsImtlZXAiLCJtYXhLZWVwIiwic3Bhbm5pbmciLCJwb3AiLCJmb3VuZCIsInNjYW5UbyIsImlzTG9ja2VkIiwibWFya0Rlc2MiLCJ0YXJnZXREZXNjIiwibWF0Y2hlcyIsImUiLCJtYXRjaGVkIiwiaGFzIiwiZG9tTm9kZSIsImdldCIsIm5leHRET00iLCJ1cGRhdGVkIiwibG9ja2VkIiwicmVjcmVhdGVXcmFwcGVyIiwid3JhcHBlciIsImNoIiwicmVxdWlyZXNHZWNrb0hhY2tOb2RlIiwiYWRkSGFja05vZGUiLCJjbGFzc05hbWUiLCJhbHQiLCJoYWNrIiwiZnJhZyIsInBhcmVudERlc2MiLCJjdXJEZXNjIiwiZGVzY0kiLCJmSSIsIk1hcCIsIm91dGVyIiwic2V0IiwicmV2ZXJzZSIsImNvbXBhcmVTaWRlIiwib25XaWRnZXQiLCJvbk5vZGUiLCJsb2NhbHMiLCJmb3JDaGlsZCIsImRlY29JbmRleCIsInJlc3ROb2RlIiwid2lkZ2V0cyIsInNvcnQiLCJjdXRBdCIsImQiLCJvbGRDU1MiLCJ3aW5kb3ciLCJsaXN0U3R5bGUiLCJjaGlsZFN0YXJ0Iiwic3RyIiwibGFzdEluZGV4T2YiLCJyZXBsYWNlbWVudCIsInNlbGVjdGlvbkZyb21ET00iLCJvcmlnaW4iLCJpbldpZGdldCIsIm5lYXJlc3REZXNjTm9kZSIsImlzU2VsZWN0YWJsZSIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiZW5kQ29udGFpbmVyIiwiZW5kT2Zmc2V0IiwiJGFuY2hvciIsInNlbGVjdGlvbkJldHdlZW4iLCJlZGl0b3JPd25zU2VsZWN0aW9uIiwiZWRpdGFibGUiLCJoYXNGb2N1cyIsImhhc1NlbGVjdGlvbiIsInNlbGVjdGlvblRvRE9NIiwic3luY05vZGVTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJhbGxvd0RlZmF1bHQiLCJjdXJTZWwiLCJkb21PYnNlcnZlciIsImN1cnJlbnRTZWxlY3Rpb24iLCJkZWxheWVkU2VsZWN0aW9uU3luYyIsInNldEN1clNlbGVjdGlvbiIsImRpc2Nvbm5lY3RTZWxlY3Rpb24iLCJjdXJzb3JXcmFwcGVyIiwic2VsZWN0Q3Vyc29yV3JhcHBlciIsInJlc2V0RWRpdGFibGVGcm9tIiwicmVzZXRFZGl0YWJsZVRvIiwiYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUiLCJ0ZW1wb3JhcmlseUVkaXRhYmxlTmVhciIsInJlc2V0RWRpdGFibGUiLCJ2aXNpYmxlIiwicmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSIsImNvbm5lY3RTZWxlY3Rpb24iLCJzZXRFZGl0YWJsZSIsIndhc0RyYWdnYWJsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoaWRlU2VsZWN0aW9uR3VhcmQiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsImltZyIsImRpc2FibGVkIiwibGFzdFNlbGVjdGVkVmlld0Rlc2MiLCJjbGVhck5vZGVTZWxlY3Rpb24iLCJiZXR3ZWVuIiwiaGFzRm9jdXNBbmRTZWxlY3Rpb24iLCJhbmNob3JJblJpZ2h0UGxhY2UiLCJtb3ZlU2VsZWN0aW9uQmxvY2siLCIkc2lkZSIsIiRzdGFydCIsImZpbmRGcm9tIiwiYXBwbHkiLCJkaXNwYXRjaCIsInRyIiwic2Nyb2xsSW50b1ZpZXciLCJzZWxlY3RIb3Jpem9udGFsbHkiLCJtb2RzIiwidGV4dE9mZnNldCIsIm5vZGVCZWZvcmUiLCJub2RlQWZ0ZXIiLCIkbmV3SGVhZCIsIm5vZGVQb3MiLCJub2RlTGVuIiwiaXNJZ25vcmFibGUiLCJza2lwSWdub3JlZE5vZGVzIiwic2tpcElnbm9yZWROb2Rlc0JlZm9yZSIsInNraXBJZ25vcmVkTm9kZXNBZnRlciIsIm1vdmVOb2RlIiwibW92ZU9mZnNldCIsImlzQmxvY2tOb2RlIiwic2V0U2VsRm9jdXMiLCJ0ZXh0Tm9kZUFmdGVyIiwidGV4dE5vZGVCZWZvcmUiLCJmaW5kRGlyZWN0aW9uIiwibWlkIiwiYWJzIiwiY29tcHV0ZWQiLCJkaXJlY3Rpb24iLCJzZWxlY3RWZXJ0aWNhbGx5IiwiYmV5b25kIiwibmVhciIsInN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlIiwic2FtZVBhcmVudCIsIm5leHROb2RlIiwiZGVsZXRlIiwic3dpdGNoRWRpdGFibGUiLCJzYWZhcmlEb3duQXJyb3dCdWciLCJnZXRNb2RzIiwiY3RybEtleSIsIm1ldGFLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsImNhcHR1cmVLZXlEb3duIiwic2VyaWFsaXplRm9yQ2xpcGJvYXJkIiwiY29udGV4dCIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJkZWZhdWx0QXR0cnMiLCJzZXJpYWxpemVyIiwiZnJvbVNjaGVtYSIsInNjaGVtYSIsImRldGFjaGVkRG9jIiwic2VyaWFsaXplRnJhZ21lbnQiLCJ3cmFwcGVycyIsIndyYXBNYXAiLCJKU09OIiwic3RyaW5naWZ5IiwidGV4dEJldHdlZW4iLCJwYXJzZUZyb21DbGlwYm9hcmQiLCJodG1sIiwicGxhaW5UZXh0IiwiJGNvbnRleHQiLCJpbkNvZGUiLCJhc1RleHQiLCJyZXBsYWNlIiwicGFyc2VkIiwiZm9yRWFjaCIsImJsb2NrIiwic2VyaWFsaXplTm9kZSIsInJlYWRIVE1MIiwicmVzdG9yZVJlcGxhY2VkU3BhY2VzIiwiY29udGV4dE5vZGUiLCJxdWVyeVNlbGVjdG9yIiwic2xpY2VEYXRhIiwiZ2V0QXR0cmlidXRlIiwicGFyc2VyIiwicGFyc2VTbGljZSIsInJ1bGVGcm9tTm9kZSIsImlubGluZVBhcmVudHMiLCJhZGRDb250ZXh0IiwiY2xvc2VTbGljZSIsIm1heE9wZW4iLCJub3JtYWxpemVTaWJsaW5ncyIsImlzb2xhdGluZyIsImZyYWdtZW50IiwibWF0Y2giLCJjb250ZW50TWF0Y2hBdCIsImxhc3RXcmFwIiwiZmluZFdyYXBwaW5nIiwiaW5MYXN0IiwiYWRkVG9TaWJsaW5nIiwiY2xvc2VSaWdodCIsIndyYXBwZWQiLCJ3aXRoV3JhcHBlcnMiLCJtYXRjaFR5cGUiLCJzaWJsaW5nIiwicmVwbGFjZUNoaWxkIiwiYXBwZW5kIiwiZmlsbCIsImZpbGxCZWZvcmUiLCJjbG9zZVJhbmdlIiwidGhlYWQiLCJ0Ym9keSIsInRmb290IiwiY2FwdGlvbiIsImNvbGdyb3VwIiwiY29sIiwidGQiLCJ0aCIsIl9kZXRhY2hlZERvYyIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiX3BvbGljeSIsIm1heWJlV3JhcFRydXN0ZWQiLCJ0cnVzdGVkVHlwZXMiLCJkZWZhdWx0UG9saWN5IiwiY3JlYXRlUG9saWN5IiwiY3JlYXRlSFRNTCIsInMiLCJtZXRhcyIsImZpcnN0VGFnIiwibWFwIiwiam9pbiIsImlubmVySFRNTCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhcnJheSIsInBhcnNlIiwiaGFzUmVxdWlyZWRBdHRycyIsImhhbmRsZXJzIiwiZWRpdEhhbmRsZXJzIiwicGFzc2l2ZUhhbmRsZXJzIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsIklucHV0U3RhdGUiLCJsYXN0S2V5Q29kZSIsImxhc3RLZXlDb2RlVGltZSIsImxhc3RDbGljayIsInRpbWUiLCJidXR0b24iLCJsYXN0U2VsZWN0aW9uT3JpZ2luIiwibGFzdFNlbGVjdGlvblRpbWUiLCJsYXN0SU9TRW50ZXIiLCJsYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQiLCJsYXN0Rm9jdXMiLCJsYXN0VG91Y2giLCJsYXN0Q2hyb21lRGVsZXRlIiwiY29tcG9zaW5nVGltZW91dCIsImNvbXBvc2l0aW9uRW5kZWRBdCIsImNvbXBvc2l0aW9uSUQiLCJiYWRTYWZhcmlDb21wb3NpdGlvbiIsImNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMiLCJkb21DaGFuZ2VDb3VudCIsImV2ZW50SGFuZGxlcnMiLCJpbml0SW5wdXQiLCJoYW5kbGVyIiwiZXZlbnRCZWxvbmdzVG9WaWV3IiwicnVuQ3VzdG9tSGFuZGxlciIsInBhc3NpdmUiLCJlbnN1cmVMaXN0ZW5lcnMiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJEYXRlIiwibm93IiwiZGVzdHJveUlucHV0IiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudEhhbmRsZXJzIiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1YmJsZXMiLCJkaXNwYXRjaEV2ZW50Iiwia2V5ZG93biIsIl9ldmVudCIsImluT3JOZWFyQ29tcG9zaXRpb24iLCJmb3JjZUZsdXNoIiwicHJldmVudERlZmF1bHQiLCJrZXl1cCIsImtleXByZXNzIiwiY2hhckNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJkZWZsdCIsImluc2VydFRleHQiLCJldmVudENvb3JkcyIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNOZWFyIiwiY2xpY2siLCJkeSIsInJ1bkhhbmRsZXJPbkNvbnRleHQiLCJwcm9wTmFtZSIsInVwZGF0ZVNlbGVjdGlvbiIsImZvY3VzZWQiLCJzZXRNZXRhIiwic2VsZWN0Q2xpY2tlZExlYWYiLCJzZWxlY3RDbGlja2VkTm9kZSIsInNlbGVjdGVkTm9kZSIsInNlbGVjdEF0IiwiaGFuZGxlU2luZ2xlQ2xpY2siLCJoYW5kbGVEb3VibGVDbGljayIsImhhbmRsZVRyaXBsZUNsaWNrIiwiZGVmYXVsdFRyaXBsZUNsaWNrIiwiZm9yY2VET01GbHVzaCIsImVuZENvbXBvc2l0aW9uIiwic2VsZWN0Tm9kZU1vZGlmaWVyIiwibW91c2Vkb3duIiwiZmx1c2hlZCIsImRvbmUiLCJNb3VzZURvd24iLCJtaWdodERyYWciLCJzdGFydERvYyIsInRhcmdldFBvcyIsIm5vZGVBdCIsInNlbGVjdGFibGUiLCJhZGRBdHRyIiwic2V0VW5lZGl0YWJsZSIsInVwIiwiYmluZCIsIm1vdmUiLCJ1cGRhdGVBbGxvd0RlZmF1bHQiLCJidXR0b25zIiwiY29udGV4dG1lbnUiLCJ0aW1lU3RhbXAiLCJ0aW1lb3V0Q29tcG9zaXRpb24iLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb251cGRhdGUiLCJmbHVzaCIsInN0b3JlZE1hcmtzIiwic29tZSIsImluY2x1c2l2ZSIsInNlbGVjdGlvbkJlZm9yZVVuZWRpdGFibGUiLCJtYXJrQ3Vyc29yIiwic2NoZWR1bGVDb21wb3NlRW5kIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsIlByb21pc2UiLCJ0aGVuIiwiZGVsYXkiLCJjbGVhckNvbXBvc2l0aW9uIiwidGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50IiwiZmluZENvbXBvc2l0aW9uTm9kZSIsInRleHRCZWZvcmUiLCJ0ZXh0QWZ0ZXIiLCJkZXNjQWZ0ZXIiLCJsYXN0Q2hhbmdlZCIsImxhc3RDaGFuZ2VkVGV4dE5vZGUiLCJkZXNjQmVmb3JlIiwicmVzdGFydGluZyIsImZsdXNoaW5nU29vbiIsInNoYXJlZERlcHRoIiwiZGVsZXRlU2VsZWN0aW9uIiwiY2FwdHVyZUNvcHkiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJibHVyIiwiYnJva2VuQ2xpcGJvYXJkQVBJIiwiZGF0YSIsImNsaXBib2FyZERhdGEiLCJjbGVhckRhdGEiLCJzZXREYXRhIiwic2xpY2VTaW5nbGVOb2RlIiwiY2FwdHVyZVBhc3RlIiwicGxhaW4iLCJkb1Bhc3RlIiwicHJlZmVyUGxhaW4iLCJzaW5nbGVOb2RlIiwicmVwbGFjZVNlbGVjdGlvbldpdGgiLCJyZXBsYWNlU2VsZWN0aW9uIiwiZ2V0VGV4dCIsImdldERhdGEiLCJ1cmlzIiwicGFzdGUiLCJEcmFnZ2luZyIsImRyYWdDb3B5TW9kaWZpZXIiLCJkcmFnTW92ZXMiLCJtb3ZlcyIsImRyYWdzdGFydCIsImRhdGFUcmFuc2ZlciIsImRyYWdnZWRTbGljZSIsImZpbGVzIiwiZWZmZWN0QWxsb3dlZCIsImRyYWdnaW5nIiwiZHJhZ2VuZCIsImRyYWdvdmVyIiwiZHJhZ2VudGVyIiwiZHJvcCIsImhhbmRsZURyb3AiLCJldmVudFBvcyIsIiRtb3VzZSIsImluc2VydFBvcyIsIm1hcHBpbmciLCJpc05vZGUiLCJiZWZvcmVJbnNlcnQiLCJyZXBsYWNlUmFuZ2VXaXRoIiwicmVwbGFjZVJhbmdlIiwibWFwcyIsIl9mcm9tIiwiX3RvIiwiX25ld0Zyb20iLCJuZXdUbyIsInJlbGF0ZWRUYXJnZXQiLCJjbGVhciIsImJlZm9yZWlucHV0IiwiaW5wdXRUeXBlIiwiZmx1c2hTb29uIiwiJGN1cnNvciIsImNvbXBhcmVPYmpzIiwiV2lkZ2V0VHlwZSIsIm5vU3BlYyIsInNwYW4iLCJvbGRPZmZzZXQiLCJkZWxldGVkIiwibWFwUmVzdWx0IiwiRGVjb3JhdGlvbiIsInZhbGlkIiwib3RoZXIiLCJJbmxpbmVUeXBlIiwiaW5jbHVzaXZlU3RhcnQiLCJpbmNsdXNpdmVFbmQiLCJpcyIsIk5vZGVUeXBlIiwiZmluZEluZGV4IiwiRGVjb3JhdGlvblNldCIsImxvY2FsIiwiZGVjb3JhdGlvbnMiLCJidWlsZFRyZWUiLCJwcmVkaWNhdGUiLCJmaW5kSW5uZXIiLCJjaGlsZE9mZiIsIm9wdGlvbnMiLCJtYXBJbm5lciIsIm5ld0xvY2FsIiwibWFwcGVkIiwib25SZW1vdmUiLCJtYXBDaGlsZHJlbiIsImJ5UG9zIiwiYWRkSW5uZXIiLCJjaGlsZE5vZGUiLCJjaGlsZE9mZnNldCIsImJhc2VPZmZzZXQiLCJ0YWtlU3BhbnNGb3JOb2RlIiwibW92ZVNwYW5zIiwid2l0aG91dE51bGxzIiwiY29uY2F0IiwicmVtb3ZlSW5uZXIiLCJyZW1vdmVkIiwiZGVjIiwibG9jYWxTZXQiLCJEZWNvcmF0aW9uR3JvdXAiLCJyZW1vdmVPdmVybGFwIiwibG9jYWxzSW5uZXIiLCJmb3JFYWNoU2V0IiwibWVtYmVycyIsIm1hcHBlZERlY29zIiwibWVtYmVyIiwic29ydGVkIiwiZXZlcnkiLCJyZWR1Y2UiLCJyIiwib2xkQ2hpbGRyZW4iLCJtb3ZlZCIsIm9sZFN0YXJ0Iiwib2xkRW5kIiwibmV3U3RhcnQiLCJuZXdFbmQiLCJkU2l6ZSIsIm11c3RSZWJ1aWxkIiwiZnJvbUxvY2FsIiwidG9Mb2NhbCIsIm1heWJlQ2hpbGQiLCJtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyIsImJ1aWx0Iiwic3BhbnMiLCJnYXRoZXIiLCJoYXNOdWxscyIsImxvY2FsU3RhcnQiLCJzdWJ0cmVlIiwid29ya2luZyIsImluc2VydEFoZWFkIiwidmlld0RlY29yYXRpb25zIiwib2JzZXJ2ZU9wdGlvbnMiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZU9sZFZhbHVlIiwidXNlQ2hhckRhdGEiLCJTZWxlY3Rpb25TdGF0ZSIsIkRPTU9ic2VydmVyIiwiaGFuZGxlRE9NQ2hhbmdlIiwicXVldWUiLCJvYnNlcnZlciIsIm9uQ2hhckRhdGEiLCJzdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwicmVtb3ZlZE5vZGVzIiwicHJldlZhbHVlIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJ0YWtlUmVjb3JkcyIsIm9ic2VydmUiLCJ0YWtlIiwiZGlzY29ubmVjdCIsInN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyIsImlnbm9yZVNlbGVjdGlvbkNoYW5nZSIsImFuY2VzdG9ycyIsIlNldCIsImNvbnRhaW5lciIsIm5ld1NlbCIsInR5cGVPdmVyIiwiYWRkZWQiLCJyZWdpc3Rlck11dGF0aW9uIiwiYnJzIiwiYnIiLCJibG9ja1BhcmVudCIsInJlYWRTZWwiLCJzY3JvbGxUb1NlbGVjdGlvbiIsImNoZWNrQ1NTIiwiZml4VXBCYWRTYWZhcmlDb21wb3NpdGlvbiIsImF0dHJpYnV0ZU5hbWUiLCJhZGRlZE5vZGVzIiwiY3NzQ2hlY2tlZCIsIldlYWtNYXAiLCJjc3NDaGVja1dhcm5lZCIsIndoaXRlU3BhY2UiLCJjb25zb2xlIiwicmFuZ2VUb1NlbGVjdGlvblJhbmdlIiwiY3VycmVudEFuY2hvciIsImRvbUF0UG9zIiwic2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2UiLCJnZXRDb21wb3NlZFJhbmdlcyIsInJlYWQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJnZXRUYXJnZXRSYW5nZXMiLCJleGVjQ29tbWFuZCIsIm5leHRDZWxsIiwicGFyc2VCZXR3ZWVuIiwiZnJvbV8iLCJ0b18iLCJ0b3BNYXRjaCIsInRvcE9wZW4iLCJmaW5kUG9zaXRpb25zIiwicmVhZERPTUNoYW5nZSIsIiRiZWZvcmUiLCJzaGFyZWQiLCJjb21wYXJlIiwicHJlZmVycmVkUG9zIiwicHJlZmVycmVkU2lkZSIsImNoYW5nZSIsImZpbmREaWZmIiwiZW5kQSIsImVuZEIiLCJyZXNvbHZlU2VsZWN0aW9uIiwicmVzb2x2ZU5vQ2FjaGUiLCIkZnJvbUEiLCJpbmxpbmVDaGFuZ2UiLCJsb29rc0xpa2VCYWNrc3BhY2UiLCJjaEZyb20iLCJjaFRvIiwibWtUciIsIm1hcmtDaGFuZ2UiLCJtYXJrc0Fjcm9zcyIsImVuc3VyZU1hcmtzIiwiaXNNYXJrQ2hhbmdlIiwiYWRkTWFyayIsInJlbW92ZU1hcmsiLCJwYXJzZWRTZWwiLCJjdXJNYXJrcyIsInByZXZNYXJrcyIsInJlbW92ZUZyb21TZXQiLCJhZGRUb1NldCIsIm9sZCIsIiRuZXdTdGFydCIsIiRuZXdFbmQiLCJza2lwQ2xvc2luZ0FuZE9wZW5pbmciLCIkbmV4dCIsImZyb21FbmQiLCJtYXlPcGVuIiwiaW5kZXhBZnRlciIsImZpbmREaWZmU3RhcnQiLCJmaW5kRGlmZkVuZCIsImFkanVzdCIsImlzU3Vycm9nYXRlUGFpciIsImNoYXJDb2RlQXQiLCJfX3BhcnNlRnJvbUNsaXBib2FyZCIsIl9fZW5kQ29tcG9zaXRpb24iLCJFZGl0b3JWaWV3IiwicGxhY2UiLCJwcm9wcyIsIl9yb290IiwibW91bnRlZCIsInByZXZEaXJlY3RQbHVnaW5zIiwicGx1Z2luVmlld3MiLCJfcHJvcHMiLCJkaXJlY3RQbHVnaW5zIiwicGx1Z2lucyIsImNoZWNrU3RhdGVDb21wb25lbnQiLCJtb3VudCIsImdldEVkaXRhYmxlIiwidXBkYXRlQ3Vyc29yV3JhcHBlciIsImJ1aWxkTm9kZVZpZXdzIiwiY29tcHV0ZURvY0RlY28iLCJ1cGRhdGVQbHVnaW5WaWV3cyIsImhhbmRsZURPTUV2ZW50cyIsInByZXZQcm9wcyIsInVwZGF0ZVN0YXRlSW5uZXIiLCJzZXRQcm9wcyIsInJlZHJhdyIsInVwZGF0ZVNlbCIsInBsdWdpbnNDaGFuZ2VkIiwiY2hhbmdlZE5vZGVWaWV3cyIsInNjcm9sbCIsInVwZGF0ZURvYyIsIm9sZFNjcm9sbFBvcyIsIm92ZXJmbG93QW5jaG9yIiwiZm9yY2VTZWxVcGRhdGUiLCJzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZCIsImNocm9tZUtsdWRnZSIsInVwZGF0ZURyYWdnZWROb2RlIiwiZGVzdHJveVBsdWdpblZpZXdzIiwicHJldlN0YXRlIiwicGx1Z2luIiwicGx1Z2luVmlldyIsIm1vdmVkUG9zIiwicGFyZW50RWxlbWVudCIsImNhY2hlZCIsImdldFByb3RvdHlwZU9mIiwidXBkYXRlUm9vdCIsInBvc0F0RE9NIiwicGFzdGVIVE1MIiwiQ2xpcGJvYXJkRXZlbnQiLCJwYXN0ZVRleHQiLCJpc0Rlc3Ryb3llZCIsImRpc3BhdGNoVHJhbnNhY3Rpb24iLCJjb250ZW50ZWRpdGFibGUiLCJhdHRyIiwidHJhbnNsYXRlIiwic2VsMSIsInNlbDIiLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsIm5BIiwibkIiLCJmaWx0ZXJUcmFuc2FjdGlvbiIsImFwcGVuZFRyYW5zYWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/prosemirror-view@1.41.5/node_modules/prosemirror-view/dist/index.js\n");

/***/ })

};
;