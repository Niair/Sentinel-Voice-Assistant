"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer+common@1.5.0";
exports.ids = ["vendor-chunks/@lezer+common@1.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/ const DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/ class NodeProp {\n    /**\n    Create a new node prop type.\n    */ constructor(config = {}){\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (()=>{\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n        this.combine = config.combine || null;\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */ add(match) {\n        if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\") match = NodeType.match(match);\n        return (type)=>{\n            let result = match(type);\n            return result === undefined ? null : [\n                this,\n                result\n            ];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/ NodeProp.closedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/ NodeProp.openedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/ NodeProp.group = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/ NodeProp.isolate = new NodeProp({\n    deserialize: (value)=>{\n        if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\") throw new RangeError(\"Invalid value for isolate: \" + value);\n        return value || \"auto\";\n    }\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/ NodeProp.contextHash = new NodeProp({\n    perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/ NodeProp.lookAhead = new NodeProp({\n    perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/ NodeProp.mounted = new NodeProp({\n    perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/ class MountedTree {\n    constructor(/**\n    The inner tree.\n    */ tree, /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */ overlay, /**\n    The parser used to create this subtree.\n    */ parser, /**\n    [Indicates](#common.IterMode.EnterBracketed) that the nested\n    content is delineated with some kind\n    of bracket token.\n    */ bracketed = false){\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n        this.bracketed = bracketed;\n    }\n    /**\n    @internal\n    */ static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */ name, /**\n    @internal\n    */ props, /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */ id, /**\n    @internal\n    */ flags = 0){\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */ static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */  : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */  : 0) | (spec.error ? 4 /* NodeFlag.Error */  : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */  : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props) for (let src of spec.props){\n            if (!Array.isArray(src)) src = src(type);\n            if (src) {\n                if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n                props[src[0].id] = src[1];\n            }\n        }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */ prop(prop) {\n        return this.props[prop.id];\n    }\n    /**\n    True when this is the top node of a grammar.\n    */ get isTop() {\n        return (this.flags & 1 /* NodeFlag.Top */ ) > 0;\n    }\n    /**\n    True when this node is produced by a skip rule.\n    */ get isSkipped() {\n        return (this.flags & 2 /* NodeFlag.Skipped */ ) > 0;\n    }\n    /**\n    Indicates whether this is an error node.\n    */ get isError() {\n        return (this.flags & 4 /* NodeFlag.Error */ ) > 0;\n    }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */ get isAnonymous() {\n        return (this.flags & 8 /* NodeFlag.Anonymous */ ) > 0;\n    }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */ is(name) {\n        if (typeof name == \"string\") {\n            if (this.name == name) return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */ static match(map) {\n        let direct = Object.create(null);\n        for(let prop in map)for (let name of prop.split(\" \"))direct[name] = map[prop];\n        return (node)=>{\n            for(let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++){\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found) return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/ NodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */ );\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/ class NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */ constructor(/**\n    The node types in this set, by id.\n    */ types){\n        this.types = types;\n        for(let i = 0; i < types.length; i++)if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */ extend(...props) {\n        let newTypes = [];\n        for (let type of this.types){\n            let newProps = null;\n            for (let source of props){\n                let add = source(type);\n                if (add) {\n                    if (!newProps) newProps = Object.assign({}, type.props);\n                    let value = add[1], prop = add[0];\n                    if (prop.combine && prop.id in newProps) value = prop.combine(newProps[prop.id], value);\n                    newProps[prop.id] = value;\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/ var IterMode;\n(function(IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */ IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */ IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */ IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */ IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n    /**\n    When set, positions on the boundary of a mounted overlay tree\n    that has its [`bracketed`](#common.NestedParse.bracketed) flag\n    set will enter that tree regardless of side. Only supported in\n    [`enter`](#common.SyntaxNode.enter), not in cursors.\n    */ IterMode[IterMode[\"EnterBracketed\"] = 16] = \"EnterBracketed\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/ class Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */ constructor(/**\n    The type of the top node.\n    */ type, /**\n    This node's child nodes.\n    */ children, /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */ positions, /**\n    The total length of this tree\n    */ length, /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */ props){\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */ this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */ toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay) return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children){\n            let str = ch.toString();\n            if (str) {\n                if (children) children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */ cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */ cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */ get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */ resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */ resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */ resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */ iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for(let c = this.cursor(mode | IterMode.IncludeAnonymous);;){\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild()) continue;\n                entered = true;\n            }\n            for(;;){\n                if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n                if (c.nextSibling()) break;\n                if (!c.parent()) return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */ prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */ get propValues() {\n        let result = [];\n        if (this.props) for(let id in this.props)result.push([\n            +id,\n            this.props[id]\n        ]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */ balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */  ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length)=>new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length)=>new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */ static build(data) {\n        return buildTree(data);\n    }\n}\n/**\nThe empty tree\n*/ Tree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index){\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    get pos() {\n        return this.index;\n    }\n    next() {\n        this.index -= 4;\n    }\n    fork() {\n        return new FlatBufferCursor(this.buffer, this.index);\n    }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/ class TreeBuffer {\n    /**\n    Create a tree buffer.\n    */ constructor(/**\n    The buffer's content.\n    */ buffer, /**\n    The total length of the group of nodes in the buffer.\n    */ length, /**\n    The node set used in this buffer.\n    */ set){\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */ get type() {\n        return NodeType.none;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = [];\n        for(let index = 0; index < this.buffer.length;){\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */ childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index) return result;\n        let children = [];\n        while(index < endIndex){\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */ findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for(let i = startIndex; i != endIndex; i = buffer[i + 3]){\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0) break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */ slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for(let i = startI, j = 0; i < endI;){\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch(side){\n        case -2 /* Side.Before */ :\n            return from < pos;\n        case -1 /* Side.AtOrBefore */ :\n            return to >= pos && from < pos;\n        case 0 /* Side.Around */ :\n            return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */ :\n            return from <= pos && to > pos;\n        case 2 /* Side.After */ :\n            return to > pos;\n        case 4 /* Side.DontCare */ :\n            return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while(node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)){\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent) return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays) for(let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent){\n        if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n    }\n    for(;;){\n        let inner = node.enter(pos, side, mode);\n        if (!inner) return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) {\n        return new TreeCursor(this, mode);\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this.parent, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while(scan){\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to) break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            } else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() {\n        return this;\n    }\n    get next() {\n        return this.parent;\n    }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent){\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() {\n        return this._tree.type;\n    }\n    get name() {\n        return this._tree.type.name;\n    }\n    get to() {\n        return this.from + this._tree.length;\n    }\n    nextChild(i, dir, pos, side, mode = 0) {\n        var _a;\n        for(let parent = this;;){\n            for(let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir){\n                let next = children[i], start = positions[i] + parent.from;\n                if (!(mode & IterMode.EnterBracketed && next instanceof Tree && ((_a = MountedTree.get(next)) === null || _a === void 0 ? void 0 : _a.overlay) === null && (start >= pos || start + next.length <= pos)) && !checkSide(side, pos, start, start + next.length)) continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers) continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side, mode);\n                }\n            }\n            if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n            if (parent.index >= 0) i = parent.index + dir;\n            else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent) return null;\n        }\n    }\n    get firstChild() {\n        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.nextChild(0, 1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */ );\n    }\n    prop(prop) {\n        return this._tree.prop(prop);\n    }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from, enterBracketed = mode & IterMode.EnterBracketed && mounted.bracketed;\n            for (let { from, to } of mounted.overlay){\n                if ((side > 0 || enterBracketed ? from <= rPos : from < rPos) && (side < 0 || enterBracketed ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while(val.type.isAnonymous && val._parent)val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get tree() {\n        return this._tree;\n    }\n    toTree() {\n        return this._tree;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this._tree.toString();\n    }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild()) return result;\n    if (before != null) for(let found = false; !found;){\n        found = cur.type.is(before);\n        if (!cur.nextSibling()) return result;\n    }\n    for(;;){\n        if (after != null && cur.type.is(after)) return result;\n        if (cur.type.is(type)) result.push(cur.node);\n        if (!cur.nextSibling()) return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for(let p = node; i >= 0; p = p.parent){\n        if (!p) return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name) return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start){\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() {\n        return this.type.name;\n    }\n    get from() {\n        return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n    get to() {\n        return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n    constructor(context, _parent, index){\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() {\n        return this.child(1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.child(-1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.child(1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.child(-1, pos, -2 /* Side.Before */ );\n    }\n    prop(prop) {\n        return this.type.prop(prop);\n    }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers) return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */ );\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart) return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n    }\n    get tree() {\n        return null;\n    }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.context.buffer.childString(this.index);\n    }\n}\nfunction iterStack(heads) {\n    if (!heads.length) return null;\n    let pick = 0, picked = heads[0];\n    for(let i = 1; i < heads.length; i++){\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next) newHeads[pick] = next;\n    else newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node){\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() {\n        return iterStack(this.heads);\n    }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for(let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent){\n        if (scan.index < 0) {\n            let parent = scan.parent;\n            (layers || (layers = [\n                inner\n            ])).push(parent.resolve(pos, side));\n            scan = parent;\n        } else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [\n                    inner\n                ])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/ class TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */ get name() {\n        return this.type.name;\n    }\n    /**\n    @internal\n    */ constructor(node, mode = 0){\n        /**\n        @internal\n        */ this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */ this.index = 0;\n        this.bufferNode = null;\n        this.mode = mode & ~IterMode.EnterBracketed;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        } else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for(let n = node._parent; n; n = n._parent)this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node) return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */ yield(node) {\n        if (!node) return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */ enterChild(dir, pos, side) {\n        if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0) return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */ firstChild() {\n        return this.enterChild(1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to this node's last child.\n    */ lastChild() {\n        return this.enterChild(-1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */ childAfter(pos) {\n        return this.enterChild(1, pos, 2 /* Side.After */ );\n    }\n    /**\n    Move to the last child that starts before `pos`.\n    */ childBefore(pos) {\n        return this.enterChild(-1, pos, -2 /* Side.Before */ );\n    }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */ enter(pos, side, mode = this.mode) {\n        if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */ parent() {\n        if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n        if (this.stack.length) return this.yieldBuf(this.stack.pop());\n        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */ sibling(dir) {\n        if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n        } else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */ nextSibling() {\n        return this.sibling(1);\n    }\n    /**\n    Move to this node's previous sibling, if any.\n    */ prevSibling() {\n        return this.sibling(-1);\n    }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length) return false;\n            } else {\n                for(let i = 0; i < this.index; i++)if (buffer.buffer.buffer[i + 3] < this.index) return false;\n            }\n            ({ index, parent } = buffer);\n        } else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for(; parent; { index, _parent: parent } = parent){\n            if (index > -1) for(let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir){\n                let child = parent._tree.children[i];\n                if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n            }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */ )) return true;\n        for(;;){\n            if (this.sibling(dir)) return true;\n            if (this.atLastNode(dir) || !this.parent()) return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */ next(enter = true) {\n        return this.move(1, enter);\n    }\n    /**\n    Move to the next node in a last-to-first pre-order traversal. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */ prev(enter = true) {\n        return this.move(-1, enter);\n    }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */ moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while(this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))if (!this.parent()) break;\n        // Then scan down into child nodes as far as possible\n        while(this.enterChild(1, pos, side)){}\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */ get node() {\n        if (!this.buffer) return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for(let index = this.index, d = this.stack.length; d >= 0;){\n                for(let c = cache; c; c = c._parent)if (c.index == index) {\n                    if (index == this.index) return c;\n                    result = c;\n                    depth = d + 1;\n                    break scan;\n                }\n                index = this.stack[--d];\n            }\n        }\n        for(let i = depth; i < this.stack.length; i++)result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */ get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */ iterate(enter, leave) {\n        for(let depth = 0;;){\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous) mustLeave = true;\n            }\n            for(;;){\n                if (mustLeave && leave) leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (!depth) return;\n                if (this.nextSibling()) break;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given contextâ€”a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */ matchContext(context) {\n        if (!this.buffer) return matchNodeContext(this.node.parent, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for(let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--){\n            if (d < 0) return matchNodeContext(this._tree, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name) return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some((ch)=>ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;\n        if (size < 0) {\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */ ) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n                contextHash = id;\n                return;\n            } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n                lookAhead = id;\n                return;\n            } else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while(cursor.pos > endPos)index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        } else {\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while(cursor.pos > endPos){\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                } else if (depth > 2500 /* CutOff.Depth */ ) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                } else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type, contextAtStart);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            } else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while(cursor.pos > minPos){\n            let { id, start, end, size } = cursor;\n            if (size > 4) {\n                cursor.next();\n            } else if (stopAt > -1 && start < stopAt) {\n                break;\n            } else {\n                if (stopAt < 0) stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for(let i = nodes.length - 3, j = 0; i >= 0; i -= 3){\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type, contextHash) {\n        return (children, positions, length)=>{\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length) return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead, contextHash);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {\n        let localChildren = [], localPositions = [];\n        while(children.length > i){\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {\n        if (contextHash) {\n            let pair = [\n                NodeProp.contextHash,\n                contextHash\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        if (lookAhead > 25) {\n            let pair = [\n                NodeProp.lookAhead,\n                lookAhead\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = {\n            size: 0,\n            start: 0,\n            skip: 0\n        };\n        scan: for(let minPos = fork.pos - maxSize; fork.pos > minPos;){\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while(fork.pos > startPos){\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */  || fork.size == -4 /* SpecialRecord.LookAhead */ ) localSkipped += 4;\n                    else break scan;\n                } else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while(cursor.pos > endPos)index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n            contextHash = id;\n        } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while(cursor.pos > 0)takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children){\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(// The type the balanced tree's inner nodes.\nbalanceType, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for(let i = from; i < to; i++)total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */ );\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for(let i = from; i < to;){\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for(; i < to; i++){\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild) break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            } else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/ class NodeWeakMap {\n    constructor(){\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner) this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */ set(node, value) {\n        if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode) this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */ get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */ cursorSet(cursor, value) {\n        if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */ cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/ class TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */ constructor(/**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */ from, /**\n    The end of the unchanged range.\n    */ to, /**\n    The tree that this fragment is based on.\n    */ tree, /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */ offset, openStart = false, openEnd = false){\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */  : 0) | (openEnd ? 2 /* Open.End */  : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */ get openStart() {\n        return (this.open & 1 /* Open.Start */ ) > 0;\n    }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */ get openEnd() {\n        return (this.open & 2 /* Open.End */ ) > 0;\n    }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */ static addTree(tree, fragments = [], partial = false) {\n        let result = [\n            new TreeFragment(0, tree.length, tree, 0, false, partial)\n        ];\n        for (let f of fragments)if (f.to > tree.length) result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */ static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length) return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for(let cI = 0, pos = 0, off = 0;; cI++){\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap) while(nextF && nextF.from < nextPos){\n                let cut = nextF;\n                if (pos >= cut.from || nextPos <= cut.to || off) {\n                    let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                    cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                }\n                if (cut) result.push(cut);\n                if (nextF.to > nextPos) break;\n                nextF = fI < fragments.length ? fragments[fI++] : null;\n            }\n            if (!nextC) break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/ class Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */ startParse(input, fragments, ranges) {\n        if (typeof input == \"string\") input = new StringInput(input);\n        ranges = !ranges ? [\n            new Range(0, input.length)\n        ] : ranges.length ? ranges.map((r)=>new Range(r.from, r.to)) : [\n            new Range(0, 0)\n        ];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */ parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for(;;){\n            let done = parse.advance();\n            if (done) return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string){\n        this.string = string;\n    }\n    get length() {\n        return this.string.length;\n    }\n    chunk(from) {\n        return this.string.slice(from);\n    }\n    get lineChunks() {\n        return false;\n    }\n    read(from, to) {\n        return this.string.slice(from, to);\n    }\n}\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/ function parseMixed(nest) {\n    return (parse, input, fragments, ranges)=>new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, bracketed, target, from){\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.bracketed = bracketed;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some((r)=>r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, bracketed, target, prev){\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.bracketed = bracketed;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({\n    perNode: true\n});\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges){\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done) return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null) for (let inner of this.inner)inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([\n                [\n                    stoppedInner,\n                    this.stoppedAt\n                ]\n            ]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser, inner.bracketed);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse) return 0;\n        let pos = this.input.length;\n        for(let i = this.innerDone; i < this.inner.length; i++){\n            if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse) this.baseParse.stopAt(pos);\n        else for(let i = this.innerDone; i < this.inner.length; i++)this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for(let nest, isCovered;;){\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            } else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find((m)=>m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match) for (let r of match.mount.overlay){\n                        let from = r.from + match.pos, to = r.to + match.pos;\n                        if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r)=>r.from < to && r.to > from)) overlay.ranges.push({\n                            from,\n                            to\n                        });\n                    }\n                }\n                enter = false;\n            } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */ ;\n            } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) {\n                    materialize(cursor);\n                    // materialize create one more level of nesting\n                    // we need to add depth to active overlay for going backwards\n                    if (overlay) overlay.depth++;\n                    if (covered) covered.depth++;\n                }\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, !!nest.bracketed, cursor.tree, overlay);\n                } else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [\n                        new Range(cursor.from, cursor.to)\n                    ] : []));\n                    if (ranges.length) checkRanges(ranges);\n                    if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map((r)=>new Range(r.from - cursor.from, r.to - cursor.from)) : null, !!nest.bracketed, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay) enter = false;\n                    else if (ranges.length) covered = {\n                        ranges,\n                        depth: 0,\n                        prev: covered\n                    };\n                }\n            } else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true) range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) {\n                    let last = overlay.ranges.length - 1;\n                    if (last >= 0 && overlay.ranges[last].to == range.from) overlay.ranges[last] = {\n                        from: overlay.ranges[last].from,\n                        to: range.to\n                    };\n                    else overlay.ranges.push(range);\n                }\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay) overlay.depth++;\n                if (covered) covered.depth++;\n            } else {\n                for(;;){\n                    if (cursor.nextSibling()) break;\n                    if (!cursor.parent()) break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r)=>new Range(r.from - overlay.start, r.to - overlay.start)), overlay.bracketed, overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth) covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered){\n        if (range.from >= to) break;\n        if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */  : 1 /* Cover.Partial */ ;\n    }\n    return 0 /* Cover.None */ ;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    let buffer = node.context.buffer;\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    }while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let base = cursor.tree, i = base.children.indexOf(buffer);\n    let buf = base.children[i], b = buf.buffer, newStack = [\n        i\n    ];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack){\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset){\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while(!this.done && cursor.from < p){\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false)) this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for(let tree = this.cursor.tree;;){\n                if (tree == cursor.tree) return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];\n                else break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments){\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        } else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while(this.curFrag && node.from >= this.curTo)this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        } else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for(let pos = this.inner.cursor.node; pos; pos = pos.parent){\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for(let i = this.fragI; i < this.fragments.length; i++){\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to) break;\n                        if (frag.tree == this.curFrag.tree) result.push({\n                            frag,\n                            pos: pos.from - frag.offset,\n                            mount\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for(let i = 1, j = 0; i < outer.length; i++){\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for(; j < current.length; j++){\n            let r = current[j];\n            if (r.from >= gapTo) break;\n            if (r.to <= gapFrom) continue;\n            if (!copy) current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            } else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            } else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for(;;){\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end) result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9) break;\n        if (nextA == pos) {\n            if (!inA) inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB) inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts){\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map((r)=>new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for(let i = 0, pos = from;; i++){\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last) break;\n                pos = changes[i].to;\n            }\n        } else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxlemVyK2NvbW1vbkAxLjUuMC9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxHQUNBLE1BQU1BLHNCQUFzQjtBQUM1QixJQUFJQyxhQUFhO0FBQ2pCLE1BQU1DO0lBQ0ZDLFlBQVlDLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtJQUNkO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBSCxZQUFZSSxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUDtRQUNWLElBQUksQ0FBQ1EsT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBT0UsT0FBTztRQUMvQixJQUFJLENBQUNDLFdBQVcsR0FBR0gsT0FBT0csV0FBVyxJQUFLO1lBQ3RDLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxHQUFHTCxPQUFPSyxPQUFPLElBQUk7SUFDckM7SUFDQTs7Ozs7Ozs7SUFRQSxHQUNBQyxJQUFJQyxLQUFLLEVBQUU7UUFDUCxJQUFJLElBQUksQ0FBQ0wsT0FBTyxFQUNaLE1BQU0sSUFBSU0sV0FBVztRQUN6QixJQUFJLE9BQU9ELFNBQVMsWUFDaEJBLFFBQVFFLFNBQVNGLEtBQUssQ0FBQ0E7UUFDM0IsT0FBTyxDQUFDRztZQUNKLElBQUlDLFNBQVNKLE1BQU1HO1lBQ25CLE9BQU9DLFdBQVdDLFlBQVksT0FBTztnQkFBQyxJQUFJO2dCQUFFRDthQUFPO1FBQ3ZEO0lBQ0o7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0FaLFNBQVNjLFFBQVEsR0FBRyxJQUFJZCxTQUFTO0lBQUVJLGFBQWFXLENBQUFBLE1BQU9BLElBQUlDLEtBQUssQ0FBQztBQUFLO0FBQ3RF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Z0JBQ0p6RSxNQUFNK0wsT0FBTyxDQUFDM04sRUFBRSxDQUFDekQsRUFBRTtZQUN2QjtRQUNKLE9BQ0s7WUFDRGEsT0FBT3NELElBQUksQ0FBQyxJQUFJd00sYUFBYTVRLE1BQU1DLElBQUk0TCxNQUFNbEssSUFBSSxFQUFFLENBQUMrTCxVQUFVK0csS0FBS3pVLElBQUksSUFBSTBOLFlBQVkrRyxLQUFLNUQsU0FBUyxFQUFFNEQsS0FBS3hVLEVBQUUsSUFBSTROLFVBQVU0RyxLQUFLM0QsT0FBTztRQUM1STtJQUNKO0lBQ0EsT0FBT2hRO0FBQ1g7QUFFZ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV6ZXIrY29tbW9uQDEuNS4wL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/Y2U3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbmZpZy5jb21iaW5lIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuQXR0YWNoZWQgdG8gbm9kZXMgdG8gaW5kaWNhdGUgdGhlc2Ugc2hvdWxkIGJlXG5bZGlzcGxheWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKVxuaW4gYSBiaWRpcmVjdGlvbmFsIHRleHQgaXNvbGF0ZSwgc28gdGhhdCBkaXJlY3Rpb24tbmV1dHJhbFxuY2hhcmFjdGVycyBvbiB0aGVpciBzaWRlcyBkb24ndCBpbmNvcnJlY3RseSBnZXQgYXNzb2NpYXRlZCB3aXRoXG5zdXJyb3VuZGluZyB0ZXh0LiBZb3UnbGwgZ2VuZXJhbGx5IHdhbnQgdG8gc2V0IHRoaXMgZm9yIG5vZGVzXG50aGF0IGNvbnRhaW4gYXJiaXRyYXJ5IHRleHQsIGxpa2Ugc3RyaW5ncyBhbmQgY29tbWVudHMsIGFuZCBmb3Jcbm5vZGVzIHRoYXQgYXBwZWFyIF9pbnNpZGVfIGFyYml0cmFyeSB0ZXh0LCBsaWtlIEhUTUwgdGFncy4gV2hlblxubm90IGdpdmVuIGEgdmFsdWUsIGluIGEgZ3JhbW1hciBkZWNsYXJhdGlvbiwgZGVmYXVsdHMgdG9cbmBcImF1dG9cImAuXG4qL1xuTm9kZVByb3AuaXNvbGF0ZSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPSBcInJ0bFwiICYmIHZhbHVlICE9IFwibHRyXCIgJiYgdmFsdWUgIT0gXCJhdXRvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgXCJhdXRvXCI7XG4gICAgfSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlciwgXG4gICAgLyoqXG4gICAgW0luZGljYXRlc10oI2NvbW1vbi5JdGVyTW9kZS5FbnRlckJyYWNrZXRlZCkgdGhhdCB0aGUgbmVzdGVkXG4gICAgY29udGVudCBpcyBkZWxpbmVhdGVkIHdpdGggc29tZSBraW5kXG4gICAgb2YgYnJhY2tldCB0b2tlbi5cbiAgICAqL1xuICAgIGJyYWNrZXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmJyYWNrZXRlZCA9IGJyYWNrZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYWRkWzFdLCBwcm9wID0gYWRkWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5jb21iaW5lICYmIHByb3AuaWQgaW4gbmV3UHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3AuY29tYmluZShuZXdQcm9wc1twcm9wLmlkXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1twcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1R5cGVzLnB1c2gobmV3UHJvcHMgPyBuZXcgTm9kZVR5cGUodHlwZS5uYW1lLCBuZXdQcm9wcywgdHlwZS5pZCwgdHlwZS5mbGFncykgOiB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZXQobmV3VHlwZXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZE5vZGUgPSBuZXcgV2Vha01hcCgpLCBDYWNoZWRJbm5lck5vZGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG5PcHRpb25zIHRoYXQgY29udHJvbCBpdGVyYXRpb24uIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBgfGBcbm9wZXJhdG9yIHRvIGVuYWJsZSBtdWx0aXBsZSBvbmVzLlxuKi9cbnZhciBJdGVyTW9kZTtcbihmdW5jdGlvbiAoSXRlck1vZGUpIHtcbiAgICAvKipcbiAgICBXaGVuIGVuYWJsZWQsIGl0ZXJhdGlvbiB3aWxsIG9ubHkgdmlzaXQgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIFtgVHJlZUJ1ZmZlcmBdKCNjb21tb24uVHJlZUJ1ZmZlcilzLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJFeGNsdWRlQnVmZmVyc1wiXSA9IDFdID0gXCJFeGNsdWRlQnVmZmVyc1wiO1xuICAgIC8qKlxuICAgIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgdGhlIG5vZGVzIHRoYXQgd3JhcCByZXBlYXRlZCBncmFtbWFyIGNvbnN0cnVjdHMgaW50byBhIGJhbGFuY2VkXG4gICAgdHJlZSkuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8qKlxuICAgIEJ5IGRlZmF1bHQsIHJlZ3VsYXIgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgbm9kZXNcbiAgICByZXBsYWNlIHRoZWlyIGJhc2Ugbm9kZSBpbiBpdGVyYXRpb24uIEVuYWJsZSB0aGlzIHRvIGlnbm9yZSB0aGVtXG4gICAgaW5zdGVhZC5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlTW91bnRzXCJdID0gNF0gPSBcIklnbm9yZU1vdW50c1wiO1xuICAgIC8qKlxuICAgIFRoaXMgb3B0aW9uIG9ubHkgYXBwbGllcyBpblxuICAgIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIGxpYnJhcnkgdG8gbm90IGVudGVyIG1vdW50ZWQgb3ZlcmxheXMgaWYgb25lIGNvdmVycyB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbiAgICAvKipcbiAgICBXaGVuIHNldCwgcG9zaXRpb25zIG9uIHRoZSBib3VuZGFyeSBvZiBhIG1vdW50ZWQgb3ZlcmxheSB0cmVlXG4gICAgdGhhdCBoYXMgaXRzIFtgYnJhY2tldGVkYF0oI2NvbW1vbi5OZXN0ZWRQYXJzZS5icmFja2V0ZWQpIGZsYWdcbiAgICBzZXQgd2lsbCBlbnRlciB0aGF0IHRyZWUgcmVnYXJkbGVzcyBvZiBzaWRlLiBPbmx5IHN1cHBvcnRlZCBpblxuICAgIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLCBub3QgaW4gY3Vyc29ycy5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRW50ZXJCcmFja2V0ZWRcIl0gPSAxNl0gPSBcIkVudGVyQnJhY2tldGVkXCI7XG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xuLyoqXG5BIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2VcbnRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbmNvbnZlbmllbnQgd2F5LlxuXG5TeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbm9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbm5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG5cbkhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbnJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbnVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbmEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5tb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgY2hpbGRyZW4sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICB0aGUgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgKi9cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICAqL1xuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIHRyZWUuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIGZyb20gYm90aCBzaWRlcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XG4gICAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIHRoZSBob3N0IHRyZWVzKS5cbiAgICAqL1xuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICAgIG5vZGVzIGFyb3VuZCBhIHBvc2l0aW9uLCBpbmNsdWRpbmcgdGhvc2UgaW4gb3ZlcmxheXMgdGhhdCBkb24ndFxuICAgIGRpcmVjdGx5IGNvdmVyIHRoZSBwb3NpdGlvbi4gVGhpcyBtZXRob2QgZ2l2ZXMgeW91IGFuIGl0ZXJhdG9yXG4gICAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgcmVzb2x2ZVN0YWNrKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrSXRlcmF0b3IodGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzO1xuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgbW9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBCYXNlTm9kZSB7XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMucGFyZW50LCBjb250ZXh0KTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7XG4gICAgICAgIGxldCBzY2FuID0gdGhpcy5jaGlsZEJlZm9yZShwb3MpLCBub2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHNjYW4pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnBhcmVudDsgfVxufVxuY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgY29uc3RydWN0b3IoX3RyZWUsIGZyb20sIFxuICAgIC8vIEluZGV4IGluIHBhcmVudCBub2RlLCBzZXQgdG8gLTEgaWYgdGhlIG5vZGUgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIF9wYXJlbnQubm9kZSAob3ZlcmxheSlcbiAgICBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90cmVlID0gX3RyZWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5fdHJlZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCEoKG1vZGUgJiBJdGVyTW9kZS5FbnRlckJyYWNrZXRlZCkgJiYgbmV4dCBpbnN0YW5jZW9mIFRyZWUgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IE1vdW50ZWRUcmVlLmdldChuZXh0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm92ZXJsYXkpID09PSBudWxsICYmIChzdGFydCA+PSBwb3MgfHwgc3RhcnQgKyBuZXh0Lmxlbmd0aCA8PSBwb3MpKSAmJlxuICAgICAgICAgICAgICAgICAgICAhY2hlY2tTaWRlKHNpZGUsIHBvcywgc3RhcnQsIHN0YXJ0ICsgbmV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU1vdW50cykgJiYgKG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQobmV4dCkpICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50LmluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll9wYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLl90cmVlLnByb3AocHJvcCk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMuX3RyZWUpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tLCBlbnRlckJyYWNrZXRlZCA9IChtb2RlICYgSXRlck1vZGUuRW50ZXJCcmFja2V0ZWQpICYmIG1vdW50ZWQuYnJhY2tldGVkO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgfHwgZW50ZXJCcmFja2V0ZWQgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwIHx8IGVudGVyQnJhY2tldGVkID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IoKSwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgZm9yIChsZXQgZm91bmQgPSBmYWxzZTsgIWZvdW5kOykge1xuICAgICAgICAgICAgZm91bmQgPSBjdXIudHlwZS5pcyhiZWZvcmUpO1xuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlOyBpID49IDA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICBpZiAoIXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcC50eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHAubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBCdWZmZXJDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJ1ZmZlciwgaW5kZXgsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07IH1cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBfcGFyZW50LCBpbmRleCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbnRleHQuYnVmZmVyLnNldC50eXBlc1tjb250ZXh0LmJ1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICB9XG4gICAgY2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuY29udGV4dC5zdGFydCwgc2lkZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyBudWxsIDogbmV3IEJ1ZmZlck5vZGUodGhpcy5jb250ZXh0LCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnR5cGUucHJvcChwcm9wKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIHNpZGUgPiAwID8gMSA6IC0xLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgfVxuICAgIGV4dGVybmFsU2libGluZyhkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IG51bGwgOiB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRDaGlsZCh0aGlzLmNvbnRleHQuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRvVHJlZSgpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IHRoaXMuaW5kZXggKyA0LCBlbmRJID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChlbmRJID4gc3RhcnRJKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChidWZmZXIuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbn1cbmZ1bmN0aW9uIGl0ZXJTdGFjayhoZWFkcykge1xuICAgIGlmICghaGVhZHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcGljayA9IDAsIHBpY2tlZCA9IGhlYWRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVhZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBoZWFkc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZnJvbSA+IHBpY2tlZC5mcm9tIHx8IG5vZGUudG8gPCBwaWNrZWQudG8pIHtcbiAgICAgICAgICAgIHBpY2tlZCA9IG5vZGU7XG4gICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV4dCA9IHBpY2tlZCBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHBpY2tlZC5pbmRleCA8IDAgPyBudWxsIDogcGlja2VkLnBhcmVudDtcbiAgICBsZXQgbmV3SGVhZHMgPSBoZWFkcy5zbGljZSgpO1xuICAgIGlmIChuZXh0KVxuICAgICAgICBuZXdIZWFkc1twaWNrXSA9IG5leHQ7XG4gICAgZWxzZVxuICAgICAgICBuZXdIZWFkcy5zcGxpY2UocGljaywgMSk7XG4gICAgcmV0dXJuIG5ldyBTdGFja0l0ZXJhdG9yKG5ld0hlYWRzLCBwaWNrZWQpO1xufVxuY2xhc3MgU3RhY2tJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaGVhZHMsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5oZWFkcyA9IGhlYWRzO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIGl0ZXJTdGFjayh0aGlzLmhlYWRzKTsgfVxufVxuZnVuY3Rpb24gc3RhY2tJdGVyYXRvcih0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgaW5uZXIgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIHNpZGUpLCBsYXllcnMgPSBudWxsO1xuICAgIGZvciAobGV0IHNjYW4gPSBpbm5lciBpbnN0YW5jZW9mIFRyZWVOb2RlID8gaW5uZXIgOiBpbm5lci5jb250ZXh0LnBhcmVudDsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FuLmluZGV4IDwgMCkgeyAvLyBUaGlzIGlzIGFuIG92ZXJsYXkgcm9vdFxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHNjYW4ucGFyZW50O1xuICAgICAgICAgICAgKGxheWVycyB8fCAobGF5ZXJzID0gW2lubmVyXSkpLnB1c2gocGFyZW50LnJlc29sdmUocG9zLCBzaWRlKSk7XG4gICAgICAgICAgICBzY2FuID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdW50ID0gTW91bnRlZFRyZWUuZ2V0KHNjYW4udHJlZSk7XG4gICAgICAgICAgICAvLyBSZWxldmFudCBvdmVybGF5IGJyYW5jaGluZyBvZmZcbiAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5vdmVybGF5ICYmIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA8PSBwb3MgJiYgbW91bnQub3ZlcmxheVttb3VudC5vdmVybGF5Lmxlbmd0aCAtIDFdLnRvID49IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCByb290ID0gbmV3IFRyZWVOb2RlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIHNjYW4uZnJvbSwgLTEsIHNjYW4pO1xuICAgICAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHJlc29sdmVOb2RlKHJvb3QsIHBvcywgc2lkZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzID8gaXRlclN0YWNrKGxheWVycykgOiBpbm5lcjtcbn1cbi8qKlxuQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG5hbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLyoqXG4gICAgU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBtb2RlID0gMCkge1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlICYgfkl0ZXJNb2RlLkVudGVyQnJhY2tldGVkO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyc2FsLiBBXG4gICAgbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIHByZXZpb3VzIHNpYmxpbmcgb3IgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudFxuICAgIG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBpbm5lcm1vc3Qgbm9kZSB0aGF0IGNvdmVycyBgcG9zYC4gSWZcbiAgICBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gICAgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgICovXG4gICAgbW92ZVRvKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmZyb20gPT0gdGhpcy50byB8fFxuICAgICAgICAgICAgKHNpZGUgPCAxID8gdGhpcy5mcm9tID49IHBvcyA6IHRoaXMuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgICAgIChzaWRlID4gLTEgPyB0aGlzLnRvIDw9IHBvcyA6IHRoaXMudG8gPCBwb3MpKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUaGVuIHNjYW4gZG93biBpbnRvIGNoaWxkIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBjdXJzb3IncyBjdXJyZW50XG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgICAgICBsZXQgY2FjaGUgPSB0aGlzLmJ1ZmZlck5vZGUsIHJlc3VsdCA9IG51bGwsIGRlcHRoID0gMDtcbiAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmNvbnRleHQgPT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIHNjYW46IGZvciAobGV0IGluZGV4ID0gdGhpcy5pbmRleCwgZCA9IHRoaXMuc3RhY2subGVuZ3RoOyBkID49IDA7KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNhY2hlOyBjOyBjID0gYy5fcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5pbmRleCA9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuc3RhY2tbLS1kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVwdGg7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5zdGFja1tpXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlck5vZGUgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbdHJlZV0oI2NvbW1vbi5UcmVlKSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgbm9kZSwgaWZcbiAgICBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgYnVmZmVyXSgjY29tbW9uLlRyZWVCdWZmZXIpLlxuICAgICovXG4gICAgZ2V0IHRyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IG51bGwgOiB0aGlzLl90cmVlLl90cmVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIGBlbnRlcmAgd2hlbiBlbnRlcmluZyBhIG5vZGUgYW5kIGBsZWF2ZWAsIGlmIGdpdmVuLCB3aGVuIGxlYXZpbmdcbiAgICBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gICAgc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICAqL1xuICAgIGl0ZXJhdGUoZW50ZXIsIGxlYXZlKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbXVzdExlYXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKHRoaXMpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RMZWF2ZSAmJiBsZWF2ZSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdGhpcy50eXBlLmlzQW5vbnltb3VzO1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgZ2l2ZW4gY29udGV4dOKAlGEgc2VxdWVuY2VcbiAgICBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICBhcmUgdHJlYXRlZCBhcyB3aWxkY2FyZHMuXG4gICAgKi9cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLnBhcmVudCwgY29udGV4dCk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIHsgdHlwZXMgfSA9IGJ1ZmZlci5zZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5fdHJlZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZCwgY29udGV4dEF0U3RhcnQgPSBjb250ZXh0SGFzaDtcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHcm91cCA9IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVuZCA9IGN1cnNvci5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPiAyNTAwIC8qIEN1dE9mZi5EZXB0aCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0YWtlRmxhdE5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZU5vZGUoc3RhcnQsIGVuZFBvcywgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxvY2FsSW5SZXBlYXQsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlLCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRha2VGbGF0Tm9kZShwYXJlbnRTdGFydCwgbWluUG9zLCBjaGlsZHJlbiwgcG9zaXRpb25zKSB7XG4gICAgICAgIGxldCBub2RlcyA9IFtdOyAvLyBUZW1wb3JhcnksIGludmVydGVkIGFycmF5IG9mIGxlYWYgbm9kZXMgZm91bmQsIHdpdGggYWJzb2x1dGUgcG9zaXRpb25zXG4gICAgICAgIGxldCBub2RlQ291bnQgPSAwLCBzdG9wQXQgPSAtMTtcbiAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBtaW5Qb3MpIHtcbiAgICAgICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHsgLy8gTm90IGEgbGVhZlxuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdG9wQXQgPiAtMSAmJiBzdGFydCA8IHN0b3BBdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BBdCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCA9IGVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGlkLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBub2RlQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkobm9kZUNvdW50ICogNCk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAzLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaSArIDFdIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMl0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBUcmVlQnVmZmVyKGJ1ZmZlciwgbm9kZXNbMl0gLSBzdGFydCwgbm9kZVNldCkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUJhbGFuY2VkKHR5cGUsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoKSB7XG4gICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW4ucG9wKCkpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChwb3NpdGlvbnMucG9wKCkgKyBiYXNlIC0gZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVHJlZShub2RlU2V0LnR5cGVzW3R5cGVdLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgdG8gLSBmcm9tLCBsb29rQWhlYWQgLSB0bywgY29udGV4dEhhc2gpKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovIHx8IGZvcmsuc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xLCAwKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgYnJhY2tldGVkLCB0YXJnZXQsIGZyb20pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5icmFja2V0ZWQgPSBicmFja2V0ZWQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlubmVyIHBhcnNlIHJhbmdlcyBnaXZlbjogXCIgKyBKU09OLnN0cmluZ2lmeShyYW5nZXMpKTtcbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgYnJhY2tldGVkLCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuYnJhY2tldGVkID0gYnJhY2tldGVkO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyLCBpbm5lci5icmFja2V0ZWQpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lcltpXS5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICB9XG4gICAgc3RhcnRJbm5lcigpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50Q3Vyc29yID0gbmV3IEZyYWdtZW50Q3Vyc29yKHRoaXMuZnJhZ21lbnRzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihuZXcgVHJlZU5vZGUodGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBjdXJzb3IuZnJvbSA+PSB0aGlzLnN0b3BwZWRBdCkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpICYmXG4gICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvIHx8ICFuZXN0Lm92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRlcmlhbGl6ZSBjcmVhdGUgb25lIG1vcmUgbGV2ZWwgb2YgbmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFkZCBkZXB0aCB0byBhY3RpdmUgb3ZlcmxheSBmb3IgZ29pbmcgYmFja3dhcmRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCAhIW5lc3QuYnJhY2tldGVkLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvID8gW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0gOiBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIHx8ICFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIHJhbmdlcy5sZW5ndGggPyBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmVzdC5wYXJzZXIuc3RhcnRQYXJzZShcIlwiKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCAhIW5lc3QuYnJhY2tldGVkLCBjdXJzb3IudHJlZSwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1swXS5mcm9tIDogY3Vyc29yLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBvdmVybGF5LnJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA+PSAwICYmIG92ZXJsYXkucmFuZ2VzW2xhc3RdLnRvID09IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlc1tsYXN0XSA9IHsgZnJvbTogb3ZlcmxheS5yYW5nZXNbbGFzdF0uZnJvbSwgdG86IHJhbmdlLnRvIH07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRlciAmJiBjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJlZClcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5kZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSAmJiAhLS1vdmVybGF5LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG92ZXJsYXkucmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnNwbGljZShvdmVybGF5LmluZGV4LCAwLCBuZXcgSW5uZXJQYXJzZShvdmVybGF5LnBhcnNlciwgb3ZlcmxheS5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvdmVybGF5Lm1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKSwgb3ZlcmxheS5yYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIG92ZXJsYXkuc3RhcnQsIHIudG8gLSBvdmVybGF5LnN0YXJ0KSksIG92ZXJsYXkuYnJhY2tldGVkLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzWzBdLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIENvdmVyLkZ1bGwgKi8gOiAxIC8qIENvdmVyLlBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIENvdmVyLk5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gb2ZmKTtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSB0aGF0J3MgaW4gYSBidWZmZXIsIGFuZCBjb252ZXJ0cyBpdCwgYW5kXG4vLyBpdHMgcGFyZW50IGJ1ZmZlciBub2RlcywgaW50byBhIFRyZWUuIFRoaXMgaXMgYWdhaW4gYWN0aW5nIG9uIHRoZVxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXG4vLyBwYXJzZSB0aGF0IHdhcyByYW4gdmlhIHRoZSBtaXggcGFyc2VyLCBhbmQgdGh1cyBhcmVuJ3Qgc2hhcmVkIHdpdGhcbi8vIGFueSBvdGhlciBjb2RlLCBtYWtpbmcgdmlvbGF0aW9ucyBvZiB0aGUgaW1tdXRhYmlsaXR5IHNhZmUuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcbiAgICBsZXQgeyBub2RlIH0gPSBjdXJzb3IsIHN0YWNrID0gW107XG4gICAgbGV0IGJ1ZmZlciA9IG5vZGUuY29udGV4dC5idWZmZXI7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBzdGFjay5wdXNoKGN1cnNvci5pbmRleCk7XG4gICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgaW4gdGhhdCB0cmVlXG4gICAgbGV0IGJhc2UgPSBjdXJzb3IudHJlZSwgaSA9IGJhc2UuY2hpbGRyZW4uaW5kZXhPZihidWZmZXIpO1xuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlciwgbmV3U3RhY2sgPSBbaV07XG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgLy8gdGhlIGNoaWxkIHRoYXQgY29udGFpbnMgYG5vZGVgIGludG8gbmV3IGJ1ZmZlcnMuXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RhcnRJLCBlbmRJLCB0eXBlLCBpbm5lck9mZnNldCwgbGVuZ3RoLCBzdGFja1Bvcykge1xuICAgICAgICBsZXQgdGFyZ2V0SSA9IHN0YWNrW3N0YWNrUG9zXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgdGFyZ2V0SSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbdGFyZ2V0SSArIDFdLCB0byA9IGJbdGFyZ2V0SSArIDJdO1xuICAgICAgICBuZXdTdGFjay5wdXNoKGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGxldCBjaGlsZCA9IHN0YWNrUG9zXG4gICAgICAgICAgICA/IHNwbGl0KHRhcmdldEkgKyA0LCBiW3RhcmdldEkgKyAzXSwgYnVmLnNldC50eXBlc1tiW3RhcmdldEldXSwgZnJvbSwgdG8gLSBmcm9tLCBzdGFja1BvcyAtIDEpXG4gICAgICAgICAgICA6IG5vZGUudG9UcmVlKCk7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbdGFyZ2V0SSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgsIHN0YWNrLmxlbmd0aCAtIDEpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGluZGV4IG9mIG5ld1N0YWNrKSB7XG4gICAgICAgIGxldCB0cmVlID0gY3Vyc29yLnRyZWUuY2hpbGRyZW5baW5kZXhdLCBwb3MgPSBjdXJzb3IudHJlZS5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICBjdXJzb3IueWllbGQobmV3IFRyZWVOb2RlKHRyZWUsIHBvcyArIGN1cnNvci5mcm9tLCBpbmRleCwgY3Vyc29yLl90cmVlKSk7XG4gICAgfVxufVxuY2xhc3MgU3RydWN0dXJlQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRvIHRoZSBmaXJzdCBub2RlIChpbiBwcmUtb3JkZXIpIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIG1vdmVUbyhwb3MpIHtcbiAgICAgICAgbGV0IHsgY3Vyc29yIH0gPSB0aGlzLCBwID0gcG9zIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5kb25lICYmIGN1cnNvci5mcm9tIDwgcCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBwb3MgJiYgY3Vyc29yLmVudGVyKHAsIDEsIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzIHwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kUG9zIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IERlZmF1bHRCdWZmZXJMZW5ndGgsIEl0ZXJNb2RlLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBOb2RlV2Vha01hcCwgUGFyc2VyLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHBhcnNlTWl4ZWQgfTtcbiJdLCJuYW1lcyI6WyJEZWZhdWx0QnVmZmVyTGVuZ3RoIiwibmV4dFByb3BJRCIsIlJhbmdlIiwiY29uc3RydWN0b3IiLCJmcm9tIiwidG8iLCJOb2RlUHJvcCIsImNvbmZpZyIsImlkIiwicGVyTm9kZSIsImRlc2VyaWFsaXplIiwiRXJyb3IiLCJjb21iaW5lIiwiYWRkIiwibWF0Y2giLCJSYW5nZUVycm9yIiwiTm9kZVR5cGUiLCJ0eXBlIiwicmVzdWx0IiwidW5kZWZpbmVkIiwiY2xvc2VkQnkiLCJzdHIiLCJzcGxpdCIsIm9wZW5lZEJ5IiwiZ3JvdXAiLCJpc29sYXRlIiwidmFsdWUiLCJjb250ZXh0SGFzaCIsImxvb2tBaGVhZCIsIm1vdW50ZWQiLCJNb3VudGVkVHJlZSIsInRyZWUiLCJvdmVybGF5IiwicGFyc2VyIiwiYnJhY2tldGVkIiwiZ2V0IiwicHJvcHMiLCJub1Byb3BzIiwiT2JqZWN0IiwiY3JlYXRlIiwibmFtZSIsImZsYWdzIiwiZGVmaW5lIiwic3BlYyIsImxlbmd0aCIsInRvcCIsInNraXBwZWQiLCJlcnJvciIsInNyYyIsIkFycmF5IiwiaXNBcnJheSIsInByb3AiLCJpc1RvcCIsImlzU2tpcHBlZCIsImlzRXJyb3IiLCJpc0Fub255bW91cyIsImlzIiwiaW5kZXhPZiIsIm1hcCIsImRpcmVjdCIsIm5vZGUiLCJncm91cHMiLCJpIiwiZm91bmQiLCJub25lIiwiTm9kZVNldCIsInR5cGVzIiwiZXh0ZW5kIiwibmV3VHlwZXMiLCJuZXdQcm9wcyIsInNvdXJjZSIsImFzc2lnbiIsInB1c2giLCJDYWNoZWROb2RlIiwiV2Vha01hcCIsIkNhY2hlZElubmVyTm9kZSIsIkl0ZXJNb2RlIiwiVHJlZSIsImNoaWxkcmVuIiwicG9zaXRpb25zIiwidG9TdHJpbmciLCJjaCIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiY3Vyc29yIiwibW9kZSIsIlRyZWVDdXJzb3IiLCJ0b3BOb2RlIiwiY3Vyc29yQXQiLCJwb3MiLCJzaWRlIiwic2NvcGUiLCJtb3ZlVG8iLCJzZXQiLCJfdHJlZSIsIlRyZWVOb2RlIiwicmVzb2x2ZSIsInJlc29sdmVOb2RlIiwicmVzb2x2ZUlubmVyIiwicmVzb2x2ZVN0YWNrIiwic3RhY2tJdGVyYXRvciIsIml0ZXJhdGUiLCJlbnRlciIsImxlYXZlIiwiYW5vbiIsIkluY2x1ZGVBbm9ueW1vdXMiLCJjIiwiZW50ZXJlZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInBhcmVudCIsInByb3BWYWx1ZXMiLCJiYWxhbmNlIiwiYmFsYW5jZVJhbmdlIiwibWFrZVRyZWUiLCJidWlsZCIsImRhdGEiLCJidWlsZFRyZWUiLCJlbXB0eSIsIkZsYXRCdWZmZXJDdXJzb3IiLCJidWZmZXIiLCJpbmRleCIsInN0YXJ0IiwiZW5kIiwic2l6ZSIsIm5leHQiLCJmb3JrIiwiVHJlZUJ1ZmZlciIsImNoaWxkU3RyaW5nIiwiam9pbiIsImVuZEluZGV4IiwiZmluZENoaWxkIiwic3RhcnRJbmRleCIsImRpciIsInBpY2siLCJjaGVja1NpZGUiLCJzbGljZSIsInN0YXJ0SSIsImVuZEkiLCJiIiwiY29weSIsIlVpbnQxNkFycmF5IiwibGVuIiwiaiIsIk1hdGgiLCJtYXgiLCJvdmVybGF5cyIsIl9hIiwiSWdub3JlT3ZlcmxheXMiLCJzY2FuIiwiaW5uZXIiLCJCYXNlTm9kZSIsImdldENoaWxkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyIiwiZ2V0Q2hpbGRyZW4iLCJtYXRjaENvbnRleHQiLCJjb250ZXh0IiwibWF0Y2hOb2RlQ29udGV4dCIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwiY2hpbGRCZWZvcmUiLCJsYXN0IiwibGFzdENoaWxkIiwicHJldlNpYmxpbmciLCJfcGFyZW50IiwibmV4dENoaWxkIiwiZSIsIkVudGVyQnJhY2tldGVkIiwiRXhjbHVkZUJ1ZmZlcnMiLCJCdWZmZXJOb2RlIiwiQnVmZmVyQ29udGV4dCIsImhhc0NoaWxkIiwiSWdub3JlTW91bnRzIiwiY2hpbGRBZnRlciIsInJQb3MiLCJlbnRlckJyYWNrZXRlZCIsIm5leHRTaWduaWZpY2FudFBhcmVudCIsInZhbCIsInRvVHJlZSIsImN1ciIsInAiLCJjaGlsZCIsImV4dGVybmFsU2libGluZyIsInBhcmVudFN0YXJ0IiwiaXRlclN0YWNrIiwiaGVhZHMiLCJwaWNrZWQiLCJuZXdIZWFkcyIsInNwbGljZSIsIlN0YWNrSXRlcmF0b3IiLCJsYXllcnMiLCJtb3VudCIsInJvb3QiLCJzdGFjayIsImJ1ZmZlck5vZGUiLCJ5aWVsZE5vZGUiLCJuIiwidW5zaGlmdCIsInlpZWxkQnVmIiwieWllbGQiLCJlbnRlckNoaWxkIiwicG9wIiwic2libGluZyIsImQiLCJhdExhc3ROb2RlIiwibW92ZSIsInByZXYiLCJjYWNoZSIsImRlcHRoIiwibXVzdExlYXZlIiwic29tZSIsIm5vZGVTZXQiLCJtYXhCdWZmZXJMZW5ndGgiLCJyZXVzZWQiLCJtaW5SZXBlYXRUeXBlIiwidGFrZU5vZGUiLCJtaW5Qb3MiLCJpblJlcGVhdCIsImxvb2tBaGVhZEF0U3RhcnQiLCJjb250ZXh0QXRTdGFydCIsInN0YXJ0UG9zIiwiZmluZEJ1ZmZlclNpemUiLCJza2lwIiwiZW5kUG9zIiwiY29weVRvQnVmZmVyIiwibG9jYWxDaGlsZHJlbiIsImxvY2FsUG9zaXRpb25zIiwibG9jYWxJblJlcGVhdCIsImxhc3RHcm91cCIsImxhc3RFbmQiLCJtYWtlUmVwZWF0TGVhZiIsInRha2VGbGF0Tm9kZSIsInJldmVyc2UiLCJtYWtlIiwibWFrZUJhbGFuY2VkIiwibm9kZXMiLCJub2RlQ291bnQiLCJzdG9wQXQiLCJsYXN0SSIsImxvb2tBaGVhZFByb3AiLCJiYXNlIiwicGFpciIsImNvbmNhdCIsIm1heFNpemUiLCJtaW5TdGFydCIsIm5vZGVTaXplIiwibG9jYWxTa2lwcGVkIiwibm9kZVN0YXJ0IiwiYnVmZmVyU3RhcnQiLCJ0b3BJRCIsIm5vZGVTaXplQ2FjaGUiLCJiYWxhbmNlVHlwZSIsIm1rVG9wIiwibWtUcmVlIiwidG90YWwiLCJtYXhDaGlsZCIsImNlaWwiLCJkaXZpZGUiLCJvZmZzZXQiLCJncm91cEZyb20iLCJncm91cFN0YXJ0IiwiZ3JvdXBTaXplIiwibmV4dFNpemUiLCJvbmx5IiwiTm9kZVdlYWtNYXAiLCJzZXRCdWZmZXIiLCJNYXAiLCJnZXRCdWZmZXIiLCJjdXJzb3JTZXQiLCJjdXJzb3JHZXQiLCJUcmVlRnJhZ21lbnQiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib3BlbiIsImFkZFRyZWUiLCJmcmFnbWVudHMiLCJwYXJ0aWFsIiwiZiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJtaW5HYXAiLCJmSSIsIm5leHRGIiwiY0kiLCJvZmYiLCJuZXh0QyIsIm5leHRQb3MiLCJmcm9tQSIsImN1dCIsImZGcm9tIiwiZlRvIiwibWluIiwidG9BIiwidG9CIiwiUGFyc2VyIiwic3RhcnRQYXJzZSIsImlucHV0IiwicmFuZ2VzIiwiU3RyaW5nSW5wdXQiLCJjcmVhdGVQYXJzZSIsInBhcnNlIiwiZG9uZSIsImFkdmFuY2UiLCJzdHJpbmciLCJjaHVuayIsImxpbmVDaHVua3MiLCJyZWFkIiwicGFyc2VNaXhlZCIsIm5lc3QiLCJNaXhlZFBhcnNlIiwiSW5uZXJQYXJzZSIsInRhcmdldCIsImNoZWNrUmFuZ2VzIiwiQWN0aXZlT3ZlcmxheSIsInByZWRpY2F0ZSIsIm1vdW50cyIsInN0b3BwZWRJbm5lciIsImlubmVyRG9uZSIsImJhc2VUcmVlIiwic3RvcHBlZEF0IiwiYmFzZVBhcnNlIiwic3RhcnRJbm5lciIsInBhcnNlZFBvcyIsImZyYWdtZW50Q3Vyc29yIiwiRnJhZ21lbnRDdXJzb3IiLCJjb3ZlcmVkIiwiaXNDb3ZlcmVkIiwicmFuZ2UiLCJoYXNOb2RlIiwiZmluZCIsIm0iLCJmcmFnIiwiY2hlY2tDb3ZlciIsIm1hdGVyaWFsaXplIiwib2xkTW91bnRzIiwiZmluZE1vdW50cyIsInB1bmNoUmFuZ2VzIiwiZW50ZXJGcmFnbWVudHMiLCJzbGljZUJ1ZiIsImJ1ZiIsIm5ld1N0YWNrIiwiaW5uZXJPZmZzZXQiLCJzdGFja1BvcyIsInRhcmdldEkiLCJTdHJ1Y3R1cmVDdXJzb3IiLCJjdXJUbyIsImZyYWdJIiwiZmlyc3QiLCJjdXJGcmFnIiwibmV4dEZyYWciLCJvdXRlciIsImN1cnJlbnQiLCJnYXBGcm9tIiwiZ2FwVG8iLCJmaW5kQ292ZXJDaGFuZ2VzIiwiYSIsImlBIiwiaUIiLCJpbkEiLCJpbkIiLCJuZXh0QSIsIm5leHRCIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lezer+common@1.5.0/node_modules/@lezer/common/dist/index.js\n");

/***/ })

};
;