"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+view@6.39.11";
exports.ids = ["vendor-chunks/@codemirror+view@6.39.11"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@codemirror+view@6.39.11/node_modules/@codemirror/view/dist/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@codemirror+view@6.39.11/node_modules/@codemirror/view/dist/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),\n/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),\n/* harmony export */   BlockType: () => (/* binding */ BlockType),\n/* harmony export */   BlockWrapper: () => (/* binding */ BlockWrapper),\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   Direction: () => (/* binding */ Direction),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),\n/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),\n/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),\n/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),\n/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),\n/* harmony export */   WidgetType: () => (/* binding */ WidgetType),\n/* harmony export */   __test: () => (/* binding */ __test),\n/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),\n/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),\n/* harmony export */   drawSelection: () => (/* binding */ drawSelection),\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor),\n/* harmony export */   getDialog: () => (/* binding */ getDialog),\n/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),\n/* harmony export */   getPanel: () => (/* binding */ getPanel),\n/* harmony export */   getTooltip: () => (/* binding */ getTooltip),\n/* harmony export */   gutter: () => (/* binding */ gutter),\n/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),\n/* harmony export */   gutterWidgetClass: () => (/* binding */ gutterWidgetClass),\n/* harmony export */   gutters: () => (/* binding */ gutters),\n/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),\n/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),\n/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),\n/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),\n/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),\n/* harmony export */   keymap: () => (/* binding */ keymap),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),\n/* harmony export */   lineNumberWidgetMarker: () => (/* binding */ lineNumberWidgetMarker),\n/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),\n/* harmony export */   logException: () => (/* binding */ logException),\n/* harmony export */   panels: () => (/* binding */ panels),\n/* harmony export */   placeholder: () => (/* binding */ placeholder),\n/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),\n/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),\n/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),\n/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),\n/* harmony export */   showDialog: () => (/* binding */ showDialog),\n/* harmony export */   showPanel: () => (/* binding */ showPanel),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   tooltips: () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/.pnpm/@codemirror+state@6.5.4/node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/.pnpm/style-mod@4.1.3/node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"(ssr)/./node_modules/.pnpm/w3c-keyname@2.2.8/node_modules/w3c-keyname/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/.pnpm/crelt@1.0.6/node_modules/crelt/index.js\");\n\n\n\n\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n    userAgent: \"\",\n    vendor: \"\",\n    platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n    documentElement: {\n        style: {}\n    }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && /*@__PURE__*/ (/Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n    mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n    windows: /*@__PURE__*/ /Win/.test(nav.platform),\n    linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +/*@__PURE__*/ (/Firefox\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios,\n    android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n    webkit,\n    webkit_version: webkit ? +/*@__PURE__*/ (/\\bAppleWebKit\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    safari,\n    safari_version: safari ? +/*@__PURE__*/ (/\\bVersion\\/(\\d+(\\.\\d+)?)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nfunction combineAttrs(source, target) {\n    for(let name in source){\n        if (name == \"class\" && target.class) target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style) target.style += \";\" + source.style;\n        else target[name] = source[name];\n    }\n    return target;\n}\nconst noAttrs = /*@__PURE__*/ Object.create(null);\nfunction attrsEq(a, b, ignore) {\n    if (a == b) return true;\n    if (!a) a = noAttrs;\n    if (!b) b = noAttrs;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;\n    for (let key of keysA){\n        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;\n    }\n    return true;\n}\nfunction setAttrs(dom, attrs) {\n    for(let i = dom.attributes.length - 1; i >= 0; i--){\n        let name = dom.attributes[i].name;\n        if (attrs[name] == null) dom.removeAttribute(name);\n    }\n    for(let name in attrs){\n        let value = attrs[name];\n        if (name == \"style\") dom.style.cssText = value;\n        else if (dom.getAttribute(name) != value) dom.setAttribute(name, value);\n    }\n}\nfunction updateAttrs(dom, prev, attrs) {\n    let changed = false;\n    if (prev) {\n        for(let name in prev)if (!(attrs && name in attrs)) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = \"\";\n            else dom.removeAttribute(name);\n        }\n    }\n    if (attrs) {\n        for(let name in attrs)if (!(prev && prev[name] == attrs[name])) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    return changed;\n}\nfunction getAttrs(dom) {\n    let attrs = Object.create(null);\n    for(let i = 0; i < dom.attributes.length; i++){\n        let attr = dom.attributes[i];\n        attrs[attr.name] = attr.value;\n    }\n    return attrs;\n}\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/ class WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */ eq(widget) {\n        return false;\n    }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */ updateDOM(dom, view) {\n        return false;\n    }\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */ get estimatedHeight() {\n        return -1;\n    }\n    /**\n    For inline widgets that are displayed inline (as opposed to\n    `inline-block`) and introduce line breaks (through `<br>` tags\n    or textual newlines), this must indicate the amount of line\n    breaks they introduce. Defaults to 0.\n    */ get lineBreaks() {\n        return 0;\n    }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */ ignoreEvent(event) {\n        return true;\n    }\n    /**\n    Override the way screen coordinates for positions at/in the\n    widget are found. `pos` will be the offset into the widget, and\n    `side` the side of the position that is being queriedâ€”less than\n    zero for before, greater than zero for after, and zero for\n    directly at that position.\n    */ coordsAt(dom, pos, side) {\n        return null;\n    }\n    /**\n    @internal\n    */ get isHidden() {\n        return false;\n    }\n    /**\n    @internal\n    */ get editable() {\n        return false;\n    }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */ destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/ var BlockType = /*@__PURE__*/ function(BlockType) {\n    /**\n    A line of text.\n    */ BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */ BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */ BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */ BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n    return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/ class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeValue {\n    constructor(/**\n    @internal\n    */ startSide, /**\n    @internal\n    */ endSide, /**\n    @internal\n    */ widget, /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */ spec){\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */ get heightRelevant() {\n        return false;\n    }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n    the higher-precedence decorations creating the inner DOM nodes.\n    Such elements are split on line boundaries and on the boundaries\n    of lower-precedence decorations.\n    */ static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which displays a DOM element at the\n    given position.\n    */ static widget(spec) {\n        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;\n        side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */  : -400000000 /* Side.BlockBefore */  : side > 0 ? 100000000 /* Side.InlineAfter */  : -100000000 /* Side.InlineBefore */ ;\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */ static replace(spec) {\n        let block = !!spec.block, startSide, endSide;\n        if (spec.isBlockGap) {\n            startSide = -500000000 /* Side.GapStart */ ;\n            endSide = 400000000 /* Side.GapEnd */ ;\n        } else {\n            let { start, end } = getInclusive(spec, block);\n            startSide = (start ? block ? -300000000 /* Side.BlockIncStart */  : -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ ) - 1;\n            endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */  : 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ ) + 1;\n        }\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */ static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */ static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */ hasHeight() {\n        return this.widget ? this.widget.estimatedHeight > -1 : false;\n    }\n}\n/**\nThe empty set of decorations.\n*/ Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec){\n        let { start, end } = getInclusive(spec);\n        super(start ? -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ , end ? 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ , null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.attrs = spec.class && spec.attributes ? combineAttrs(spec.attributes, {\n            class: spec.class\n        }) : spec.class ? {\n            class: spec.class\n        } : spec.attributes || noAttrs;\n    }\n    eq(other) {\n        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && attrsEq(this.attrs, other.attrs);\n    }\n    range(from, to = from) {\n        if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec){\n        super(-200000000 /* Side.Line */ , -200000000 /* Side.Line */ , null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace){\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() {\n        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n    }\n    eq(other) {\n        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null) start = spec.inclusive;\n    if (end == null) end = spec.inclusive;\n    return {\n        start: start !== null && start !== void 0 ? start : block,\n        end: end !== null && end !== void 0 ? end : block\n    };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);\n    else ranges.push(from, to);\n}\n/**\nA block wrapper defines a DOM node that wraps lines or other block\nwrappers at the top of the document. It affects any line or block\nwidget that starts inside its range, including blocks starting\ndirectly at `from` but not including `to`.\n*/ class BlockWrapper extends _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeValue {\n    constructor(tagName, attributes){\n        super();\n        this.tagName = tagName;\n        this.attributes = attributes;\n    }\n    eq(other) {\n        return other == this || other instanceof BlockWrapper && this.tagName == other.tagName && attrsEq(this.attributes, other.attributes);\n    }\n    /**\n    Create a block wrapper object with the given tag name and\n    attributes.\n    */ static create(spec) {\n        return new BlockWrapper(spec.tagName, spec.attributes || noAttrs);\n    }\n    /**\n    Create a range set from the given block wrapper ranges.\n    */ static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.of(of, sort);\n    }\n}\nBlockWrapper.prototype.startSide = BlockWrapper.prototype.endSide = -1;\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) {\n        target = root.getSelection ? root : root.ownerDocument;\n    } else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    } catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1) return dom.getClientRects();\n    else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\") return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1) return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return {\n        left: x,\n        right: x,\n        top: rect.top,\n        bottom: rect.bottom\n    };\n}\nfunction windowRect(win) {\n    let vp = win.visualViewport;\n    if (vp) return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n    };\n    return {\n        left: 0,\n        right: win.innerWidth,\n        top: 0,\n        bottom: win.innerHeight\n    };\n}\nfunction getScale(elt, rect) {\n    let scaleX = rect.width / elt.offsetWidth;\n    let scaleY = rect.height / elt.offsetHeight;\n    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;\n    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;\n    return {\n        scaleX,\n        scaleY\n    };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    for(let cur = dom, stop = false; cur && !stop;){\n        if (cur.nodeType == 1) {\n            let bounding, top = cur == doc.body;\n            let scaleX = 1, scaleY = 1;\n            if (top) {\n                bounding = windowRect(win);\n            } else {\n                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.assignedSlot || cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                ({ scaleX, scaleY } = getScale(cur, rect));\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = {\n                    left: rect.left,\n                    right: rect.left + cur.clientWidth * scaleX,\n                    top: rect.top,\n                    bottom: rect.top + cur.clientHeight * scaleY\n                };\n            }\n            let moveX = 0, moveY = 0;\n            if (y == \"nearest\") {\n                if (rect.top < bounding.top) {\n                    moveY = rect.top - (bounding.top + yMargin);\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + yMargin;\n                } else if (rect.bottom > bounding.bottom) {\n                    moveY = rect.bottom - bounding.bottom + yMargin;\n                    if (side < 0 && rect.top - moveY < bounding.top) moveY = rect.top - (bounding.top + yMargin);\n                }\n            } else {\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n                moveY = targetTop - bounding.top;\n            }\n            if (x == \"nearest\") {\n                if (rect.left < bounding.left) {\n                    moveX = rect.left - (bounding.left + xMargin);\n                    if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + xMargin;\n                } else if (rect.right > bounding.right) {\n                    moveX = rect.right - bounding.right + xMargin;\n                    if (side < 0 && rect.left < bounding.left + moveX) moveX = rect.left - (bounding.left + xMargin);\n                }\n            } else {\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n                moveX = targetLeft - bounding.left;\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                } else {\n                    let movedX = 0, movedY = 0;\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY / scaleY;\n                        movedY = (cur.scrollTop - start) * scaleY;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX / scaleX;\n                        movedX = (cur.scrollLeft - start) * scaleX;\n                    }\n                    rect = {\n                        left: rect.left - movedX,\n                        top: rect.top - movedY,\n                        right: rect.right - movedX,\n                        bottom: rect.bottom - movedY\n                    };\n                    if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n                    if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n                }\n            }\n            if (top) break;\n            if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right) rect = {\n                left: Math.max(rect.left, bounding.left),\n                right: Math.min(rect.right, bounding.right),\n                top: Math.max(rect.top, bounding.top),\n                bottom: Math.min(rect.bottom, bounding.bottom)\n            };\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n}\nfunction scrollableParents(dom) {\n    let doc = dom.ownerDocument, x, y;\n    for(let cur = dom.parentNode; cur;){\n        if (cur == doc.body || x && y) {\n            break;\n        } else if (cur.nodeType == 1) {\n            if (!y && cur.scrollHeight > cur.clientHeight) y = cur;\n            if (!x && cur.scrollWidth > cur.clientWidth) x = cur;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        x,\n        y\n    };\n}\nclass DOMSelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    setRange(range) {\n        let { anchorNode, focusNode } = range;\n        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n    }\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\n        this.anchorNode = anchorNode;\n        this.anchorOffset = anchorOffset;\n        this.focusNode = focusNode;\n        this.focusOffset = focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Safari 26 breaks preventScroll support\nif (browser.safari && browser.safari_version >= 26) preventScrollSupported = false;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stack = [];\n    for(let cur = dom; cur; cur = cur.parentNode){\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument) break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for(let i = 0; i < stack.length;){\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top) elt.scrollTop = top;\n            if (elt.scrollLeft != left) elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code, mods) {\n    let options = {\n        key: name,\n        code: name,\n        keyCode: code,\n        which: code,\n        cancelable: true\n    };\n    if (mods) ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n    while(node){\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n        node = node.assignedSlot || node.parentNode;\n    }\n    return null;\n}\nfunction atElementStart(doc, selection) {\n    let node = selection.focusNode, offset = selection.focusOffset;\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n    // Safari can report bogus offsets (#1152)\n    offset = Math.min(offset, maxOffset(node));\n    for(;;){\n        if (offset) {\n            if (node.nodeType != 1) return false;\n            let prev = node.childNodes[offset - 1];\n            if (prev.contentEditable == \"false\") offset--;\n            else {\n                node = prev;\n                offset = maxOffset(node);\n            }\n        } else if (node == doc) {\n            return true;\n        } else {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n    }\n}\nfunction isScrolledToBottom(elt) {\n    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\nfunction textNodeBefore(startNode, startOffset) {\n    for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3 && offset > 0) {\n            return {\n                node: node,\n                offset: offset\n            };\n        } else if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        } else if (node.parentNode && !isBlockElement(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter(startNode, startOffset) {\n    for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3 && offset < node.nodeValue.length) {\n            return {\n                node: node,\n                offset: offset\n            };\n        } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        } else if (node.parentNode && !isBlockElement(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nclass DOMPos {\n    constructor(node, offset, precise = true){\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom), precise);\n    }\n    static after(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n    }\n}\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/ var Direction = /*@__PURE__*/ function(Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */ Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */ Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n    return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for(let i = 0; i < str.length; i++)result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/ dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/ dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/ Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\n    \"()\",\n    \"[]\",\n    \"{}\"\n]){\n    let l = /*@__PURE__*/ p.charCodeAt(0), r = /*@__PURE__*/ p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */  : 0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */  : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */  : 1 /* T.L */ ;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/ class BidiSpan {\n    /**\n    The direction of this span.\n    */ get dir() {\n        return this.level % 2 ? RTL : LTR;\n    }\n    /**\n    @internal\n    */ constructor(/**\n    The start of the span (relative to the start of the line).\n    */ from, /**\n    The end of the span.\n    */ to, /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */ level){\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    @internal\n    */ side(end, dir) {\n        return this.dir == dir == end ? this.to : this.from;\n    }\n    /**\n    @internal\n    */ forward(forward, dir) {\n        return forward == (this.dir == dir);\n    }\n    /**\n    @internal\n    */ static find(order, index, level, assoc) {\n        let maybe = -1;\n        for(let i = 0; i < order.length; i++){\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level) return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n            }\n        }\n        if (maybe < 0) throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\nfunction isolatesEq(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        let iA = a[i], iB = b[i];\n        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;\n    }\n    return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n    for(let iI = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        let prevType = iI ? 256 /* T.NI */  : outerType;\n        // W1. Examine each non-spacing mark (NSM) in the level run, and\n        // change the type of the NSM to the type of the previous\n        // character. If the NSM is at the start of the level run, it will\n        // get the type of sor.\n        // W2. Search backwards from each instance of a European number\n        // until the first strong type (R, L, AL, or sor) is found. If an\n        // AL is found, change the type of the European number to Arabic\n        // number.\n        // W3. Change all ALs to R.\n        // (Left after this: L, R, EN, AN, ET, CS, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = charType(line.charCodeAt(i));\n            if (type == 512 /* T.NSM */ ) type = prev;\n            else if (type == 8 /* T.EN */  && prevStrong == 4 /* T.AL */ ) type = 16 /* T.AN */ ;\n            types[i] = type == 4 /* T.AL */  ? 2 /* T.R */  : type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n            prev = type;\n        }\n        // W5. A sequence of European terminators adjacent to European\n        // numbers changes to all European numbers.\n        // W6. Otherwise, separators and terminators change to Other\n        // Neutral.\n        // W7. Search backwards from each instance of a European number\n        // until the first strong type (R, L, or sor) is found. If an L is\n        // found, then change the type of the European number to L.\n        // (Left after this: L, R, EN+AN, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = types[i];\n            if (type == 128 /* T.CS */ ) {\n                if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */ ) type = types[i] = prev;\n                else types[i] = 256 /* T.NI */ ;\n            } else if (type == 64 /* T.ET */ ) {\n                let end = i + 1;\n                while(end < to && types[end] == 64 /* T.ET */ )end++;\n                let replace = i && prev == 8 /* T.EN */  || end < rTo && types[end] == 8 /* T.EN */  ? prevStrong == 1 /* T.L */  ? 1 /* T.L */  : 8 /* T.EN */  : 256 /* T.NI */ ;\n                for(let j = i; j < end; j++)types[j] = replace;\n                i = end - 1;\n            } else if (type == 8 /* T.EN */  && prevStrong == 1 /* T.L */ ) {\n                types[i] = 1 /* T.L */ ;\n            }\n            prev = type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n        }\n    }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n    let oppositeType = outerType == 1 /* T.L */  ? 2 /* T.R */  : 1 /* T.L */ ;\n    for(let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N0. Process bracket pairs in an isolating run sequence\n        // sequentially in the logical order of the text positions of the\n        // opening paired brackets using the logic given below. Within this\n        // scope, bidirectional types EN and AN are treated as R.\n        for(let i = from, ch, br, type; i < to; i++){\n            // Keeps [startIndex, type, strongSeen] triples for each open\n            // bracket on BracketStack.\n            if (br = Brackets[ch = line.charCodeAt(i)]) {\n                if (br < 0) {\n                    for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                        if (BracketStack[sJ + 1] == -br) {\n                            let flags = BracketStack[sJ + 2];\n                            let type = flags & 2 /* Bracketed.EmbedInside */  ? outerType : !(flags & 4 /* Bracketed.OppositeInside */ ) ? 0 : flags & 1 /* Bracketed.OppositeBefore */  ? oppositeType : outerType;\n                            if (type) types[i] = types[BracketStack[sJ]] = type;\n                            sI = sJ;\n                            break;\n                        }\n                    }\n                } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */ ) {\n                    break;\n                } else {\n                    BracketStack[sI++] = i;\n                    BracketStack[sI++] = ch;\n                    BracketStack[sI++] = context;\n                }\n            } else if ((type = types[i]) == 2 /* T.R */  || type == 1 /* T.L */ ) {\n                let embed = type == outerType;\n                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */ ;\n                for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                    let cur = BracketStack[sJ + 2];\n                    if (cur & 2 /* Bracketed.EmbedInside */ ) break;\n                    if (embed) {\n                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */ ;\n                    } else {\n                        if (cur & 4 /* Bracketed.OppositeInside */ ) break;\n                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */ ;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n    for(let iI = 0, prev = outerType; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N1. A sequence of neutrals takes the direction of the\n        // surrounding strong text if the text on both sides has the same\n        // direction. European and Arabic numbers act as if they were R in\n        // terms of their influence on neutrals. Start-of-level-run (sor)\n        // and end-of-level-run (eor) are used at level run boundaries.\n        // N2. Any remaining neutrals take the embedding direction.\n        // (Left after this: L, R, EN+AN)\n        for(let i = from; i < to;){\n            let type = types[i];\n            if (type == 256 /* T.NI */ ) {\n                let end = i + 1;\n                for(;;){\n                    if (end == to) {\n                        if (iI == isolates.length) break;\n                        end = isolates[iI++].to;\n                        to = iI < isolates.length ? isolates[iI].from : rTo;\n                    } else if (types[end] == 256 /* T.NI */ ) {\n                        end++;\n                    } else {\n                        break;\n                    }\n                }\n                let beforeL = prev == 1 /* T.L */ ;\n                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */ ;\n                let replace = beforeL == afterL ? beforeL ? 1 /* T.L */  : 2 /* T.R */  : outerType;\n                for(let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;){\n                    if (j == fromJ) {\n                        j = isolates[--jI].from;\n                        fromJ = jI ? isolates[jI - 1].to : rFrom;\n                    }\n                    types[--j] = replace;\n                }\n                i = end;\n            } else {\n                prev = type;\n                i++;\n            }\n        }\n    }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n    let ourType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    if (level % 2 == baseLevel % 2) {\n        for(let iCh = from, iI = 0; iCh < to;){\n            // Scan a section of characters in direction ourType, unless\n            // there's another type of char right after iCh, in which case\n            // we scan a section of other characters (which, if ourType ==\n            // T.L, may contain both T.R and T.AN chars).\n            let sameDir = true, isNum = false;\n            if (iI == isolates.length || iCh < isolates[iI].from) {\n                let next = types[iCh];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            // Holds an array of isolates to pass to a recursive call if we\n            // must recurse (to distinguish T.AN inside an RTL section in\n            // LTR text), null if we can emit directly\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI < isolates.length && iScan == isolates[iI].from) {\n                    if (isNum) break run;\n                    let iso = isolates[iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.to, jI = iI + 1;;){\n                        if (upto == to) break run;\n                        if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;\n                        else if (types[upto] == ourType) break run;\n                        else break;\n                    }\n                    iI++;\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.to;\n                    }\n                    iScan = iso.to;\n                } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n                    break;\n                } else {\n                    iScan++;\n                }\n            }\n            if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);\n            else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));\n            iCh = iScan;\n        }\n    } else {\n        // Iterate in reverse to flip the span order. Same code again, but\n        // going from the back of the section to the front\n        for(let iCh = to, iI = isolates.length; iCh > from;){\n            let sameDir = true, isNum = false;\n            if (!iI || iCh > isolates[iI - 1].to) {\n                let next = types[iCh - 1];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI && iScan == isolates[iI - 1].to) {\n                    if (isNum) break run;\n                    let iso = isolates[--iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.from, jI = iI;;){\n                        if (upto == from) break run;\n                        if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;\n                        else if (types[upto - 1] == ourType) break run;\n                        else break;\n                    }\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.from;\n                    }\n                    iScan = iso.from;\n                } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n                    break;\n                } else {\n                    iScan--;\n                }\n            }\n            if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);\n            else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));\n            iCh = iScan;\n        }\n    }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n    let outerType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    computeCharTypes(line, from, to, isolates, outerType);\n    processBracketPairs(line, from, to, isolates, outerType);\n    processNeutrals(from, to, isolates, outerType);\n    emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n    if (!line) return [\n        new BidiSpan(0, 0, direction == RTL ? 1 : 0)\n    ];\n    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);\n    if (isolates.length) while(line.length > types.length)types[types.length] = 256 /* T.NI */ ; // Make sure types array has no gaps\n    let order = [], level = direction == LTR ? 0 : 1;\n    computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n    return order;\n}\nfunction trivialOrder(length) {\n    return [\n        new BidiSpan(0, length, 0)\n    ];\n}\nlet movedOver = \"\";\n// This implementation moves strictly visually, without concern for a\n// traversal visiting every logical position in the string. It will\n// still do so for simple input, but situations like multiple isolates\n// with the same level next to each other, or text going against the\n// main dir at the end of the line, will make some positions\n// unreachable with this motion. Each visible cursor position will\n// correspond to the lower-level bidi span that touches it.\n//\n// The alternative would be to solve an order globally for a given\n// line, making sure that it includes every position, but that would\n// require associating non-canonical (higher bidi span level)\n// positions with a given visual position, which is likely to confuse\n// people. (And would generally be a lot more complicated.)\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from;\n    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI], spanEnd = span.side(forward, dir);\n    // End of span\n    if (startIndex == spanEnd) {\n        let nextI = spanI += forward ? 1 : -1;\n        if (nextI < 0 || nextI >= order.length) return null;\n        span = order[spanI = nextI];\n        startIndex = span.side(!forward, dir);\n        spanEnd = span.side(forward, dir);\n    }\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));\n    if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);\n}\nfunction autoDirection(text, from, to) {\n    for(let i = from; i < to; i++){\n        let type = charType(text.charCodeAt(i));\n        if (type == 1 /* T.L */ ) return LTR;\n        if (type == 2 /* T.R */  || type == 4 /* T.AL */ ) return RTL;\n    }\n    return LTR;\n}\nconst clickAddsSelectionRange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst exceptionSink = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst updateListener = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst inputHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst clipboardInputFilter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst clipboardOutputFilter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst scrollHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nclass ScrollTarget {\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5, // This data structure is abused to also store precise scroll\n    // snapshots, instead of a `scrollIntoView` request. When this\n    // flag is `true`, `range` points at a position in the reference\n    // line, `yMargin` holds the difference between the top of that\n    // line and the top of the editor, and `xMargin` holds the\n    // editor's `scrollLeft`.\n    isSnapshot = false){\n        this.range = range;\n        this.y = y;\n        this.x = x;\n        this.yMargin = yMargin;\n        this.xMargin = xMargin;\n        this.isSnapshot = isSnapshot;\n    }\n    map(changes) {\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n    clip(state) {\n        return this.range.to <= state.doc.length ? this : new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n}\nconst scrollIntoView = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: (t, ch)=>t.map(ch)\n});\nconst setEditContextFormatting = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/ function logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length) handler[0](exception);\n    else if (window.onerror && window.onerror(String(exception), context, undefined, undefined, exception)) ;\n    else if (context) console.error(context + \":\", exception);\n    else console.error(exception);\n}\nconst editable = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (plugins) {\n        return plugins.filter((p, i)=>{\n            for(let j = 0; j < i; j++)if (plugins[j].plugin == p.plugin) return false;\n            return true;\n        });\n    }\n});\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view. They optionally take an argument, in\nwhich case you need to call [`of`](https://codemirror.net/6/docs/ref/#view.ViewPlugin.of) to create\nan extension for the plugin. When the argument type is undefined,\nyou can use the plugin instance as an extension directly.\n*/ class ViewPlugin {\n    constructor(/**\n    @internal\n    */ id, /**\n    @internal\n    */ create, /**\n    @internal\n    */ domEventHandlers, /**\n    @internal\n    */ domEventObservers, buildExtensions){\n        this.id = id;\n        this.create = create;\n        this.domEventHandlers = domEventHandlers;\n        this.domEventObservers = domEventObservers;\n        this.baseExtensions = buildExtensions(this);\n        this.extension = this.baseExtensions.concat(viewPlugin.of({\n            plugin: this,\n            arg: undefined\n        }));\n    }\n    /**\n    Create an extension for this plugin with the given argument.\n    */ of(arg) {\n        return this.baseExtensions.concat(viewPlugin.of({\n            plugin: this,\n            arg\n        }));\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */ static define(create, spec) {\n        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin)=>{\n            let ext = [];\n            if (deco) ext.push(decorations.of((view)=>{\n                let pluginInst = view.plugin(plugin);\n                return pluginInst ? deco(pluginInst) : Decoration.none;\n            }));\n            if (provide) ext.push(provide(plugin));\n            return ext;\n        });\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */ static fromClass(cls, spec) {\n        return ViewPlugin.define((view, arg)=>new cls(view, arg), spec);\n    }\n}\nclass PluginInstance {\n    constructor(spec){\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `null`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    get plugin() {\n        return this.spec && this.spec.plugin;\n    }\n    update(view) {\n        if (!this.value) {\n            if (this.spec) {\n                try {\n                    this.value = this.spec.plugin.create(view, this.spec.arg);\n                } catch (e) {\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\n                    this.deactivate();\n                }\n            }\n        } else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (this.value.update) {\n                try {\n                    this.value.update(update);\n                } catch (e) {\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\n                    if (this.value.destroy) try {\n                        this.value.destroy();\n                    } catch (_) {}\n                    this.deactivate();\n                }\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            } catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n    deactivate() {\n        this.spec = this.value = null;\n    }\n}\nconst editorAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst contentAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst blockWrappers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst outerDecorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst atomicRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nfunction getIsolatedRanges(view, line) {\n    let isolates = view.state.facet(bidiIsolatedRanges);\n    if (!isolates.length) return isolates;\n    let sets = isolates.map((i)=>i instanceof Function ? i(view) : i);\n    let result = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(sets, line.from, line.to, {\n        point () {},\n        span (fromDoc, toDoc, active, open) {\n            let from = fromDoc - line.from, to = toDoc - line.from;\n            let level = result;\n            for(let i = active.length - 1; i >= 0; i--, open--){\n                let direction = active[i].spec.bidiIsolate, update;\n                if (direction == null) direction = autoDirection(line.text, from, to);\n                if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {\n                    update.to = to;\n                    level = update.inner;\n                } else {\n                    let add = {\n                        from,\n                        to,\n                        direction,\n                        inner: []\n                    };\n                    level.push(add);\n                    level = add.inner;\n                }\n            }\n        }\n    });\n    return result;\n}\nconst scrollMargins = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nfunction getScrollMargins(view) {\n    let left = 0, right = 0, top = 0, bottom = 0;\n    for (let source of view.state.facet(scrollMargins)){\n        let m = source(view);\n        if (m) {\n            if (m.left != null) left = Math.max(left, m.left);\n            if (m.right != null) right = Math.max(right, m.right);\n            if (m.top != null) top = Math.max(top, m.top);\n            if (m.bottom != null) bottom = Math.max(bottom, m.bottom);\n        }\n    }\n    return {\n        left,\n        right,\n        top,\n        bottom\n    };\n}\nconst styleModule = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB){\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for(; i > 0; i--){\n            let range = set[i - 1];\n            if (range.fromA > me.toA) continue;\n            if (range.toA < me.fromA) break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    // Extend a set to cover all the content in `ranges`, which is a\n    // flat array with each pair of numbers representing fromB/toB\n    // positions. These pairs are generated in unchanged ranges, so the\n    // offset between doc A and doc B is the same for their start and\n    // end points.\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0) return diff;\n        let result = [];\n        for(let dI = 0, rI = 0, off = 0;;){\n            let nextD = dI < diff.length ? diff[dI].fromB : 1e9;\n            let nextR = rI < ranges.length ? ranges[rI] : 1e9;\n            let fromB = Math.min(nextD, nextR);\n            if (fromB == 1e9) break;\n            let fromA = fromB + off, toB = fromB, toA = fromA;\n            for(;;){\n                if (rI < ranges.length && ranges[rI] <= toB) {\n                    let end = ranges[rI + 1];\n                    rI += 2;\n                    toB = Math.max(toB, end);\n                    for(let i = dI; i < diff.length && diff[i].fromB <= toB; i++)off = diff[i].toA - diff[i].toB;\n                    toA = Math.max(toA, end + off);\n                } else if (dI < diff.length && diff[dI].fromB <= toB) {\n                    let next = diff[dI++];\n                    toB = Math.max(toB, next.toB);\n                    toA = Math.max(toA, next.toA);\n                    off = next.toA - next.toB;\n                } else {\n                    break;\n                }\n            }\n            result.push(new ChangedRange(fromA, toA, fromB, toB));\n        }\n        return result;\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/ class ViewUpdate {\n    constructor(/**\n    The editor view that the update is associated with.\n    */ view, /**\n    The new editor state.\n    */ state, /**\n    The transactions involved in the update. May be empty.\n    */ transactions){\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */ this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB)=>changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n    }\n    /**\n    @internal\n    */ static create(view, state, transactions) {\n        return new ViewUpdate(view, state, transactions);\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */ get viewportChanged() {\n        return (this.flags & 4 /* UpdateFlag.Viewport */ ) > 0;\n    }\n    /**\n    Returns true when\n    [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true\n    and the viewport change is not just the result of mapping it in\n    response to document changes.\n    */ get viewportMoved() {\n        return (this.flags & 8 /* UpdateFlag.ViewportMoved */ ) > 0;\n    }\n    /**\n    Indicates whether the height of a block element in the editor\n    changed in this update.\n    */ get heightChanged() {\n        return (this.flags & 2 /* UpdateFlag.Height */ ) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */ get geometryChanged() {\n        return this.docChanged || (this.flags & (16 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ )) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */ get focusChanged() {\n        return (this.flags & 1 /* UpdateFlag.Focus */ ) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */ get selectionSet() {\n        return this.transactions.some((tr)=>tr.selection);\n    }\n    /**\n    @internal\n    */ get empty() {\n        return this.flags == 0 && this.transactions.length == 0;\n    }\n}\nconst noChildren = [];\nclass Tile {\n    constructor(dom, length, flags = 0){\n        this.dom = dom;\n        this.length = length;\n        this.flags = flags;\n        this.parent = null;\n        dom.cmTile = this;\n    }\n    get breakAfter() {\n        return this.flags & 1 /* TileFlag.BreakAfter */ ;\n    }\n    get children() {\n        return noChildren;\n    }\n    isWidget() {\n        return false;\n    }\n    get isHidden() {\n        return false;\n    }\n    isComposite() {\n        return false;\n    }\n    isLine() {\n        return false;\n    }\n    isText() {\n        return false;\n    }\n    isBlock() {\n        return false;\n    }\n    get domAttrs() {\n        return null;\n    }\n    sync(track) {\n        this.flags |= 2 /* TileFlag.Synced */ ;\n        if (this.flags & 4 /* TileFlag.AttrsDirty */ ) {\n            this.flags &= ~4 /* TileFlag.AttrsDirty */ ;\n            let attrs = this.domAttrs;\n            if (attrs) setAttrs(this.dom, attrs);\n        }\n    }\n    toString() {\n        return this.constructor.name + (this.children.length ? `(${this.children})` : \"\") + (this.breakAfter ? \"#\" : \"\");\n    }\n    destroy() {\n        this.parent = null;\n    }\n    setDOM(dom) {\n        this.dom = dom;\n        dom.cmTile = this;\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(tile, start = this.posAtStart) {\n        let pos = start;\n        for (let child of this.children){\n            if (child == tile) return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(tile) {\n        return this.posBefore(tile) + tile.length;\n    }\n    covers(side) {\n        return true;\n    }\n    coordsIn(pos, side) {\n        return null;\n    }\n    domPosFor(off, side) {\n        let index = domIndex(this.dom);\n        let after = this.length ? off > 0 : side > 0;\n        return new DOMPos(this.parent.dom, index + (after ? 1 : 0), off == 0 || off == this.length);\n    }\n    markDirty(attrs) {\n        this.flags &= ~2 /* TileFlag.Synced */ ;\n        if (attrs) this.flags |= 4 /* TileFlag.AttrsDirty */ ;\n        if (this.parent && this.parent.flags & 2 /* TileFlag.Synced */ ) this.parent.markDirty(false);\n    }\n    get overrideDOMText() {\n        return null;\n    }\n    get root() {\n        for(let t = this; t; t = t.parent)if (t instanceof DocTile) return t;\n        return null;\n    }\n    static get(dom) {\n        return dom.cmTile;\n    }\n}\nclass CompositeTile extends Tile {\n    constructor(dom){\n        super(dom, 0);\n        this._children = [];\n    }\n    isComposite() {\n        return true;\n    }\n    get children() {\n        return this._children;\n    }\n    get lastChild() {\n        return this.children.length ? this.children[this.children.length - 1] : null;\n    }\n    append(child) {\n        this.children.push(child);\n        child.parent = this;\n    }\n    sync(track) {\n        if (this.flags & 2 /* TileFlag.Synced */ ) return;\n        super.sync(track);\n        let parent = this.dom, prev = null, next;\n        let tracking = (track === null || track === void 0 ? void 0 : track.node) == parent ? track : null;\n        let length = 0;\n        for (let child of this.children){\n            child.sync(track);\n            length += child.length + child.breakAfter;\n            next = prev ? prev.nextSibling : parent.firstChild;\n            if (tracking && next != child.dom) tracking.written = true;\n            if (child.dom.parentNode == parent) {\n                while(next && next != child.dom)next = rm$1(next);\n            } else {\n                parent.insertBefore(child.dom, next);\n            }\n            prev = child.dom;\n        }\n        next = prev ? prev.nextSibling : parent.firstChild;\n        if (tracking && next) tracking.written = true;\n        while(next)next = rm$1(next);\n        this.length = length;\n    }\n}\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// The top-level tile. Its dom property equals view.contentDOM.\nclass DocTile extends CompositeTile {\n    constructor(view, dom){\n        super(dom);\n        this.view = view;\n    }\n    owns(tile) {\n        for(; tile; tile = tile.parent)if (tile == this) return true;\n        return false;\n    }\n    isBlock() {\n        return true;\n    }\n    nearest(dom) {\n        for(;;){\n            if (!dom) return null;\n            let tile = Tile.get(dom);\n            if (tile && this.owns(tile)) return tile;\n            dom = dom.parentNode;\n        }\n    }\n    blockTiles(f) {\n        for(let stack = [], cur = this, i = 0, pos = 0;;){\n            if (i == cur.children.length) {\n                if (!stack.length) return;\n                cur = cur.parent;\n                if (cur.breakAfter) pos++;\n                i = stack.pop();\n            } else {\n                let next = cur.children[i++];\n                if (next instanceof BlockWrapperTile) {\n                    stack.push(i);\n                    cur = next;\n                    i = 0;\n                } else {\n                    let end = pos + next.length;\n                    let result = f(next, pos);\n                    if (result !== undefined) return result;\n                    pos = end + next.breakAfter;\n                }\n            }\n        }\n    }\n    // Find the block at the given position. If side < -1, make sure to\n    // stay before block widgets at that position, if side > 1, after\n    // such widgets (used for selection drawing, which needs to be able\n    // to get coordinates for positions that aren't valid cursor positions).\n    resolveBlock(pos, side) {\n        let before, beforeOff = -1, after, afterOff = -1;\n        this.blockTiles((tile, off)=>{\n            let end = off + tile.length;\n            if (pos >= off && pos <= end) {\n                if (tile.isWidget() && side >= -1 && side <= 1) {\n                    if (tile.flags & 32 /* TileFlag.After */ ) return true;\n                    if (tile.flags & 16 /* TileFlag.Before */ ) before = undefined;\n                }\n                if ((off < pos || pos == end && (side < -1 ? tile.length : tile.covers(1))) && (!before || !tile.isWidget() && before.isWidget())) {\n                    before = tile;\n                    beforeOff = pos - off;\n                }\n                if ((end > pos || pos == off && (side > 1 ? tile.length : tile.covers(-1))) && (!after || !tile.isWidget() && after.isWidget())) {\n                    after = tile;\n                    afterOff = pos - off;\n                }\n            }\n        });\n        if (!before && !after) throw new Error(\"No tile at position \" + pos);\n        return before && side < 0 || !after ? {\n            tile: before,\n            offset: beforeOff\n        } : {\n            tile: after,\n            offset: afterOff\n        };\n    }\n}\nclass BlockWrapperTile extends CompositeTile {\n    constructor(dom, wrapper){\n        super(dom);\n        this.wrapper = wrapper;\n    }\n    isBlock() {\n        return true;\n    }\n    covers(side) {\n        if (!this.children.length) return false;\n        return side < 0 ? this.children[0].covers(-1) : this.lastChild.covers(1);\n    }\n    get domAttrs() {\n        return this.wrapper.attributes;\n    }\n    static of(wrapper, dom) {\n        let tile = new BlockWrapperTile(dom || document.createElement(wrapper.tagName), wrapper);\n        if (!dom) tile.flags |= 4 /* TileFlag.AttrsDirty */ ;\n        return tile;\n    }\n}\nclass LineTile extends CompositeTile {\n    constructor(dom, attrs){\n        super(dom);\n        this.attrs = attrs;\n    }\n    isLine() {\n        return true;\n    }\n    static start(attrs, dom, keepAttrs) {\n        let line = new LineTile(dom || document.createElement(\"div\"), attrs);\n        if (!dom || !keepAttrs) line.flags |= 4 /* TileFlag.AttrsDirty */ ;\n        return line;\n    }\n    get domAttrs() {\n        return this.attrs;\n    }\n    // Find the tile associated with a given position in this line.\n    resolveInline(pos, side, forCoords) {\n        let before = null, beforeOff = -1, after = null, afterOff = -1;\n        function scan(tile, pos) {\n            for(let i = 0, off = 0; i < tile.children.length && off <= pos; i++){\n                let child = tile.children[i], end = off + child.length;\n                if (end >= pos) {\n                    if (child.isComposite()) {\n                        scan(child, pos - off);\n                    } else if ((!after || after.isHidden && (side > 0 || forCoords && onSameLine(after, child))) && (end > pos || child.flags & 32 /* TileFlag.After */ )) {\n                        after = child;\n                        afterOff = pos - off;\n                    } else if (off < pos || child.flags & 16 /* TileFlag.Before */  && !child.isHidden) {\n                        before = child;\n                        beforeOff = pos - off;\n                    }\n                }\n                off = end;\n            }\n        }\n        scan(this, pos);\n        let target = (side < 0 ? before : after) || before || after;\n        return target ? {\n            tile: target,\n            offset: target == before ? beforeOff : afterOff\n        } : null;\n    }\n    coordsIn(pos, side) {\n        let found = this.resolveInline(pos, side, true);\n        if (!found) return fallbackRect(this);\n        return found.tile.coordsIn(Math.max(0, found.offset), side);\n    }\n    domIn(pos, side) {\n        let found = this.resolveInline(pos, side);\n        if (found) {\n            let { tile, offset } = found;\n            if (this.dom.contains(tile.dom)) {\n                if (tile.isText()) return new DOMPos(tile.dom, Math.min(tile.dom.nodeValue.length, offset));\n                return tile.domPosFor(offset, tile.flags & 16 /* TileFlag.Before */  ? 1 : tile.flags & 32 /* TileFlag.After */  ? -1 : side);\n            }\n            let parent = found.tile.parent, saw = false;\n            for (let ch of parent.children){\n                if (saw) return new DOMPos(ch.dom, 0);\n                if (ch == found.tile) {\n                    saw = true;\n                }\n            }\n        }\n        return new DOMPos(this.dom, 0);\n    }\n}\nfunction fallbackRect(tile) {\n    let last = tile.dom.lastChild;\n    if (!last) return tile.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1] || null;\n}\nfunction onSameLine(a, b) {\n    let posA = a.coordsIn(0, 1), posB = b.coordsIn(0, 1);\n    return posA && posB && posB.top < posA.bottom;\n}\nclass MarkTile extends CompositeTile {\n    constructor(dom, mark){\n        super(dom);\n        this.mark = mark;\n    }\n    get domAttrs() {\n        return this.mark.attrs;\n    }\n    static of(mark, dom) {\n        let tile = new MarkTile(dom || document.createElement(mark.tagName), mark);\n        if (!dom) tile.flags |= 4 /* TileFlag.AttrsDirty */ ;\n        return tile;\n    }\n}\nclass TextTile extends Tile {\n    constructor(dom, text){\n        super(dom, text.length);\n        this.text = text;\n    }\n    sync(track) {\n        if (this.flags & 2 /* TileFlag.Synced */ ) return;\n        super.sync(track);\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom) track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    isText() {\n        return true;\n    }\n    toString() {\n        return JSON.stringify(this.text);\n    }\n    coordsIn(pos, side) {\n        let length = this.dom.nodeValue.length;\n        if (pos > length) pos = length;\n        let from = pos, to = pos, flatten = 0;\n        if (pos == 0 && side < 0 || pos == length && side >= 0) {\n            if (!(browser.chrome || browser.gecko)) {\n                if (pos) {\n                    from--;\n                    flatten = 1;\n                } else if (to < length) {\n                    to++;\n                    flatten = -1;\n                }\n            }\n        } else {\n            if (side < 0) from--;\n            else if (to < length) to++;\n        }\n        let rects = textRange(this.dom, from, to).getClientRects();\n        if (!rects.length) return null;\n        let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n        if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, (r)=>r.width) || rect;\n        return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n    }\n    static of(text, dom) {\n        let tile = new TextTile(dom || document.createTextNode(text), text);\n        if (!dom) tile.flags |= 2 /* TileFlag.Synced */ ;\n        return tile;\n    }\n}\nclass WidgetTile extends Tile {\n    constructor(dom, length, widget, flags){\n        super(dom, length, flags);\n        this.widget = widget;\n    }\n    isWidget() {\n        return true;\n    }\n    get isHidden() {\n        return this.widget.isHidden;\n    }\n    covers(side) {\n        if (this.flags & 48 /* TileFlag.PointWidget */ ) return false;\n        return (this.flags & (side < 0 ? 64 /* TileFlag.IncStart */  : 128 /* TileFlag.IncEnd */ )) > 0;\n    }\n    coordsIn(pos, side) {\n        return this.coordsInWidget(pos, side, false);\n    }\n    coordsInWidget(pos, side, block) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        if (block) {\n            return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);\n        } else {\n            let rects = this.dom.getClientRects(), rect = null;\n            if (!rects.length) return null;\n            let fromBack = this.flags & 16 /* TileFlag.Before */  ? true : this.flags & 32 /* TileFlag.After */  ? false : pos > 0;\n            for(let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1){\n                rect = rects[i];\n                if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n            }\n            return flattenRect(rect, !fromBack);\n        }\n    }\n    get overrideDOMText() {\n        if (!this.length) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n        let { root } = this;\n        if (!root) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n        let start = this.posAtStart;\n        return root.view.state.doc.slice(start, start + this.length);\n    }\n    destroy() {\n        super.destroy();\n        this.widget.destroy(this.dom);\n    }\n    static of(widget, view, length, flags, dom) {\n        if (!dom) {\n            dom = widget.toDOM(view);\n            if (!widget.editable) dom.contentEditable = \"false\";\n        }\n        return new WidgetTile(dom, length, widget, flags);\n    }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferTile extends Tile {\n    constructor(flags){\n        let img = document.createElement(\"img\");\n        img.className = \"cm-widgetBuffer\";\n        img.setAttribute(\"aria-hidden\", \"true\");\n        super(img, 0, flags);\n    }\n    get isHidden() {\n        return true;\n    }\n    get overrideDOMText() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n    coordsIn(pos) {\n        return this.dom.getBoundingClientRect();\n    }\n}\n// Represents a position in the tile tree.\nclass TilePointer {\n    constructor(top){\n        this.index = 0;\n        this.beforeBreak = false;\n        this.parents = [];\n        this.tile = top;\n    }\n    // Advance by the given distance. If side is -1, stop leaving or\n    // entering tiles, or skipping zero-length tiles, once the distance\n    // has been traversed. When side is 1, leave, enter, or skip\n    // everything at the end position.\n    advance(dist, side, walker) {\n        let { tile, index, beforeBreak, parents } = this;\n        while(dist || side > 0){\n            if (!tile.isComposite()) {\n                if (index == tile.length) {\n                    beforeBreak = !!tile.breakAfter;\n                    ({ tile, index } = parents.pop());\n                    index++;\n                } else if (!dist) {\n                    break;\n                } else {\n                    let take = Math.min(dist, tile.length - index);\n                    if (walker) walker.skip(tile, index, index + take);\n                    dist -= take;\n                    index += take;\n                }\n            } else if (beforeBreak) {\n                if (!dist) break;\n                if (walker) walker.break();\n                dist--;\n                beforeBreak = false;\n            } else if (index == tile.children.length) {\n                if (!dist && !parents.length) break;\n                if (walker) walker.leave(tile);\n                beforeBreak = !!tile.breakAfter;\n                ({ tile, index } = parents.pop());\n                index++;\n            } else {\n                let next = tile.children[index], brk = next.breakAfter;\n                if ((side > 0 ? next.length <= dist : next.length < dist) && (!walker || walker.skip(next, 0, next.length) !== false || !next.isComposite)) {\n                    beforeBreak = !!brk;\n                    index++;\n                    dist -= next.length;\n                } else {\n                    parents.push({\n                        tile,\n                        index\n                    });\n                    tile = next;\n                    index = 0;\n                    if (walker && next.isComposite()) walker.enter(next);\n                }\n            }\n        }\n        this.tile = tile;\n        this.index = index;\n        this.beforeBreak = beforeBreak;\n        return this;\n    }\n    get root() {\n        return this.parents.length ? this.parents[0].tile : this.tile;\n    }\n}\n// Used to track open block wrappers\nclass OpenWrapper {\n    constructor(from, to, wrapper, rank){\n        this.from = from;\n        this.to = to;\n        this.wrapper = wrapper;\n        this.rank = rank;\n    }\n}\n// This class builds up a new document tile using input from either\n// iteration over the old tree or iteration over the document +\n// decorations. The add* methods emit elements into the tile\n// structure. To avoid awkward synchronization issues, marks and block\n// wrappers are treated as belonging to to their content, rather than\n// opened/closed independently.\n//\n// All composite tiles that are touched by changes are rebuilt,\n// reusing as much of the old tree (either whole nodes or just DOM\n// elements) as possible. The new tree is built without the Synced\n// flag, and then synced (during which DOM parent/child relations are\n// fixed up, text nodes filled in, and attributes added) in a second\n// phase.\nclass TileBuilder {\n    constructor(cache, root, blockWrappers){\n        this.cache = cache;\n        this.root = root;\n        this.blockWrappers = blockWrappers;\n        this.curLine = null;\n        this.lastBlock = null;\n        this.afterWidget = null;\n        this.pos = 0;\n        this.wrappers = [];\n        this.wrapperPos = 0;\n    }\n    addText(text, marks, openStart, tile) {\n        var _a;\n        this.flushBuffer();\n        let parent = this.ensureMarks(marks, openStart);\n        let prev = parent.lastChild;\n        if (prev && prev.isText() && !(prev.flags & 8 /* TileFlag.Composition */ )) {\n            this.cache.reused.set(prev, 2 /* Reused.DOM */ );\n            let tile = parent.children[parent.children.length - 1] = new TextTile(prev.dom, prev.text + text);\n            tile.parent = parent;\n        } else {\n            parent.append(tile || TextTile.of(text, (_a = this.cache.find(TextTile)) === null || _a === void 0 ? void 0 : _a.dom));\n        }\n        this.pos += text.length;\n        this.afterWidget = null;\n    }\n    addComposition(composition, context) {\n        let line = this.curLine;\n        if (line.dom != context.line.dom) {\n            line.setDOM(this.cache.reused.has(context.line) ? freeNode(context.line.dom) : context.line.dom);\n            this.cache.reused.set(context.line, 2 /* Reused.DOM */ );\n        }\n        let head = line;\n        for(let i = context.marks.length - 1; i >= 0; i--){\n            let mark = context.marks[i];\n            let last = head.lastChild;\n            if (last instanceof MarkTile && last.mark.eq(mark.mark)) {\n                if (last.dom != mark.dom) last.setDOM(freeNode(mark.dom));\n                head = last;\n            } else {\n                if (this.cache.reused.get(mark)) {\n                    let tile = Tile.get(mark.dom);\n                    if (tile) tile.setDOM(freeNode(mark.dom));\n                }\n                let nw = MarkTile.of(mark.mark, mark.dom);\n                head.append(nw);\n                head = nw;\n            }\n            this.cache.reused.set(mark, 2 /* Reused.DOM */ );\n        }\n        let oldTile = Tile.get(composition.text);\n        if (oldTile) this.cache.reused.set(oldTile, 2 /* Reused.DOM */ );\n        let text = new TextTile(composition.text, composition.text.nodeValue);\n        text.flags |= 8 /* TileFlag.Composition */ ;\n        head.append(text);\n    }\n    addInlineWidget(widget, marks, openStart) {\n        // Adjacent same-side-facing non-replacing widgets don't need buffers between them\n        let noSpace = this.afterWidget && widget.flags & 48 /* TileFlag.PointWidget */  && (this.afterWidget.flags & 48 /* TileFlag.PointWidget */ ) == (widget.flags & 48 /* TileFlag.PointWidget */ );\n        if (!noSpace) this.flushBuffer();\n        let parent = this.ensureMarks(marks, openStart);\n        if (!noSpace && !(widget.flags & 16 /* TileFlag.Before */ )) parent.append(this.getBuffer(1));\n        parent.append(widget);\n        this.pos += widget.length;\n        this.afterWidget = widget;\n    }\n    addMark(tile, marks, openStart) {\n        this.flushBuffer();\n        let parent = this.ensureMarks(marks, openStart);\n        parent.append(tile);\n        this.pos += tile.length;\n        this.afterWidget = null;\n    }\n    addBlockWidget(widget) {\n        this.getBlockPos().append(widget);\n        this.pos += widget.length;\n        this.lastBlock = widget;\n        this.endLine();\n    }\n    continueWidget(length) {\n        let widget = this.afterWidget || this.lastBlock;\n        widget.length += length;\n        this.pos += length;\n    }\n    addLineStart(attrs, dom) {\n        var _a;\n        if (!attrs) attrs = lineBaseAttrs;\n        let tile = LineTile.start(attrs, dom || ((_a = this.cache.find(LineTile)) === null || _a === void 0 ? void 0 : _a.dom), !!dom);\n        this.getBlockPos().append(this.lastBlock = this.curLine = tile);\n    }\n    addLine(tile) {\n        this.getBlockPos().append(tile);\n        this.pos += tile.length;\n        this.lastBlock = tile;\n        this.endLine();\n    }\n    addBreak() {\n        this.lastBlock.flags |= 1 /* TileFlag.BreakAfter */ ;\n        this.endLine();\n        this.pos++;\n    }\n    addLineStartIfNotCovered(attrs) {\n        if (!this.blockPosCovered()) this.addLineStart(attrs);\n    }\n    ensureLine(attrs) {\n        if (!this.curLine) this.addLineStart(attrs);\n    }\n    ensureMarks(marks, openStart) {\n        var _a;\n        let parent = this.curLine;\n        for(let i = marks.length - 1; i >= 0; i--){\n            let mark = marks[i], last;\n            if (openStart > 0 && (last = parent.lastChild) && last instanceof MarkTile && last.mark.eq(mark)) {\n                parent = last;\n                openStart--;\n            } else {\n                let tile = MarkTile.of(mark, (_a = this.cache.find(MarkTile, (m)=>m.mark.eq(mark))) === null || _a === void 0 ? void 0 : _a.dom);\n                parent.append(tile);\n                parent = tile;\n                openStart = 0;\n            }\n        }\n        return parent;\n    }\n    endLine() {\n        if (this.curLine) {\n            this.flushBuffer();\n            let last = this.curLine.lastChild;\n            if (!last || !hasContent(this.curLine, false) || last.dom.nodeName != \"BR\" && last.isWidget() && !(browser.ios && hasContent(this.curLine, true))) this.curLine.append(this.cache.findWidget(BreakWidget, 0, 32 /* TileFlag.After */ ) || new WidgetTile(BreakWidget.toDOM(), 0, BreakWidget, 32 /* TileFlag.After */ ));\n            this.curLine = this.afterWidget = null;\n        }\n    }\n    updateBlockWrappers() {\n        if (this.wrapperPos > this.pos + 10000 /* C.WrapperReset */ ) {\n            this.blockWrappers.goto(this.pos);\n            this.wrappers.length = 0;\n        }\n        for(let i = this.wrappers.length - 1; i >= 0; i--)if (this.wrappers[i].to < this.pos) this.wrappers.splice(i, 1);\n        for(let cur = this.blockWrappers; cur.value && cur.from <= this.pos; cur.next())if (cur.to >= this.pos) {\n            let wrap = new OpenWrapper(cur.from, cur.to, cur.value, cur.rank), i = this.wrappers.length;\n            while(i > 0 && (this.wrappers[i - 1].rank - wrap.rank || this.wrappers[i - 1].to - wrap.to) < 0)i--;\n            this.wrappers.splice(i, 0, wrap);\n        }\n        this.wrapperPos = this.pos;\n    }\n    getBlockPos() {\n        var _a;\n        this.updateBlockWrappers();\n        let parent = this.root;\n        for (let wrap of this.wrappers){\n            let last = parent.lastChild;\n            if (wrap.from < this.pos && last instanceof BlockWrapperTile && last.wrapper.eq(wrap.wrapper)) {\n                parent = last;\n            } else {\n                let tile = BlockWrapperTile.of(wrap.wrapper, (_a = this.cache.find(BlockWrapperTile, (t)=>t.wrapper.eq(wrap.wrapper))) === null || _a === void 0 ? void 0 : _a.dom);\n                parent.append(tile);\n                parent = tile;\n            }\n        }\n        return parent;\n    }\n    blockPosCovered() {\n        let last = this.lastBlock;\n        return last != null && !last.breakAfter && (!last.isWidget() || (last.flags & (32 /* TileFlag.After */  | 128 /* TileFlag.IncEnd */ )) > 0);\n    }\n    getBuffer(side) {\n        let flags = 2 /* TileFlag.Synced */  | (side < 0 ? 16 /* TileFlag.Before */  : 32 /* TileFlag.After */ );\n        let found = this.cache.find(WidgetBufferTile, undefined, 1 /* Reused.Full */ );\n        if (found) found.flags = flags;\n        return found || new WidgetBufferTile(flags);\n    }\n    flushBuffer() {\n        if (this.afterWidget && !(this.afterWidget.flags & 32 /* TileFlag.After */ )) {\n            this.afterWidget.parent.append(this.getBuffer(-1));\n            this.afterWidget = null;\n        }\n    }\n}\n// Helps getting efficient access to the document text.\nclass TextStream {\n    constructor(doc){\n        this.skipCount = 0;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n    }\n    skip(len) {\n        // Advance the iterator past the replaced content\n        if (this.textOff + len <= this.text.length) {\n            this.textOff += len;\n        } else {\n            this.skipCount += len - (this.text.length - this.textOff);\n            this.text = \"\";\n            this.textOff = 0;\n        }\n    }\n    next(maxLen) {\n        if (this.textOff == this.text.length) {\n            let { value, lineBreak, done } = this.cursor.next(this.skipCount);\n            this.skipCount = 0;\n            if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n            this.text = value;\n            let len = this.textOff = Math.min(maxLen, value.length);\n            return lineBreak ? null : value.slice(0, len);\n        }\n        let end = Math.min(this.text.length, this.textOff + maxLen);\n        let chars = this.text.slice(this.textOff, end);\n        this.textOff = end;\n        return chars;\n    }\n}\n// Assign the tile classes bucket numbers for caching.\nconst buckets = [\n    WidgetTile,\n    LineTile,\n    TextTile,\n    MarkTile,\n    WidgetBufferTile,\n    BlockWrapperTile,\n    DocTile\n];\nfor(let i = 0; i < buckets.length; i++)buckets[i].bucket = i;\n// Leaf tiles and line tiles may be reused in their entirety. All\n// others will get new tiles allocated, using the old DOM when\n// possible.\nclass TileCache {\n    constructor(view){\n        this.view = view;\n        // Buckets are circular buffers, using `index` as the current\n        // position.\n        this.buckets = buckets.map(()=>[]);\n        this.index = buckets.map(()=>0);\n        this.reused = new Map;\n    }\n    // Put a tile in the cache.\n    add(tile) {\n        let i = tile.constructor.bucket, bucket = this.buckets[i];\n        if (bucket.length < 6 /* C.Bucket */ ) bucket.push(tile);\n        else bucket[this.index[i] = (this.index[i] + 1) % 6 /* C.Bucket */ ] = tile;\n    }\n    find(cls, test, type = 2 /* Reused.DOM */ ) {\n        let i = cls.bucket;\n        let bucket = this.buckets[i], off = this.index[i];\n        for(let j = bucket.length - 1; j >= 0; j--){\n            // Look at the most recently added items first (last-in, first-out)\n            let index = (j + off) % bucket.length, tile = bucket[index];\n            if ((!test || test(tile)) && !this.reused.has(tile)) {\n                bucket.splice(index, 1);\n                if (index < off) this.index[i]--;\n                this.reused.set(tile, type);\n                return tile;\n            }\n        }\n        return null;\n    }\n    findWidget(widget, length, flags) {\n        let widgets = this.buckets[0];\n        if (widgets.length) for(let i = 0, pass = 0;; i++){\n            if (i == widgets.length) {\n                if (pass) return null;\n                pass = 1;\n                i = 0;\n            }\n            let tile = widgets[i];\n            if (!this.reused.has(tile) && (pass == 0 ? tile.widget.compare(widget) : tile.widget.constructor == widget.constructor && widget.updateDOM(tile.dom, this.view))) {\n                widgets.splice(i, 1);\n                if (i < this.index[0]) this.index[0]--;\n                if (tile.widget == widget && tile.length == length && (tile.flags & (496 /* TileFlag.Widget */  | 1 /* TileFlag.BreakAfter */ )) == flags) {\n                    this.reused.set(tile, 1 /* Reused.Full */ );\n                    return tile;\n                } else {\n                    this.reused.set(tile, 2 /* Reused.DOM */ );\n                    return new WidgetTile(tile.dom, length, widget, tile.flags & ~(496 /* TileFlag.Widget */  | 1 /* TileFlag.BreakAfter */ ) | flags);\n                }\n            }\n        }\n    }\n    reuse(tile) {\n        this.reused.set(tile, 1 /* Reused.Full */ );\n        return tile;\n    }\n    maybeReuse(tile, type = 2 /* Reused.DOM */ ) {\n        if (this.reused.has(tile)) return undefined;\n        this.reused.set(tile, type);\n        return tile.dom;\n    }\n    clear() {\n        for(let i = 0; i < this.buckets.length; i++)this.buckets[i].length = this.index[i] = 0;\n    }\n}\n// This class organizes a pass over the document, guided by the array\n// of replaced ranges. For ranges that haven't changed, it iterates\n// the old tree and copies its content into the new document. For\n// changed ranges, it runs a decoration iterator to guide generation\n// of content.\nclass TileUpdate {\n    constructor(view, old, blockWrappers, decorations, disallowBlockEffectsFor){\n        this.view = view;\n        this.decorations = decorations;\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n        this.openWidget = false;\n        this.openMarks = 0;\n        this.cache = new TileCache(view);\n        this.text = new TextStream(view.state.doc);\n        this.builder = new TileBuilder(this.cache, new DocTile(view, view.contentDOM), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.iter(blockWrappers));\n        this.cache.reused.set(old, 2 /* Reused.DOM */ );\n        this.old = new TilePointer(old);\n        this.reuseWalker = {\n            skip: (tile, from, to)=>{\n                this.cache.add(tile);\n                if (tile.isComposite()) return false;\n            },\n            enter: (tile)=>this.cache.add(tile),\n            leave: ()=>{},\n            break: ()=>{}\n        };\n    }\n    run(changes, composition) {\n        let compositionContext = composition && this.getCompositionContext(composition.text);\n        for(let posA = 0, posB = 0, i = 0;;){\n            let next = i < changes.length ? changes[i++] : null;\n            let skipA = next ? next.fromA : this.old.root.length;\n            if (skipA > posA) {\n                let len = skipA - posA;\n                this.preserve(len, !i, !next);\n                posA = skipA;\n                posB += len;\n            }\n            if (!next) break;\n            // Compositions need to be handled specially, forcing the\n            // focused text node and its parent nodes to remain stable at\n            // that point in the document.\n            if (composition && next.fromA <= composition.range.fromA && next.toA >= composition.range.toA) {\n                this.forward(next.fromA, composition.range.fromA, composition.range.fromA < composition.range.toA ? 1 : -1);\n                this.emit(posB, composition.range.fromB);\n                this.cache.clear(); // Must not reuse DOM across composition\n                this.builder.addComposition(composition, compositionContext);\n                this.text.skip(composition.range.toB - composition.range.fromB);\n                this.forward(composition.range.fromA, next.toA);\n                this.emit(composition.range.toB, next.toB);\n            } else {\n                this.forward(next.fromA, next.toA);\n                this.emit(posB, next.toB);\n            }\n            posB = next.toB;\n            posA = next.toA;\n        }\n        if (this.builder.curLine) this.builder.endLine();\n        return this.builder.root;\n    }\n    preserve(length, incStart, incEnd) {\n        let activeMarks = getMarks(this.old), openMarks = this.openMarks;\n        this.old.advance(length, incEnd ? 1 : -1, {\n            skip: (tile, from, to)=>{\n                if (tile.isWidget()) {\n                    if (this.openWidget) {\n                        this.builder.continueWidget(to - from);\n                    } else {\n                        let widget = to > 0 || from < tile.length ? WidgetTile.of(tile.widget, this.view, to - from, tile.flags & 496 /* TileFlag.Widget */ , this.cache.maybeReuse(tile)) : this.cache.reuse(tile);\n                        if (widget.flags & 256 /* TileFlag.Block */ ) {\n                            widget.flags &= ~1 /* TileFlag.BreakAfter */ ;\n                            this.builder.addBlockWidget(widget);\n                        } else {\n                            this.builder.ensureLine(null);\n                            this.builder.addInlineWidget(widget, activeMarks, openMarks);\n                            openMarks = activeMarks.length;\n                        }\n                    }\n                } else if (tile.isText()) {\n                    this.builder.ensureLine(null);\n                    if (!from && to == tile.length) {\n                        this.builder.addText(tile.text, activeMarks, openMarks, this.cache.reuse(tile));\n                    } else {\n                        this.cache.add(tile);\n                        this.builder.addText(tile.text.slice(from, to), activeMarks, openMarks);\n                    }\n                    openMarks = activeMarks.length;\n                } else if (tile.isLine()) {\n                    tile.flags &= ~1 /* TileFlag.BreakAfter */ ;\n                    this.cache.reused.set(tile, 1 /* Reused.Full */ );\n                    this.builder.addLine(tile);\n                } else if (tile instanceof WidgetBufferTile) {\n                    this.cache.add(tile);\n                } else if (tile instanceof MarkTile) {\n                    this.builder.ensureLine(null);\n                    this.builder.addMark(tile, activeMarks, openMarks);\n                    this.cache.reused.set(tile, 1 /* Reused.Full */ );\n                    openMarks = activeMarks.length;\n                } else {\n                    return false;\n                }\n                this.openWidget = false;\n            },\n            enter: (tile)=>{\n                if (tile.isLine()) {\n                    this.builder.addLineStart(tile.attrs, this.cache.maybeReuse(tile));\n                } else {\n                    this.cache.add(tile);\n                    if (tile instanceof MarkTile) activeMarks.unshift(tile.mark);\n                }\n                this.openWidget = false;\n            },\n            leave: (tile)=>{\n                if (tile.isLine()) {\n                    if (activeMarks.length) activeMarks.length = openMarks = 0;\n                } else if (tile instanceof MarkTile) {\n                    activeMarks.shift();\n                    openMarks = Math.min(openMarks, activeMarks.length);\n                }\n            },\n            break: ()=>{\n                this.builder.addBreak();\n                this.openWidget = false;\n            }\n        });\n        this.text.skip(length);\n    }\n    emit(from, to) {\n        let pendingLineAttrs = null;\n        let b = this.builder, markCount = 0;\n        let openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(this.decorations, from, to, {\n            point: (from, to, deco, active, openStart, index)=>{\n                if (deco instanceof PointDecoration) {\n                    if (this.disallowBlockEffectsFor[index]) {\n                        if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n                        if (to > this.view.state.doc.lineAt(from).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n                    }\n                    markCount = active.length;\n                    if (openStart > active.length) {\n                        b.continueWidget(to - from);\n                    } else {\n                        let widget = deco.widget || (deco.block ? NullWidget.block : NullWidget.inline);\n                        let flags = widgetFlags(deco);\n                        let tile = this.cache.findWidget(widget, to - from, flags) || WidgetTile.of(widget, this.view, to - from, flags);\n                        if (deco.block) {\n                            if (deco.startSide > 0) b.addLineStartIfNotCovered(pendingLineAttrs);\n                            b.addBlockWidget(tile);\n                        } else {\n                            b.ensureLine(pendingLineAttrs);\n                            b.addInlineWidget(tile, active, openStart);\n                        }\n                    }\n                    pendingLineAttrs = null;\n                } else {\n                    pendingLineAttrs = addLineDeco(pendingLineAttrs, deco);\n                }\n                if (to > from) this.text.skip(to - from);\n            },\n            span: (from, to, active, openStart)=>{\n                for(let pos = from; pos < to;){\n                    let chars = this.text.next(Math.min(512 /* C.Chunk */ , to - pos));\n                    if (chars == null) {\n                        b.addLineStartIfNotCovered(pendingLineAttrs);\n                        b.addBreak();\n                        pos++;\n                    } else {\n                        b.ensureLine(pendingLineAttrs);\n                        b.addText(chars, active, openStart);\n                        pos += chars.length;\n                    }\n                    pendingLineAttrs = null;\n                }\n            }\n        });\n        b.addLineStartIfNotCovered(pendingLineAttrs);\n        this.openWidget = openEnd > markCount;\n        this.openMarks = openEnd;\n    }\n    forward(from, to, side = 1) {\n        if (to - from <= 10) {\n            this.old.advance(to - from, side, this.reuseWalker);\n        } else {\n            this.old.advance(5, -1, this.reuseWalker);\n            this.old.advance(to - from - 10, -1);\n            this.old.advance(5, side, this.reuseWalker);\n        }\n    }\n    getCompositionContext(text) {\n        let marks = [], line = null;\n        for(let parent = text.parentNode;; parent = parent.parentNode){\n            let tile = Tile.get(parent);\n            if (parent == this.view.contentDOM) break;\n            if (tile instanceof MarkTile) marks.push(tile);\n            else if (tile === null || tile === void 0 ? void 0 : tile.isLine()) line = tile;\n            else if (parent.nodeName == \"DIV\" && !line && parent != this.view.contentDOM) line = new LineTile(parent, lineBaseAttrs);\n            else marks.push(MarkTile.of(new MarkDecoration({\n                tagName: parent.nodeName.toLowerCase(),\n                attributes: getAttrs(parent)\n            }), parent));\n        }\n        return {\n            line: line,\n            marks\n        };\n    }\n}\nfunction hasContent(tile, requireText) {\n    let scan = (tile)=>{\n        for (let ch of tile.children)if ((requireText ? ch.isText() : ch.length) || scan(ch)) return true;\n        return false;\n    };\n    return scan(tile);\n}\nfunction widgetFlags(deco) {\n    let flags = deco.isReplace ? (deco.startSide < 0 ? 64 /* TileFlag.IncStart */  : 0) | (deco.endSide > 0 ? 128 /* TileFlag.IncEnd */  : 0) : deco.startSide > 0 ? 32 /* TileFlag.After */  : 16 /* TileFlag.Before */ ;\n    if (deco.block) flags |= 256 /* TileFlag.Block */ ;\n    return flags;\n}\nconst lineBaseAttrs = {\n    class: \"cm-line\"\n};\nfunction addLineDeco(value, deco) {\n    let attrs = deco.spec.attributes, cls = deco.spec.class;\n    if (!attrs && !cls) return value;\n    if (!value) value = {\n        class: \"cm-line\"\n    };\n    if (attrs) combineAttrs(attrs, value);\n    if (cls) value.class += \" \" + cls;\n    return value;\n}\nfunction getMarks(ptr) {\n    let found = [];\n    for(let i = ptr.parents.length; i > 1; i--){\n        let tile = i == ptr.parents.length ? ptr.tile : ptr.parents[i].tile;\n        if (tile instanceof MarkTile) found.push(tile.mark);\n    }\n    return found;\n}\nfunction freeNode(node) {\n    let tile = Tile.get(node);\n    if (tile) tile.setDOM(node.cloneNode());\n    return node;\n}\nclass NullWidget extends WidgetType {\n    constructor(tag){\n        super();\n        this.tag = tag;\n    }\n    eq(other) {\n        return other.tag == this.tag;\n    }\n    toDOM() {\n        return document.createElement(this.tag);\n    }\n    updateDOM(elt) {\n        return elt.nodeName.toLowerCase() == this.tag;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nNullWidget.inline = /*@__PURE__*/ new NullWidget(\"span\");\nNullWidget.block = /*@__PURE__*/ new NullWidget(\"div\");\nconst BreakWidget = /*@__PURE__*/ new class extends WidgetType {\n    toDOM() {\n        return document.createElement(\"br\");\n    }\n    get isHidden() {\n        return true;\n    }\n    get editable() {\n        return true;\n    }\n};\nclass DocView {\n    constructor(view){\n        this.view = view;\n        this.decorations = [];\n        this.blockWrappers = [];\n        this.dynamicDecorationMap = [\n            false\n        ];\n        this.domChanged = null;\n        this.hasComposition = null;\n        this.editContextFormatting = Decoration.none;\n        this.lastCompositionAfterCursor = false;\n        // Track a minimum width for the editor. When measuring sizes in\n        // measureVisibleLineHeights, this is updated to point at the width\n        // of a given element and its extent in the document. When a change\n        // happens in that range, these are reset. That way, once we've seen\n        // a line/element of a given length, we keep the editor wide enough\n        // to fit at least that element, until it is changed, at which point\n        // we forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.forceSelection = false;\n        // Used by the resize observer to ignore resizes that we caused\n        // ourselves\n        this.lastUpdate = Date.now();\n        this.updateDeco();\n        this.tile = new DocTile(view, view.contentDOM);\n        this.updateInner([\n            new ChangedRange(0, 0, 0, view.state.doc.length)\n        ], null);\n    }\n    // Update the document view to a given state.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA })=>toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n            } else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        this.updateEditContextFormatting(update);\n        let readCompositionAt = -1;\n        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {\n            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;\n            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;\n        }\n        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n        this.domChanged = null;\n        if (this.hasComposition) {\n            let { from, to } = this.hasComposition;\n            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());\n        }\n        this.hasComposition = composition ? {\n            from: composition.range.fromB,\n            to: composition.range.toB\n        } : null;\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n        let prevDeco = this.decorations, prevWrappers = this.blockWrappers;\n        this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, this.decorations, update.changes);\n        if (decoDiff.length) changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        let blockDiff = findChangedWrappers(prevWrappers, this.blockWrappers, update.changes);\n        if (blockDiff.length) changedRanges = ChangedRange.extendWithRanges(changedRanges, blockDiff);\n        if (composition && !changedRanges.some((r)=>r.fromA <= composition.range.fromA && r.toA >= composition.range.toA)) changedRanges = composition.range.addToSet(changedRanges.slice());\n        if (this.tile.flags & 2 /* TileFlag.Synced */  && changedRanges.length == 0) {\n            return false;\n        } else {\n            this.updateInner(changedRanges, composition);\n            if (update.transactions.length) this.lastUpdate = Date.now();\n            return true;\n        }\n    }\n    // Used by update and the constructor do perform the actual DOM\n    // update\n    updateInner(changes, composition) {\n        this.view.viewState.mustMeasureContent = true;\n        let { observer } = this.view;\n        observer.ignore(()=>{\n            if (composition || changes.length) {\n                let oldTile = this.tile;\n                let builder = new TileUpdate(this.view, oldTile, this.blockWrappers, this.decorations, this.dynamicDecorationMap);\n                this.tile = builder.run(changes, composition);\n                destroyDropped(oldTile, builder.cache.reused);\n            }\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.tile.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n            this.tile.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? {\n                node: observer.selectionRange.focusNode,\n                written: false\n            } : undefined;\n            this.tile.sync(track);\n            if (track && (track.written || observer.selectionRange.focusNode != track.node || !this.tile.dom.contains(track.node))) this.forceSelection = true;\n            this.tile.dom.style.height = \"\";\n        });\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {\n            for (let child of this.tile.children)if (child.isWidget() && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n        }\n        observer.updateGaps(gaps);\n    }\n    updateEditContextFormatting(update) {\n        this.editContextFormatting = this.editContextFormatting.map(update.changes);\n        for (let tr of update.transactions)for (let effect of tr.effects)if (effect.is(setEditContextFormatting)) {\n            this.editContextFormatting = effect.value;\n        }\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(mustRead = false, fromPointer = false) {\n        if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n        let { dom } = this.tile;\n        let activeElt = this.view.root.activeElement, focused = activeElt == dom;\n        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || dom.tabIndex > -1) && hasSelection(dom, this.view.observer.selectionRange) && !(activeElt && dom.contains(activeElt));\n        if (!(focused || fromPointer || selectionNotFocus)) return;\n        let force = this.forceSelection;\n        this.forceSelection = false;\n        let main = this.view.state.selection.main, anchor, head;\n        if (main.empty) {\n            head = anchor = this.inlineDOMNearPos(main.anchor, main.assoc || 1);\n        } else {\n            head = this.inlineDOMNearPos(main.head, main.head == main.from ? 1 : -1);\n            anchor = this.inlineDOMNearPos(main.anchor, main.anchor == main.from ? 1 : -1);\n        }\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(()=>anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {\n            this.view.observer.ignore(()=>{\n                // Chrome Android will hide the virtual keyboard when tapping\n                // inside an uneditable node, and not bring it back when we\n                // move the cursor to its proper position. This tries to\n                // restore the keyboard by cycling focus.\n                if (browser.android && browser.chrome && dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, dom)) {\n                    dom.blur();\n                    dom.focus({\n                        preventScroll: true\n                    });\n                }\n                let rawSel = getSelection(this.view.root);\n                if (!rawSel) ;\n                else if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* NextTo.Before */  | 2 /* NextTo.After */ )) {\n                            let text = (nextTo == 1 /* NextTo.Before */  ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);\n                            if (text) anchor = new DOMPos(text.node, text.offset);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;\n                } else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    // Safari will ignore the call above when the editor is\n                    // hidden, and then raise an error on the call to extend\n                    // (#940).\n                    try {\n                        rawSel.extend(head.node, head.offset);\n                    } catch (_) {}\n                } else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head) [anchor, head] = [\n                        head,\n                        anchor\n                    ];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n                if (selectionNotFocus && this.view.root.activeElement == dom) {\n                    dom.blur();\n                    if (activeElt) activeElt.focus();\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    // If a zero-length widget is inserted next to the cursor during\n    // composition, avoid moving it across it and disrupting the\n    // composition.\n    suppressWidgetCursorChange(sel, cursor) {\n        return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;\n    }\n    enforceCursorAssoc() {\n        if (this.hasComposition) return;\n        let { view } = this, cursor = view.state.selection.main;\n        let sel = getSelection(view.root);\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n        let line = this.lineAt(cursor.head, cursor.assoc);\n        if (!line) return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top) return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc, cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n        // This can go wrong in corner cases like single-character lines,\n        // so check and reset if necessary.\n        view.observer.readSelectionRange();\n        let newRange = view.observer.selectionRange;\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n    }\n    posFromDOM(node, offset) {\n        let tile = this.tile.nearest(node);\n        if (!tile) return this.tile.dom.compareDocumentPosition(node) & 2 /* PRECEDING */  ? 0 : this.view.state.doc.length;\n        let start = tile.posAtStart;\n        if (tile.isComposite()) {\n            let after;\n            if (node == tile.dom) {\n                after = tile.dom.childNodes[offset];\n            } else {\n                let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n                for(;;){\n                    let parent = node.parentNode;\n                    if (parent == tile.dom) break;\n                    if (bias == 0 && parent.firstChild != parent.lastChild) {\n                        if (node == parent.firstChild) bias = -1;\n                        else bias = 1;\n                    }\n                    node = parent;\n                }\n                if (bias < 0) after = node;\n                else after = node.nextSibling;\n            }\n            if (after == tile.dom.firstChild) return start;\n            while(after && !Tile.get(after))after = after.nextSibling;\n            if (!after) return start + tile.length;\n            for(let i = 0, pos = start;; i++){\n                let child = tile.children[i];\n                if (child.dom == after) return pos;\n                pos += child.length + child.breakAfter;\n            }\n        } else if (tile.isText()) {\n            return node == tile.dom ? start + offset : start + (offset ? tile.length : 0);\n        } else {\n            return start;\n        }\n    }\n    domAtPos(pos, side) {\n        let { tile, offset } = this.tile.resolveBlock(pos, side);\n        if (tile.isWidget()) return tile.domPosFor(pos, side);\n        return tile.domIn(offset, side);\n    }\n    inlineDOMNearPos(pos, side) {\n        let before, beforeOff = -1, beforeBad = false;\n        let after, afterOff = -1, afterBad = false;\n        this.tile.blockTiles((tile, off)=>{\n            if (tile.isWidget()) {\n                if (tile.flags & 32 /* TileFlag.After */  && off >= pos) return true;\n                if (tile.flags & 16 /* TileFlag.Before */ ) beforeBad = true;\n            } else {\n                let end = off + tile.length;\n                if (off <= pos) {\n                    before = tile;\n                    beforeOff = pos - off;\n                    beforeBad = end < pos;\n                }\n                if (end >= pos && !after) {\n                    after = tile;\n                    afterOff = pos - off;\n                    afterBad = off > pos;\n                }\n                if (off > pos && after) return true;\n            }\n        });\n        if (!before && !after) return this.domAtPos(pos, side);\n        if (beforeBad && after) before = null;\n        else if (afterBad && before) after = null;\n        return before && side < 0 || !after ? before.domIn(beforeOff, side) : after.domIn(afterOff, side);\n    }\n    coordsAt(pos, side) {\n        let { tile, offset } = this.tile.resolveBlock(pos, side);\n        if (tile.isWidget()) {\n            if (tile.widget instanceof BlockGapWidget) return null;\n            return tile.coordsInWidget(offset, side, true);\n        }\n        return tile.coordsIn(offset, side);\n    }\n    lineAt(pos, side) {\n        let { tile } = this.tile.resolveBlock(pos, side);\n        return tile.isLine() ? tile : null;\n    }\n    coordsForChar(pos) {\n        let { tile, offset } = this.tile.resolveBlock(pos, 1);\n        if (!tile.isLine()) return null;\n        function scan(tile, offset) {\n            if (tile.isComposite()) {\n                for (let ch of tile.children){\n                    if (ch.length >= offset) {\n                        let found = scan(ch, offset);\n                        if (found) return found;\n                    }\n                    offset -= ch.length;\n                    if (offset < 0) break;\n                }\n            } else if (tile.isText() && offset < tile.length) {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(tile.text, offset);\n                if (end == offset) return null;\n                let rects = textRange(tile.dom, offset, end).getClientRects();\n                for(let i = 0; i < rects.length; i++){\n                    let rect = rects[i];\n                    if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;\n                }\n            }\n            return null;\n        }\n        return scan(tile, offset);\n    }\n    measureVisibleLineHeights(viewport) {\n        let result = [], { from, to } = viewport;\n        let contentWidth = this.view.contentDOM.clientWidth;\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\n        let spaceAbove = 0;\n        let scan = (tile, pos, measureBounds)=>{\n            for(let i = 0; i < tile.children.length; i++){\n                if (pos > to) break;\n                let child = tile.children[i], end = pos + child.length;\n                let childRect = child.dom.getBoundingClientRect(), { height } = childRect;\n                if (measureBounds && !i) spaceAbove += childRect.top - measureBounds.top;\n                if (child instanceof BlockWrapperTile) {\n                    if (end > from) scan(child, pos, childRect);\n                } else if (pos >= from) {\n                    if (spaceAbove > 0) result.push(-spaceAbove);\n                    result.push(height + spaceAbove);\n                    spaceAbove = 0;\n                    if (isWider) {\n                        let last = child.dom.lastChild;\n                        let rects = last ? clientRectsFor(last) : [];\n                        if (rects.length) {\n                            let rect = rects[rects.length - 1];\n                            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n                            if (width > widest) {\n                                widest = width;\n                                this.minWidth = contentWidth;\n                                this.minWidthFrom = pos;\n                                this.minWidthTo = end;\n                            }\n                        }\n                    }\n                }\n                if (measureBounds && i == tile.children.length - 1) spaceAbove += measureBounds.bottom - childRect.bottom;\n                pos = end + child.breakAfter;\n            }\n        };\n        scan(this.tile, 0, null);\n        return result;\n    }\n    textDirectionAt(pos) {\n        let { tile } = this.tile.resolveBlock(pos, 1);\n        return getComputedStyle(tile.dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    }\n    measureTextSize() {\n        let lineMeasure = this.tile.blockTiles((tile)=>{\n            if (tile.isLine() && tile.children.length && tile.length <= 20) {\n                let totalWidth = 0, textHeight;\n                for (let child of tile.children){\n                    if (!child.isText() || /[^ -~]/.test(child.text)) return undefined;\n                    let rects = clientRectsFor(child.dom);\n                    if (rects.length != 1) return undefined;\n                    totalWidth += rects[0].width;\n                    textHeight = rects[0].height;\n                }\n                if (totalWidth) return {\n                    lineHeight: tile.dom.getBoundingClientRect().height,\n                    charWidth: totalWidth / tile.length,\n                    textHeight\n                };\n            }\n        });\n        if (lineMeasure) return lineMeasure;\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth, textHeight;\n        dummy.className = \"cm-line\";\n        dummy.style.width = \"99999px\";\n        dummy.style.position = \"absolute\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(()=>{\n            this.tile.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect && rect.width ? rect.width / 27 : 7;\n            textHeight = rect && rect.height ? rect.height : lineHeight;\n            dummy.remove();\n        });\n        return {\n            lineHeight,\n            charWidth,\n            textHeight\n        };\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for(let pos = 0, i = 0;; i++){\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.view.state.doc.length;\n            if (end > pos) {\n                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n                deco.push(Decoration.replace({\n                    widget: new BlockGapWidget(height),\n                    block: true,\n                    inclusive: true,\n                    isBlockGap: true\n                }).range(pos, end));\n            }\n            if (!next) break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        let i = 1;\n        let allDeco = this.view.state.facet(decorations).map((d)=>{\n            let dynamic = this.dynamicDecorationMap[i++] = typeof d == \"function\";\n            return dynamic ? d(this.view) : d;\n        });\n        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i)=>{\n            let dynamic = typeof d == \"function\";\n            if (dynamic) dynamicOuter = true;\n            return dynamic ? d(this.view) : d;\n        });\n        if (outerDeco.length) {\n            this.dynamicDecorationMap[i++] = dynamicOuter;\n            allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.join(outerDeco));\n        }\n        this.decorations = [\n            this.editContextFormatting,\n            ...allDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n        while(i < this.decorations.length)this.dynamicDecorationMap[i++] = false;\n        this.blockWrappers = this.view.state.facet(blockWrappers).map((v)=>typeof v == \"function\" ? v(this.view) : v);\n    }\n    scrollIntoView(target) {\n        if (target.isSnapshot) {\n            let ref = this.view.viewState.lineBlockAt(target.range.head);\n            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;\n            this.view.scrollDOM.scrollLeft = target.xMargin;\n            return;\n        }\n        for (let handler of this.view.state.facet(scrollHandler)){\n            try {\n                if (handler(this.view, target.range, target)) return true;\n            } catch (e) {\n                logException(this.view.state, e, \"scroll handler\");\n            }\n        }\n        let { range } = target;\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect) return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n            left: Math.min(rect.left, other.left),\n            top: Math.min(rect.top, other.top),\n            right: Math.max(rect.right, other.right),\n            bottom: Math.max(rect.bottom, other.bottom)\n        };\n        let margins = getScrollMargins(this.view);\n        let targetRect = {\n            left: rect.left - margins.left,\n            top: rect.top - margins.top,\n            right: rect.right + margins.right,\n            bottom: rect.bottom + margins.bottom\n        };\n        let { offsetWidth, offsetHeight } = this.view.scrollDOM;\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);\n    }\n    lineHasWidget(pos) {\n        let scan = (child)=>child.isWidget() || child.children.some(scan);\n        return scan(this.tile.resolveBlock(pos, 1).tile);\n    }\n    destroy() {\n        destroyDropped(this.tile);\n    }\n}\nfunction destroyDropped(tile, reused) {\n    let r = reused === null || reused === void 0 ? void 0 : reused.get(tile);\n    if (r != 1 /* Reused.Full */ ) {\n        if (r == null) tile.destroy();\n        for (let ch of tile.children)destroyDropped(ch, reused);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nfunction findCompositionNode(view, headPos) {\n    let sel = view.observer.selectionRange;\n    if (!sel.focusNode) return null;\n    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);\n    let textNode = textBefore || textAfter;\n    if (textAfter && textBefore && textAfter.node != textBefore.node) {\n        let tileAfter = Tile.get(textAfter.node);\n        if (!tileAfter || tileAfter.isText() && tileAfter.text != textAfter.node.nodeValue) {\n            textNode = textAfter;\n        } else if (view.docView.lastCompositionAfterCursor) {\n            let tileBefore = Tile.get(textBefore.node);\n            if (!(!tileBefore || tileBefore.isText() && tileBefore.text != textBefore.node.nodeValue)) textNode = textAfter;\n        }\n    }\n    view.docView.lastCompositionAfterCursor = textNode != textBefore;\n    if (!textNode) return null;\n    let from = headPos - textNode.offset;\n    return {\n        from,\n        to: from + textNode.node.nodeValue.length,\n        node: textNode.node\n    };\n}\nfunction findCompositionRange(view, changes, headPos) {\n    let found = findCompositionNode(view, headPos);\n    if (!found) return null;\n    let { node: textNode, from, to } = found, text = textNode.nodeValue;\n    // Don't try to preserve multi-line compositions\n    if (/[\\n\\r]/.test(text)) return null;\n    if (view.state.doc.sliceString(found.from, found.to) != text) return null;\n    let inv = changes.invertedDesc;\n    return {\n        range: new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to),\n        text: textNode\n    };\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1) return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */  : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange(from, to) {\n        addRange(from, to, this.changes);\n    }\n    comparePoint(from, to) {\n        addRange(from, to, this.changes);\n    }\n    boundChange(pos) {\n        addRange(pos, pos, this.changes);\n    }\n};\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nclass WrapperComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange(from, to) {\n        addRange(from, to, this.changes);\n    }\n    comparePoint() {}\n    boundChange(pos) {\n        addRange(pos, pos, this.changes);\n    }\n}\nfunction findChangedWrappers(a, b, diff) {\n    let comp = new WrapperComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nfunction inUneditable(node, inside) {\n    for(let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode){\n        if (cur.nodeType == 1 && cur.contentEditable == \"false\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction touchesComposition(changes, composition) {\n    let touched = false;\n    if (composition) changes.iterChangedRanges((from, to)=>{\n        if (from < composition.to && to > composition.from) touched = true;\n    });\n    return touched;\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height){\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-gap\";\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) {\n        return other.height == this.height;\n    }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get editable() {\n        return true;\n    }\n    get estimatedHeight() {\n        return this.height;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos);\n    if (linePos == 0) bias = 1;\n    else if (linePos == line.length) bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos, false);\n    else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while(from > 0){\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat) break;\n        from = prev;\n    }\n    while(to < line.length){\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat) break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from + line.from, to + line.from);\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let textHeight = view.viewState.heightOracle.textHeight;\n        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(content, into, view.state.tabSize);\n}\nfunction blockAt(view, pos, side) {\n    let line = view.lineBlockAt(pos);\n    if (Array.isArray(line.type)) {\n        let best;\n        for (let l of line.type){\n            if (l.from > pos) break;\n            if (l.to < pos) continue;\n            if (l.from < pos && l.to > pos) return l;\n            if (!best || l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos))) best = l;\n        }\n        return best || line;\n    }\n    return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = blockAt(view, start.head, start.assoc || -1);\n    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let direction = view.textDirectionAt(line.from);\n        let pos = view.posAtCoords({\n            x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2\n        });\n        if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    let direction = view.textDirectionAt(line.from);\n    for(let cur = start, check = null;;){\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = view.visualLineSide(line, !forward);\n        }\n        if (!check) {\n            if (!by) return next;\n            check = by(char);\n        } else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.CharCategory.Space) cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(startPos, start.assoc);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;\n    if (startCoords) {\n        if (goal == null) goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    } else {\n        let line = view.viewState.lineBlockAt(startPos);\n        if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;\n    let pos = posAtCoords(view, {\n        x: resolvedGoal,\n        y: startY + dist * dir\n    }, false, dir);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos.pos, pos.assoc, undefined, goal);\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n    for(;;){\n        let moved = 0;\n        for (let set of atoms){\n            set.between(pos - 1, pos + 1, (from, to, value)=>{\n                if (pos > from && pos < to) {\n                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n                    pos = side < 0 ? from : to;\n                    moved = side;\n                }\n            });\n        }\n        if (!moved) return pos;\n    }\n}\nfunction skipAtomsForSelection(atoms, sel) {\n    let ranges = null;\n    for(let i = 0; i < sel.ranges.length; i++){\n        let range = sel.ranges[i], updated = null;\n        if (range.empty) {\n            let pos = skipAtomicRanges(atoms, range.from, 0);\n            if (pos != range.from) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, -1);\n        } else {\n            let from = skipAtomicRanges(atoms, range.from, -1);\n            let to = skipAtomicRanges(atoms, range.to, 1);\n            if (from != range.from || to != range.to) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n        }\n        if (updated) {\n            if (!ranges) ranges = sel.ranges.slice();\n            ranges[i] = updated;\n        }\n    }\n    return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f)=>f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\nclass PosAssoc {\n    constructor(pos, assoc){\n        this.pos = pos;\n        this.assoc = assoc;\n    }\n}\nfunction posAtCoords(view, coords, precise, scanY) {\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\n    let { x, y } = coords, yOffset = y - docTop, block;\n    // First find the block at the given Y position, if any. If scanY is\n    // given (used for vertical cursor motion), try to skip widgets and\n    // line padding.\n    for(;;){\n        if (yOffset < 0) return new PosAssoc(0, 1);\n        if (yOffset > view.viewState.docHeight) return new PosAssoc(view.state.doc.length, -1);\n        block = view.elementAtHeight(yOffset);\n        if (scanY == null) break;\n        if (block.type == BlockType.Text) {\n            // Check whether we aren't landing the top/bottom padding of the line\n            let rect = view.docView.coordsAt(scanY < 0 ? block.from : block.to, scanY);\n            if (rect && (scanY < 0 ? rect.top <= yOffset + docTop : rect.bottom >= yOffset + docTop)) break;\n        }\n        let halfLine = view.viewState.heightOracle.textHeight / 2;\n        yOffset = scanY > 0 ? block.bottom + halfLine : block.top - halfLine;\n    }\n    // If outside the viewport, return null if precise==true, an\n    // estimate otherwise.\n    if (view.viewport.from >= block.to || view.viewport.to <= block.from) {\n        if (precise) return null;\n        if (block.type == BlockType.Text) {\n            let pos = posAtCoordsImprecise(view, content, block, x, y);\n            return new PosAssoc(pos, pos == block.from ? 1 : -1);\n        }\n    }\n    if (block.type != BlockType.Text) return yOffset < (block.top + block.bottom) / 2 ? new PosAssoc(block.from, 1) : new PosAssoc(block.to, -1);\n    // Here we know we're in a line, so run the logic for inline layout\n    let line = view.docView.lineAt(block.from, 2);\n    if (!line || line.length != block.length) line = view.docView.lineAt(block.from, -2);\n    return posAtCoordsInline(view, line, block.from, x, y);\n}\n// Scan through the rectangles for the content of a tile, finding the\n// one closest to the given coordinates, prefering closeness in Y over\n// closeness in X.\n//\n// If this is a text tile, go character-by-character. For line or mark\n// tiles, check each non-point-widget child, and descend text or mark\n// tiles with a recursive call.\n//\n// For non-wrapped, purely left-to-right text, this could use a binary\n// search. But because this seems to be fast enough, for how often it\n// is called, there's not currently a specialized implementation for\n// that.\nfunction posAtCoordsInline(view, tile, offset, x, y) {\n    let closest = -1, closestRect = null;\n    let dxClosest = 1e9, dyClosest = 1e9;\n    let rowTop = y, rowBot = y;\n    let checkRects = (rects, index)=>{\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (rect.top == rect.bottom) continue;\n            let dx = rect.left > x ? rect.left - x : rect.right < x ? x - rect.right : 0;\n            let dy = rect.top > y ? rect.top - y : rect.bottom < y ? y - rect.bottom : 0;\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                // Rectangle is in the current row\n                rowTop = Math.min(rect.top, rowTop);\n                rowBot = Math.max(rect.bottom, rowBot);\n                dy = 0;\n            }\n            if (closest < 0 || (dy - dyClosest || dx - dxClosest) < 0) {\n                if (closest >= 0 && dyClosest && dxClosest < dx && closestRect.top <= rowBot - 2 && closestRect.bottom >= rowTop + 2) {\n                    // Retroactively set dy to 0 if the current match is in this row.\n                    dyClosest = 0;\n                } else {\n                    closest = index;\n                    dxClosest = dx;\n                    dyClosest = dy;\n                    closestRect = rect;\n                }\n            }\n        }\n    };\n    if (tile.isText()) {\n        for(let i = 0; i < tile.length;){\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(tile.text, i);\n            checkRects(textRange(tile.dom, i, next).getClientRects(), i);\n            if (!dxClosest && !dyClosest) break;\n            i = next;\n        }\n        let after = x > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);\n        return after ? new PosAssoc(offset + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(tile.text, closest), -1) : new PosAssoc(offset + closest, 1);\n    } else {\n        if (!tile.length) return new PosAssoc(offset, 1);\n        for(let i = 0; i < tile.children.length; i++){\n            let child = tile.children[i];\n            if (child.flags & 48 /* TileFlag.PointWidget */ ) continue;\n            let rects = (child.dom.nodeType == 1 ? child.dom : textRange(child.dom, 0, child.length)).getClientRects();\n            checkRects(rects, i);\n            if (!dxClosest && !dyClosest) break;\n        }\n        let inner = tile.children[closest], innerOff = tile.posBefore(inner, offset);\n        if (inner.isComposite() || inner.isText()) return posAtCoordsInline(view, inner, innerOff, Math.max(closestRect.left, Math.min(closestRect.right, x)), y);\n        let after = x > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);\n        return after ? new PosAssoc(innerOff + inner.length, -1) : new PosAssoc(innerOff, 1);\n    }\n}\nfunction dirAt(view, pos) {\n    let line = view.state.doc.lineAt(pos), spans = view.bidiSpans(line);\n    return spans[BidiSpan.find(view.bidiSpans(line), pos - line.from, -1, 1)].dir;\n}\nconst LineBreakPlaceholder = \"ï¿¿\";\nclass DOMReader {\n    constructor(points, view){\n        this.points = points;\n        this.view = view;\n        this.text = \"\";\n        this.lineSeparator = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.lineSeparator);\n    }\n    append(text) {\n        this.text += text;\n    }\n    lineBreak() {\n        this.text += LineBreakPlaceholder;\n    }\n    readRange(start, end) {\n        if (!start) return this;\n        let parent = start.parentNode;\n        for(let cur = start;;){\n            this.findPointBefore(parent, cur);\n            let oldLen = this.text.length;\n            this.readNode(cur);\n            let tile = Tile.get(cur), next = cur.nextSibling;\n            if (next == end) {\n                if ((tile === null || tile === void 0 ? void 0 : tile.breakAfter) && !next && parent != this.view.contentDOM) this.lineBreak();\n                break;\n            }\n            let nextTile = Tile.get(next);\n            if ((tile && nextTile ? tile.breakAfter : (tile ? tile.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || (tile === null || tile === void 0 ? void 0 : tile.isWidget())) && this.text.length > oldLen) && !isEmptyToEnd(next, end)) this.lineBreak();\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n        return this;\n    }\n    readTextNode(node) {\n        let text = node.nodeValue;\n        for (let point of this.points)if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n        for(let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;){\n            let nextBreak = -1, breakSize = 1, m;\n            if (this.lineSeparator) {\n                nextBreak = text.indexOf(this.lineSeparator, off);\n                breakSize = this.lineSeparator.length;\n            } else if (m = re.exec(text)) {\n                nextBreak = m.index;\n                breakSize = m[0].length;\n            }\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n            if (nextBreak < 0) break;\n            this.lineBreak();\n            if (breakSize > 1) {\n                for (let point of this.points)if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n            }\n            off = nextBreak + breakSize;\n        }\n    }\n    readNode(node) {\n        let tile = Tile.get(node);\n        let fromView = tile && tile.overrideDOMText;\n        if (fromView != null) {\n            this.findPointInside(node, fromView.length);\n            for(let i = fromView.iter(); !i.next().done;){\n                if (i.lineBreak) this.lineBreak();\n                else this.append(i.value);\n            }\n        } else if (node.nodeType == 3) {\n            this.readTextNode(node);\n        } else if (node.nodeName == \"BR\") {\n            if (node.nextSibling) this.lineBreak();\n        } else if (node.nodeType == 1) {\n            this.readRange(node.firstChild, null);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n    }\n    findPointInside(node, length) {\n        for (let point of this.points)if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);\n    }\n}\nfunction isAtEnd(parent, node, offset) {\n    for(;;){\n        if (!node || offset < maxOffset(node)) return false;\n        if (node == parent) return true;\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n}\nfunction isEmptyToEnd(node, end) {\n    let widgets;\n    for(;; node = node.nextSibling){\n        if (node == end || !node) break;\n        let view = Tile.get(node);\n        if (!(view === null || view === void 0 ? void 0 : view.isWidget())) return false;\n        if (view) (widgets || (widgets = [])).push(view);\n    }\n    if (widgets) for (let w of widgets){\n        let override = w.overrideDOMText;\n        if (override === null || override === void 0 ? void 0 : override.length) return false;\n    }\n    return true;\n}\nclass DOMPoint {\n    constructor(node, offset){\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nclass DOMChange {\n    constructor(view, start, end, typeOver){\n        this.typeOver = typeOver;\n        this.bounds = null;\n        this.text = \"\";\n        this.domChanged = start > -1;\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        if (view.state.readOnly && start > -1) {\n            // Ignore changes when the editor is read-only\n            this.newSel = null;\n        } else if (start > -1 && (this.bounds = domBoundsAround(view.docView.tile, start, end, 0))) {\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n            let reader = new DOMReader(selPoints, view);\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n            this.text = reader.text;\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n        } else {\n            let domSel = view.observer.selectionRange;\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n            // iOS will refuse to select the block gaps when doing\n            // select-all.\n            // Chrome will put the selection *inside* them, confusing\n            // posFromDOM\n            let vp = view.viewport;\n            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {\n                let from = Math.min(head, anchor), to = Math.max(head, anchor);\n                let offFrom = vp.from - from, offTo = vp.to - to;\n                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {\n                    head = 0;\n                    anchor = view.state.doc.length;\n                }\n            }\n            if (view.inputState.composing > -1 && view.state.selection.ranges.length > 1) this.newSel = view.state.selection.replaceRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(anchor, head));\n            else this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(anchor, head);\n        }\n    }\n}\nfunction domBoundsAround(tile, from, to, offset) {\n    if (tile.isComposite()) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for(let i = 0, pos = offset, prevEnd = offset; i < tile.children.length; i++){\n            let child = tile.children[i], end = pos + child.length;\n            if (pos < from && end > to) return domBoundsAround(child, from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == tile.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return {\n            from: fromStart,\n            to: toEnd < 0 ? offset + tile.length : toEnd,\n            startDOM: (fromI ? tile.children[fromI - 1].dom.nextSibling : null) || tile.dom.firstChild,\n            endDOM: toI < tile.children.length && toI >= 0 ? tile.children[toI].dom : null\n        };\n    } else if (tile.isText()) {\n        return {\n            from: offset,\n            to: offset + tile.length,\n            startDOM: tile.dom,\n            endDOM: tile.dom.nextSibling\n        };\n    } else {\n        return null;\n    }\n}\nfunction applyDOMChange(view, domChange) {\n    let change;\n    let { newSel } = domChange, sel = view.state.selection.main;\n    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n    if (domChange.bounds) {\n        let { from, to } = domChange.bounds;\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n        if (diff) {\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. DomChange drops one of those.\n            if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n            change = {\n                from: from + diff.from,\n                to: from + diff.toA,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n            };\n        }\n    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || sameSelPos(newSel, sel))) {\n        newSel = null;\n    }\n    if (!change && !newSel) return false;\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n        // Heuristic to notice typing over a selected character\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, sel.to)\n        };\n    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n        // Detect insert-period-on-double-space Mac and Android behavior,\n        // and transform it into a regular space insert.\n        if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: change.from,\n            to: change.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([\n                change.insert.toString().replace(\".\", \" \")\n            ])\n        };\n    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n        // If the change is inside the selection and covers most of it,\n        // assume it is a selection replace (with identical characters at\n        // the start/end not included in the diff)\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    } else if (view.state.doc.lineAt(sel.from).to < sel.to && view.docView.lineHasWidget(sel.to) && view.inputState.insertingTextAt > Date.now() - 50) {\n        // For a cross-line insertion, Chrome and Safari will crudely take\n        // the text of the line after the selection, flattening any\n        // widgets, and move it into the joined line. This tries to detect\n        // such a situation, and replaces the change with a selection\n        // replace of the text provided by the beforeinput event.\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.toText(view.inputState.insertingText)\n        };\n    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n        // In Chrome, if you insert a space at the start of a wrapped\n        // line, it will actually insert a newline and a space, causing a\n        // bogus new line to be created in CodeMirror (#968)\n        if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([\n                \" \"\n            ])\n        };\n    }\n    if (change) {\n        return applyDOMChangeInner(view, change, newSel, lastKey);\n    } else if (newSel && !sameSelPos(newSel, sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n            if (userEvent == \"select.pointer\") newSel = skipAtomsForSelection(view.state.facet(atomicRanges).map((f)=>f(view)), newSel);\n        }\n        view.dispatch({\n            selection: newSel,\n            scrollIntoView,\n            userEvent\n        });\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction applyDOMChangeInner(view, change, newSel, lastKey = -1) {\n    if (browser.ios && view.inputState.flushIOSKey(change)) return true;\n    let sel = view.state.selection.main;\n    // Android browsers don't fire reasonable key events for enter,\n    // backspace, or delete. So this detects changes that look like\n    // they're caused by those keys, and reinterprets them as key\n    // events. (Some of these keys are also handled by beforeinput\n    // events and the pendingAndroidKey mechanism, but that's not\n    // reliable in all situations.)\n    if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted\n    // after a completion when you press enter\n    (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == \" \") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n    let text = change.insert.toString();\n    if (view.inputState.composing >= 0) view.inputState.composing++;\n    let defaultTr;\n    let defaultInsert = ()=>defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n    if (!view.state.facet(inputHandler).some((h)=>h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());\n    return true;\n}\nfunction applyDefaultInsert(view, change, newSel) {\n    let tr, startState = view.state, sel = startState.selection.main, inAtomic = -1;\n    if (change.from == change.to && change.from < sel.from || change.from > sel.to) {\n        let side = change.from < sel.from ? -1 : 1, pos = side < 0 ? sel.from : sel.to;\n        let moved = skipAtomicRanges(startState.facet(atomicRanges).map((f)=>f(view)), pos, side);\n        if (change.from == moved) inAtomic = moved;\n    }\n    if (inAtomic > -1) {\n        tr = {\n            changes: change,\n            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(change.from + change.insert.length, -1)\n        };\n    } else if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n        let changes = startState.changes(change);\n        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n        // Try to apply a composition change to all cursors\n        if (startState.selection.ranges.length > 1 && (view.inputState.composing >= 0 || view.inputState.compositionPendingChange) && change.to <= sel.to + 10 && change.to >= sel.to - 10) {\n            let replaced = view.state.sliceDoc(change.from, change.to);\n            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);\n            if (composition) {\n                let dLen = change.insert.length - (change.to - change.from);\n                compositionRange = {\n                    from: composition.from,\n                    to: composition.to - dLen\n                };\n            } else {\n                compositionRange = view.state.doc.lineAt(sel.head);\n            }\n            let offset = sel.to - change.to;\n            tr = startState.changeByRange((range)=>{\n                if (range.from == sel.from && range.to == sel.to) return {\n                    changes,\n                    range: mainSel || range.map(changes)\n                };\n                let to = range.to - offset, from = to - replaced.length;\n                if (view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple\n                // changes in the same node work without aborting\n                // composition, so cursors in the composition range are\n                // ignored.\n                to >= compositionRange.from && from <= compositionRange.to) return {\n                    range\n                };\n                let rangeChanges = startState.changes({\n                    from,\n                    to,\n                    insert: change.insert\n                }), selOff = range.to - sel.to;\n                return {\n                    changes: rangeChanges,\n                    range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n                };\n            });\n        } else {\n            tr = {\n                changes,\n                selection: mainSel && startState.selection.replaceRange(mainSel)\n            };\n        }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n        view.inputState.compositionPendingChange = false;\n        userEvent += \".compose\";\n        if (view.inputState.compositionFirstChange) {\n            userEvent += \".start\";\n            view.inputState.compositionFirstChange = false;\n        }\n    }\n    return startState.update(tr, {\n        userEvent,\n        scrollIntoView: true\n    });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while(from < minLen && a.charCodeAt(from) == b.charCodeAt(from))from++;\n    if (from == minLen && a.length == b.length) return null;\n    let toA = a.length, toB = b.length;\n    while(toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)){\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    } else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return {\n        from,\n        toA,\n        toB\n    };\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM) return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0) return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(anchor + base, head + base) : null;\n}\nfunction sameSelPos(selection, range) {\n    return range.head == selection.main.head && range.anchor == selection.main.anchor;\n}\nclass InputState {\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    constructor(view){\n        this.view = view;\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastTouchTime = 0;\n        this.lastFocusTime = 0;\n        this.lastScrollTop = 0;\n        this.lastScrollLeft = 0;\n        // On iOS, some keys need to have their default behavior happen\n        // (after which we retroactively handle them and reset the DOM) to\n        // avoid messing up the virtual keyboard state.\n        this.pendingIOSKey = undefined;\n        /**\n        When enabled (>-1), tab presses are not given to key handlers,\n        leaving the browser's default behavior. If >0, the mode expires\n        at that timestamp, and any other keypress clears it.\n        Esc enables temporary tab focus mode for two seconds when not\n        otherwise handled.\n        */ this.tabFocusMode = -1;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.handlers = Object.create(null);\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        // End time of the previous composition\n        this.compositionEndedAt = 0;\n        // Used in a kludge to detect when an Enter keypress should be\n        // considered part of the composition on Safari, which fires events\n        // in the wrong order\n        this.compositionPendingKey = false;\n        // Used to categorize changes as part of a composition, even when\n        // the mutation events fire shortly after the compositionend event\n        this.compositionPendingChange = false;\n        // Set by beforeinput, used in DOM change reader\n        this.insertingText = \"\";\n        this.insertingTextAt = 0;\n        this.mouseSelection = null;\n        // When a drag from the editor is active, this points at the range\n        // being dragged.\n        this.draggedContent = null;\n        this.handleEvent = this.handleEvent.bind(this);\n        this.notifiedFocused = view.hasFocus;\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari) view.contentDOM.addEventListener(\"input\", ()=>null);\n        if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);\n    }\n    handleEvent(event) {\n        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;\n        if (event.type == \"keydown\" && this.keydown(event)) return;\n        if (this.view.updateState != 0 /* UpdateState.Idle */ ) Promise.resolve().then(()=>this.runHandlers(event.type, event));\n        else this.runHandlers(event.type, event);\n    }\n    runHandlers(type, event) {\n        let handlers = this.handlers[type];\n        if (handlers) {\n            for (let observer of handlers.observers)observer(this.view, event);\n            for (let handler of handlers.handlers){\n                if (event.defaultPrevented) break;\n                if (handler(this.view, event)) {\n                    event.preventDefault();\n                    break;\n                }\n            }\n        }\n    }\n    ensureHandlers(plugins) {\n        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;\n        for(let type in handlers)if (type != \"scroll\") {\n            let passive = !handlers[type].handlers.length;\n            let exists = prev[type];\n            if (exists && passive != !exists.handlers.length) {\n                dom.removeEventListener(type, this.handleEvent);\n                exists = null;\n            }\n            if (!exists) dom.addEventListener(type, this.handleEvent, {\n                passive\n            });\n        }\n        for(let type in prev)if (type != \"scroll\" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);\n        this.handlers = handlers;\n    }\n    keydown(event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return true;\n        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.tabFocusMode = -1;\n        // Chrome for Android usually doesn't fire proper key events, but\n        // occasionally does, usually surrounded by a bunch of complicated\n        // composition changes. When an enter or backspace key event is\n        // seen, hold off on handling DOM events for a bit, and then\n        // dispatch it.\n        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n            this.view.observer.delayAndroidKey(event.key, event.keyCode);\n            return true;\n        }\n        // Preventing the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        let pending;\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key)=>key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n            this.pendingIOSKey = pending || event;\n            setTimeout(()=>this.flushIOSKey(), 250);\n            return true;\n        }\n        if (event.keyCode != 229) this.view.observer.forceFlush();\n        return false;\n    }\n    flushIOSKey(change) {\n        let key = this.pendingIOSKey;\n        if (!key) return false;\n        // This looks like an autocorrection before Enter\n        if (key.key == \"Enter\" && change && change.from < change.to && /^\\S+$/.test(change.insert.toString())) return false;\n        this.pendingIOSKey = undefined;\n        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type) || event.synthetic) return false;\n        if (this.composing > 0) return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n            this.compositionPendingKey = false;\n            return true;\n        }\n        return false;\n    }\n    startMouseSelection(mouseSelection) {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n        this.mouseSelection = mouseSelection;\n    }\n    update(update) {\n        this.view.observer.update(update);\n        if (this.mouseSelection) this.mouseSelection.update(update);\n        if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);\n        if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n    }\n}\nfunction bindHandler(plugin, handler) {\n    return (view, event)=>{\n        try {\n            return handler.call(plugin, event, view);\n        } catch (e) {\n            logException(view.state, e);\n        }\n    };\n}\nfunction computeHandlers(plugins) {\n    let result = Object.create(null);\n    function record(type) {\n        return result[type] || (result[type] = {\n            observers: [],\n            handlers: []\n        });\n    }\n    for (let plugin of plugins){\n        let spec = plugin.spec, handlers = spec && spec.plugin.domEventHandlers, observers = spec && spec.plugin.domEventObservers;\n        if (handlers) for(let type in handlers){\n            let f = handlers[type];\n            if (f) record(type).handlers.push(bindHandler(plugin.value, f));\n        }\n        if (observers) for(let type in observers){\n            let f = observers[type];\n            if (f) record(type).observers.push(bindHandler(plugin.value, f));\n        }\n    }\n    for(let type in handlers)record(type).handlers.push(handlers[type]);\n    for(let type in observers)record(type).observers.push(observers[type]);\n    return result;\n}\nconst PendingKeys = [\n    {\n        key: \"Backspace\",\n        keyCode: 8,\n        inputType: \"deleteContentBackward\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertParagraph\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertLineBreak\"\n    },\n    {\n        key: \"Delete\",\n        keyCode: 46,\n        inputType: \"deleteContentForward\"\n    }\n];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [\n    16,\n    17,\n    18,\n    20,\n    91,\n    92,\n    224,\n    225\n];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n    return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n    constructor(view, startEvent, style, mustSelect){\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        this.mustSelect = mustSelect;\n        this.scrollSpeed = {\n            x: 0,\n            y: 0\n        };\n        this.scrolling = -1;\n        this.lastEvent = startEvent;\n        this.scrollParents = scrollableParents(view.contentDOM);\n        this.atoms = view.state.facet(atomicRanges).map((f)=>f(view));\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n    }\n    start(event) {\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) this.select(event);\n    }\n    move(event) {\n        if (event.buttons == 0) return this.destroy();\n        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;\n        this.select(this.lastEvent = event);\n        let sx = 0, sy = 0;\n        let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;\n        if (this.scrollParents.x) ({ left, right } = this.scrollParents.x.getBoundingClientRect());\n        if (this.scrollParents.y) ({ top, bottom } = this.scrollParents.y.getBoundingClientRect());\n        let margins = getScrollMargins(this.view);\n        if (event.clientX - margins.left <= left + dragScrollMargin) sx = -dragScrollSpeed(left - event.clientX);\n        else if (event.clientX + margins.right >= right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - right);\n        if (event.clientY - margins.top <= top + dragScrollMargin) sy = -dragScrollSpeed(top - event.clientY);\n        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - bottom);\n        this.setScrollSpeed(sx, sy);\n    }\n    up(event) {\n        if (this.dragging == null) this.select(this.lastEvent);\n        if (!this.dragging) event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        this.setScrollSpeed(0, 0);\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n    }\n    setScrollSpeed(sx, sy) {\n        this.scrollSpeed = {\n            x: sx,\n            y: sy\n        };\n        if (sx || sy) {\n            if (this.scrolling < 0) this.scrolling = setInterval(()=>this.scroll(), 50);\n        } else if (this.scrolling > -1) {\n            clearInterval(this.scrolling);\n            this.scrolling = -1;\n        }\n    }\n    scroll() {\n        let { x, y } = this.scrollSpeed;\n        if (x && this.scrollParents.x) {\n            this.scrollParents.x.scrollLeft += x;\n            x = 0;\n        }\n        if (y && this.scrollParents.y) {\n            this.scrollParents.y.scrollTop += y;\n            y = 0;\n        }\n        if (x || y) this.view.win.scrollBy(x, y);\n        if (this.dragging === false) this.select(this.lastEvent);\n    }\n    select(event) {\n        let { view } = this, selection = skipAtomsForSelection(this.atoms, this.style.get(event, this.extend, this.multiple));\n        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({\n            selection,\n            userEvent: \"select.pointer\"\n        });\n        this.mustSelect = false;\n    }\n    update(update) {\n        if (update.transactions.some((tr)=>tr.isUserEvent(\"input.type\"))) this.destroy();\n        else if (this.style.update(update)) setTimeout(()=>this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty) return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (!sel || sel.rangeCount == 0) return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for(let i = 0; i < rects.length; i++){\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target, tile; node != view.contentDOM; node = node.parentNode)if (!node || node.nodeType == 11 || (tile = Tile.get(node)) && tile.isWidget() && !tile.isHidden && tile.widget.ignoreEvent(event)) return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/ Object.create(null);\nconst observers = /*@__PURE__*/ Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIâ€”all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(()=>{\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction textFilter(state, facet, text) {\n    for (let filter of state.facet(facet))text = filter(text, state);\n    return text;\n}\nfunction doPaste(view, input) {\n    input = textFilter(view.state, clipboardInputFilter, input);\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r)=>r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange((range)=>{\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine) return {\n                range\n            };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return {\n                changes: {\n                    from: line.from,\n                    insert\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(range.from + insert.length)\n            };\n        });\n    } else if (byLine) {\n        changes = state.changeByRange((range)=>{\n            let line = text.line(i++);\n            return {\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: line.text\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(range.from + line.length)\n            };\n        });\n    } else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nobservers.scroll = (view)=>{\n    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;\n    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;\n};\nhandlers.keydown = (view, event)=>{\n    view.inputState.setSelectionOrigin(\"select\");\n    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0) view.inputState.tabFocusMode = Date.now() + 2000;\n    return false;\n};\nobservers.touchstart = (view, e)=>{\n    view.inputState.lastTouchTime = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nobservers.touchmove = (view)=>{\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event)=>{\n    view.observer.flush();\n    if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)){\n        style = makeStyle(view, event);\n        if (style) break;\n    }\n    if (!style && event.button == 0) style = basicMouseSelection(view, event);\n    if (style) {\n        let mustFocus = !view.hasFocus;\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n        if (mustFocus) view.observer.ignore(()=>{\n            focusPreventScroll(view.contentDOM);\n            let active = view.root.activeElement;\n            if (active && !active.contains(view.contentDOM)) active.blur();\n        });\n        let mouseSel = view.inputState.mouseSelection;\n        if (mouseSel) {\n            mouseSel.start(event);\n            return mouseSel.dragging === false;\n        }\n    } else {\n        view.inputState.setSelectionOrigin(\"select.pointer\");\n    }\n    return false;\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos, bias);\n    } else if (type == 2) {\n        return groupAt(view.state, pos, bias);\n    } else {\n        let visual = view.docView.lineAt(pos, bias), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to) to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to);\n    }\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail) return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = view.posAndSideAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false), type = getClickType(event);\n    let startSel = view.state.selection;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, extend, multiple) {\n            let cur = view.posAndSideAtCoords({\n                x: event.clientX,\n                y: event.clientY\n            }, false), removed;\n            let range = rangeForClick(view, cur.pos, cur.assoc, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.assoc, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(to, from);\n            }\n            if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;\n            else if (multiple) return startSel.addRange(range);\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create([\n                range\n            ]);\n        }\n    };\n}\nfunction removeRangeAround(sel, pos) {\n    for(let i = 0; i < sel.ranges.length; i++){\n        let { from, to } = sel.ranges[i];\n        if (from <= pos && to >= pos) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n    }\n    return null;\n}\nhandlers.dragstart = (view, event)=>{\n    let { selection: { main: range } } = view.state;\n    if (event.target.draggable) {\n        let tile = view.docView.tile.nearest(event.target);\n        if (tile && tile.isWidget()) {\n            let from = tile.posAtStart, to = from + tile.length;\n            if (from >= range.to || to <= range.from) range = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(from, to);\n        }\n    }\n    let { inputState } = view;\n    if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;\n    inputState.draggedContent = range;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n    return false;\n};\nhandlers.dragend = (view)=>{\n    view.inputState.draggedContent = null;\n    return false;\n};\nfunction dropText(view, event, text, direct) {\n    text = textFilter(view.state, clipboardInputFilter, text);\n    if (!text) return;\n    let dropPos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let { draggedContent } = view.inputState;\n    let del = direct && draggedContent && dragMovesSelection(view, event) ? {\n        from: draggedContent.from,\n        to: draggedContent.to\n    } : null;\n    let ins = {\n        from: dropPos,\n        insert: text\n    };\n    let changes = view.state.changes(del ? [\n        del,\n        ins\n    ] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: {\n            anchor: changes.mapPos(dropPos, -1),\n            head: changes.mapPos(dropPos, 1)\n        },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n    view.inputState.draggedContent = null;\n}\nhandlers.drop = (view, event)=>{\n    if (!event.dataTransfer) return false;\n    if (view.state.readOnly) return true;\n    let files = event.dataTransfer.files;\n    if (files && files.length) {\n        let text = Array(files.length), read = 0;\n        let finishFile = ()=>{\n            if (++read == files.length) dropText(view, event, text.filter((s)=>s != null).join(view.state.lineBreak), false);\n        };\n        for(let i = 0; i < files.length; i++){\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = ()=>{\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n        return true;\n    } else {\n        let text = event.dataTransfer.getData(\"Text\");\n        if (text) {\n            dropText(view, event, text, true);\n            return true;\n        }\n    }\n    return false;\n};\nhandlers.paste = (view, event)=>{\n    if (view.state.readOnly) return true;\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-list\"));\n        return true;\n    } else {\n        capturePaste(view);\n        return false;\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(()=>{\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)if (!range.empty) {\n        content.push(state.sliceDoc(range.from, range.to));\n        ranges.push(range);\n    }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges){\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({\n                    from: line.from,\n                    to: Math.min(state.doc.length, line.to + 1)\n                });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return {\n        text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)),\n        ranges,\n        linewise\n    };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event)=>{\n    // If the DOM selection is outside this editor, don't intercept.\n    // This happens when a parent editor (like ProseMirror) selects content that\n    // spans multiple elements including this CodeMirror. The copy event may\n    // bubble through CodeMirror (e.g. when CodeMirror is the first or the last\n    // element in the selection), but we should let the parent handle it.\n    let domSel = getSelection(view.root);\n    if (domSel && !hasSelection(view.contentDOM, domSel)) return false;\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise) return false;\n    lastLinewiseCopy = linewise ? text : null;\n    if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n        changes: ranges,\n        scrollIntoView: true,\n        userEvent: \"delete.cut\"\n    });\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        data.clearData();\n        data.setData(\"text/plain\", text);\n        return true;\n    } else {\n        captureCopy(view, text);\n        return false;\n    }\n};\nconst isFocusChange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n    let effects = [];\n    for (let getEffect of state.facet(focusChangeEffect)){\n        let effect = getEffect(state, focus);\n        if (effect) effects.push(effect);\n    }\n    return effects.length ? state.update({\n        effects,\n        annotations: isFocusChange.of(true)\n    }) : null;\n}\nfunction updateForFocusChange(view) {\n    setTimeout(()=>{\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            let tr = focusChangeTransaction(view.state, focus);\n            if (tr) view.dispatch(tr);\n            else view.update([]);\n        }\n    }, 10);\n}\nobservers.focus = (view)=>{\n    view.inputState.lastFocusTime = Date.now();\n    // When focusing reset the scroll position, move it back to where it was\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n    }\n    updateForFocusChange(view);\n};\nobservers.blur = (view)=>{\n    view.observer.clearSelectionRange();\n    updateForFocusChange(view);\n};\nobservers.compositionstart = observers.compositionupdate = (view)=>{\n    if (view.observer.editContext) return; // Composition handled by edit context\n    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nobservers.compositionend = (view)=>{\n    if (view.observer.editContext) return; // Composition handled by edit context\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionPendingKey = true;\n    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n    view.inputState.compositionFirstChange = null;\n    if (browser.chrome && browser.android) {\n        // Delay flushing for a bit on Android because it'll often fire a\n        // bunch of contradictory changes in a row at end of compositon\n        view.observer.flushSoon();\n    } else if (view.inputState.compositionPendingChange) {\n        // If we found pending records, schedule a flush.\n        Promise.resolve().then(()=>view.observer.flush());\n    } else {\n        // Otherwise, make sure that, if no changes come in soon, the\n        // composition view is cleared.\n        setTimeout(()=>{\n            if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);\n        }, 50);\n    }\n};\nobservers.contextmenu = (view)=>{\n    view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event)=>{\n    var _a, _b;\n    if (event.inputType == \"insertText\" || event.inputType == \"insertCompositionText\") {\n        view.inputState.insertingText = event.data;\n        view.inputState.insertingTextAt = Date.now();\n    }\n    // In EditContext mode, we must handle insertReplacementText events\n    // directly, to make spell checking corrections work\n    if (event.inputType == \"insertReplacementText\" && view.observer.editContext) {\n        let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData(\"text/plain\"), ranges = event.getTargetRanges();\n        if (text && ranges.length) {\n            let r = ranges[0];\n            let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);\n            applyDOMChangeInner(view, {\n                from,\n                to,\n                insert: view.state.toText(text)\n            }, null);\n            return true;\n        }\n    }\n    // Because Chrome Android doesn't fire useful key events, use\n    // beforeinput to detect backspace (and possibly enter and delete,\n    // but those usually don't even seem to fire beforeinput events at\n    // the moment) and fake a key event for it.\n    //\n    // (preventDefault on beforeinput, though supported in the spec,\n    // seems to do nothing at all on Chrome).\n    let pending;\n    if (browser.chrome && browser.android && (pending = PendingKeys.find((key)=>key.inputType == event.inputType))) {\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n            let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;\n            setTimeout(()=>{\n                var _a;\n                // Backspacing near uneditable nodes on Chrome Android sometimes\n                // closes the virtual keyboard. This tries to crudely detect\n                // that and refocus to get it back.\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n                    view.contentDOM.blur();\n                    view.focus();\n                }\n            }, 100);\n        }\n    }\n    if (browser.ios && event.inputType == \"deleteContentForward\") {\n        // For some reason, DOM changes (and beforeinput) happen _before_\n        // the key event for ctrl-d on iOS when using an external\n        // keyboard.\n        view.observer.flushSoon();\n    }\n    // Safari will occasionally forget to fire compositionend at the end of a dead-key composition\n    if (browser.safari && event.inputType == \"insertText\" && view.inputState.composing >= 0) {\n        setTimeout(()=>observers.compositionend(view, event), 20);\n    }\n    return false;\n};\nconst appliedFirefoxHack = /*@__PURE__*/ new Set;\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n    if (!appliedFirefoxHack.has(doc)) {\n        appliedFirefoxHack.add(doc);\n        doc.addEventListener(\"copy\", ()=>{});\n        doc.addEventListener(\"cut\", ()=>{});\n    }\n}\nconst wrappingWhiteSpace = [\n    \"pre-wrap\",\n    \"normal\",\n    \"pre-line\",\n    \"break-spaces\"\n];\n// Used to track, during updateHeight, if any actual heights changed\nlet heightChangeFlag = false;\nfunction clearHeightChangeFlag() {\n    heightChangeFlag = false;\n}\nclass HeightOracle {\n    constructor(lineWrapping){\n        this.lineWrapping = lineWrapping;\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n        this.heightSamples = {};\n        this.lineHeight = 14; // The height of an entire line (line-height)\n        this.charWidth = 7;\n        this.textHeight = 14; // The height of the actual font (font-size)\n        this.lineLength = 30;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping) return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) {\n        this.doc = doc;\n        return this;\n    }\n    mustRefreshForWrapping(whiteSpace) {\n        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n    }\n    mustRefreshForHeights(lineHeights) {\n        let newHeight = false;\n        for(let i = 0; i < lineHeights.length; i++){\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            } else if (!this.heightSamples[Math.floor(h * 10)]) {\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.abs(lineHeight - this.lineHeight) > 0.3 || this.lineWrapping != lineWrapping || Math.abs(charWidth - this.charWidth) > 0.1;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.textHeight = textHeight;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for(let i = 0; i < knownHeights.length; i++){\n                let h = knownHeights[i];\n                if (h < 0) i++;\n                else this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nodes. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights){\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() {\n        return this.index < this.heights.length;\n    }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/ class BlockInfo {\n    /**\n    @internal\n    */ constructor(/**\n    The start of the element in the document.\n    */ from, /**\n    The length of the element.\n    */ length, /**\n    The top position of the element (relative to the top of the\n    document).\n    */ top, /**\n    Its height.\n    */ height, /**\n    @internal Weird packed field that holds an array of children\n    for composite blocks, a decoration for block widgets, and a\n    number indicating the amount of widget-created line breaks for\n    text blocks.\n    */ _content){\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this._content = _content;\n    }\n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */ get type() {\n        return typeof this._content == \"number\" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;\n    }\n    /**\n    The end of the element as a document position.\n    */ get to() {\n        return this.from + this.length;\n    }\n    /**\n    The bottom position of the element.\n    */ get bottom() {\n        return this.top + this.height;\n    }\n    /**\n    If this is a widget block, this will return the widget\n    associated with it.\n    */ get widget() {\n        return this._content instanceof PointDecoration ? this._content.widget : null;\n    }\n    /**\n    If this is a textblock, this holds the number of line breaks\n    that appear in widgets inside the block.\n    */ get widgetLineBreaks() {\n        return typeof this._content == \"number\" ? this._content : 0;\n    }\n    /**\n    @internal\n    */ join(other) {\n        let content = (Array.isArray(this._content) ? this._content : [\n            this\n        ]).concat(Array.isArray(other._content) ? other._content : [\n            other\n        ]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n    }\n}\nvar QueryType = /*@__PURE__*/ function(QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n    return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n    constructor(length, height, flags = 2 /* Flag.Outdated */ ){\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() {\n        return (this.flags & 2 /* Flag.Outdated */ ) > 0;\n    }\n    set outdated(value) {\n        this.flags = (value ? 2 /* Flag.Outdated */  : 0) | this.flags & ~2 /* Flag.Outdated */ ;\n    }\n    setHeight(height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon) heightChangeFlag = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) {\n        result.push(this);\n    }\n    decomposeRight(_from, result) {\n        result.push(this);\n    }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this, doc = oracle.doc;\n        for(let i = changes.length - 1; i >= 0; i--){\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while(i > 0 && start.from <= changes[i - 1].toA){\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n            me = replace(me, me.replace(fromA, toA, nodes));\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() {\n        return new HeightMapText(0, 0, 0);\n    }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1) return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for(;;){\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break) nodes.splice(--i, 1, split.left, null, split.right);\n                    else nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                } else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break) nodes.splice(j, 1, split.left, null, split.right);\n                    else nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                } else {\n                    break;\n                }\n            } else if (before < after) {\n                let next = nodes[i++];\n                if (next) before += next.size;\n            } else {\n                let next = nodes[--j];\n                if (next) after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        } else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nfunction replace(old, val) {\n    if (old == val) return old;\n    if (old.constructor != val.constructor) heightChangeFlag = true;\n    return val;\n}\nHeightMap.prototype.size = 1;\nconst SpaceDeco = /*@__PURE__*/ Decoration.replace({});\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, deco){\n        super(length, height);\n        this.deco = deco;\n        this.spaceAbove = 0;\n    }\n    mainBlock(top, offset) {\n        return new BlockInfo(offset, this.length, top + this.spaceAbove, this.height - this.spaceAbove, this.deco || 0);\n    }\n    blockAt(height, _oracle, top, offset) {\n        return this.spaceAbove && height < top + this.spaceAbove ? new BlockInfo(offset, 0, top, this.spaceAbove, SpaceDeco) : this.mainBlock(top, offset);\n    }\n    lineAt(_value, _type, oracle, top, offset) {\n        let main = this.mainBlock(top, offset);\n        return this.spaceAbove ? this.blockAt(0, oracle, top, offset).join(main) : main;\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        if (from <= offset + this.length && to >= offset) f(this.lineAt(0, QueryType.ByPos, oracle, top, offset));\n    }\n    setMeasuredHeight(measured) {\n        let next = measured.heights[measured.index++];\n        if (next < 0) {\n            this.spaceAbove = -next;\n            next = measured.heights[measured.index++];\n        } else {\n            this.spaceAbove = 0;\n        }\n        this.setHeight(next);\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setMeasuredHeight(measured);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `block(${this.length})`;\n    }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height, above){\n        super(length, height, null);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n        this.breaks = 0; // Number of widget-introduced line breaks on the line\n        this.spaceAbove = above;\n    }\n    mainBlock(top, offset) {\n        return new BlockInfo(offset, this.length, top + this.spaceAbove, this.height - this.spaceAbove, this.breaks);\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */ ) && Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height, this.spaceAbove);\n            else node.height = this.height;\n            if (!this.outdated) node.outdated = false;\n            return node;\n        } else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) {\n            this.setMeasuredHeight(measured);\n        } else if (force || this.outdated) {\n            this.spaceAbove = 0;\n            this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);\n        }\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length){\n        super(length, 0);\n    }\n    heightMetrics(oracle, offset) {\n        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;\n        let lines = lastLine - firstLine + 1;\n        let perLine, perChar = 0;\n        if (oracle.lineWrapping) {\n            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n            perLine = totalPerLine / lines;\n            if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n        } else {\n            perLine = this.height / lines;\n        }\n        return {\n            firstLine,\n            lastLine,\n            perLine,\n            perChar\n        };\n    }\n    blockAt(height, oracle, top, offset) {\n        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        if (oracle.lineWrapping) {\n            let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));\n            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;\n            let lineTop = Math.max(top, height - lineHeight / 2);\n            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n        } else {\n            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n            let { from, length } = oracle.doc.line(firstLine + line);\n            return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n        }\n    }\n    lineAt(value, type, oracle, top, offset) {\n        if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = oracle.doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, 0);\n        }\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;\n        let linesAbove = line.number - firstLine;\n        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        from = Math.max(from, offset);\n        to = Math.min(to, offset + this.length);\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        for(let pos = from, lineTop = top; pos <= to;){\n            let line = oracle.doc.lineAt(pos);\n            if (pos == from) {\n                let linesAbove = line.number - firstLine;\n                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n            }\n            let lineHeight = perLine + perChar * line.length;\n            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n            lineTop += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);\n            else nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\n            if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while(pos <= end && measured.more){\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length) nodes.push(null);\n                let height = measured.heights[measured.index++], above = 0;\n                if (height < 0) {\n                    above = -height;\n                    height = measured.heights[measured.index++];\n                }\n                if (singleHeight == -1) singleHeight = height;\n                else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n                let line = new HeightMapText(len, height, above);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            let result = HeightMap.of(nodes);\n            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) heightChangeFlag = true;\n            return replace(this, result);\n        } else if (force || this.outdated) {\n            this.setHeight(oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() {\n        return `gap(${this.length})`;\n    }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right){\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */  : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() {\n        return this.flags & 1 /* Flag.Break */ ;\n    }\n    blockAt(height, oracle, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, oracle, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));\n        else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);\n            if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n        } else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n            if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n            if (mid.to >= from && mid.from <= to) f(mid);\n            if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0) this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)result.push(node);\n        if (from > 0) mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left) return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left) result.push(null);\n        }\n        if (to > left) this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right) return this.right.decomposeRight(from - right, result);\n        if (from < left) this.left.decomposeRight(from, result);\n        if (this.break && from < right) result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [\n            left,\n            null,\n            right\n        ] : [\n            left,\n            right\n        ]);\n        this.left = replace(this.left, left);\n        this.right = replace(this.right, right);\n        this.setHeight(left.height + right.height);\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else right.updateHeight(oracle, rightStart, force);\n        if (rebalance) return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return this.left + (this.break ? \" \" : \"-\") + this.right;\n    }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle){\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText) last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1, 0));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\n            let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n            if (height < 0) height = this.oracle.lineHeight;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco));\n            } else if (len || breaks || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, breaks, len);\n            }\n        } else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1) return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1, 0));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */ ;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText) return last;\n        let line = new HeightMapText(0, -1, 0);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        let deco = block.deco;\n        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (deco && deco.endSide > 0) this.covering = block;\n    }\n    addLineDeco(height, breaks, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        line.breaks += breaks;\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1, 0));\n        else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes){\n            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange() {}\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n    }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\n    for(let parent = dom.parentNode; parent && parent != doc.body;){\n        if (parent.nodeType == 1) {\n            let elt = parent;\n            let style = window.getComputedStyle(elt);\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n                let parentRect = elt.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n        } else if (parent.nodeType == 11) {\n            parent = parent.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        left: left - rect.left,\n        right: Math.max(left, right) - rect.left,\n        top: top - (rect.top + paddingTop),\n        bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n    };\n}\nfunction inWindow(elt) {\n    let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;\n    return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;\n}\nfunction fullPixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    return {\n        left: 0,\n        right: rect.right - rect.left,\n        top: paddingTop,\n        bottom: rect.bottom - (rect.top + paddingTop)\n    };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size, displaySize){\n        this.from = from;\n        this.to = to;\n        this.size = size;\n        this.displaySize = displaySize;\n    }\n    static same(a, b) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++){\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n        }\n        return true;\n    }\n    draw(viewState, wrapping) {\n        return Decoration.replace({\n            widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n        }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical){\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) {\n        return other.size == this.size && other.vertical == this.vertical;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        } else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() {\n        return this.vertical ? this.size : -1;\n    }\n}\nclass ViewState {\n    constructor(state){\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = {\n            left: 0,\n            right: window.innerWidth,\n            top: 0,\n            bottom: 0\n        };\n        this.inView = true;\n        this.paddingTop = 0; // Padding above the document, scaled\n        this.paddingBottom = 0; // Padding below the document, scaled\n        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n        this.scrolledToBottom = false;\n        // The CSS-transformation scale of the editor (transformed size /\n        // concrete size)\n        this.scaleX = 1;\n        this.scaleY = 1;\n        // The vertical position (document-relative) to which to anchor the\n        // scroll position. -1 means anchor to the end of the document.\n        this.scrollAnchorPos = 0;\n        // The height at the anchor position. Set by the DOM update phase.\n        // -1 means no height available.\n        this.scrollAnchorHeight = -1;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTarget = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        // Flag set when editor content was redrawn, so that the next\n        // measure stage knows it must read DOM layout\n        this.mustMeasureContent = true;\n        this.defaultTextDirection = Direction.LTR;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        let guessWrapping = state.facet(contentAttributes).some((v)=>typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n        this.heightOracle = new HeightOracle(guessWrapping);\n        this.stateDeco = staticDeco(state);\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle.setDoc(state.doc), [\n            new ChangedRange(0, 0, 0, state.doc.length)\n        ]);\n        for(let i = 0; i < 2; i++){\n            this.viewport = this.getViewport(0, null);\n            if (!this.updateForViewport()) break;\n        }\n        this.updateViewportLines();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap)=>gap.draw(this, false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [\n            this.viewport\n        ], { main } = this.state.selection;\n        for(let i = 0; i <= 1; i++){\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to })=>pos >= from && pos <= to)) {\n                let { from, to } = this.lineBlockAt(pos);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b)=>a.from - b.from);\n        return this.updateScaler();\n    }\n    updateScaler() {\n        let scaler = this.scaler;\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */  ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n        return scaler.eq(this.scaler) ? 0 : 2 /* UpdateFlag.Height */ ;\n    }\n    updateViewportLines() {\n        this.viewportLines = [];\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block)=>{\n            this.viewportLines.push(scaleBlock(block, this.scaler));\n        });\n    }\n    update(update, scrollTarget = null) {\n        this.state = update.state;\n        let prevDeco = this.stateDeco;\n        this.stateDeco = staticDeco(this.state);\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n        clearHeightChangeFlag();\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight || heightChangeFlag) update.flags |= 2 /* UpdateFlag.Height */ ;\n        if (scrollAnchor) {\n            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n            this.scrollAnchorHeight = scrollAnchor.top;\n        } else {\n            this.scrollAnchorPos = -1;\n            this.scrollAnchorHeight = prevHeight;\n        }\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n        this.viewport = viewport;\n        update.flags |= this.updateForViewport();\n        if (viewportChange || !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */ ) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges(update.changes);\n        if (scrollTarget) this.scrollTarget = scrollTarget;\n        if (!this.mustEnforceCursorAssoc && (update.selectionSet || update.focusChanged) && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n    }\n    measure(view) {\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\n        let oracle = this.heightOracle;\n        let whiteSpace = style.whiteSpace;\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace) || this.mustMeasureContent;\n        let domRect = dom.getBoundingClientRect();\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n        this.contentDOMHeight = domRect.height;\n        this.mustMeasureContent = false;\n        let result = 0, bias = 0;\n        if (domRect.width && domRect.height) {\n            let { scaleX, scaleY } = getScale(dom, domRect);\n            if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 || scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {\n                this.scaleX = scaleX;\n                this.scaleY = scaleY;\n                result |= 16 /* UpdateFlag.Geometry */ ;\n                refresh = measureContent = true;\n            }\n        }\n        // Vertical padding\n        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n            this.paddingTop = paddingTop;\n            this.paddingBottom = paddingBottom;\n            result |= 16 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ ;\n        }\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\n            if (oracle.lineWrapping) measureContent = true;\n            this.editorWidth = view.scrollDOM.clientWidth;\n            result |= 16 /* UpdateFlag.Geometry */ ;\n        }\n        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n        if (this.scrollTop != scrollTop) {\n            this.scrollAnchorHeight = -1;\n            this.scrollTop = scrollTop;\n        }\n        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n        // Pixel viewport\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (inView != this.inView) {\n            this.inView = inView;\n            if (inView) measureContent = true;\n        }\n        if (!this.inView && !this.scrollTarget && !inWindow(view.dom)) return 0;\n        let contentWidth = domRect.width;\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n            this.contentDOMWidth = domRect.width;\n            this.editorHeight = view.scrollDOM.clientHeight;\n            result |= 16 /* UpdateFlag.Geometry */ ;\n        }\n        if (measureContent) {\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n            if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);\n                if (refresh) {\n                    view.docView.minWidth = 0;\n                    result |= 16 /* UpdateFlag.Geometry */ ;\n                }\n            }\n            if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n            clearHeightChangeFlag();\n            for (let vp of this.viewports){\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle, [\n                    new ChangedRange(0, 0, 0, view.state.doc.length)\n                ]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n            }\n            if (heightChangeFlag) result |= 2 /* UpdateFlag.Height */ ;\n        }\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n        if (viewportChange) {\n            if (result & 2 /* UpdateFlag.Height */ ) result |= this.updateScaler();\n            this.viewport = this.getViewport(bias, this.scrollTarget);\n            result |= this.updateForViewport();\n        }\n        if (result & 2 /* UpdateFlag.Height */  || viewportChange) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            view.docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() {\n        return this.scaler.fromDOM(this.pixelViewport.top);\n    }\n    get visibleBottom() {\n        return this.scaler.fromDOM(this.pixelViewport.bottom);\n    }\n    getViewport(bias, scrollTarget) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */  / 2));\n        let map = this.heightMap, oracle = this.heightOracle;\n        let { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).to);\n        // If scrollTarget is given, make sure the viewport includes that position\n        if (scrollTarget) {\n            let { head } = scrollTarget.range;\n            if (head < viewport.from || head > viewport.to) {\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;\n                if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;\n                else topPos = block.bottom - viewHeight;\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        if (!this.inView) return true;\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */ , Math.min(-bias, 250 /* VP.MaxCoverMargin */ ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */ , Math.min(bias, 250 /* VP.MaxCoverMargin */ ))) && top > visibleTop - 2 * 1000 /* VP.Margin */  && bottom < visibleBottom + 2 * 1000 /* VP.Margin */ ;\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty) return gaps;\n        let mapped = [];\n        for (let gap of gaps)if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current, mayMeasure) {\n        let wrapping = this.heightOracle.lineWrapping;\n        let margin = wrapping ? 10000 /* LG.MarginWrap */  : 2000 /* LG.Margin */ , halfMargin = margin >> 1, doubleMargin = margin << 1;\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\n        if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n        let gaps = [];\n        let addGap = (from, to, line, structure)=>{\n            if (to - from < halfMargin) return;\n            let sel = this.state.selection.main, avoid = [\n                sel.from\n            ];\n            if (!sel.empty) avoid.push(sel.to);\n            for (let pos of avoid){\n                if (pos > from && pos < to) {\n                    addGap(from, pos - 10 /* LG.SelectionMargin */ , line, structure);\n                    addGap(pos + 10 /* LG.SelectionMargin */ , to, line, structure);\n                    return;\n                }\n            }\n            let gap = find(current, (gap)=>gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some((pos)=>gap.from < pos && gap.to > pos));\n            if (!gap) {\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n                if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r)=>r.from <= to && r.to >= to)) {\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(to), false, true).head;\n                    if (lineStart > from) to = lineStart;\n                }\n                let size = this.gapSize(line, from, to, structure);\n                let displaySize = wrapping || size < 2000000 /* VP.MaxHorizGap */  ? size : 2000000 /* VP.MaxHorizGap */ ;\n                gap = new LineGap(from, to, size, displaySize);\n            }\n            gaps.push(gap);\n        };\n        let checkLine = (line)=>{\n            if (line.length < doubleMargin || line.type != BlockType.Text) return;\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\n            if (structure.total < doubleMargin) return;\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n            let viewFrom, viewTo;\n            if (wrapping) {\n                let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n                let top, bot;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n                    top = targetFrac - spaceFrac;\n                    bot = targetFrac + spaceFrac;\n                } else {\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n                }\n                viewFrom = findPosition(structure, top);\n                viewTo = findPosition(structure, bot);\n            } else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                let marginWidth = margin * this.heightOracle.charWidth;\n                let horizOffset = 0;\n                if (totalWidth > 2000000 /* VP.MaxHorizGap */ ) for (let old of current){\n                    if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left) horizOffset = old.size - old.displaySize;\n                }\n                let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;\n                let left, right;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;\n                    left = targetFrac - spaceFrac;\n                    right = targetFrac + spaceFrac;\n                } else {\n                    left = (pxLeft - marginWidth) / totalWidth;\n                    right = (pxRight + marginWidth) / totalWidth;\n                }\n                viewFrom = findPosition(structure, left);\n                viewTo = findPosition(structure, right);\n            }\n            if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n            if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n        };\n        for (let line of this.viewportLines){\n            if (Array.isArray(line.type)) line.type.forEach(checkLine);\n            else checkLine(line);\n        }\n        return gaps;\n    }\n    gapSize(line, from, to, structure) {\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\n        if (this.heightOracle.lineWrapping) {\n            return line.height * fraction;\n        } else {\n            return structure.total * this.heightOracle.charWidth * fraction;\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map((gap)=>gap.draw(this, this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges(changes) {\n        let deco = this.stateDeco;\n        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span (from, to) {\n                ranges.push({\n                    from,\n                    to\n                });\n            },\n            point () {}\n        }, 20);\n        let changed = 0;\n        if (ranges.length != this.visibleRanges.length) {\n            changed = 8 /* UpdateFlag.ViewportMoved */  | 4 /* UpdateFlag.Viewport */ ;\n        } else {\n            for(let i = 0; i < ranges.length && !(changed & 8 /* UpdateFlag.ViewportMoved */ ); i++){\n                let old = this.visibleRanges[i], nw = ranges[i];\n                if (old.from != nw.from || old.to != nw.to) {\n                    changed |= 4 /* UpdateFlag.Viewport */ ;\n                    if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to)) changed |= 8 /* UpdateFlag.ViewportMoved */ ;\n                }\n            }\n        }\n        this.visibleRanges = ranges;\n        return changed;\n    }\n    lineBlockAt(pos) {\n        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b)=>b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n    }\n    lineBlockAtHeight(height) {\n        return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l)=>l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n    }\n    scrollAnchorAt(scrollTop) {\n        let block = this.lineBlockAtHeight(scrollTop + 8);\n        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n    }\n    elementAtHeight(height) {\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n    }\n    get docHeight() {\n        return this.scaler.toDOM(this.heightMap.height);\n    }\n    get contentHeight() {\n        return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n}\nclass Viewport {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, stateDeco) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.spans(stateDeco, from, to, {\n        span () {},\n        point (from, to) {\n            if (from > pos) {\n                ranges.push({\n                    from: pos,\n                    to: from\n                });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({\n            from: pos,\n            to\n        });\n        total += to - pos;\n    }\n    return {\n        total,\n        ranges\n    };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0) return ranges[0].from;\n    if (ratio >= 1) return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for(let i = 0;; i++){\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size) return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges){\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)if (f(val)) return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM (n) {\n        return n;\n    },\n    fromDOM (n) {\n        return n;\n    },\n    scale: 1,\n    eq (other) {\n        return other == this;\n    }\n};\nfunction staticDeco(state) {\n    let deco = state.facet(decorations).filter((d)=>typeof d != \"function\");\n    let outer = state.facet(outerDecorations).filter((d)=>typeof d != \"function\");\n    if (outer.length) deco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.join(outer));\n    return deco;\n}\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(oracle, heightMap, viewports){\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to })=>{\n            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return {\n                from,\n                to,\n                top,\n                bottom,\n                domTop: 0,\n                domBottom: 0\n            };\n        });\n        this.scale = (7000000 /* VP.MaxDOMHeight */  - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports){\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n            if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n            if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    eq(other) {\n        if (!(other instanceof BigScaler)) return false;\n        return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i)=>vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);\n    }\n}\nfunction scaleBlock(block, scaler) {\n    if (scaler.scale == 1) return block;\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b)=>scaleBlock(b, scaler)) : block._content);\n}\nconst theme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (strs)=>strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n    \"&light\": \".\" + baseLightID,\n    \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish (sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, (m)=>{\n                if (m == \"&\") return main;\n                if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme$1 = /*@__PURE__*/ buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0,\n        overflowAnchor: \"none\"\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        flexShrink: 0,\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        \"&[contenteditable=true]\": {\n            WebkitUserModify: \"read-write-plaintext-only\"\n        }\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace_fallback: \"pre-wrap\",\n        whiteSpace: \"break-spaces\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\",\n        flexShrink: 1\n    },\n    \"&light .cm-content\": {\n        caretColor: \"black\"\n    },\n    \"&dark .cm-content\": {\n        caretColor: \"white\"\n    },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 6px\"\n    },\n    \".cm-layer\": {\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        contain: \"size style\",\n        \"& > *\": {\n            position: \"absolute\"\n        }\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \"@keyframes cm-blink2\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\"\n    },\n    \".cm-cursor\": {\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#ddd\"\n    },\n    \".cm-dropCursor\": {\n        position: \"absolute\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n        display: \"block\"\n    },\n    \".cm-iso\": {\n        unicodeBidi: \"isolate\"\n    },\n    \".cm-announced\": {\n        position: \"fixed\",\n        top: \"-10000px\"\n    },\n    \"@media print\": {\n        \".cm-announced\": {\n            display: \"none\"\n        }\n    },\n    \"&light .cm-activeLine\": {\n        backgroundColor: \"#cceeff44\"\n    },\n    \"&dark .cm-activeLine\": {\n        backgroundColor: \"#99eeff33\"\n    },\n    \"&light .cm-specialChar\": {\n        color: \"red\"\n    },\n    \"&dark .cm-specialChar\": {\n        color: \"#f78\"\n    },\n    \".cm-gutters\": {\n        flexShrink: 0,\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        zIndex: 200\n    },\n    \".cm-gutters-before\": {\n        insetInlineStart: 0\n    },\n    \".cm-gutters-after\": {\n        insetInlineEnd: 0\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#6c6c6c\",\n        border: \"0px solid #ddd\",\n        \"&.cm-gutters-before\": {\n            borderRightWidth: \"1px\"\n        },\n        \"&.cm-gutters-after\": {\n            borderLeftWidth: \"1px\"\n        }\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    },\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0,\n        zIndex: 300\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-dialog\": {\n        padding: \"2px 19px 4px 6px\",\n        position: \"relative\",\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    },\n    \".cm-dialog-close\": {\n        position: \"absolute\",\n        top: \"3px\",\n        right: \"4px\",\n        backgroundColor: \"inherit\",\n        border: \"none\",\n        font: \"inherit\",\n        fontSize: \"14px\",\n        padding: \"0\"\n    },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-widgetBuffer\": {\n        verticalAlign: \"text-top\",\n        height: \"1em\",\n        width: 0,\n        display: \"inline\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\",\n        verticalAlign: \"top\",\n        userSelect: \"none\"\n    },\n    \".cm-highlightSpace\": {\n        backgroundImage: \"radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)\",\n        backgroundPosition: \"center\"\n    },\n    \".cm-highlightTab\": {\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n        backgroundSize: \"auto 100%\",\n        backgroundPosition: \"right 90%\",\n        backgroundRepeat: \"no-repeat\"\n    },\n    \".cm-trailingSpace\": {\n        backgroundColor: \"#ff332255\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"1px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view){\n        this.view = view;\n        this.active = false;\n        this.editContext = null;\n        // The known selection. Kept in our own object, as opposed to just\n        // directly accessing the selection because:\n        //  - Safari doesn't report the right selection in shadow DOM\n        //  - Reading from the selection forces a DOM layout\n        //  - This way, we can ignore selectionchange events if we have\n        //    already seen the 'new' selection\n        this.selectionRange = new DOMSelectionState;\n        // Set when a selection change is detected, cleared on flush\n        this.selectionChanged = false;\n        this.delayedFlush = -1;\n        this.resizeTimeout = -1;\n        this.queue = [];\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n        this.lastChange = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.resizeScroll = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        this.printQuery = null;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver((mutations)=>{\n            for (let mut of mutations)this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)\n        !(browser.chrome && browser.chrome_version < 126)) {\n            this.editContext = new EditContextManager(view);\n            if (view.state.facet(editable)) view.contentDOM.editContext = this.editContext.editContext;\n        }\n        if (useCharData) this.onCharData = (event)=>{\n            this.queue.push({\n                target: event.target,\n                type: \"characterData\",\n                oldValue: event.prevValue\n            });\n            this.flushSoon();\n        };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onPrint = this.onPrint.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n        if (window.matchMedia) this.printQuery = window.matchMedia(\"print\");\n        if (typeof ResizeObserver == \"function\") {\n            this.resizeScroll = new ResizeObserver(()=>{\n                var _a;\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n            });\n            this.resizeScroll.observe(view.scrollDOM);\n        }\n        this.addWindowListeners(this.win = view.win);\n        this.start();\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver((entries)=>{\n                if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {\n                threshold: [\n                    0,\n                    .001\n                ]\n            });\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver((entries)=>{\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n        this.readSelectionRange();\n    }\n    onScrollChanged(e) {\n        this.view.inputState.runHandlers(\"scroll\", e);\n        if (this.intersecting) this.view.measure();\n    }\n    onScroll(e) {\n        if (this.intersecting) this.flush(false);\n        if (this.editContext) this.view.requestMeasure(this.editContext.measureReq);\n        this.onScrollChanged(e);\n    }\n    onResize() {\n        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(()=>{\n            this.resizeTimeout = -1;\n            this.view.requestMeasure();\n        }, 50);\n    }\n    onPrint(event) {\n        if ((event.type == \"change\" || !event.type) && !event.matches) return;\n        this.view.viewState.printing = true;\n        this.view.measure();\n        setTimeout(()=>{\n            this.view.viewState.printing = false;\n            this.view.requestMeasure();\n        }, 500);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i)=>g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        let wasChanged = this.selectionChanged;\n        if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel)) return;\n        let context = sel.anchorNode && view.docView.tile.nearest(sel.anchorNode);\n        if (context && context.isWidget() && context.widget.ignoreEvent(event)) {\n            if (!wasChanged) this.selectionChanged = false;\n            return;\n        }\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // Chrome Android has a similar issue when backspacing out a\n        // selection (#645).\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();\n        else this.flush(false);\n    }\n    readSelectionRange() {\n        let { view } = this;\n        // The Selection object is broken in shadow roots in Safari. See\n        // https://github.com/codemirror/dev/issues/414\n        let selection = getSelection(view.root);\n        if (!selection) return false;\n        let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;\n        if (!range || this.selectionRange.eq(range)) return false;\n        let local = hasSelection(this.dom, range);\n        // Detect the situation where the browser has, on focus, moved the\n        // selection to the start of the content element. Reset it to the\n        // position from the editor state.\n        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n            this.view.inputState.lastFocusTime = 0;\n            view.docView.updateSelection();\n            return false;\n        }\n        this.selectionRange.setRange(range);\n        if (local) this.selectionChanged = true;\n        return true;\n    }\n    setSelectionRange(anchor, head) {\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n        this.selectionChanged = false;\n    }\n    clearSelectionRange() {\n        this.selectionRange.set(null, 0, null, 0);\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for(let dom = this.dom; dom;){\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;\n                else if (!changed) changed = this.scrollTargets.slice(0, i);\n                if (changed) changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            } else if (dom.nodeType == 11) {\n                dom = dom.host;\n            } else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active) return f();\n        try {\n            this.stop();\n            return f();\n        } finally{\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active) return;\n        this.observer.observe(this.dom, observeOptions);\n        if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active) return;\n        this.active = false;\n        this.observer.disconnect();\n        if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.processRecords();\n        this.queue.length = 0;\n        this.selectionChanged = false;\n    }\n    // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then tries to flush\n    // them or, if that has no effect, dispatches the given key.\n    delayAndroidKey(key, keyCode) {\n        var _a;\n        if (!this.delayedAndroidKey) {\n            let flush = ()=>{\n                let key = this.delayedAndroidKey;\n                if (key) {\n                    this.clearDelayedAndroidKey();\n                    this.view.inputState.lastKeyCode = key.keyCode;\n                    this.view.inputState.lastKeyTime = Date.now();\n                    let flushed = this.flush();\n                    if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n                }\n            };\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n        }\n        // Since backspace beforeinput is sometimes signalled spuriously,\n        // Enter always takes precedence.\n        if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n            key,\n            keyCode,\n            // Only run the key handler when no changes are detected if\n            // this isn't coming right after another change, in which case\n            // it is probably part of a weird chain of updates, and should\n            // be ignored if it returns the DOM to its previous state.\n            force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n        };\n    }\n    clearDelayedAndroidKey() {\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(()=>{\n            this.delayedFlush = -1;\n            this.flush();\n        });\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\n            this.delayedFlush = -1;\n        }\n        this.flush();\n    }\n    pendingRecords() {\n        for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    processRecords() {\n        let records = this.pendingRecords();\n        if (records.length) this.queue = [];\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records){\n            let range = this.readMutation(record);\n            if (!range) continue;\n            if (range.typeOver) typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            } else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        return {\n            from,\n            to,\n            typeOver\n        };\n    }\n    readChange() {\n        let { from, to, typeOver } = this.processRecords();\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n        if (from < 0 && !newSel) return null;\n        if (from > -1) this.lastChange = Date.now();\n        this.view.inputState.lastFocusTime = 0;\n        this.selectionChanged = false;\n        let change = new DOMChange(this.view, from, to, typeOver);\n        this.view.docView.domChanged = {\n            newSel: change.newSel ? change.newSel.main : null\n        };\n        return change;\n    }\n    // Apply pending changes, if any\n    flush(readSelection = true) {\n        // Completely hold off flushing when pending keys are setâ€”the code\n        // managing those will make sure processRecords is called and the\n        // view is resynchronized after\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n        if (readSelection) this.readSelectionRange();\n        let domChange = this.readChange();\n        if (!domChange) {\n            this.view.requestMeasure();\n            return false;\n        }\n        let startState = this.view.state;\n        let handled = applyDOMChange(this.view, domChange);\n        // The view wasn't updated but DOM/selection changes were seen. Reset the view.\n        if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !sameSelPos(this.view.state.selection, domChange.newSel.main))) this.view.update([]);\n        return handled;\n    }\n    readMutation(rec) {\n        let tile = this.view.docView.tile.nearest(rec.target);\n        if (!tile || tile.isWidget()) return null;\n        tile.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(tile, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(tile, rec.nextSibling || rec.target.nextSibling, 1);\n            return {\n                from: childBefore ? tile.posAfter(childBefore) : tile.posAtStart,\n                to: childAfter ? tile.posBefore(childAfter) : tile.posAtEnd,\n                typeOver: false\n            };\n        } else if (rec.type == \"characterData\") {\n            return {\n                from: tile.posAtStart,\n                to: tile.posAtEnd,\n                typeOver: rec.target.nodeValue == rec.oldValue\n            };\n        } else {\n            return null;\n        }\n    }\n    setWindow(win) {\n        if (win != this.win) {\n            this.removeWindowListeners(this.win);\n            this.win = win;\n            this.addWindowListeners(this.win);\n        }\n    }\n    addWindowListeners(win) {\n        win.addEventListener(\"resize\", this.onResize);\n        if (this.printQuery) {\n            if (this.printQuery.addEventListener) this.printQuery.addEventListener(\"change\", this.onPrint);\n            else this.printQuery.addListener(this.onPrint);\n        } else win.addEventListener(\"beforeprint\", this.onPrint);\n        win.addEventListener(\"scroll\", this.onScroll);\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    removeWindowListeners(win) {\n        win.removeEventListener(\"scroll\", this.onScroll);\n        win.removeEventListener(\"resize\", this.onResize);\n        if (this.printQuery) {\n            if (this.printQuery.removeEventListener) this.printQuery.removeEventListener(\"change\", this.onPrint);\n            else this.printQuery.removeListener(this.onPrint);\n        } else win.removeEventListener(\"beforeprint\", this.onPrint);\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    update(update) {\n        if (this.editContext) {\n            this.editContext.update(update);\n            if (update.startState.facet(editable) != update.state.facet(editable)) update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;\n        }\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.stop();\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n        for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n        this.removeWindowListeners(this.win);\n        clearTimeout(this.parentCheck);\n        clearTimeout(this.resizeTimeout);\n        this.win.cancelAnimationFrame(this.delayedFlush);\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        if (this.editContext) {\n            this.view.contentDOM.editContext = null;\n            this.editContext.destroy();\n        }\n    }\n}\nfunction findChild(tile, dom, dir) {\n    while(dom){\n        let curTile = Tile.get(dom);\n        if (curTile && curTile.parent == tile) return curTile;\n        let parent = dom.parentNode;\n        dom = parent != tile.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\nfunction buildSelectionRangeFromRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor, 1);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range) return buildSelectionRangeFromRange(view, range);\n    }\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at itâ€”using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    view.dom.ownerDocument.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    return found ? buildSelectionRangeFromRange(view, found) : null;\n}\nclass EditContextManager {\n    constructor(view){\n        // The document window for which the text in the context is\n        // maintained. For large documents, this may be smaller than the\n        // editor document. This window always includes the selection head.\n        this.from = 0;\n        this.to = 0;\n        // When applying a transaction, this is used to compare the change\n        // made to the context content to the change in the transaction in\n        // order to make the minimal changes to the context (since touching\n        // that sometimes breaks series of multiple edits made for a single\n        // user action on some Android keyboards)\n        this.pendingContextChange = null;\n        this.handlers = Object.create(null);\n        // Kludge to work around the fact that EditContext does not respond\n        // well to having its content updated during a composition (see #1472)\n        this.composing = null;\n        this.resetRange(view.state);\n        let context = this.editContext = new window.EditContext({\n            text: view.state.doc.sliceString(this.from, this.to),\n            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),\n            selectionEnd: this.toContextPos(view.state.selection.main.head)\n        });\n        this.handlers.textupdate = (e)=>{\n            let main = view.state.selection.main, { anchor, head } = main;\n            let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);\n            if (view.inputState.composing >= 0 && !this.composing) this.composing = {\n                contextBase: e.updateRangeStart,\n                editorBase: from,\n                drifted: false\n            };\n            let deletes = to - from > e.text.length;\n            // If the window doesn't include the anchor, assume changes\n            // adjacent to a side go up to the anchor.\n            if (from == this.from && anchor < this.from) from = anchor;\n            else if (to == this.to && anchor > this.to) to = anchor;\n            let diff = findDiff(view.state.sliceDoc(from, to), e.text, (deletes ? main.from : main.to) - from, deletes ? \"end\" : null);\n            // Edit contexts sometimes fire empty changes\n            if (!diff) {\n                let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));\n                if (!sameSelPos(newSel, main)) view.dispatch({\n                    selection: newSel,\n                    userEvent: \"select\"\n                });\n                return;\n            }\n            let change = {\n                from: diff.from + from,\n                to: diff.toA + from,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of(e.text.slice(diff.from, diff.toB).split(\"\\n\"))\n            };\n            if ((browser.mac || browser.android) && change.from == head - 1 && /^\\. ?$/.test(e.text) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") change = {\n                from,\n                to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Text.of([\n                    e.text.replace(\".\", \" \")\n                ])\n            };\n            this.pendingContextChange = change;\n            if (!view.state.readOnly) {\n                let newLen = this.to - this.from + (change.to - change.from + change.insert.length);\n                applyDOMChangeInner(view, change, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));\n            }\n            // If the transaction didn't flush our change, revert it so\n            // that the context is in sync with the editor state again.\n            if (this.pendingContextChange) {\n                this.revertPending(view.state);\n                this.setSelection(view.state);\n            }\n            // Work around missed compositionend events. See https://discuss.codemirror.net/t/a/9514\n            if (change.from < change.to && !change.insert.length && view.inputState.composing >= 0 && !/[\\\\p{Alphabetic}\\\\p{Number}_]/.test(context.text.slice(Math.max(0, e.updateRangeStart - 1), Math.min(context.text.length, e.updateRangeStart + 1)))) this.handlers.compositionend(e);\n        };\n        this.handlers.characterboundsupdate = (e)=>{\n            let rects = [], prev = null;\n            for(let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++){\n                let rect = view.coordsForChar(i);\n                prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect;\n                rects.push(prev);\n            }\n            context.updateCharacterBounds(e.rangeStart, rects);\n        };\n        this.handlers.textformatupdate = (e)=>{\n            let deco = [];\n            for (let format of e.getTextFormats()){\n                let lineStyle = format.underlineStyle, thickness = format.underlineThickness;\n                if (!/none/i.test(lineStyle) && !/none/i.test(thickness)) {\n                    let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);\n                    if (from < to) {\n                        // These values changed from capitalized custom strings to lower-case CSS keywords in 2025\n                        let style = `text-decoration: underline ${/^[a-z]/.test(lineStyle) ? lineStyle + \" \" : lineStyle == \"Dashed\" ? \"dashed \" : lineStyle == \"Squiggle\" ? \"wavy \" : \"\"}${/thin/i.test(thickness) ? 1 : 2}px`;\n                        deco.push(Decoration.mark({\n                            attributes: {\n                                style\n                            }\n                        }).range(from, to));\n                    }\n                }\n            }\n            view.dispatch({\n                effects: setEditContextFormatting.of(Decoration.set(deco))\n            });\n        };\n        this.handlers.compositionstart = ()=>{\n            if (view.inputState.composing < 0) {\n                view.inputState.composing = 0;\n                view.inputState.compositionFirstChange = true;\n            }\n        };\n        this.handlers.compositionend = ()=>{\n            view.inputState.composing = -1;\n            view.inputState.compositionFirstChange = null;\n            if (this.composing) {\n                let { drifted } = this.composing;\n                this.composing = null;\n                if (drifted) this.reset(view.state);\n            }\n        };\n        for(let event in this.handlers)context.addEventListener(event, this.handlers[event]);\n        this.measureReq = {\n            read: (view)=>{\n                this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());\n                let sel = getSelection(view.root);\n                if (sel && sel.rangeCount) this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());\n            }\n        };\n    }\n    applyEdits(update) {\n        let off = 0, abort = false, pending = this.pendingContextChange;\n        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert)=>{\n            if (abort) return;\n            let dLen = insert.length - (toA - fromA);\n            if (pending && toA >= pending.to) {\n                if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {\n                    pending = this.pendingContextChange = null; // Match\n                    off += dLen;\n                    this.to += dLen;\n                    return;\n                } else {\n                    pending = null;\n                    this.revertPending(update.state);\n                }\n            }\n            fromA += off;\n            toA += off;\n            if (toA <= this.from) {\n                this.from += dLen;\n                this.to += dLen;\n            } else if (fromA < this.to) {\n                if (fromA < this.from || toA > this.to || this.to - this.from + insert.length > 30000 /* CxVp.MaxSize */ ) {\n                    abort = true;\n                    return;\n                }\n                this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());\n                this.to += dLen;\n            }\n            off += dLen;\n        });\n        if (pending && !abort) this.revertPending(update.state);\n        return !abort;\n    }\n    update(update) {\n        let reverted = this.pendingContextChange, startSel = update.startState.selection.main;\n        if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr)=>!tr.isUserEvent(\"input.type\") && tr.changes.touchesRange(this.from, this.to)))) {\n            this.composing.drifted = true;\n            this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);\n        } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {\n            this.pendingContextChange = null;\n            this.reset(update.state);\n        } else if (update.docChanged || update.selectionSet || reverted) {\n            this.setSelection(update.state);\n        }\n        if (update.geometryChanged || update.docChanged || update.selectionSet) update.view.requestMeasure(this.measureReq);\n    }\n    resetRange(state) {\n        let { head } = state.selection.main;\n        this.from = Math.max(0, head - 10000 /* CxVp.Margin */ );\n        this.to = Math.min(state.doc.length, head + 10000 /* CxVp.Margin */ );\n    }\n    reset(state) {\n        this.resetRange(state);\n        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));\n        this.setSelection(state);\n    }\n    revertPending(state) {\n        let pending = this.pendingContextChange;\n        this.pendingContextChange = null;\n        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));\n    }\n    setSelection(state) {\n        let { main } = state.selection;\n        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));\n        let end = this.toContextPos(main.head);\n        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end) this.editContext.updateSelection(start, end);\n    }\n    rangeIsValid(state) {\n        let { head } = state.selection.main;\n        return !(this.from > 0 && head - this.from < 500 /* CxVp.MinMargin */  || this.to < state.doc.length && this.to - head < 500 /* CxVp.MinMargin */  || this.to - this.from > 10000 /* CxVp.Margin */  * 3);\n    }\n    toEditorPos(contextPos, clipLen = this.to - this.from) {\n        contextPos = Math.min(contextPos, clipLen);\n        let c = this.composing;\n        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;\n    }\n    toContextPos(editorPos) {\n        let c = this.composing;\n        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;\n    }\n    destroy() {\n        for(let event in this.handlers)this.editContext.removeEventListener(event, this.handlers[event]);\n    }\n}\n// The editor's update state machine looks something like this:\n//\n//     Idle â†’ Updating â‡† Idle (unchecked) â†’ Measuring â†’ Idle\n//                                         â†‘      â†“\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/ class EditorView {\n    /**\n    The current editor state.\n    */ get state() {\n        return this.viewState.state;\n    }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */ get viewport() {\n        return this.viewState.viewport;\n    }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */ get visibleRanges() {\n        return this.viewState.visibleRanges;\n    }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */ get inView() {\n        return this.viewState.inView;\n    }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n    one change has been made in the current composition.\n    */ get composing() {\n        return !!this.inputState && this.inputState.composing > 0;\n    }\n    /**\n    Indicates whether the user is currently in composing state. Note\n    that on some platforms, like Android, this will be the case a\n    lot, since just putting the cursor on a word starts a\n    composition there.\n    */ get compositionStarted() {\n        return !!this.inputState && this.inputState.composing >= 0;\n    }\n    /**\n    The document or shadow root that the view lives in.\n    */ get root() {\n        return this._root;\n    }\n    /**\n    @internal\n    */ get win() {\n        return this.dom.ownerDocument.defaultView || window;\n    }\n    /**\n    Construct a new view. You'll want to either provide a `parent`\n    option, or put `view.dom` into your document after creating a\n    view, so that the user can see the editor.\n    */ constructor(config = {}){\n        var _a;\n        this.plugins = [];\n        this.pluginMap = new Map;\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */ this.updateState = 2 /* UpdateState.Updating */ ;\n        /**\n        @internal\n        */ this.measureScheduled = -1;\n        /**\n        @internal\n        */ this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.className = \"cm-announced\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        if (config.parent) config.parent.appendChild(this.dom);\n        let { dispatch } = config;\n        this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs)=>trs.forEach((tr)=>dispatch(tr, this))) || ((trs)=>this.update(trs));\n        this.dispatch = this.dispatch.bind(this);\n        this._root = config.root || getRoot(config.parent) || document;\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.create(config));\n        if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);\n        this.plugins = this.state.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n        for (let plugin of this.plugins)plugin.update(this);\n        this.observer = new DOMObserver(this);\n        this.inputState = new InputState(this);\n        this.inputState.ensureHandlers(this.plugins);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* UpdateState.Idle */ ;\n        this.requestMeasure();\n        if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready) document.fonts.ready.then(()=>{\n            this.viewState.mustMeasureContent = true;\n            this.requestMeasure();\n        });\n    }\n    dispatch(...input) {\n        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [\n            this.state.update(...input)\n        ];\n        this.dispatchTransactions(trs, this);\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */ update(transactions) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, attrsChanged = false, update;\n        let state = this.state;\n        for (let tr of transactions){\n            if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;\n        if (transactions.some((tr)=>tr.annotation(isFocusChange))) {\n            this.inputState.notifiedFocused = focus;\n            // If a focus-change transaction is being dispatched, set this update flag.\n            focusFlag = 1 /* UpdateFlag.Focus */ ;\n        } else if (focus != this.inputState.notifiedFocused) {\n            this.inputState.notifiedFocused = focus;\n            // Schedule a separate focus transaction if necessary, otherwise\n            // add a flag to this update\n            dispatchFocus = focusChangeTransaction(state, focus);\n            if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */ ;\n        }\n        // If there was a pending DOM change, eagerly read it and try to\n        // apply it after the given transactions.\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\n        if (pendingKey) {\n            this.observer.clearDelayedAndroidKey();\n            domChange = this.observer.readChange();\n            // Only try to apply DOM changes if the transactions didn't\n            // change the doc or selection.\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n        } else {\n            this.observer.clear();\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.phrases)) return this.setState(state);\n        update = ViewUpdate.create(this, state, transactions);\n        update.flags |= focusFlag;\n        let scrollTarget = this.viewState.scrollTarget;\n        try {\n            this.updateState = 2 /* UpdateState.Updating */ ;\n            for (let tr of transactions){\n                if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n                }\n                for (let e of tr.effects)if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);\n            }\n            this.viewState.update(update, scrollTarget);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n            attrsChanged = this.updateAttrs();\n            this.showAnnouncements(transactions);\n            this.docView.updateSelection(redrawn, transactions.some((tr)=>tr.isUserEvent(\"select.pointer\")));\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n        if (redrawn) this.docViewUpdate();\n        if (!update.empty) for (let listener of this.state.facet(updateListener)){\n            try {\n                listener(update);\n            } catch (e) {\n                logException(this.state, e, \"update listener\");\n            }\n        }\n        if (dispatchFocus || domChange) Promise.resolve().then(()=>{\n            if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);\n            if (domChange) {\n                if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n            }\n        });\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */ setState(newState) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* UpdateState.Updating */ ;\n        let hadFocus = this.hasFocus;\n        try {\n            for (let plugin of this.plugins)plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n            this.pluginMap.clear();\n            for (let plugin of this.plugins)plugin.update(this);\n            this.docView.destroy();\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this.plugins);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (hadFocus) this.focus();\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs){\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                } else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)if (plugin.mustUpdate != update) plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.pluginMap.clear();\n        } else {\n            for (let p of this.plugins)p.mustUpdate = update;\n        }\n        for(let i = 0; i < this.plugins.length; i++)this.plugins[i].update(this);\n        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);\n    }\n    docViewUpdate() {\n        for (let plugin of this.plugins){\n            let val = plugin.value;\n            if (val && val.docViewUpdate) {\n                try {\n                    val.docViewUpdate(this);\n                } catch (e) {\n                    logException(this.state, e, \"doc view update listener\");\n                }\n            }\n        }\n    }\n    /**\n    @internal\n    */ measure(flush = true) {\n        if (this.destroyed) return;\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        if (this.observer.delayedAndroidKey) {\n            this.measureScheduled = -1;\n            this.requestMeasure();\n            return;\n        }\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush) this.observer.forceFlush();\n        let updated = null;\n        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;\n        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;\n        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;\n        this.viewState.scrollAnchorHeight = -1;\n        try {\n            for(let i = 0;; i++){\n                if (scrollAnchorHeight < 0) {\n                    if (isScrolledToBottom(sDOM)) {\n                        scrollAnchorPos = -1;\n                        scrollAnchorHeight = this.viewState.heightMap.height;\n                    } else {\n                        let block = this.viewState.scrollAnchorAt(scrollTop);\n                        scrollAnchorPos = block.from;\n                        scrollAnchorHeight = block.top;\n                    }\n                }\n                this.updateState = 1 /* UpdateState.Measuring */ ;\n                let changed = this.viewState.measure(this);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n                if (i > 5) {\n                    console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* UpdateFlag.Viewport */ )) [this.measureRequests, measuring] = [\n                    measuring,\n                    this.measureRequests\n                ];\n                let measured = measuring.map((m)=>{\n                    try {\n                        return m.read(this);\n                    } catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false;\n                update.flags |= changed;\n                if (!updated) updated = update;\n                else updated.flags |= changed;\n                this.updateState = 2 /* UpdateState.Updating */ ;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                    this.updateAttrs();\n                    redrawn = this.docView.update(update);\n                    if (redrawn) this.docViewUpdate();\n                }\n                for(let i = 0; i < measuring.length; i++)if (measured[i] != BadMeasure) {\n                    try {\n                        let m = measuring[i];\n                        if (m.write) m.write(measured[i], this);\n                    } catch (e) {\n                        logException(this.state, e);\n                    }\n                }\n                if (redrawn) this.docView.updateSelection(true);\n                if (!update.viewportChanged && this.measureRequests.length == 0) {\n                    if (this.viewState.editorHeight) {\n                        if (this.viewState.scrollTarget) {\n                            this.docView.scrollIntoView(this.viewState.scrollTarget);\n                            this.viewState.scrollTarget = null;\n                            scrollAnchorHeight = -1;\n                            continue;\n                        } else {\n                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;\n                            let diff = newAnchorHeight - scrollAnchorHeight;\n                            if (diff > 1 || diff < -1) {\n                                scrollTop = scrollTop + diff;\n                                sDOM.scrollTop = scrollTop / this.scaleY;\n                                scrollAnchorHeight = -1;\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n            this.measureScheduled = -1;\n        }\n        if (updated && !updated.empty) for (let listener of this.state.facet(updateListener))listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */ get themeClasses() {\n        return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            writingsuggestions: \"false\",\n            translate: \"no\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n        attrsFromFacet(this, contentAttributes, contentAttrs);\n        let changed = this.observer.ignore(()=>{\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n            return changedContent || changedEditor;\n        });\n        this.editorAttrs = editorAttrs;\n        this.contentAttrs = contentAttrs;\n        return changed;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)for (let effect of tr.effects)if (effect.is(EditorView.announce)) {\n            if (first) this.announceDOM.textContent = \"\";\n            first = false;\n            let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n            div.textContent = effect.value;\n        }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        let nonce = this.state.facet(EditorView.cspNonce);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {\n            nonce\n        } : undefined);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* UpdateState.Updating */ ) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* UpdateState.Idle */  && this.measureScheduled > -1) this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */ requestMeasure(request) {\n        if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(()=>this.measure());\n        if (request) {\n            if (this.measureRequests.indexOf(request) > -1) return;\n            if (request.key != null) for(let i = 0; i < this.measureRequests.length; i++){\n                if (this.measureRequests[i].key === request.key) {\n                    this.measureRequests[i] = request;\n                    return;\n                }\n            }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */ plugin(plugin) {\n        let known = this.pluginMap.get(plugin);\n        if (known === undefined || known && known.plugin != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p)=>p.plugin == plugin) || null);\n        return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */ get documentTop() {\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */ get documentPadding() {\n        return {\n            top: this.viewState.paddingTop,\n            bottom: this.viewState.paddingBottom\n        };\n    }\n    /**\n    If the editor is transformed with CSS, this provides the scale\n    along the X axis. Otherwise, it will just be 1. Note that\n    transforms other than translation and scaling are not supported.\n    */ get scaleX() {\n        return this.viewState.scaleX;\n    }\n    /**\n    Provide the CSS transformed scale along the Y axis.\n    */ get scaleY() {\n        return this.viewState.scaleY;\n    }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n    */ elementAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given\n    height, again interpreted relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n    */ lineBlockAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */ get viewportLineBlocks() {\n        return this.viewState.viewportLines;\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */ lineBlockAt(pos) {\n        return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */ get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. In\n    bidirectional text, the line is traversed in visual order, using\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n    When the start position was the last one on the line, the\n    returned position will be across the line break. If there is no\n    further line, the original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */ moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */ moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, (initial)=>byGroup(this, start.head, initial)));\n    }\n    /**\n    Get the cursor position visually at the start or end of a line.\n    Note that this may differ from the _logical_ position at its\n    start or end (which is simply at `line.from`/`line.to`) if text\n    at the start or end goes against the line's base text direction.\n    */ visualLineSide(line, end) {\n        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);\n        let span = order[end ? order.length - 1 : 0];\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */ moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */ moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */ domAtPos(pos, side = 1) {\n        return this.docView.domAtPos(pos, side);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */ posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        let found = posAtCoords(this, coords, precise);\n        return found && found.pos;\n    }\n    posAndSideAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */ coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right) return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n    }\n    /**\n    Return the rectangle around a given character. If `pos` does not\n    point in front of a character that is in the viewport and\n    rendered (i.e. not replaced, not a line break), this will return\n    null. For space characters that are a line wrap point, this will\n    return the position before the line break.\n    */ coordsForChar(pos) {\n        this.readMeasured();\n        return this.docView.coordsForChar(pos);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */ get defaultCharacterWidth() {\n        return this.viewState.heightOracle.charWidth;\n    }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */ get defaultLineHeight() {\n        return this.viewState.heightOracle.lineHeight;\n    }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor's content element.\n    */ get textDirection() {\n        return this.viewState.defaultTextDirection;\n    }\n    /**\n    Find the text direction of the block at the given position, as\n    assigned by CSS. If\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n    isn't enabled, or the given position is outside of the viewport,\n    this will always return the same as\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n    this may trigger a DOM layout.\n    */ textDirectionAt(pos) {\n        let perLine = this.state.facet(perLineTextDirection);\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n        this.readMeasured();\n        return this.docView.textDirectionAt(pos);\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */ get lineWrapping() {\n        return this.viewState.heightOracle.lineWrapping;\n    }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */ bidiSpans(line) {\n        if (line.length > MaxBidiLine) return trivialOrder(line.length);\n        let dir = this.textDirectionAt(line.from), isolates;\n        for (let entry of this.bidiCache){\n            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;\n        }\n        if (!isolates) isolates = getIsolatedRanges(this, line);\n        let order = computeOrder(line.text, dir, isolates);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */ get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */ focus() {\n        this.observer.ignore(()=>{\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n    necessary when moving the editor's existing DOM to a new window or shadow root.\n    */ setRoot(root) {\n        if (this._root != root) {\n            this._root = root;\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n            this.mountStyles();\n        }\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */ destroy() {\n        if (this.root.activeElement == this.contentDOM) this.contentDOM.blur();\n        for (let plugin of this.plugins)plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.docView.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */ static scrollIntoView(pos, options = {}) {\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Return an effect that resets the editor to its current (at the\n    time this method was called) scroll position. Note that this\n    only affects the editor's own scrollable element, not parents.\n    See also\n    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n    \n    The effect should be used with a document identical to the one\n    it was created for. Failing to do so is not an error, but may\n    not scroll to the expected position. You can\n    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n    */ scrollSnapshot() {\n        let { scrollTop, scrollLeft } = this.scrollDOM;\n        let ref = this.viewState.scrollAnchorAt(scrollTop);\n        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(ref.from), \"start\", \"start\", ref.top - scrollTop, scrollLeft, true));\n    }\n    /**\n    Enable or disable tab-focus mode, which disables key bindings\n    for Tab and Shift-Tab, letting the browser's default\n    focus-changing behavior go through instead. This is useful to\n    prevent trapping keyboard users in your editor.\n    \n    Without argument, this toggles the mode. With a boolean, it\n    enables (true) or disables it (false). Given a number, it\n    temporarily enables the mode until that number of milliseconds\n    have passed or another non-Tab key is pressed.\n    */ setTabFocusMode(to) {\n        if (to == null) this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;\n        else if (typeof to == \"boolean\") this.inputState.tabFocusMode = to ? 0 : -1;\n        else if (this.inputState.tabFocusMode != 0) this.inputState.tabFocusMode = Date.now() + to;\n    }\n    /**\n    Returns an extension that can be used to add DOM event handlers.\n    The value should be an object mapping event names to handler\n    functions. For any given event, such functions are ordered by\n    extension precedence, and the first handler to return true will\n    be assumed to have handled that event, and no other handlers or\n    built-in behavior will be activated for it. These are registered\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n    for `scroll` handlers, which will be called any time the\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n    its parent nodes is scrolled.\n    */ static domEventHandlers(handlers) {\n        return ViewPlugin.define(()=>({}), {\n            eventHandlers: handlers\n        });\n    }\n    /**\n    Create an extension that registers DOM event observers. Contrary\n    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n    observers can't be prevented from running by a higher-precedence\n    handler returning true. They also don't prevent other handlers\n    and observers from running when they return true, and should not\n    call `preventDefault`.\n    */ static domEventObservers(observers) {\n        return ViewPlugin.define(()=>({}), {\n            eventObservers: observers\n        });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be\n    addedâ€”need to be explicitly differentiated by adding an `&` to\n    the selector for that elementâ€”for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */ static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [\n            theme.of(prefix),\n            styleModule.of(buildTheme(`.${prefix}`, spec))\n        ];\n        if (options && options.dark) result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */ static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n    /**\n    Retrieve an editor view instance from the view's DOM\n    representation.\n    */ static findFromDOM(dom) {\n        var _a;\n        let content = dom.querySelector(\".cm-content\");\n        let tile = content && Tile.get(content) || Tile.get(dom);\n        return ((_a = tile === null || tile === void 0 ? void 0 : tile.root) === null || _a === void 0 ? void 0 : _a.view) || null;\n    }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/ EditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/ EditorView.inputHandler = inputHandler;\n/**\nFunctions provided in this facet will be used to transform text\npasted or dropped into the editor.\n*/ EditorView.clipboardInputFilter = clipboardInputFilter;\n/**\nTransform text copied or dragged from the editor.\n*/ EditorView.clipboardOutputFilter = clipboardOutputFilter;\n/**\nScroll handlers can override how things are scrolled into view.\nIf they return `true`, no further handling happens for the\nscrolling. If they return false, the default scroll behavior is\napplied. Scroll handlers should never initiate editor updates.\n*/ EditorView.scrollHandler = scrollHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/ EditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/ EditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/ EditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/ EditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/ EditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/ EditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/ EditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/ EditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nwaysâ€”directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/ EditorView.decorations = decorations;\n/**\n[Block wrappers](https://codemirror.net/6/docs/ref/#view.BlockWrapper) provide a way to add DOM\nstructure around editor lines and block widgets. Sets of\nwrappers are provided in a similar way to decorations, and are\nnested in a similar way when they overlap. A wrapper affects all\nlines and block widgets that start inside its range.\n*/ EditorView.blockWrappers = blockWrappers;\n/**\nFacet that works much like\n[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its\ninputs at the very bottom of the precedence stack, meaning mark\ndecorations provided here will only be split by other, partially\noverlapping `outerDecorations` ranges, and wrap around all\nregular decorations. Use this for mark elements that should, as\nmuch as possible, remain in one piece.\n*/ EditorView.outerDecorations = outerDecorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/ EditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/ EditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/ EditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/ EditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/ EditorView.cspNonce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.length ? values[0] : \"\"\n});\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/ EditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/ EditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/ EditorView.lineWrapping = /*@__PURE__*/ EditorView.contentAttributes.of({\n    \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/ EditorView.announce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, isolates, fresh, order){\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.isolates = isolates;\n        this.fresh = fresh;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty && !cache.some((c)=>c.fresh)) return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for(let i = Math.max(0, cache.length - 10); i < cache.length; i++){\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n        }\n        return result;\n    }\n}\nfunction attrsFromFacet(view, facet, base) {\n    for(let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--){\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\n        if (value) combineAttrs(value, base);\n    }\n    return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\") result = \" \";\n    let alt, ctrl, shift, meta;\n    for(let i = 0; i < parts.length - 1; ++i){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) meta = true;\n        else if (/^a(lt)?$/i.test(mod)) alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n        else if (/^s(hift)?$/i.test(mod)) shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\") meta = true;\n            else ctrl = true;\n        } else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) result = \"Alt-\" + result;\n    if (ctrl) result = \"Ctrl-\" + result;\n    if (meta) result = \"Meta-\" + result;\n    if (shift) result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey) name = \"Alt-\" + name;\n    if (event.ctrlKey) name = \"Ctrl-\" + name;\n    if (event.metaKey) name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.default(/*@__PURE__*/ EditorView.domEventHandlers({\n    keydown (event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/ const keymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/ new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b)=>a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/ function runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is)=>{\n        let current = isPrefix[name];\n        if (current == null) isPrefix[name] = is;\n        else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault, stopPropagation)=>{\n        var _a, _b;\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map((k)=>normalizeKeyName(k, platform));\n        for(let i = 1; i < parts.length; i++){\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix]) scopeObj[prefix] = {\n                preventDefault: true,\n                stopPropagation: false,\n                run: [\n                    (view)=>{\n                        let ourObj = storedPrefix = {\n                            view,\n                            prefix,\n                            scope\n                        };\n                        setTimeout(()=>{\n                            if (storedPrefix == ourObj) storedPrefix = null;\n                        }, PrefixTimeout);\n                        return true;\n                    }\n                ]\n            };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = {\n            preventDefault: false,\n            stopPropagation: false,\n            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n        });\n        if (command) binding.run.push(command);\n        if (preventDefault) binding.preventDefault = true;\n        if (stopPropagation) binding.stopPropagation = true;\n    };\n    for (let b of bindings){\n        let scopes = b.scope ? b.scope.split(\" \") : [\n            \"editor\"\n        ];\n        if (b.any) for (let scope of scopes){\n            let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n            if (!scopeObj._any) scopeObj._any = {\n                preventDefault: false,\n                stopPropagation: false,\n                run: []\n            };\n            let { any } = b;\n            for(let key in scopeObj)scopeObj[key].run.push((view)=>any(view, currentKeyEvent));\n        }\n        let name = b[platform] || b.key;\n        if (!name) continue;\n        for (let scope of scopes){\n            add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n            if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n        }\n    }\n    return bound;\n}\nlet currentKeyEvent = null;\nfunction runHandlers(map, event, view, scope) {\n    currentKeyEvent = event;\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointSize)(charCode) == name.length && name != \" \";\n    let prefix = \"\", handled = false, prevented = false, stopPropagation = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (modifierCodes.indexOf(event.keyCode) < 0) {\n            prevented = true;\n            storedPrefix = null;\n        }\n    }\n    let ran = new Set;\n    let runFor = (binding)=>{\n        if (binding) {\n            for (let cmd of binding.run)if (!ran.has(cmd)) {\n                ran.add(cmd);\n                if (cmd(view)) {\n                    if (binding.stopPropagation) stopPropagation = true;\n                    return true;\n                }\n            }\n            if (binding.preventDefault) {\n                if (binding.stopPropagation) stopPropagation = true;\n                prevented = true;\n            }\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName, shiftName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n            handled = true;\n        } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters\n        !(browser.mac && event.altKey && !(event.ctrlKey || event.metaKey)) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n                handled = true;\n            } else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n                handled = true;\n            }\n        } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n            handled = true;\n        }\n        if (!handled && runFor(scopeObj._any)) handled = true;\n    }\n    if (prevented) handled = true;\n    if (handled && stopPropagation) event.stopPropagation();\n    currentKeyEvent = null;\n    return handled;\n}\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/ class RectangleMarker {\n    /**\n    Create a marker with the given class and dimensions. If `width`\n    is null, the DOM element will get no width style.\n    */ constructor(className, /**\n    The left position of the marker (in pixels, document-relative).\n    */ left, /**\n    The top position of the marker.\n    */ top, /**\n    The width of the marker, or null if it shouldn't get a width assigned.\n    */ width, /**\n    The height of the marker.\n    */ height){\n        this.className = className;\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    update(elt, prev) {\n        if (prev.className != this.className) return false;\n        this.adjust(elt);\n        return true;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width != null) elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n    }\n    /**\n    Create a set of rectangles for the given selection range,\n    assigning them theclass`className`. Will create a single\n    rectangle for empty ranges, and a set of selection-style\n    rectangles covering the range's content (in a bidi-aware\n    way) for non-empty ones.\n    */ static forRange(view, className, range) {\n        if (range.empty) {\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (!pos) return [];\n            let base = getBase(view);\n            return [\n                new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)\n            ];\n        } else {\n            return rectanglesForRange(view, className, range);\n        }\n    }\n}\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n    return {\n        left: left - view.scrollDOM.scrollLeft * view.scaleX,\n        top: rect.top - view.scrollDOM.scrollTop * view.scaleY\n    };\n}\nfunction wrappedLine(view, pos, side, inside) {\n    let coords = view.coordsAtPos(pos, side * 2);\n    if (!coords) return inside;\n    let editorRect = view.dom.getBoundingClientRect();\n    let y = (coords.top + coords.bottom) / 2;\n    let left = view.posAtCoords({\n        x: editorRect.left + 1,\n        y\n    });\n    let right = view.posAtCoords({\n        x: editorRect.right - 1,\n        y\n    });\n    if (left == null || right == null) return inside;\n    return {\n        from: Math.max(inside.from, Math.min(left, right)),\n        to: Math.min(inside.to, Math.max(left, right))\n    };\n}\nfunction rectanglesForRange(view, className, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineElt = content.querySelector(\".cm-line\"), lineStyle = lineElt && window.getComputedStyle(lineElt);\n    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n    let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to, -1);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, 1, visualStart);\n    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, -1, visualEnd);\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    } else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new RectangleMarker(className, left - base.left, top - base.top, right - left, bottom - top);\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for(let i = 0; i < horizontal.length; i += 2)pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n            let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n            if (!fromCoords || !toCoords) return;\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)if (r.to > start && r.from < end) {\n            for(let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;){\n                let docLine = view.state.doc.lineAt(pos);\n                for (let span of view.bidiSpans(docLine)){\n                    let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                    if (spanFrom >= endPos) break;\n                    if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                }\n                pos = docLine.to + 1;\n                if (pos >= endPos) break;\n            }\n        }\n        if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n        return {\n            top,\n            bottom,\n            horizontal\n        };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return {\n            top: y,\n            bottom: y,\n            horizontal: []\n        };\n    }\n}\nfunction sameMarker(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n    constructor(view, layer){\n        this.view = view;\n        this.layer = layer;\n        this.drawn = [];\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.measureReq = {\n            read: this.measure.bind(this),\n            write: this.draw.bind(this)\n        };\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.dom.classList.add(\"cm-layer\");\n        if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n        if (layer.class) this.dom.classList.add(layer.class);\n        this.scale();\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.setOrder(view.state);\n        view.requestMeasure(this.measureReq);\n        if (layer.mount) layer.mount(this.dom, view);\n    }\n    update(update) {\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n        if (this.layer.update(update, this.dom) || update.geometryChanged) {\n            this.scale();\n            update.view.requestMeasure(this.measureReq);\n        }\n    }\n    docViewUpdate(view) {\n        if (this.layer.updateOnDocViewUpdate !== false) view.requestMeasure(this.measureReq);\n    }\n    setOrder(state) {\n        let pos = 0, order = state.facet(layerOrder);\n        while(pos < order.length && order[pos] != this.layer)pos++;\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n    }\n    measure() {\n        return this.layer.markers(this.view);\n    }\n    scale() {\n        let { scaleX, scaleY } = this.view;\n        if (scaleX != this.scaleX || scaleY != this.scaleY) {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n        }\n    }\n    draw(markers) {\n        if (markers.length != this.drawn.length || markers.some((p, i)=>!sameMarker(p, this.drawn[i]))) {\n            let old = this.dom.firstChild, oldI = 0;\n            for (let marker of markers){\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n                    old = old.nextSibling;\n                    oldI++;\n                } else {\n                    this.dom.insertBefore(marker.draw(), old);\n                }\n            }\n            while(old){\n                let next = old.nextSibling;\n                old.remove();\n                old = next;\n            }\n            this.drawn = markers;\n            if (browser.safari && browser.safari_version >= 26) this.dom.style.display = this.dom.firstChild ? \"\" : \"none\";\n        }\n    }\n    destroy() {\n        if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n        this.dom.remove();\n    }\n}\nconst layerOrder = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nDefine a layer.\n*/ function layer(config) {\n    return [\n        ViewPlugin.define((v)=>new LayerView(v, config)),\n        layerOrder.of(config)\n    ];\n}\nconst selectionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b)=>Math.min(a, b),\n            drawRangeCursor: (a, b)=>a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/ function drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        cursorLayer,\n        selectionLayer,\n        hideNativeSelection,\n        nativeSelectionHidden.of(true)\n    ];\n}\n/**\nRetrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration\nfor this state. (Note that this will return a set of defaults even\nif `drawSelection` isn't enabled.)\n*/ function getDrawSelectionConfig(state) {\n    return state.facet(selectionConfig);\n}\nfunction configChanged(update) {\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/ layer({\n    above: true,\n    markers (view) {\n        let { state } = view, conf = state.facet(selectionConfig);\n        let cursors = [];\n        for (let r of state.selection.ranges){\n            let prim = r == state.selection.main;\n            if (r.empty || conf.drawRangeCursor) {\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n                for (let piece of RectangleMarker.forRange(view, className, cursor))cursors.push(piece);\n            }\n        }\n        return cursors;\n    },\n    update (update, dom) {\n        if (update.transactions.some((tr)=>tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        let confChange = configChanged(update);\n        if (confChange) setBlinkRate(update.state, dom);\n        return update.docChanged || update.selectionSet || confChange;\n    },\n    mount (dom, view) {\n        setBlinkRate(view.state, dom);\n    },\n    class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/ layer({\n    above: false,\n    markers (view) {\n        return view.state.selection.ranges.map((r)=>r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b)=>a.concat(b));\n    },\n    update (update, dom) {\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n    },\n    class: \"cm-selectionLayer\"\n});\nconst hideNativeSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.highest(/*@__PURE__*/ EditorView.theme({\n    \".cm-line\": {\n        \"& ::selection, &::selection\": {\n            backgroundColor: \"transparent !important\"\n        },\n        caretColor: \"transparent !important\"\n    },\n    \".cm-content\": {\n        caretColor: \"transparent !important\",\n        \"& :focus\": {\n            caretColor: \"initial !important\",\n            \"&::selection, & ::selection\": {\n                backgroundColor: \"Highlight !important\"\n            }\n        }\n    }\n}));\nconst setDropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map (pos, mapping) {\n        return pos == null ? null : mapping.mapPos(pos);\n    }\n});\nconst dropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return null;\n    },\n    update (pos, tr) {\n        if (pos != null) pos = tr.changes.mapPos(pos);\n        return tr.effects.reduce((pos, e)=>e.is(setDropCursorPos) ? e.value : pos, pos);\n    }\n});\nconst drawDropCursor = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.cursor = null;\n        this.measureReq = {\n            read: this.readPos.bind(this),\n            write: this.drawCursor.bind(this)\n        };\n    }\n    update(update) {\n        var _a;\n        let cursorPos = update.state.field(dropCursorPos);\n        if (cursorPos == null) {\n            if (this.cursor != null) {\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n                this.cursor = null;\n            }\n        } else {\n            if (!this.cursor) {\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n                this.cursor.className = \"cm-dropCursor\";\n            }\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n        }\n    }\n    readPos() {\n        let { view } = this;\n        let pos = view.state.field(dropCursorPos);\n        let rect = pos != null && view.coordsAtPos(pos);\n        if (!rect) return null;\n        let outer = view.scrollDOM.getBoundingClientRect();\n        return {\n            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n            height: rect.bottom - rect.top\n        };\n    }\n    drawCursor(pos) {\n        if (this.cursor) {\n            let { scaleX, scaleY } = this.view;\n            if (pos) {\n                this.cursor.style.left = pos.left / scaleX + \"px\";\n                this.cursor.style.top = pos.top / scaleY + \"px\";\n                this.cursor.style.height = pos.height / scaleY + \"px\";\n            } else {\n                this.cursor.style.left = \"-100000px\";\n            }\n        }\n    }\n    destroy() {\n        if (this.cursor) this.cursor.remove();\n    }\n    setDropPos(pos) {\n        if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n            effects: setDropCursorPos.of(pos)\n        });\n    }\n}, {\n    eventObservers: {\n        dragover (event) {\n            this.setDropPos(this.view.posAtCoords({\n                x: event.clientX,\n                y: event.clientY\n            }));\n        },\n        dragleave (event) {\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n        },\n        dragend () {\n            this.setDropPos(null);\n        },\n        drop () {\n            this.setDropPos(null);\n        }\n    }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/ function dropCursor() {\n    return [\n        dropCursorPos,\n        drawDropCursor\n    ];\n}\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for(let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length){\n        if (!cursor.lineBreak) while(m = re.exec(cursor.value))f(pos + m.index, m);\n    }\n}\nfunction matchRanges(view, maxLength) {\n    let visible = view.visibleRanges;\n    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n    let result = [];\n    for (let { from, to } of visible){\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n        if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;\n        else result.push({\n            from,\n            to\n        });\n    }\n    return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/ class MatchDecorator {\n    /**\n    Create a decorator.\n    */ constructor(config){\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\n        if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        if (decorate) {\n            this.addMatch = (match, view, from, add)=>decorate(add, from, from + match[0].length, match, view);\n        } else if (typeof decoration == \"function\") {\n            this.addMatch = (match, view, from, add)=>{\n                let deco = decoration(match, view, from);\n                if (deco) add(from, from + match[0].length, deco);\n            };\n        } else if (decoration) {\n            this.addMatch = (match, _view, from, add)=>add(from, from + match[0].length, decoration);\n        } else {\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n        }\n        this.boundary = boundary;\n        this.maxLength = maxLength;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */ createDeco(view) {\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder(), add = build.add.bind(build);\n        for (let { from, to } of matchRanges(view, this.maxLength))iterMatches(view.state.doc, this.regexp, from, to, (from, m)=>this.addMatch(m, view, from, add));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */ updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged) update.changes.iterChanges((_f, _t, from, to)=>{\n            if (to >= update.view.viewport.from && from <= update.view.viewport.to) {\n                changeFrom = Math.min(from, changeFrom);\n                changeTo = Math.max(to, changeTo);\n            }\n        });\n        if (update.viewportMoved || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n        if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges){\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to >= from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for(; from > fromLine.from; from--)if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                        start = from;\n                        break;\n                    }\n                    for(; to < toLine.to; to++)if (this.boundary.test(toLine.text[to - toLine.from])) {\n                        end = to;\n                        break;\n                    }\n                }\n                let ranges = [], m;\n                let add = (from, to, deco)=>ranges.push(deco.range(from, to));\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)this.addMatch(m, view, m.index + fromLine.from, add);\n                } else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m)=>this.addMatch(m, view, from, add));\n                }\n                deco = deco.update({\n                    filterFrom: start,\n                    filterTo: end,\n                    filter: (from, to)=>from < start || to > end,\n                    add: ranges\n                });\n            }\n        }\n        return deco;\n    }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/ new RegExp(\"[\\x00-\\b\\n-\\x1f\\x7f-\\x9f\\xadØœâ€‹â€Žâ€\\u2028\\u2029â€­â€®â¦â§â©\\uFEFFï¿¹-ï¿¼]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8237: \"left-to-right override\",\n    8238: \"right-to-left override\",\n    8294: \"left-to-right isolate\",\n    8295: \"right-to-left isolate\",\n    8297: \"pop directional isolate\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/ function highlightSpecialChars(/**\nConfiguration options.\n*/ config = {}) {\n    return [\n        specialCharConfig.of(config),\n        specialCharPlugin()\n    ];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos)=>{\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({\n                            widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)\n                        });\n                    }\n                    return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n                        widget: new SpecialCharWidget(conf, code)\n                    }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            } else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"â€¢\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32) return DefaultPlaceholder;\n    if (code == 10) return \"â¤\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code){\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) {\n        return other.code == this.code;\n    }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom) return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass TabWidget extends WidgetType {\n    constructor(width){\n        super();\n        this.width = width;\n    }\n    eq(other) {\n        return other.width == this.width;\n    }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nconst plugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(){\n        this.height = 1000;\n        this.attrs = {\n            style: \"padding-bottom: 1000px\"\n        };\n    }\n    update(update) {\n        let { view } = update;\n        let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;\n        if (height >= 0 && height != this.height) {\n            this.height = height;\n            this.attrs = {\n                style: `padding-bottom: ${height}px`\n            };\n        }\n    }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/ function scrollPastEnd() {\n    return [\n        plugin,\n        contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n        })\n    ];\n}\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/ function highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/ Decoration.line({\n    class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges){\n            let line = view.lineBlockAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nclass Placeholder extends WidgetType {\n    constructor(content){\n        super();\n        this.content = content;\n    }\n    toDOM(view) {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : typeof this.content == \"function\" ? this.content(view) : this.content.cloneNode(true));\n        wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    coordsAt(dom) {\n        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n        if (!rects.length) return null;\n        let style = window.getComputedStyle(dom.parentNode);\n        let rect = flattenRect(rects[0], style.direction != \"rtl\");\n        let lineHeight = parseInt(style.lineHeight);\n        if (rect.bottom - rect.top > lineHeight * 1.5) return {\n            left: rect.left,\n            right: rect.right,\n            top: rect.top,\n            bottom: rect.top + lineHeight\n        };\n        return rect;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\n/**\nExtension that enables a placeholderâ€”a piece of example content\nto show when the editor is empty.\n*/ function placeholder(content) {\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.placeholder = content ? Decoration.set([\n                Decoration.widget({\n                    widget: new Placeholder(content),\n                    side: 1\n                }).range(0)\n            ]) : Decoration.none;\n        }\n        get decorations() {\n            return this.view.state.doc.length ? Decoration.none : this.placeholder;\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    });\n    return typeof content == \"string\" ? [\n        plugin,\n        EditorView.contentAttributes.of({\n            \"aria-placeholder\": content\n        })\n    ] : plugin;\n}\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    } else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start < 0) {\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(line.to));\n            } else {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return {\n        line: line.number,\n        col,\n        off\n    };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start) return null;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = {\n                    line: newLine.number,\n                    col: start.col,\n                    off: Math.min(start.off, newLine.length)\n                };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur) return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length) return startSel;\n            if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/ function rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e)=>e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event)=>filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n    Alt: [\n        18,\n        (e)=>!!e.altKey\n    ],\n    Control: [\n        17,\n        (e)=>!!e.ctrlKey\n    ],\n    Shift: [\n        16,\n        (e)=>!!e.shiftKey\n    ],\n    Meta: [\n        91,\n        (e)=>!!e.metaKey\n    ]\n};\nconst showCrosshair = {\n    style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/ function crosshairCursor(options = {}) {\n    let [code, getter] = keys[options.key || \"Alt\"];\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.isDown = false;\n        }\n        set(isDown) {\n            if (this.isDown != isDown) {\n                this.isDown = isDown;\n                this.view.update([]);\n            }\n        }\n    }, {\n        eventObservers: {\n            keydown (e) {\n                this.set(e.keyCode == code || getter(e));\n            },\n            keyup (e) {\n                if (e.keyCode == code || !getter(e)) this.set(false);\n            },\n            mousemove (e) {\n                this.set(getter(e));\n            }\n        }\n    });\n    return [\n        plugin,\n        EditorView.contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n        })\n    ];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView, removeTooltipView){\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.removeTooltipView = removeTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter((t)=>t);\n        let prev = null;\n        this.tooltipViews = this.tooltips.map((t)=>prev = createTooltipView(t, prev));\n    }\n    update(update, above) {\n        var _a;\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter((x)=>x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)if (t.update) t.update(update);\n            return false;\n        }\n        let tooltipViews = [], newAbove = above ? [] : null;\n        for(let i = 0; i < tooltips.length; i++){\n            let tip = tooltips[i], known = -1;\n            if (!tip) continue;\n            for(let i = 0; i < this.tooltips.length; i++){\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create) known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);\n                if (newAbove) newAbove[i] = !!tip.above;\n            } else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (newAbove) newAbove[i] = above[known];\n                if (tooltipView.update) tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)if (tooltipViews.indexOf(t) < 0) {\n            this.removeTooltipView(t);\n            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n        }\n        if (above) {\n            newAbove.forEach((val, i)=>above[i] = val);\n            above.length = newAbove.length;\n        }\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return true;\n    }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/ function tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n    let docElt = view.dom.ownerDocument.documentElement;\n    return {\n        top: 0,\n        left: 0,\n        bottom: docElt.clientHeight,\n        right: docElt.clientWidth\n    };\n}\nconst tooltipConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        var _a, _b, _c;\n        return {\n            position: browser.ios ? \"absolute\" : ((_a = values.find((conf)=>conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find((conf)=>conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n            tooltipSpace: ((_c = values.find((conf)=>conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n        };\n    }\n});\nconst knownHeight = /*@__PURE__*/ new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.above = [];\n        this.inView = true;\n        this.madeAbsolute = false;\n        this.lastTransaction = 0;\n        this.measureTimeout = -1;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = {\n            read: this.readMeasure.bind(this),\n            write: this.writeMeasure.bind(this),\n            key: this\n        };\n        this.resizeObserver = typeof ResizeObserver == \"function\" ? new ResizeObserver(()=>this.measureSoon()) : null;\n        this.manager = new TooltipViewManager(view, showTooltip, (t, p)=>this.createTooltip(t, p), (t)=>{\n            if (this.resizeObserver) this.resizeObserver.unobserve(t.dom);\n            t.dom.remove();\n        });\n        this.above = this.manager.tooltips.map((t)=>!!t.above);\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver((entries)=>{\n            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n        }, {\n            threshold: [\n                1\n            ]\n        }) : null;\n        this.observeIntersection();\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        } else {\n            this.container = this.view.dom;\n        }\n    }\n    observeIntersection() {\n        if (this.intersectionObserver) {\n            this.intersectionObserver.disconnect();\n            for (let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom);\n        }\n    }\n    measureSoon() {\n        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(()=>{\n            this.measureTimeout = -1;\n            this.maybeMeasure();\n        }, 50);\n    }\n    update(update) {\n        if (update.transactions.length) this.lastTransaction = Date.now();\n        let updated = this.manager.update(update, this.above);\n        if (updated) this.observeIntersection();\n        let shouldMeasure = updated || update.geometryChanged;\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position && !this.madeAbsolute) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent) this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        } else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure) this.maybeMeasure();\n    }\n    createTooltip(tooltip, prev) {\n        let tooltipView = tooltip.create(this.view);\n        let before = prev ? prev.dom : null;\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n            let arrow = document.createElement(\"div\");\n            arrow.className = \"cm-tooltip-arrow\";\n            tooltipView.dom.appendChild(arrow);\n        }\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        tooltipView.dom.style.left = \"0px\";\n        this.container.insertBefore(tooltipView.dom, before);\n        if (tooltipView.mount) tooltipView.mount(this.view);\n        if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);\n        return tooltipView;\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\n        for (let tooltipView of this.manager.tooltipViews){\n            tooltipView.dom.remove();\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n        }\n        if (this.parent) this.container.remove();\n        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();\n        clearTimeout(this.measureTimeout);\n    }\n    readMeasure() {\n        let scaleX = 1, scaleY = 1, makeAbsolute = false;\n        if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n            let { dom } = this.manager.tooltipViews[0];\n            if (browser.safari) {\n                // Safari always sets offsetParent to null, even if a fixed\n                // element is positioned relative to a transformed parent. So\n                // we use this kludge to try and detect this.\n                let rect = dom.getBoundingClientRect();\n                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;\n            } else {\n                // More conforming browsers will set offsetParent to the\n                // transformed element.\n                makeAbsolute = !!dom.offsetParent && dom.offsetParent != this.container.ownerDocument.body;\n            }\n        }\n        if (makeAbsolute || this.position == \"absolute\") {\n            if (this.parent) {\n                let rect = this.parent.getBoundingClientRect();\n                if (rect.width && rect.height) {\n                    scaleX = rect.width / this.parent.offsetWidth;\n                    scaleY = rect.height / this.parent.offsetHeight;\n                }\n            } else {\n                ({ scaleX, scaleY } = this.view.viewState);\n            }\n        }\n        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);\n        return {\n            visible: {\n                left: visible.left + margins.left,\n                top: visible.top + margins.top,\n                right: visible.right - margins.right,\n                bottom: visible.bottom - margins.bottom\n            },\n            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),\n            pos: this.manager.tooltips.map((t, i)=>{\n                let tv = this.manager.tooltipViews[i];\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n            }),\n            size: this.manager.tooltipViews.map(({ dom })=>dom.getBoundingClientRect()),\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n            scaleX,\n            scaleY,\n            makeAbsolute\n        };\n    }\n    writeMeasure(measured) {\n        var _a;\n        if (measured.makeAbsolute) {\n            this.madeAbsolute = true;\n            this.position = \"absolute\";\n            for (let t of this.manager.tooltipViews)t.dom.style.position = \"absolute\";\n        }\n        let { visible, space, scaleX, scaleY } = measured;\n        let others = [];\n        for(let i = 0; i < this.manager.tooltips.length; i++){\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - .1 || pos.left > Math.min(visible.right, space.right) + .1)) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n            let arrowHeight = arrow ? 7 /* Arrow.Size */  : 0;\n            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\n            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */  : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */  : 0) - offset.x), space.right - width);\n            let above = this.above[i];\n            if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n            if (spaceVert < height && tView.resize !== false) {\n                if (spaceVert < this.view.defaultLineHeight) {\n                    dom.style.top = Outside;\n                    continue;\n                }\n                knownHeight.set(tView, height);\n                dom.style.height = (height = spaceVert) / scaleY + \"px\";\n            } else if (dom.style.height) {\n                dom.style.height = \"\";\n            }\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n            let right = left + width;\n            if (tView.overlap !== true) {\n                for (let r of others)if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            }\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n                setLeftStyle(dom, (left - measured.parent.left) / scaleX);\n            } else {\n                dom.style.top = top / scaleY + \"px\";\n                setLeftStyle(dom, left / scaleX);\n            }\n            if (arrow) {\n                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */  - 7 /* Arrow.Size */ );\n                arrow.style.left = arrowLeft / scaleX + \"px\";\n            }\n            if (tView.overlap !== true) others.push({\n                left,\n                top,\n                right,\n                bottom: top + height\n            });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned) tView.positioned(measured.space);\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView) this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView) for (let tv of this.manager.tooltipViews)tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventObservers: {\n        scroll () {\n            this.maybeMeasure();\n        }\n    }\n});\nfunction setLeftStyle(elt, value) {\n    let current = parseInt(elt.style.left, 10);\n    if (isNaN(current) || Math.abs(value - current) > 1) elt.style.left = value + \"px\";\n}\nconst baseTheme = /*@__PURE__*/ EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 500,\n        boxSizing: \"border-box\"\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\"\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip-arrow\": {\n        height: `${7 /* Arrow.Size */ }px`,\n        width: `${7 /* Arrow.Size */  * 2}px`,\n        position: \"absolute\",\n        zIndex: -1,\n        overflow: \"hidden\",\n        \"&:before, &:after\": {\n            content: \"''\",\n            position: \"absolute\",\n            width: 0,\n            height: 0,\n            borderLeft: `${7 /* Arrow.Size */ }px solid transparent`,\n            borderRight: `${7 /* Arrow.Size */ }px solid transparent`\n        },\n        \".cm-tooltip-above &\": {\n            bottom: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                bottom: \"1px\"\n            }\n        },\n        \".cm-tooltip-below &\": {\n            top: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                top: \"1px\"\n            }\n        }\n    },\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n        \"&:before\": {\n            borderTopColor: \"#333338\",\n            borderBottomColor: \"#333338\"\n        },\n        \"&:after\": {\n            borderTopColor: \"transparent\",\n            borderBottomColor: \"transparent\"\n        }\n    }\n});\nconst noOffset = {\n    x: 0,\n    y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/ const showTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    enables: [\n        tooltipPlugin,\n        baseTheme\n    ]\n});\nconst showHoverTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (inputs)=>inputs.reduce((a, i)=>a.concat(i), [])\n});\nclass HoverTooltipHost {\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    constructor(view){\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p)=>this.createHostedView(t, p), (t)=>t.dom.remove());\n    }\n    createHostedView(tooltip, prev) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);\n        if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.mount) hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned(space) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.positioned) hostedView.positioned(space);\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n    destroy() {\n        var _a;\n        for (let t of this.manager.tooltipViews)(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    passProp(name) {\n        let value = undefined;\n        for (let view of this.manager.tooltipViews){\n            let given = view[name];\n            if (given !== undefined) {\n                if (value === undefined) value = given;\n                else if (value !== given) return undefined;\n            }\n        }\n        return value;\n    }\n    get offset() {\n        return this.passProp(\"offset\");\n    }\n    get getCoords() {\n        return this.passProp(\"getCoords\");\n    }\n    get overlap() {\n        return this.passProp(\"overlap\");\n    }\n    get resize() {\n        return this.passProp(\"resize\");\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/ showTooltip.compute([\n    showHoverTooltip\n], (state)=>{\n    let tooltips = state.facet(showHoverTooltip);\n    if (tooltips.length === 0) return null;\n    return {\n        pos: Math.min(...tooltips.map((t)=>t.pos)),\n        end: Math.max(...tooltips.map((t)=>{\n            var _a;\n            return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;\n        })),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some((t)=>t.arrow)\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime){\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.lastMove = {\n            x: 0,\n            y: 0,\n            target: view.dom,\n            time: 0\n        };\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(()=>this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active.length) return;\n        let hovered = Date.now() - this.lastMove.time;\n        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else this.startHover();\n    }\n    startHover() {\n        clearTimeout(this.restartTimeout);\n        let { view, lastMove } = this;\n        let tile = view.docView.tile.nearest(lastMove.target);\n        if (!tile) return;\n        let pos, side = 1;\n        if (tile.isWidget()) {\n            pos = tile.posAtStart;\n        } else {\n            pos = view.posAtCoords(lastMove);\n            if (pos == null) return;\n            let posCoords = view.coordsAtPos(pos);\n            if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;\n            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s)=>s.from <= pos && s.to >= pos);\n            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n            side = lastMove.x < posCoords.left ? -rtl : rtl;\n        }\n        let open = this.source(view, pos, side);\n        if (open === null || open === void 0 ? void 0 : open.then) {\n            let pending = this.pending = {\n                pos\n            };\n            open.then((result)=>{\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result && !(Array.isArray(result) && !result.length)) view.dispatch({\n                        effects: this.setHover.of(Array.isArray(result) ? result : [\n                            result\n                        ])\n                    });\n                }\n            }, (e)=>logException(view.state, e, \"hover tooltip\"));\n        } else if (open && !(Array.isArray(open) && !open.length)) {\n            view.dispatch({\n                effects: this.setHover.of(Array.isArray(open) ? open : [\n                    open\n                ])\n            });\n        }\n    }\n    get tooltip() {\n        let plugin = this.view.plugin(tooltipPlugin);\n        let index = plugin ? plugin.manager.tooltips.findIndex((t)=>t.create == HoverTooltipHost.create) : -1;\n        return index > -1 ? plugin.manager.tooltipViews[index] : null;\n    }\n    mousemove(event) {\n        var _a, _b;\n        this.lastMove = {\n            x: event.clientX,\n            y: event.clientY,\n            target: event.target,\n            time: Date.now()\n        };\n        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let { active, tooltip } = this;\n        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {\n            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;\n            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {\n                this.view.dispatch({\n                    effects: this.setHover.of([])\n                });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave(event) {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        let { active } = this;\n        if (active.length) {\n            let { tooltip } = this;\n            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);\n            if (!inTooltip) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n            else this.watchTooltipLeave(tooltip.dom);\n        }\n    }\n    watchTooltipLeave(tooltip) {\n        let watch = (event)=>{\n            tooltip.removeEventListener(\"mouseleave\", watch);\n            if (this.active.length && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n        };\n        tooltip.addEventListener(\"mouseleave\", watch);\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        clearTimeout(this.restartTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nconst tooltipMargin = 4;\nfunction isInTooltip(tooltip, event) {\n    let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;\n    if (arrow = tooltip.querySelector(\".cm-tooltip-arrow\")) {\n        let arrowRect = arrow.getBoundingClientRect();\n        top = Math.min(arrowRect.top, top);\n        bottom = Math.max(arrowRect.bottom, bottom);\n    }\n    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;\n    let pos = view.posAtCoords({\n        x,\n        y\n    }, false);\n    return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer isâ€”it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n\nThe return value is a valid [editor extension](https://codemirror.net/6/docs/ref/#state.Extension)\nbut also provides an `active` property holding a state field that\ncan be used to read the currently active tooltips produced by this\nextension.\n*/ function hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n        create () {\n            return [];\n        },\n        update (value, tr) {\n            if (value.length) {\n                if (options.hideOnChange && (tr.docChanged || tr.selection)) value = [];\n                else if (options.hideOn) value = value.filter((v)=>!options.hideOn(tr, v));\n                if (tr.docChanged) {\n                    let mapped = [];\n                    for (let tooltip of value){\n                        let newPos = tr.changes.mapPos(tooltip.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackDel);\n                        if (newPos != null) {\n                            let copy = Object.assign(Object.create(null), tooltip);\n                            copy.pos = newPos;\n                            if (copy.end != null) copy.end = tr.changes.mapPos(copy.end);\n                            mapped.push(copy);\n                        }\n                    }\n                    value = mapped;\n                }\n            }\n            for (let effect of tr.effects){\n                if (effect.is(setHover)) value = effect.value;\n                if (effect.is(closeHoverTooltipEffect)) value = [];\n            }\n            return value;\n        },\n        provide: (f)=>showHoverTooltip.from(f)\n    });\n    return {\n        active: hoverState,\n        extension: [\n            hoverState,\n            ViewPlugin.define((view)=>new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */ )),\n            showHoverTooltipHost\n        ]\n    };\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/ function getTooltip(view, tooltip) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (!plugin) return null;\n    let found = plugin.manager.tooltips.indexOf(tooltip);\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/ function hasHoverTooltips(state) {\n    return state.facet(showHoverTooltip).some((x)=>x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/ const closeHoverTooltips = /*@__PURE__*/ closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/ function repositionTooltips(view) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (plugin) plugin.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs){\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return {\n            topContainer,\n            bottomContainer\n        };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/ function panels(config) {\n    return config ? [\n        panelConfig.of(config)\n    ] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/ function getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter((s)=>s);\n        this.panels = this.specs.map((spec)=>spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter((p)=>p.top));\n        this.bottom.sync(this.panels.filter((p)=>!p.top));\n        for (let p of this.panels){\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount) p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter((x)=>x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs){\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                } else {\n                    panel = this.panels[known];\n                    if (panel.update) panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount){\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount) p.mount();\n            }\n        } else {\n            for (let p of this.panels)if (p.update) p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            return value && {\n                top: value.top.scrollMargin(),\n                bottom: value.bottom.scrollMargin()\n            };\n        })\n});\nclass PanelGroup {\n    constructor(view, top, container){\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        for (let p of this.panels)if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels){\n            if (panel.dom.parentNode == this.dom) {\n                while(curDOM != panel.dom)curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            } else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while(curDOM)curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses) return;\n        for (let cls of this.classes.split(\" \"))if (cls) this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))if (cls) this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/ const showPanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    enables: panelPlugin\n});\n/**\nShow a panel above or below the editor to show the user a message\nor prompt them for input. Returns an effect that can be dispatched\nto close the dialog, and a promise that resolves when the dialog\nis closed or a form inside of it is submitted.\n\nYou are encouraged, if your handling of the result of the promise\ndispatches a transaction, to include the `close` effect in it. If\nyou don't, this function will automatically dispatch a separate\ntransaction right after.\n*/ function showDialog(view, config) {\n    let resolve;\n    let promise = new Promise((r)=>resolve = r);\n    let panelCtor = (view)=>createDialog(view, config, resolve);\n    if (view.state.field(dialogField, false)) {\n        view.dispatch({\n            effects: openDialogEffect.of(panelCtor)\n        });\n    } else {\n        view.dispatch({\n            effects: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(dialogField.init(()=>[\n                    panelCtor\n                ]))\n        });\n    }\n    let close = closeDialogEffect.of(panelCtor);\n    return {\n        close,\n        result: promise.then((form)=>{\n            let queue = view.win.queueMicrotask || ((f)=>view.win.setTimeout(f, 10));\n            queue(()=>{\n                if (view.state.field(dialogField).indexOf(panelCtor) > -1) view.dispatch({\n                    effects: close\n                });\n            });\n            return form;\n        })\n    };\n}\n/**\nFind the [`Panel`](https://codemirror.net/6/docs/ref/#view.Panel) for an open dialog, using a class\nname as identifier.\n*/ function getDialog(view, className) {\n    let dialogs = view.state.field(dialogField, false) || [];\n    for (let open of dialogs){\n        let panel = getPanel(view, open);\n        if (panel && panel.dom.classList.contains(className)) return panel;\n    }\n    return null;\n}\nconst dialogField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return [];\n    },\n    update (dialogs, tr) {\n        for (let e of tr.effects){\n            if (e.is(openDialogEffect)) dialogs = [\n                e.value\n            ].concat(dialogs);\n            else if (e.is(closeDialogEffect)) dialogs = dialogs.filter((d)=>d != e.value);\n        }\n        return dialogs;\n    },\n    provide: (f)=>showPanel.computeN([\n            f\n        ], (state)=>state.field(f))\n});\nconst openDialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nconst closeDialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction createDialog(view, config, result) {\n    let content = config.content ? config.content(view, ()=>done(null)) : null;\n    if (!content) {\n        content = (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"form\");\n        if (config.input) {\n            let input = (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"input\", config.input);\n            if (/^(text|password|number|email|tel|url)$/.test(input.type)) input.classList.add(\"cm-textfield\");\n            if (!input.name) input.name = \"input\";\n            content.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"label\", (config.label || \"\") + \": \", input));\n        } else {\n            content.appendChild(document.createTextNode(config.label || \"\"));\n        }\n        content.appendChild(document.createTextNode(\" \"));\n        content.appendChild((0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"button\", {\n            class: \"cm-button\",\n            type: \"submit\"\n        }, config.submitLabel || \"OK\"));\n    }\n    let forms = content.nodeName == \"FORM\" ? [\n        content\n    ] : content.querySelectorAll(\"form\");\n    for(let i = 0; i < forms.length; i++){\n        let form = forms[i];\n        form.addEventListener(\"keydown\", (event)=>{\n            if (event.keyCode == 27) {\n                event.preventDefault();\n                done(null);\n            } else if (event.keyCode == 13) {\n                event.preventDefault();\n                done(form);\n            }\n        });\n        form.addEventListener(\"submit\", (event)=>{\n            event.preventDefault();\n            done(form);\n        });\n    }\n    let panel = (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"div\", content, (0,crelt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"button\", {\n        onclick: ()=>done(null),\n        \"aria-label\": view.state.phrase(\"close\"),\n        class: \"cm-dialog-close\",\n        type: \"button\"\n    }, [\n        \"\\xd7\"\n    ]));\n    if (config.class) panel.className = config.class;\n    panel.classList.add(\"cm-dialog\");\n    function done(form) {\n        if (panel.contains(panel.ownerDocument.activeElement)) view.focus();\n        result(form);\n    }\n    return {\n        dom: panel,\n        top: config.top,\n        mount: ()=>{\n            if (config.focus) {\n                let focus;\n                if (typeof config.focus == \"string\") focus = content.querySelector(config.focus);\n                else focus = content.querySelector(\"input\") || content.querySelector(\"button\");\n                if (focus && \"select\" in focus) focus.select();\n                else if (focus && \"focus\" in focus) focus.focus();\n            }\n        }\n    };\n}\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/ class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeValue {\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */ eq(other) {\n        return false;\n    }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */ destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/ const gutterLineClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet used to add a class to all gutter elements next to a widget.\nShould not provide widgets with a `toDOM` method.\n*/ const gutterWidgetClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: ()=>_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty,\n    lineMarker: ()=>null,\n    widgetMarker: ()=>null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {},\n    side: \"before\"\n};\nconst activeGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/ function gutter(config) {\n    return [\n        gutters(),\n        activeGutters.of({\n            ...defaults,\n            ...config\n        })\n    ];\n}\nconst unfixGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/ function gutters(config) {\n    let result = [\n        gutterView\n    ];\n    if (config && config.fixed === false) result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.domAfter = null;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters cm-gutters-before\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n        this.gutters = view.state.facet(activeGutters).map((conf)=>new SingleGutterView(view, conf));\n        this.fixed = !view.state.facet(unfixGutters);\n        for (let gutter of this.gutters){\n            if (gutter.config.side == \"after\") this.getDOMAfter().appendChild(gutter.dom);\n            else this.dom.appendChild(gutter.dom);\n        }\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    getDOMAfter() {\n        if (!this.domAfter) {\n            this.domAfter = document.createElement(\"div\");\n            this.domAfter.className = \"cm-gutters cm-gutters-after\";\n            this.domAfter.setAttribute(\"aria-hidden\", \"true\");\n            this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n            this.domAfter.style.position = this.fixed ? \"sticky\" : \"\";\n            this.view.scrollDOM.appendChild(this.domAfter);\n        }\n        return this.domAfter;\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged) {\n            let min = this.view.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.minHeight = min;\n            if (this.domAfter) this.domAfter.style.minHeight = min;\n        }\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n            if (this.domAfter) this.domAfter.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach) {\n            this.dom.remove();\n            if (this.domAfter) this.domAfter.remove();\n        }\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map((gutter)=>new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks){\n            if (classSet.length) classSet = [];\n            if (Array.isArray(line.type)) {\n                let first = true;\n                for (let b of line.type){\n                    if (b.type == BlockType.Text && first) {\n                        advanceCursor(lineClasses, classSet, b.from);\n                        for (let cx of contexts)cx.line(this.view, b, classSet);\n                        first = false;\n                    } else if (b.widget) {\n                        for (let cx of contexts)cx.widget(this.view, b);\n                    }\n                }\n            } else if (line.type == BlockType.Text) {\n                advanceCursor(lineClasses, classSet, line.from);\n                for (let cx of contexts)cx.line(this.view, line, classSet);\n            } else if (line.widget) {\n                for (let cx of contexts)cx.widget(this.view, line);\n            }\n        }\n        for (let cx of contexts)cx.finish();\n        if (detach) {\n            this.view.scrollDOM.insertBefore(this.dom, after);\n            if (this.domAfter) this.view.scrollDOM.appendChild(this.domAfter);\n        }\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)if (gutter.update(update)) change = true;\n        } else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur){\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                } else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters){\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0) g.destroy();\n            }\n            for (let g of gutters){\n                if (g.config.side == \"after\") this.getDOMAfter().appendChild(g.dom);\n                else this.dom.appendChild(g.dom);\n            }\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)view.destroy();\n        this.dom.remove();\n        if (this.domAfter) this.domAfter.remove();\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            if (!value || value.gutters.length == 0 || !value.fixed) return null;\n            let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;\n            return view.textDirection == Direction.LTR ? {\n                left: before,\n                right: after\n            } : {\n                right: before,\n                left: after\n            };\n        })\n});\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\nfunction advanceCursor(cursor, collect, pos) {\n    while(cursor.value && cursor.from <= pos){\n        if (cursor.from == pos) collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height){\n        this.gutter = gutter;\n        this.height = height;\n        this.i = 0;\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    addElement(view, block, markers) {\n        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, height, above, markers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        } else {\n            gutter.elements[this.i].update(view, height, above, markers);\n        }\n        this.height = block.bottom;\n        this.i++;\n    }\n    line(view, line, extraMarkers) {\n        let localMarkers = [];\n        advanceCursor(this.cursor, localMarkers, line.from);\n        if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine) localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n        this.addElement(view, line, localMarkers);\n    }\n    widget(view, block) {\n        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [\n            marker\n        ] : null;\n        for (let cls of view.state.facet(gutterWidgetClass)){\n            let marker = cls(view, block.widget, block);\n            if (marker) (markers || (markers = [])).push(marker);\n        }\n        if (markers) this.addElement(view, block, markers);\n    }\n    finish() {\n        let gutter = this.gutter;\n        while(gutter.elements.length > this.i){\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config){\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for(let prop in config.domEventHandlers){\n            this.dom.addEventListener(prop, (event)=>{\n                let target = event.target, y;\n                if (target != this.dom && this.dom.contains(target)) {\n                    while(target.parentNode != this.dom)target = target.parentNode;\n                    let rect = target.getBoundingClientRect();\n                    y = (rect.top + rect.bottom) / 2;\n                } else {\n                    y = event.clientY;\n                }\n                let line = view.lineBlockAtHeight(y - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [\n                config.initialSpacer(view)\n            ]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [\n                updated\n            ]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers){\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutterElement\";\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height) {\n            this.height = height;\n            this.dom.style.height = height + \"px\";\n        }\n        if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for(let iNew = 0, iOld = 0;;){\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c) cls += \" \" + c;\n                for(let i = iOld; i < this.markers.length; i++)if (this.markers[i].compare(marker)) {\n                    skipTo = i;\n                    matched = true;\n                    break;\n                }\n            } else {\n                skipTo = this.markers.length;\n            }\n            while(iOld < skipTo){\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker) break;\n            if (marker.toDOM) {\n                if (matched) domPos = domPos.nextSibling;\n                else this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched) iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].compare(b[i])) return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/ const lineNumberMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet used to create markers in the line number gutter next to widgets.\n*/ const lineNumberWidgetMarker = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, {\n            formatNumber: String,\n            domEventHandlers: {}\n        }, {\n            domEventHandlers (a, b) {\n                let result = Object.assign({}, a);\n                for(let event in b){\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event)=>exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number){\n        super();\n        this.number = number;\n    }\n    eq(other) {\n        return this.number == other.number;\n    }\n    toDOM() {\n        return document.createTextNode(this.number);\n    }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/ activeGutters.compute([\n    lineNumberConfig\n], (state)=>({\n        class: \"cm-lineNumbers\",\n        renderEmptyElements: false,\n        markers (view) {\n            return view.state.facet(lineNumberMarkers);\n        },\n        lineMarker (view, line, others) {\n            if (others.some((m)=>m.toDOM)) return null;\n            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n        },\n        widgetMarker: (view, widget, block)=>{\n            for (let m of view.state.facet(lineNumberWidgetMarker)){\n                let result = m(view, widget, block);\n                if (result) return result;\n            }\n            return null;\n        },\n        lineMarkerChange: (update)=>update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n        initialSpacer (view) {\n            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n        },\n        updateSpacer (spacer, update) {\n            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n            return max == spacer.number ? spacer : new NumberMarker(max);\n        },\n        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,\n        side: \"before\"\n    }));\n/**\nCreate a line number gutter extension.\n*/ function lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while(last < lines)last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/ new class extends GutterMarker {\n    constructor(){\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/ gutterLineClass.compute([\n    \"selection\"\n], (state)=>{\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges){\n        let linePos = state.doc.lineAt(range.head).from;\n        if (linePos > last) {\n            last = linePos;\n            marks.push(activeLineGutterMarker.range(linePos));\n        }\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/ function highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\nfunction matcher(decorator) {\n    return ViewPlugin.define((view)=>({\n            decorations: decorator.createDeco(view),\n            update (u) {\n                this.decorations = decorator.updateDeco(u, this.decorations);\n            }\n        }), {\n        decorations: (v)=>v.decorations\n    });\n}\nconst tabDeco = /*@__PURE__*/ Decoration.mark({\n    class: \"cm-highlightTab\"\n});\nconst spaceDeco = /*@__PURE__*/ Decoration.mark({\n    class: \"cm-highlightSpace\"\n});\nconst whitespaceHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\t| /g,\n    decoration: (match)=>match[0] == \"\t\" ? tabDeco : spaceDeco,\n    boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/ function highlightWhitespace() {\n    return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\s+$/g,\n    decoration: /*@__PURE__*/ Decoration.mark({\n        class: \"cm-trailingSpace\"\n    })\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/ function highlightTrailingWhitespace() {\n    return trailingHighlighter;\n}\n/**\n@internal\n*/ const __test = {\n    HeightMap,\n    HeightOracle,\n    MeasuredHeights,\n    QueryType,\n    ChangedRange,\n    computeOrder,\n    moveVisually,\n    clearHeightChangeFlag,\n    getHeightChangeFlag: ()=>heightChangeFlag\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3Irdmlld0A2LjM5LjExL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcVM7QUFDN1A7QUFDVztBQUMzQjtBQUV4QixJQUFJMEIsTUFBTSxPQUFPQyxhQUFhLGNBQWNBLFlBQVk7SUFBRUMsV0FBVztJQUFJQyxRQUFRO0lBQUlDLFVBQVU7QUFBRztBQUNsRyxJQUFJQyxNQUFNLE9BQU9DLFlBQVksY0FBY0EsV0FBVztJQUFFQyxpQkFBaUI7UUFBRUMsT0FBTyxDQUFDO0lBQUU7QUFBRTtBQUN2RixNQUFNQyxVQUFVLFdBQVcsR0FBRSxjQUFjQyxJQUFJLENBQUNWLElBQUlFLFNBQVM7QUFDN0QsTUFBTVMsWUFBWSxXQUFXLEdBQUUsVUFBVUMsSUFBSSxDQUFDWixJQUFJRSxTQUFTO0FBQzNELE1BQU1XLFVBQVUsV0FBVyxHQUFFLHdDQUF3Q0gsSUFBSSxDQUFDVixJQUFJRSxTQUFTO0FBQ3ZGLE1BQU1ZLEtBQUssQ0FBQyxDQUFFSCxDQUFBQSxhQUFhRSxXQUFXSixPQUFNO0FBQzVDLE1BQU1NLFFBQVEsQ0FBQ0QsTUFBTSxXQUFXLEdBQUUsZ0JBQWdCRixJQUFJLENBQUNaLElBQUlFLFNBQVM7QUFDcEUsTUFBTWMsU0FBUyxDQUFDRixNQUFNLFdBQVcsR0FBRSxnQkFBZ0JKLElBQUksQ0FBQ1YsSUFBSUUsU0FBUztBQUNyRSxNQUFNZSxTQUFTLHlCQUF5QlosSUFBSUUsZUFBZSxDQUFDQyxLQUFLO0FBQ2pFLE1BQU1VLFNBQVMsQ0FBQ0osTUFBTSxXQUFXLEdBQUUsaUJBQWlCRixJQUFJLENBQUNaLElBQUlHLE1BQU07QUFDbkUsTUFBTWdCLE1BQU1ELFVBQVcsV0FBVyxHQUFFLGVBQWNOLElBQUksQ0FBQ1osSUFBSUUsU0FBUyxLQUFL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R0FDQSxNQUFNRSxTQUFTO0lBQUVqMUI7SUFBV3BCO0lBQWNhO0lBQWlCSztJQUFXcHJCO0lBQWNsRztJQUNoRkc7SUFBY2d3QjtJQUF1QnUyQixxQkFBcUIsSUFBTXgyQjtBQUFpQjtBQUUyb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZW50aW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AY29kZW1pcnJvcit2aWV3QDYuMzkuMTEvbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3ZpZXcvZGlzdC9pbmRleC5qcz82M2E4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJhbmdlU2V0LCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBmaW5kQ2x1c3RlckJyZWFrLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBTdGF0ZUVmZmVjdCwgQ2hhbmdlU2V0LCBUZXh0LCBmaW5kQ29sdW1uLCBDaGFyQ2F0ZWdvcnksIEVkaXRvclN0YXRlLCBBbm5vdGF0aW9uLCBUcmFuc2FjdGlvbiwgUHJlYywgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFJhbmdlU2V0QnVpbGRlciwgY291bnRDb2x1bW4gfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5pbXBvcnQgeyBrZXlOYW1lLCBiYXNlLCBzaGlmdCB9IGZyb20gJ3czYy1rZXluYW1lJztcbmltcG9ydCBlbHQgZnJvbSAnY3JlbHQnO1xuXG5sZXQgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6IFwiXCIsIHZlbmRvcjogXCJcIiwgcGxhdGZvcm06IFwiXCIgfTtcbmxldCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogeyBkb2N1bWVudEVsZW1lbnQ6IHsgc3R5bGU6IHt9IH0gfTtcbmNvbnN0IGllX2VkZ2UgPSAvKkBfX1BVUkVfXyovL0VkZ2VcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvKkBfX1BVUkVfXyovL01TSUUgXFxkLy50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC8qQF9fUFVSRV9fKi8vVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgLypAX19QVVJFX18qLy9nZWNrb1xcLyhcXGQrKS9pLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhaWUgJiYgLypAX19QVVJFX18qLy9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCB3ZWJraXQgPSBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgc2FmYXJpID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC8qQF9fUFVSRV9fKi8vTW9iaWxlXFwvXFx3Ky8udGVzdChuYXYudXNlckFnZW50KSB8fCBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbnZhciBicm93c2VyID0ge1xuICAgIG1hYzogaW9zIHx8IC8qQF9fUFVSRV9fKi8vTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgd2luZG93czogLypAX19QVVJFX18qLy9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBsaW51eDogLypAX19QVVJFX18qLy9MaW51eHxYMTEvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBpZSxcbiAgICBpZV92ZXJzaW9uOiBpZV91cHRvMTAgPyBkb2MuZG9jdW1lbnRNb2RlIHx8IDYgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwLFxuICAgIGdlY2tvLFxuICAgIGdlY2tvX3ZlcnNpb246IGdlY2tvID8gKygvKkBfX1BVUkVfXyovL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgY2hyb21lOiAhIWNocm9tZSxcbiAgICBjaHJvbWVfdmVyc2lvbjogY2hyb21lID8gK2Nocm9tZVsxXSA6IDAsXG4gICAgaW9zLFxuICAgIGFuZHJvaWQ6IC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXYudXNlckFnZW50KSxcbiAgICB3ZWJraXQsXG4gICAgd2Via2l0X3ZlcnNpb246IHdlYmtpdCA/ICsoLypAX19QVVJFX18qLy9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICBzYWZhcmksXG4gICAgc2FmYXJpX3ZlcnNpb246IHNhZmFyaSA/ICsoLypAX19QVVJFX18qLy9cXGJWZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICB0YWJTaXplOiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRhYlNpemUgIT0gbnVsbCA/IFwidGFiLXNpemVcIiA6IFwiLW1vei10YWItc2l6ZVwiXG59O1xuXG5mdW5jdGlvbiBjb21iaW5lQXR0cnMoc291cmNlLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIgJiYgdGFyZ2V0LmNsYXNzKVxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzICs9IFwiIFwiICsgc291cmNlLmNsYXNzO1xuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiB0YXJnZXQuc3R5bGUpXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUgKz0gXCI7XCIgKyBzb3VyY2Uuc3R5bGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNvbnN0IG5vQXR0cnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGF0dHJzRXEoYSwgYiwgaWdub3JlKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhKVxuICAgICAgICBhID0gbm9BdHRycztcbiAgICBpZiAoIWIpXG4gICAgICAgIGIgPSBub0F0dHJzO1xuICAgIGxldCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpLCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrZXlzQS5sZW5ndGggLSAoaWdub3JlICYmIGtleXNBLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApICE9XG4gICAgICAgIGtleXNCLmxlbmd0aCAtIChpZ25vcmUgJiYga2V5c0IuaW5kZXhPZihpZ25vcmUpID4gLTEgPyAxIDogMCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleSAhPSBpZ25vcmUgJiYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2V0QXR0cnMoZG9tLCBhdHRycykge1xuICAgIGZvciAobGV0IGkgPSBkb20uYXR0cmlidXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgbmFtZSA9IGRvbS5hdHRyaWJ1dGVzW2ldLm5hbWU7XG4gICAgICAgIGlmIChhdHRyc1tuYW1lXSA9PSBudWxsKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcbiAgICAgICAgZWxzZSBpZiAoZG9tLmdldEF0dHJpYnV0ZShuYW1lKSAhPSB2YWx1ZSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKGRvbSwgcHJldiwgYXR0cnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHIgPSBkb20uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbn1cblxuLyoqXG5XaWRnZXRzIGFkZGVkIHRvIHRoZSBjb250ZW50IGFyZSBkZXNjcmliZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXG5kZWxheSBjcmVhdGluZyBvZiB0aGUgRE9NIHN0cnVjdHVyZSBmb3IgYSB3aWRnZXQgdW50aWwgaXQgaXNcbm5lZWRlZCwgYW5kIHRvIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIGV2ZW4gaWYgdGhlIGRlY29yYXRpb25zXG50aGF0IGRlZmluZSB0aGVtIGFyZSByZWNyZWF0ZWQuXG4qL1xuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGluc3RhbmNlIHRvIGFub3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAoVHlwZVNjcmlwdCBjYW4ndCBleHByZXNzIHRoaXMsIGJ1dCBvbmx5IGluc3RhbmNlcyBvZiB0aGUgc2FtZVxuICAgIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLikgVGhpcyBpcyB1c2VkIHRvXG4gICAgYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgd2hlbiB0aGV5IGFyZSByZXBsYWNlZCBieSBhIG5ld1xuICAgIGRlY29yYXRpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdFxuICAgIHJldHVybnMgYGZhbHNlYCwgd2hpY2ggd2lsbCBjYXVzZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB3aWRnZXQgdG9cbiAgICBhbHdheXMgYmUgcmVkcmF3bi5cbiAgICAqL1xuICAgIGVxKHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IGEgd2lkZ2V0IG9mIHRoZSBzYW1lIHR5cGUgKGJ1dFxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxuICAgIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gICAgY291bGRuJ3QgKGluIHdoaWNoIGNhc2UgdGhlIHdpZGdldCB3aWxsIGJlIHJlZHJhd24pLiBUaGUgZGVmYXVsdFxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cbiAgICAqL1xuICAgIHVwZGF0ZURPTShkb20sIHZpZXcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gICAgZXN0aW1hdGluZyB0aGUgaGVpZ2h0IG9mIGNvbnRlbnQgdGhhdCBoYXNuJ3QgYmVlbiBkcmF3bi4gTWF5XG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybnMgLTEuXG4gICAgKi9cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cbiAgICAvKipcbiAgICBGb3IgaW5saW5lIHdpZGdldHMgdGhhdCBhcmUgZGlzcGxheWVkIGlubGluZSAoYXMgb3Bwb3NlZCB0b1xuICAgIGBpbmxpbmUtYmxvY2tgKSBhbmQgaW50cm9kdWNlIGxpbmUgYnJlYWtzICh0aHJvdWdoIGA8YnI+YCB0YWdzXG4gICAgb3IgdGV4dHVhbCBuZXdsaW5lcyksIHRoaXMgbXVzdCBpbmRpY2F0ZSB0aGUgYW1vdW50IG9mIGxpbmVcbiAgICBicmVha3MgdGhleSBpbnRyb2R1Y2UuIERlZmF1bHRzIHRvIDAuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrcygpIHsgcmV0dXJuIDA7IH1cbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxuICAgIGV2ZW50cy5cbiAgICAqL1xuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG4gICAgLyoqXG4gICAgT3ZlcnJpZGUgdGhlIHdheSBzY3JlZW4gY29vcmRpbmF0ZXMgZm9yIHBvc2l0aW9ucyBhdC9pbiB0aGVcbiAgICB3aWRnZXQgYXJlIGZvdW5kLiBgcG9zYCB3aWxsIGJlIHRoZSBvZmZzZXQgaW50byB0aGUgd2lkZ2V0LCBhbmRcbiAgICBgc2lkZWAgdGhlIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgcXVlcmllZOKAlGxlc3MgdGhhblxuICAgIHplcm8gZm9yIGJlZm9yZSwgZ3JlYXRlciB0aGFuIHplcm8gZm9yIGFmdGVyLCBhbmQgemVybyBmb3JcbiAgICBkaXJlY3RseSBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICovXG4gICAgY29vcmRzQXQoZG9tLCBwb3MsIHNpZGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGFuIGluc3RhbmNlIG9mIHRoZSB3aWRnZXQgaXMgcmVtb3ZlZFxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG52YXIgQmxvY2tUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2l0aFxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxuICAgIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgICBvZiBsb3dlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggZGlzcGxheXMgYSBET00gZWxlbWVudCBhdCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQoc3BlYykge1xuICAgICAgICBsZXQgc2lkZSA9IE1hdGgubWF4KC0xMDAwMCwgTWF0aC5taW4oMTAwMDAsIHNwZWMuc2lkZSB8fCAwKSksIGJsb2NrID0gISFzcGVjLmJsb2NrO1xuICAgICAgICBzaWRlICs9IChibG9jayAmJiAhc3BlYy5pbmxpbmVPcmRlcilcbiAgICAgICAgICAgID8gKHNpZGUgPiAwID8gMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tBZnRlciAqLyA6IC00MDAwMDAwMDAgLyogU2lkZS5CbG9ja0JlZm9yZSAqLylcbiAgICAgICAgICAgIDogKHNpZGUgPiAwID8gMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQWZ0ZXIgKi8gOiAtMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XG4gICAgICAgIGlmIChzcGVjLmlzQmxvY2tHYXApIHtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IC01MDAwMDAwMDAgLyogU2lkZS5HYXBTdGFydCAqLztcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gKHN0YXJ0ID8gKGJsb2NrID8gLTMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovKSA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovKSAtIDE7XG4gICAgICAgICAgICBlbmRTaWRlID0gKGVuZCA/IChibG9jayA/IDIwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jRW5kICovIDogMSAvKiBTaWRlLklubGluZUluY0VuZCAqLykgOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSBSYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHNwZWMudGFnTmFtZSB8fCBcInNwYW5cIjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuY2xhc3MgJiYgc3BlYy5hdHRyaWJ1dGVzID8gY29tYmluZUF0dHJzKHNwZWMuYXR0cmlidXRlcywgeyBjbGFzczogc3BlYy5jbGFzcyB9KVxuICAgICAgICAgICAgOiBzcGVjLmNsYXNzID8geyBjbGFzczogc3BlYy5jbGFzcyB9IDogc3BlYy5hdHRyaWJ1dGVzIHx8IG5vQXR0cnM7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IG90aGVyIGluc3RhbmNlb2YgTWFya0RlY29yYXRpb24gJiYgdGhpcy50YWdOYW1lID09IG90aGVyLnRhZ05hbWUgJiYgYXR0cnNFcSh0aGlzLmF0dHJzLCBvdGhlci5hdHRycyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA+PSB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFyayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbk1hcmtEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuY2xhc3MgTGluZURlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCAtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgbnVsbCwgc3BlYyk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB0aGlzLnNwZWMuY2xhc3MgPT0gb3RoZXIuc3BlYy5jbGFzcyAmJlxuICAgICAgICAgICAgYXR0cnNFcSh0aGlzLnNwZWMuYXR0cmlidXRlcywgb3RoZXIuc3BlYy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuTGluZURlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmNsYXNzIFBvaW50RGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0U2lkZSwgZW5kU2lkZSwgd2lkZ2V0LCBzcGVjKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcbiAgICAgICAgdGhpcy5tYXBNb2RlID0gIWJsb2NrID8gTWFwTW9kZS5UcmFja0RlbCA6IHN0YXJ0U2lkZSA8PSAwID8gTWFwTW9kZS5UcmFja0JlZm9yZSA6IE1hcE1vZGUuVHJhY2tBZnRlcjtcbiAgICB9XG4gICAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNpZGUgIT0gdGhpcy5lbmRTaWRlID8gQmxvY2tUeXBlLldpZGdldFJhbmdlXG4gICAgICAgICAgICA6IHRoaXMuc3RhcnRTaWRlIDw9IDAgPyBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlIDogQmxvY2tUeXBlLldpZGdldEFmdGVyO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgKHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+PSA1IHx8IHRoaXMud2lkZ2V0LmxpbmVCcmVha3MgPiAwKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB3aWRnZXRzRXEodGhpcy53aWRnZXQsIG90aGVyLndpZGdldCkgJiZcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPT0gb3RoZXIuYmxvY2sgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaWRlID09IG90aGVyLnN0YXJ0U2lkZSAmJiB0aGlzLmVuZFNpZGUgPT0gb3RoZXIuZW5kU2lkZTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVwbGFjZSAmJiAoZnJvbSA+IHRvIHx8IChmcm9tID09IHRvICYmIHRoaXMuc3RhcnRTaWRlID4gMCAmJiB0aGlzLmVuZFNpZGUgPD0gMCkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHJhbmdlIGZvciByZXBsYWNlbWVudCBkZWNvcmF0aW9uXCIpO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZXBsYWNlICYmIHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldpZGdldCBkZWNvcmF0aW9ucyBjYW4gb25seSBoYXZlIHplcm8tbGVuZ3RoIHJhbmdlc1wiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5Qb2ludERlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmZ1bmN0aW9uIGdldEluY2x1c2l2ZShzcGVjLCBibG9jayA9IGZhbHNlKSB7XG4gICAgbGV0IHsgaW5jbHVzaXZlU3RhcnQ6IHN0YXJ0LCBpbmNsdXNpdmVFbmQ6IGVuZCB9ID0gc3BlYztcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgc3RhcnQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICBpZiAoZW5kID09IG51bGwpXG4gICAgICAgIGVuZCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gdm9pZCAwID8gc3RhcnQgOiBibG9jaywgZW5kOiBlbmQgIT09IG51bGwgJiYgZW5kICE9PSB2b2lkIDAgPyBlbmQgOiBibG9jayB9O1xufVxuZnVuY3Rpb24gd2lkZ2V0c0VxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8ICEhKGEgJiYgYiAmJiBhLmNvbXBhcmUoYikpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoZnJvbSwgdG8sIHJhbmdlcywgbWFyZ2luID0gMCkge1xuICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0gKyBtYXJnaW4gPj0gZnJvbSlcbiAgICAgICAgcmFuZ2VzW2xhc3RdID0gTWF0aC5tYXgocmFuZ2VzW2xhc3RdLCB0byk7XG4gICAgZWxzZVxuICAgICAgICByYW5nZXMucHVzaChmcm9tLCB0byk7XG59XG4vKipcbkEgYmxvY2sgd3JhcHBlciBkZWZpbmVzIGEgRE9NIG5vZGUgdGhhdCB3cmFwcyBsaW5lcyBvciBvdGhlciBibG9ja1xud3JhcHBlcnMgYXQgdGhlIHRvcCBvZiB0aGUgZG9jdW1lbnQuIEl0IGFmZmVjdHMgYW55IGxpbmUgb3IgYmxvY2tcbndpZGdldCB0aGF0IHN0YXJ0cyBpbnNpZGUgaXRzIHJhbmdlLCBpbmNsdWRpbmcgYmxvY2tzIHN0YXJ0aW5nXG5kaXJlY3RseSBhdCBgZnJvbWAgYnV0IG5vdCBpbmNsdWRpbmcgYHRvYC5cbiovXG5jbGFzcyBCbG9ja1dyYXBwZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciA9PSB0aGlzIHx8XG4gICAgICAgICAgICBvdGhlciBpbnN0YW5jZW9mIEJsb2NrV3JhcHBlciAmJiB0aGlzLnRhZ05hbWUgPT0gb3RoZXIudGFnTmFtZSAmJiBhdHRyc0VxKHRoaXMuYXR0cmlidXRlcywgb3RoZXIuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGJsb2NrIHdyYXBwZXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHRhZyBuYW1lIGFuZFxuICAgIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1dyYXBwZXIoc3BlYy50YWdOYW1lLCBzcGVjLmF0dHJpYnV0ZXMgfHwgbm9BdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmcm9tIHRoZSBnaXZlbiBibG9jayB3cmFwcGVyIHJhbmdlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXQob2YsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VTZXQub2Yob2YsIHNvcnQpO1xuICAgIH1cbn1cbkJsb2NrV3JhcHBlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gQmxvY2tXcmFwcGVyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihyb290KSB7XG4gICAgbGV0IHRhcmdldDtcbiAgICAvLyBCcm93c2VycyBkaWZmZXIgb24gd2hldGhlciBzaGFkb3cgcm9vdHMgaGF2ZSBhIGdldFNlbGVjdGlvblxuICAgIC8vIG1ldGhvZC4gSWYgaXQgZXhpc3RzLCB1c2UgdGhhdCwgb3RoZXJ3aXNlLCBjYWxsIGl0IG9uIHRoZVxuICAgIC8vIGRvY3VtZW50LlxuICAgIGlmIChyb290Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgIHRhcmdldCA9IHJvb3QuZ2V0U2VsZWN0aW9uID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuZ2V0U2VsZWN0aW9uKCk7XG59XG5mdW5jdGlvbiBjb250YWlucyhkb20sIG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IGRvbSA9PSBub2RlIHx8IGRvbS5jb250YWlucyhub2RlLm5vZGVUeXBlICE9IDEgPyBub2RlLnBhcmVudE5vZGUgOiBub2RlKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKGRvbSwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gY29udGFpbnMoZG9tLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0c0Zvcihkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2UoZG9tLCAwLCBkb20ubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGRvbS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFtdO1xufVxuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuZnVuY3Rpb24gaXNFcXVpdmFsZW50UG9zaXRpb24obm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSA/IChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkb21JbmRleChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Jsb2NrRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAvXihESVZ8UHxMSXxVTHxPTHxCTE9DS1FVT1RFfEREfERUfEhcXGR8U0VDVElPTnxQUkUpJC8udGVzdChub2RlLm5vZGVOYW1lKTtcbn1cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbWF4T2Zmc2V0KG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbWF4T2Zmc2V0KG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1heE9mZnNldChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBmbGF0dGVuUmVjdChyZWN0LCBsZWZ0KSB7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyBsZWZ0OiB4LCByaWdodDogeCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSB9O1xufVxuZnVuY3Rpb24gd2luZG93UmVjdCh3aW4pIHtcbiAgICBsZXQgdnAgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gICAgaWYgKHZwKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogMCwgcmlnaHQ6IHZwLndpZHRoLFxuICAgICAgICAgICAgdG9wOiAwLCBib3R0b206IHZwLmhlaWdodFxuICAgICAgICB9O1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGUoZWx0LCByZWN0KSB7XG4gICAgbGV0IHNjYWxlWCA9IHJlY3Qud2lkdGggLyBlbHQub2Zmc2V0V2lkdGg7XG4gICAgbGV0IHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gZWx0Lm9mZnNldEhlaWdodDtcbiAgICBpZiAoc2NhbGVYID4gMC45OTUgJiYgc2NhbGVYIDwgMS4wMDUgfHwgIWlzRmluaXRlKHNjYWxlWCkgfHwgTWF0aC5hYnMocmVjdC53aWR0aCAtIGVsdC5vZmZzZXRXaWR0aCkgPCAxKVxuICAgICAgICBzY2FsZVggPSAxO1xuICAgIGlmIChzY2FsZVkgPiAwLjk5NSAmJiBzY2FsZVkgPCAxLjAwNSB8fCAhaXNGaW5pdGUoc2NhbGVZKSB8fCBNYXRoLmFicyhyZWN0LmhlaWdodCAtIGVsdC5vZmZzZXRIZWlnaHQpIDwgMSlcbiAgICAgICAgc2NhbGVZID0gMTtcbiAgICByZXR1cm4geyBzY2FsZVgsIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KGRvbSwgcmVjdCwgc2lkZSwgeCwgeSwgeE1hcmdpbiwgeU1hcmdpbiwgbHRyKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbSwgc3RvcCA9IGZhbHNlOyBjdXIgJiYgIXN0b3A7KSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSkgeyAvLyBFbGVtZW50XG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcbiAgICAgICAgICAgIGxldCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxO1xuICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0gd2luZG93UmVjdCh3aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KGdldENvbXB1dGVkU3R5bGUoY3VyKS5wb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IGdldFNjYWxlKGN1ciwgcmVjdCkpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAoeSA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QudG9wIC0gKGJvdW5kaW5nLnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC50b3AgLSAoYm91bmRpbmcudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wLCBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgeSA9PSBcInN0YXJ0XCIgfHwgeSA9PSBcImNlbnRlclwiICYmIHNpZGUgPCAwID8gcmVjdC50b3AgLSB5TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuYm90dG9tIC0gYm91bmRpbmdIZWlnaHQgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QubGVmdCAtIChib3VuZGluZy5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5sZWZ0IC0gKGJvdW5kaW5nLmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAoeCA9PSBcInN0YXJ0XCIpID09IGx0ciA/IHJlY3QubGVmdCAtIHhNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5yaWdodCAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3ZlZFggPSAwLCBtb3ZlZFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wICs9IG1vdmVZIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRZID0gKGN1ci5zY3JvbGxUb3AgLSBzdGFydCkgKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYIC8gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gKGN1ci5zY3JvbGxMZWZ0IC0gc3RhcnQpICogc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIG1vdmVkWCwgdG9wOiByZWN0LnRvcCAtIG1vdmVkWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gbW92ZWRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gbW92ZWRZIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFggJiYgTWF0aC5hYnMobW92ZWRYIC0gbW92ZVgpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWSAmJiBNYXRoLmFicyhtb3ZlZFkgLSBtb3ZlWSkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgfHwgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICByZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0IHx8IHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodClcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIGJvdW5kaW5nLmxlZnQpLCByaWdodDogTWF0aC5taW4ocmVjdC5yaWdodCwgYm91bmRpbmcucmlnaHQpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QudG9wLCBib3VuZGluZy50b3ApLCBib3R0b206IE1hdGgubWluKHJlY3QuYm90dG9tLCBib3VuZGluZy5ib3R0b20pIH07XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkgeyAvLyBBIHNoYWRvdyByb290XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsYWJsZVBhcmVudHMoZG9tKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB4LCB5O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbS5wYXJlbnROb2RlOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gZG9jLmJvZHkgfHwgKHggJiYgeSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoIXkgJiYgY3VyLnNjcm9sbEhlaWdodCA+IGN1ci5jbGllbnRIZWlnaHQpXG4gICAgICAgICAgICAgICAgeSA9IGN1cjtcbiAgICAgICAgICAgIGlmICgheCAmJiBjdXIuc2Nyb2xsV2lkdGggPiBjdXIuY2xpZW50V2lkdGgpXG4gICAgICAgICAgICAgICAgeCA9IGN1cjtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHkgfTtcbn1cbmNsYXNzIERPTVNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlcShkb21TZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yTm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiB0aGlzLmFuY2hvck9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLmZvY3VzTm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIHRoaXMuZm9jdXNPZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBhbmNob3JOb2RlLCBmb2N1c05vZGUgfSA9IHJhbmdlO1xuICAgICAgICAvLyBDbGlwIG9mZnNldHMgdG8gbm9kZSBzaXplIHRvIGF2b2lkIGNyYXNoZXMgd2hlbiBTYWZhcmkgcmVwb3J0cyBib2d1cyBvZmZzZXRzICgjMTE1MilcbiAgICAgICAgdGhpcy5zZXQoYW5jaG9yTm9kZSwgTWF0aC5taW4ocmFuZ2UuYW5jaG9yT2Zmc2V0LCBhbmNob3JOb2RlID8gbWF4T2Zmc2V0KGFuY2hvck5vZGUpIDogMCksIGZvY3VzTm9kZSwgTWF0aC5taW4ocmFuZ2UuZm9jdXNPZmZzZXQsIGZvY3VzTm9kZSA/IG1heE9mZnNldChmb2N1c05vZGUpIDogMCkpO1xuICAgIH1cbiAgICBzZXQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIFNhZmFyaSAyNiBicmVha3MgcHJldmVudFNjcm9sbCBzdXBwb3J0XG5pZiAoYnJvd3Nlci5zYWZhcmkgJiYgYnJvd3Nlci5zYWZhcmlfdmVyc2lvbiA+PSAyNilcbiAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY3VyLCBjdXIuc2Nyb2xsVG9wLCBjdXIuc2Nyb2xsTGVmdCk7XG4gICAgICAgIGlmIChjdXIgPT0gY3VyLm93bmVyRG9jdW1lbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHN0YWNrW2krK10sIHRvcCA9IHN0YWNrW2krK10sIGxlZnQgPSBzdGFja1tpKytdO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxUb3AgIT0gdG9wKVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgc2NyYXRjaFJhbmdlO1xuZnVuY3Rpb24gdGV4dFJhbmdlKG5vZGUsIGZyb20sIHRvID0gZnJvbSkge1xuICAgIGxldCByYW5nZSA9IHNjcmF0Y2hSYW5nZSB8fCAoc2NyYXRjaFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEtleShlbHQsIG5hbWUsIGNvZGUsIG1vZHMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHsga2V5OiBuYW1lLCBjb2RlOiBuYW1lLCBrZXlDb2RlOiBjb2RlLCB3aGljaDogY29kZSwgY2FuY2VsYWJsZTogdHJ1ZSB9O1xuICAgIGlmIChtb2RzKVxuICAgICAgICAoeyBhbHRLZXk6IG9wdGlvbnMuYWx0S2V5LCBjdHJsS2V5OiBvcHRpb25zLmN0cmxLZXksIHNoaWZ0S2V5OiBvcHRpb25zLnNoaWZ0S2V5LCBtZXRhS2V5OiBvcHRpb25zLm1ldGFLZXkgfSA9IG1vZHMpO1xuICAgIGxldCBkb3duID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIG9wdGlvbnMpO1xuICAgIGRvd24uc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudChkb3duKTtcbiAgICBsZXQgdXAgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleXVwXCIsIG9wdGlvbnMpO1xuICAgIHVwLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQodXApO1xuICAgIHJldHVybiBkb3duLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdXAuZGVmYXVsdFByZXZlbnRlZDtcbn1cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLm5vZGVUeXBlID09IDkgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSAmJiBub2RlLmhvc3QpKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXRFbGVtZW50U3RhcnQoZG9jLCBzZWxlY3Rpb24pIHtcbiAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsIG9mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ICE9IG9mZnNldClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFNhZmFyaSBjYW4gcmVwb3J0IGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KG5vZGUpKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgPT0gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRUb0JvdHRvbShlbHQpIHtcbiAgICByZXR1cm4gZWx0LnNjcm9sbFRvcCA+IE1hdGgubWF4KDEsIGVsdC5zY3JvbGxIZWlnaHQgLSBlbHQuY2xpZW50SGVpZ2h0IC0gNCk7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZShzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaXNCbG9ja0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlcihzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgb2Zmc2V0OiBvZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFpc0Jsb2NrRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cblxuLyoqXG5Vc2VkIHRvIGluZGljYXRlIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4qL1xudmFyIERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIC8vIChUaGVzZSBhcmUgY2hvc2VuIHRvIG1hdGNoIHRoZSBiYXNlIGxldmVscywgaW4gYmlkaSBhbGdvcml0aG1cbiAgICAvLyB0ZXJtcywgb2Ygc3BhbnMgaW4gdGhhdCBkaXJlY3Rpb24uKVxuICAgIC8qKlxuICAgIExlZnQtdG8tcmlnaHQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xuICAgIC8qKlxuICAgIFJpZ2h0LXRvLWxlZnQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUlRMXCJdID0gMV0gPSBcIlJUTFwiO1xucmV0dXJuIERpcmVjdGlvbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbmNvbnN0IExUUiA9IERpcmVjdGlvbi5MVFIsIFJUTCA9IERpcmVjdGlvbi5SVEw7XG4vLyBEZWNvZGUgYSBzdHJpbmcgd2l0aCBlYWNoIHR5cGUgZW5jb2RlZCBhcyBsb2cyKHR5cGUpXG5mdW5jdGlvbiBkZWMoc3RyKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaCgxIDw8ICtzdHJbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGY4XG5jb25zdCBMb3dUeXBlcyA9IC8qQF9fUFVSRV9fKi9kZWMoXCI4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODY2Njg4ODg4ODc4NzgzMzMzMzMzMzMzNzg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4Nzg2NjY2ODg4ODA4ODg4ODY2MzM4MDg4ODMwODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOFwiKTtcbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuY29uc3QgQXJhYmljVHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcbmNvbnN0IEJyYWNrZXRzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCksIEJyYWNrZXRTdGFjayA9IFtdO1xuLy8gVGhlcmUncyBhIGxvdCBtb3JlIGluXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvQmlkaUJyYWNrZXRzLnR4dCxcbi8vIHdoaWNoIGFyZSBsZWZ0IG91dCB0byBrZWVwIGNvZGUgc2l6ZSBkb3duLlxuZm9yIChsZXQgcCBvZiBbXCIoKVwiLCBcIltdXCIsIFwie31cIl0pIHtcbiAgICBsZXQgbCA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMCksIHIgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDEpO1xuICAgIEJyYWNrZXRzW2xdID0gcjtcbiAgICBCcmFja2V0c1tyXSA9IC1sO1xufVxuZnVuY3Rpb24gY2hhclR5cGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPD0gMHhmNyA/IExvd1R5cGVzW2NoXSA6XG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBULlIgKi8gOlxuICAgICAgICAgICAgMHg2MDAgPD0gY2ggJiYgY2ggPD0gMHg2ZjkgPyBBcmFiaWNUeXBlc1tjaCAtIDB4NjAwXSA6XG4gICAgICAgICAgICAgICAgMHg2ZWUgPD0gY2ggJiYgY2ggPD0gMHg4YWMgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAweDIwMDAgPD0gY2ggJiYgY2ggPD0gMHgyMDBjID8gMjU2IC8qIFQuTkkgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgMHhmYjUwIDw9IGNoICYmIGNoIDw9IDB4ZmRmZiA/IDQgLyogVC5BTCAqLyA6IDEgLyogVC5MICovO1xufVxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLztcbi8qKlxuUmVwcmVzZW50cyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgdGV4dCB0aGF0IGhhcyBhIHNpbmdsZSBkaXJlY3Rpb25cbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxuKi9cbmNsYXNzIEJpZGlTcGFuIHtcbiAgICAvKipcbiAgICBUaGUgZGlyZWN0aW9uIG9mIHRoaXMgc3Bhbi5cbiAgICAqL1xuICAgIGdldCBkaXIoKSB7IHJldHVybiB0aGlzLmxldmVsICUgMiA/IFJUTCA6IExUUjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBzcGFuIChyZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgW1wiYmlkaVxuICAgIGxldmVsXCJdKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvI0Jhc2ljX0Rpc3BsYXlfQWxnb3JpdGhtKVxuICAgIG9mIHRoZSBzcGFuIChpbiB0aGlzIGNvbnRleHQsIDAgbWVhbnNcbiAgICBsZWZ0LXRvLXJpZ2h0LCAxIG1lYW5zIHJpZ2h0LXRvLWxlZnQsIDIgbWVhbnMgbGVmdC10by1yaWdodFxuICAgIG51bWJlciBpbnNpZGUgcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiAgICAqL1xuICAgIGxldmVsKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpZGUoZW5kLCBkaXIpIHsgcmV0dXJuICh0aGlzLmRpciA9PSBkaXIpID09IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcndhcmQoZm9yd2FyZCwgZGlyKSB7IHJldHVybiBmb3J3YXJkID09ICh0aGlzLmRpciA9PSBkaXIpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZChvcmRlciwgaW5kZXgsIGxldmVsLCBhc3NvYykge1xuICAgICAgICBsZXQgbWF5YmUgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gaW5kZXggJiYgc3Bhbi50byA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFuLmxldmVsID09IGxldmVsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG11bHRpcGxlIHNwYW5zIG1hdGNoLCBpZiBhc3NvYyAhPSAwLCB0YWtlIHRoZSBvbmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGNvdmVycyB0aGF0IHNpZGUsIG90aGVyd2lzZSB0YWtlIHRoZSBvbmUgd2l0aCB0aGUgbWluaW11bVxuICAgICAgICAgICAgICAgIC8vIGxldmVsLlxuICAgICAgICAgICAgICAgIGlmIChtYXliZSA8IDAgfHwgKGFzc29jICE9IDAgPyAoYXNzb2MgPCAwID8gc3Bhbi5mcm9tIDwgaW5kZXggOiBzcGFuLnRvID4gaW5kZXgpIDogb3JkZXJbbWF5YmVdLmxldmVsID4gc3Bhbi5sZXZlbCkpXG4gICAgICAgICAgICAgICAgICAgIG1heWJlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBtYXliZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc29sYXRlc0VxKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlBID0gYVtpXSwgaUIgPSBiW2ldO1xuICAgICAgICBpZiAoaUEuZnJvbSAhPSBpQi5mcm9tIHx8IGlBLnRvICE9IGlCLnRvIHx8IGlBLmRpcmVjdGlvbiAhPSBpQi5kaXJlY3Rpb24gfHwgIWlzb2xhdGVzRXEoaUEuaW5uZXIsIGlCLmlubmVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZXVzZWQgYXJyYXkgb2YgY2hhcmFjdGVyIHR5cGVzXG5jb25zdCB0eXBlcyA9IFtdO1xuLy8gRmlsbCBpbiB0aGUgY2hhcmFjdGVyIHR5cGVzIChpbiBgdHlwZXNgKSBmcm9tIGBmcm9tYCB0byBgdG9gIGFuZFxuLy8gYXBwbHkgVyBub3JtYWxpemF0aW9uIHJ1bGVzLlxuZnVuY3Rpb24gY29tcHV0ZUNoYXJUeXBlcyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICBsZXQgcHJldlR5cGUgPSBpSSA/IDI1NiAvKiBULk5JICovIDogb3V0ZXJUeXBlO1xuICAgICAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cbiAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgICAgLy8gbnVtYmVyLlxuICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4sIEFOLCBFVCwgQ1MsIE5JKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbSwgcHJldiA9IHByZXZUeXBlLCBwcmV2U3Ryb25nID0gcHJldlR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSA1MTIgLyogVC5OU00gKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgICAgICB0eXBlID0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZSA9PSA0IC8qIFQuQUwgKi8gPyAyIC8qIFQuUiAqLyA6IHR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgICAgICAvLyBOZXV0cmFsLlxuICAgICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDEyOCAvKiBULkNTICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0byAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBULk51bSAqLykpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBULkVUICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbmQgPCB0byAmJiB0eXBlc1tlbmRdID09IDY0IC8qIFQuRVQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gKGkgJiYgcHJldiA9PSA4IC8qIFQuRU4gKi8pIHx8IChlbmQgPCByVG8gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIFQuRU4gKi8pID8gKHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8gPyAxIC8qIFQuTCAqLyA6IDggLyogVC5FTiAqLykgOiAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gUHJvY2VzcyBicmFja2V0cyB0aHJvdWdob3V0IGEgcnVuIHNlcXVlbmNlLlxuZnVuY3Rpb24gcHJvY2Vzc0JyYWNrZXRQYWlycyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgbGV0IG9wcG9zaXRlVHlwZSA9IG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgZm9yIChsZXQgaUkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgICAgLy8gc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0IHBvc2l0aW9ucyBvZiB0aGVcbiAgICAgICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgICAgICAvLyBzY29wZSwgYmlkaXJlY3Rpb25hbCB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIGNoLCBiciwgdHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cbiAgICAgICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICAgICAgaWYgKGJyID0gQnJhY2tldHNbY2ggPSBsaW5lLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcmFja2V0U3RhY2tbc0ogKyAxXSA9PSAtYnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKSA/IG91dGVyVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZmxhZ3MgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSB0eXBlc1tCcmFja2V0U3RhY2tbc0pdXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCcmFja2V0U3RhY2subGVuZ3RoID09IDE4OSAvKiBCcmFja2V0ZWQuTWF4RGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9IHR5cGVzW2ldKSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGVtYmVkID8gMCA6IDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NOZXV0cmFscyhyRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cbiAgICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA9PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlzb2xhdGVzW2lJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW2VuZF0gPT0gMjU2IC8qIFQuTkkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZUwgPSBwcmV2ID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlckwgPSAoZW5kIDwgclRvID8gdHlwZXNbZW5kXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSBiZWZvcmVMID09IGFmdGVyTCA/IChiZWZvcmVMID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGVuZCwgakkgPSBpSSwgZnJvbUogPSBqSSA/IGlzb2xhdGVzW2pJIC0gMV0udG8gOiByRnJvbTsgaiA+IGk7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGZyb21KKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbLS1qXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBGaW5kIHRoZSBjb250aWd1b3VzIHJhbmdlcyBvZiBjaGFyYWN0ZXIgdHlwZXMgaW4gYSBnaXZlbiByYW5nZSwgYW5kXG4vLyBlbWl0IHNwYW5zIGZvciB0aGVtLiBGbGlwIHRoZSBvcmRlciBvZiB0aGUgc3BhbnMgYXMgYXBwcm9wcmlhdGVcbi8vIGJhc2VkIG9uIHRoZSBsZXZlbCwgYW5kIGNhbGwgdGhyb3VnaCB0byBjb21wdXRlIHRoZSBzcGFucyBmb3Jcbi8vIGlzb2xhdGVzIGF0IHRoZSBwcm9wZXIgcG9pbnQuXG5mdW5jdGlvbiBlbWl0U3BhbnMobGluZSwgZnJvbSwgdG8sIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBvcmRlcikge1xuICAgIGxldCBvdXJUeXBlID0gbGV2ZWwgJSAyID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBpZiAoKGxldmVsICUgMikgPT0gKGJhc2VMZXZlbCAlIDIpKSB7IC8vIFNhbWUgZGlyIGFzIGJhc2UgZGlyZWN0aW9uLCBkb24ndCBmbGlwXG4gICAgICAgIGZvciAobGV0IGlDaCA9IGZyb20sIGlJID0gMDsgaUNoIDwgdG87KSB7XG4gICAgICAgICAgICAvLyBTY2FuIGEgc2VjdGlvbiBvZiBjaGFyYWN0ZXJzIGluIGRpcmVjdGlvbiBvdXJUeXBlLCB1bmxlc3NcbiAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW5vdGhlciB0eXBlIG9mIGNoYXIgcmlnaHQgYWZ0ZXIgaUNoLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBzY2FuIGEgc2VjdGlvbiBvZiBvdGhlciBjaGFyYWN0ZXJzICh3aGljaCwgaWYgb3VyVHlwZSA9PVxuICAgICAgICAgICAgLy8gVC5MLCBtYXkgY29udGFpbiBib3RoIFQuUiBhbmQgVC5BTiBjaGFycykuXG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaUkgPT0gaXNvbGF0ZXMubGVuZ3RoIHx8IGlDaCA8IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2hdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb2xkcyBhbiBhcnJheSBvZiBpc29sYXRlcyB0byBwYXNzIHRvIGEgcmVjdXJzaXZlIGNhbGwgaWYgd2VcbiAgICAgICAgICAgIC8vIG11c3QgcmVjdXJzZSAodG8gZGlzdGluZ3Vpc2ggVC5BTiBpbnNpZGUgYW4gUlRMIHNlY3Rpb24gaW5cbiAgICAgICAgICAgIC8vIExUUiB0ZXh0KSwgbnVsbCBpZiB3ZSBjYW4gZW1pdCBkaXJlY3RseVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgPCBpc29sYXRlcy5sZW5ndGggJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUldLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNvID0gaXNvbGF0ZXNbaUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLnRvLCBqSSA9IGlJICsgMTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwdG8gPT0gdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgPCBpc29sYXRlcy5sZW5ndGggJiYgaXNvbGF0ZXNbakldLmZyb20gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzW2pJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW3VwdG9dID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpSSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLmZyb20gPiBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpc28uZnJvbSwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpclN3YXAgPSAoaXNvLmRpcmVjdGlvbiA9PSBMVFIpICE9ICEobG9jYWxMZXZlbCAlIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBkaXJTd2FwID8gbGV2ZWwgKyAxIDogbGV2ZWwsIGJhc2VMZXZlbCwgaXNvLmlubmVyLCBpc28uZnJvbSwgaXNvLnRvLCBvcmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpQ2ggPSBpc28udG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28udG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IHRvIHx8IChzYW1lRGlyID8gdHlwZXNbaVNjYW5dICE9IG91clR5cGUgOiB0eXBlc1tpU2Nhbl0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2NhbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpQ2gsIGlTY2FuLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaUNoIDwgaVNjYW4pXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpU2NhbiwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSB0byBmbGlwIHRoZSBzcGFuIG9yZGVyLiBTYW1lIGNvZGUgYWdhaW4sIGJ1dFxuICAgICAgICAvLyBnb2luZyBmcm9tIHRoZSBiYWNrIG9mIHRoZSBzZWN0aW9uIHRvIHRoZSBmcm9udFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSB0bywgaUkgPSBpc29sYXRlcy5sZW5ndGg7IGlDaCA+IGZyb207KSB7XG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlJIHx8IGlDaCA+IGlzb2xhdGVzW2lJIC0gMV0udG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHR5cGVzW2lDaCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVjdXJzZSA9ICFzYW1lRGlyICYmIG91clR5cGUgPT0gMSAvKiBULkwgKi8gPyBbXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbG9jYWxMZXZlbCA9IHNhbWVEaXIgPyBsZXZlbCA6IGxldmVsICsgMTtcbiAgICAgICAgICAgIGxldCBpU2NhbiA9IGlDaDtcbiAgICAgICAgICAgIHJ1bjogZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChpSSAmJiBpU2NhbiA9PSBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzWy0taUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLmZyb20sIGpJID0gaUk7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgJiYgaXNvbGF0ZXNbakkgLSAxXS50byA9PSB1cHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHRvID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvIC0gMV0gPT0gb3VyVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlLnB1c2goaXNvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc28udG8gPCBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaXNvLnRvLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28uZnJvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPT0gZnJvbSB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuIC0gMV0gIT0gb3VyVHlwZSA6IHR5cGVzW2lTY2FuIC0gMV0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2Nhbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpU2NhbiwgaUNoLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPCBpQ2gpXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaVNjYW4sIGlDaCwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBmcm9tLCB0bywgb3JkZXIpIHtcbiAgICBsZXQgb3V0ZXJUeXBlID0gKGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi8pO1xuICAgIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NOZXV0cmFscyhmcm9tLCB0bywgaXNvbGF0ZXMsIG91dGVyVHlwZSk7XG4gICAgZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGxpbmUsIGRpcmVjdGlvbiwgaXNvbGF0ZXMpIHtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIDAsIGRpcmVjdGlvbiA9PSBSVEwgPyAxIDogMCldO1xuICAgIGlmIChkaXJlY3Rpb24gPT0gTFRSICYmICFpc29sYXRlcy5sZW5ndGggJiYgIUJpZGlSRS50ZXN0KGxpbmUpKVxuICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICBpZiAoaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICB3aGlsZSAobGluZS5sZW5ndGggPiB0eXBlcy5sZW5ndGgpXG4gICAgICAgICAgICB0eXBlc1t0eXBlcy5sZW5ndGhdID0gMjU2IC8qIFQuTkkgKi87IC8vIE1ha2Ugc3VyZSB0eXBlcyBhcnJheSBoYXMgbm8gZ2Fwc1xuICAgIGxldCBvcmRlciA9IFtdLCBsZXZlbCA9IGRpcmVjdGlvbiA9PSBMVFIgPyAwIDogMTtcbiAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBsZXZlbCwgaXNvbGF0ZXMsIDAsIGxpbmUubGVuZ3RoLCBvcmRlcik7XG4gICAgcmV0dXJuIG9yZGVyO1xufVxuZnVuY3Rpb24gdHJpdmlhbE9yZGVyKGxlbmd0aCkge1xuICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIGxlbmd0aCwgMCldO1xufVxubGV0IG1vdmVkT3ZlciA9IFwiXCI7XG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG1vdmVzIHN0cmljdGx5IHZpc3VhbGx5LCB3aXRob3V0IGNvbmNlcm4gZm9yIGFcbi8vIHRyYXZlcnNhbCB2aXNpdGluZyBldmVyeSBsb2dpY2FsIHBvc2l0aW9uIGluIHRoZSBzdHJpbmcuIEl0IHdpbGxcbi8vIHN0aWxsIGRvIHNvIGZvciBzaW1wbGUgaW5wdXQsIGJ1dCBzaXR1YXRpb25zIGxpa2UgbXVsdGlwbGUgaXNvbGF0ZXNcbi8vIHdpdGggdGhlIHNhbWUgbGV2ZWwgbmV4dCB0byBlYWNoIG90aGVyLCBvciB0ZXh0IGdvaW5nIGFnYWluc3QgdGhlXG4vLyBtYWluIGRpciBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLCB3aWxsIG1ha2Ugc29tZSBwb3NpdGlvbnNcbi8vIHVucmVhY2hhYmxlIHdpdGggdGhpcyBtb3Rpb24uIEVhY2ggdmlzaWJsZSBjdXJzb3IgcG9zaXRpb24gd2lsbFxuLy8gY29ycmVzcG9uZCB0byB0aGUgbG93ZXItbGV2ZWwgYmlkaSBzcGFuIHRoYXQgdG91Y2hlcyBpdC5cbi8vXG4vLyBUaGUgYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8gc29sdmUgYW4gb3JkZXIgZ2xvYmFsbHkgZm9yIGEgZ2l2ZW5cbi8vIGxpbmUsIG1ha2luZyBzdXJlIHRoYXQgaXQgaW5jbHVkZXMgZXZlcnkgcG9zaXRpb24sIGJ1dCB0aGF0IHdvdWxkXG4vLyByZXF1aXJlIGFzc29jaWF0aW5nIG5vbi1jYW5vbmljYWwgKGhpZ2hlciBiaWRpIHNwYW4gbGV2ZWwpXG4vLyBwb3NpdGlvbnMgd2l0aCBhIGdpdmVuIHZpc3VhbCBwb3NpdGlvbiwgd2hpY2ggaXMgbGlrZWx5IHRvIGNvbmZ1c2Vcbi8vIHBlb3BsZS4gKEFuZCB3b3VsZCBnZW5lcmFsbHkgYmUgYSBsb3QgbW9yZSBjb21wbGljYXRlZC4pXG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgb3JkZXIsIGRpciwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5oZWFkIC0gbGluZS5mcm9tO1xuICAgIGxldCBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgc3BhbiA9IG9yZGVyW3NwYW5JXSwgc3BhbkVuZCA9IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpO1xuICAgIC8vIEVuZCBvZiBzcGFuXG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gc3BhbkVuZCkge1xuICAgICAgICBsZXQgbmV4dEkgPSBzcGFuSSArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICBpZiAobmV4dEkgPCAwIHx8IG5leHRJID49IG9yZGVyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBzcGFuID0gb3JkZXJbc3BhbkkgPSBuZXh0SV07XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzcGFuLnNpZGUoIWZvcndhcmQsIGRpcik7XG4gICAgICAgIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICB9XG4gICAgbGV0IG5leHRJbmRleCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBzdGFydEluZGV4LCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSk7XG4gICAgaWYgKG5leHRJbmRleCA8IHNwYW4uZnJvbSB8fCBuZXh0SW5kZXggPiBzcGFuLnRvKVxuICAgICAgICBuZXh0SW5kZXggPSBzcGFuRW5kO1xuICAgIG1vdmVkT3ZlciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihzdGFydEluZGV4LCBuZXh0SW5kZXgpLCBNYXRoLm1heChzdGFydEluZGV4LCBuZXh0SW5kZXgpKTtcbiAgICBsZXQgbmV4dFNwYW4gPSBzcGFuSSA9PSAoZm9yd2FyZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBvcmRlcltzcGFuSSArIChmb3J3YXJkID8gMSA6IC0xKV07XG4gICAgaWYgKG5leHRTcGFuICYmIG5leHRJbmRleCA9PSBzcGFuRW5kICYmIG5leHRTcGFuLmxldmVsICsgKGZvcndhcmQgPyAwIDogMSkgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBuZXh0U3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikgPyAxIDogLTEsIG5leHRTcGFuLmxldmVsKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0SW5kZXggKyBsaW5lLmZyb20sIHNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cbmZ1bmN0aW9uIGF1dG9EaXJlY3Rpb24odGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZSh0ZXh0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBpZiAodHlwZSA9PSAxIC8qIFQuTCAqLylcbiAgICAgICAgICAgIHJldHVybiBMVFI7XG4gICAgICAgIGlmICh0eXBlID09IDIgLyogVC5SICovIHx8IHR5cGUgPT0gNCAvKiBULkFMICovKVxuICAgICAgICAgICAgcmV0dXJuIFJUTDtcbiAgICB9XG4gICAgcmV0dXJuIExUUjtcbn1cblxuY29uc3QgY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkcmFnTW92ZXNTZWxlY3Rpb24kMSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IG1vdXNlU2VsZWN0aW9uU3R5bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBleGNlcHRpb25TaW5rID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdXBkYXRlTGlzdGVuZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmb2N1c0NoYW5nZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNsaXBib2FyZElucHV0RmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgY2xpcGJvYXJkT3V0cHV0RmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcGVyTGluZVRleHREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBuYXRpdmVTZWxlY3Rpb25IaWRkZW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG5jb25zdCBzY3JvbGxIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgU2Nyb2xsVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgeSA9IFwibmVhcmVzdFwiLCB4ID0gXCJuZWFyZXN0XCIsIHlNYXJnaW4gPSA1LCB4TWFyZ2luID0gNSwgXG4gICAgLy8gVGhpcyBkYXRhIHN0cnVjdHVyZSBpcyBhYnVzZWQgdG8gYWxzbyBzdG9yZSBwcmVjaXNlIHNjcm9sbFxuICAgIC8vIHNuYXBzaG90cywgaW5zdGVhZCBvZiBhIGBzY3JvbGxJbnRvVmlld2AgcmVxdWVzdC4gV2hlbiB0aGlzXG4gICAgLy8gZmxhZyBpcyBgdHJ1ZWAsIGByYW5nZWAgcG9pbnRzIGF0IGEgcG9zaXRpb24gaW4gdGhlIHJlZmVyZW5jZVxuICAgIC8vIGxpbmUsIGB5TWFyZ2luYCBob2xkcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhhdFxuICAgIC8vIGxpbmUgYW5kIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgYW5kIGB4TWFyZ2luYCBob2xkcyB0aGVcbiAgICAvLyBlZGl0b3IncyBgc2Nyb2xsTGVmdGAuXG4gICAgaXNTbmFwc2hvdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55TWFyZ2luID0geU1hcmdpbjtcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcbiAgICAgICAgdGhpcy5pc1NuYXBzaG90ID0gaXNTbmFwc2hvdDtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDpcbiAgICAgICAgICAgIG5ldyBTY3JvbGxUYXJnZXQodGhpcy5yYW5nZS5tYXAoY2hhbmdlcyksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG4gICAgY2xpcChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZS50byA8PSBzdGF0ZS5kb2MubGVuZ3RoID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgU2Nyb2xsVGFyZ2V0KEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhdGUuZG9jLmxlbmd0aCksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG59XG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6ICh0LCBjaCkgPT4gdC5tYXAoY2gpIH0pO1xuY29uc3Qgc2V0RWRpdENvbnRleHRGb3JtYXR0aW5nID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5Mb2cgb3IgcmVwb3J0IGFuIHVuaGFuZGxlZCBleGNlcHRpb24gaW4gY2xpZW50IGNvZGUuIFNob3VsZFxucHJvYmFibHkgb25seSBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBjb2RlIHRoYXQgYWxsb3dzIGNsaWVudCBjb2RlIHRvXG5wcm92aWRlIGZ1bmN0aW9ucywgYW5kIGNhbGxzIHRob3NlIGZ1bmN0aW9ucyBpbiBhIGNvbnRleHQgd2hlcmUgYW5cbmV4Y2VwdGlvbiBjYW4ndCBiZSBwcm9wYWdhdGVkIHRvIGNhbGxpbmcgY29kZSBpbiBhIHJlYXNvbmFibGUgd2F5XG4oZm9yIGV4YW1wbGUgd2hlbiBpbiBhbiBldmVudCBoYW5kbGVyKS5cblxuRWl0aGVyIGNhbGxzIGEgaGFuZGxlciByZWdpc3RlcmVkIHdpdGhcbltgRWRpdG9yVmlldy5leGNlcHRpb25TaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZXhjZXB0aW9uU2luayksXG5gd2luZG93Lm9uZXJyb3JgLCBpZiBkZWZpbmVkLCBvciBgY29uc29sZS5lcnJvcmAgKGluIHdoaWNoIGNhc2Vcbml0J2xsIHBhc3MgYGNvbnRleHRgLCB3aGVuIGdpdmVuLCBhcyBmaXJzdCBhcmd1bWVudCkuXG4qL1xuZnVuY3Rpb24gbG9nRXhjZXB0aW9uKHN0YXRlLCBleGNlcHRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgaGFuZGxlciA9IHN0YXRlLmZhY2V0KGV4Y2VwdGlvblNpbmspO1xuICAgIGlmIChoYW5kbGVyLmxlbmd0aClcbiAgICAgICAgaGFuZGxlclswXShleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yICYmIHdpbmRvdy5vbmVycm9yKFN0cmluZyhleGNlcHRpb24pLCBjb250ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXhjZXB0aW9uKSkgO1xuICAgIGVsc2UgaWYgKGNvbnRleHQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGV4dCArIFwiOlwiLCBleGNlcHRpb24pO1xuICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihleGNlcHRpb24pO1xufVxuY29uc3QgZWRpdGFibGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB0cnVlIH0pO1xubGV0IG5leHRQbHVnaW5JRCA9IDA7XG5jb25zdCB2aWV3UGx1Z2luID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShwbHVnaW5zKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW5zLmZpbHRlcigocCwgaSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbnNbal0ucGx1Z2luID09IHAucGx1Z2luKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblZpZXcgcGx1Z2lucyBhc3NvY2lhdGUgc3RhdGVmdWwgdmFsdWVzIHdpdGggYSB2aWV3LiBUaGV5IGNhblxuaW5mbHVlbmNlIHRoZSB3YXkgdGhlIGNvbnRlbnQgaXMgZHJhd24sIGFuZCBhcmUgbm90aWZpZWQgb2YgdGhpbmdzXG50aGF0IGhhcHBlbiBpbiB0aGUgdmlldy4gVGhleSBvcHRpb25hbGx5IHRha2UgYW4gYXJndW1lbnQsIGluXG53aGljaCBjYXNlIHlvdSBuZWVkIHRvIGNhbGwgW2BvZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luLm9mKSB0byBjcmVhdGVcbmFuIGV4dGVuc2lvbiBmb3IgdGhlIHBsdWdpbi4gV2hlbiB0aGUgYXJndW1lbnQgdHlwZSBpcyB1bmRlZmluZWQsXG55b3UgY2FuIHVzZSB0aGUgcGx1Z2luIGluc3RhbmNlIGFzIGFuIGV4dGVuc2lvbiBkaXJlY3RseS5cbiovXG5jbGFzcyBWaWV3UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudEhhbmRsZXJzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbUV2ZW50T2JzZXJ2ZXJzLCBidWlsZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgdGhpcy5kb21FdmVudEhhbmRsZXJzID0gZG9tRXZlbnRIYW5kbGVycztcbiAgICAgICAgdGhpcy5kb21FdmVudE9ic2VydmVycyA9IGRvbUV2ZW50T2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLmJhc2VFeHRlbnNpb25zID0gYnVpbGRFeHRlbnNpb25zKHRoaXMpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IHRoaXMuYmFzZUV4dGVuc2lvbnMuY29uY2F0KHZpZXdQbHVnaW4ub2YoeyBwbHVnaW46IHRoaXMsIGFyZzogdW5kZWZpbmVkIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgdGhpcyBwbHVnaW4gd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnQuXG4gICAgKi9cbiAgICBvZihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUV4dGVuc2lvbnMuY29uY2F0KHZpZXdQbHVnaW4ub2YoeyBwbHVnaW46IHRoaXMsIGFyZyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHBsdWdpbiBmcm9tIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZVxuICAgIHBsdWdpbidzIHZhbHVlLCBnaXZlbiBhbiBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY3JlYXRlLCBzcGVjKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRIYW5kbGVycywgZXZlbnRPYnNlcnZlcnMsIHByb3ZpZGUsIGRlY29yYXRpb25zOiBkZWNvIH0gPSBzcGVjIHx8IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdQbHVnaW4obmV4dFBsdWdpbklEKyssIGNyZWF0ZSwgZXZlbnRIYW5kbGVycywgZXZlbnRPYnNlcnZlcnMsIHBsdWdpbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXh0ID0gW107XG4gICAgICAgICAgICBpZiAoZGVjbylcbiAgICAgICAgICAgICAgICBleHQucHVzaChkZWNvcmF0aW9ucy5vZih2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbkluc3QgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luSW5zdCA/IGRlY28ocGx1Z2luSW5zdCkgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGUpXG4gICAgICAgICAgICAgICAgZXh0LnB1c2gocHJvdmlkZShwbHVnaW4pKTtcbiAgICAgICAgICAgIHJldHVybiBleHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4gZm9yIGEgY2xhc3Mgd2hvc2UgY29uc3RydWN0b3IgdGFrZXMgYSBzaW5nbGVcbiAgICBlZGl0b3IgdmlldyBhcyBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ2xhc3MoY2xzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgodmlldywgYXJnKSA9PiBuZXcgY2xzKHZpZXcsIGFyZyksIHNwZWMpO1xuICAgIH1cbn1cbmNsYXNzIFBsdWdpbkluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8vIFdoZW4gc3RhcnRpbmcgYW4gdXBkYXRlLCBhbGwgcGx1Z2lucyBoYXZlIHRoaXMgZmllbGQgc2V0IHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgb2JqZWN0LCBpbmRpY2F0aW5nIHRoZXkgbmVlZCB0byBiZSB1cGRhdGVkLiBXaGVuIGZpbmlzaGVkXG4gICAgICAgIC8vIHVwZGF0aW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgLiBSZXRyaWV2aW5nIGEgcGx1Z2luIHRoYXQgbmVlZHMgdG9cbiAgICAgICAgLy8gYmUgdXBkYXRlZCB3aXRoIGB2aWV3LnBsdWdpbmAgZm9yY2VzIGFuIGVhZ2VyIHVwZGF0ZS5cbiAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgLy8gVGhpcyBpcyBudWxsIHdoZW4gdGhlIHBsdWdpbiBpcyBpbml0aWFsbHkgY3JlYXRlZCwgYnV0XG4gICAgICAgIC8vIGluaXRpYWxpemVkIG9uIHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgcGx1Z2luKCkgeyByZXR1cm4gdGhpcy5zcGVjICYmIHRoaXMuc3BlYy5wbHVnaW47IH1cbiAgICB1cGRhdGUodmlldykge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zcGVjLnBsdWdpbi5jcmVhdGUodmlldywgdGhpcy5zcGVjLmFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGUgPSB0aGlzLm11c3RVcGRhdGU7XG4gICAgICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHVwZGF0ZS5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KHZpZXcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxufVxuY29uc3QgZWRpdG9yQXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNvbnRlbnRBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLy8gUHJvdmlkZSBkZWNvcmF0aW9uc1xuY29uc3QgZGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBibG9ja1dyYXBwZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3Qgb3V0ZXJEZWNvcmF0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGF0b21pY1JhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGJpZGlJc29sYXRlZFJhbmdlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGdldElzb2xhdGVkUmFuZ2VzKHZpZXcsIGxpbmUpIHtcbiAgICBsZXQgaXNvbGF0ZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGJpZGlJc29sYXRlZFJhbmdlcyk7XG4gICAgaWYgKCFpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBpc29sYXRlcztcbiAgICBsZXQgc2V0cyA9IGlzb2xhdGVzLm1hcChpID0+IGkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGkodmlldykgOiBpKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgUmFuZ2VTZXQuc3BhbnMoc2V0cywgbGluZS5mcm9tLCBsaW5lLnRvLCB7XG4gICAgICAgIHBvaW50KCkgeyB9LFxuICAgICAgICBzcGFuKGZyb21Eb2MsIHRvRG9jLCBhY3RpdmUsIG9wZW4pIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZnJvbURvYyAtIGxpbmUuZnJvbSwgdG8gPSB0b0RvYyAtIGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBhY3RpdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0sIG9wZW4tLSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBhY3RpdmVbaV0uc3BlYy5iaWRpSXNvbGF0ZSwgdXBkYXRlO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gYXV0b0RpcmVjdGlvbihsaW5lLnRleHQsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbiA+IDAgJiYgbGV2ZWwubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICh1cGRhdGUgPSBsZXZlbFtsZXZlbC5sZW5ndGggLSAxXSkudG8gPT0gZnJvbSAmJiB1cGRhdGUuZGlyZWN0aW9uID09IGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudG8gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSB1cGRhdGUuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0geyBmcm9tLCB0bywgZGlyZWN0aW9uLCBpbm5lcjogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwucHVzaChhZGQpO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGFkZC5pbm5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgc2Nyb2xsTWFyZ2lucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGdldFNjcm9sbE1hcmdpbnModmlldykge1xuICAgIGxldCBsZWZ0ID0gMCwgcmlnaHQgPSAwLCB0b3AgPSAwLCBib3R0b20gPSAwO1xuICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KHNjcm9sbE1hcmdpbnMpKSB7XG4gICAgICAgIGxldCBtID0gc291cmNlKHZpZXcpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgaWYgKG0ubGVmdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBtLmxlZnQpO1xuICAgICAgICAgICAgaWYgKG0ucmlnaHQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBtLnJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChtLnRvcCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgbS50b3ApO1xuICAgICAgICAgICAgaWYgKG0uYm90dG9tICE9IG51bGwpXG4gICAgICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYm90dG9tLCBtLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH07XG59XG5jb25zdCBzdHlsZU1vZHVsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIENoYW5nZWRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikge1xuICAgICAgICB0aGlzLmZyb21BID0gZnJvbUE7XG4gICAgICAgIHRoaXMudG9BID0gdG9BO1xuICAgICAgICB0aGlzLmZyb21CID0gZnJvbUI7XG4gICAgICAgIHRoaXMudG9CID0gdG9CO1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlZFJhbmdlKE1hdGgubWluKHRoaXMuZnJvbUEsIG90aGVyLmZyb21BKSwgTWF0aC5tYXgodGhpcy50b0EsIG90aGVyLnRvQSksIE1hdGgubWluKHRoaXMuZnJvbUIsIG90aGVyLmZyb21CKSwgTWF0aC5tYXgodGhpcy50b0IsIG90aGVyLnRvQikpO1xuICAgIH1cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGkgPSBzZXQubGVuZ3RoLCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBzZXRbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmZyb21BID4gbWUudG9BKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlLnRvQSA8IG1lLmZyb21BKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbWUgPSBtZS5qb2luKHJhbmdlKTtcbiAgICAgICAgICAgIHNldC5zcGxpY2UoaSAtIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5zcGxpY2UoaSwgMCwgbWUpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvLyBFeHRlbmQgYSBzZXQgdG8gY292ZXIgYWxsIHRoZSBjb250ZW50IGluIGByYW5nZXNgLCB3aGljaCBpcyBhXG4gICAgLy8gZmxhdCBhcnJheSB3aXRoIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBmcm9tQi90b0JcbiAgICAvLyBwb3NpdGlvbnMuIFRoZXNlIHBhaXJzIGFyZSBnZW5lcmF0ZWQgaW4gdW5jaGFuZ2VkIHJhbmdlcywgc28gdGhlXG4gICAgLy8gb2Zmc2V0IGJldHdlZW4gZG9jIEEgYW5kIGRvYyBCIGlzIHRoZSBzYW1lIGZvciB0aGVpciBzdGFydCBhbmRcbiAgICAvLyBlbmQgcG9pbnRzLlxuICAgIHN0YXRpYyBleHRlbmRXaXRoUmFuZ2VzKGRpZmYsIHJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIG9mZiA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHREID0gZEkgPCBkaWZmLmxlbmd0aCA/IGRpZmZbZEldLmZyb21CIDogMWU5O1xuICAgICAgICAgICAgbGV0IG5leHRSID0gckkgPCByYW5nZXMubGVuZ3RoID8gcmFuZ2VzW3JJXSA6IDFlOTtcbiAgICAgICAgICAgIGxldCBmcm9tQiA9IE1hdGgubWluKG5leHRELCBuZXh0Uik7XG4gICAgICAgICAgICBpZiAoZnJvbUIgPT0gMWU5KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGZyb21BID0gZnJvbUIgKyBvZmYsIHRvQiA9IGZyb21CLCB0b0EgPSBmcm9tQTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAockkgPCByYW5nZXMubGVuZ3RoICYmIHJhbmdlc1tySV0gPD0gdG9CKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbckkgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgckkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgdG9CID0gTWF0aC5tYXgodG9CLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZEk7IGkgPCBkaWZmLmxlbmd0aCAmJiBkaWZmW2ldLmZyb21CIDw9IHRvQjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmID0gZGlmZltpXS50b0EgLSBkaWZmW2ldLnRvQjtcbiAgICAgICAgICAgICAgICAgICAgdG9BID0gTWF0aC5tYXgodG9BLCBlbmQgKyBvZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkSSA8IGRpZmYubGVuZ3RoICYmIGRpZmZbZEldLmZyb21CIDw9IHRvQikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGRpZmZbZEkrK107XG4gICAgICAgICAgICAgICAgICAgIHRvQiA9IE1hdGgubWF4KHRvQiwgbmV4dC50b0IpO1xuICAgICAgICAgICAgICAgICAgICB0b0EgPSBNYXRoLm1heCh0b0EsIG5leHQudG9BKTtcbiAgICAgICAgICAgICAgICAgICAgb2ZmID0gbmV4dC50b0EgLSBuZXh0LnRvQjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5WaWV3IFtwbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikgYXJlIGdpdmVuIGluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcywgd2hpY2ggZGVzY3JpYmUgd2hhdCBoYXBwZW5lZCwgd2hlbmV2ZXIgdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiovXG5jbGFzcyBWaWV3VXBkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxuICAgICovXG4gICAgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW5cbiAgICBbYHZpZXdwb3J0Q2hhbmdlZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3VXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkgaXMgdHJ1ZVxuICAgIGFuZCB0aGUgdmlld3BvcnQgY2hhbmdlIGlzIG5vdCBqdXN0IHRoZSByZXN1bHQgb2YgbWFwcGluZyBpdCBpblxuICAgIHJlc3BvbnNlIHRvIGRvY3VtZW50IGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRNb3ZlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDE2IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB1cGRhdGUgaW5kaWNhdGVzIGEgZm9jdXMgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGZvY3VzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIGRvY3VtZW50IGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSBzZXQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgPT0gMCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMDsgfVxufVxuXG5jb25zdCBub0NoaWxkcmVuID0gW107XG5jbGFzcyBUaWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb20sIGxlbmd0aCwgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIGRvbS5jbVRpbGUgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgYnJlYWtBZnRlcigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBUaWxlRmxhZy5CcmVha0FmdGVyICovKTsgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG5vQ2hpbGRyZW47IH1cbiAgICBpc1dpZGdldCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc0NvbXBvc2l0ZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaXNMaW5lKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc1RleHQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzQmxvY2soKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBkb21BdHRycygpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgfD0gMiAvKiBUaWxlRmxhZy5TeW5jZWQgKi87XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgNCAvKiBUaWxlRmxhZy5BdHRyc0RpcnR5ICovKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdzICY9IH40IC8qIFRpbGVGbGFnLkF0dHJzRGlydHkgKi87XG4gICAgICAgICAgICBsZXQgYXR0cnMgPSB0aGlzLmRvbUF0dHJzO1xuICAgICAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgICAgIHNldEF0dHJzKHRoaXMuZG9tLCBhdHRycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGggPyBgKCR7dGhpcy5jaGlsZHJlbn0pYCA6IFwiXCIpICsgKHRoaXMuYnJlYWtBZnRlciA/IFwiI1wiIDogXCJcIik7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7IHRoaXMucGFyZW50ID0gbnVsbDsgfVxuICAgIHNldERPTShkb20pIHtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIGRvbS5jbVRpbGUgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlKHRoaXMpIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc0JlZm9yZSh0aWxlLCBzdGFydCA9IHRoaXMucG9zQXRTdGFydCkge1xuICAgICAgICBsZXQgcG9zID0gc3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSB0aWxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY2hpbGQgaW4gcG9zQmVmb3JlXCIpO1xuICAgIH1cbiAgICBwb3NBZnRlcih0aWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSh0aWxlKSArIHRpbGUubGVuZ3RoO1xuICAgIH1cbiAgICBjb3ZlcnMoc2lkZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNvb3Jkc0luKHBvcywgc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGRvbVBvc0ZvcihvZmYsIHNpZGUpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gZG9tSW5kZXgodGhpcy5kb20pO1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxlbmd0aCA/IG9mZiA+IDAgOiBzaWRlID4gMDtcbiAgICAgICAgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5wYXJlbnQuZG9tLCBpbmRleCArIChhZnRlciA/IDEgOiAwKSwgb2ZmID09IDAgfHwgb2ZmID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGF0dHJzKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgJj0gfjIgLyogVGlsZUZsYWcuU3luY2VkICovO1xuICAgICAgICBpZiAoYXR0cnMpXG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVGlsZUZsYWcuQXR0cnNEaXJ0eSAqLztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmICh0aGlzLnBhcmVudC5mbGFncyAmIDIgLyogVGlsZUZsYWcuU3luY2VkICovKSlcbiAgICAgICAgICAgIHRoaXMucGFyZW50Lm1hcmtEaXJ0eShmYWxzZSk7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGZvciAobGV0IHQgPSB0aGlzOyB0OyB0ID0gdC5wYXJlbnQpXG4gICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIERvY1RpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGRvbSkge1xuICAgICAgICByZXR1cm4gZG9tLmNtVGlsZTtcbiAgICB9XG59XG5jbGFzcyBDb21wb3NpdGVUaWxlIGV4dGVuZHMgVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZG9tKSB7XG4gICAgICAgIHN1cGVyKGRvbSwgMCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgfVxuICAgIGlzQ29tcG9zaXRlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIHRoaXMuX2NoaWxkcmVuOyB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdIDogbnVsbDsgfVxuICAgIGFwcGVuZChjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgMiAvKiBUaWxlRmxhZy5TeW5jZWQgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN1cGVyLnN5bmModHJhY2spO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5kb20sIHByZXYgPSBudWxsLCBuZXh0O1xuICAgICAgICBsZXQgdHJhY2tpbmcgPSAodHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLm5vZGUpID09IHBhcmVudCA/IHRyYWNrIDogbnVsbDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNoaWxkLnN5bmModHJhY2spO1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICh0cmFja2luZyAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICB0cmFja2luZy53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gY2hpbGQuZG9tO1xuICAgICAgICB9XG4gICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodHJhY2tpbmcgJiYgbmV4dClcbiAgICAgICAgICAgIHRyYWNraW5nLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICB3aGlsZSAobmV4dClcbiAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG59XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybSQxKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG4vLyBUaGUgdG9wLWxldmVsIHRpbGUuIEl0cyBkb20gcHJvcGVydHkgZXF1YWxzIHZpZXcuY29udGVudERPTS5cbmNsYXNzIERvY1RpbGUgZXh0ZW5kcyBDb21wb3NpdGVUaWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBkb20pIHtcbiAgICAgICAgc3VwZXIoZG9tKTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB9XG4gICAgb3ducyh0aWxlKSB7XG4gICAgICAgIGZvciAoOyB0aWxlOyB0aWxlID0gdGlsZS5wYXJlbnQpXG4gICAgICAgICAgICBpZiAodGlsZSA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzQmxvY2soKSB7IHJldHVybiB0cnVlOyB9XG4gICAgbmVhcmVzdChkb20pIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCFkb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IFRpbGUuZ2V0KGRvbSk7XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aGlzLm93bnModGlsZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgICAgICBkb20gPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja1RpbGVzKGYpIHtcbiAgICAgICAgZm9yIChsZXQgc3RhY2sgPSBbXSwgY3VyID0gdGhpcywgaSA9IDAsIHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgaWYgKGkgPT0gY3VyLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmJyZWFrQWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyLmNoaWxkcmVuW2krK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBCbG9ja1dyYXBwZXJUaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHBvcyArIG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihuZXh0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBlbmQgKyBuZXh0LmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGJsb2NrIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgc2lkZSA8IC0xLCBtYWtlIHN1cmUgdG9cbiAgICAvLyBzdGF5IGJlZm9yZSBibG9jayB3aWRnZXRzIGF0IHRoYXQgcG9zaXRpb24sIGlmIHNpZGUgPiAxLCBhZnRlclxuICAgIC8vIHN1Y2ggd2lkZ2V0cyAodXNlZCBmb3Igc2VsZWN0aW9uIGRyYXdpbmcsIHdoaWNoIG5lZWRzIHRvIGJlIGFibGVcbiAgICAvLyB0byBnZXQgY29vcmRpbmF0ZXMgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCB2YWxpZCBjdXJzb3IgcG9zaXRpb25zKS5cbiAgICByZXNvbHZlQmxvY2socG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGJlZm9yZU9mZiA9IC0xLCBhZnRlciwgYWZ0ZXJPZmYgPSAtMTtcbiAgICAgICAgdGhpcy5ibG9ja1RpbGVzKCh0aWxlLCBvZmYpID0+IHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBvZmYgKyB0aWxlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gb2ZmICYmIHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc1dpZGdldCgpICYmIHNpZGUgPj0gLTEgJiYgc2lkZSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWxlLmZsYWdzICYgMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbGUuZmxhZ3MgJiAxNiAvKiBUaWxlRmxhZy5CZWZvcmUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgob2ZmIDwgcG9zIHx8IHBvcyA9PSBlbmQgJiYgKHNpZGUgPCAtMSA/IHRpbGUubGVuZ3RoIDogdGlsZS5jb3ZlcnMoMSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlZm9yZSB8fCAhdGlsZS5pc1dpZGdldCgpICYmIGJlZm9yZS5pc1dpZGdldCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSB0aWxlO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVPZmYgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZW5kID4gcG9zIHx8IHBvcyA9PSBvZmYgJiYgKHNpZGUgPiAxID8gdGlsZS5sZW5ndGggOiB0aWxlLmNvdmVycygtMSkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWFmdGVyIHx8ICF0aWxlLmlzV2lkZ2V0KCkgJiYgYWZ0ZXIuaXNXaWRnZXQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSB0aWxlO1xuICAgICAgICAgICAgICAgICAgICBhZnRlck9mZiA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWJlZm9yZSAmJiAhYWZ0ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0aWxlIGF0IHBvc2l0aW9uIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIGJlZm9yZSAmJiBzaWRlIDwgMCB8fCAhYWZ0ZXIgPyB7IHRpbGU6IGJlZm9yZSwgb2Zmc2V0OiBiZWZvcmVPZmYgfSA6IHsgdGlsZTogYWZ0ZXIsIG9mZnNldDogYWZ0ZXJPZmYgfTtcbiAgICB9XG59XG5jbGFzcyBCbG9ja1dyYXBwZXJUaWxlIGV4dGVuZHMgQ29tcG9zaXRlVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCB3cmFwcGVyKSB7XG4gICAgICAgIHN1cGVyKGRvbSk7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgfVxuICAgIGlzQmxvY2soKSB7IHJldHVybiB0cnVlOyB9XG4gICAgY292ZXJzKHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNpZGUgPCAwID8gdGhpcy5jaGlsZHJlblswXS5jb3ZlcnMoLTEpIDogdGhpcy5sYXN0Q2hpbGQuY292ZXJzKDEpO1xuICAgIH1cbiAgICBnZXQgZG9tQXR0cnMoKSB7IHJldHVybiB0aGlzLndyYXBwZXIuYXR0cmlidXRlczsgfVxuICAgIHN0YXRpYyBvZih3cmFwcGVyLCBkb20pIHtcbiAgICAgICAgbGV0IHRpbGUgPSBuZXcgQmxvY2tXcmFwcGVyVGlsZShkb20gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh3cmFwcGVyLnRhZ05hbWUpLCB3cmFwcGVyKTtcbiAgICAgICAgaWYgKCFkb20pXG4gICAgICAgICAgICB0aWxlLmZsYWdzIHw9IDQgLyogVGlsZUZsYWcuQXR0cnNEaXJ0eSAqLztcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfVxufVxuY2xhc3MgTGluZVRpbGUgZXh0ZW5kcyBDb21wb3NpdGVUaWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb20sIGF0dHJzKSB7XG4gICAgICAgIHN1cGVyKGRvbSk7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgaXNMaW5lKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHN0YXRpYyBzdGFydChhdHRycywgZG9tLCBrZWVwQXR0cnMpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgTGluZVRpbGUoZG9tIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGF0dHJzKTtcbiAgICAgICAgaWYgKCFkb20gfHwgIWtlZXBBdHRycylcbiAgICAgICAgICAgIGxpbmUuZmxhZ3MgfD0gNCAvKiBUaWxlRmxhZy5BdHRyc0RpcnR5ICovO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0dHJzKCkgeyByZXR1cm4gdGhpcy5hdHRyczsgfVxuICAgIC8vIEZpbmQgdGhlIHRpbGUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhpcyBsaW5lLlxuICAgIHJlc29sdmVJbmxpbmUocG9zLCBzaWRlLCBmb3JDb29yZHMpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZU9mZiA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyT2ZmID0gLTE7XG4gICAgICAgIGZ1bmN0aW9uIHNjYW4odGlsZSwgcG9zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IHRpbGUuY2hpbGRyZW4ubGVuZ3RoICYmIG9mZiA8PSBwb3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRpbGUuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNDb21wb3NpdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbihjaGlsZCwgcG9zIC0gb2ZmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoIWFmdGVyIHx8IGFmdGVyLmlzSGlkZGVuICYmIChzaWRlID4gMCB8fCBmb3JDb29yZHMgJiYgb25TYW1lTGluZShhZnRlciwgY2hpbGQpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbmQgPiBwb3MgfHwgKGNoaWxkLmZsYWdzICYgMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyT2ZmID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZiA8IHBvcyB8fCAoY2hpbGQuZmxhZ3MgJiAxNiAvKiBUaWxlRmxhZy5CZWZvcmUgKi8pICYmICFjaGlsZC5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVPZmYgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjYW4odGhpcywgcG9zKTtcbiAgICAgICAgbGV0IHRhcmdldCA9ICgoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldCA/IHsgdGlsZTogdGFyZ2V0LCBvZmZzZXQ6IHRhcmdldCA9PSBiZWZvcmUgPyBiZWZvcmVPZmYgOiBhZnRlck9mZiB9IDogbnVsbDtcbiAgICB9XG4gICAgY29vcmRzSW4ocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMucmVzb2x2ZUlubGluZShwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kLnRpbGUuY29vcmRzSW4oTWF0aC5tYXgoMCwgZm91bmQub2Zmc2V0KSwgc2lkZSk7XG4gICAgfVxuICAgIGRvbUluKHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnJlc29sdmVJbmxpbmUocG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBsZXQgeyB0aWxlLCBvZmZzZXQgfSA9IGZvdW5kO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKHRpbGUuZG9tKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzVGV4dCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERPTVBvcyh0aWxlLmRvbSwgTWF0aC5taW4odGlsZS5kb20ubm9kZVZhbHVlLmxlbmd0aCwgb2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGUuZG9tUG9zRm9yKG9mZnNldCwgdGlsZS5mbGFncyAmIDE2IC8qIFRpbGVGbGFnLkJlZm9yZSAqLyA/IDEgOiB0aWxlLmZsYWdzICYgMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8gPyAtMSA6IHNpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGZvdW5kLnRpbGUucGFyZW50LCBzYXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIHBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChzYXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRE9NUG9zKGNoLmRvbSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09IGZvdW5kLnRpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2F3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZhbGxiYWNrUmVjdCh0aWxlKSB7XG4gICAgbGV0IGxhc3QgPSB0aWxlLmRvbS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsYXN0KVxuICAgICAgICByZXR1cm4gdGlsZS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XG4gICAgcmV0dXJuIHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5mdW5jdGlvbiBvblNhbWVMaW5lKGEsIGIpIHtcbiAgICBsZXQgcG9zQSA9IGEuY29vcmRzSW4oMCwgMSksIHBvc0IgPSBiLmNvb3Jkc0luKDAsIDEpO1xuICAgIHJldHVybiBwb3NBICYmIHBvc0IgJiYgcG9zQi50b3AgPCBwb3NBLmJvdHRvbTtcbn1cbmNsYXNzIE1hcmtUaWxlIGV4dGVuZHMgQ29tcG9zaXRlVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCBtYXJrKSB7XG4gICAgICAgIHN1cGVyKGRvbSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGdldCBkb21BdHRycygpIHsgcmV0dXJuIHRoaXMubWFyay5hdHRyczsgfVxuICAgIHN0YXRpYyBvZihtYXJrLCBkb20pIHtcbiAgICAgICAgbGV0IHRpbGUgPSBuZXcgTWFya1RpbGUoZG9tIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobWFyay50YWdOYW1lKSwgbWFyayk7XG4gICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgdGlsZS5mbGFncyB8PSA0IC8qIFRpbGVGbGFnLkF0dHJzRGlydHkgKi87XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH1cbn1cbmNsYXNzIFRleHRUaWxlIGV4dGVuZHMgVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCB0ZXh0KSB7XG4gICAgICAgIHN1cGVyKGRvbSwgdGV4dC5sZW5ndGgpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgMiAvKiBUaWxlRmxhZy5TeW5jZWQgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN1cGVyLnN5bmModHJhY2spO1xuICAgICAgICBpZiAodGhpcy5kb20ubm9kZVZhbHVlICE9IHRoaXMudGV4dCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5ub2RlVmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNUZXh0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KTsgfVxuICAgIGNvb3Jkc0luKHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5kb20ubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA+IGxlbmd0aClcbiAgICAgICAgICAgIHBvcyA9IGxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBwb3MsIHRvID0gcG9zLCBmbGF0dGVuID0gMDtcbiAgICAgICAgaWYgKHBvcyA9PSAwICYmIHNpZGUgPCAwIHx8IHBvcyA9PSBsZW5ndGggJiYgc2lkZSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoIShicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSkgeyAvLyBUaGVzZSBicm93c2VycyByZWxpYWJseSByZXR1cm4gdmFsaWQgcmVjdGFuZ2xlcyBmb3IgZW1wdHkgcmFuZ2VzXG4gICAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAxO1xuICAgICAgICAgICAgICAgIH0gLy8gRklYTUUgdGhpcyBpcyB3cm9uZyBpbiBSVEwgdGV4dFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDApXG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGhpcy5kb20sIGZyb20sIHRvKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzWyhmbGF0dGVuID8gZmxhdHRlbiA8IDAgOiBzaWRlID49IDApID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWZsYXR0ZW4gJiYgcmVjdC53aWR0aCA9PSAwKVxuICAgICAgICAgICAgcmVjdCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIHIgPT4gci53aWR0aCkgfHwgcmVjdDtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4gPyBmbGF0dGVuUmVjdChyZWN0LCBmbGF0dGVuIDwgMCkgOiByZWN0IHx8IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBvZih0ZXh0LCBkb20pIHtcbiAgICAgICAgbGV0IHRpbGUgPSBuZXcgVGV4dFRpbGUoZG9tIHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpLCB0ZXh0KTtcbiAgICAgICAgaWYgKCFkb20pXG4gICAgICAgICAgICB0aWxlLmZsYWdzIHw9IDIgLyogVGlsZUZsYWcuU3luY2VkICovO1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9XG59XG5jbGFzcyBXaWRnZXRUaWxlIGV4dGVuZHMgVGlsZSB7XG4gICAgY29uc3RydWN0b3IoZG9tLCBsZW5ndGgsIHdpZGdldCwgZmxhZ3MpIHtcbiAgICAgICAgc3VwZXIoZG9tLCBsZW5ndGgsIGZsYWdzKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgfVxuICAgIGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LmlzSGlkZGVuOyB9XG4gICAgY292ZXJzKHNpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiA0OCAvKiBUaWxlRmxhZy5Qb2ludFdpZGdldCAqLylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgKHNpZGUgPCAwID8gNjQgLyogVGlsZUZsYWcuSW5jU3RhcnQgKi8gOiAxMjggLyogVGlsZUZsYWcuSW5jRW5kICovKSkgPiAwO1xuICAgIH1cbiAgICBjb29yZHNJbihwb3MsIHNpZGUpIHsgcmV0dXJuIHRoaXMuY29vcmRzSW5XaWRnZXQocG9zLCBzaWRlLCBmYWxzZSk7IH1cbiAgICBjb29yZHNJbldpZGdldChwb3MsIHNpZGUsIGJsb2NrKSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLndpZGdldC5jb29yZHNBdCh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKGN1c3RvbSlcbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLmxlbmd0aCA/IHBvcyA9PSAwIDogc2lkZSA8PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IHRoaXMuZG9tLmdldENsaWVudFJlY3RzKCksIHJlY3QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgZnJvbUJhY2sgPSAodGhpcy5mbGFncyAmIDE2IC8qIFRpbGVGbGFnLkJlZm9yZSAqLykgPyB0cnVlIDogKHRoaXMuZmxhZ3MgJiAzMiAvKiBUaWxlRmxhZy5BZnRlciAqLykgPyBmYWxzZSA6IHBvcyA+IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbUJhY2sgPyByZWN0cy5sZW5ndGggLSAxIDogMDs7IGkgKz0gKGZyb21CYWNrID8gLTEgOiAxKSkge1xuICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gMCA/IGkgPT0gMCA6IGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAhZnJvbUJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgbGV0IHsgcm9vdCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyb290KVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHJvb3Qudmlldy5zdGF0ZS5kb2Muc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbiAgICBzdGF0aWMgb2Yod2lkZ2V0LCB2aWV3LCBsZW5ndGgsIGZsYWdzLCBkb20pIHtcbiAgICAgICAgaWYgKCFkb20pIHtcbiAgICAgICAgICAgIGRvbSA9IHdpZGdldC50b0RPTSh2aWV3KTtcbiAgICAgICAgICAgIGlmICghd2lkZ2V0LmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRUaWxlKGRvbSwgbGVuZ3RoLCB3aWRnZXQsIGZsYWdzKTtcbiAgICB9XG59XG4vLyBUaGVzZSBhcmUgZHJhd24gYXJvdW5kIHVuZWRpdGFibGUgd2lkZ2V0cyB0byBhdm9pZCBhIG51bWJlciBvZlxuLy8gYnJvd3NlciBidWdzIHRoYXQgc2hvdyB1cCB3aGVuIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgbmV4dCB0b1xuLy8gdW5lZGl0YWJsZSBpbmxpbmUgY29udGVudC5cbmNsYXNzIFdpZGdldEJ1ZmZlclRpbGUgZXh0ZW5kcyBUaWxlIHtcbiAgICBjb25zdHJ1Y3RvcihmbGFncykge1xuICAgICAgICBsZXQgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgaW1nLmNsYXNzTmFtZSA9IFwiY20td2lkZ2V0QnVmZmVyXCI7XG4gICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHN1cGVyKGltZywgMCwgZmxhZ3MpO1xuICAgIH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHsgcmV0dXJuIFRleHQuZW1wdHk7IH1cbiAgICBjb29yZHNJbihwb3MpIHsgcmV0dXJuIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG59XG4vLyBSZXByZXNlbnRzIGEgcG9zaXRpb24gaW4gdGhlIHRpbGUgdHJlZS5cbmNsYXNzIFRpbGVQb2ludGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3ApIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYmVmb3JlQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJlbnRzID0gW107XG4gICAgICAgIHRoaXMudGlsZSA9IHRvcDtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBieSB0aGUgZ2l2ZW4gZGlzdGFuY2UuIElmIHNpZGUgaXMgLTEsIHN0b3AgbGVhdmluZyBvclxuICAgIC8vIGVudGVyaW5nIHRpbGVzLCBvciBza2lwcGluZyB6ZXJvLWxlbmd0aCB0aWxlcywgb25jZSB0aGUgZGlzdGFuY2VcbiAgICAvLyBoYXMgYmVlbiB0cmF2ZXJzZWQuIFdoZW4gc2lkZSBpcyAxLCBsZWF2ZSwgZW50ZXIsIG9yIHNraXBcbiAgICAvLyBldmVyeXRoaW5nIGF0IHRoZSBlbmQgcG9zaXRpb24uXG4gICAgYWR2YW5jZShkaXN0LCBzaWRlLCB3YWxrZXIpIHtcbiAgICAgICAgbGV0IHsgdGlsZSwgaW5kZXgsIGJlZm9yZUJyZWFrLCBwYXJlbnRzIH0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAoZGlzdCB8fCBzaWRlID4gMCkge1xuICAgICAgICAgICAgaWYgKCF0aWxlLmlzQ29tcG9zaXRlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlQnJlYWsgPSAhIXRpbGUuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgKHsgdGlsZSwgaW5kZXggfSA9IHBhcmVudHMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWtlID0gTWF0aC5taW4oZGlzdCwgdGlsZS5sZW5ndGggLSBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrZXIuc2tpcCh0aWxlLCBpbmRleCwgaW5kZXggKyB0YWtlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCAtPSB0YWtlO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSB0YWtlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAod2Fsa2VyKVxuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuYnJlYWsoKTtcbiAgICAgICAgICAgICAgICBkaXN0LS07XG4gICAgICAgICAgICAgICAgYmVmb3JlQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09IHRpbGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXN0ICYmICFwYXJlbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHdhbGtlcilcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmxlYXZlKHRpbGUpO1xuICAgICAgICAgICAgICAgIGJlZm9yZUJyZWFrID0gISF0aWxlLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgKHsgdGlsZSwgaW5kZXggfSA9IHBhcmVudHMucG9wKCkpO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRpbGUuY2hpbGRyZW5baW5kZXhdLCBicmsgPSBuZXh0LmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKChzaWRlID4gMCA/IG5leHQubGVuZ3RoIDw9IGRpc3QgOiBuZXh0Lmxlbmd0aCA8IGRpc3QpICYmXG4gICAgICAgICAgICAgICAgICAgICghd2Fsa2VyIHx8IHdhbGtlci5za2lwKG5leHQsIDAsIG5leHQubGVuZ3RoKSAhPT0gZmFsc2UgfHwgIW5leHQuaXNDb21wb3NpdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUJyZWFrID0gISFicms7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2goeyB0aWxlLCBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGtlciAmJiBuZXh0LmlzQ29tcG9zaXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxrZXIuZW50ZXIobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlsZSA9IHRpbGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5iZWZvcmVCcmVhayA9IGJlZm9yZUJyZWFrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiAodGhpcy5wYXJlbnRzLmxlbmd0aCA/IHRoaXMucGFyZW50c1swXS50aWxlIDogdGhpcy50aWxlKTsgfVxufVxuXG4vLyBVc2VkIHRvIHRyYWNrIG9wZW4gYmxvY2sgd3JhcHBlcnNcbmNsYXNzIE9wZW5XcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgd3JhcHBlciwgcmFuaykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgfVxufVxuLy8gVGhpcyBjbGFzcyBidWlsZHMgdXAgYSBuZXcgZG9jdW1lbnQgdGlsZSB1c2luZyBpbnB1dCBmcm9tIGVpdGhlclxuLy8gaXRlcmF0aW9uIG92ZXIgdGhlIG9sZCB0cmVlIG9yIGl0ZXJhdGlvbiBvdmVyIHRoZSBkb2N1bWVudCArXG4vLyBkZWNvcmF0aW9ucy4gVGhlIGFkZCogbWV0aG9kcyBlbWl0IGVsZW1lbnRzIGludG8gdGhlIHRpbGVcbi8vIHN0cnVjdHVyZS4gVG8gYXZvaWQgYXdrd2FyZCBzeW5jaHJvbml6YXRpb24gaXNzdWVzLCBtYXJrcyBhbmQgYmxvY2tcbi8vIHdyYXBwZXJzIGFyZSB0cmVhdGVkIGFzIGJlbG9uZ2luZyB0byB0byB0aGVpciBjb250ZW50LCByYXRoZXIgdGhhblxuLy8gb3BlbmVkL2Nsb3NlZCBpbmRlcGVuZGVudGx5LlxuLy9cbi8vIEFsbCBjb21wb3NpdGUgdGlsZXMgdGhhdCBhcmUgdG91Y2hlZCBieSBjaGFuZ2VzIGFyZSByZWJ1aWx0LFxuLy8gcmV1c2luZyBhcyBtdWNoIG9mIHRoZSBvbGQgdHJlZSAoZWl0aGVyIHdob2xlIG5vZGVzIG9yIGp1c3QgRE9NXG4vLyBlbGVtZW50cykgYXMgcG9zc2libGUuIFRoZSBuZXcgdHJlZSBpcyBidWlsdCB3aXRob3V0IHRoZSBTeW5jZWRcbi8vIGZsYWcsIGFuZCB0aGVuIHN5bmNlZCAoZHVyaW5nIHdoaWNoIERPTSBwYXJlbnQvY2hpbGQgcmVsYXRpb25zIGFyZVxuLy8gZml4ZWQgdXAsIHRleHQgbm9kZXMgZmlsbGVkIGluLCBhbmQgYXR0cmlidXRlcyBhZGRlZCkgaW4gYSBzZWNvbmRcbi8vIHBoYXNlLlxuY2xhc3MgVGlsZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlLCByb290LCBibG9ja1dyYXBwZXJzKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5ibG9ja1dyYXBwZXJzID0gYmxvY2tXcmFwcGVycztcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0QmxvY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmFmdGVyV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLndyYXBwZXJzID0gW107XG4gICAgICAgIHRoaXMud3JhcHBlclBvcyA9IDA7XG4gICAgfVxuICAgIGFkZFRleHQodGV4dCwgbWFya3MsIG9wZW5TdGFydCwgdGlsZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZW5zdXJlTWFya3MobWFya3MsIG9wZW5TdGFydCk7XG4gICAgICAgIGxldCBwcmV2ID0gcGFyZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKHByZXYgJiYgcHJldi5pc1RleHQoKSAmJiAhKHByZXYuZmxhZ3MgJiA4IC8qIFRpbGVGbGFnLkNvbXBvc2l0aW9uICovKSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5yZXVzZWQuc2V0KHByZXYsIDIgLyogUmV1c2VkLkRPTSAqLyk7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBuZXcgVGV4dFRpbGUocHJldi5kb20sIHByZXYudGV4dCArIHRleHQpO1xuICAgICAgICAgICAgdGlsZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRpbGUgfHwgVGV4dFRpbGUub2YodGV4dCwgKF9hID0gdGhpcy5jYWNoZS5maW5kKFRleHRUaWxlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvbSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IHRleHQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFmdGVyV2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgYWRkQ29tcG9zaXRpb24oY29tcG9zaXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmN1ckxpbmU7XG4gICAgICAgIGlmIChsaW5lLmRvbSAhPSBjb250ZXh0LmxpbmUuZG9tKSB7XG4gICAgICAgICAgICBsaW5lLnNldERPTSh0aGlzLmNhY2hlLnJldXNlZC5oYXMoY29udGV4dC5saW5lKSA/IGZyZWVOb2RlKGNvbnRleHQubGluZS5kb20pIDogY29udGV4dC5saW5lLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnJldXNlZC5zZXQoY29udGV4dC5saW5lLCAyIC8qIFJldXNlZC5ET00gKi8pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZWFkID0gbGluZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRleHQubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBtYXJrID0gY29udGV4dC5tYXJrc1tpXTtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gaGVhZC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIE1hcmtUaWxlICYmIGxhc3QubWFyay5lcShtYXJrLm1hcmspKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QuZG9tICE9IG1hcmsuZG9tKVxuICAgICAgICAgICAgICAgICAgICBsYXN0LnNldERPTShmcmVlTm9kZShtYXJrLmRvbSkpO1xuICAgICAgICAgICAgICAgIGhlYWQgPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUucmV1c2VkLmdldChtYXJrKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IFRpbGUuZ2V0KG1hcmsuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLnNldERPTShmcmVlTm9kZShtYXJrLmRvbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbncgPSBNYXJrVGlsZS5vZihtYXJrLm1hcmssIG1hcmsuZG9tKTtcbiAgICAgICAgICAgICAgICBoZWFkLmFwcGVuZChudyk7XG4gICAgICAgICAgICAgICAgaGVhZCA9IG53O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWNoZS5yZXVzZWQuc2V0KG1hcmssIDIgLyogUmV1c2VkLkRPTSAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZFRpbGUgPSBUaWxlLmdldChjb21wb3NpdGlvbi50ZXh0KTtcbiAgICAgICAgaWYgKG9sZFRpbGUpXG4gICAgICAgICAgICB0aGlzLmNhY2hlLnJldXNlZC5zZXQob2xkVGlsZSwgMiAvKiBSZXVzZWQuRE9NICovKTtcbiAgICAgICAgbGV0IHRleHQgPSBuZXcgVGV4dFRpbGUoY29tcG9zaXRpb24udGV4dCwgY29tcG9zaXRpb24udGV4dC5ub2RlVmFsdWUpO1xuICAgICAgICB0ZXh0LmZsYWdzIHw9IDggLyogVGlsZUZsYWcuQ29tcG9zaXRpb24gKi87XG4gICAgICAgIGhlYWQuYXBwZW5kKHRleHQpO1xuICAgIH1cbiAgICBhZGRJbmxpbmVXaWRnZXQod2lkZ2V0LCBtYXJrcywgb3BlblN0YXJ0KSB7XG4gICAgICAgIC8vIEFkamFjZW50IHNhbWUtc2lkZS1mYWNpbmcgbm9uLXJlcGxhY2luZyB3aWRnZXRzIGRvbid0IG5lZWQgYnVmZmVycyBiZXR3ZWVuIHRoZW1cbiAgICAgICAgbGV0IG5vU3BhY2UgPSB0aGlzLmFmdGVyV2lkZ2V0ICYmICh3aWRnZXQuZmxhZ3MgJiA0OCAvKiBUaWxlRmxhZy5Qb2ludFdpZGdldCAqLykgJiZcbiAgICAgICAgICAgICh0aGlzLmFmdGVyV2lkZ2V0LmZsYWdzICYgNDggLyogVGlsZUZsYWcuUG9pbnRXaWRnZXQgKi8pID09ICh3aWRnZXQuZmxhZ3MgJiA0OCAvKiBUaWxlRmxhZy5Qb2ludFdpZGdldCAqLyk7XG4gICAgICAgIGlmICghbm9TcGFjZSlcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZW5zdXJlTWFya3MobWFya3MsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmICghbm9TcGFjZSAmJiAhKHdpZGdldC5mbGFncyAmIDE2IC8qIFRpbGVGbGFnLkJlZm9yZSAqLykpXG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuZ2V0QnVmZmVyKDEpKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZCh3aWRnZXQpO1xuICAgICAgICB0aGlzLnBvcyArPSB3aWRnZXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFmdGVyV2lkZ2V0ID0gd2lkZ2V0O1xuICAgIH1cbiAgICBhZGRNYXJrKHRpbGUsIG1hcmtzLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5lbnN1cmVNYXJrcyhtYXJrcywgb3BlblN0YXJ0KTtcbiAgICAgICAgcGFyZW50LmFwcGVuZCh0aWxlKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gdGlsZS5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWZ0ZXJXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBhZGRCbG9ja1dpZGdldCh3aWRnZXQpIHtcbiAgICAgICAgdGhpcy5nZXRCbG9ja1BvcygpLmFwcGVuZCh3aWRnZXQpO1xuICAgICAgICB0aGlzLnBvcyArPSB3aWRnZXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmxhc3RCbG9jayA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5lbmRMaW5lKCk7XG4gICAgfVxuICAgIGNvbnRpbnVlV2lkZ2V0KGxlbmd0aCkge1xuICAgICAgICBsZXQgd2lkZ2V0ID0gdGhpcy5hZnRlcldpZGdldCB8fCB0aGlzLmxhc3RCbG9jaztcbiAgICAgICAgd2lkZ2V0Lmxlbmd0aCArPSBsZW5ndGg7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9XG4gICAgYWRkTGluZVN0YXJ0KGF0dHJzLCBkb20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWF0dHJzKVxuICAgICAgICAgICAgYXR0cnMgPSBsaW5lQmFzZUF0dHJzO1xuICAgICAgICBsZXQgdGlsZSA9IExpbmVUaWxlLnN0YXJ0KGF0dHJzLCBkb20gfHwgKChfYSA9IHRoaXMuY2FjaGUuZmluZChMaW5lVGlsZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb20pLCAhIWRvbSk7XG4gICAgICAgIHRoaXMuZ2V0QmxvY2tQb3MoKS5hcHBlbmQodGhpcy5sYXN0QmxvY2sgPSB0aGlzLmN1ckxpbmUgPSB0aWxlKTtcbiAgICB9XG4gICAgYWRkTGluZSh0aWxlKSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvY2tQb3MoKS5hcHBlbmQodGlsZSk7XG4gICAgICAgIHRoaXMucG9zICs9IHRpbGUubGVuZ3RoO1xuICAgICAgICB0aGlzLmxhc3RCbG9jayA9IHRpbGU7XG4gICAgICAgIHRoaXMuZW5kTGluZSgpO1xuICAgIH1cbiAgICBhZGRCcmVhaygpIHtcbiAgICAgICAgdGhpcy5sYXN0QmxvY2suZmxhZ3MgfD0gMSAvKiBUaWxlRmxhZy5CcmVha0FmdGVyICovO1xuICAgICAgICB0aGlzLmVuZExpbmUoKTtcbiAgICAgICAgdGhpcy5wb3MrKztcbiAgICB9XG4gICAgYWRkTGluZVN0YXJ0SWZOb3RDb3ZlcmVkKGF0dHJzKSB7XG4gICAgICAgIGlmICghdGhpcy5ibG9ja1Bvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkTGluZVN0YXJ0KGF0dHJzKTtcbiAgICB9XG4gICAgZW5zdXJlTGluZShhdHRycykge1xuICAgICAgICBpZiAoIXRoaXMuY3VyTGluZSlcbiAgICAgICAgICAgIHRoaXMuYWRkTGluZVN0YXJ0KGF0dHJzKTtcbiAgICB9XG4gICAgZW5zdXJlTWFya3MobWFya3MsIG9wZW5TdGFydCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmN1ckxpbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG1hcmsgPSBtYXJrc1tpXSwgbGFzdDtcbiAgICAgICAgICAgIGlmIChvcGVuU3RhcnQgPiAwICYmIChsYXN0ID0gcGFyZW50Lmxhc3RDaGlsZCkgJiYgbGFzdCBpbnN0YW5jZW9mIE1hcmtUaWxlICYmIGxhc3QubWFyay5lcShtYXJrKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IE1hcmtUaWxlLm9mKG1hcmssIChfYSA9IHRoaXMuY2FjaGUuZmluZChNYXJrVGlsZSwgbSA9PiBtLm1hcmsuZXEobWFyaykpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZG9tKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRpbGUpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRpbGU7XG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBlbmRMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY3VyTGluZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgIWhhc0NvbnRlbnQodGhpcy5jdXJMaW5lLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBsYXN0LmRvbS5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgbGFzdC5pc1dpZGdldCgpICYmICEoYnJvd3Nlci5pb3MgJiYgaGFzQ29udGVudCh0aGlzLmN1ckxpbmUsIHRydWUpKSlcbiAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUuYXBwZW5kKHRoaXMuY2FjaGUuZmluZFdpZGdldChCcmVha1dpZGdldCwgMCwgMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8pIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ldyBXaWRnZXRUaWxlKEJyZWFrV2lkZ2V0LnRvRE9NKCksIDAsIEJyZWFrV2lkZ2V0LCAzMiAvKiBUaWxlRmxhZy5BZnRlciAqLykpO1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5hZnRlcldpZGdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQmxvY2tXcmFwcGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlclBvcyA+IHRoaXMucG9zICsgMTAwMDAgLyogQy5XcmFwcGVyUmVzZXQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tXcmFwcGVycy5nb3RvKHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy53cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXBwZXJzW2ldLnRvIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHRoaXMuYmxvY2tXcmFwcGVyczsgY3VyLnZhbHVlICYmIGN1ci5mcm9tIDw9IHRoaXMucG9zOyBjdXIubmV4dCgpKVxuICAgICAgICAgICAgaWYgKGN1ci50byA+PSB0aGlzLnBvcykge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gbmV3IE9wZW5XcmFwcGVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSwgY3VyLnJhbmspLCBpID0gdGhpcy53cmFwcGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmICh0aGlzLndyYXBwZXJzW2kgLSAxXS5yYW5rIC0gd3JhcC5yYW5rIHx8IHRoaXMud3JhcHBlcnNbaSAtIDFdLnRvIC0gd3JhcC50bykgPCAwKVxuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVycy5zcGxpY2UoaSwgMCwgd3JhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHRoaXMud3JhcHBlclBvcyA9IHRoaXMucG9zO1xuICAgIH1cbiAgICBnZXRCbG9ja1BvcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrV3JhcHBlcnMoKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucm9vdDtcbiAgICAgICAgZm9yIChsZXQgd3JhcCBvZiB0aGlzLndyYXBwZXJzKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAod3JhcC5mcm9tIDwgdGhpcy5wb3MgJiYgbGFzdCBpbnN0YW5jZW9mIEJsb2NrV3JhcHBlclRpbGUgJiYgbGFzdC53cmFwcGVyLmVxKHdyYXAud3JhcHBlcikpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSBCbG9ja1dyYXBwZXJUaWxlLm9mKHdyYXAud3JhcHBlciwgKF9hID0gdGhpcy5jYWNoZS5maW5kKEJsb2NrV3JhcHBlclRpbGUsIHQgPT4gdC53cmFwcGVyLmVxKHdyYXAud3JhcHBlcikpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZG9tKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRpbGUpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgYmxvY2tQb3NDb3ZlcmVkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdEJsb2NrO1xuICAgICAgICByZXR1cm4gbGFzdCAhPSBudWxsICYmICFsYXN0LmJyZWFrQWZ0ZXIgJiYgKCFsYXN0LmlzV2lkZ2V0KCkgfHwgKGxhc3QuZmxhZ3MgJiAoMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8gfCAxMjggLyogVGlsZUZsYWcuSW5jRW5kICovKSkgPiAwKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKHNpZGUpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gMiAvKiBUaWxlRmxhZy5TeW5jZWQgKi8gfCAoc2lkZSA8IDAgPyAxNiAvKiBUaWxlRmxhZy5CZWZvcmUgKi8gOiAzMiAvKiBUaWxlRmxhZy5BZnRlciAqLyk7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuY2FjaGUuZmluZChXaWRnZXRCdWZmZXJUaWxlLCB1bmRlZmluZWQsIDEgLyogUmV1c2VkLkZ1bGwgKi8pO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICBmb3VuZC5mbGFncyA9IGZsYWdzO1xuICAgICAgICByZXR1cm4gZm91bmQgfHwgbmV3IFdpZGdldEJ1ZmZlclRpbGUoZmxhZ3MpO1xuICAgIH1cbiAgICBmbHVzaEJ1ZmZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJXaWRnZXQgJiYgISh0aGlzLmFmdGVyV2lkZ2V0LmZsYWdzICYgMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8pKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyV2lkZ2V0LnBhcmVudC5hcHBlbmQodGhpcy5nZXRCdWZmZXIoLTEpKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJXaWRnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gSGVscHMgZ2V0dGluZyBlZmZpY2llbnQgYWNjZXNzIHRvIHRoZSBkb2N1bWVudCB0ZXh0LlxuY2xhc3MgVGV4dFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgICAgIHRoaXMuc2tpcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgIH1cbiAgICBza2lwKGxlbikge1xuICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgIGlmICh0aGlzLnRleHRPZmYgKyBsZW4gPD0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcENvdW50ICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHQobWF4TGVuKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRPZmYgPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgdmFsdWUsIGxpbmVCcmVhaywgZG9uZSB9ID0gdGhpcy5jdXJzb3IubmV4dCh0aGlzLnNraXBDb3VudCk7XG4gICAgICAgICAgICB0aGlzLnNraXBDb3VudCA9IDA7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW4gb3V0IG9mIHRleHQgY29udGVudCB3aGVuIGRyYXdpbmcgaW5saW5lIHZpZXdzXCIpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy50ZXh0T2ZmID0gTWF0aC5taW4obWF4TGVuLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVCcmVhayA/IG51bGwgOiB2YWx1ZS5zbGljZSgwLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0aGlzLnRleHQubGVuZ3RoLCB0aGlzLnRleHRPZmYgKyBtYXhMZW4pO1xuICAgICAgICBsZXQgY2hhcnMgPSB0aGlzLnRleHQuc2xpY2UodGhpcy50ZXh0T2ZmLCBlbmQpO1xuICAgICAgICB0aGlzLnRleHRPZmYgPSBlbmQ7XG4gICAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG59XG4vLyBBc3NpZ24gdGhlIHRpbGUgY2xhc3NlcyBidWNrZXQgbnVtYmVycyBmb3IgY2FjaGluZy5cbmNvbnN0IGJ1Y2tldHMgPSBbV2lkZ2V0VGlsZSwgTGluZVRpbGUsIFRleHRUaWxlLCBNYXJrVGlsZSwgV2lkZ2V0QnVmZmVyVGlsZSwgQmxvY2tXcmFwcGVyVGlsZSwgRG9jVGlsZV07XG5mb3IgKGxldCBpID0gMDsgaSA8IGJ1Y2tldHMubGVuZ3RoOyBpKyspXG4gICAgYnVja2V0c1tpXS5idWNrZXQgPSBpO1xuLy8gTGVhZiB0aWxlcyBhbmQgbGluZSB0aWxlcyBtYXkgYmUgcmV1c2VkIGluIHRoZWlyIGVudGlyZXR5LiBBbGxcbi8vIG90aGVycyB3aWxsIGdldCBuZXcgdGlsZXMgYWxsb2NhdGVkLCB1c2luZyB0aGUgb2xkIERPTSB3aGVuXG4vLyBwb3NzaWJsZS5cbmNsYXNzIFRpbGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBCdWNrZXRzIGFyZSBjaXJjdWxhciBidWZmZXJzLCB1c2luZyBgaW5kZXhgIGFzIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLmJ1Y2tldHMgPSBidWNrZXRzLm1hcCgoKSA9PiBbXSk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBidWNrZXRzLm1hcCgoKSA9PiAwKTtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBuZXcgTWFwO1xuICAgIH1cbiAgICAvLyBQdXQgYSB0aWxlIGluIHRoZSBjYWNoZS5cbiAgICBhZGQodGlsZSkge1xuICAgICAgICBsZXQgaSA9IHRpbGUuY29uc3RydWN0b3IuYnVja2V0LCBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbaV07XG4gICAgICAgIGlmIChidWNrZXQubGVuZ3RoIDwgNiAvKiBDLkJ1Y2tldCAqLylcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHRpbGUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBidWNrZXRbdGhpcy5pbmRleFtpXSA9ICh0aGlzLmluZGV4W2ldICsgMSkgJSA2IC8qIEMuQnVja2V0ICovXSA9IHRpbGU7XG4gICAgfVxuICAgIGZpbmQoY2xzLCB0ZXN0LCB0eXBlID0gMiAvKiBSZXVzZWQuRE9NICovKSB7XG4gICAgICAgIGxldCBpID0gY2xzLmJ1Y2tldDtcbiAgICAgICAgbGV0IGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tpXSwgb2ZmID0gdGhpcy5pbmRleFtpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGJ1Y2tldC5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgLy8gTG9vayBhdCB0aGUgbW9zdCByZWNlbnRseSBhZGRlZCBpdGVtcyBmaXJzdCAobGFzdC1pbiwgZmlyc3Qtb3V0KVxuICAgICAgICAgICAgbGV0IGluZGV4ID0gKGogKyBvZmYpICUgYnVja2V0Lmxlbmd0aCwgdGlsZSA9IGJ1Y2tldFtpbmRleF07XG4gICAgICAgICAgICBpZiAoKCF0ZXN0IHx8IHRlc3QodGlsZSkpICYmICF0aGlzLnJldXNlZC5oYXModGlsZSkpIHtcbiAgICAgICAgICAgICAgICBidWNrZXQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBvZmYpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbaV0tLTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldXNlZC5zZXQodGlsZSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbmRXaWRnZXQod2lkZ2V0LCBsZW5ndGgsIGZsYWdzKSB7XG4gICAgICAgIGxldCB3aWRnZXRzID0gdGhpcy5idWNrZXRzWzBdO1xuICAgICAgICBpZiAod2lkZ2V0cy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcGFzcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSB3aWRnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwYXNzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0aWxlID0gd2lkZ2V0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmV1c2VkLmhhcyh0aWxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAocGFzcyA9PSAwID8gdGlsZS53aWRnZXQuY29tcGFyZSh3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRpbGUud2lkZ2V0LmNvbnN0cnVjdG9yID09IHdpZGdldC5jb25zdHJ1Y3RvciAmJiB3aWRnZXQudXBkYXRlRE9NKHRpbGUuZG9tLCB0aGlzLnZpZXcpKSkge1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLmluZGV4WzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleFswXS0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZS53aWRnZXQgPT0gd2lkZ2V0ICYmIHRpbGUubGVuZ3RoID09IGxlbmd0aCAmJiAodGlsZS5mbGFncyAmICg0OTYgLyogVGlsZUZsYWcuV2lkZ2V0ICovIHwgMSAvKiBUaWxlRmxhZy5CcmVha0FmdGVyICovKSkgPT0gZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmV1c2VkLnNldCh0aWxlLCAxIC8qIFJldXNlZC5GdWxsICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXVzZWQuc2V0KHRpbGUsIDIgLyogUmV1c2VkLkRPTSAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpZGdldFRpbGUodGlsZS5kb20sIGxlbmd0aCwgd2lkZ2V0LCAodGlsZS5mbGFncyAmIH4oNDk2IC8qIFRpbGVGbGFnLldpZGdldCAqLyB8IDEgLyogVGlsZUZsYWcuQnJlYWtBZnRlciAqLykpIHwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZSh0aWxlKSB7XG4gICAgICAgIHRoaXMucmV1c2VkLnNldCh0aWxlLCAxIC8qIFJldXNlZC5GdWxsICovKTtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfVxuICAgIG1heWJlUmV1c2UodGlsZSwgdHlwZSA9IDIgLyogUmV1c2VkLkRPTSAqLykge1xuICAgICAgICBpZiAodGhpcy5yZXVzZWQuaGFzKHRpbGUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZXVzZWQuc2V0KHRpbGUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdGlsZS5kb207XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVja2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYnVja2V0c1tpXS5sZW5ndGggPSB0aGlzLmluZGV4W2ldID0gMDtcbiAgICB9XG59XG4vLyBUaGlzIGNsYXNzIG9yZ2FuaXplcyBhIHBhc3Mgb3ZlciB0aGUgZG9jdW1lbnQsIGd1aWRlZCBieSB0aGUgYXJyYXlcbi8vIG9mIHJlcGxhY2VkIHJhbmdlcy4gRm9yIHJhbmdlcyB0aGF0IGhhdmVuJ3QgY2hhbmdlZCwgaXQgaXRlcmF0ZXNcbi8vIHRoZSBvbGQgdHJlZSBhbmQgY29waWVzIGl0cyBjb250ZW50IGludG8gdGhlIG5ldyBkb2N1bWVudC4gRm9yXG4vLyBjaGFuZ2VkIHJhbmdlcywgaXQgcnVucyBhIGRlY29yYXRpb24gaXRlcmF0b3IgdG8gZ3VpZGUgZ2VuZXJhdGlvblxuLy8gb2YgY29udGVudC5cbmNsYXNzIFRpbGVVcGRhdGUge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIG9sZCwgYmxvY2tXcmFwcGVycywgZGVjb3JhdGlvbnMsIGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xuICAgICAgICB0aGlzLm9wZW5XaWRnZXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGVuTWFya3MgPSAwO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IFRpbGVDYWNoZSh2aWV3KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gbmV3IFRleHRTdHJlYW0odmlldy5zdGF0ZS5kb2MpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBuZXcgVGlsZUJ1aWxkZXIodGhpcy5jYWNoZSwgbmV3IERvY1RpbGUodmlldywgdmlldy5jb250ZW50RE9NKSwgUmFuZ2VTZXQuaXRlcihibG9ja1dyYXBwZXJzKSk7XG4gICAgICAgIHRoaXMuY2FjaGUucmV1c2VkLnNldChvbGQsIDIgLyogUmV1c2VkLkRPTSAqLyk7XG4gICAgICAgIHRoaXMub2xkID0gbmV3IFRpbGVQb2ludGVyKG9sZCk7XG4gICAgICAgIHRoaXMucmV1c2VXYWxrZXIgPSB7XG4gICAgICAgICAgICBza2lwOiAodGlsZSwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmFkZCh0aWxlKTtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc0NvbXBvc2l0ZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50ZXI6IHRpbGUgPT4gdGhpcy5jYWNoZS5hZGQodGlsZSksXG4gICAgICAgICAgICBsZWF2ZTogKCkgPT4geyB9LFxuICAgICAgICAgICAgYnJlYWs6ICgpID0+IHsgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oY2hhbmdlcywgY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uQ29udGV4dCA9IGNvbXBvc2l0aW9uICYmIHRoaXMuZ2V0Q29tcG9zaXRpb25Db250ZXh0KGNvbXBvc2l0aW9uLnRleHQpO1xuICAgICAgICBmb3IgKGxldCBwb3NBID0gMCwgcG9zQiA9IDAsIGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tpKytdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBza2lwQSA9IG5leHQgPyBuZXh0LmZyb21BIDogdGhpcy5vbGQucm9vdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2tpcEEgPiBwb3NBKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IHNraXBBIC0gcG9zQTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXNlcnZlKGxlbiwgIWksICFuZXh0KTtcbiAgICAgICAgICAgICAgICBwb3NBID0gc2tpcEE7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDb21wb3NpdGlvbnMgbmVlZCB0byBiZSBoYW5kbGVkIHNwZWNpYWxseSwgZm9yY2luZyB0aGVcbiAgICAgICAgICAgIC8vIGZvY3VzZWQgdGV4dCBub2RlIGFuZCBpdHMgcGFyZW50IG5vZGVzIHRvIHJlbWFpbiBzdGFibGUgYXRcbiAgICAgICAgICAgIC8vIHRoYXQgcG9pbnQgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uICYmIG5leHQuZnJvbUEgPD0gY29tcG9zaXRpb24ucmFuZ2UuZnJvbUEgJiYgbmV4dC50b0EgPj0gY29tcG9zaXRpb24ucmFuZ2UudG9BKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKG5leHQuZnJvbUEsIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21BLCBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQSA8IGNvbXBvc2l0aW9uLnJhbmdlLnRvQSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KHBvc0IsIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7IC8vIE11c3Qgbm90IHJldXNlIERPTSBhY3Jvc3MgY29tcG9zaXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuYWRkQ29tcG9zaXRpb24oY29tcG9zaXRpb24sIGNvbXBvc2l0aW9uQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0LnNraXAoY29tcG9zaXRpb24ucmFuZ2UudG9CIC0gY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZChjb21wb3NpdGlvbi5yYW5nZS5mcm9tQSwgbmV4dC50b0EpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChjb21wb3NpdGlvbi5yYW5nZS50b0IsIG5leHQudG9CKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZChuZXh0LmZyb21BLCBuZXh0LnRvQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KHBvc0IsIG5leHQudG9CKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0IgPSBuZXh0LnRvQjtcbiAgICAgICAgICAgIHBvc0EgPSBuZXh0LnRvQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idWlsZGVyLmN1ckxpbmUpXG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXIuZW5kTGluZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZGVyLnJvb3Q7XG4gICAgfVxuICAgIHByZXNlcnZlKGxlbmd0aCwgaW5jU3RhcnQsIGluY0VuZCkge1xuICAgICAgICBsZXQgYWN0aXZlTWFya3MgPSBnZXRNYXJrcyh0aGlzLm9sZCksIG9wZW5NYXJrcyA9IHRoaXMub3Blbk1hcmtzO1xuICAgICAgICB0aGlzLm9sZC5hZHZhbmNlKGxlbmd0aCwgaW5jRW5kID8gMSA6IC0xLCB7XG4gICAgICAgICAgICBza2lwOiAodGlsZSwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc1dpZGdldCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5XaWRnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5jb250aW51ZVdpZGdldCh0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZGdldCA9IHRvID4gMCB8fCBmcm9tIDwgdGlsZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFdpZGdldFRpbGUub2YodGlsZS53aWRnZXQsIHRoaXMudmlldywgdG8gLSBmcm9tLCB0aWxlLmZsYWdzICYgNDk2IC8qIFRpbGVGbGFnLldpZGdldCAqLywgdGhpcy5jYWNoZS5tYXliZVJldXNlKHRpbGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5jYWNoZS5yZXVzZSh0aWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWRnZXQuZmxhZ3MgJiAyNTYgLyogVGlsZUZsYWcuQmxvY2sgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZmxhZ3MgJj0gfjEgLyogVGlsZUZsYWcuQnJlYWtBZnRlciAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuYWRkQmxvY2tXaWRnZXQod2lkZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5lbnN1cmVMaW5lKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRJbmxpbmVXaWRnZXQod2lkZ2V0LCBhY3RpdmVNYXJrcywgb3Blbk1hcmtzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuTWFya3MgPSBhY3RpdmVNYXJrcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGlsZS5pc1RleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuZW5zdXJlTGluZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcm9tICYmIHRvID09IHRpbGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuYWRkVGV4dCh0aWxlLnRleHQsIGFjdGl2ZU1hcmtzLCBvcGVuTWFya3MsIHRoaXMuY2FjaGUucmV1c2UodGlsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5hZGQodGlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuYWRkVGV4dCh0aWxlLnRleHQuc2xpY2UoZnJvbSwgdG8pLCBhY3RpdmVNYXJrcywgb3Blbk1hcmtzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcGVuTWFya3MgPSBhY3RpdmVNYXJrcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbGUuaXNMaW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5mbGFncyAmPSB+MSAvKiBUaWxlRmxhZy5CcmVha0FmdGVyICovO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLnJldXNlZC5zZXQodGlsZSwgMSAvKiBSZXVzZWQuRnVsbCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRMaW5lKHRpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aWxlIGluc3RhbmNlb2YgV2lkZ2V0QnVmZmVyVGlsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmFkZCh0aWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGlsZSBpbnN0YW5jZW9mIE1hcmtUaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5lbnN1cmVMaW5lKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuYWRkTWFyayh0aWxlLCBhY3RpdmVNYXJrcywgb3Blbk1hcmtzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5yZXVzZWQuc2V0KHRpbGUsIDEgLyogUmV1c2VkLkZ1bGwgKi8pO1xuICAgICAgICAgICAgICAgICAgICBvcGVuTWFya3MgPSBhY3RpdmVNYXJrcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbldpZGdldCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudGVyOiAodGlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzTGluZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5hZGRMaW5lU3RhcnQodGlsZS5hdHRycywgdGhpcy5jYWNoZS5tYXliZVJldXNlKHRpbGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuYWRkKHRpbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlsZSBpbnN0YW5jZW9mIE1hcmtUaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWFya3MudW5zaGlmdCh0aWxlLm1hcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5XaWRnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWF2ZTogKHRpbGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc0xpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlTWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWFya3MubGVuZ3RoID0gb3Blbk1hcmtzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGlsZSBpbnN0YW5jZW9mIE1hcmtUaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hcmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5NYXJrcyA9IE1hdGgubWluKG9wZW5NYXJrcywgYWN0aXZlTWFya3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnJlYWs6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkZXIuYWRkQnJlYWsoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5XaWRnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRleHQuc2tpcChsZW5ndGgpO1xuICAgIH1cbiAgICBlbWl0KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBwZW5kaW5nTGluZUF0dHJzID0gbnVsbDtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1aWxkZXIsIG1hcmtDb3VudCA9IDA7XG4gICAgICAgIGxldCBvcGVuRW5kID0gUmFuZ2VTZXQuc3BhbnModGhpcy5kZWNvcmF0aW9ucywgZnJvbSwgdG8sIHtcbiAgICAgICAgICAgIHBvaW50OiAoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0byA+IHRoaXMudmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGVjb3JhdGlvbnMgdGhhdCByZXBsYWNlIGxpbmUgYnJlYWtzIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hcmtDb3VudCA9IGFjdGl2ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLmNvbnRpbnVlV2lkZ2V0KHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gZGVjby53aWRnZXQgfHwgKGRlY28uYmxvY2sgPyBOdWxsV2lkZ2V0LmJsb2NrIDogTnVsbFdpZGdldC5pbmxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gd2lkZ2V0RmxhZ3MoZGVjbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuY2FjaGUuZmluZFdpZGdldCh3aWRnZXQsIHRvIC0gZnJvbSwgZmxhZ3MpIHx8IFdpZGdldFRpbGUub2Yod2lkZ2V0LCB0aGlzLnZpZXcsIHRvIC0gZnJvbSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjby5zdGFydFNpZGUgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFkZExpbmVTdGFydElmTm90Q292ZXJlZChwZW5kaW5nTGluZUF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmFkZEJsb2NrV2lkZ2V0KHRpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5lbnN1cmVMaW5lKHBlbmRpbmdMaW5lQXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkSW5saW5lV2lkZ2V0KHRpbGUsIGFjdGl2ZSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTGluZUF0dHJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdMaW5lQXR0cnMgPSBhZGRMaW5lRGVjbyhwZW5kaW5nTGluZUF0dHJzLCBkZWNvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0LnNraXAodG8gLSBmcm9tKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcGFuOiAoZnJvbSwgdG8sIGFjdGl2ZSwgb3BlblN0YXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDwgdG87KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFycyA9IHRoaXMudGV4dC5uZXh0KE1hdGgubWluKDUxMiAvKiBDLkNodW5rICovLCB0byAtIHBvcykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnMgPT0gbnVsbCkgeyAvLyBMaW5lIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmFkZExpbmVTdGFydElmTm90Q292ZXJlZChwZW5kaW5nTGluZUF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkQnJlYWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5lbnN1cmVMaW5lKHBlbmRpbmdMaW5lQXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5hZGRUZXh0KGNoYXJzLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gY2hhcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdMaW5lQXR0cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGIuYWRkTGluZVN0YXJ0SWZOb3RDb3ZlcmVkKHBlbmRpbmdMaW5lQXR0cnMpO1xuICAgICAgICB0aGlzLm9wZW5XaWRnZXQgPSBvcGVuRW5kID4gbWFya0NvdW50O1xuICAgICAgICB0aGlzLm9wZW5NYXJrcyA9IG9wZW5FbmQ7XG4gICAgfVxuICAgIGZvcndhcmQoZnJvbSwgdG8sIHNpZGUgPSAxKSB7XG4gICAgICAgIGlmICh0byAtIGZyb20gPD0gMTApIHtcbiAgICAgICAgICAgIHRoaXMub2xkLmFkdmFuY2UodG8gLSBmcm9tLCBzaWRlLCB0aGlzLnJldXNlV2Fsa2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2xkLmFkdmFuY2UoNSwgLTEsIHRoaXMucmV1c2VXYWxrZXIpO1xuICAgICAgICAgICAgdGhpcy5vbGQuYWR2YW5jZSh0byAtIGZyb20gLSAxMCwgLTEpO1xuICAgICAgICAgICAgdGhpcy5vbGQuYWR2YW5jZSg1LCBzaWRlLCB0aGlzLnJldXNlV2Fsa2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb21wb3NpdGlvbkNvbnRleHQodGV4dCkge1xuICAgICAgICBsZXQgbWFya3MgPSBbXSwgbGluZSA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRleHQucGFyZW50Tm9kZTs7IHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IFRpbGUuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRpbGUgaW5zdGFuY2VvZiBNYXJrVGlsZSlcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHRpbGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodGlsZSA9PT0gbnVsbCB8fCB0aWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aWxlLmlzTGluZSgpKVxuICAgICAgICAgICAgICAgIGxpbmUgPSB0aWxlO1xuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50Lm5vZGVOYW1lID09IFwiRElWXCIgJiYgIWxpbmUgJiYgcGFyZW50ICE9IHRoaXMudmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBuZXcgTGluZVRpbGUocGFyZW50LCBsaW5lQmFzZUF0dHJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKE1hcmtUaWxlLm9mKG5ldyBNYXJrRGVjb3JhdGlvbih7IHRhZ05hbWU6IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyaWJ1dGVzOiBnZXRBdHRycyhwYXJlbnQpIH0pLCBwYXJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lOiBsaW5lLCBtYXJrcyB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NvbnRlbnQodGlsZSwgcmVxdWlyZVRleHQpIHtcbiAgICBsZXQgc2NhbiA9ICh0aWxlKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRpbGUuY2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoKHJlcXVpcmVUZXh0ID8gY2guaXNUZXh0KCkgOiBjaC5sZW5ndGgpIHx8IHNjYW4oY2gpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gc2Nhbih0aWxlKTtcbn1cbmZ1bmN0aW9uIHdpZGdldEZsYWdzKGRlY28pIHtcbiAgICBsZXQgZmxhZ3MgPSBkZWNvLmlzUmVwbGFjZSA/IChkZWNvLnN0YXJ0U2lkZSA8IDAgPyA2NCAvKiBUaWxlRmxhZy5JbmNTdGFydCAqLyA6IDApIHwgKGRlY28uZW5kU2lkZSA+IDAgPyAxMjggLyogVGlsZUZsYWcuSW5jRW5kICovIDogMClcbiAgICAgICAgOiAoZGVjby5zdGFydFNpZGUgPiAwID8gMzIgLyogVGlsZUZsYWcuQWZ0ZXIgKi8gOiAxNiAvKiBUaWxlRmxhZy5CZWZvcmUgKi8pO1xuICAgIGlmIChkZWNvLmJsb2NrKVxuICAgICAgICBmbGFncyB8PSAyNTYgLyogVGlsZUZsYWcuQmxvY2sgKi87XG4gICAgcmV0dXJuIGZsYWdzO1xufVxuY29uc3QgbGluZUJhc2VBdHRycyA9IHsgY2xhc3M6IFwiY20tbGluZVwiIH07XG5mdW5jdGlvbiBhZGRMaW5lRGVjbyh2YWx1ZSwgZGVjbykge1xuICAgIGxldCBhdHRycyA9IGRlY28uc3BlYy5hdHRyaWJ1dGVzLCBjbHMgPSBkZWNvLnNwZWMuY2xhc3M7XG4gICAgaWYgKCFhdHRycyAmJiAhY2xzKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdmFsdWUgPSB7IGNsYXNzOiBcImNtLWxpbmVcIiB9O1xuICAgIGlmIChhdHRycylcbiAgICAgICAgY29tYmluZUF0dHJzKGF0dHJzLCB2YWx1ZSk7XG4gICAgaWYgKGNscylcbiAgICAgICAgdmFsdWUuY2xhc3MgKz0gXCIgXCIgKyBjbHM7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0TWFya3MocHRyKSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IHB0ci5wYXJlbnRzLmxlbmd0aDsgaSA+IDE7IGktLSkge1xuICAgICAgICBsZXQgdGlsZSA9IGkgPT0gcHRyLnBhcmVudHMubGVuZ3RoID8gcHRyLnRpbGUgOiBwdHIucGFyZW50c1tpXS50aWxlO1xuICAgICAgICBpZiAodGlsZSBpbnN0YW5jZW9mIE1hcmtUaWxlKVxuICAgICAgICAgICAgZm91bmQucHVzaCh0aWxlLm1hcmspO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmcmVlTm9kZShub2RlKSB7XG4gICAgbGV0IHRpbGUgPSBUaWxlLmdldChub2RlKTtcbiAgICBpZiAodGlsZSlcbiAgICAgICAgdGlsZS5zZXRET00obm9kZS5jbG9uZU5vZGUoKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuTnVsbFdpZGdldC5pbmxpbmUgPSAvKkBfX1BVUkVfXyovbmV3IE51bGxXaWRnZXQoXCJzcGFuXCIpO1xuTnVsbFdpZGdldC5ibG9jayA9IC8qQF9fUFVSRV9fKi9uZXcgTnVsbFdpZGdldChcImRpdlwiKTtcbmNvbnN0IEJyZWFrV2lkZ2V0ID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBlZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbn07XG5cbmNsYXNzIERvY1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmJsb2NrV3JhcHBlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCA9IFtmYWxzZV07XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgdGhpcy5sYXN0Q29tcG9zaXRpb25BZnRlckN1cnNvciA9IGZhbHNlO1xuICAgICAgICAvLyBUcmFjayBhIG1pbmltdW0gd2lkdGggZm9yIHRoZSBlZGl0b3IuIFdoZW4gbWVhc3VyaW5nIHNpemVzIGluXG4gICAgICAgIC8vIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMsIHRoaXMgaXMgdXBkYXRlZCB0byBwb2ludCBhdCB0aGUgd2lkdGhcbiAgICAgICAgLy8gb2YgYSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZXh0ZW50IGluIHRoZSBkb2N1bWVudC4gV2hlbiBhIGNoYW5nZVxuICAgICAgICAvLyBoYXBwZW5zIGluIHRoYXQgcmFuZ2UsIHRoZXNlIGFyZSByZXNldC4gVGhhdCB3YXksIG9uY2Ugd2UndmUgc2VlblxuICAgICAgICAvLyBhIGxpbmUvZWxlbWVudCBvZiBhIGdpdmVuIGxlbmd0aCwgd2Uga2VlcCB0aGUgZWRpdG9yIHdpZGUgZW5vdWdoXG4gICAgICAgIC8vIHRvIGZpdCBhdCBsZWFzdCB0aGF0IGVsZW1lbnQsIHVudGlsIGl0IGlzIGNoYW5nZWQsIGF0IHdoaWNoIHBvaW50XG4gICAgICAgIC8vIHdlIGZvcmdldCBpdCBhZ2Fpbi5cbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgRE9NIHNlbGVjdGlvbiB3YXMgc2V0IGluIGEgbG9zc3kgd2F5LCBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IG1lc3MgaXQgdXAgd2hlbiByZWFkaW5nIGl0IGJhY2sgaXRcbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIHJlc2l6ZSBvYnNlcnZlciB0byBpZ25vcmUgcmVzaXplcyB0aGF0IHdlIGNhdXNlZFxuICAgICAgICAvLyBvdXJzZWx2ZXNcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIHRoaXMudGlsZSA9IG5ldyBEb2NUaWxlKHZpZXcsIHZpZXcuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIoW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0sIG51bGwpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS5cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aEZyb20gPSB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aEZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoVG8sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdENvbnRleHRGb3JtYXR0aW5nKHVwZGF0ZSk7XG4gICAgICAgIGxldCByZWFkQ29tcG9zaXRpb25BdCA9IC0xO1xuICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiYgIXRoaXMudmlldy5vYnNlcnZlci5lZGl0Q29udGV4dCkge1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuZG9tQ2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5ld1NlbClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHRoaXMuZG9tQ2hhbmdlZC5uZXdTZWwuaGVhZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0b3VjaGVzQ29tcG9zaXRpb24odXBkYXRlLmNoYW5nZXMsIHRoaXMuaGFzQ29tcG9zaXRpb24pICYmICF1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgICAgIHJlYWRDb21wb3NpdGlvbkF0ID0gdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gcmVhZENvbXBvc2l0aW9uQXQgPiAtMSA/IGZpbmRDb21wb3NpdGlvblJhbmdlKHRoaXMudmlldywgdXBkYXRlLmNoYW5nZXMsIHJlYWRDb21wb3NpdGlvbkF0KSA6IG51bGw7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5oYXNDb21wb3NpdGlvbjtcbiAgICAgICAgICAgIGNoYW5nZWRSYW5nZXMgPSBuZXcgQ2hhbmdlZFJhbmdlKGZyb20sIHRvLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3MoZnJvbSwgLTEpLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModG8sIDEpKVxuICAgICAgICAgICAgICAgIC5hZGRUb1NldChjaGFuZ2VkUmFuZ2VzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiA/IHsgZnJvbTogY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIHRvOiBjb21wb3NpdGlvbi5yYW5nZS50b0IgfSA6IG51bGw7XG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBub2RlcyBhcm91bmQgdGhlIHNlbGVjdGlvbiBhcmUgbW92ZWQgdG8gYW5vdGhlclxuICAgICAgICAvLyBwYXJlbnQsIENocm9tZSBzb21ldGltZXMgcmVwb3J0cyBhIGRpZmZlcmVudCBzZWxlY3Rpb24gdGhyb3VnaFxuICAgICAgICAvLyBnZXRTZWxlY3Rpb24gdGhhbiB0aGUgb25lIHRoYXQgaXQgYWN0dWFsbHkgc2hvd3MgdG8gdGhlIHVzZXIuXG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIGEgc2VsZWN0aW9uIHVwZGF0ZSB3aGVuIGxpbmVzIGFyZSBqb2luZWQgdG8gd29ya1xuICAgICAgICAvLyBhcm91bmQgdGhhdC4gSXNzdWUgIzU0XG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSB8fCBicm93c2VyLmNocm9tZSkgJiYgIWNvbXBvc2l0aW9uICYmIHVwZGF0ZSAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmRvYy5saW5lcyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZXMpXG4gICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5kZWNvcmF0aW9ucywgcHJldldyYXBwZXJzID0gdGhpcy5ibG9ja1dyYXBwZXJzO1xuICAgICAgICB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCB0aGlzLmRlY29yYXRpb25zLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmIChkZWNvRGlmZi5sZW5ndGgpXG4gICAgICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY2hhbmdlZFJhbmdlcywgZGVjb0RpZmYpO1xuICAgICAgICBsZXQgYmxvY2tEaWZmID0gZmluZENoYW5nZWRXcmFwcGVycyhwcmV2V3JhcHBlcnMsIHRoaXMuYmxvY2tXcmFwcGVycywgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBpZiAoYmxvY2tEaWZmLmxlbmd0aClcbiAgICAgICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBibG9ja0RpZmYpO1xuICAgICAgICBpZiAoY29tcG9zaXRpb24gJiYgIWNoYW5nZWRSYW5nZXMuc29tZShyID0+IHIuZnJvbUEgPD0gY29tcG9zaXRpb24ucmFuZ2UuZnJvbUEgJiYgci50b0EgPj0gY29tcG9zaXRpb24ucmFuZ2UudG9BKSlcbiAgICAgICAgICAgIGNoYW5nZWRSYW5nZXMgPSBjb21wb3NpdGlvbi5yYW5nZS5hZGRUb1NldChjaGFuZ2VkUmFuZ2VzLnNsaWNlKCkpO1xuICAgICAgICBpZiAoKHRoaXMudGlsZS5mbGFncyAmIDIgLyogVGlsZUZsYWcuU3luY2VkICovKSAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCBieSB1cGRhdGUgYW5kIHRoZSBjb25zdHJ1Y3RvciBkbyBwZXJmb3JtIHRoZSBhY3R1YWwgRE9NXG4gICAgLy8gdXBkYXRlXG4gICAgdXBkYXRlSW5uZXIoY2hhbmdlcywgY29tcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICBsZXQgeyBvYnNlcnZlciB9ID0gdGhpcy52aWV3O1xuICAgICAgICBvYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uIHx8IGNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFRpbGUgPSB0aGlzLnRpbGU7XG4gICAgICAgICAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgVGlsZVVwZGF0ZSh0aGlzLnZpZXcsIG9sZFRpbGUsIHRoaXMuYmxvY2tXcmFwcGVycywgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgdGhpcy50aWxlID0gYnVpbGRlci5ydW4oY2hhbmdlcywgY29tcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGRlc3Ryb3lEcm9wcGVkKG9sZFRpbGUsIGJ1aWxkZXIuY2FjaGUucmV1c2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBtZXNzZXMgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBET00gbXV0YXRpb24gKHRob3VnaFxuICAgICAgICAgICAgLy8gbm8gcmVsYXlvdXQgaXMgdHJpZ2dlcmVkIGFuZCBJIGNhbm5vdCBpbWFnaW5lIGhvdyBpdCBjYW5cbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXG4gICAgICAgICAgICB0aGlzLnRpbGUuZG9tLnN0eWxlLmhlaWdodCA9IHRoaXMudmlldy52aWV3U3RhdGUuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLnRpbGUuZG9tLnN0eWxlLmZsZXhCYXNpcyA9IHRoaXMubWluV2lkdGggPyB0aGlzLm1pbldpZHRoICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcywgd2hlbiBET00gbXV0YXRpb25zIG9jY3VyIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBhcm91bmQgdGhlIHNlbGVjdGlvbiwgZ2V0IGNvbmZ1c2VkIGFuZCByZXBvcnQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBmcm9tIHRoZSBvbmUgaXQgZGlzcGxheXMgKGlzc3VlICMyMTgpLiBUaGlzIHRyaWVzXG4gICAgICAgICAgICAvLyB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSBicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmlvcyA/IHsgbm9kZTogb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlLCB3cml0dGVuOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50aWxlLnN5bmModHJhY2spO1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmICh0cmFjay53cml0dGVuIHx8IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSAhPSB0cmFjay5ub2RlIHx8ICF0aGlzLnRpbGUuZG9tLmNvbnRhaW5zKHRyYWNrLm5vZGUpKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudGlsZS5kb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGlmICh0aGlzLnZpZXcudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMudGlsZS5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNXaWRnZXQoKSAmJiBjaGlsZC53aWRnZXQgaW5zdGFuY2VvZiBCbG9ja0dhcFdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgZ2Fwcy5wdXNoKGNoaWxkLmRvbSk7XG4gICAgICAgIG9ic2VydmVyLnVwZGF0ZUdhcHMoZ2Fwcyk7XG4gICAgfVxuICAgIHVwZGF0ZUVkaXRDb250ZXh0Rm9ybWF0dGluZyh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcgPSB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRFZGl0Q29udGV4dEZvcm1hdHRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihtdXN0UmVhZCA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtdXN0UmVhZCB8fCAhdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHsgZG9tIH0gPSB0aGlzLnRpbGU7XG4gICAgICAgIGxldCBhY3RpdmVFbHQgPSB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50LCBmb2N1c2VkID0gYWN0aXZlRWx0ID09IGRvbTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbk5vdEZvY3VzID0gIWZvY3VzZWQgJiYgISh0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpIHx8IGRvbS50YWJJbmRleCA+IC0xKSAmJlxuICAgICAgICAgICAgaGFzU2VsZWN0aW9uKGRvbSwgdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlKSAmJiAhKGFjdGl2ZUVsdCAmJiBkb20uY29udGFpbnMoYWN0aXZlRWx0KSk7XG4gICAgICAgIGlmICghKGZvY3VzZWQgfHwgZnJvbVBvaW50ZXIgfHwgc2VsZWN0aW9uTm90Rm9jdXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLCBhbmNob3IsIGhlYWQ7XG4gICAgICAgIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICBoZWFkID0gYW5jaG9yID0gdGhpcy5pbmxpbmVET01OZWFyUG9zKG1haW4uYW5jaG9yLCBtYWluLmFzc29jIHx8IDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZCA9IHRoaXMuaW5saW5lRE9NTmVhclBvcyhtYWluLmhlYWQsIG1haW4uaGVhZCA9PSBtYWluLmZyb20gPyAxIDogLTEpO1xuICAgICAgICAgICAgYW5jaG9yID0gdGhpcy5pbmxpbmVET01OZWFyUG9zKG1haW4uYW5jaG9yLCBtYWluLmFuY2hvciA9PSBtYWluLmZyb20gPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmICF0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHwgKCFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkgJiYgIXRoaXMuc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2UoZG9tU2VsLCBtYWluKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgZG9tLmNvbnRhaW5zKGRvbVNlbC5mb2N1c05vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgIGluVW5lZGl0YWJsZShkb21TZWwuZm9jdXNOb2RlLCBkb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYXdTZWwgPSBnZXRTZWxlY3Rpb24odGhpcy52aWV3LnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmICghcmF3U2VsKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjEyMDc2XG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFRvID0gbmV4dFRvVW5lZGl0YWJsZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRvICYmIG5leHRUbyAhPSAoMSAvKiBOZXh0VG8uQmVmb3JlICovIHwgMiAvKiBOZXh0VG8uQWZ0ZXIgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSAobmV4dFRvID09IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA/IHRleHROb2RlQmVmb3JlIDogdGV4dE5vZGVBZnRlcikoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgRE9NUG9zKHRleHQubm9kZSwgdGV4dC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmJpZGlMZXZlbCAhPSBudWxsICYmIHJhd1NlbC5jYXJldEJpZGlMZXZlbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNhcmV0QmlkaUxldmVsID0gbWFpbi5iaWRpTGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhd1NlbC5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIHdpbGwgaWdub3JlIHRoZSBjYWxsIGFib3ZlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWRkZW4sIGFuZCB0aGVuIHJhaXNlIGFuIGVycm9yIG9uIHRoZSBjYWxsIHRvIGV4dGVuZFxuICAgICAgICAgICAgICAgICAgICAvLyAoIzk0MCkuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuZXh0ZW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSAoSUUpIHdheVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5hbmNob3IgPiBtYWluLmhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBbYW5jaG9yLCBoZWFkXSA9IFtoZWFkLCBhbmNob3JdO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTm90Rm9jdXMgJiYgdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudCA9PSBkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsdC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSB6ZXJvLWxlbmd0aCB3aWRnZXQgaXMgaW5zZXJ0ZWQgbmV4dCB0byB0aGUgY3Vyc29yIGR1cmluZ1xuICAgIC8vIGNvbXBvc2l0aW9uLCBhdm9pZCBtb3ZpbmcgaXQgYWNyb3NzIGl0IGFuZCBkaXNydXB0aW5nIHRoZVxuICAgIC8vIGNvbXBvc2l0aW9uLlxuICAgIHN1cHByZXNzV2lkZ2V0Q3Vyc29yQ2hhbmdlKHNlbCwgY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGN1cnNvci5lbXB0eSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIHRoaXMucG9zRnJvbURPTShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpID09IGN1cnNvci5oZWFkO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMubGluZUF0KGN1cnNvci5oZWFkLCBjdXJzb3IuYXNzb2MpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYywgY3Vyc29yLmFzc29jKTtcbiAgICAgICAgc2VsLmNvbGxhcHNlKGRvbS5ub2RlLCBkb20ub2Zmc2V0KTtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgY3Vyc29yLmFzc29jIDwgMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgICAgLy8gVGhpcyBjYW4gZ28gd3JvbmcgaW4gY29ybmVyIGNhc2VzIGxpa2Ugc2luZ2xlLWNoYXJhY3RlciBsaW5lcyxcbiAgICAgICAgLy8gc28gY2hlY2sgYW5kIHJlc2V0IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgdmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1JhbmdlID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5ld1JhbmdlLmFuY2hvck5vZGUsIG5ld1JhbmdlLmFuY2hvck9mZnNldCkgIT0gY3Vyc29yLmZyb20pXG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICB9XG4gICAgcG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHRpbGUgPSB0aGlzLnRpbGUubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF0aWxlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlsZS5kb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiAyIC8qIFBSRUNFRElORyAqLyA/IDAgOiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGlsZS5wb3NBdFN0YXJ0O1xuICAgICAgICBpZiAodGlsZS5pc0NvbXBvc2l0ZSgpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXI7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSB0aWxlLmRvbSkge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gdGlsZS5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGlsZS5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpYXMgPT0gMCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPT0gdGlsZS5kb20uZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoYWZ0ZXIgJiYgIVRpbGUuZ2V0KGFmdGVyKSlcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgKyB0aWxlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRpbGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRvbSA9PSBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aWxlLmlzVGV4dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZSA9PSB0aWxlLmRvbSA/IHN0YXJ0ICsgb2Zmc2V0IDogc3RhcnQgKyAob2Zmc2V0ID8gdGlsZS5sZW5ndGggOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21BdFBvcyhwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgdGlsZSwgb2Zmc2V0IH0gPSB0aGlzLnRpbGUucmVzb2x2ZUJsb2NrKHBvcywgc2lkZSk7XG4gICAgICAgIGlmICh0aWxlLmlzV2lkZ2V0KCkpXG4gICAgICAgICAgICByZXR1cm4gdGlsZS5kb21Qb3NGb3IocG9zLCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIHRpbGUuZG9tSW4ob2Zmc2V0LCBzaWRlKTtcbiAgICB9XG4gICAgaW5saW5lRE9NTmVhclBvcyhwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYmVmb3JlT2ZmID0gLTEsIGJlZm9yZUJhZCA9IGZhbHNlO1xuICAgICAgICBsZXQgYWZ0ZXIsIGFmdGVyT2ZmID0gLTEsIGFmdGVyQmFkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGlsZS5ibG9ja1RpbGVzKCh0aWxlLCBvZmYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aWxlLmlzV2lkZ2V0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRpbGUuZmxhZ3MgJiAzMiAvKiBUaWxlRmxhZy5BZnRlciAqLykgJiYgb2ZmID49IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRpbGUuZmxhZ3MgJiAxNiAvKiBUaWxlRmxhZy5CZWZvcmUgKi8pXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUJhZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gb2ZmICsgdGlsZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG9mZiA8PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gdGlsZTtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlT2ZmID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVCYWQgPSBlbmQgPCBwb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zICYmICFhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IHRpbGU7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyT2ZmID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICBhZnRlckJhZCA9IG9mZiA+IHBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9mZiA+IHBvcyAmJiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWJlZm9yZSAmJiAhYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21BdFBvcyhwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoYmVmb3JlQmFkICYmIGFmdGVyKVxuICAgICAgICAgICAgYmVmb3JlID0gbnVsbDtcbiAgICAgICAgZWxzZSBpZiAoYWZ0ZXJCYWQgJiYgYmVmb3JlKVxuICAgICAgICAgICAgYWZ0ZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gYmVmb3JlICYmIHNpZGUgPCAwIHx8ICFhZnRlciA/IGJlZm9yZS5kb21JbihiZWZvcmVPZmYsIHNpZGUpIDogYWZ0ZXIuZG9tSW4oYWZ0ZXJPZmYsIHNpZGUpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgdGlsZSwgb2Zmc2V0IH0gPSB0aGlzLnRpbGUucmVzb2x2ZUJsb2NrKHBvcywgc2lkZSk7XG4gICAgICAgIGlmICh0aWxlLmlzV2lkZ2V0KCkpIHtcbiAgICAgICAgICAgIGlmICh0aWxlLndpZGdldCBpbnN0YW5jZW9mIEJsb2NrR2FwV2lkZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRpbGUuY29vcmRzSW5XaWRnZXQob2Zmc2V0LCBzaWRlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZS5jb29yZHNJbihvZmZzZXQsIHNpZGUpO1xuICAgIH1cbiAgICBsaW5lQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IHRpbGUgfSA9IHRoaXMudGlsZS5yZXNvbHZlQmxvY2socG9zLCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIHRpbGUuaXNMaW5lKCkgPyB0aWxlIDogbnVsbDtcbiAgICB9XG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgbGV0IHsgdGlsZSwgb2Zmc2V0IH0gPSB0aGlzLnRpbGUucmVzb2x2ZUJsb2NrKHBvcywgMSk7XG4gICAgICAgIGlmICghdGlsZS5pc0xpbmUoKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmdW5jdGlvbiBzY2FuKHRpbGUsIG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKHRpbGUuaXNDb21wb3NpdGUoKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIHRpbGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoLmxlbmd0aCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHNjYW4oY2gsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBjaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlsZS5pc1RleHQoKSAmJiBvZmZzZXQgPCB0aWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBmaW5kQ2x1c3RlckJyZWFrKHRpbGUudGV4dCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKHRpbGUuZG9tLCBvZmZzZXQsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSAmJiByZWN0LmxlZnQgPCByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYW4odGlsZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh2aWV3cG9ydCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHsgZnJvbSwgdG8gfSA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gdGhpcy52aWV3LmNvbnRlbnRET00uY2xpZW50V2lkdGg7XG4gICAgICAgIGxldCBpc1dpZGVyID0gY29udGVudFdpZHRoID4gTWF0aC5tYXgodGhpcy52aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCwgdGhpcy5taW5XaWR0aCkgKyAxO1xuICAgICAgICBsZXQgd2lkZXN0ID0gLTEsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGxldCBzcGFjZUFib3ZlID0gMDtcbiAgICAgICAgbGV0IHNjYW4gPSAodGlsZSwgcG9zLCBtZWFzdXJlQm91bmRzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRpbGUuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSZWN0ID0gY2hpbGQuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB7IGhlaWdodCB9ID0gY2hpbGRSZWN0O1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlQm91bmRzICYmICFpKVxuICAgICAgICAgICAgICAgICAgICBzcGFjZUFib3ZlICs9IGNoaWxkUmVjdC50b3AgLSBtZWFzdXJlQm91bmRzLnRvcDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dyYXBwZXJUaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbihjaGlsZCwgcG9zLCBjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2VBYm92ZSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgtc3BhY2VBYm92ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGhlaWdodCArIHNwYWNlQWJvdmUpO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZUFib3ZlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2lkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gY2hpbGQuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGxhc3QgPyBjbGllbnRSZWN0c0ZvcihsYXN0KSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gbHRyID8gcmVjdC5yaWdodCAtIGNoaWxkUmVjdC5sZWZ0IDogY2hpbGRSZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlc3QgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVCb3VuZHMgJiYgaSA9PSB0aWxlLmNoaWxkcmVuLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlQWJvdmUgKz0gbWVhc3VyZUJvdW5kcy5ib3R0b20gLSBjaGlsZFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNjYW4odGhpcy50aWxlLCAwLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgeyB0aWxlIH0gPSB0aGlzLnRpbGUucmVzb2x2ZUJsb2NrKHBvcywgMSk7XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRpbGUuZG9tKS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGxldCBsaW5lTWVhc3VyZSA9IHRoaXMudGlsZS5ibG9ja1RpbGVzKHRpbGUgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbGUuaXNMaW5lKCkgJiYgdGlsZS5jaGlsZHJlbi5sZW5ndGggJiYgdGlsZS5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDAsIHRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGlsZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dCgpIHx8IC9bXiAtfl0vLnRlc3QoY2hpbGQudGV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IHJlY3RzWzBdLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gcmVjdHNbMF0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRpbGUuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJXaWR0aDogdG90YWxXaWR0aCAvIHRpbGUubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxpbmVNZWFzdXJlKVxuICAgICAgICAgICAgcmV0dXJuIGxpbmVNZWFzdXJlO1xuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcbiAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0O1xuICAgICAgICBkdW1teS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUud2lkdGggPSBcIjk5OTk5cHhcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGR1bW15LnRleHRDb250ZW50ID0gXCJhYmMgZGVmIGdoaSBqa2wgbW5vIHBxciBzdHVcIjtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbGUuZG9tLmFwcGVuZENoaWxkKGR1bW15KTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gY2xpZW50UmVjdHNGb3IoZHVtbXkuZmlyc3RDaGlsZClbMF07XG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gZHVtbXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgY2hhcldpZHRoID0gcmVjdCAmJiByZWN0LndpZHRoID8gcmVjdC53aWR0aCAvIDI3IDogNztcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0ICYmIHJlY3QuaGVpZ2h0ID8gcmVjdC5oZWlnaHQgOiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgZHVtbXkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfTtcbiAgICB9XG4gICAgY29tcHV0ZUJsb2NrR2FwRGVjbygpIHtcbiAgICAgICAgbGV0IGRlY28gPSBbXSwgdnMgPSB0aGlzLnZpZXcudmlld1N0YXRlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHZzLnZpZXdwb3J0cy5sZW5ndGggPyBudWxsIDogdnMudmlld3BvcnRzW2ldO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb20gLSAxIDogdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9ICh2cy5saW5lQmxvY2tBdChlbmQpLmJvdHRvbSAtIHZzLmxpbmVCbG9ja0F0KHBvcykudG9wKSAvIHRoaXMudmlldy5zY2FsZVk7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IEJsb2NrR2FwV2lkZ2V0KGhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQmxvY2tHYXA6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UocG9zLCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG4gICAgdXBkYXRlRGVjbygpIHtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgYWxsRGVjbyA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykubWFwKGQgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2krK10gPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pYyA/IGQodGhpcy52aWV3KSA6IGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZHluYW1pY091dGVyID0gZmFsc2UsIG91dGVyRGVjbyA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChvdXRlckRlY29yYXRpb25zKS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgaWYgKGR5bmFtaWMpXG4gICAgICAgICAgICAgICAgZHluYW1pY091dGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXRlckRlY28ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2krK10gPSBkeW5hbWljT3V0ZXI7XG4gICAgICAgICAgICBhbGxEZWNvLnB1c2goUmFuZ2VTZXQuam9pbihvdXRlckRlY28pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gW1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcsXG4gICAgICAgICAgICAuLi5hbGxEZWNvLFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQmxvY2tHYXBEZWNvKCksXG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVHYXBEZWNvXG4gICAgICAgIF07XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5kZWNvcmF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2krK10gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibG9ja1dyYXBwZXJzID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGJsb2NrV3JhcHBlcnMpLm1hcCh2ID0+IHR5cGVvZiB2ID09IFwiZnVuY3Rpb25cIiA/IHYodGhpcy52aWV3KSA6IHYpO1xuICAgIH1cbiAgICBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldC5pc1NuYXBzaG90KSB7XG4gICAgICAgICAgICBsZXQgcmVmID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lQmxvY2tBdCh0YXJnZXQucmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHJlZi50b3AgLSB0YXJnZXQueU1hcmdpbjtcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHRhcmdldC54TWFyZ2luO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNjcm9sbEhhbmRsZXIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKHRoaXMudmlldywgdGFyZ2V0LnJhbmdlLCB0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJzY3JvbGwgaGFuZGxlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByYW5nZSB9ID0gdGFyZ2V0O1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY29vcmRzQXQocmFuZ2UuaGVhZCwgcmFuZ2UuZW1wdHkgPyByYW5nZS5hc3NvYyA6IHJhbmdlLmhlYWQgPiByYW5nZS5hbmNob3IgPyAtMSA6IDEpLCBvdGhlcjtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIChvdGhlciA9IHRoaXMuY29vcmRzQXQocmFuZ2UuYW5jaG9yLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gLTEgOiAxKSkpXG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1pbihyZWN0LmxlZnQsIG90aGVyLmxlZnQpLCB0b3A6IE1hdGgubWluKHJlY3QudG9wLCBvdGhlci50b3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyZWN0LnJpZ2h0LCBvdGhlci5yaWdodCksIGJvdHRvbTogTWF0aC5tYXgocmVjdC5ib3R0b20sIG90aGVyLmJvdHRvbSkgfTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gbWFyZ2lucy5sZWZ0LCB0b3A6IHJlY3QudG9wIC0gbWFyZ2lucy50b3AsXG4gICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCArIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtYXJnaW5zLmJvdHRvbVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSB0aGlzLnZpZXcuc2Nyb2xsRE9NO1xuICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcy52aWV3LnNjcm9sbERPTSwgdGFyZ2V0UmVjdCwgcmFuZ2UuaGVhZCA8IHJhbmdlLmFuY2hvciA/IC0xIDogMSwgdGFyZ2V0LngsIHRhcmdldC55LCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueE1hcmdpbiwgb2Zmc2V0V2lkdGgpLCAtb2Zmc2V0V2lkdGgpLCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueU1hcmdpbiwgb2Zmc2V0SGVpZ2h0KSwgLW9mZnNldEhlaWdodCksIHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpO1xuICAgIH1cbiAgICBsaW5lSGFzV2lkZ2V0KHBvcykge1xuICAgICAgICBsZXQgc2NhbiA9IChjaGlsZCkgPT4gY2hpbGQuaXNXaWRnZXQoKSB8fCBjaGlsZC5jaGlsZHJlbi5zb21lKHNjYW4pO1xuICAgICAgICByZXR1cm4gc2Nhbih0aGlzLnRpbGUucmVzb2x2ZUJsb2NrKHBvcywgMSkudGlsZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lEcm9wcGVkKHRoaXMudGlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJveURyb3BwZWQodGlsZSwgcmV1c2VkKSB7XG4gICAgbGV0IHIgPSByZXVzZWQgPT09IG51bGwgfHwgcmV1c2VkID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXVzZWQuZ2V0KHRpbGUpO1xuICAgIGlmIChyICE9IDEgLyogUmV1c2VkLkZ1bGwgKi8pIHtcbiAgICAgICAgaWYgKHIgPT0gbnVsbClcbiAgICAgICAgICAgIHRpbGUuZGVzdHJveSgpO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aWxlLmNoaWxkcmVuKVxuICAgICAgICAgICAgZGVzdHJveURyb3BwZWQoY2gsIHJldXNlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmV0d2VlblVuZWRpdGFibGUocG9zKSB7XG4gICAgcmV0dXJuIHBvcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgcG9zLm5vZGUuZmlyc3RDaGlsZCAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IHBvcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIGhlYWRQb3MpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0ZXh0QmVmb3JlID0gdGV4dE5vZGVCZWZvcmUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBsZXQgdGV4dEFmdGVyID0gdGV4dE5vZGVBZnRlcihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGxldCB0ZXh0Tm9kZSA9IHRleHRCZWZvcmUgfHwgdGV4dEFmdGVyO1xuICAgIGlmICh0ZXh0QWZ0ZXIgJiYgdGV4dEJlZm9yZSAmJiB0ZXh0QWZ0ZXIubm9kZSAhPSB0ZXh0QmVmb3JlLm5vZGUpIHtcbiAgICAgICAgbGV0IHRpbGVBZnRlciA9IFRpbGUuZ2V0KHRleHRBZnRlci5ub2RlKTtcbiAgICAgICAgaWYgKCF0aWxlQWZ0ZXIgfHwgdGlsZUFmdGVyLmlzVGV4dCgpICYmIHRpbGVBZnRlci50ZXh0ICE9IHRleHRBZnRlci5ub2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgdGV4dE5vZGUgPSB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5kb2NWaWV3Lmxhc3RDb21wb3NpdGlvbkFmdGVyQ3Vyc29yKSB7XG4gICAgICAgICAgICBsZXQgdGlsZUJlZm9yZSA9IFRpbGUuZ2V0KHRleHRCZWZvcmUubm9kZSk7XG4gICAgICAgICAgICBpZiAoISghdGlsZUJlZm9yZSB8fCB0aWxlQmVmb3JlLmlzVGV4dCgpICYmIHRpbGVCZWZvcmUudGV4dCAhPSB0ZXh0QmVmb3JlLm5vZGUubm9kZVZhbHVlKSlcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHRBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvY1ZpZXcubGFzdENvbXBvc2l0aW9uQWZ0ZXJDdXJzb3IgPSB0ZXh0Tm9kZSAhPSB0ZXh0QmVmb3JlO1xuICAgIGlmICghdGV4dE5vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gaGVhZFBvcyAtIHRleHROb2RlLm9mZnNldDtcbiAgICByZXR1cm4geyBmcm9tLCB0bzogZnJvbSArIHRleHROb2RlLm5vZGUubm9kZVZhbHVlLmxlbmd0aCwgbm9kZTogdGV4dE5vZGUubm9kZSB9O1xufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uUmFuZ2UodmlldywgY2hhbmdlcywgaGVhZFBvcykge1xuICAgIGxldCBmb3VuZCA9IGZpbmRDb21wb3NpdGlvbk5vZGUodmlldywgaGVhZFBvcyk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgbm9kZTogdGV4dE5vZGUsIGZyb20sIHRvIH0gPSBmb3VuZCwgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAvLyBEb24ndCB0cnkgdG8gcHJlc2VydmUgbXVsdGktbGluZSBjb21wb3NpdGlvbnNcbiAgICBpZiAoL1tcXG5cXHJdLy50ZXN0KHRleHQpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZm91bmQuZnJvbSwgZm91bmQudG8pICE9IHRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpbnYgPSBjaGFuZ2VzLmludmVydGVkRGVzYztcbiAgICByZXR1cm4geyByYW5nZTogbmV3IENoYW5nZWRSYW5nZShpbnYubWFwUG9zKGZyb20pLCBpbnYubWFwUG9zKHRvKSwgZnJvbSwgdG8pLCB0ZXh0OiB0ZXh0Tm9kZSB9O1xufVxuZnVuY3Rpb24gbmV4dFRvVW5lZGl0YWJsZShub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA6IDApIHxcbiAgICAgICAgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDIgLyogTmV4dFRvLkFmdGVyICovIDogMCk7XG59XG5sZXQgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSA9IGNsYXNzIERlY29yYXRpb25Db21wYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZShmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGJvdW5kQ2hhbmdlKHBvcykgeyBhZGRSYW5nZShwb3MsIHBvcywgdGhpcy5jaGFuZ2VzKTsgfVxufTtcbmZ1bmN0aW9uIGZpbmRDaGFuZ2VkRGVjbyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMTtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5jbGFzcyBXcmFwcGVyQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoKSB7IH1cbiAgICBib3VuZENoYW5nZShwb3MpIHsgYWRkUmFuZ2UocG9zLCBwb3MsIHRoaXMuY2hhbmdlcyk7IH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGFuZ2VkV3JhcHBlcnMoYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IFdyYXBwZXJDb21wYXJhdG9yO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGluVW5lZGl0YWJsZShub2RlLCBpbnNpZGUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXIgJiYgY3VyICE9IGluc2lkZTsgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0b3VjaGVzQ29tcG9zaXRpb24oY2hhbmdlcywgY29tcG9zaXRpb24pIHtcbiAgICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgY29tcG9zaXRpb24udG8gJiYgdG8gPiBjb21wb3NpdGlvbi5mcm9tKVxuICAgICAgICAgICAgICAgIHRvdWNoZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hlZDtcbn1cbmNsYXNzIEJsb2NrR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBcImNtLWdhcFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTShlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuaGVpZ2h0ID09IHRoaXMuaGVpZ2h0OyB9XG4gICAgdXBkYXRlRE9NKGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgZWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuaGVpZ2h0OyB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgbGluZVBvcyA9IHBvcyAtIGxpbmUuZnJvbTtcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICBpZiAobGluZVBvcyA9PSAwKVxuICAgICAgICBiaWFzID0gMTtcbiAgICBlbHNlIGlmIChsaW5lUG9zID09IGxpbmUubGVuZ3RoKVxuICAgICAgICBiaWFzID0gLTE7XG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XG4gICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICBmcm9tID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZyb20gPSBwcmV2O1xuICAgIH1cbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudFJlY3QsIGJsb2NrLCB4LCB5KSB7XG4gICAgbGV0IGludG8gPSBNYXRoLnJvdW5kKCh4IC0gY29udGVudFJlY3QubGVmdCkgKiB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCk7XG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nICYmIGJsb2NrLmhlaWdodCA+IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgKiAxLjUpIHtcbiAgICAgICAgbGV0IHRleHRIZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodDtcbiAgICAgICAgbGV0IGxpbmUgPSBNYXRoLmZsb29yKCh5IC0gYmxvY2sudG9wIC0gKHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLSB0ZXh0SGVpZ2h0KSAqIDAuNSkgLyB0ZXh0SGVpZ2h0KTtcbiAgICAgICAgaW50byArPSBsaW5lICogdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGg7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gdmlldy5zdGF0ZS5zbGljZURvYyhibG9jay5mcm9tLCBibG9jay50byk7XG4gICAgcmV0dXJuIGJsb2NrLmZyb20gKyBmaW5kQ29sdW1uKGNvbnRlbnQsIGludG8sIHZpZXcuc3RhdGUudGFiU2l6ZSk7XG59XG5mdW5jdGlvbiBibG9ja0F0KHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpIHtcbiAgICAgICAgbGV0IGJlc3Q7XG4gICAgICAgIGZvciAobGV0IGwgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAobC5mcm9tID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGwudG8gPCBwb3MpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobC5mcm9tIDwgcG9zICYmIGwudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICBpZiAoIWJlc3QgfHwgKGwudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCAmJiAoYmVzdC50eXBlICE9IGwudHlwZSB8fCAoc2lkZSA8IDAgPyBsLmZyb20gPCBwb3MgOiBsLnRvID4gcG9zKSkpKVxuICAgICAgICAgICAgICAgIGJlc3QgPSBsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0IHx8IGxpbmU7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gYmxvY2tBdCh2aWV3LCBzdGFydC5oZWFkLCBzdGFydC5hc3NvYyB8fCAtMSk7XG4gICAgbGV0IGNvb3JkcyA9ICFpbmNsdWRlV3JhcCB8fCBsaW5lLnR5cGUgIT0gQmxvY2tUeXBlLlRleHQgfHwgISh2aWV3LmxpbmVXcmFwcGluZyB8fCBsaW5lLndpZGdldExpbmVCcmVha3MpID8gbnVsbFxuICAgICAgICA6IHZpZXcuY29vcmRzQXRQb3Moc3RhcnQuYXNzb2MgPCAwICYmIHN0YXJ0LmhlYWQgPiBsaW5lLmZyb20gPyBzdGFydC5oZWFkIC0gMSA6IHN0YXJ0LmhlYWQpO1xuICAgIGlmIChjb29yZHMpIHtcbiAgICAgICAgbGV0IGVkaXRvclJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZm9yd2FyZCA9PSAoZGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpID8gZWRpdG9yUmVjdC5yaWdodCAtIDEgOiBlZGl0b3JSZWN0LmxlZnQgKyAxLFxuICAgICAgICAgICAgeTogKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDIgfSk7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIG1vdmVCeUNoYXIodmlldywgc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCksIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhcnQsIGNoZWNrID0gbnVsbDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVZpc3VhbGx5KGxpbmUsIHNwYW5zLCBkaXJlY3Rpb24sIGN1ciwgZm9yd2FyZCksIGNoYXIgPSBtb3ZlZE92ZXI7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgY2hhciA9IFwiXFxuXCI7XG4gICAgICAgICAgICBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZShsaW5lLm51bWJlciArIChmb3J3YXJkID8gMSA6IC0xKSk7XG4gICAgICAgICAgICBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICAgICAgbmV4dCA9IHZpZXcudmlzdWFsTGluZVNpZGUobGluZSwgIWZvcndhcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgICAgIGlmICghYnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICBjaGVjayA9IGJ5KGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGVjayhjaGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ5R3JvdXAodmlldywgcG9zLCBzdGFydCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICByZXR1cm4gY2F0ID09IG5leHRDYXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVWZXJ0aWNhbGx5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgaWYgKHN0YXJ0UG9zID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBzdGFydFk7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHN0YXJ0Q29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhzdGFydFBvcywgc3RhcnQuYXNzb2MgfHwgLTEpLCBkb2NUb3AgPSB2aWV3LmRvY3VtZW50VG9wO1xuICAgIGlmIChzdGFydENvb3Jkcykge1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IHN0YXJ0Q29vcmRzLmxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgIHN0YXJ0WSA9IGRpciA8IDAgPyBzdGFydENvb3Jkcy50b3AgOiBzdGFydENvb3Jkcy5ib3R0b207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcudmlld1N0YXRlLmxpbmVCbG9ja0F0KHN0YXJ0UG9zKTtcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdvYWwgPSBNYXRoLm1pbihyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAqIChzdGFydFBvcyAtIGxpbmUuZnJvbSkpO1xuICAgICAgICBzdGFydFkgPSAoZGlyIDwgMCA/IGxpbmUudG9wIDogbGluZS5ib3R0b20pICsgZG9jVG9wO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRHb2FsID0gcmVjdC5sZWZ0ICsgZ29hbDtcbiAgICBsZXQgZGlzdCA9IGRpc3RhbmNlICE9PSBudWxsICYmIGRpc3RhbmNlICE9PSB2b2lkIDAgPyBkaXN0YW5jZSA6ICh2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodCA+PiAxKTtcbiAgICBsZXQgcG9zID0gcG9zQXRDb29yZHModmlldywgeyB4OiByZXNvbHZlZEdvYWwsIHk6IHN0YXJ0WSArIGRpc3QgKiBkaXIgfSwgZmFsc2UsIGRpcik7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLnBvcywgcG9zLmFzc29jLCB1bmRlZmluZWQsIGdvYWwpO1xufVxuZnVuY3Rpb24gc2tpcEF0b21pY1JhbmdlcyhhdG9tcywgcG9zLCBiaWFzKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgYXRvbXMpIHtcbiAgICAgICAgICAgIHNldC5iZXR3ZWVuKHBvcyAtIDEsIHBvcyArIDEsIChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBwb3MgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2lkZSA9IG1vdmVkIHx8IGJpYXMgfHwgKHBvcyAtIGZyb20gPCB0byAtIHBvcyA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNpZGUgPCAwID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHNpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb3ZlZClcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxufVxuZnVuY3Rpb24gc2tpcEF0b21zRm9yU2VsZWN0aW9uKGF0b21zLCBzZWwpIHtcbiAgICBsZXQgcmFuZ2VzID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsLnJhbmdlc1tpXSwgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHJhbmdlLmZyb20sIDApO1xuICAgICAgICAgICAgaWYgKHBvcyAhPSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBza2lwQXRvbWljUmFuZ2VzKGF0b21zLCByYW5nZS5mcm9tLCAtMSk7XG4gICAgICAgICAgICBsZXQgdG8gPSBza2lwQXRvbWljUmFuZ2VzKGF0b21zLCByYW5nZS50bywgMSk7XG4gICAgICAgICAgICBpZiAoZnJvbSAhPSByYW5nZS5mcm9tIHx8IHRvICE9IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSA9PSByYW5nZS5hbmNob3IgPyBmcm9tIDogdG8sIHJhbmdlLmZyb20gPT0gcmFuZ2UuaGVhZCA/IGZyb20gOiB0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcyA9IHNlbC5yYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHJhbmdlc1tpXSA9IHVwZGF0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcyA/IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSA6IHNlbDtcbn1cbmZ1bmN0aW9uIHNraXBBdG9tcyh2aWV3LCBvbGRQb3MsIHBvcykge1xuICAgIGxldCBuZXdQb3MgPSBza2lwQXRvbWljUmFuZ2VzKHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKSwgcG9zLmZyb20sIG9sZFBvcy5oZWFkID4gcG9zLmZyb20gPyAtMSA6IDEpO1xuICAgIHJldHVybiBuZXdQb3MgPT0gcG9zLmZyb20gPyBwb3MgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgbmV3UG9zIDwgcG9zLmZyb20gPyAxIDogLTEpO1xufVxuY2xhc3MgUG9zQXNzb2Mge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgYXNzb2MpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMsIHByZWNpc2UsIHNjYW5ZKSB7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvY1RvcCA9IGNvbnRlbnQudG9wICsgdmlldy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICBsZXQgeyB4LCB5IH0gPSBjb29yZHMsIHlPZmZzZXQgPSB5IC0gZG9jVG9wLCBibG9jaztcbiAgICAvLyBGaXJzdCBmaW5kIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gWSBwb3NpdGlvbiwgaWYgYW55LiBJZiBzY2FuWSBpc1xuICAgIC8vIGdpdmVuICh1c2VkIGZvciB2ZXJ0aWNhbCBjdXJzb3IgbW90aW9uKSwgdHJ5IHRvIHNraXAgd2lkZ2V0cyBhbmRcbiAgICAvLyBsaW5lIHBhZGRpbmcuXG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoeU9mZnNldCA8IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc0Fzc29jKDAsIDEpO1xuICAgICAgICBpZiAoeU9mZnNldCA+IHZpZXcudmlld1N0YXRlLmRvY0hlaWdodClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zQXNzb2Modmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAtMSk7XG4gICAgICAgIGJsb2NrID0gdmlldy5lbGVtZW50QXRIZWlnaHQoeU9mZnNldCk7XG4gICAgICAgIGlmIChzY2FuWSA9PSBudWxsKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChibG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0KSB7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHdlIGFyZW4ndCBsYW5kaW5nIHRoZSB0b3AvYm90dG9tIHBhZGRpbmcgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIGxldCByZWN0ID0gdmlldy5kb2NWaWV3LmNvb3Jkc0F0KHNjYW5ZIDwgMCA/IGJsb2NrLmZyb20gOiBibG9jay50bywgc2NhblkpO1xuICAgICAgICAgICAgaWYgKHJlY3QgJiYgKHNjYW5ZIDwgMCA/IHJlY3QudG9wIDw9IHlPZmZzZXQgKyBkb2NUb3AgOiByZWN0LmJvdHRvbSA+PSB5T2Zmc2V0ICsgZG9jVG9wKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFsZkxpbmUgPSB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodCAvIDI7XG4gICAgICAgIHlPZmZzZXQgPSBzY2FuWSA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgIH1cbiAgICAvLyBJZiBvdXRzaWRlIHRoZSB2aWV3cG9ydCwgcmV0dXJuIG51bGwgaWYgcHJlY2lzZT09dHJ1ZSwgYW5cbiAgICAvLyBlc3RpbWF0ZSBvdGhlcndpc2UuXG4gICAgaWYgKHZpZXcudmlld3BvcnQuZnJvbSA+PSBibG9jay50byB8fCB2aWV3LnZpZXdwb3J0LnRvIDw9IGJsb2NrLmZyb20pIHtcbiAgICAgICAgaWYgKHByZWNpc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc0Fzc29jKHBvcywgcG9zID09IGJsb2NrLmZyb20gPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChibG9jay50eXBlICE9IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICByZXR1cm4geU9mZnNldCA8IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiA/IG5ldyBQb3NBc3NvYyhibG9jay5mcm9tLCAxKSA6IG5ldyBQb3NBc3NvYyhibG9jay50bywgLTEpO1xuICAgIC8vIEhlcmUgd2Uga25vdyB3ZSdyZSBpbiBhIGxpbmUsIHNvIHJ1biB0aGUgbG9naWMgZm9yIGlubGluZSBsYXlvdXRcbiAgICBsZXQgbGluZSA9IHZpZXcuZG9jVmlldy5saW5lQXQoYmxvY2suZnJvbSwgMik7XG4gICAgaWYgKCFsaW5lIHx8IGxpbmUubGVuZ3RoICE9IGJsb2NrLmxlbmd0aClcbiAgICAgICAgbGluZSA9IHZpZXcuZG9jVmlldy5saW5lQXQoYmxvY2suZnJvbSwgLTIpO1xuICAgIHJldHVybiBwb3NBdENvb3Jkc0lubGluZSh2aWV3LCBsaW5lLCBibG9jay5mcm9tLCB4LCB5KTtcbn1cbi8vIFNjYW4gdGhyb3VnaCB0aGUgcmVjdGFuZ2xlcyBmb3IgdGhlIGNvbnRlbnQgb2YgYSB0aWxlLCBmaW5kaW5nIHRoZVxuLy8gb25lIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLCBwcmVmZXJpbmcgY2xvc2VuZXNzIGluIFkgb3ZlclxuLy8gY2xvc2VuZXNzIGluIFguXG4vL1xuLy8gSWYgdGhpcyBpcyBhIHRleHQgdGlsZSwgZ28gY2hhcmFjdGVyLWJ5LWNoYXJhY3Rlci4gRm9yIGxpbmUgb3IgbWFya1xuLy8gdGlsZXMsIGNoZWNrIGVhY2ggbm9uLXBvaW50LXdpZGdldCBjaGlsZCwgYW5kIGRlc2NlbmQgdGV4dCBvciBtYXJrXG4vLyB0aWxlcyB3aXRoIGEgcmVjdXJzaXZlIGNhbGwuXG4vL1xuLy8gRm9yIG5vbi13cmFwcGVkLCBwdXJlbHkgbGVmdC10by1yaWdodCB0ZXh0LCB0aGlzIGNvdWxkIHVzZSBhIGJpbmFyeVxuLy8gc2VhcmNoLiBCdXQgYmVjYXVzZSB0aGlzIHNlZW1zIHRvIGJlIGZhc3QgZW5vdWdoLCBmb3IgaG93IG9mdGVuIGl0XG4vLyBpcyBjYWxsZWQsIHRoZXJlJ3Mgbm90IGN1cnJlbnRseSBhIHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9uIGZvclxuLy8gdGhhdC5cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzSW5saW5lKHZpZXcsIHRpbGUsIG9mZnNldCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0ID0gLTEsIGNsb3Nlc3RSZWN0ID0gbnVsbDtcbiAgICBsZXQgZHhDbG9zZXN0ID0gMWU5LCBkeUNsb3Nlc3QgPSAxZTk7XG4gICAgbGV0IHJvd1RvcCA9IHksIHJvd0JvdCA9IHk7XG4gICAgbGV0IGNoZWNrUmVjdHMgPSAocmVjdHMsIGluZGV4KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgZHggPSByZWN0LmxlZnQgPiB4ID8gcmVjdC5sZWZ0IC0geCA6IHJlY3QucmlnaHQgPCB4ID8geCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICAgICAgbGV0IGR5ID0gcmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogcmVjdC5ib3R0b20gPCB5ID8geSAtIHJlY3QuYm90dG9tIDogMDtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVjdGFuZ2xlIGlzIGluIHRoZSBjdXJyZW50IHJvd1xuICAgICAgICAgICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICAgICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbG9zZXN0IDwgMCB8fCAoZHkgLSBkeUNsb3Nlc3QgfHwgZHggLSBkeENsb3Nlc3QpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0ID49IDAgJiYgZHlDbG9zZXN0ICYmIGR4Q2xvc2VzdCA8IGR4ICYmXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RSZWN0LnRvcCA8PSByb3dCb3QgLSAyICYmIGNsb3Nlc3RSZWN0LmJvdHRvbSA+PSByb3dUb3AgKyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHJvYWN0aXZlbHkgc2V0IGR5IHRvIDAgaWYgdGhlIGN1cnJlbnQgbWF0Y2ggaXMgaW4gdGhpcyByb3cuXG4gICAgICAgICAgICAgICAgICAgIGR5Q2xvc2VzdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgICAgICAgICAgICBkeUNsb3Nlc3QgPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRpbGUuaXNUZXh0KCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWxlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayh0aWxlLnRleHQsIGkpO1xuICAgICAgICAgICAgY2hlY2tSZWN0cyh0ZXh0UmFuZ2UodGlsZS5kb20sIGksIG5leHQpLmdldENsaWVudFJlY3RzKCksIGkpO1xuICAgICAgICAgICAgaWYgKCFkeENsb3Nlc3QgJiYgIWR5Q2xvc2VzdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGkgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZnRlciA9ICh4ID4gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyKSA9PSAoZGlyQXQodmlldywgY2xvc2VzdCArIG9mZnNldCkgPT0gRGlyZWN0aW9uLkxUUik7XG4gICAgICAgIHJldHVybiBhZnRlciA/IG5ldyBQb3NBc3NvYyhvZmZzZXQgKyBmaW5kQ2x1c3RlckJyZWFrKHRpbGUudGV4dCwgY2xvc2VzdCksIC0xKSA6IG5ldyBQb3NBc3NvYyhvZmZzZXQgKyBjbG9zZXN0LCAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghdGlsZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc0Fzc29jKG9mZnNldCwgMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlsZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGlsZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncyAmIDQ4IC8qIFRpbGVGbGFnLlBvaW50V2lkZ2V0ICovKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHJlY3RzID0gKGNoaWxkLmRvbS5ub2RlVHlwZSA9PSAxID8gY2hpbGQuZG9tIDogdGV4dFJhbmdlKGNoaWxkLmRvbSwgMCwgY2hpbGQubGVuZ3RoKSkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGNoZWNrUmVjdHMocmVjdHMsIGkpO1xuICAgICAgICAgICAgaWYgKCFkeENsb3Nlc3QgJiYgIWR5Q2xvc2VzdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aWxlLmNoaWxkcmVuW2Nsb3Nlc3RdLCBpbm5lck9mZiA9IHRpbGUucG9zQmVmb3JlKGlubmVyLCBvZmZzZXQpO1xuICAgICAgICBpZiAoaW5uZXIuaXNDb21wb3NpdGUoKSB8fCBpbm5lci5pc1RleHQoKSlcbiAgICAgICAgICAgIHJldHVybiBwb3NBdENvb3Jkc0lubGluZSh2aWV3LCBpbm5lciwgaW5uZXJPZmYsIE1hdGgubWF4KGNsb3Nlc3RSZWN0LmxlZnQsIE1hdGgubWluKGNsb3Nlc3RSZWN0LnJpZ2h0LCB4KSksIHkpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSAoeCA+IChjbG9zZXN0UmVjdC5sZWZ0ICsgY2xvc2VzdFJlY3QucmlnaHQpIC8gMikgPT0gKGRpckF0KHZpZXcsIGNsb3Nlc3QgKyBvZmZzZXQpID09IERpcmVjdGlvbi5MVFIpO1xuICAgICAgICByZXR1cm4gYWZ0ZXIgPyBuZXcgUG9zQXNzb2MoaW5uZXJPZmYgKyBpbm5lci5sZW5ndGgsIC0xKSA6IG5ldyBQb3NBc3NvYyhpbm5lck9mZiwgMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlyQXQodmlldywgcG9zKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICByZXR1cm4gc3BhbnNbQmlkaVNwYW4uZmluZCh2aWV3LmJpZGlTcGFucyhsaW5lKSwgcG9zIC0gbGluZS5mcm9tLCAtMSwgMSldLmRpcjtcbn1cblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCB2aWV3KSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpbmVTZXBhcmF0b3IgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBhcHBlbmQodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gdGV4dDtcbiAgICB9XG4gICAgbGluZUJyZWFrKCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gTGluZUJyZWFrUGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIHJlYWRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgY3VyKTtcbiAgICAgICAgICAgIGxldCBvbGRMZW4gPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZWFkTm9kZShjdXIpO1xuICAgICAgICAgICAgbGV0IHRpbGUgPSBUaWxlLmdldChjdXIpLCBuZXh0ID0gY3VyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0aWxlID09PSBudWxsIHx8IHRpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbGUuYnJlYWtBZnRlcikgJiYgIW5leHQgJiYgcGFyZW50ICE9IHRoaXMudmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHRUaWxlID0gVGlsZS5nZXQobmV4dCk7XG4gICAgICAgICAgICBpZiAoKHRpbGUgJiYgbmV4dFRpbGUgPyB0aWxlLmJyZWFrQWZ0ZXIgOlxuICAgICAgICAgICAgICAgICh0aWxlID8gdGlsZS5icmVha0FmdGVyIDogaXNCbG9ja0VsZW1lbnQoY3VyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQmxvY2tFbGVtZW50KG5leHQpICYmIChjdXIubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICh0aWxlID09PSBudWxsIHx8IHRpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbGUuaXNXaWRnZXQoKSkpICYmIHRoaXMudGV4dC5sZW5ndGggPiBvbGRMZW4pKSAmJlxuICAgICAgICAgICAgICAgICFpc0VtcHR5VG9FbmQobmV4dCwgZW5kKSlcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFkVGV4dE5vZGUobm9kZSkge1xuICAgICAgICBsZXQgdGV4dCA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHBvaW50Lm9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSAwLCByZSA9IHRoaXMubGluZVNlcGFyYXRvciA/IG51bGwgOiAvXFxyXFxuP3xcXG4vZzs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gLTEsIGJyZWFrU2l6ZSA9IDEsIG07XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKHRoaXMubGluZVNlcGFyYXRvciwgb2ZmKTtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobSA9IHJlLmV4ZWModGV4dCkpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmQodGV4dC5zbGljZShvZmYsIG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaykpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgaWYgKGJyZWFrU2l6ZSA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgcG9pbnQucG9zID4gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnBvcyAtPSBicmVha1NpemUgLSAxO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEJyZWFrICsgYnJlYWtTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROb2RlKG5vZGUpIHtcbiAgICAgICAgbGV0IHRpbGUgPSBUaWxlLmdldChub2RlKTtcbiAgICAgICAgbGV0IGZyb21WaWV3ID0gdGlsZSAmJiB0aWxlLm92ZXJyaWRlRE9NVGV4dDtcbiAgICAgICAgaWYgKGZyb21WaWV3ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50SW5zaWRlKG5vZGUsIGZyb21WaWV3Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbVZpZXcuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5saW5lQnJlYWspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChpLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kUG9pbnRCZWZvcmUobm9kZSwgbmV4dCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzW3BvaW50Lm9mZnNldF0gPT0gbmV4dClcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5kUG9pbnRJbnNpZGUobm9kZSwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyA/IHBvaW50Lm5vZGUgPT0gbm9kZSA6IG5vZGUuY29udGFpbnMocG9pbnQubm9kZSkpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIChpc0F0RW5kKG5vZGUsIHBvaW50Lm5vZGUsIHBvaW50Lm9mZnNldCkgPyBsZW5ndGggOiAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0F0RW5kKHBhcmVudCwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIW5vZGUgfHwgb2Zmc2V0IDwgbWF4T2Zmc2V0KG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRW1wdHlUb0VuZChub2RlLCBlbmQpIHtcbiAgICBsZXQgd2lkZ2V0cztcbiAgICBmb3IgKDs7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChub2RlID09IGVuZCB8fCAhbm9kZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgdmlldyA9IFRpbGUuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoISh2aWV3ID09PSBudWxsIHx8IHZpZXcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZXcuaXNXaWRnZXQoKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh2aWV3KVxuICAgICAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbXSkpLnB1c2godmlldyk7XG4gICAgfVxuICAgIGlmICh3aWRnZXRzKVxuICAgICAgICBmb3IgKGxldCB3IG9mIHdpZGdldHMpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZSA9IHcub3ZlcnJpZGVET01UZXh0O1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlID09PSBudWxsIHx8IG92ZXJyaWRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBET01Qb2ludCB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnBvcyA9IC0xO1xuICAgIH1cbn1cblxuY2xhc3MgRE9NQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydCwgZW5kLCB0eXBlT3Zlcikge1xuICAgICAgICB0aGlzLnR5cGVPdmVyID0gdHlwZU92ZXI7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gc3RhcnQgPiAtMTtcbiAgICAgICAgbGV0IHsgaW1wcmVjaXNlSGVhZDogaUhlYWQsIGltcHJlY2lzZUFuY2hvcjogaUFuY2hvciB9ID0gdmlldy5kb2NWaWV3O1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSAmJiBzdGFydCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgY2hhbmdlcyB3aGVuIHRoZSBlZGl0b3IgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgPiAtMSAmJiAodGhpcy5ib3VuZHMgPSBkb21Cb3VuZHNBcm91bmQodmlldy5kb2NWaWV3LnRpbGUsIHN0YXJ0LCBlbmQsIDApKSkge1xuICAgICAgICAgICAgbGV0IHNlbFBvaW50cyA9IGlIZWFkIHx8IGlBbmNob3IgPyBbXSA6IHNlbGVjdGlvblBvaW50cyh2aWV3KTtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRE9NUmVhZGVyKHNlbFBvaW50cywgdmlldyk7XG4gICAgICAgICAgICByZWFkZXIucmVhZFJhbmdlKHRoaXMuYm91bmRzLnN0YXJ0RE9NLCB0aGlzLmJvdW5kcy5lbmRET00pO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gcmVhZGVyLnRleHQ7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IHNlbGVjdGlvbkZyb21Qb2ludHMoc2VsUG9pbnRzLCB0aGlzLmJvdW5kcy5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb21TZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAgICAgbGV0IGhlYWQgPSBpSGVhZCAmJiBpSGVhZC5ub2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgaUhlYWQub2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWRcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICBsZXQgYW5jaG9yID0gaUFuY2hvciAmJiBpQW5jaG9yLm5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgaUFuY2hvci5vZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5hbmNob3JOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3JcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGlPUyB3aWxsIHJlZnVzZSB0byBzZWxlY3QgdGhlIGJsb2NrIGdhcHMgd2hlbiBkb2luZ1xuICAgICAgICAgICAgLy8gc2VsZWN0LWFsbC5cbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHB1dCB0aGUgc2VsZWN0aW9uICppbnNpZGUqIHRoZW0sIGNvbmZ1c2luZ1xuICAgICAgICAgICAgLy8gcG9zRnJvbURPTVxuICAgICAgICAgICAgbGV0IHZwID0gdmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pb3MgfHwgYnJvd3Nlci5jaHJvbWUpICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgaGVhZCAhPSBhbmNob3IgJiZcbiAgICAgICAgICAgICAgICAodnAuZnJvbSA+IDAgfHwgdnAudG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihoZWFkLCBhbmNob3IpLCB0byA9IE1hdGgubWF4KGhlYWQsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9mZkZyb20gPSB2cC5mcm9tIC0gZnJvbSwgb2ZmVG8gPSB2cC50byAtIHRvO1xuICAgICAgICAgICAgICAgIGlmICgob2ZmRnJvbSA9PSAwIHx8IG9mZkZyb20gPT0gMSB8fCBmcm9tID09IDApICYmIChvZmZUbyA9PSAwIHx8IG9mZlRvID09IC0xIHx8IHRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IC0xICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIHRoaXMubmV3U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmVwbGFjZVJhbmdlKEVkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRvbUJvdW5kc0Fyb3VuZCh0aWxlLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgaWYgKHRpbGUuaXNDb21wb3NpdGUoKSkge1xuICAgICAgICBsZXQgZnJvbUkgPSAtMSwgZnJvbVN0YXJ0ID0gLTEsIHRvSSA9IC0xLCB0b0VuZCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0LCBwcmV2RW5kID0gb2Zmc2V0OyBpIDwgdGlsZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGlsZS5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJvdW5kc0Fyb3VuZChjaGlsZCwgZnJvbSwgdG8sIHBvcyk7XG4gICAgICAgICAgICBpZiAoZW5kID49IGZyb20gJiYgZnJvbUkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRpbGUuZG9tKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RW5kID0gZW5kO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tU3RhcnQsIHRvOiB0b0VuZCA8IDAgPyBvZmZzZXQgKyB0aWxlLmxlbmd0aCA6IHRvRW5kLFxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRpbGUuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aWxlLmRvbS5maXJzdENoaWxkLFxuICAgICAgICAgICAgZW5kRE9NOiB0b0kgPCB0aWxlLmNoaWxkcmVuLmxlbmd0aCAmJiB0b0kgPj0gMCA/IHRpbGUuY2hpbGRyZW5bdG9JXS5kb20gOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpbGUuaXNUZXh0KCkpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2Zmc2V0LCB0bzogb2Zmc2V0ICsgdGlsZS5sZW5ndGgsIHN0YXJ0RE9NOiB0aWxlLmRvbSwgZW5kRE9NOiB0aWxlLmRvbS5uZXh0U2libGluZyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2UodmlldywgZG9tQ2hhbmdlKSB7XG4gICAgbGV0IGNoYW5nZTtcbiAgICBsZXQgeyBuZXdTZWwgfSA9IGRvbUNoYW5nZSwgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgbGFzdEtleSA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA+IERhdGUubm93KCkgLSAxMDAgPyB2aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgOiAtMTtcbiAgICBpZiAoZG9tQ2hhbmdlLmJvdW5kcykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gZG9tQ2hhbmdlLmJvdW5kcztcbiAgICAgICAgbGV0IHByZWZlcnJlZFBvcyA9IHNlbC5mcm9tLCBwcmVmZXJyZWRTaWRlID0gbnVsbDtcbiAgICAgICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZCAob3IsIG9uXG4gICAgICAgIC8vIEFuZHJvaWQsIHdoZW4gc29tZXRoaW5nIHdhcyBkZWxldGVkKVxuICAgICAgICBpZiAobGFzdEtleSA9PT0gOCB8fCBicm93c2VyLmFuZHJvaWQgJiYgZG9tQ2hhbmdlLnRleHQubGVuZ3RoIDwgdG8gLSBmcm9tKSB7XG4gICAgICAgICAgICBwcmVmZXJyZWRQb3MgPSBzZWwudG87XG4gICAgICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlmZiA9IGZpbmREaWZmKHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCBMaW5lQnJlYWtQbGFjZWhvbGRlciksIGRvbUNoYW5nZS50ZXh0LCBwcmVmZXJyZWRQb3MgLSBmcm9tLCBwcmVmZXJyZWRTaWRlKTtcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBpbnNlcnRzIHR3byBuZXdsaW5lcyB3aGVuIHByZXNzaW5nIHNoaWZ0LWVudGVyIGF0IHRoZVxuICAgICAgICAgICAgLy8gZW5kIG9mIGEgbGluZS4gRG9tQ2hhbmdlIGRyb3BzIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBsYXN0S2V5ID09IDEzICYmXG4gICAgICAgICAgICAgICAgZGlmZi50b0IgPT0gZGlmZi5mcm9tICsgMiAmJiBkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKSA9PSBMaW5lQnJlYWtQbGFjZWhvbGRlciArIExpbmVCcmVha1BsYWNlaG9sZGVyKVxuICAgICAgICAgICAgICAgIGRpZmYudG9CLS07XG4gICAgICAgICAgICBjaGFuZ2UgPSB7IGZyb206IGZyb20gKyBkaWZmLmZyb20sIHRvOiBmcm9tICsgZGlmZi50b0EsXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBUZXh0Lm9mKGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpLnNwbGl0KExpbmVCcmVha1BsYWNlaG9sZGVyKSkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgKCF2aWV3Lmhhc0ZvY3VzICYmIHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpIHx8IHNhbWVTZWxQb3MobmV3U2VsLCBzZWwpKSkge1xuICAgICAgICBuZXdTZWwgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSAmJiAhbmV3U2VsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjaGFuZ2UgJiYgZG9tQ2hhbmdlLnR5cGVPdmVyICYmICFzZWwuZW1wdHkgJiYgbmV3U2VsICYmIG5ld1NlbC5tYWluLmVtcHR5KSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgc2VsLnRvKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkIC0gMSAmJlxuICAgICAgICAvXlxcLiA/JC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpICYmIHZpZXcuY29udGVudERPTS5nZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiKSA9PSBcIm9mZlwiKSB7XG4gICAgICAgIC8vIERldGVjdCBpbnNlcnQtcGVyaW9kLW9uLWRvdWJsZS1zcGFjZSBNYWMgYW5kIEFuZHJvaWQgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJlZ3VsYXIgc3BhY2UgaW5zZXJ0LlxuICAgICAgICBpZiAobmV3U2VsICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDIpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgXCIgXCIpXSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlICYmIGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiZcbiAgICAgICAgKGNoYW5nZS5mcm9tICE9IHNlbC5mcm9tIHx8IGNoYW5nZS50byAhPSBzZWwudG8pICYmXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbnNpZGUgdGhlIHNlbGVjdGlvbiBhbmQgY292ZXJzIG1vc3Qgb2YgaXQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHNlbGVjdGlvbiByZXBsYWNlICh3aXRoIGlkZW50aWNhbCBjaGFyYWN0ZXJzIGF0XG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5zdGF0ZS5kb2MubGluZUF0KHNlbC5mcm9tKS50byA8IHNlbC50byAmJiB2aWV3LmRvY1ZpZXcubGluZUhhc1dpZGdldChzZWwudG8pICYmXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5pbnNlcnRpbmdUZXh0QXQgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgLy8gRm9yIGEgY3Jvc3MtbGluZSBpbnNlcnRpb24sIENocm9tZSBhbmQgU2FmYXJpIHdpbGwgY3J1ZGVseSB0YWtlXG4gICAgICAgIC8vIHRoZSB0ZXh0IG9mIHRoZSBsaW5lIGFmdGVyIHRoZSBzZWxlY3Rpb24sIGZsYXR0ZW5pbmcgYW55XG4gICAgICAgIC8vIHdpZGdldHMsIGFuZCBtb3ZlIGl0IGludG8gdGhlIGpvaW5lZCBsaW5lLiBUaGlzIHRyaWVzIHRvIGRldGVjdFxuICAgICAgICAvLyBzdWNoIGEgc2l0dWF0aW9uLCBhbmQgcmVwbGFjZXMgdGhlIGNoYW5nZSB3aXRoIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIHJlcGxhY2Ugb2YgdGhlIHRleHQgcHJvdmlkZWQgYnkgdGhlIGJlZm9yZWlucHV0IGV2ZW50LlxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS50b1RleHQodmlldy5pbnB1dFN0YXRlLmluc2VydGluZ1RleHQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIuY2hyb21lICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgJiZcbiAgICAgICAgY2hhbmdlLmluc2VydC50b1N0cmluZygpID09IFwiXFxuIFwiICYmIHZpZXcubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIC8vIEluIENocm9tZSwgaWYgeW91IGluc2VydCBhIHNwYWNlIGF0IHRoZSBzdGFydCBvZiBhIHdyYXBwZWRcbiAgICAgICAgLy8gbGluZSwgaXQgd2lsbCBhY3R1YWxseSBpbnNlcnQgYSBuZXdsaW5lIGFuZCBhIHNwYWNlLCBjYXVzaW5nIGFcbiAgICAgICAgLy8gYm9ndXMgbmV3IGxpbmUgdG8gYmUgY3JlYXRlZCBpbiBDb2RlTWlycm9yICgjOTY4KVxuICAgICAgICBpZiAobmV3U2VsKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgbmV3U2VsLCBsYXN0S2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFzYW1lU2VsUG9zKG5ld1NlbCwgc2VsKSkge1xuICAgICAgICBsZXQgc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZSwgdXNlckV2ZW50ID0gXCJzZWxlY3RcIjtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luID09IFwic2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgdXNlckV2ZW50ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW47XG4gICAgICAgICAgICBpZiAodXNlckV2ZW50ID09IFwic2VsZWN0LnBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICBuZXdTZWwgPSBza2lwQXRvbXNGb3JTZWxlY3Rpb24odmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpLCBuZXdTZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgc2Nyb2xsSW50b1ZpZXcsIHVzZXJFdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2VJbm5lcih2aWV3LCBjaGFuZ2UsIG5ld1NlbCwgbGFzdEtleSA9IC0xKSB7XG4gICAgaWYgKGJyb3dzZXIuaW9zICYmIHZpZXcuaW5wdXRTdGF0ZS5mbHVzaElPU0tleShjaGFuZ2UpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAvLyBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IGZpcmUgcmVhc29uYWJsZSBrZXkgZXZlbnRzIGZvciBlbnRlcixcbiAgICAvLyBiYWNrc3BhY2UsIG9yIGRlbGV0ZS4gU28gdGhpcyBkZXRlY3RzIGNoYW5nZXMgdGhhdCBsb29rIGxpa2VcbiAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgLy8gZXZlbnRzLiAoU29tZSBvZiB0aGVzZSBrZXlzIGFyZSBhbHNvIGhhbmRsZWQgYnkgYmVmb3JlaW5wdXRcbiAgICAvLyBldmVudHMgYW5kIHRoZSBwZW5kaW5nQW5kcm9pZEtleSBtZWNoYW5pc20sIGJ1dCB0aGF0J3Mgbm90XG4gICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiZcbiAgICAgICAgKChjaGFuZ2UudG8gPT0gc2VsLnRvICYmXG4gICAgICAgICAgICAvLyBHQm9hcmQgd2lsbCBzb21ldGltZXMgcmVtb3ZlIGEgc3BhY2UgaXQganVzdCBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gYWZ0ZXIgYSBjb21wbGV0aW9uIHdoZW4geW91IHByZXNzIGVudGVyXG4gICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gfHwgY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gLSAxICYmIHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIHNlbC5mcm9tKSA9PSBcIiBcIikgJiZcbiAgICAgICAgICAgIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDEgJiYgY2hhbmdlLmluc2VydC5saW5lcyA9PSAyICYmXG4gICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRW50ZXJcIiwgMTMpKSB8fFxuICAgICAgICAgICAgKChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgY2hhbmdlLnRvID09IHNlbC50byAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICAgICAgbGFzdEtleSA9PSA4ICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoIDwgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gJiYgY2hhbmdlLnRvID4gc2VsLmhlYWQpICYmXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkJhY2tzcGFjZVwiLCA4KSkgfHxcbiAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICsgMSAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkRlbGV0ZVwiLCA0NikpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHRleHQgPSBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZysrO1xuICAgIGxldCBkZWZhdWx0VHI7XG4gICAgbGV0IGRlZmF1bHRJbnNlcnQgPSAoKSA9PiBkZWZhdWx0VHIgfHwgKGRlZmF1bHRUciA9IGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkpO1xuICAgIGlmICghdmlldy5zdGF0ZS5mYWNldChpbnB1dEhhbmRsZXIpLnNvbWUoaCA9PiBoKHZpZXcsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8sIHRleHQsIGRlZmF1bHRJbnNlcnQpKSlcbiAgICAgICAgdmlldy5kaXNwYXRjaChkZWZhdWx0SW5zZXJ0KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0SW5zZXJ0KHZpZXcsIGNoYW5nZSwgbmV3U2VsKSB7XG4gICAgbGV0IHRyLCBzdGFydFN0YXRlID0gdmlldy5zdGF0ZSwgc2VsID0gc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbiwgaW5BdG9taWMgPSAtMTtcbiAgICBpZiAoY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tIDwgc2VsLmZyb20gfHwgY2hhbmdlLmZyb20gPiBzZWwudG8pIHtcbiAgICAgICAgbGV0IHNpZGUgPSBjaGFuZ2UuZnJvbSA8IHNlbC5mcm9tID8gLTEgOiAxLCBwb3MgPSBzaWRlIDwgMCA/IHNlbC5mcm9tIDogc2VsLnRvO1xuICAgICAgICBsZXQgbW92ZWQgPSBza2lwQXRvbWljUmFuZ2VzKHN0YXJ0U3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKSwgcG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKGNoYW5nZS5mcm9tID09IG1vdmVkKVxuICAgICAgICAgICAgaW5BdG9taWMgPSBtb3ZlZDtcbiAgICB9XG4gICAgaWYgKGluQXRvbWljID4gLTEpIHtcbiAgICAgICAgdHIgPSB7XG4gICAgICAgICAgICBjaGFuZ2VzOiBjaGFuZ2UsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCwgLTEpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgKCFuZXdTZWwgfHwgbmV3U2VsLm1haW4uZW1wdHkgJiYgbmV3U2VsLm1haW4uZnJvbSA9PSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKSAmJlxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICBsZXQgYmVmb3JlID0gc2VsLmZyb20gPCBjaGFuZ2UuZnJvbSA/IHN0YXJ0U3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIGNoYW5nZS5mcm9tKSA6IFwiXCI7XG4gICAgICAgIGxldCBhZnRlciA9IHNlbC50byA+IGNoYW5nZS50byA/IHN0YXJ0U3RhdGUuc2xpY2VEb2MoY2hhbmdlLnRvLCBzZWwudG8pIDogXCJcIjtcbiAgICAgICAgdHIgPSBzdGFydFN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odmlldy5zdGF0ZS50b1RleHQoYmVmb3JlICsgY2hhbmdlLmluc2VydC5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHZpZXcuc3RhdGUubGluZUJyZWFrKSArIGFmdGVyKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICBsZXQgbWFpblNlbCA9IG5ld1NlbCAmJiBuZXdTZWwubWFpbi50byA8PSBjaGFuZ2VzLm5ld0xlbmd0aCA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgdG8gYXBwbHkgYSBjb21wb3NpdGlvbiBjaGFuZ2UgdG8gYWxsIGN1cnNvcnNcbiAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgfHwgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSkgJiZcbiAgICAgICAgICAgIGNoYW5nZS50byA8PSBzZWwudG8gKyAxMCAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSwgY29tcG9zaXRpb24gPSBuZXdTZWwgJiYgZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBuZXdTZWwubWFpbi5oZWFkKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBkTGVuID0gY2hhbmdlLmluc2VydC5sZW5ndGggLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB7IGZyb206IGNvbXBvc2l0aW9uLmZyb20sIHRvOiBjb21wb3NpdGlvbi50byAtIGRMZW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bztcbiAgICAgICAgICAgIHRyID0gc3RhcnRTdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiByYW5nZS50byA9PSBzZWwudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXMsIHJhbmdlOiBtYWluU2VsIHx8IHJhbmdlLm1hcChjaGFuZ2VzKSB9O1xuICAgICAgICAgICAgICAgIGxldCB0byA9IHJhbmdlLnRvIC0gb2Zmc2V0LCBmcm9tID0gdG8gLSByZXBsYWNlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pICE9IHJlcGxhY2VkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgc2FtZSBub2RlIHdvcmsgd2l0aG91dCBhYm9ydGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGlvbiwgc28gY3Vyc29ycyBpbiB0aGUgY29tcG9zaXRpb24gcmFuZ2UgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgICAgIHRvID49IGNvbXBvc2l0aW9uUmFuZ2UuZnJvbSAmJiBmcm9tIDw9IGNvbXBvc2l0aW9uUmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlQ2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyh7IGZyb20sIHRvLCBpbnNlcnQ6IGNoYW5nZS5pbnNlcnQgfSksIHNlbE9mZiA9IHJhbmdlLnRvIC0gc2VsLnRvO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6ICFtYWluU2VsID8gcmFuZ2UubWFwKHJhbmdlQ2hhbmdlcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWF4KDAsIG1haW5TZWwuYW5jaG9yICsgc2VsT2ZmKSwgTWF0aC5tYXgoMCwgbWFpblNlbC5oZWFkICsgc2VsT2ZmKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ciA9IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogbWFpblNlbCAmJiBzdGFydFN0YXRlLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobWFpblNlbClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHVzZXJFdmVudCA9IFwiaW5wdXQudHlwZVwiO1xuICAgIGlmICh2aWV3LmNvbXBvc2luZyB8fFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB1c2VyRXZlbnQgKz0gXCIuY29tcG9zZVwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgIHVzZXJFdmVudCArPSBcIi5zdGFydFwiO1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnRTdGF0ZS51cGRhdGUodHIsIHsgdXNlckV2ZW50LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICAgIGxldCBtaW5MZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBmcm9tID0gMDtcbiAgICB3aGlsZSAoZnJvbSA8IG1pbkxlbiAmJiBhLmNoYXJDb2RlQXQoZnJvbSkgPT0gYi5jaGFyQ29kZUF0KGZyb20pKVxuICAgICAgICBmcm9tKys7XG4gICAgaWYgKGZyb20gPT0gbWluTGVuICYmIGEubGVuZ3RoID09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdG9BID0gYS5sZW5ndGgsIHRvQiA9IGIubGVuZ3RoO1xuICAgIHdoaWxlICh0b0EgPiAwICYmIHRvQiA+IDAgJiYgYS5jaGFyQ29kZUF0KHRvQSAtIDEpID09IGIuY2hhckNvZGVBdCh0b0IgLSAxKSkge1xuICAgICAgICB0b0EtLTtcbiAgICAgICAgdG9CLS07XG4gICAgfVxuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIGZyb20gLSBNYXRoLm1pbih0b0EsIHRvQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gdG9BICsgYWRqdXN0IC0gZnJvbTtcbiAgICB9XG4gICAgaWYgKHRvQSA8IGZyb20gJiYgYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0EgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0IgPSBmcm9tICsgKHRvQiAtIHRvQSk7XG4gICAgICAgIHRvQSA9IGZyb207XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvQiA8IGZyb20pIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9CID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9BID0gZnJvbSArICh0b0EgLSB0b0IpO1xuICAgICAgICB0b0IgPSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4geyBmcm9tLCB0b0EsIHRvQiB9O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uUG9pbnRzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBsZXQgeyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGFuY2hvck5vZGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkpO1xuICAgICAgICBpZiAoZm9jdXNOb2RlICE9IGFuY2hvck5vZGUgfHwgZm9jdXNPZmZzZXQgIT0gYW5jaG9yT2Zmc2V0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IERPTVBvaW50KGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkZyb21Qb2ludHMocG9pbnRzLCBiYXNlKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvciA9IHBvaW50c1swXS5wb3MsIGhlYWQgPSBwb2ludHMubGVuZ3RoID09IDIgPyBwb2ludHNbMV0ucG9zIDogYW5jaG9yO1xuICAgIHJldHVybiBhbmNob3IgPiAtMSAmJiBoZWFkID4gLTEgPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciArIGJhc2UsIGhlYWQgKyBiYXNlKSA6IG51bGw7XG59XG5mdW5jdGlvbiBzYW1lU2VsUG9zKHNlbGVjdGlvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA9PSBzZWxlY3Rpb24ubWFpbi5oZWFkICYmIHJhbmdlLmFuY2hvciA9PSBzZWxlY3Rpb24ubWFpbi5hbmNob3I7XG59XG5cbmNsYXNzIElucHV0U3RhdGUge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSAwO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZW5hYmxlZCAoPi0xKSwgdGFiIHByZXNzZXMgYXJlIG5vdCBnaXZlbiB0byBrZXkgaGFuZGxlcnMsXG4gICAgICAgIGxlYXZpbmcgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yLiBJZiA+MCwgdGhlIG1vZGUgZXhwaXJlc1xuICAgICAgICBhdCB0aGF0IHRpbWVzdGFtcCwgYW5kIGFueSBvdGhlciBrZXlwcmVzcyBjbGVhcnMgaXQuXG4gICAgICAgIEVzYyBlbmFibGVzIHRlbXBvcmFyeSB0YWIgZm9jdXMgbW9kZSBmb3IgdHdvIHNlY29uZHMgd2hlbiBub3RcbiAgICAgICAgb3RoZXJ3aXNlIGhhbmRsZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFiRm9jdXNNb2RlID0gLTE7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb250ZXh0TWVudSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIC0xIG1lYW5zIG5vdCBpbiBhIGNvbXBvc2l0aW9uLiBPdGhlcndpc2UsIHRoaXMgY291bnRzIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgY2hhbmdlcyBtYWRlIGR1cmluZyB0aGUgY29tcG9zaXRpb24uIFRoZSBjb3VudCBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGF2b2lkIHRyZWF0aW5nIHRoZSBzdGFydCBzdGF0ZSBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBhbnlcbiAgICAgICAgLy8gY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSwgYXMgcGFydCBvZiB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gLTE7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBuZXh0IGNoYW5nZSBzaG91bGQgYmUgbWFya2VkIGFzIHN0YXJ0aW5nIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiAobnVsbCBtZWFucyBubyBjb21wb3NpdGlvbiwgdHJ1ZSBtZWFucyBuZXh0IGlzIHRoZVxuICAgICAgICAvLyBmaXJzdCwgZmFsc2UgbWVhbnMgZmlyc3QgaGFzIGFscmVhZHkgYmVlbiBtYXJrZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gY29tcG9zaXRpb24pXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgICAgIC8vIEVuZCB0aW1lIG9mIHRoZSBwcmV2aW91cyBjb21wb3NpdGlvblxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XG4gICAgICAgIC8vIFVzZWQgaW4gYSBrbHVkZ2UgdG8gZGV0ZWN0IHdoZW4gYW4gRW50ZXIga2V5cHJlc3Mgc2hvdWxkIGJlXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgY29tcG9zaXRpb24gb24gU2FmYXJpLCB3aGljaCBmaXJlcyBldmVudHNcbiAgICAgICAgLy8gaW4gdGhlIHdyb25nIG9yZGVyXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgdG8gY2F0ZWdvcml6ZSBjaGFuZ2VzIGFzIHBhcnQgb2YgYSBjb21wb3NpdGlvbiwgZXZlbiB3aGVuXG4gICAgICAgIC8vIHRoZSBtdXRhdGlvbiBldmVudHMgZmlyZSBzaG9ydGx5IGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAvLyBTZXQgYnkgYmVmb3JlaW5wdXQsIHVzZWQgaW4gRE9NIGNoYW5nZSByZWFkZXJcbiAgICAgICAgdGhpcy5pbnNlcnRpbmdUZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5pbnNlcnRpbmdUZXh0QXQgPSAwO1xuICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgLy8gV2hlbiBhIGRyYWcgZnJvbSB0aGUgZWRpdG9yIGlzIGFjdGl2ZSwgdGhpcyBwb2ludHMgYXQgdGhlIHJhbmdlXG4gICAgICAgIC8vIGJlaW5nIGRyYWdnZWQuXG4gICAgICAgIHRoaXMuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGlmaWVkRm9jdXNlZCA9IHZpZXcuaGFzRm9jdXM7XG4gICAgICAgIC8vIE9uIFNhZmFyaSBhZGRpbmcgYW4gaW5wdXQgZXZlbnQgaGFuZGxlciBzb21laG93IHByZXZlbnRzIGFuXG4gICAgICAgIC8vIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuIHlvdSBwcmVzcyBlbnRlci5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpKVxuICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pXG4gICAgICAgICAgICBmaXJlZm94Q29weUN1dEhhY2sodmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50QmVsb25nc1RvRWRpdG9yKHRoaXMudmlldywgZXZlbnQpIHx8IHRoaXMuaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PSBcImtleWRvd25cIiAmJiB0aGlzLmtleWRvd24oZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy52aWV3LnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy5ydW5IYW5kbGVycyhldmVudC50eXBlLCBldmVudCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnJ1bkhhbmRsZXJzKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICB9XG4gICAgcnVuSGFuZGxlcnModHlwZSwgZXZlbnQpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBvYnNlcnZlciBvZiBoYW5kbGVycy5vYnNlcnZlcnMpXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIodGhpcy52aWV3LCBldmVudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGhhbmRsZXJzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKHRoaXMudmlldywgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnN1cmVIYW5kbGVycyhwbHVnaW5zKSB7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IGNvbXB1dGVIYW5kbGVycyhwbHVnaW5zKSwgcHJldiA9IHRoaXMuaGFuZGxlcnMsIGRvbSA9IHRoaXMudmlldy5jb250ZW50RE9NO1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGhhbmRsZXJzKVxuICAgICAgICAgICAgaWYgKHR5cGUgIT0gXCJzY3JvbGxcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXNzaXZlID0gIWhhbmRsZXJzW3R5cGVdLmhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcHJldlt0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzICYmIHBhc3NpdmUgIT0gIWV4aXN0cy5oYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50LCB7IHBhc3NpdmUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gcHJldilcbiAgICAgICAgICAgIGlmICh0eXBlICE9IFwic2Nyb2xsXCIgJiYgIWhhbmRsZXJzW3R5cGVdKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgfVxuICAgIGtleWRvd24oZXZlbnQpIHtcbiAgICAgICAgLy8gTXVzdCBhbHdheXMgcnVuLCBldmVuIGlmIGEgY3VzdG9tIGhhbmRsZXIgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA5ICYmIHRoaXMudGFiRm9jdXNNb2RlID4gLTEgJiYgKCF0aGlzLnRhYkZvY3VzTW9kZSB8fCBEYXRlLm5vdygpIDw9IHRoaXMudGFiRm9jdXNNb2RlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy50YWJGb2N1c01vZGUgPiAwICYmIGV2ZW50LmtleUNvZGUgIT0gMjcgJiYgbW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMudGFiRm9jdXNNb2RlID0gLTE7XG4gICAgICAgIC8vIENocm9tZSBmb3IgQW5kcm9pZCB1c3VhbGx5IGRvZXNuJ3QgZmlyZSBwcm9wZXIga2V5IGV2ZW50cywgYnV0XG4gICAgICAgIC8vIG9jY2FzaW9uYWxseSBkb2VzLCB1c3VhbGx5IHN1cnJvdW5kZWQgYnkgYSBidW5jaCBvZiBjb21wbGljYXRlZFxuICAgICAgICAvLyBjb21wb3NpdGlvbiBjaGFuZ2VzLiBXaGVuIGFuIGVudGVyIG9yIGJhY2tzcGFjZSBrZXkgZXZlbnQgaXNcbiAgICAgICAgLy8gc2VlbiwgaG9sZCBvZmYgb24gaGFuZGxpbmcgRE9NIGV2ZW50cyBmb3IgYSBiaXQsIGFuZCB0aGVuXG4gICAgICAgIC8vIGRpc3BhdGNoIGl0LlxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lICYmICFldmVudC5zeW50aGV0aWMgJiZcbiAgICAgICAgICAgIChldmVudC5rZXlDb2RlID09IDEzIHx8IGV2ZW50LmtleUNvZGUgPT0gOCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkoZXZlbnQua2V5LCBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgRW50ZXIgb24gaU9TIG1ha2VzIHRoZVxuICAgICAgICAvLyB2aXJ0dWFsIGtleWJvYXJkIGdldCBzdHVjayBpbiB0aGUgd3JvbmcgKGxvd2VyY2FzZSlcbiAgICAgICAgLy8gc3RhdGUuIFNvIHdlIGxldCBpdCBnbyB0aHJvdWdoLCBhbmQgdGhlbiwgaW5cbiAgICAgICAgLy8gYXBwbHlET01DaGFuZ2UsIG5vdGlmeSBrZXkgaGFuZGxlcnMgb2YgaXQgYW5kIHJlc2V0IHRvXG4gICAgICAgIC8vIHRoZSBzdGF0ZSB0aGV5IHByb2R1Y2UuXG4gICAgICAgIGxldCBwZW5kaW5nO1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAgICAgICAoKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkua2V5Q29kZSA9PSBldmVudC5rZXlDb2RlKSkgJiYgIWV2ZW50LmN0cmxLZXkgfHxcbiAgICAgICAgICAgICAgICBFbWFjc3lQZW5kaW5nS2V5cy5pbmRleE9mKGV2ZW50LmtleSkgPiAtMSAmJiBldmVudC5jdHJsS2V5ICYmICFldmVudC5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHBlbmRpbmcgfHwgZXZlbnQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2hJT1NLZXkoKSwgMjUwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmx1c2hJT1NLZXkoY2hhbmdlKSB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLnBlbmRpbmdJT1NLZXk7XG4gICAgICAgIGlmICgha2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYW4gYXV0b2NvcnJlY3Rpb24gYmVmb3JlIEVudGVyXG4gICAgICAgIGlmIChrZXkua2V5ID09IFwiRW50ZXJcIiAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPCBjaGFuZ2UudG8gJiYgL15cXFMrJC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEtleSh0aGlzLnZpZXcuY29udGVudERPTSwga2V5LmtleSwga2V5LmtleUNvZGUsIGtleSBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQgPyBrZXkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIS9ea2V5Ly50ZXN0KGV2ZW50LnR5cGUpIHx8IGV2ZW50LnN5bnRoZXRpYylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgICAgIC8vIE9uIHNvbWUgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gY29uZmlybSBjaGFyYWN0ZXIgc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCxcbiAgICAgICAgLy8gY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZSBzb21ldGltZXMgZW1pdHRlZCBpbiB0aGVcbiAgICAgICAgLy8gd3Jvbmcgb3JkZXIuIFRoZSBrZXkgZXZlbnQgc2hvdWxkIHN0aWxsIGJlIGlnbm9yZWQsIGV2ZW4gd2hlblxuICAgICAgICAvLyBpdCBoYXBwZW5zIGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudC5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFicm93c2VyLmlvcyAmJiB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPCAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0TW91c2VTZWxlY3Rpb24obW91c2VTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG1vdXNlU2VsZWN0aW9uO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkQ29udGVudCAmJiB1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZENvbnRlbnQgPSB0aGlzLmRyYWdnZWRDb250ZW50Lm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiaW5kSGFuZGxlcihwbHVnaW4sIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHBsdWdpbiwgZXZlbnQsIHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUhhbmRsZXJzKHBsdWdpbnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiByZWNvcmQodHlwZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0W3R5cGVdIHx8IChyZXN1bHRbdHlwZV0gPSB7IG9ic2VydmVyczogW10sIGhhbmRsZXJzOiBbXSB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgbGV0IHNwZWMgPSBwbHVnaW4uc3BlYywgaGFuZGxlcnMgPSBzcGVjICYmIHNwZWMucGx1Z2luLmRvbUV2ZW50SGFuZGxlcnMsIG9ic2VydmVycyA9IHNwZWMgJiYgc3BlYy5wbHVnaW4uZG9tRXZlbnRPYnNlcnZlcnM7XG4gICAgICAgIGlmIChoYW5kbGVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQodHlwZSkuaGFuZGxlcnMucHVzaChiaW5kSGFuZGxlcihwbHVnaW4udmFsdWUsIGYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gb2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBvYnNlcnZlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5vYnNlcnZlcnMucHVzaChiaW5kSGFuZGxlcihwbHVnaW4udmFsdWUsIGYpKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgcmVjb3JkKHR5cGUpLmhhbmRsZXJzLnB1c2goaGFuZGxlcnNbdHlwZV0pO1xuICAgIGZvciAobGV0IHR5cGUgaW4gb2JzZXJ2ZXJzKVxuICAgICAgICByZWNvcmQodHlwZSkub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXJzW3R5cGVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgUGVuZGluZ0tleXMgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIGtleUNvZGU6IDgsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50QmFja3dhcmRcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0UGFyYWdyYXBoXCIgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydExpbmVCcmVha1wiIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIGtleUNvZGU6IDQ2LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEZvcndhcmRcIiB9XG5dO1xuY29uc3QgRW1hY3N5UGVuZGluZ0tleXMgPSBcImR0aGtvXCI7XG4vLyBLZXkgY29kZXMgZm9yIG1vZGlmaWVyIGtleXNcbmNvbnN0IG1vZGlmaWVyQ29kZXMgPSBbMTYsIDE3LCAxOCwgMjAsIDkxLCA5MiwgMjI0LCAyMjVdO1xuY29uc3QgZHJhZ1Njcm9sbE1hcmdpbiA9IDY7XG5mdW5jdGlvbiBkcmFnU2Nyb2xsU3BlZWQoZGlzdCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBkaXN0KSAqIDAuNyArIDg7XG59XG5mdW5jdGlvbiBkaXN0KGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoYS5jbGllbnRYIC0gYi5jbGllbnRYKSwgTWF0aC5hYnMoYS5jbGllbnRZIC0gYi5jbGllbnRZKSk7XG59XG5jbGFzcyBNb3VzZVNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnRFdmVudCwgc3R5bGUsIG11c3RTZWxlY3QpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGFydEV2ZW50ID0gc3RhcnRFdmVudDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBtdXN0U2VsZWN0O1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gc3RhcnRFdmVudDtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzID0gc2Nyb2xsYWJsZVBhcmVudHModmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hdG9tcyA9IHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKTtcbiAgICAgICAgbGV0IGRvYyA9IHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5leHRlbmQgPSBzdGFydEV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gdmlldy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucykgJiYgYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCkgJiYgZ2V0Q2xpY2tUeXBlKHN0YXJ0RXZlbnQpID09IDEgPyBudWxsIDogZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uLCBpbW1lZGlhdGVseSBhcHBseSB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIHN0YXJ0aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoZXZlbnQpO1xuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nIHx8IHRoaXMuZHJhZ2dpbmcgPT0gbnVsbCAmJiBkaXN0KHRoaXMuc3RhcnRFdmVudCwgZXZlbnQpIDwgMTApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50ID0gZXZlbnQpO1xuICAgICAgICBsZXQgc3ggPSAwLCBzeSA9IDA7XG4gICAgICAgIGxldCBsZWZ0ID0gMCwgdG9wID0gMCwgcmlnaHQgPSB0aGlzLnZpZXcud2luLmlubmVyV2lkdGgsIGJvdHRvbSA9IHRoaXMudmlldy53aW4uaW5uZXJIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudHMueClcbiAgICAgICAgICAgICh7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLnNjcm9sbFBhcmVudHMueC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudHMueSlcbiAgICAgICAgICAgICh7IHRvcCwgYm90dG9tIH0gPSB0aGlzLnNjcm9sbFBhcmVudHMueS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGxldCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCAtIG1hcmdpbnMubGVmdCA8PSBsZWZ0ICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN4ID0gLWRyYWdTY3JvbGxTcGVlZChsZWZ0IC0gZXZlbnQuY2xpZW50WCk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFggKyBtYXJnaW5zLnJpZ2h0ID49IHJpZ2h0IC0gZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN4ID0gZHJhZ1Njcm9sbFNwZWVkKGV2ZW50LmNsaWVudFggLSByaWdodCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRZIC0gbWFyZ2lucy50b3AgPD0gdG9wICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN5ID0gLWRyYWdTY3JvbGxTcGVlZCh0b3AgLSBldmVudC5jbGllbnRZKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WSArIG1hcmdpbnMuYm90dG9tID49IGJvdHRvbSAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeSA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRZIC0gYm90dG9tKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZChzeCwgc3kpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZCgwLCAwKTtcbiAgICAgICAgbGV0IGRvYyA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24gPSB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIHNldFNjcm9sbFNwZWVkKHN4LCBzeSkge1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiBzeCwgeTogc3kgfTtcbiAgICAgICAgaWYgKHN4IHx8IHN5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zY3JvbGwoKSwgNTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsaW5nID4gLTEpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zY3JvbGxpbmcpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGwoKSB7XG4gICAgICAgIGxldCB7IHgsIHkgfSA9IHRoaXMuc2Nyb2xsU3BlZWQ7XG4gICAgICAgIGlmICh4ICYmIHRoaXMuc2Nyb2xsUGFyZW50cy54KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMueC5zY3JvbGxMZWZ0ICs9IHg7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSAmJiB0aGlzLnNjcm9sbFBhcmVudHMueSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzLnkuc2Nyb2xsVG9wICs9IHk7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCB8fCB5KVxuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5zY3JvbGxCeSh4LCB5KTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgIH1cbiAgICBzZWxlY3QoZXZlbnQpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsZWN0aW9uID0gc2tpcEF0b21zRm9yU2VsZWN0aW9uKHRoaXMuYXRvbXMsIHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSkpO1xuICAgICAgICBpZiAodGhpcy5tdXN0U2VsZWN0IHx8ICFzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3QucG9pbnRlclwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikpKVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGUudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgMjApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChkcmFnTW92ZXNTZWxlY3Rpb24kMSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gIWV2ZW50LmFsdEtleSA6ICFldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgeyBtYWluIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9uIGJvdW5kYXJ5IGNsaWNrcywgY2hlY2sgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSB0aGVcbiAgICAvLyBzZWxlY3Rpb24ncyBjbGllbnQgcmVjdGFuZ2xlc1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICBpZiAoIXNlbCB8fCBzZWwucmFuZ2VDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgcmVjdHMgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgPj0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgcmVjdC50b3AgPD0gZXZlbnQuY2xpZW50WSAmJiByZWN0LmJvdHRvbSA+PSBldmVudC5jbGllbnRZKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQsIHRpbGU7IG5vZGUgIT0gdmlldy5jb250ZW50RE9NOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fFxuICAgICAgICAgICAgKCh0aWxlID0gVGlsZS5nZXQobm9kZSkpICYmIHRpbGUuaXNXaWRnZXQoKSAmJiAhdGlsZS5pc0hpZGRlbiAmJiB0aWxlLndpZGdldC5pZ25vcmVFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgaGFuZGxlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG9ic2VydmVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJ4oCUYWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGJyb3dzZXIuaW9zICYmIGJyb3dzZXIud2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcpIHtcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gdGV4dEZpbHRlcihzdGF0ZSwgZmFjZXQsIHRleHQpIHtcbiAgICBmb3IgKGxldCBmaWx0ZXIgb2Ygc3RhdGUuZmFjZXQoZmFjZXQpKVxuICAgICAgICB0ZXh0ID0gZmlsdGVyKHRleHQsIHN0YXRlKTtcbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgaW5wdXQpIHtcbiAgICBpbnB1dCA9IHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkSW5wdXRGaWx0ZXIsIGlucHV0KTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgIT0gbnVsbCAmJiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3RMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBzdGF0ZS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dC5saW5lKGkrKyk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgbGluZS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICB9KTtcbn1cbm9ic2VydmVycy5zY3JvbGwgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcDtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xufTtcbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpO1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3ICYmIHZpZXcuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgIT0gMClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IERhdGUubm93KCkgKyAyMDAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5vYnNlcnZlcnMudG91Y2hzdGFydCA9ICh2aWV3LCBlKSA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5vYnNlcnZlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPiBEYXRlLm5vdygpIC0gMjAwMClcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJZ25vcmUgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICBsZXQgc3R5bGUgPSBudWxsO1xuICAgIGZvciAobGV0IG1ha2VTdHlsZSBvZiB2aWV3LnN0YXRlLmZhY2V0KG1vdXNlU2VsZWN0aW9uU3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gbWFrZVN0eWxlKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghc3R5bGUgJiYgZXZlbnQuYnV0dG9uID09IDApXG4gICAgICAgIHN0eWxlID0gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGxldCBtdXN0Rm9jdXMgPSAhdmlldy5oYXNGb2N1cztcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnN0YXJ0TW91c2VTZWxlY3Rpb24obmV3IE1vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50LCBzdHlsZSwgbXVzdEZvY3VzKSk7XG4gICAgICAgIGlmIChtdXN0Rm9jdXMpXG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHZpZXcuY29udGVudERPTSk7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUgJiYgIWFjdGl2ZS5jb250YWlucyh2aWV3LmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUuYmx1cigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxldCBtb3VzZVNlbCA9IHZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG1vdXNlU2VsKSB7XG4gICAgICAgICAgICBtb3VzZVNlbC5zdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gbW91c2VTZWwuZHJhZ2dpbmcgPT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiByYW5nZUZvckNsaWNrKHZpZXcsIHBvcywgYmlhcywgdHlwZSkge1xuICAgIGlmICh0eXBlID09IDEpIHsgLy8gU2luZ2xlIGNsaWNrXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgeyAvLyBEb3VibGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIGdyb3VwQXQodmlldy5zdGF0ZSwgcG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIFRyaXBsZSBjbGlja1xuICAgICAgICBsZXQgdmlzdWFsID0gdmlldy5kb2NWaWV3LmxpbmVBdChwb3MsIGJpYXMpLCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0U3RhcnQgOiBsaW5lLmZyb20sIHRvID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogbGluZS50bztcbiAgICAgICAgaWYgKHRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoICYmIHRvID09IGxpbmUudG8pXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5jb25zdCBCYWRNb3VzZURldGFpbCA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xubGV0IGxhc3RNb3VzZURvd24gPSBudWxsLCBsYXN0TW91c2VEb3duQ291bnQgPSAwLCBsYXN0TW91c2VEb3duVGltZSA9IDA7XG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcbiAgICBpZiAoIUJhZE1vdXNlRGV0YWlsKVxuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93biwgbGFzdFRpbWUgPSBsYXN0TW91c2VEb3duVGltZTtcbiAgICBsYXN0TW91c2VEb3duID0gZXZlbnQ7XG4gICAgbGFzdE1vdXNlRG93blRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBsYXN0TW91c2VEb3duQ291bnQgPSAhbGFzdCB8fCAobGFzdFRpbWUgPiBEYXRlLm5vdygpIC0gNDAwICYmIE1hdGguYWJzKGxhc3QuY2xpZW50WCAtIGV2ZW50LmNsaWVudFgpIDwgMiAmJlxuICAgICAgICBNYXRoLmFicyhsYXN0LmNsaWVudFkgLSBldmVudC5jbGllbnRZKSA8IDIpID8gKGxhc3RNb3VzZURvd25Db3VudCArIDEpICUgMyA6IDE7XG59XG5mdW5jdGlvbiBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdmlldy5wb3NBbmRTaWRlQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKSwgdHlwZSA9IGdldENsaWNrVHlwZShldmVudCk7XG4gICAgbGV0IHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQucG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHN0YXJ0LnBvcyk7XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIGV4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB2aWV3LnBvc0FuZFNpZGVBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpLCByZW1vdmVkO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBjdXIucG9zLCBjdXIuYXNzb2MsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBjdXIucG9zICYmICFleHRlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgc3RhcnQucG9zLCBzdGFydC5hc3NvYywgdHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihzdGFydFJhbmdlLmZyb20sIHJhbmdlLmZyb20pLCB0byA9IE1hdGgubWF4KHN0YXJ0UmFuZ2UudG8sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGZyb20gPCByYW5nZS5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5yZXBsYWNlUmFuZ2Uoc3RhcnRTZWwubWFpbi5leHRlbmQocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlICYmIHR5cGUgPT0gMSAmJiBzdGFydFNlbC5yYW5nZXMubGVuZ3RoID4gMSAmJiAocmVtb3ZlZCA9IHJlbW92ZVJhbmdlQXJvdW5kKHN0YXJ0U2VsLCBjdXIucG9zKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJhbmdlQXJvdW5kKHNlbCwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgICBpZiAoZnJvbSA8PSBwb3MgJiYgdG8gPj0gcG9zKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5zbGljZSgwLCBpKS5jb25jYXQoc2VsLnJhbmdlcy5zbGljZShpICsgMSkpLCBzZWwubWFpbkluZGV4ID09IGkgPyAwIDogc2VsLm1haW5JbmRleCAtIChzZWwubWFpbkluZGV4ID4gaSA/IDEgOiAwKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uOiB7IG1haW46IHJhbmdlIH0gfSA9IHZpZXcuc3RhdGU7XG4gICAgaWYgKGV2ZW50LnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgICAgbGV0IHRpbGUgPSB2aWV3LmRvY1ZpZXcudGlsZS5uZWFyZXN0KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmICh0aWxlICYmIHRpbGUuaXNXaWRnZXQoKSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSB0aWxlLnBvc0F0U3RhcnQsIHRvID0gZnJvbSArIHRpbGUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHsgaW5wdXRTdGF0ZSB9ID0gdmlldztcbiAgICBpZiAoaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IHRydWU7XG4gICAgaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IHJhbmdlO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkT3V0cHV0RmlsdGVyLCB2aWV3LnN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5mdW5jdGlvbiBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgZGlyZWN0KSB7XG4gICAgdGV4dCA9IHRleHRGaWx0ZXIodmlldy5zdGF0ZSwgY2xpcGJvYXJkSW5wdXRGaWx0ZXIsIHRleHQpO1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCB7IGRyYWdnZWRDb250ZW50IH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgbGV0IGRlbCA9IGRpcmVjdCAmJiBkcmFnZ2VkQ29udGVudCAmJiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpXG4gICAgICAgID8geyBmcm9tOiBkcmFnZ2VkQ29udGVudC5mcm9tLCB0bzogZHJhZ2dlZENvbnRlbnQudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIHVzZXJFdmVudDogZGVsID8gXCJtb3ZlLmRyb3BcIiA6IFwiaW5wdXQuZHJvcFwiXG4gICAgfSk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdGV4dCA9IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgZGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgdGFyZ2V0LnNlbGVjdGlvbkVuZCA9IHRleHQubGVuZ3RoO1xuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXSwgcmFuZ2VzID0gW10sIGxpbmV3aXNlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGRvIGEgbGluZS13aXNlIGNvcHlcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChsaW5lLnRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXB0byA9IGxpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dDogdGV4dEZpbHRlcihzdGF0ZSwgY2xpcGJvYXJkT3V0cHV0RmlsdGVyLCBjb250ZW50LmpvaW4oc3RhdGUubGluZUJyZWFrKSksIHJhbmdlcywgbGluZXdpc2UgfTtcbn1cbmxldCBsYXN0TGluZXdpc2VDb3B5ID0gbnVsbDtcbmhhbmRsZXJzLmNvcHkgPSBoYW5kbGVycy5jdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBvdXRzaWRlIHRoaXMgZWRpdG9yLCBkb24ndCBpbnRlcmNlcHQuXG4gICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gYSBwYXJlbnQgZWRpdG9yIChsaWtlIFByb3NlTWlycm9yKSBzZWxlY3RzIGNvbnRlbnQgdGhhdFxuICAgIC8vIHNwYW5zIG11bHRpcGxlIGVsZW1lbnRzIGluY2x1ZGluZyB0aGlzIENvZGVNaXJyb3IuIFRoZSBjb3B5IGV2ZW50IG1heVxuICAgIC8vIGJ1YmJsZSB0aHJvdWdoIENvZGVNaXJyb3IgKGUuZy4gd2hlbiBDb2RlTWlycm9yIGlzIHRoZSBmaXJzdCBvciB0aGUgbGFzdFxuICAgIC8vIGVsZW1lbnQgaW4gdGhlIHNlbGVjdGlvbiksIGJ1dCB3ZSBzaG91bGQgbGV0IHRoZSBwYXJlbnQgaGFuZGxlIGl0LlxuICAgIGxldCBkb21TZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICBpZiAoZG9tU2VsICYmICFoYXNTZWxlY3Rpb24odmlldy5jb250ZW50RE9NLCBkb21TZWwpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgdGV4dCwgcmFuZ2VzLCBsaW5ld2lzZSB9ID0gY29waWVkUmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgaWYgKCF0ZXh0ICYmICFsaW5ld2lzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxhc3RMaW5ld2lzZUNvcHkgPSBsaW5ld2lzZSA/IHRleHQgOiBudWxsO1xuICAgIGlmIChldmVudC50eXBlID09IFwiY3V0XCIgJiYgIXZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VzLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IFwiZGVsZXRlLmN1dFwiXG4gICAgICAgIH0pO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5jb25zdCBpc0ZvY3VzQ2hhbmdlID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG5mdW5jdGlvbiBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHN0YXRlLCBmb2N1cykge1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgZ2V0RWZmZWN0IG9mIHN0YXRlLmZhY2V0KGZvY3VzQ2hhbmdlRWZmZWN0KSkge1xuICAgICAgICBsZXQgZWZmZWN0ID0gZ2V0RWZmZWN0KHN0YXRlLCBmb2N1cyk7XG4gICAgICAgIGlmIChlZmZlY3QpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoID8gc3RhdGUudXBkYXRlKHsgZWZmZWN0cywgYW5ub3RhdGlvbnM6IGlzRm9jdXNDaGFuZ2Uub2YodHJ1ZSkgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsZXQgZm9jdXMgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICBpZiAoZm9jdXMgIT0gdmlldy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgbGV0IHRyID0gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbih2aWV3LnN0YXRlLCBmb2N1cyk7XG4gICAgICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9XG4gICAgfSwgMTApO1xufVxub2JzZXJ2ZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFdoZW4gZm9jdXNpbmcgcmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiwgbW92ZSBpdCBiYWNrIHRvIHdoZXJlIGl0IHdhc1xuICAgIGlmICghdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICYmICh2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCB8fCB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQpKSB7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0O1xuICAgIH1cbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5vYnNlcnZlcnMuYmx1ciA9IHZpZXcgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuY2xlYXJTZWxlY3Rpb25SYW5nZSgpO1xuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbm9ic2VydmVycy5jb21wb3NpdGlvbnN0YXJ0ID0gb2JzZXJ2ZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpXG4gICAgICAgIHJldHVybjsgLy8gQ29tcG9zaXRpb24gaGFuZGxlZCBieSBlZGl0IGNvbnRleHRcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPT0gbnVsbClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAvLyBGSVhNRSBwb3NzaWJseSBzZXQgYSB0aW1lb3V0IHRvIGNsZWFyIGl0IGFnYWluIG9uIEFuZHJvaWRcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgfVxufTtcbm9ic2VydmVycy5jb21wb3NpdGlvbmVuZCA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3Lm9ic2VydmVyLmVkaXRDb250ZXh0KVxuICAgICAgICByZXR1cm47IC8vIENvbXBvc2l0aW9uIGhhbmRsZWQgYnkgZWRpdCBjb250ZXh0XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSB0cnVlO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSB2aWV3Lm9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID4gMDtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCkge1xuICAgICAgICAvLyBEZWxheSBmbHVzaGluZyBmb3IgYSBiaXQgb24gQW5kcm9pZCBiZWNhdXNlIGl0J2xsIG9mdGVuIGZpcmUgYVxuICAgICAgICAvLyBidW5jaCBvZiBjb250cmFkaWN0b3J5IGNoYW5nZXMgaW4gYSByb3cgYXQgZW5kIG9mIGNvbXBvc2l0b25cbiAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBwZW5kaW5nIHJlY29yZHMsIHNjaGVkdWxlIGEgZmx1c2guXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5vYnNlcnZlci5mbHVzaCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgbWFrZSBzdXJlIHRoYXQsIGlmIG5vIGNoYW5nZXMgY29tZSBpbiBzb29uLCB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gdmlldyBpcyBjbGVhcmVkLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCAmJiB2aWV3LmRvY1ZpZXcuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbm9ic2VydmVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Q29udGV4dE1lbnUgPSBEYXRlLm5vdygpO1xufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlID09IFwiaW5zZXJ0VGV4dFwiIHx8IGV2ZW50LmlucHV0VHlwZSA9PSBcImluc2VydENvbXBvc2l0aW9uVGV4dFwiKSB7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5pbnNlcnRpbmdUZXh0ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmluc2VydGluZ1RleHRBdCA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIC8vIEluIEVkaXRDb250ZXh0IG1vZGUsIHdlIG11c3QgaGFuZGxlIGluc2VydFJlcGxhY2VtZW50VGV4dCBldmVudHNcbiAgICAvLyBkaXJlY3RseSwgdG8gbWFrZSBzcGVsbCBjaGVja2luZyBjb3JyZWN0aW9ucyB3b3JrXG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSA9PSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiICYmIHZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSAoX2EgPSBldmVudC5kYXRhVHJhbnNmZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSwgcmFuZ2VzID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG4gICAgICAgIGlmICh0ZXh0ICYmIHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByID0gcmFuZ2VzWzBdO1xuICAgICAgICAgICAgbGV0IGZyb20gPSB2aWV3LnBvc0F0RE9NKHIuc3RhcnRDb250YWluZXIsIHIuc3RhcnRPZmZzZXQpLCB0byA9IHZpZXcucG9zQXRET00oci5lbmRDb250YWluZXIsIHIuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGFwcGx5RE9NQ2hhbmdlSW5uZXIodmlldywgeyBmcm9tLCB0bywgaW5zZXJ0OiB2aWV3LnN0YXRlLnRvVGV4dCh0ZXh0KSB9LCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJlY2F1c2UgQ2hyb21lIEFuZHJvaWQgZG9lc24ndCBmaXJlIHVzZWZ1bCBrZXkgZXZlbnRzLCB1c2VcbiAgICAvLyBiZWZvcmVpbnB1dCB0byBkZXRlY3QgYmFja3NwYWNlIChhbmQgcG9zc2libHkgZW50ZXIgYW5kIGRlbGV0ZSxcbiAgICAvLyBidXQgdGhvc2UgdXN1YWxseSBkb24ndCBldmVuIHNlZW0gdG8gZmlyZSBiZWZvcmVpbnB1dCBldmVudHMgYXRcbiAgICAvLyB0aGUgbW9tZW50KSBhbmQgZmFrZSBhIGtleSBldmVudCBmb3IgaXQuXG4gICAgLy9cbiAgICAvLyAocHJldmVudERlZmF1bHQgb24gYmVmb3JlaW5wdXQsIHRob3VnaCBzdXBwb3J0ZWQgaW4gdGhlIHNwZWMsXG4gICAgLy8gc2VlbXMgdG8gZG8gbm90aGluZyBhdCBhbGwgb24gQ2hyb21lKS5cbiAgICBsZXQgcGVuZGluZztcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkICYmIChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmlucHV0VHlwZSA9PSBldmVudC5pbnB1dFR5cGUpKSkge1xuICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShwZW5kaW5nLmtleSwgcGVuZGluZy5rZXlDb2RlKTtcbiAgICAgICAgaWYgKHBlbmRpbmcua2V5ID09IFwiQmFja3NwYWNlXCIgfHwgcGVuZGluZy5rZXkgPT0gXCJEZWxldGVcIikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0Vmlld0hlaWdodCA9ICgoX2IgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gQmFja3NwYWNpbmcgbmVhciB1bmVkaXRhYmxlIG5vZGVzIG9uIENocm9tZSBBbmRyb2lkIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlcyB0aGUgdmlydHVhbCBrZXlib2FyZC4gVGhpcyB0cmllcyB0byBjcnVkZWx5IGRldGVjdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYW5kIHJlZm9jdXMgdG8gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgaWYgKCgoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKSA+IHN0YXJ0Vmlld0hlaWdodCArIDEwICYmIHZpZXcuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJyb3dzZXIuaW9zICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIpIHtcbiAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBET00gY2hhbmdlcyAoYW5kIGJlZm9yZWlucHV0KSBoYXBwZW4gX2JlZm9yZV9cbiAgICAgICAgLy8gdGhlIGtleSBldmVudCBmb3IgY3RybC1kIG9uIGlPUyB3aGVuIHVzaW5nIGFuIGV4dGVybmFsXG4gICAgICAgIC8vIGtleWJvYXJkLlxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIH1cbiAgICAvLyBTYWZhcmkgd2lsbCBvY2Nhc2lvbmFsbHkgZm9yZ2V0IHRvIGZpcmUgY29tcG9zaXRpb25lbmQgYXQgdGhlIGVuZCBvZiBhIGRlYWQta2V5IGNvbXBvc2l0aW9uXG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImluc2VydFRleHRcIiAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvYnNlcnZlcnMuY29tcG9zaXRpb25lbmQodmlldywgZXZlbnQpLCAyMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhcHBsaWVkRmlyZWZveEhhY2sgPSAvKkBfX1BVUkVfXyovbmV3IFNldDtcbi8vIEluIEZpcmVmb3gsIHdoZW4gY3V0L2NvcHkgaGFuZGxlcnMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCwgdGhhdFxuLy8gc29tZWhvdyBhdm9pZHMgYSBidWcgd2hlcmUgdGhvc2UgZXZlbnRzIGFyZW4ndCBmaXJlZCB3aGVuIHRoZVxuLy8gc2VsZWN0aW9uIGlzIGVtcHR5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy8xMDgyXG4vLyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTk1OTYxXG5mdW5jdGlvbiBmaXJlZm94Q29weUN1dEhhY2soZG9jKSB7XG4gICAgaWYgKCFhcHBsaWVkRmlyZWZveEhhY2suaGFzKGRvYykpIHtcbiAgICAgICAgYXBwbGllZEZpcmVmb3hIYWNrLmFkZChkb2MpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgKCkgPT4geyB9KTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgKCkgPT4geyB9KTtcbiAgICB9XG59XG5cbmNvbnN0IHdyYXBwaW5nV2hpdGVTcGFjZSA9IFtcInByZS13cmFwXCIsIFwibm9ybWFsXCIsIFwicHJlLWxpbmVcIiwgXCJicmVhay1zcGFjZXNcIl07XG4vLyBVc2VkIHRvIHRyYWNrLCBkdXJpbmcgdXBkYXRlSGVpZ2h0LCBpZiBhbnkgYWN0dWFsIGhlaWdodHMgY2hhbmdlZFxubGV0IGhlaWdodENoYW5nZUZsYWcgPSBmYWxzZTtcbmZ1bmN0aW9uIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZygpIHsgaGVpZ2h0Q2hhbmdlRmxhZyA9IGZhbHNlOyB9XG5jbGFzcyBIZWlnaHRPcmFjbGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kb2MgPSBUZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgYW4gZW50aXJlIGxpbmUgKGxpbmUtaGVpZ2h0KVxuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IDc7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IDE0OyAvLyBUaGUgaGVpZ2h0IG9mIHRoZSBhY3R1YWwgZm9udCAoZm9udC1zaXplKVxuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSAzMDtcbiAgICB9XG4gICAgaGVpZ2h0Rm9yR2FwKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuZG9jLmxpbmVBdCh0bykubnVtYmVyIC0gdGhpcy5kb2MubGluZUF0KGZyb20pLm51bWJlciArIDE7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIGxpbmVzICs9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoKHRvIC0gZnJvbSkgLSAobGluZXMgKiB0aGlzLmxpbmVMZW5ndGggKiAwLjUpKSAvIHRoaXMubGluZUxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0ICogbGluZXM7XG4gICAgfVxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gTWF0aC5tYXgoMSwgdGhpcy5saW5lTGVuZ3RoIC0gNSkpKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xuICAgIH1cbiAgICBzZXREb2MoZG9jKSB7IHRoaXMuZG9jID0gZG9jOyByZXR1cm4gdGhpczsgfVxuICAgIG11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSkge1xuICAgICAgICByZXR1cm4gKHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTEpICE9IHRoaXMubGluZVdyYXBwaW5nO1xuICAgIH1cbiAgICBtdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpIHtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVIZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGxpbmVIZWlnaHRzW2ldO1xuICAgICAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldKSB7IC8vIFJvdW5kIHRvIC4xIHBpeGVsc1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuICAgIHJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBsaW5lTGVuZ3RoLCBrbm93bkhlaWdodHMpIHtcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gTWF0aC5hYnMobGluZUhlaWdodCAtIHRoaXMubGluZUhlaWdodCkgPiAwLjMgfHwgdGhpcy5saW5lV3JhcHBpbmcgIT0gbGluZVdyYXBwaW5nIHx8XG4gICAgICAgICAgICBNYXRoLmFicyhjaGFyV2lkdGggLSB0aGlzLmNoYXJXaWR0aCkgPiAwLjE7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IGNoYXJXaWR0aDtcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gdGV4dEhlaWdodDtcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gbGluZUxlbmd0aDtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrbm93bkhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGtub3duSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaCA8IDApXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG59XG4vLyBUaGlzIG9iamVjdCBpcyB1c2VkIGJ5IGB1cGRhdGVIZWlnaHRgIHRvIG1ha2UgRE9NIG1lYXN1cmVtZW50c1xuLy8gYXJyaXZlIGF0IHRoZSByaWdodCBub2Rlcy4gVGhlIGBoZWlnaHRzYCBhcnJheSBpcyBhIHNlcXVlbmNlIG9mXG4vLyBibG9jayBoZWlnaHRzLCBzdGFydGluZyBmcm9tIHBvc2l0aW9uIGBmcm9tYC5cbmNsYXNzIE1lYXN1cmVkSGVpZ2h0cyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgaGVpZ2h0cykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmhlaWdodHMgPSBoZWlnaHRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgZ2V0IG1vcmUoKSB7IHJldHVybiB0aGlzLmluZGV4IDwgdGhpcy5oZWlnaHRzLmxlbmd0aDsgfVxufVxuLyoqXG5SZWNvcmQgdXNlZCB0byByZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBibG9jay1sZXZlbCBlbGVtZW50XG5pbiB0aGUgZWRpdG9yIHZpZXcuXG4qL1xuY2xhc3MgQmxvY2tJbmZvIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50KS5cbiAgICAqL1xuICAgIHRvcCwgXG4gICAgLyoqXG4gICAgSXRzIGhlaWdodC5cbiAgICAqL1xuICAgIGhlaWdodCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsIFdlaXJkIHBhY2tlZCBmaWVsZCB0aGF0IGhvbGRzIGFuIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgZm9yIGNvbXBvc2l0ZSBibG9ja3MsIGEgZGVjb3JhdGlvbiBmb3IgYmxvY2sgd2lkZ2V0cywgYW5kIGFcbiAgICBudW1iZXIgaW5kaWNhdGluZyB0aGUgYW1vdW50IG9mIHdpZGdldC1jcmVhdGVkIGxpbmUgYnJlYWtzIGZvclxuICAgIHRleHQgYmxvY2tzLlxuICAgICovXG4gICAgX2NvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IF9jb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBlbGVtZW50IHRoaXMgaXMuIFdoZW4gcXVlcnlpbmcgbGluZXMsIHRoaXMgbWF5IGJlXG4gICAgYW4gYXJyYXkgb2YgYWxsIHRoZSBibG9ja3MgdGhhdCBtYWtlIHVwIHRoZSBsaW5lLlxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29udGVudCA9PSBcIm51bWJlclwiID8gQmxvY2tUeXBlLlRleHQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiB0aGlzLl9jb250ZW50LnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgYXMgYSBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCBib3R0b20oKSB7IHJldHVybiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0OyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIHdpZGdldCBibG9jaywgdGhpcyB3aWxsIHJldHVybiB0aGUgd2lkZ2V0XG4gICAgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gPyB0aGlzLl9jb250ZW50LndpZGdldCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB0ZXh0YmxvY2ssIHRoaXMgaG9sZHMgdGhlIG51bWJlciBvZiBsaW5lIGJyZWFrc1xuICAgIHRoYXQgYXBwZWFyIGluIHdpZGdldHMgaW5zaWRlIHRoZSBibG9jay5cbiAgICAqL1xuICAgIGdldCB3aWRnZXRMaW5lQnJlYWtzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IHRoaXMuX2NvbnRlbnQgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAoQXJyYXkuaXNBcnJheSh0aGlzLl9jb250ZW50KSA/IHRoaXMuX2NvbnRlbnQgOiBbdGhpc10pXG4gICAgICAgICAgICAuY29uY2F0KEFycmF5LmlzQXJyYXkob3RoZXIuX2NvbnRlbnQpID8gb3RoZXIuX2NvbnRlbnQgOiBbb3RoZXJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCwgdGhpcy50b3AsIHRoaXMuaGVpZ2h0ICsgb3RoZXIuaGVpZ2h0LCBjb250ZW50KTtcbiAgICB9XG59XG52YXIgUXVlcnlUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUXVlcnlUeXBlKSB7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5SGVpZ2h0XCJdID0gMV0gPSBcIkJ5SGVpZ2h0XCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zTm9IZWlnaHRcIl0gPSAyXSA9IFwiQnlQb3NOb0hlaWdodFwiO1xucmV0dXJuIFF1ZXJ5VHlwZX0pKFF1ZXJ5VHlwZSB8fCAoUXVlcnlUeXBlID0ge30pKTtcbmNvbnN0IEVwc2lsb24gPSAxZS0zO1xuY2xhc3MgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb3ZlcmVkXG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2YgdGhpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgIGZsYWdzID0gMiAvKiBGbGFnLk91dGRhdGVkICovKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBnZXQgb3V0ZGF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogRmxhZy5PdXRkYXRlZCAqLykgPiAwOyB9XG4gICAgc2V0IG91dGRhdGVkKHZhbHVlKSB7IHRoaXMuZmxhZ3MgPSAodmFsdWUgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSB8ICh0aGlzLmZsYWdzICYgfjIgLyogRmxhZy5PdXRkYXRlZCAqLyk7IH1cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmhlaWdodCAtIGhlaWdodCkgPiBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFzZSBjYXNlIGlzIHRvIHJlcGxhY2UgYSBsZWFmIG5vZGUsIHdoaWNoIHNpbXBseSBidWlsZHMgYSB0cmVlXG4gICAgLy8gZnJvbSB0aGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIHRoYXQgKEhlaWdodE1hcEJyYW5jaCBhbmRcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICAvLyBBZ2FpbiwgdGhlc2UgYXJlIGJhc2UgY2FzZXMsIGFuZCBhcmUgb3ZlcnJpZGRlbiBmb3IgYnJhbmNoIGFuZCBnYXAgbm9kZXMuXG4gICAgZGVjb21wb3NlTGVmdChfdG8sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBhcHBseUNoYW5nZXMoZGVjb3JhdGlvbnMsIG9sZERvYywgb3JhY2xlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsIGRvYyA9IG9yYWNsZS5kb2M7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLnNldERvYyhvbGREb2MpLCAwLCAwKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgdG9CICs9IGVuZC50byAtIHRvQTtcbiAgICAgICAgICAgIHRvQSA9IGVuZC50bztcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xuICAgICAgICAgICAgICAgIGZyb21BID0gY2hhbmdlc1tpIC0gMV0uZnJvbUE7XG4gICAgICAgICAgICAgICAgZnJvbUIgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQjtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgc3RhcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvcmFjbGUsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUIgKz0gc3RhcnQuZnJvbSAtIGZyb21BO1xuICAgICAgICAgICAgZnJvbUEgPSBzdGFydC5mcm9tO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLnNldERvYyhkb2MpLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XG4gICAgICAgICAgICBtZSA9IHJlcGxhY2UobWUsIG1lLnJlcGxhY2UoZnJvbUEsIHRvQSwgbm9kZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWUudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHsgcmV0dXJuIG5ldyBIZWlnaHRNYXBUZXh0KDAsIDAsIDApOyB9XG4gICAgLy8gbm9kZXMgdXNlcyBudWxsIHZhbHVlcyB0byBpbmRpY2F0ZSB0aGUgcG9zaXRpb24gb2YgbGluZSBicmVha3MuXG4gICAgLy8gVGhlcmUgYXJlIG5ldmVyIGxpbmUgYnJlYWtzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGFycmF5LCBvclxuICAgIC8vIHR3byBsaW5lIGJyZWFrcyBuZXh0IHRvIGVhY2ggb3RoZXIsIGFuZCB0aGUgYXJyYXkgaXNuJ3QgYWxsb3dlZFxuICAgIC8vIHRvIGJlIGVtcHR5IChzYW1lIHJlc3RyaWN0aW9ucyBhcyByZXR1cm4gdmFsdWUgZnJvbSB0aGUgYnVpbGRlcikuXG4gICAgc3RhdGljIG9mKG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICAgICAgbGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoLCBiZWZvcmUgPSAwLCBhZnRlciA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlID4gYWZ0ZXIgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMSArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPiBiZWZvcmUgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDIgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZSA8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1tpKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1stLWpdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBhZnRlciArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJyayA9IDA7XG4gICAgICAgIGlmIChub2Rlc1tpIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2Rlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGVpZ2h0TWFwQnJhbmNoKEhlaWdodE1hcC5vZihub2Rlcy5zbGljZSgwLCBpKSksIGJyaywgSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKGopKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZShvbGQsIHZhbCkge1xuICAgIGlmIChvbGQgPT0gdmFsKVxuICAgICAgICByZXR1cm4gb2xkO1xuICAgIGlmIChvbGQuY29uc3RydWN0b3IgIT0gdmFsLmNvbnN0cnVjdG9yKVxuICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICByZXR1cm4gdmFsO1xufVxuSGVpZ2h0TWFwLnByb3RvdHlwZS5zaXplID0gMTtcbmNvbnN0IFNwYWNlRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLnJlcGxhY2Uoe30pO1xuY2xhc3MgSGVpZ2h0TWFwQmxvY2sgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0LCBkZWNvKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5kZWNvID0gZGVjbztcbiAgICAgICAgdGhpcy5zcGFjZUFib3ZlID0gMDtcbiAgICB9XG4gICAgbWFpbkJsb2NrKHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCArIHRoaXMuc3BhY2VBYm92ZSwgdGhpcy5oZWlnaHQgLSB0aGlzLnNwYWNlQWJvdmUsIHRoaXMuZGVjbyB8fCAwKTtcbiAgICB9XG4gICAgYmxvY2tBdChoZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYWNlQWJvdmUgJiYgaGVpZ2h0IDwgdG9wICsgdGhpcy5zcGFjZUFib3ZlID8gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIDAsIHRvcCwgdGhpcy5zcGFjZUFib3ZlLCBTcGFjZURlY28pXG4gICAgICAgICAgICA6IHRoaXMubWFpbkJsb2NrKHRvcCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbGluZUF0KF92YWx1ZSwgX3R5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLm1haW5CbG9jayh0b3AsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYWNlQWJvdmUgPyB0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCkuam9pbihtYWluKSA6IG1haW47XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIHRvID49IG9mZnNldClcbiAgICAgICAgICAgIGYodGhpcy5saW5lQXQoMCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIHNldE1lYXN1cmVkSGVpZ2h0KG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXTtcbiAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlQWJvdmUgPSAtbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGFjZUFib3ZlID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEhlaWdodChuZXh0KTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgX2ZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRNZWFzdXJlZEhlaWdodChtZWFzdXJlZCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGJsb2NrKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcFRleHQgZXh0ZW5kcyBIZWlnaHRNYXBCbG9jayB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIGFib3ZlKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0LCBudWxsKTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSAwOyAvLyBBbW91bnQgb2YgY29sbGFwc2VkIGNvbnRlbnQgaW4gdGhlIGxpbmVcbiAgICAgICAgdGhpcy53aWRnZXRIZWlnaHQgPSAwOyAvLyBNYXhpbXVtIGlubGluZSB3aWRnZXQgaGVpZ2h0XG4gICAgICAgIHRoaXMuYnJlYWtzID0gMDsgLy8gTnVtYmVyIG9mIHdpZGdldC1pbnRyb2R1Y2VkIGxpbmUgYnJlYWtzIG9uIHRoZSBsaW5lXG4gICAgICAgIHRoaXMuc3BhY2VBYm92ZSA9IGFib3ZlO1xuICAgIH1cbiAgICBtYWluQmxvY2sodG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wICsgdGhpcy5zcGFjZUFib3ZlLCB0aGlzLmhlaWdodCAtIHRoaXMuc3BhY2VBYm92ZSwgdGhpcy5icmVha3MpO1xuICAgIH1cbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSAmJiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJiAobm9kZS5mbGFncyAmIDQgLyogRmxhZy5TaW5nbGVMaW5lICovKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMubGVuZ3RoIC0gbm9kZS5sZW5ndGgpIDwgMTApIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgSGVpZ2h0TWFwVGV4dChub2RlLmxlbmd0aCwgdGhpcy5oZWlnaHQsIHRoaXMuc3BhY2VBYm92ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgICAgICBub2RlLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1lYXN1cmVkSGVpZ2h0KG1lYXN1cmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlQWJvdmUgPSAwO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoTWF0aC5tYXgodGhpcy53aWRnZXRIZWlnaHQsIG9yYWNsZS5oZWlnaHRGb3JMaW5lKHRoaXMubGVuZ3RoIC0gdGhpcy5jb2xsYXBzZWQpKSArXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3MgKiBvcmFjbGUubGluZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgbGluZSgke3RoaXMubGVuZ3RofSR7dGhpcy5jb2xsYXBzZWQgPyAtdGhpcy5jb2xsYXBzZWQgOiBcIlwifSR7dGhpcy53aWRnZXRIZWlnaHQgPyBcIjpcIiArIHRoaXMud2lkZ2V0SGVpZ2h0IDogXCJcIn0pYDtcbiAgICB9XG59XG5jbGFzcyBIZWlnaHRNYXBHYXAgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkgeyBzdXBlcihsZW5ndGgsIDApOyB9XG4gICAgaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgZmlyc3RMaW5lID0gb3JhY2xlLmRvYy5saW5lQXQob2Zmc2V0KS5udW1iZXIsIGxhc3RMaW5lID0gb3JhY2xlLmRvYy5saW5lQXQob2Zmc2V0ICsgdGhpcy5sZW5ndGgpLm51bWJlcjtcbiAgICAgICAgbGV0IGxpbmVzID0gbGFzdExpbmUgLSBmaXJzdExpbmUgKyAxO1xuICAgICAgICBsZXQgcGVyTGluZSwgcGVyQ2hhciA9IDA7XG4gICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgdG90YWxQZXJMaW5lID0gTWF0aC5taW4odGhpcy5oZWlnaHQsIG9yYWNsZS5saW5lSGVpZ2h0ICogbGluZXMpO1xuICAgICAgICAgICAgcGVyTGluZSA9IHRvdGFsUGVyTGluZSAvIGxpbmVzO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gbGluZXMgKyAxKVxuICAgICAgICAgICAgICAgIHBlckNoYXIgPSAodGhpcy5oZWlnaHQgLSB0b3RhbFBlckxpbmUpIC8gKHRoaXMubGVuZ3RoIC0gbGluZXMgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlckxpbmUgPSB0aGlzLmhlaWdodCAvIGxpbmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpcnN0TGluZSwgbGFzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfTtcbiAgICB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCBndWVzcyA9IG9mZnNldCArIChoZWlnaHQgPCBvcmFjbGUubGluZUhlaWdodCA/IDBcbiAgICAgICAgICAgICAgICA6IE1hdGgucm91bmQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGhlaWdodCAtIHRvcCkgLyB0aGlzLmhlaWdodCkpICogdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQoZ3Vlc3MpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgICAgIGxldCBsaW5lVG9wID0gTWF0aC5tYXgodG9wLCBoZWlnaHQgLSBsaW5lSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBsaW5lVG9wLCBsaW5lSGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGFzdExpbmUgLSBmaXJzdExpbmUsIE1hdGguZmxvb3IoKGhlaWdodCAtIHRvcCkgLyBwZXJMaW5lKSkpO1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoIH0gPSBvcmFjbGUuZG9jLmxpbmUoZmlyc3RMaW5lICsgbGluZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCBsZW5ndGgsIHRvcCArIHBlckxpbmUgKiBsaW5lLCBwZXJMaW5lLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCh2YWx1ZSwgb3JhY2xlLCB0b3AsIG9mZnNldCk7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gb3JhY2xlLmRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgdG8gLSBmcm9tLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQodmFsdWUpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgbGV0IGxpbmVUb3AgPSB0b3AgKyBwZXJMaW5lICogbGluZXNBYm92ZSArIHBlckNoYXIgKiAobGluZS5mcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIE1hdGgubWF4KHRvcCwgTWF0aC5taW4obGluZVRvcCwgdG9wICsgdGhpcy5oZWlnaHQgLSBsaW5lSGVpZ2h0KSksIGxpbmVIZWlnaHQsIDApO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgoZnJvbSwgb2Zmc2V0KTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpO1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGZyb20sIGxpbmVUb3AgPSB0b3A7IHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lc0Fib3ZlID0gbGluZS5udW1iZXIgLSBmaXJzdExpbmU7XG4gICAgICAgICAgICAgICAgbGluZVRvcCArPSBwZXJMaW5lICogbGluZXNBYm92ZSArIHBlckNoYXIgKiAoZnJvbSAtIG9mZnNldCAtIGxpbmVzQWJvdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgcGVyQ2hhciAqIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgZihuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApKTtcbiAgICAgICAgICAgIGxpbmVUb3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMubGVuZ3RoIC0gdG87XG4gICAgICAgIGlmIChhZnRlciA+IDApIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA9IG5ldyBIZWlnaHRNYXBHYXAobGFzdC5sZW5ndGggKyBhZnRlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGFmdGVyIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID4gMCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZXNbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbMF0gPSBuZXcgSGVpZ2h0TWFwR2FwKGZyb20gKyBmaXJzdC5sZW5ndGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnVuc2hpZnQobmV3IEhlaWdodE1hcEdhcChmcm9tIC0gMSksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IEhlaWdodE1hcEdhcCh0byAtIDEpLCBudWxsKTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAodGhpcy5sZW5ndGggLSBmcm9tIC0gMSkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gcGFydCBvZiB0aGlzIGdhcCB3aXRoIG1lYXN1cmVkIGxpbmVzLiBXZSBrbm93IHRoZXJlXG4gICAgICAgICAgICAvLyBjYW4ndCBiZSB3aWRnZXRzIG9yIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhvc2UgbGluZXMsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZXkgd291bGQgYWxyZWFkeSBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGhlaWdodG1hcCAoZ2Fwc1xuICAgICAgICAgICAgLy8gb25seSBjb250YWluIHBsYWluIHRleHQpLlxuICAgICAgICAgICAgbGV0IG5vZGVzID0gW10sIHBvcyA9IE1hdGgubWF4KG9mZnNldCwgbWVhc3VyZWQuZnJvbSksIHNpbmdsZUhlaWdodCA9IC0xO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmVkLmZyb20gPiBvZmZzZXQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwR2FwKG1lYXN1cmVkLmZyb20gLSBvZmZzZXQgLSAxKS51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPD0gZW5kICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXSwgYWJvdmUgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3ZlID0gLWhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUhlaWdodCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGhlaWdodCAtIHNpbmdsZUhlaWdodCkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlSGVpZ2h0ID0gLTI7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBuZXcgSGVpZ2h0TWFwVGV4dChsZW4sIGhlaWdodCwgYWJvdmUpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkucGVyTGluZSkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLmhlaWdodEZvckdhcChvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBCcmFuY2ggZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVmdC5sZW5ndGggKyBicmsgKyByaWdodC5sZW5ndGgsIGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0LCBicmsgfCAobGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZCA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IHJlcGxhY2UodGhpcy5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJlcGxhY2UodGhpcy5yaWdodCwgcmlnaHQpO1xuICAgICAgICB0aGlzLnNldEhlaWdodChsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkO1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLCByaWdodFN0YXJ0ID0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrLCByZWJhbGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UpO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSByaWdodCA9IHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcbiAgICAgICAgaWYgKHJlYmFsYW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMuYnJlYWsgPyBcIiBcIiA6IFwiLVwiKSArIHRoaXMucmlnaHQ7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XG4gICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgaWYgKG5vZGVzW2Fyb3VuZF0gPT0gbnVsbCAmJlxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXG4gICAgICAgIChhZnRlciA9IG5vZGVzW2Fyb3VuZCArIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgbm9kZXMuc3BsaWNlKGFyb3VuZCAtIDEsIDMsIG5ldyBIZWlnaHRNYXBHYXAoYmVmb3JlLmxlbmd0aCArIDEgKyBhZnRlci5sZW5ndGgpKTtcbn1cbmNvbnN0IHJlbGV2YW50V2lkZ2V0SGVpZ2h0ID0gNTtcbmNsYXNzIE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5vcmFjbGUgPSBvcmFjbGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gLTE7XG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHBvcztcbiAgICB9XG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gICAgfVxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4odG8sIHRoaXMubGluZUVuZCksIGxhc3QgPSB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbGFzdC5sZW5ndGggKz0gZW5kIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPiB0aGlzLnBvcyB8fCAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSwgMCkpO1xuICAgICAgICAgICAgdGhpcy53cml0dGVuVG8gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodG8gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0dGVuVG8rKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgZGVjby5oZWlnaHRSZWxldmFudCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGxldCBicmVha3MgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmxpbmVCcmVha3MgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gfHwgYnJlYWtzIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBicmVha3MsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVFbmQgPiAtMSAmJiB0aGlzLmxpbmVFbmQgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBlbnRlckxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gdG87XG4gICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KHRoaXMucG9zIC0gZnJvbSwgLTEsIDApKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcbiAgICB9XG4gICAgYmxhbmtDb250ZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLm9yYWNsZS5kb2MubGluZUF0KGZyb20pLnRvID09IHRvKVxuICAgICAgICAgICAgZ2FwLmZsYWdzIHw9IDQgLyogRmxhZy5TaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEsIDApO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgZGVjbyA9IGJsb2NrLmRlY287XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xuICAgICAgICBpZiAoZGVjbyAmJiBkZWNvLmVuZFNpZGUgPiAwKVxuICAgICAgICAgICAgdGhpcy5jb3ZlcmluZyA9IGJsb2NrO1xuICAgIH1cbiAgICBhZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICBsaW5lLmJyZWFrcyArPSBicmVha3M7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xLCAwKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGxldCBsZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0KSwgcmlnaHQgPSBNYXRoLm1pbih3aW4uaW5uZXJXaWR0aCwgcmVjdC5yaWdodCk7XG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT0gZG9jLmJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKHBhcmVudCA9PSBkb20ucGFyZW50Tm9kZSA/IHdpbi5pbm5lckhlaWdodCA6IGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuZnVuY3Rpb24gaW5XaW5kb3coZWx0KSB7XG4gICAgbGV0IHJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpbiA9IGVsdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICByZXR1cm4gcmVjdC5sZWZ0IDwgd2luLmlubmVyV2lkdGggJiYgcmVjdC5yaWdodCA+IDAgJiZcbiAgICAgICAgcmVjdC50b3AgPCB3aW4uaW5uZXJIZWlnaHQgJiYgcmVjdC5ib3R0b20gPiAwO1xufVxuZnVuY3Rpb24gZnVsbFBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogcGFkZGluZ1RvcCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUsIGRpc3BsYXlTaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5kaXNwbGF5U2l6ZSA9IGRpc3BsYXlTaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcodmlld1N0YXRlLCB3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgIHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5kaXNwbGF5U2l6ZSAqICh3cmFwcGluZyA/IHZpZXdTdGF0ZS5zY2FsZVkgOiB2aWV3U3RhdGUuc2NhbGVYKSwgd3JhcHBpbmcpXG4gICAgICAgIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb250ZW50RE9NLWxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHsgbGVmdDogMCwgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7IC8vIFBhZGRpbmcgYWJvdmUgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDsgLy8gUGFkZGluZyBiZWxvdyB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSAwOyAvLyBzY3JvbGxET00uY2xpZW50SGVpZ2h0LCB1bnNjYWxlZFxuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB1bnNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7IC8vIExhc3Qgc2VlbiBzY3JvbGxET00uc2Nyb2xsVG9wLCBzY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBDU1MtdHJhbnNmb3JtYXRpb24gc2NhbGUgb2YgdGhlIGVkaXRvciAodHJhbnNmb3JtZWQgc2l6ZSAvXG4gICAgICAgIC8vIGNvbmNyZXRlIHNpemUpXG4gICAgICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xuICAgICAgICAvLyBUaGUgdmVydGljYWwgcG9zaXRpb24gKGRvY3VtZW50LXJlbGF0aXZlKSB0byB3aGljaCB0byBhbmNob3IgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBwb3NpdGlvbi4gLTEgbWVhbnMgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IDA7XG4gICAgICAgIC8vIFRoZSBoZWlnaHQgYXQgdGhlIGFuY2hvciBwb3NpdGlvbi4gU2V0IGJ5IHRoZSBET00gdXBkYXRlIHBoYXNlLlxuICAgICAgICAvLyAtMSBtZWFucyBubyBoZWlnaHQgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZS5mYWNldChjb250ZW50QXR0cmlidXRlcykuc29tZSh2ID0+IHR5cGVvZiB2ICE9IFwiZnVuY3Rpb25cIiAmJiB2LmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGUoZ3Vlc3NXcmFwcGluZyk7XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGljRGVjbyhzdGF0ZSk7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2Moc3RhdGUuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUuZG9jLmxlbmd0aCldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIG51bGwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCBmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUJsb2NrQXQocG9zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVTY2FsZXIoKTtcbiAgICB9XG4gICAgdXBkYXRlU2NhbGVyKCkge1xuICAgICAgICBsZXQgc2NhbGVyID0gdGhpcy5zY2FsZXI7XG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxuICAgICAgICAgICAgbmV3IEJpZ1NjYWxlcih0aGlzLmhlaWdodE9yYWNsZSwgdGhpcy5oZWlnaHRNYXAsIHRoaXMudmlld3BvcnRzKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlci5lcSh0aGlzLnNjYWxlcikgPyAwIDogMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICB9XG4gICAgdXBkYXRlVmlld3BvcnRMaW5lcygpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzID0gW107XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwLmZvckVhY2hMaW5lKHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgMCwgMCwgYmxvY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2goc2NhbGVCbG9jayhibG9jaywgdGhpcy5zY2FsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGljRGVjbyh0aGlzLnN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5zY3JvbGxlZFRvQm90dG9tID8gbnVsbCA6IHRoaXMuc2Nyb2xsQW5jaG9yQXQodGhpcy5zY3JvbGxUb3ApO1xuICAgICAgICBjbGVhckhlaWdodENoYW5nZUZsYWcoKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSB0aGlzLmhlaWdodE1hcC5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIHVwZGF0ZS5zdGFydFN0YXRlLmRvYywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgaGVpZ2h0Q2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE1hcC5oZWlnaHQgIT0gcHJldkhlaWdodCB8fCBoZWlnaHRDaGFuZ2VGbGFnKVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHNjcm9sbEFuY2hvci5mcm9tLCAtMSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvci50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSBwcmV2SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IGhlaWdodENoYW5nZXMubGVuZ3RoID8gdGhpcy5tYXBWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB1cGRhdGUuY2hhbmdlcykgOiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcbiAgICAgICAgICAgICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh2aWV3cG9ydCkpXG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gdmlld3BvcnQuZnJvbSAhPSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdmlld3BvcnQudG8gIT0gdGhpcy52aWV3cG9ydC50bztcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UgfHwgIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcyh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldDtcbiAgICAgICAgaWYgKCF0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgJiYgKHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLmZvY3VzQ2hhbmdlZCkgJiYgdXBkYXRlLnZpZXcubGluZVdyYXBwaW5nICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmXG4gICAgICAgICAgICAhdXBkYXRlLnN0YXRlLmZhY2V0KG5hdGl2ZVNlbGVjdGlvbkhpZGRlbikpXG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSB0cnVlO1xuICAgIH1cbiAgICBtZWFzdXJlKHZpZXcpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcuY29udGVudERPTSwgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pO1xuICAgICAgICBsZXQgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IHN0eWxlLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGxldCByZWZyZXNoID0gdGhpcy5oZWlnaHRPcmFjbGUubXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKSB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudDtcbiAgICAgICAgbGV0IGRvbVJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBtZWFzdXJlQ29udGVudCA9IHJlZnJlc2ggfHwgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgfHwgdGhpcy5jb250ZW50RE9NSGVpZ2h0ICE9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSBkb21SZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDAsIGJpYXMgPSAwO1xuICAgICAgICBpZiAoZG9tUmVjdC53aWR0aCAmJiBkb21SZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IGdldFNjYWxlKGRvbSwgZG9tUmVjdCk7XG4gICAgICAgICAgICBpZiAoc2NhbGVYID4gLjAwNSAmJiBNYXRoLmFicyh0aGlzLnNjYWxlWCAtIHNjYWxlWCkgPiAuMDA1IHx8XG4gICAgICAgICAgICAgICAgc2NhbGVZID4gLjAwNSAmJiBNYXRoLmFicyh0aGlzLnNjYWxlWSAtIHNjYWxlWSkgPiAuMDA1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDE2IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJ0aWNhbCBwYWRkaW5nXG4gICAgICAgIGxldCBwYWRkaW5nVG9wID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3ApIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdUb3AgIT0gcGFkZGluZ1RvcCB8fCB0aGlzLnBhZGRpbmdCb3R0b20gIT0gcGFkZGluZ0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yV2lkdGggIT0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCB8PSAxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wICE9IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsZWRUb0JvdHRvbSA9IGlzU2Nyb2xsZWRUb0JvdHRvbSh2aWV3LnNjcm9sbERPTSk7XG4gICAgICAgIC8vIFBpeGVsIHZpZXdwb3J0XG4gICAgICAgIGxldCBwaXhlbFZpZXdwb3J0ID0gKHRoaXMucHJpbnRpbmcgPyBmdWxsUGl4ZWxSYW5nZSA6IHZpc2libGVQaXhlbFJhbmdlKShkb20sIHRoaXMucGFkZGluZ1RvcCk7XG4gICAgICAgIGxldCBkVG9wID0gcGl4ZWxWaWV3cG9ydC50b3AgLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wLCBkQm90dG9tID0gcGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tO1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSBwaXhlbFZpZXdwb3J0O1xuICAgICAgICBsZXQgaW5WaWV3ID0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSA+IHRoaXMucGl4ZWxWaWV3cG9ydC50b3AgJiYgdGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ID4gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQ7XG4gICAgICAgIGlmIChpblZpZXcgIT0gdGhpcy5pblZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gaW5WaWV3O1xuICAgICAgICAgICAgaWYgKGluVmlldylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmluVmlldyAmJiAhdGhpcy5zY3JvbGxUYXJnZXQgJiYgIWluV2luZG93KHZpZXcuZG9tKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTVdpZHRoICE9IGNvbnRlbnRXaWR0aCB8fCB0aGlzLmVkaXRvckhlaWdodCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0IHw9IDE2IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lYXN1cmVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodHMgPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh0aGlzLnZpZXdwb3J0KTtcbiAgICAgICAgICAgIGlmIChvcmFjbGUubXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSlcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChyZWZyZXNoIHx8IG9yYWNsZS5saW5lV3JhcHBpbmcgJiYgTWF0aC5hYnMoY29udGVudFdpZHRoIC0gdGhpcy5jb250ZW50RE9NV2lkdGgpID4gb3JhY2xlLmNoYXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCB9ID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBsaW5lSGVpZ2h0ID4gMCAmJiBvcmFjbGUucmVmcmVzaCh3aGl0ZVNwYWNlLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQsIE1hdGgubWF4KDUsIGNvbnRlbnRXaWR0aCAvIGNoYXJXaWR0aCksIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWluV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgY2xlYXJIZWlnaHRDaGFuZ2VGbGFnKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB2cCBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHRzID0gdnAuZnJvbSA9PSB0aGlzLnZpZXdwb3J0LmZyb20gPyBsaW5lSGVpZ2h0cyA6IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodE1hcCA9IChyZWZyZXNoID8gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0pIDogdGhpcy5oZWlnaHRNYXApLnVwZGF0ZUhlaWdodChvcmFjbGUsIDAsIHJlZnJlc2gsIG5ldyBNZWFzdXJlZEhlaWdodHModnAuZnJvbSwgaGVpZ2h0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodENoYW5nZUZsYWcpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCAmJiAodGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHRoaXMudmlld3BvcnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLylcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gdGhpcy51cGRhdGVTY2FsZXIoKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fCB2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzLCB2aWV3KSk7XG4gICAgICAgIHJlc3VsdCB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MpIHtcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIGluIHRoZSByZWFkIHN0YWdlLCBiZWNhdXNlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyB0byBhIGxpbmUgZW5kIGlzIGdvaW5nIHRvIHRyaWdnZXIgYSBsYXlvdXQgYW55d2F5LCBzbyBpdFxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgYSBwdXJlIHdyaXRlLiBJdCBzaG91bGQgYmUgcmFyZSB0aGF0IGl0IGRvZXMgYW55XG4gICAgICAgICAgICAvLyB3cml0aW5nLlxuICAgICAgICAgICAgdmlldy5kb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTsgfVxuICAgIGdldCB2aXNpYmxlQm90dG9tKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tKTsgfVxuICAgIGdldFZpZXdwb3J0KGJpYXMsIHNjcm9sbFRhcmdldCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgZGl2aWRlIFZQLk1hcmdpbiBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZVxuICAgICAgICAvLyBib3R0b20sIGRlcGVuZGluZyBvbiB0aGUgYmlhcyAodGhlIGNoYW5nZSBpbiB2aWV3cG9ydCBwb3NpdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLiBJdCdsbCBob2xkIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICBsZXQgbWFyZ2luVG9wID0gMC41IC0gTWF0aC5tYXgoLTAuNSwgTWF0aC5taW4oMC41LCBiaWFzIC8gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyKSk7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmhlaWdodE1hcCwgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHZpc2libGVUb3AgLSBtYXJnaW5Ub3AgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodmlzaWJsZUJvdHRvbSArICgxIC0gbWFyZ2luVG9wKSAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAvLyBJZiBzY3JvbGxUYXJnZXQgaXMgZ2l2ZW4sIG1ha2Ugc3VyZSB0aGUgdmlld3BvcnQgaW5jbHVkZXMgdGhhdCBwb3NpdGlvblxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWFkIH0gPSBzY3JvbGxUYXJnZXQucmFuZ2U7XG4gICAgICAgICAgICBpZiAoaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgaGVhZCA+IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSBNYXRoLm1pbih0aGlzLmVkaXRvckhlaWdodCwgdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApO1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLCB0b3BQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldC55ID09IFwiY2VudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiAtIHZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHRvcFBvcyAtIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodG9wUG9zICsgdmlld0hlaWdodCArIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgYm90dG9tIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG8gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgYm90dG9tID49IHZpc2libGVCb3R0b20gKyBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogVlAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgbWFwTGluZUdhcHMoZ2FwcywgY2hhbmdlcykge1xuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZ2FwcztcbiAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy50b3VjaGVzUmFuZ2UoZ2FwLmZyb20sIGdhcC50bykpXG4gICAgICAgICAgICAgICAgbWFwcGVkLnB1c2gobmV3IExpbmVHYXAoY2hhbmdlcy5tYXBQb3MoZ2FwLmZyb20pLCBjaGFuZ2VzLm1hcFBvcyhnYXAudG8pLCBnYXAuc2l6ZSwgZ2FwLmRpc3BsYXlTaXplKSk7XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHBvc2l0aW9ucyBpbiB0aGUgdmlld3BvcnQgd2hlcmUgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhXG4gICAgLy8gbGluZSBzaG91bGQgYmUgaGlkZGVuLCB0cnlpbmcgdG8gcmV1c2UgZXhpc3RpbmcgbGluZSBnYXBzIHdoZW5cbiAgICAvLyBhcHByb3ByaWF0ZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSByZWRyYXdzLlxuICAgIC8vIFVzZXMgY3J1ZGUgY2hhcmFjdGVyLWNvdW50aW5nIGZvciB0aGUgcG9zaXRpb25pbmcgYW5kIHNpemluZyxcbiAgICAvLyBzaW5jZSBhY3R1YWwgRE9NIGNvb3JkaW5hdGVzIGFyZW4ndCBhbHdheXMgYXZhaWxhYmxlIGFuZFxuICAgIC8vIHByZWRpY3RhYmxlLiBSZWxpZXMgb24gZ2VuZXJvdXMgbWFyZ2lucyAoc2VlIExHLk1hcmdpbikgdG8gaGlkZVxuICAgIC8vIHRoZSBhcnRpZmFjdHMgdGhpcyBtaWdodCBwcm9kdWNlIGZyb20gdGhlIHVzZXIuXG4gICAgZW5zdXJlTGluZUdhcHMoY3VycmVudCwgbWF5TWVhc3VyZSkge1xuICAgICAgICBsZXQgd3JhcHBpbmcgPSB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7XG4gICAgICAgIGxldCBtYXJnaW4gPSB3cmFwcGluZyA/IDEwMDAwIC8qIExHLk1hcmdpbldyYXAgKi8gOiAyMDAwIC8qIExHLk1hcmdpbiAqLywgaGFsZk1hcmdpbiA9IG1hcmdpbiA+PiAxLCBkb3VibGVNYXJnaW4gPSBtYXJnaW4gPDwgMTtcbiAgICAgICAgLy8gVGhlIG5vbi13cmFwcGluZyBsb2dpYyB3b24ndCB3b3JrIGF0IGFsbCBpbiBwcmVkb21pbmFudGx5IHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiAmJiAhd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGxldCBhZGRHYXAgPSAoZnJvbSwgdG8sIGxpbmUsIHN0cnVjdHVyZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRvIC0gZnJvbSA8IGhhbGZNYXJnaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGF2b2lkID0gW3NlbC5mcm9tXTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5KVxuICAgICAgICAgICAgICAgIGF2b2lkLnB1c2goc2VsLnRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBhdm9pZCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIHBvcyA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChmcm9tLCBwb3MgLSAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChwb3MgKyAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdhcCA9IGZpbmQoY3VycmVudCwgZ2FwID0+IGdhcC5mcm9tID49IGxpbmUuZnJvbSAmJiBnYXAudG8gPD0gbGluZS50byAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhcC5mcm9tIC0gZnJvbSkgPCBoYWxmTWFyZ2luICYmIE1hdGguYWJzKGdhcC50byAtIHRvKSA8IGhhbGZNYXJnaW4gJiZcbiAgICAgICAgICAgICAgICAhYXZvaWQuc29tZShwb3MgPT4gZ2FwLmZyb20gPCBwb3MgJiYgZ2FwLnRvID4gcG9zKSk7XG4gICAgICAgICAgICBpZiAoIWdhcCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGRvd24sIHNuYXAgZ2FwIGVuZHMgdG8gbGluZSBzdGFydHMgdG8gYXZvaWQgc2hpZnRzIGluIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRvIDwgbGluZS50byAmJiBtYXlNZWFzdXJlICYmIHdyYXBwaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG1heU1lYXN1cmUudmlzaWJsZVJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDw9IHRvICYmIHIudG8gPj0gdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lU3RhcnQgPSBtYXlNZWFzdXJlLm1vdmVUb0xpbmVCb3VuZGFyeShFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSwgZmFsc2UsIHRydWUpLmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU3RhcnQgPiBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5nYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5U2l6ZSA9IHdyYXBwaW5nIHx8IHNpemUgPCAyMDAwMDAwIC8qIFZQLk1heEhvcml6R2FwICovID8gc2l6ZSA6IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi87XG4gICAgICAgICAgICAgICAgZ2FwID0gbmV3IExpbmVHYXAoZnJvbSwgdG8sIHNpemUsIGRpc3BsYXlTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcHMucHVzaChnYXApO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY2hlY2tMaW5lID0gKGxpbmUpID0+IHtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGRvdWJsZU1hcmdpbiB8fCBsaW5lLnR5cGUgIT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHN0cnVjdHVyZSA9IGxpbmVTdHJ1Y3R1cmUobGluZS5mcm9tLCBsaW5lLnRvLCB0aGlzLnN0YXRlRGVjbyk7XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjcm9sbFRhcmdldCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHZpZXdGcm9tLCB2aWV3VG87XG4gICAgICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKG1hcmdpbiAvIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGgpICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgdG9wLCBib3Q7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy52aXNpYmxlQm90dG9tIC0gdGhpcy52aXNpYmxlVG9wKSAvIDIgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy52aXNpYmxlVG9wIC0gbGluZS50b3AgLSBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9ICh0aGlzLnZpc2libGVCb3R0b20gLSBsaW5lLnRvcCArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0b3ApO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luV2lkdGggPSBtYXJnaW4gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGhvcml6T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aCA+IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi8pXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG9sZCBvZiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkLmZyb20gPj0gbGluZS5mcm9tICYmIG9sZC5mcm9tIDwgbGluZS50byAmJiBvbGQuc2l6ZSAhPSBvbGQuZGlzcGxheVNpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQuZnJvbSAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCArIGhvcml6T2Zmc2V0IDwgdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpPZmZzZXQgPSBvbGQuc2l6ZSAtIG9sZC5kaXNwbGF5U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBweExlZnQgPSB0aGlzLnBpeGVsVmlld3BvcnQubGVmdCArIGhvcml6T2Zmc2V0LCBweFJpZ2h0ID0gdGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ICsgaG9yaXpPZmZzZXQ7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHB4UmlnaHQgLSBweExlZnQpIC8gMiArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKHB4TGVmdCAtIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHB4UmlnaHQgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGxlZnQpO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3RnJvbSA+IGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICBhZGRHYXAobGluZS5mcm9tLCB2aWV3RnJvbSwgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgIGlmICh2aWV3VG8gPCBsaW5lLnRvKVxuICAgICAgICAgICAgICAgIGFkZEdhcCh2aWV3VG8sIGxpbmUudG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3cG9ydExpbmVzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKVxuICAgICAgICAgICAgICAgIGxpbmUudHlwZS5mb3JFYWNoKGNoZWNrTGluZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2hlY2tMaW5lKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXBzO1xuICAgIH1cbiAgICBnYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpIHtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdG8pIC0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmhlaWdodCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxpbmVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKCFMaW5lR2FwLnNhbWUoZ2FwcywgdGhpcy5saW5lR2FwcykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUdhcHMgPSBnYXBzO1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KGdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZVZpc2libGVSYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gMDtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggIT0gdGhpcy52aXNpYmxlUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IDggLyogVXBkYXRlRmxhZy5WaWV3cG9ydE1vdmVkICovIHwgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoICYmICEoY2hhbmdlZCAmIDggLyogVXBkYXRlRmxhZy5WaWV3cG9ydE1vdmVkICovKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IHRoaXMudmlzaWJsZVJhbmdlc1tpXSwgbncgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG9sZC5mcm9tICE9IG53LmZyb20gfHwgb2xkLnRvICE9IG53LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgfD0gNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VzICYmIGNoYW5nZXMubWFwUG9zKG9sZC5mcm9tLCAtMSkgPT0gbncuZnJvbSAmJiBjaGFuZ2VzLm1hcFBvcyhvbGQudG8sIDEpID09IG53LnRvKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgfD0gOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiZcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRMaW5lcy5maW5kKGIgPT4gYi5mcm9tIDw9IHBvcyAmJiBiLnRvID49IHBvcykpIHx8XG4gICAgICAgICAgICBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChwb3MsIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gKGhlaWdodCA+PSB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wICYmIGhlaWdodCA8PSB0aGlzLnZpZXdwb3J0TGluZXNbdGhpcy52aWV3cG9ydExpbmVzLmxlbmd0aCAtIDFdLmJvdHRvbSAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQobCA9PiBsLnRvcCA8PSBoZWlnaHQgJiYgbC5ib3R0b20gPj0gaGVpZ2h0KSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGxldCBibG9jayA9IHRoaXMubGluZUJsb2NrQXRIZWlnaHQoc2Nyb2xsVG9wICsgOCk7XG4gICAgICAgIHJldHVybiBibG9jay5mcm9tID49IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wIC0gc2Nyb2xsVG9wID4gMjAwID8gYmxvY2sgOiB0aGlzLnZpZXdwb3J0TGluZXNbMF07XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlRGVjbykge1xuICAgIGxldCByYW5nZXMgPSBbXSwgcG9zID0gZnJvbSwgdG90YWwgPSAwO1xuICAgIFJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcbiAgICAgICAgc3BhbigpIHsgfSxcbiAgICAgICAgcG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZyb20gLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgfVxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXG4gICAgaWYgKHBvcyA8IHRvKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0byB9KTtcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCByYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvbih7IHRvdGFsLCByYW5nZXMgfSwgcmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPD0gMClcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xuICAgIGlmIChyYXRpbyA+PSAxKVxuICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXSwgc2l6ZSA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgZGlzdDtcbiAgICAgICAgZGlzdCAtPSBzaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHBvcykge1xuICAgIGxldCBjb3VudGVkID0gMDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygc3RydWN0dXJlLnJhbmdlcykge1xuICAgICAgICBpZiAocG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZWQgLyBzdHJ1Y3R1cmUudG90YWw7XG59XG5mdW5jdGlvbiBmaW5kKGFycmF5LCBmKSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIGFycmF5KVxuICAgICAgICBpZiAoZih2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gRG9uJ3Qgc2NhbGUgd2hlbiB0aGUgZG9jdW1lbnQgaGVpZ2h0IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygd2hhdFxuLy8gdGhlIERPTSBjYW4gaGFuZGxlLlxuY29uc3QgSWRTY2FsZXIgPSB7XG4gICAgdG9ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBmcm9tRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgc2NhbGU6IDEsXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyID09IHRoaXM7IH1cbn07XG5mdW5jdGlvbiBzdGF0aWNEZWNvKHN0YXRlKSB7XG4gICAgbGV0IGRlY28gPSBzdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICBsZXQgb3V0ZXIgPSBzdGF0ZS5mYWNldChvdXRlckRlY29yYXRpb25zKS5maWx0ZXIoZCA9PiB0eXBlb2YgZCAhPSBcImZ1bmN0aW9uXCIpO1xuICAgIGlmIChvdXRlci5sZW5ndGgpXG4gICAgICAgIGRlY28ucHVzaChSYW5nZVNldC5qb2luKG91dGVyKSk7XG4gICAgcmV0dXJuIGRlY287XG59XG4vLyBXaGVuIHRoZSBoZWlnaHQgaXMgdG9vIGJpZyAoPiBWUC5NYXhET01IZWlnaHQpLCBzY2FsZSBkb3duIHRoZVxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXG4vLyBWUC5NYXhET01IZWlnaHQuXG5jbGFzcyBCaWdTY2FsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yYWNsZSwgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcbiAgICAgICAgbGV0IHZwSGVpZ2h0ID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBoZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkuYm90dG9tO1xuICAgICAgICAgICAgdnBIZWlnaHQgKz0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZSA9ICg3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyAtIHZwSGVpZ2h0KSAvIChoZWlnaHRNYXAuaGVpZ2h0IC0gdnBIZWlnaHQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgIG9iai5kb21Ub3AgPSBkb21CYXNlICsgKG9iai50b3AgLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkb21CYXNlID0gb2JqLmRvbUJvdHRvbSA9IG9iai5kb21Ub3AgKyAob2JqLmJvdHRvbSAtIG9iai50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21CYXNlICsgKG4gLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5ib3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAuZG9tVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5kb21Cb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLnRvcCArIChuIC0gdnAuZG9tVG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgQmlnU2NhbGVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUgPT0gb3RoZXIuc2NhbGUgJiYgdGhpcy52aWV3cG9ydHMubGVuZ3RoID09IG90aGVyLnZpZXdwb3J0cy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRzLmV2ZXJ5KCh2cCwgaSkgPT4gdnAuZnJvbSA9PSBvdGhlci52aWV3cG9ydHNbaV0uZnJvbSAmJiB2cC50byA9PSBvdGhlci52aWV3cG9ydHNbaV0udG8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlcikge1xuICAgIGlmIChzY2FsZXIuc2NhbGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIGxldCBiVG9wID0gc2NhbGVyLnRvRE9NKGJsb2NrLnRvcCksIGJCb3R0b20gPSBzY2FsZXIudG9ET00oYmxvY2suYm90dG9tKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhibG9jay5mcm9tLCBibG9jay5sZW5ndGgsIGJUb3AsIGJCb3R0b20gLSBiVG9wLCBBcnJheS5pc0FycmF5KGJsb2NrLl9jb250ZW50KSA/IGJsb2NrLl9jb250ZW50Lm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay5fY29udGVudCk7XG59XG5cbmNvbnN0IHRoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHN0cnMgPT4gc3Rycy5qb2luKFwiIFwiKSB9KTtcbmNvbnN0IGRhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmluZGV4T2YodHJ1ZSkgPiAtMSB9KTtcbmNvbnN0IGJhc2VUaGVtZUlEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZUxpZ2h0SUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlRGFya0lEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKTtcbmNvbnN0IGxpZ2h0RGFya0lEcyA9IHsgXCImbGlnaHRcIjogXCIuXCIgKyBiYXNlTGlnaHRJRCwgXCImZGFya1wiOiBcIi5cIiArIGJhc2VEYXJrSUQgfTtcbmZ1bmN0aW9uIGJ1aWxkVGhlbWUobWFpbiwgc3BlYywgc2NvcGVzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZU1vZHVsZShzcGVjLCB7XG4gICAgICAgIGZpbmlzaChzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAvJi8udGVzdChzZWwpID8gc2VsLnJlcGxhY2UoLyZcXHcqLywgbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWluO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVzIHx8ICFzY29wZXNbbV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHttfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZXNbbV07XG4gICAgICAgICAgICB9KSA6IG1haW4gKyBcIiBcIiArIHNlbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XG4gICAgXCImXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgIG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLCAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQ1NlxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsIC8vIEZvciBJRVxuICAgICAgICB3aGl0ZVNwYWNlOiBcImJyZWFrLXNwYWNlc1wiLFxuICAgICAgICB3b3JkQnJlYWs6IFwiYnJlYWstd29yZFwiLCAvLyBGb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgb3ZlcmZsb3ctd3JhcDogYW55d2hlcmVcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiBcImFueXdoZXJlXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDFcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJibGFja1wiIH0sXG4gICAgXCImZGFyayAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwid2hpdGVcIiB9LFxuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAycHggMCA2cHhcIlxuICAgIH0sXG4gICAgXCIuY20tbGF5ZXJcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiLFxuICAgICAgICBcIiYgPiAqXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkOWQ5ZDlcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXG4gICAgfSxcbiAgICBcIiZsaWdodC5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDdkNGYwXCJcbiAgICB9LFxuICAgIFwiJmRhcmsuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIzM1wiXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIGFuaW1hdGlvbjogXCJzdGVwcygxKSBjbS1ibGluayAxLjJzIGluZmluaXRlXCJcbiAgICB9LFxuICAgIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAgIC8vIHJlc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRob3V0IGZvcmNpbmcgYW5vdGhlciBzdHlsZVxuICAgIC8vIHJlY29tcHV0YXRpb24uXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGluazJcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiNkZGRcIlxuICAgIH0sXG4gICAgXCIuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LFxuICAgIFwiLmNtLWlzb1wiOiB7XG4gICAgICAgIHVuaWNvZGVCaWRpOiBcImlzb2xhdGVcIlxuICAgIH0sXG4gICAgXCIuY20tYW5ub3VuY2VkXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgICAgdG9wOiBcIi0xMDAwMHB4XCJcbiAgICB9LFxuICAgIFwiQG1lZGlhIHByaW50XCI6IHtcbiAgICAgICAgXCIuY20tYW5ub3VuY2VkXCI6IHsgZGlzcGxheTogXCJub25lXCIgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NjZWVmZjQ0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWVlZmYzM1wiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwicmVkXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcIiNmNzhcIiB9LFxuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgekluZGV4OiAyMDAsXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJzLWJlZm9yZVwiOiB7IGluc2V0SW5saW5lU3RhcnQ6IDAgfSxcbiAgICBcIi5jbS1ndXR0ZXJzLWFmdGVyXCI6IHsgaW5zZXRJbmxpbmVFbmQ6IDAgfSxcbiAgICBcIiZsaWdodCAuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcIiM2YzZjNmNcIixcbiAgICAgICAgYm9yZGVyOiBcIjBweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIFwiJi5jbS1ndXR0ZXJzLWJlZm9yZVwiOiB7IGJvcmRlclJpZ2h0V2lkdGg6IFwiMXB4XCIgfSxcbiAgICAgICAgXCImLmNtLWd1dHRlcnMtYWZ0ZXJcIjogeyBib3JkZXJMZWZ0V2lkdGg6IFwiMXB4XCIgfSxcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsIC8vIE5lY2Vzc2FyeSAtLSBwcmV2ZW50cyBtYXJnaW4gY29sbGFwc2luZ1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbmVOdW1iZXJzIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDNweCAwIDVweFwiLFxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZTJmMmZmXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzIyMjIyN1wiXG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbHNcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHpJbmRleDogMzAwXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiYmxhY2tcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy10b3BcIjoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVscy1ib3R0b21cIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNkZGRcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhbG9nXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggMTlweCA0cHggNnB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7IGZvbnRTaXplOiBcIjgwJVwiIH0sXG4gICAgfSxcbiAgICBcIi5jbS1kaWFsb2ctY2xvc2VcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB0b3A6IFwiM3B4XCIsXG4gICAgICAgIHJpZ2h0OiBcIjRweFwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiMTRweFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjBcIlxuICAgIH0sXG4gICAgXCIuY20tdGFiXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCJcbiAgICB9LFxuICAgIFwiLmNtLXdpZGdldEJ1ZmZlclwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC10b3BcIixcbiAgICAgICAgaGVpZ2h0OiBcIjFlbVwiLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmVcIlxuICAgIH0sXG4gICAgXCIuY20tcGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCIsXG4gICAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIi5jbS1oaWdobGlnaHRTcGFjZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJyYWRpYWwtZ3JhZGllbnQoY2lyY2xlIGF0IDUwJSA1NSUsICNhYWEgMjAlLCB0cmFuc3BhcmVudCA1JSlcIixcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImNlbnRlclwiLFxuICAgIH0sXG4gICAgXCIuY20taGlnaGxpZ2h0VGFiXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIyMFwiPjxwYXRoIHN0cm9rZT1cIiUyMzg4OFwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwibm9uZVwiIGQ9XCJNMSAxMEgxOTZMMTkwIDVNMTkwIDE1TDE5NiAxME0xOTcgNEwxOTcgMTZcIi8+PC9zdmc+JylgLFxuICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogXCJhdXRvIDEwMCVcIixcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcInJpZ2h0IDkwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiXG4gICAgfSxcbiAgICBcIi5jbS10cmFpbGluZ1NwYWNlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZjMzMjI1NVwiXG4gICAgfSxcbiAgICBcIi5jbS1idXR0b25cIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gMWVtXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIxcHhcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2VmZjFmNSwgI2Q5ZDlkZilcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjODg4XCIsXG4gICAgICAgIFwiJjphY3RpdmVcIjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjYjRiNGI0LCAjZDBkM2Q2KVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWJ1dHRvblwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzM5MzkzOSwgIzExMSlcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjODg4XCIsXG4gICAgICAgIFwiJjphY3RpdmVcIjoge1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBcImxpbmVhci1ncmFkaWVudCgjMTExLCAjMzMzKVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgc2lsdmVyXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjJlbSAuNWVtXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjNTU1XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCJcbiAgICB9XG59LCBsaWdodERhcmtJRHMpO1xuXG5jb25zdCBvYnNlcnZlT3B0aW9ucyA9IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59O1xuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0b1xuLy8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkIHRoZXJlXG5jb25zdCB1c2VDaGFyRGF0YSA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dCA9IG51bGw7XG4gICAgICAgIC8vIFRoZSBrbm93biBzZWxlY3Rpb24uIEtlcHQgaW4gb3VyIG93biBvYmplY3QsIGFzIG9wcG9zZWQgdG8ganVzdFxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxuICAgICAgICAvLyAgLSBTYWZhcmkgZG9lc24ndCByZXBvcnQgdGhlIHJpZ2h0IHNlbGVjdGlvbiBpbiBzaGFkb3cgRE9NXG4gICAgICAgIC8vICAtIFJlYWRpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGZvcmNlcyBhIERPTSBsYXlvdXRcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXG4gICAgICAgIC8vICAgIGFscmVhZHkgc2VlbiB0aGUgJ25ldycgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgRE9NU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhcHMgPSBbXTtcbiAgICAgICAgdGhpcy5wcmludFF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIG11dGF0aW9ucylcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyIHRleHQgbm9kZSkgY2FsbCB0aGVcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIGNhbGxiYWNrIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVucmVsYXRlZGx5LCBpT1MgU2FmYXJpIHdpbGwsIHdoZW4gZW5kaW5nIGEgY29tcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgZmlyc3QgY2xlYXIgaXQsIGRlbGl2ZXIgdGhlIG11dGF0aW9ucywgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkZWxldGlvbiB3aWxsIHByZXZlbnQgdGhlIHJlaW5zZXJ0aW9uIGZyb20gaGFwcGVuaW5nLFxuICAgICAgICAgICAgLy8gYnJlYWtpbmcgY29tcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHdpbmRvdy5FZGl0Q29udGV4dCAmJiBicm93c2VyLmFuZHJvaWQgJiYgdmlldy5jb25zdHJ1Y3Rvci5FRElUX0NPTlRFWFQgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAvLyBDaHJvbWUgPDEyNiBkb2Vzbid0IHN1cHBvcnQgaW52ZXJ0ZWQgc2VsZWN0aW9ucyBpbiBlZGl0IGNvbnRleHQgKCMxMzkyKVxuICAgICAgICAgICAgIShicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmNocm9tZV92ZXJzaW9uIDwgMTI2KSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dCA9IG5ldyBFZGl0Q29udGV4dE1hbmFnZXIodmlldyk7XG4gICAgICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkpXG4gICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmVkaXRDb250ZXh0ID0gdGhpcy5lZGl0Q29udGV4dC5lZGl0Q29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBldmVudC5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25QcmludCA9IHRoaXMub25QcmludC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsID0gdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpXG4gICAgICAgICAgICB0aGlzLnByaW50UXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcInByaW50XCIpO1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMudmlldy5kb2NWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdFVwZGF0ZSkgPCBEYXRlLm5vdygpIC0gNzUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwub2JzZXJ2ZSh2aWV3LnNjcm9sbERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4gPSB2aWV3Lndpbik7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENoZWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiAoZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMCkgIT0gdGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSAhdGhpcy5pbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFswLCAuMDAxXSB9KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLm9ic2VydmUodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbkZvclNjcm9sbCgpO1xuICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbENoYW5nZWQoZSkge1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5ydW5IYW5kbGVycyhcInNjcm9sbFwiLCBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoZSkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5lZGl0Q29udGV4dC5tZWFzdXJlUmVxKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZSk7XG4gICAgfVxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBvblByaW50KGV2ZW50KSB7XG4gICAgICAgIGlmICgoZXZlbnQudHlwZSA9PSBcImNoYW5nZVwiIHx8ICFldmVudC50eXBlKSAmJiAhZXZlbnQubWF0Y2hlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHVwZGF0ZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGdhcHMubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKGcsIGkpID0+IGcgIT0gZ2Fwc1tpXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5vYnNlcnZlKGdhcCk7XG4gICAgICAgICAgICB0aGlzLmdhcHMgPSBnYXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCB3YXNDaGFuZ2VkID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICBpZiAoIXRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCkgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsID0gdGhpcy5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCBzZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29udGV4dCA9IHNlbC5hbmNob3JOb2RlICYmIHZpZXcuZG9jVmlldy50aWxlLm5lYXJlc3Qoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmlzV2lkZ2V0KCkgJiYgY29udGV4dC53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIXdhc0NoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCBoYXMgYSBzaW1pbGFyIGlzc3VlIHdoZW4gYmFja3NwYWNpbmcgb3V0IGFcbiAgICAgICAgLy8gc2VsZWN0aW9uICgjNjQ1KS5cbiAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUpICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmXG4gICAgICAgICAgICAvLyAoU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFKVxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgIH1cbiAgICByZWFkU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIC8vIFRoZSBTZWxlY3Rpb24gb2JqZWN0IGlzIGJyb2tlbiBpbiBzaGFkb3cgcm9vdHMgaW4gU2FmYXJpLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTRcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHJhbmdlID0gYnJvd3Nlci5zYWZhcmkgJiYgdmlldy5yb290Lm5vZGVUeXBlID09IDExICYmXG4gICAgICAgICAgICB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbSAmJlxuICAgICAgICAgICAgc2FmYXJpU2VsZWN0aW9uUmFuZ2VIYWNrKHRoaXMudmlldywgc2VsZWN0aW9uKSB8fCBzZWxlY3Rpb247XG4gICAgICAgIGlmICghcmFuZ2UgfHwgdGhpcy5zZWxlY3Rpb25SYW5nZS5lcShyYW5nZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBsb2NhbCA9IGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgcmFuZ2UpO1xuICAgICAgICAvLyBEZXRlY3QgdGhlIHNpdHVhdGlvbiB3aGVyZSB0aGUgYnJvd3NlciBoYXMsIG9uIGZvY3VzLCBtb3ZlZCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgY29udGVudCBlbGVtZW50LiBSZXNldCBpdCB0byB0aGVcbiAgICAgICAgLy8gcG9zaXRpb24gZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxuICAgICAgICBpZiAobG9jYWwgJiYgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPiBEYXRlLm5vdygpIC0gMjAwICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIGF0RWxlbWVudFN0YXJ0KHRoaXMuZG9tLCByYW5nZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICAgICAgdmlldy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAobG9jYWwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFyU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2Uuc2V0KG51bGwsIDAsIG51bGwsIDApO1xuICAgIH1cbiAgICBsaXN0ZW5Gb3JTY3JvbGwoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwLCBjaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gdGhpcy5kb207IGRvbTspIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiBpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiB0aGlzLnNjcm9sbFRhcmdldHNbaV0gPT0gZG9tKVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQucHVzaChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5hc3NpZ25lZFNsb3QgfHwgZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgdGhpcy5zY3JvbGxUYXJnZXRzLmxlbmd0aCAmJiAhY2hhbmdlZClcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgaSk7XG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlKGYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgIH1cbiAgICAvLyBUaHJvdyBhd2F5IGFueSBwZW5kaW5nIGNoYW5nZXNcbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVjb3JkcygpO1xuICAgICAgICB0aGlzLnF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCwgZXNwZWNpYWxseSBpbiBjb21iaW5hdGlvbiB3aXRoIEdCb2FyZCwgbm90IG9ubHlcbiAgICAvLyBkb2Vzbid0IHJlbGlhYmx5IGZpcmUgcmVndWxhciBrZXkgZXZlbnRzLCBidXQgYWxzbyBvZnRlblxuICAgIC8vIHN1cnJvdW5kcyB0aGUgZWZmZWN0IG9mIGVudGVyIG9yIGJhY2tzcGFjZSB3aXRoIGEgYnVuY2ggb2ZcbiAgICAvLyBjb21wb3NpdGlvbiBldmVudHMgdGhhdCwgd2hlbiBpbnRlcnJ1cHRlZCwgY2F1c2UgdGV4dCBkdXBsaWNhdGlvblxuICAgIC8vIG9yIG90aGVyIGtpbmRzIG9mIGNvcnJ1cHRpb24uIFRoaXMgaGFjayBtYWtlcyB0aGUgZWRpdG9yIGJhY2sgb2ZmXG4gICAgLy8gZnJvbSBoYW5kbGluZyBET00gY2hhbmdlcyBmb3IgYSBtb21lbnQgd2hlbiBzdWNoIGEga2V5IGlzXG4gICAgLy8gZGV0ZWN0ZWQgKHZpYSBiZWZvcmVpbnB1dCBvciBrZXlkb3duKSwgYW5kIHRoZW4gdHJpZXMgdG8gZmx1c2hcbiAgICAvLyB0aGVtIG9yLCBpZiB0aGF0IGhhcyBubyBlZmZlY3QsIGRpc3BhdGNoZXMgdGhlIGdpdmVuIGtleS5cbiAgICBkZWxheUFuZHJvaWRLZXkoa2V5LCBrZXlDb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICBsZXQgZmx1c2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleUNvZGUgPSBrZXkua2V5Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmx1c2hlZCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbHVzaGVkICYmIGtleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuZG9tLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGJhY2tzcGFjZSBiZWZvcmVpbnB1dCBpcyBzb21ldGltZXMgc2lnbmFsbGVkIHNwdXJpb3VzbHksXG4gICAgICAgIC8vIEVudGVyIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkgfHwga2V5ID09IFwiRW50ZXJcIilcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSB7XG4gICAgICAgICAgICAgICAga2V5LCBrZXlDb2RlLFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBrZXkgaGFuZGxlciB3aGVuIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBjb21pbmcgcmlnaHQgYWZ0ZXIgYW5vdGhlciBjaGFuZ2UsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBwcm9iYWJseSBwYXJ0IG9mIGEgd2VpcmQgY2hhaW4gb2YgdXBkYXRlcywgYW5kIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGlnbm9yZWQgaWYgaXQgcmV0dXJucyB0aGUgRE9NIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JjZTogdGhpcy5sYXN0Q2hhbmdlIDwgRGF0ZS5ub3coKSAtIDUwIHx8ICEhKChfYSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZSlcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSB7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoIDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xOyB0aGlzLmZsdXNoKCk7IH0pO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIHByb2Nlc3NSZWNvcmRzKCkge1xuICAgICAgICBsZXQgcmVjb3JkcyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yZWFkTXV0YXRpb24ocmVjb3JkKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKHJhbmdlLmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdHlwZU92ZXIgfTtcbiAgICB9XG4gICAgcmVhZENoYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8sIHR5cGVPdmVyIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiYgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgaWYgKGZyb20gPCAwICYmICFuZXdTZWwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGZyb20gPiAtMSlcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IG5ldyBET01DaGFuZ2UodGhpcy52aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgICAgICB0aGlzLnZpZXcuZG9jVmlldy5kb21DaGFuZ2VkID0geyBuZXdTZWw6IGNoYW5nZS5uZXdTZWwgPyBjaGFuZ2UubmV3U2VsLm1haW4gOiBudWxsIH07XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIC8vIEFwcGx5IHBlbmRpbmcgY2hhbmdlcywgaWYgYW55XG4gICAgZmx1c2gocmVhZFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBob2xkIG9mZiBmbHVzaGluZyB3aGVuIHBlbmRpbmcga2V5cyBhcmUgc2V04oCUdGhlIGNvZGVcbiAgICAgICAgLy8gbWFuYWdpbmcgdGhvc2Ugd2lsbCBtYWtlIHN1cmUgcHJvY2Vzc1JlY29yZHMgaXMgY2FsbGVkIGFuZCB0aGVcbiAgICAgICAgLy8gdmlldyBpcyByZXN5bmNocm9uaXplZCBhZnRlclxuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocmVhZFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBkb21DaGFuZ2UgPSB0aGlzLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgaWYgKCFkb21DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGFwcGx5RE9NQ2hhbmdlKHRoaXMudmlldywgZG9tQ2hhbmdlKTtcbiAgICAgICAgLy8gVGhlIHZpZXcgd2Fzbid0IHVwZGF0ZWQgYnV0IERPTS9zZWxlY3Rpb24gY2hhbmdlcyB3ZXJlIHNlZW4uIFJlc2V0IHRoZSB2aWV3LlxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlID09IHN0YXJ0U3RhdGUgJiZcbiAgICAgICAgICAgIChkb21DaGFuZ2UuZG9tQ2hhbmdlZCB8fCBkb21DaGFuZ2UubmV3U2VsICYmICFzYW1lU2VsUG9zKHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24sIGRvbUNoYW5nZS5uZXdTZWwubWFpbikpKVxuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgIH1cbiAgICByZWFkTXV0YXRpb24ocmVjKSB7XG4gICAgICAgIGxldCB0aWxlID0gdGhpcy52aWV3LmRvY1ZpZXcudGlsZS5uZWFyZXN0KHJlYy50YXJnZXQpO1xuICAgICAgICBpZiAoIXRpbGUgfHwgdGlsZS5pc1dpZGdldCgpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRpbGUubWFya0RpcnR5KHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEJlZm9yZSA9IGZpbmRDaGlsZCh0aWxlLCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRBZnRlciA9IGZpbmRDaGlsZCh0aWxlLCByZWMubmV4dFNpYmxpbmcgfHwgcmVjLnRhcmdldC5uZXh0U2libGluZywgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjaGlsZEJlZm9yZSA/IHRpbGUucG9zQWZ0ZXIoY2hpbGRCZWZvcmUpIDogdGlsZS5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gdGlsZS5wb3NCZWZvcmUoY2hpbGRBZnRlcikgOiB0aWxlLnBvc0F0RW5kLCB0eXBlT3ZlcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWMudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogdGlsZS5wb3NBdFN0YXJ0LCB0bzogdGlsZS5wb3NBdEVuZCwgdHlwZU92ZXI6IHJlYy50YXJnZXQubm9kZVZhbHVlID09IHJlYy5vbGRWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2luZG93KHdpbikge1xuICAgICAgICBpZiAod2luICE9IHRoaXMud2luKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgICAgICB0aGlzLndpbiA9IHdpbjtcbiAgICAgICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkuYWRkTGlzdGVuZXIodGhpcy5vblByaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW50UXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uUHJpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZWRpdGFibGUpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChlZGl0YWJsZSkpXG4gICAgICAgICAgICAgICAgdXBkYXRlLnZpZXcuY29udGVudERPTS5lZGl0Q29udGV4dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB0aGlzLmVkaXRDb250ZXh0LmVkaXRDb250ZXh0IDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2IgPSB0aGlzLmdhcEludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5yZXNpemVTY3JvbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wYXJlbnRDaGVjayk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5jb250ZW50RE9NLmVkaXRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENoaWxkKHRpbGUsIGRvbSwgZGlyKSB7XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBsZXQgY3VyVGlsZSA9IFRpbGUuZ2V0KGRvbSk7XG4gICAgICAgIGlmIChjdXJUaWxlICYmIGN1clRpbGUucGFyZW50ID09IHRpbGUpXG4gICAgICAgICAgICByZXR1cm4gY3VyVGlsZTtcbiAgICAgICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICBkb20gPSBwYXJlbnQgIT0gdGlsZS5kb20gPyBwYXJlbnQgOiBkaXIgPiAwID8gZG9tLm5leHRTaWJsaW5nIDogZG9tLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBidWlsZFNlbGVjdGlvblJhbmdlRnJvbVJhbmdlKHZpZXcsIHJhbmdlKSB7XG4gICAgbGV0IGFuY2hvck5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IHJhbmdlLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1ckFuY2hvciA9IHZpZXcuZG9jVmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgMSk7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VyQW5jaG9yLm5vZGUsIGN1ckFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWcgKCM0MTQpXG5mdW5jdGlvbiBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodmlldywgc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXModmlldy5yb290KVswXTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UodmlldywgcmFuZ2UpO1xuICAgIH1cbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjEpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93cm9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl04oCUdXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgdmlldy5kb20ub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmNvbnRlbnRET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHJldHVybiBmb3VuZCA/IGJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UodmlldywgZm91bmQpIDogbnVsbDtcbn1cbmNsYXNzIEVkaXRDb250ZXh0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAvLyBUaGUgZG9jdW1lbnQgd2luZG93IGZvciB3aGljaCB0aGUgdGV4dCBpbiB0aGUgY29udGV4dCBpc1xuICAgICAgICAvLyBtYWludGFpbmVkLiBGb3IgbGFyZ2UgZG9jdW1lbnRzLCB0aGlzIG1heSBiZSBzbWFsbGVyIHRoYW4gdGhlXG4gICAgICAgIC8vIGVkaXRvciBkb2N1bWVudC4gVGhpcyB3aW5kb3cgYWx3YXlzIGluY2x1ZGVzIHRoZSBzZWxlY3Rpb24gaGVhZC5cbiAgICAgICAgdGhpcy5mcm9tID0gMDtcbiAgICAgICAgdGhpcy50byA9IDA7XG4gICAgICAgIC8vIFdoZW4gYXBwbHlpbmcgYSB0cmFuc2FjdGlvbiwgdGhpcyBpcyB1c2VkIHRvIGNvbXBhcmUgdGhlIGNoYW5nZVxuICAgICAgICAvLyBtYWRlIHRvIHRoZSBjb250ZXh0IGNvbnRlbnQgdG8gdGhlIGNoYW5nZSBpbiB0aGUgdHJhbnNhY3Rpb24gaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gbWFrZSB0aGUgbWluaW1hbCBjaGFuZ2VzIHRvIHRoZSBjb250ZXh0IChzaW5jZSB0b3VjaGluZ1xuICAgICAgICAvLyB0aGF0IHNvbWV0aW1lcyBicmVha3Mgc2VyaWVzIG9mIG11bHRpcGxlIGVkaXRzIG1hZGUgZm9yIGEgc2luZ2xlXG4gICAgICAgIC8vIHVzZXIgYWN0aW9uIG9uIHNvbWUgQW5kcm9pZCBrZXlib2FyZHMpXG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIHRoZSBmYWN0IHRoYXQgRWRpdENvbnRleHQgZG9lcyBub3QgcmVzcG9uZFxuICAgICAgICAvLyB3ZWxsIHRvIGhhdmluZyBpdHMgY29udGVudCB1cGRhdGVkIGR1cmluZyBhIGNvbXBvc2l0aW9uIChzZWUgIzE0NzIpXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldFJhbmdlKHZpZXcuc3RhdGUpO1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuZWRpdENvbnRleHQgPSBuZXcgd2luZG93LkVkaXRDb250ZXh0KHtcbiAgICAgICAgICAgIHRleHQ6IHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHRoaXMuZnJvbSwgdGhpcy50byksXG4gICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogdGhpcy50b0NvbnRleHRQb3MoTWF0aC5tYXgodGhpcy5mcm9tLCBNYXRoLm1pbih0aGlzLnRvLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcikpKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkVuZDogdGhpcy50b0NvbnRleHRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy50ZXh0dXBkYXRlID0gZSA9PiB7XG4gICAgICAgICAgICBsZXQgbWFpbiA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIHsgYW5jaG9yLCBoZWFkIH0gPSBtYWluO1xuICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvRWRpdG9yUG9zKGUudXBkYXRlUmFuZ2VTdGFydCksIHRvID0gdGhpcy50b0VkaXRvclBvcyhlLnVwZGF0ZVJhbmdlRW5kKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiYgIXRoaXMuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0geyBjb250ZXh0QmFzZTogZS51cGRhdGVSYW5nZVN0YXJ0LCBlZGl0b3JCYXNlOiBmcm9tLCBkcmlmdGVkOiBmYWxzZSB9O1xuICAgICAgICAgICAgbGV0IGRlbGV0ZXMgPSB0byAtIGZyb20gPiBlLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHdpbmRvdyBkb2Vzbid0IGluY2x1ZGUgdGhlIGFuY2hvciwgYXNzdW1lIGNoYW5nZXNcbiAgICAgICAgICAgIC8vIGFkamFjZW50IHRvIGEgc2lkZSBnbyB1cCB0byB0aGUgYW5jaG9yLlxuICAgICAgICAgICAgaWYgKGZyb20gPT0gdGhpcy5mcm9tICYmIGFuY2hvciA8IHRoaXMuZnJvbSlcbiAgICAgICAgICAgICAgICBmcm9tID0gYW5jaG9yO1xuICAgICAgICAgICAgZWxzZSBpZiAodG8gPT0gdGhpcy50byAmJiBhbmNob3IgPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRvID0gYW5jaG9yO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBmaW5kRGlmZih2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSwgZS50ZXh0LCAoZGVsZXRlcyA/IG1haW4uZnJvbSA6IG1haW4udG8pIC0gZnJvbSwgZGVsZXRlcyA/IFwiZW5kXCIgOiBudWxsKTtcbiAgICAgICAgICAgIC8vIEVkaXQgY29udGV4dHMgc29tZXRpbWVzIGZpcmUgZW1wdHkgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKCFkaWZmKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUodGhpcy50b0VkaXRvclBvcyhlLnNlbGVjdGlvblN0YXJ0KSwgdGhpcy50b0VkaXRvclBvcyhlLnNlbGVjdGlvbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2FtZVNlbFBvcyhuZXdTZWwsIG1haW4pKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hhbmdlID0geyBmcm9tOiBkaWZmLmZyb20gKyBmcm9tLCB0bzogZGlmZi50b0EgKyBmcm9tLFxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoXCJcXG5cIikpIH07XG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlLmZyb20gPT0gaGVhZCAtIDEgJiZcbiAgICAgICAgICAgICAgICAvXlxcLiA/JC8udGVzdChlLnRleHQpICYmIHZpZXcuY29udGVudERPTS5nZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiKSA9PSBcIm9mZlwiKVxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZihbZS50ZXh0LnJlcGxhY2UoXCIuXCIsIFwiIFwiKV0pIH07XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gY2hhbmdlO1xuICAgICAgICAgICAgaWYgKCF2aWV3LnN0YXRlLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xlbiA9IHRoaXMudG8gLSB0aGlzLmZyb20gKyAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYXBwbHlET01DaGFuZ2VJbm5lcih2aWV3LCBjaGFuZ2UsIEVkaXRvclNlbGVjdGlvbi5zaW5nbGUodGhpcy50b0VkaXRvclBvcyhlLnNlbGVjdGlvblN0YXJ0LCBuZXdMZW4pLCB0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uRW5kLCBuZXdMZW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gZGlkbid0IGZsdXNoIG91ciBjaGFuZ2UsIHJldmVydCBpdCBzb1xuICAgICAgICAgICAgLy8gdGhhdCB0aGUgY29udGV4dCBpcyBpbiBzeW5jIHdpdGggdGhlIGVkaXRvciBzdGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXZlcnRQZW5kaW5nKHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgbWlzc2VkIGNvbXBvc2l0aW9uZW5kIGV2ZW50cy4gU2VlIGh0dHBzOi8vZGlzY3Vzcy5jb2RlbWlycm9yLm5ldC90L2EvOTUxNFxuICAgICAgICAgICAgaWYgKGNoYW5nZS5mcm9tIDwgY2hhbmdlLnRvICYmICFjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiZcbiAgICAgICAgICAgICAgICAhL1tcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXS8udGVzdChjb250ZXh0LnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgZS51cGRhdGVSYW5nZVN0YXJ0IC0gMSksIE1hdGgubWluKGNvbnRleHQudGV4dC5sZW5ndGgsIGUudXBkYXRlUmFuZ2VTdGFydCArIDEpKSkpXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wb3NpdGlvbmVuZChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jaGFyYWN0ZXJib3VuZHN1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRvRWRpdG9yUG9zKGUucmFuZ2VTdGFydCksIGVuZCA9IHRoaXMudG9FZGl0b3JQb3MoZS5yYW5nZUVuZCk7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdmlldy5jb29yZHNGb3JDaGFyKGkpO1xuICAgICAgICAgICAgICAgIHByZXYgPSAocmVjdCAmJiBuZXcgRE9NUmVjdChyZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LCByZWN0LmJvdHRvbSAtIHJlY3QudG9wKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgcHJldiB8fCBuZXcgRE9NUmVjdDtcbiAgICAgICAgICAgICAgICByZWN0cy5wdXNoKHByZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC51cGRhdGVDaGFyYWN0ZXJCb3VuZHMoZS5yYW5nZVN0YXJ0LCByZWN0cyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMudGV4dGZvcm1hdHVwZGF0ZSA9IGUgPT4ge1xuICAgICAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGZvcm1hdCBvZiBlLmdldFRleHRGb3JtYXRzKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZVN0eWxlID0gZm9ybWF0LnVuZGVybGluZVN0eWxlLCB0aGlja25lc3MgPSBmb3JtYXQudW5kZXJsaW5lVGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIGlmICghL25vbmUvaS50ZXN0KGxpbmVTdHlsZSkgJiYgIS9ub25lL2kudGVzdCh0aGlja25lc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy50b0VkaXRvclBvcyhmb3JtYXQucmFuZ2VTdGFydCksIHRvID0gdGhpcy50b0VkaXRvclBvcyhmb3JtYXQucmFuZ2VFbmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSB2YWx1ZXMgY2hhbmdlZCBmcm9tIGNhcGl0YWxpemVkIGN1c3RvbSBzdHJpbmdzIHRvIGxvd2VyLWNhc2UgQ1NTIGtleXdvcmRzIGluIDIwMjVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IGB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSAkey9eW2Etel0vLnRlc3QobGluZVN0eWxlKSA/IGxpbmVTdHlsZSArIFwiIFwiIDogbGluZVN0eWxlID09IFwiRGFzaGVkXCIgPyBcImRhc2hlZCBcIiA6IGxpbmVTdHlsZSA9PSBcIlNxdWlnZ2xlXCIgPyBcIndhdnkgXCIgOiBcIlwifSR7L3RoaW4vaS50ZXN0KHRoaWNrbmVzcykgPyAxIDogMn1weGA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5tYXJrKHsgYXR0cmlidXRlczogeyBzdHlsZSB9IH0pLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RWRpdENvbnRleHRGb3JtYXR0aW5nLm9mKERlY29yYXRpb24uc2V0KGRlY28pKSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZHJpZnRlZCB9ID0gdGhpcy5jb21wb3Npbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChkcmlmdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiB0aGlzLmhhbmRsZXJzKVxuICAgICAgICAgICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZXJzW2V2ZW50XSk7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVDb250cm9sQm91bmRzKHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgc2VsLnJhbmdlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlU2VsZWN0aW9uQm91bmRzKHNlbC5nZXRSYW5nZUF0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgIH0gfTtcbiAgICB9XG4gICAgYXBwbHlFZGl0cyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IG9mZiA9IDAsIGFib3J0ID0gZmFsc2UsIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlO1xuICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoZnJvbUEsIHRvQSwgX2Zyb21CLCBfdG9CLCBpbnNlcnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhYm9ydClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZExlbiA9IGluc2VydC5sZW5ndGggLSAodG9BIC0gZnJvbUEpO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgJiYgdG9BID49IHBlbmRpbmcudG8pIHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZy5mcm9tID09IGZyb21BICYmIHBlbmRpbmcudG8gPT0gdG9BICYmIHBlbmRpbmcuaW5zZXJ0LmVxKGluc2VydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsOyAvLyBNYXRjaFxuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZExlbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBNaXNtYXRjaCwgcmV2ZXJ0XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tQSArPSBvZmY7XG4gICAgICAgICAgICB0b0EgKz0gb2ZmO1xuICAgICAgICAgICAgaWYgKHRvQSA8PSB0aGlzLmZyb20pIHsgLy8gQmVmb3JlIHRoZSB3aW5kb3dcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gKz0gZExlbjtcbiAgICAgICAgICAgICAgICB0aGlzLnRvICs9IGRMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQSA8IHRoaXMudG8pIHsgLy8gT3ZlcmxhcHMgd2l0aCB3aW5kb3dcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCB0aGlzLmZyb20gfHwgdG9BID4gdGhpcy50byB8fCAodGhpcy50byAtIHRoaXMuZnJvbSkgKyBpbnNlcnQubGVuZ3RoID4gMzAwMDAgLyogQ3hWcC5NYXhTaXplICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVRleHQodGhpcy50b0NvbnRleHRQb3MoZnJvbUEpLCB0aGlzLnRvQ29udGV4dFBvcyh0b0EpLCBpbnNlcnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmICs9IGRMZW47XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGVuZGluZyAmJiAhYWJvcnQpXG4gICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuICFhYm9ydDtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcmV2ZXJ0ZWQgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlLCBzdGFydFNlbCA9IHVwZGF0ZS5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbXBvc2luZy5kcmlmdGVkIHx8XG4gICAgICAgICAgICAgICAgKCF1cGRhdGUuY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnRTZWwuZnJvbSwgc3RhcnRTZWwudG8pICYmXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50bykpKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nLmRyaWZ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcuZWRpdG9yQmFzZSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbXBvc2luZy5lZGl0b3JCYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5hcHBseUVkaXRzKHVwZGF0ZSkgfHwgIXRoaXMucmFuZ2VJc1ZhbGlkKHVwZGF0ZS5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNldCh1cGRhdGUuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgcmV2ZXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgfVxuICAgIHJlc2V0UmFuZ2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHsgaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWF4KDAsIGhlYWQgLSAxMDAwMCAvKiBDeFZwLk1hcmdpbiAqLyk7XG4gICAgICAgIHRoaXMudG8gPSBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBoZWFkICsgMTAwMDAgLyogQ3hWcC5NYXJnaW4gKi8pO1xuICAgIH1cbiAgICByZXNldChzdGF0ZSkge1xuICAgICAgICB0aGlzLnJlc2V0UmFuZ2Uoc3RhdGUpO1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVRleHQoMCwgdGhpcy5lZGl0Q29udGV4dC50ZXh0Lmxlbmd0aCwgc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHRoaXMuZnJvbSwgdGhpcy50bykpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzdGF0ZSk7XG4gICAgfVxuICAgIHJldmVydFBlbmRpbmcoc3RhdGUpIHtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlO1xuICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVUZXh0KHRoaXMudG9Db250ZXh0UG9zKHBlbmRpbmcuZnJvbSksIHRoaXMudG9Db250ZXh0UG9zKHBlbmRpbmcuZnJvbSArIHBlbmRpbmcuaW5zZXJ0Lmxlbmd0aCksIHN0YXRlLmRvYy5zbGljZVN0cmluZyhwZW5kaW5nLmZyb20sIHBlbmRpbmcudG8pKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKHN0YXRlKSB7XG4gICAgICAgIGxldCB7IG1haW4gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy50b0NvbnRleHRQb3MoTWF0aC5tYXgodGhpcy5mcm9tLCBNYXRoLm1pbih0aGlzLnRvLCBtYWluLmFuY2hvcikpKTtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMudG9Db250ZXh0UG9zKG1haW4uaGVhZCk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRDb250ZXh0LnNlbGVjdGlvblN0YXJ0ICE9IHN0YXJ0IHx8IHRoaXMuZWRpdENvbnRleHQuc2VsZWN0aW9uRW5kICE9IGVuZClcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlU2VsZWN0aW9uKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICByYW5nZUlzVmFsaWQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHsgaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIHJldHVybiAhKHRoaXMuZnJvbSA+IDAgJiYgaGVhZCAtIHRoaXMuZnJvbSA8IDUwMCAvKiBDeFZwLk1pbk1hcmdpbiAqLyB8fFxuICAgICAgICAgICAgdGhpcy50byA8IHN0YXRlLmRvYy5sZW5ndGggJiYgdGhpcy50byAtIGhlYWQgPCA1MDAgLyogQ3hWcC5NaW5NYXJnaW4gKi8gfHxcbiAgICAgICAgICAgIHRoaXMudG8gLSB0aGlzLmZyb20gPiAxMDAwMCAvKiBDeFZwLk1hcmdpbiAqLyAqIDMpO1xuICAgIH1cbiAgICB0b0VkaXRvclBvcyhjb250ZXh0UG9zLCBjbGlwTGVuID0gdGhpcy50byAtIHRoaXMuZnJvbSkge1xuICAgICAgICBjb250ZXh0UG9zID0gTWF0aC5taW4oY29udGV4dFBvcywgY2xpcExlbik7XG4gICAgICAgIGxldCBjID0gdGhpcy5jb21wb3Npbmc7XG4gICAgICAgIHJldHVybiBjICYmIGMuZHJpZnRlZCA/IGMuZWRpdG9yQmFzZSArIChjb250ZXh0UG9zIC0gYy5jb250ZXh0QmFzZSkgOiBjb250ZXh0UG9zICsgdGhpcy5mcm9tO1xuICAgIH1cbiAgICB0b0NvbnRleHRQb3MoZWRpdG9yUG9zKSB7XG4gICAgICAgIGxldCBjID0gdGhpcy5jb21wb3Npbmc7XG4gICAgICAgIHJldHVybiBjICYmIGMuZHJpZnRlZCA/IGMuY29udGV4dEJhc2UgKyAoZWRpdG9yUG9zIC0gYy5lZGl0b3JCYXNlKSA6IGVkaXRvclBvcyAtIHRoaXMuZnJvbTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gdGhpcy5oYW5kbGVycylcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVyc1tldmVudF0pO1xuICAgIH1cbn1cblxuLy8gVGhlIGVkaXRvcidzIHVwZGF0ZSBzdGF0ZSBtYWNoaW5lIGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gICAgIElkbGUg4oaSIFVwZGF0aW5nIOKHhiBJZGxlICh1bmNoZWNrZWQpIOKGkiBNZWFzdXJpbmcg4oaSIElkbGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgICAgICDihpNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGluZyAobWVhc3VyZSlcbi8vXG4vLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdJZGxlJyBhbmQgJ0lkbGUgKHVuY2hlY2tlZCknIGxpZXMgaW5cbi8vIHdoZXRoZXIgYSBsYXlvdXQgY2hlY2sgaGFzIGJlZW4gc2NoZWR1bGVkLiBBIHJlZ3VsYXIgdXBkYXRlIHRocm91Z2hcbi8vIHRoZSBgdXBkYXRlYCBtZXRob2QgdXBkYXRlcyB0aGUgRE9NIGluIGEgd3JpdGUtb25seSBmYXNoaW9uLCBhbmRcbi8vIHJlbGllcyBvbiBhIGNoZWNrIChzY2hlZHVsZWQgd2l0aCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCkgdG8gbWFrZVxuLy8gc3VyZSBldmVyeXRoaW5nIGlzIHdoZXJlIGl0IHNob3VsZCBiZSBhbmQgdGhlIHZpZXdwb3J0IGNvdmVycyB0aGVcbi8vIHZpc2libGUgY29kZS4gVGhhdCBjaGVjayBjb250aW51ZXMgdG8gbWVhc3VyZSBhbmQgdGhlbiBvcHRpb25hbGx5XG4vLyB1cGRhdGUgdW50aWwgaXQgcmVhY2hlcyBhIGNvaGVyZW50IHN0YXRlLlxuLyoqXG5BbiBlZGl0b3IgdmlldyByZXByZXNlbnRzIHRoZSBlZGl0b3IncyB1c2VyIGludGVyZmFjZS4gSXQgaG9sZHNcbnRoZSBlZGl0YWJsZSBET00gc3VyZmFjZSwgYW5kIHBvc3NpYmx5IG90aGVyIGVsZW1lbnRzIHN1Y2ggYXMgdGhlXG5saW5lIG51bWJlciBndXR0ZXIuIEl0IGhhbmRsZXMgZXZlbnRzIGFuZCBkaXNwYXRjaGVzIHN0YXRlXG50cmFuc2FjdGlvbnMgZm9yIGVkaXRpbmcgYWN0aW9ucy5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zdGF0ZTsgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGlzcGxheSBsYXJnZSBkb2N1bWVudHMgd2l0aG91dCBjb25zdW1pbmcgdG9vIG11Y2hcbiAgICBtZW1vcnkgb3Igb3ZlcmxvYWRpbmcgdGhlIGJyb3dzZXIsIENvZGVNaXJyb3Igb25seSBkcmF3cyB0aGVcbiAgICBjb2RlIHRoYXQgaXMgdmlzaWJsZSAocGx1cyBhIG1hcmdpbiBhcm91bmQgaXQpIHRvIHRoZSBET00uIFRoaXNcbiAgICBwcm9wZXJ0eSB0ZWxscyB5b3UgdGhlIGV4dGVudCBvZiB0aGUgY3VycmVudCBkcmF3biB2aWV3cG9ydCwgaW5cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgYXJlLCBmb3IgZXhhbXBsZSwgbGFyZ2UgY29sbGFwc2VkIHJhbmdlcyBpbiB0aGVcbiAgICB2aWV3cG9ydCwgaXRzIHNpemUgY2FuIGJlIGEgbG90IGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgdmlzaWJsZVxuICAgIGNvbnRlbnQuIFRodXMsIGlmIHlvdSBhcmUgZG9pbmcgc29tZXRoaW5nIGxpa2Ugc3R5bGluZyB0aGVcbiAgICBjb250ZW50IGluIHRoZSB2aWV3cG9ydCwgaXQgaXMgcHJlZmVyYWJsZSB0byBvbmx5IGRvIHNvIGZvclxuICAgIHRoZXNlIHJhbmdlcywgd2hpY2ggYXJlIHRoZSBzdWJzZXQgb2YgdGhlIHZpZXdwb3J0IHRoYXQgaXNcbiAgICBhY3R1YWxseSBkcmF3bi5cbiAgICAqL1xuICAgIGdldCB2aXNpYmxlUmFuZ2VzKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlzaWJsZVJhbmdlczsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgZWRpdG9yIGlzIGVudGlyZWx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XG4gICAgb3Igb3RoZXJ3aXNlIGhpZGRlbi5cbiAgICAqL1xuICAgIGdldCBpblZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5pblZpZXc7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIHRleHQgdmlhXG4gICAgW0lNRV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5wdXRfbWV0aG9kKSwgYW5kIGF0IGxlYXN0XG4gICAgb25lIGNoYW5nZSBoYXMgYmVlbiBtYWRlIGluIHRoZSBjdXJyZW50IGNvbXBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuICEhdGhpcy5pbnB1dFN0YXRlICYmIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGluIGNvbXBvc2luZyBzdGF0ZS4gTm90ZVxuICAgIHRoYXQgb24gc29tZSBwbGF0Zm9ybXMsIGxpa2UgQW5kcm9pZCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIGFcbiAgICBsb3QsIHNpbmNlIGp1c3QgcHV0dGluZyB0aGUgY3Vyc29yIG9uIGEgd29yZCBzdGFydHMgYVxuICAgIGNvbXBvc2l0aW9uIHRoZXJlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2l0aW9uU3RhcnRlZCgpIHsgcmV0dXJuICEhdGhpcy5pbnB1dFN0YXRlICYmIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMDsgfVxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBvciBzaGFkb3cgcm9vdCB0aGF0IHRoZSB2aWV3IGxpdmVzIGluLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLl9yb290OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2luKCkgeyByZXR1cm4gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdmlldy4gWW91J2xsIHdhbnQgdG8gZWl0aGVyIHByb3ZpZGUgYSBgcGFyZW50YFxuICAgIG9wdGlvbiwgb3IgcHV0IGB2aWV3LmRvbWAgaW50byB5b3VyIGRvY3VtZW50IGFmdGVyIGNyZWF0aW5nIGFcbiAgICB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWUgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luTWFwID0gbmV3IE1hcDtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW107XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00udGFiSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uY2xhc3NOYW1lID0gXCJjbS1zY3JvbGxlclwiO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5jbGFzc05hbWUgPSBcImNtLWFubm91bmNlZFwiO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmFubm91bmNlRE9NKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxET00pO1xuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICBsZXQgeyBkaXNwYXRjaCB9ID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zID0gY29uZmlnLmRpc3BhdGNoVHJhbnNhY3Rpb25zIHx8XG4gICAgICAgICAgICAoZGlzcGF0Y2ggJiYgKCh0cnMpID0+IHRycy5mb3JFYWNoKHRyID0+IGRpc3BhdGNoKHRyLCB0aGlzKSkpKSB8fFxuICAgICAgICAgICAgKCh0cnMpID0+IHRoaXMudXBkYXRlKHRycykpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yb290ID0gKGNvbmZpZy5yb290IHx8IGdldFJvb3QoY29uZmlnLnBhcmVudCkgfHwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUoY29uZmlnLnN0YXRlIHx8IEVkaXRvclN0YXRlLmNyZWF0ZShjb25maWcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5zY3JvbGxUbyAmJiBjb25maWcuc2Nyb2xsVG8uaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gY29uZmlnLnNjcm9sbFRvLnZhbHVlLmNsaXAodGhpcy52aWV3U3RhdGUuc3RhdGUpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAoKF9hID0gZG9jdW1lbnQuZm9udHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeSlcbiAgICAgICAgICAgIGRvY3VtZW50LmZvbnRzLnJlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKC4uLmlucHV0KSB7XG4gICAgICAgIGxldCB0cnMgPSBpbnB1dC5sZW5ndGggPT0gMSAmJiBpbnB1dFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gaW5wdXRcbiAgICAgICAgICAgIDogaW5wdXQubGVuZ3RoID09IDEgJiYgQXJyYXkuaXNBcnJheShpbnB1dFswXSkgPyBpbnB1dFswXVxuICAgICAgICAgICAgICAgIDogW3RoaXMuc3RhdGUudXBkYXRlKC4uLmlucHV0KV07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnModHJzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLiBUaGlzIHdpbGxcbiAgICB1cGRhdGUgdGhlIHZpc2libGUgZG9jdW1lbnQgYW5kIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgc3RhdGVcbiAgICBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb25zLCBhbmQgbm90aWZ5IHZpZXcgcGx1Z2lucyBvZiB0aGVcbiAgICBjaGFuZ2UuIFlvdSBzaG91bGQgdXN1YWxseSBjYWxsXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLCB3aGljaCB1c2VzIHRoaXNcbiAgICBhcyBhIHByaW1pdGl2ZS5cbiAgICAqL1xuICAgIHVwZGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy51cGRhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgbGV0IHJlZHJhd24gPSBmYWxzZSwgYXR0cnNDaGFuZ2VkID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgc3RhdGUgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZG9lc24ndCBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cIik7XG4gICAgICAgICAgICBzdGF0ZSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm9jdXMgPSB0aGlzLmhhc0ZvY3VzLCBmb2N1c0ZsYWcgPSAwLCBkaXNwYXRjaEZvY3VzID0gbnVsbDtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmFubm90YXRpb24oaXNGb2N1c0NoYW5nZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkID0gZm9jdXM7XG4gICAgICAgICAgICAvLyBJZiBhIGZvY3VzLWNoYW5nZSB0cmFuc2FjdGlvbiBpcyBiZWluZyBkaXNwYXRjaGVkLCBzZXQgdGhpcyB1cGRhdGUgZmxhZy5cbiAgICAgICAgICAgIGZvY3VzRmxhZyA9IDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb2N1cyAhPSB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkID0gZm9jdXM7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHNlcGFyYXRlIGZvY3VzIHRyYW5zYWN0aW9uIGlmIG5lY2Vzc2FyeSwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBhZGQgYSBmbGFnIHRvIHRoaXMgdXBkYXRlXG4gICAgICAgICAgICBkaXNwYXRjaEZvY3VzID0gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbihzdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKCFkaXNwYXRjaEZvY3VzKVxuICAgICAgICAgICAgICAgIGZvY3VzRmxhZyA9IDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIERPTSBjaGFuZ2UsIGVhZ2VybHkgcmVhZCBpdCBhbmQgdHJ5IHRvXG4gICAgICAgIC8vIGFwcGx5IGl0IGFmdGVyIHRoZSBnaXZlbiB0cmFuc2FjdGlvbnMuXG4gICAgICAgIGxldCBwZW5kaW5nS2V5ID0gdGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSwgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKHBlbmRpbmdLZXkpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgZG9tQ2hhbmdlID0gdGhpcy5vYnNlcnZlci5yZWFkQ2hhbmdlKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHRyeSB0byBhcHBseSBET00gY2hhbmdlcyBpZiB0aGUgdHJhbnNhY3Rpb25zIGRpZG4ndFxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBkb2Mgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSAmJiAhdGhpcy5zdGF0ZS5kb2MuZXEoc3RhdGUuZG9jKSB8fCAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHBocmFzZXMgY2hhbmdlLCByZWRyYXcgdGhlIGVkaXRvclxuICAgICAgICBpZiAoc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykgIT0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSBmb2N1c0ZsYWc7XG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXQgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG1haW4gfSA9IHRyLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gbmV3IFNjcm9sbFRhcmdldChtYWluLmVtcHR5ID8gbWFpbiA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobWFpbi5oZWFkLCBtYWluLmhlYWQgPiBtYWluLmFuY2hvciA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IGUudmFsdWUuY2xpcCh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IENhY2hlZE9yZGVyLnVwZGF0ZSh0aGlzLmJpZGlDYWNoZSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpICE9IHRoaXMuc3R5bGVNb2R1bGVzKVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIGF0dHJzQ2hhbmdlZCA9IHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Fubm91bmNlbWVudHModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24ocmVkcmF3biwgdHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuaXNVc2VyRXZlbnQoXCJzZWxlY3QucG9pbnRlclwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodGhlbWUpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGVtZSkpXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICBpZiAocmVkcmF3biB8fCBhdHRyc0NoYW5nZWQgfHwgc2Nyb2xsVGFyZ2V0IHx8IHRoaXMudmlld1N0YXRlLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgfHwgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgIHRoaXMuZG9jVmlld1VwZGF0ZSgpO1xuICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUsIFwidXBkYXRlIGxpc3RlbmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgfHwgZG9tQ2hhbmdlKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgJiYgdGhpcy5zdGF0ZSA9PSBkaXNwYXRjaEZvY3VzLnN0YXJ0U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGlzcGF0Y2hGb2N1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuY29udGVudERPTSwgcGVuZGluZ0tleS5rZXksIHBlbmRpbmdLZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxuICAgIHNvIHlvdSBzaG91bGQgcHJvYmFibHkgb25seSB1c2UgaXQgd2hlbiB0aGUgbmV3IHN0YXRlIGlzbid0XG4gICAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcbiAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcuc2V0U3RhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICBsZXQgaGFkRm9jdXMgPSB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhZEZvY3VzKVxuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVBsdWdpbnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2U3BlY3MgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKSwgc3BlY3MgPSB1cGRhdGUuc3RhdGUuZmFjZXQodmlld1BsdWdpbik7XG4gICAgICAgIGlmIChwcmV2U3BlY3MgIT0gc3BlY3MpIHtcbiAgICAgICAgICAgIGxldCBuZXdQbHVnaW5zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIHNwZWNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gcHJldlNwZWNzLmluZGV4T2Yoc3BlYyk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gobmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbZm91bmRdO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLm11c3RVcGRhdGUgIT0gdXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1BsdWdpbnM7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcC5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW2ldLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcylcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgIH1cbiAgICBkb2NWaWV3VXBkYXRlKCkge1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gcGx1Z2luLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuZG9jVmlld1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kb2NWaWV3VXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSwgXCJkb2MgdmlldyB1cGRhdGUgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gMDsgLy8gUHJldmVudCByZXF1ZXN0TWVhc3VyZSBjYWxscyBmcm9tIHNjaGVkdWxpbmcgYW5vdGhlciBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgaWYgKGZsdXNoKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgbGV0IHNET00gPSB0aGlzLnNjcm9sbERPTSwgc2Nyb2xsVG9wID0gc0RPTS5zY3JvbGxUb3AgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGV0IHsgc2Nyb2xsQW5jaG9yUG9zLCBzY3JvbGxBbmNob3JIZWlnaHQgfSA9IHRoaXMudmlld1N0YXRlO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc2Nyb2xsVG9wIC0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVG9wKSA+IDEpXG4gICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxBbmNob3JIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Njcm9sbGVkVG9Cb3R0b20oc0RPTSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JQb3MgPSBibG9jay5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAxIC8qIFVwZGF0ZVN0YXRlLk1lYXN1cmluZyAqLztcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMudmlld1N0YXRlLm1lYXN1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmICF0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggJiYgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpID4gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiTWVhc3VyZSBsb29wIHJlc3RhcnRlZCBtb3JlIHRoYW4gNSB0aW1lc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiVmlld3BvcnQgZmFpbGVkIHRvIHN0YWJpbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biBtZWFzdXJlIHJlcXVlc3RzIGluIHRoaXMgY3ljbGUgd2hlbiB0aGUgdmlld3BvcnQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZWQgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pKVxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5tZWFzdXJlUmVxdWVzdHMsIG1lYXN1cmluZ10gPSBbbWVhc3VyaW5nLCB0aGlzLm1lYXN1cmVSZXF1ZXN0c107XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmVkID0gbWVhc3VyaW5nLm1hcChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLnJlYWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCYWRNZWFzdXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHRoaXMuc3RhdGUsIFtdKSwgcmVkcmF3biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3VXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyaW5nLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRbaV0gIT0gQmFkTWVhc3VyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1lYXN1cmluZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS53cml0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS53cml0ZShtZWFzdXJlZFtpXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCAmJiB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnNjcm9sbEludG9WaWV3KHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdBbmNob3JIZWlnaHQgPSBzY3JvbGxBbmNob3JQb3MgPCAwID8gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHNjcm9sbEFuY2hvclBvcykudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gbmV3QW5jaG9ySGVpZ2h0IC0gc2Nyb2xsQW5jaG9ySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMSB8fCBkaWZmIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gc2Nyb2xsVG9wICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0RPTS5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgLyB0aGlzLnNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgIXVwZGF0ZWQuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBDU1MgY2xhc3NlcyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWRpdG9yIHRoZW1lcy5cbiAgICAqL1xuICAgIGdldCB0aGVtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBiYXNlVGhlbWVJRCArIFwiIFwiICtcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLmZhY2V0KGRhcmtUaGVtZSkgPyBiYXNlRGFya0lEIDogYmFzZUxpZ2h0SUQpICsgXCIgXCIgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5mYWNldCh0aGVtZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF0dHJzKCkge1xuICAgICAgICBsZXQgZWRpdG9yQXR0cnMgPSBhdHRyc0Zyb21GYWNldCh0aGlzLCBlZGl0b3JBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1lZGl0b3JcIiArICh0aGlzLmhhc0ZvY3VzID8gXCIgY20tZm9jdXNlZCBcIiA6IFwiIFwiKSArIHRoaXMudGhlbWVDbGFzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY29udGVudEF0dHJzID0ge1xuICAgICAgICAgICAgc3BlbGxjaGVjazogXCJmYWxzZVwiLFxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJvZmZcIixcbiAgICAgICAgICAgIHdyaXRpbmdzdWdnZXN0aW9uczogXCJmYWxzZVwiLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBcIm5vXCIsXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6ICF0aGlzLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tY29udGVudFwiLFxuICAgICAgICAgICAgc3R5bGU6IGAke2Jyb3dzZXIudGFiU2l6ZX06ICR7dGhpcy5zdGF0ZS50YWJTaXplfWAsXG4gICAgICAgICAgICByb2xlOiBcInRleHRib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogXCJ0cnVlXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICBjb250ZW50QXR0cnNbXCJhcmlhLXJlYWRvbmx5XCJdID0gXCJ0cnVlXCI7XG4gICAgICAgIGF0dHJzRnJvbUZhY2V0KHRoaXMsIGNvbnRlbnRBdHRyaWJ1dGVzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29udGVudCA9IHVwZGF0ZUF0dHJzKHRoaXMuY29udGVudERPTSwgdGhpcy5jb250ZW50QXR0cnMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZEVkaXRvciA9IHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLmVkaXRvckF0dHJzLCBlZGl0b3JBdHRycyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZENvbnRlbnQgfHwgY2hhbmdlZEVkaXRvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSBlZGl0b3JBdHRycztcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSBjb250ZW50QXR0cnM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICBzaG93QW5ub3VuY2VtZW50cyh0cnMpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhFZGl0b3JWaWV3LmFubm91bmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlRE9NLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdiA9IHRoaXMuYW5ub3VuY2VET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50U3R5bGVzKCkge1xuICAgICAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpO1xuICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuY3NwTm9uY2UpO1xuICAgICAgICBTdHlsZU1vZHVsZS5tb3VudCh0aGlzLnJvb3QsIHRoaXMuc3R5bGVNb2R1bGVzLmNvbmNhdChiYXNlVGhlbWUkMSkucmV2ZXJzZSgpLCBub25jZSA/IHsgbm9uY2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8gJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBTY2hlZHVsZSBhIGxheW91dCBtZWFzdXJlbWVudCwgb3B0aW9uYWxseSBwcm92aWRpbmcgY2FsbGJhY2tzIHRvXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXG4gICAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgICBleGFtcGxlLCBhbiBldmVudCBoYW5kbGVyLCBiZWNhdXNlIGl0J2xsIG1ha2Ugc3VyZSBtZWFzdXJpbmcgYW5kXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xuICAgIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAgICovXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkIDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHRoaXMud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldLmtleSA9PT0gcmVxdWVzdC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmljIHBsdWdpbiwgaWYgcHJlc2VudC4gTm90ZSB0aGF0XG4gICAgcGx1Z2lucyB0aGF0IGNyYXNoIGNhbiBiZSBkcm9wcGVkIGZyb20gYSB2aWV3LCBzbyBldmVuIHdoZW4geW91XG4gICAga25vdyB5b3UgcmVnaXN0ZXJlZCBhIGdpdmVuIHBsdWdpbiwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hlY2tcbiAgICB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgcGx1Z2luKHBsdWdpbikge1xuICAgICAgICBsZXQga25vd24gPSB0aGlzLnBsdWdpbk1hcC5nZXQocGx1Z2luKTtcbiAgICAgICAgaWYgKGtub3duID09PSB1bmRlZmluZWQgfHwga25vd24gJiYga25vd24ucGx1Z2luICE9IHBsdWdpbilcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLnNldChwbHVnaW4sIGtub3duID0gdGhpcy5wbHVnaW5zLmZpbmQocCA9PiBwLnBsdWdpbiA9PSBwbHVnaW4pIHx8IG51bGwpO1xuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXG4gICAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgICBkaXJlY3RseSB0byB0aGUgdG9wIG9mIHRoZSBmaXJzdCBsaW5lLCBub3QgYWJvdmUgdGhlIHBhZGRpbmcuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwb3J0cyB0aGUgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgSWYgdGhlIGVkaXRvciBpcyB0cmFuc2Zvcm1lZCB3aXRoIENTUywgdGhpcyBwcm92aWRlcyB0aGUgc2NhbGVcbiAgICBhbG9uZyB0aGUgWCBheGlzLiBPdGhlcndpc2UsIGl0IHdpbGwganVzdCBiZSAxLiBOb3RlIHRoYXRcbiAgICB0cmFuc2Zvcm1zIG90aGVyIHRoYW4gdHJhbnNsYXRpb24gYW5kIHNjYWxpbmcgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVYKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVYOyB9XG4gICAgLyoqXG4gICAgUHJvdmlkZSB0aGUgQ1NTIHRyYW5zZm9ybWVkIHNjYWxlIGFsb25nIHRoZSBZIGF4aXMuXG4gICAgKi9cbiAgICBnZXQgc2NhbGVZKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVZOyB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWxcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKSkuXG4gICAgKi9cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayAoc2VlXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSkgYXQgdGhlIGdpdmVuXG4gICAgaGVpZ2h0LCBhZ2FpbiBpbnRlcnByZXRlZCByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApLlxuICAgICovXG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGV4dGVudCBhbmQgdmVydGljYWwgcG9zaXRpb24gb2YgYWxsIFtsaW5lXG4gICAgYmxvY2tzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lQmxvY2tBdCkgaW4gdGhlIHZpZXdwb3J0LiBQb3NpdGlvbnNcbiAgICBhcmUgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKTtcbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydExpbmVCbG9ja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydExpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIGFyb3VuZCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIEEgbGluZVxuICAgIGJsb2NrIGlzIGEgcmFuZ2UgZGVsaW1pdGVkIG9uIGJvdGggc2lkZXMgYnkgZWl0aGVyIGFcbiAgICBub24tW2hpZGRlbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgbGluZSBicmVhaywgb3IgdGhlXG4gICAgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudC4gSXQgd2lsbCB1c3VhbGx5IGp1c3QgaG9sZCBhIGxpbmUgb2ZcbiAgICB0ZXh0LCBidXQgbWF5IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIHRleHRibG9ja3MgYnkgYmxvY2tcbiAgICB3aWRnZXRzLlxuICAgICovXG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZWRpdG9yJ3MgdG90YWwgY29udGVudCBoZWlnaHQuXG4gICAgKi9cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYnkgW2dyYXBoZW1lXG4gICAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxuICAgIHRoZSBtb3Rpb24gaXMgYXdheSBmcm9tIHRoZSBsaW5lIHN0YXJ0LCBvciB0b3dhcmRzIGl0LiBJblxuICAgIGJpZGlyZWN0aW9uYWwgdGV4dCwgdGhlIGxpbmUgaXMgdHJhdmVyc2VkIGluIHZpc3VhbCBvcmRlciwgdXNpbmdcbiAgICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiAgICBXaGVuIHRoZSBzdGFydCBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGVcbiAgICByZXR1cm5lZCBwb3NpdGlvbiB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm9cbiAgICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbml0aWFsID0+IGJ5R3JvdXAodGhpcywgc3RhcnQuaGVhZCwgaW5pdGlhbCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJzb3IgcG9zaXRpb24gdmlzdWFsbHkgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIGxpbmUuXG4gICAgTm90ZSB0aGF0IHRoaXMgbWF5IGRpZmZlciBmcm9tIHRoZSBfbG9naWNhbF8gcG9zaXRpb24gYXQgaXRzXG4gICAgc3RhcnQgb3IgZW5kICh3aGljaCBpcyBzaW1wbHkgYXQgYGxpbmUuZnJvbWAvYGxpbmUudG9gKSBpZiB0ZXh0XG4gICAgYXQgdGhlIHN0YXJ0IG9yIGVuZCBnb2VzIGFnYWluc3QgdGhlIGxpbmUncyBiYXNlIHRleHQgZGlyZWN0aW9uLlxuICAgICovXG4gICAgdmlzdWFsTGluZVNpZGUobGluZSwgZW5kKSB7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpLCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW2VuZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwXTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3Bhbi5zaWRlKGVuZCwgZGlyKSArIGxpbmUuZnJvbSwgc3Bhbi5mb3J3YXJkKCFlbmQsIGRpcikgPyAxIDogLTEpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi4gSWZcbiAgICBgaW5jbHVkZVdyYXBgIGlzIHRydWUsIGxpbmUgd3JhcHBpbmcgaXMgb24sIGFuZCB0aGVyZSBpcyBhXG4gICAgZnVydGhlciB3cmFwIHBvaW50IG9uIHRoZSBjdXJyZW50IGxpbmUsIHRoZSB3cmFwIHBvaW50IHdpbGwgYmVcbiAgICByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHN0YXJ0IG9yIGVuZFxuICAgIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgbW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVUb0xpbmVCb3VuZGFyeSh0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIHZlcnRpY2FsbHkuIFdoZW4gYGRpc3RhbmNlYCBpc24ndCBnaXZlbixcbiAgICBpdCBkZWZhdWx0cyB0byBtb3ZpbmcgdG8gdGhlIG5leHQgbGluZSAoaW5jbHVkaW5nIHdyYXBwZWRcbiAgICBsaW5lcykuIE90aGVyd2lzZSwgYGRpc3RhbmNlYCBzaG91bGQgcHJvdmlkZSBhIHBvc2l0aXZlIGRpc3RhbmNlXG4gICAgaW4gcGl4ZWxzLlxuICAgIFxuICAgIFdoZW4gYHN0YXJ0YCBoYXMgYVxuICAgIFtgZ29hbENvbHVtbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZ29hbENvbHVtbiksIHRoZSB2ZXJ0aWNhbFxuICAgIG1vdGlvbiB3aWxsIHVzZSB0aGF0IGFzIGEgdGFyZ2V0IGhvcml6b250YWwgcG9zaXRpb24uIE90aGVyd2lzZSxcbiAgICB0aGUgY3Vyc29yJ3Mgb3duIGhvcml6b250YWwgcG9zaXRpb24gaXMgdXNlZC4gVGhlIHJldHVybmVkXG4gICAgY3Vyc29yIHdpbGwgaGF2ZSBpdHMgZ29hbCBjb2x1bW4gc2V0IHRvIHdoaWNoZXZlciBjb2x1bW4gd2FzXG4gICAgdXNlZC5cbiAgICAqL1xuICAgIG1vdmVWZXJ0aWNhbGx5KHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlVmVydGljYWxseSh0aGlzLCBzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIHBhcmVudCBub2RlIGFuZCBvZmZzZXQgKGNoaWxkIG9mZnNldCBpZiBgbm9kZWAgaXNcbiAgICBhbiBlbGVtZW50LCBjaGFyYWN0ZXIgb2Zmc2V0IHdoZW4gaXQgaXMgYSB0ZXh0IG5vZGUpIGF0IHRoZVxuICAgIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBmb3IgcG9zaXRpb25zIHRoYXQgYXJlbid0IGN1cnJlbnRseSBpblxuICAgIGB2aXNpYmxlUmFuZ2VzYCwgdGhlIHJlc3VsdGluZyBET00gcG9zaXRpb24gaXNuJ3QgbmVjZXNzYXJpbHlcbiAgICBtZWFuaW5nZnVsIChpdCBtYXkganVzdCBwb2ludCBiZWZvcmUgb3IgYWZ0ZXIgYSBwbGFjZWhvbGRlclxuICAgIGVsZW1lbnQpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCBmb3VuZCA9IHBvc0F0Q29vcmRzKHRoaXMsIGNvb3JkcywgcHJlY2lzZSk7XG4gICAgICAgIHJldHVybiBmb3VuZCAmJiBmb3VuZC5wb3M7XG4gICAgfVxuICAgIHBvc0FuZFNpZGVBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSByZWN0YW5nbGUgYXJvdW5kIGEgZ2l2ZW4gY2hhcmFjdGVyLiBJZiBgcG9zYCBkb2VzIG5vdFxuICAgIHBvaW50IGluIGZyb250IG9mIGEgY2hhcmFjdGVyIHRoYXQgaXMgaW4gdGhlIHZpZXdwb3J0IGFuZFxuICAgIHJlbmRlcmVkIChpLmUuIG5vdCByZXBsYWNlZCwgbm90IGEgbGluZSBicmVhayksIHRoaXMgd2lsbCByZXR1cm5cbiAgICBudWxsLiBGb3Igc3BhY2UgY2hhcmFjdGVycyB0aGF0IGFyZSBhIGxpbmUgd3JhcCBwb2ludCwgdGhpcyB3aWxsXG4gICAgcmV0dXJuIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIGxpbmUgYnJlYWsuXG4gICAgKi9cbiAgICBjb29yZHNGb3JDaGFyKHBvcykge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICAgIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgd2lkdGggb2YgYWxsIGNoYXJhY3RlcnMgKGdpdmVuIHZhcmlhYmxlXG4gICAgd2lkdGggZm9udHMgb3Igc3R5bGluZyBvZiBpbnZpZGlkdWFsIHJhbmdlcykuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdENoYXJhY3RlcldpZHRoKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxuICAgIGZvciBhbGwgbGluZXMuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXG4gICAgQ1NTIHByb3BlcnR5KSBvZiB0aGUgZWRpdG9yJ3MgY29udGVudCBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjsgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFzXG4gICAgYXNzaWduZWQgYnkgQ1NTLiBJZlxuICAgIFtgcGVyTGluZVRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15wZXJMaW5lVGV4dERpcmVjdGlvbilcbiAgICBpc24ndCBlbmFibGVkLCBvciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQsXG4gICAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcbiAgICBbYHRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gTm90ZSB0aGF0XG4gICAgdGhpcyBtYXkgdHJpZ2dlciBhIERPTSBsYXlvdXQuXG4gICAgKi9cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCBwZXJMaW5lID0gdGhpcy5zdGF0ZS5mYWNldChwZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghcGVyTGluZSB8fCBwb3MgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgcG9zID4gdGhpcy52aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHREaXJlY3Rpb247XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcudGV4dERpcmVjdGlvbkF0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXG4gICAgKGFzIGRldGVybWluZWQgYnkgdGhlXG4gICAgW2B3aGl0ZS1zcGFjZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy93aGl0ZS1zcGFjZSlcbiAgICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXG4gICAgKi9cbiAgICBnZXQgbGluZVdyYXBwaW5nKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIGxpbmVcbiAgICAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50IGRvY3VtZW50KSBhcyBhbiBhcnJheSBvZiBzcGFuXG4gICAgb2JqZWN0cy4gVGhlIG9yZGVyIG9mIHRoZXNlIHNwYW5zIG1hdGNoZXMgdGhlIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKeKAlGlmIHRoYXQgaXNcbiAgICBsZWZ0LXRvLXJpZ2h0LCB0aGUgbGVmdG1vc3Qgc3BhbnMgY29tZSBmaXJzdCwgb3RoZXJ3aXNlIHRoZVxuICAgIHJpZ2h0bW9zdCBzcGFucyBjb21lIGZpcnN0LlxuICAgICovXG4gICAgYmlkaVNwYW5zKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gTWF4QmlkaUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICAgICAgbGV0IGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSksIGlzb2xhdGVzO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiB0aGlzLmJpZGlDYWNoZSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LmZyb20gPT0gbGluZS5mcm9tICYmIGVudHJ5LmRpciA9PSBkaXIgJiZcbiAgICAgICAgICAgICAgICAoZW50cnkuZnJlc2ggfHwgaXNvbGF0ZXNFcShlbnRyeS5pc29sYXRlcywgaXNvbGF0ZXMgPSBnZXRJc29sYXRlZFJhbmdlcyh0aGlzLCBsaW5lKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5vcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzb2xhdGVzKVxuICAgICAgICAgICAgaXNvbGF0ZXMgPSBnZXRJc29sYXRlZFJhbmdlcyh0aGlzLCBsaW5lKTtcbiAgICAgICAgbGV0IG9yZGVyID0gY29tcHV0ZU9yZGVyKGxpbmUudGV4dCwgZGlyLCBpc29sYXRlcyk7XG4gICAgICAgIHRoaXMuYmlkaUNhY2hlLnB1c2gobmV3IENhY2hlZE9yZGVyKGxpbmUuZnJvbSwgbGluZS50bywgZGlyLCBpc29sYXRlcywgdHJ1ZSwgb3JkZXIpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBlZGl0b3IgaGFzIGZvY3VzLlxuICAgICovXG4gICAgZ2V0IGhhc0ZvY3VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFNhZmFyaSByZXR1cm4gZmFsc2UgZm9yIGhhc0ZvY3VzIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuXG4gICAgICAgIC8vIG9yIGNsb3NpbmcsIHdoaWNoIGxlYWRzIHVzIHRvIGlnbm9yZSBzZWxlY3Rpb24gY2hhbmdlcyBmcm9tIHRoZVxuICAgICAgICAvLyBjb250ZXh0IG1lbnUgYmVjYXVzZSBpdCBsb29rcyBsaWtlIHRoZSBlZGl0b3IgaXNuJ3QgZm9jdXNlZC5cbiAgICAgICAgLy8gVGhpcyBrbHVkZ2VzIGFyb3VuZCB0aGF0LlxuICAgICAgICByZXR1cm4gKHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuaGFzRm9jdXMoKSB8fCBicm93c2VyLnNhZmFyaSAmJiAoKF9hID0gdGhpcy5pbnB1dFN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdENvbnRleHRNZW51KSA+IERhdGUubm93KCkgLSAzZTQpICYmXG4gICAgICAgICAgICB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET007XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBmb2N1cyBvbiB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBbcm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyMjdmlldy5FZGl0b3JWaWV3Q29uZmlnLnJvb3QpIGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuIFRoaXMgaXMgb25seVxuICAgIG5lY2Vzc2FyeSB3aGVuIG1vdmluZyB0aGUgZWRpdG9yJ3MgZXhpc3RpbmcgRE9NIHRvIGEgbmV3IHdpbmRvdyBvciBzaGFkb3cgcm9vdC5cbiAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICBpZiAodGhpcy5fcm9vdCAhPSByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuc2V0V2luZG93KChyb290Lm5vZGVUeXBlID09IDkgPyByb290IDogcm9vdC5vd25lckRvY3VtZW50KS5kZWZhdWx0VmlldyB8fCB3aW5kb3cpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFuIHVwIHRoaXMgZWRpdG9yIHZpZXcsIHJlbW92aW5nIGl0cyBlbGVtZW50IGZyb20gdGhlXG4gICAgZG9jdW1lbnQsIHVucmVnaXN0ZXJpbmcgZXZlbnQgaGFuZGxlcnMsIGFuZCBub3RpZnlpbmdcbiAgICBwbHVnaW5zLiBUaGUgdmlldyBpbnN0YW5jZSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXJcbiAgICBjYWxsaW5nIHRoaXMuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gICAgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhIHRyYW5zYWN0aW9uIHRvXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgc2Nyb2xsSW50b1ZpZXcocG9zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGFuIGVmZmVjdCB0aGF0IHJlc2V0cyB0aGUgZWRpdG9yIHRvIGl0cyBjdXJyZW50IChhdCB0aGVcbiAgICB0aW1lIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQpIHNjcm9sbCBwb3NpdGlvbi4gTm90ZSB0aGF0IHRoaXNcbiAgICBvbmx5IGFmZmVjdHMgdGhlIGVkaXRvcidzIG93biBzY3JvbGxhYmxlIGVsZW1lbnQsIG5vdCBwYXJlbnRzLlxuICAgIFNlZSBhbHNvXG4gICAgW2BFZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdDb25maWcuc2Nyb2xsVG8pLlxuICAgIFxuICAgIFRoZSBlZmZlY3Qgc2hvdWxkIGJlIHVzZWQgd2l0aCBhIGRvY3VtZW50IGlkZW50aWNhbCB0byB0aGUgb25lXG4gICAgaXQgd2FzIGNyZWF0ZWQgZm9yLiBGYWlsaW5nIHRvIGRvIHNvIGlzIG5vdCBhbiBlcnJvciwgYnV0IG1heVxuICAgIG5vdCBzY3JvbGwgdG8gdGhlIGV4cGVjdGVkIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdC5tYXApIHRoZSBlZmZlY3QgdG8gYWNjb3VudCBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIHNjcm9sbFNuYXBzaG90KCkge1xuICAgICAgICBsZXQgeyBzY3JvbGxUb3AsIHNjcm9sbExlZnQgfSA9IHRoaXMuc2Nyb2xsRE9NO1xuICAgICAgICBsZXQgcmVmID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyZWYuZnJvbSksIFwic3RhcnRcIiwgXCJzdGFydFwiLCByZWYudG9wIC0gc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0LCB0cnVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEVuYWJsZSBvciBkaXNhYmxlIHRhYi1mb2N1cyBtb2RlLCB3aGljaCBkaXNhYmxlcyBrZXkgYmluZGluZ3NcbiAgICBmb3IgVGFiIGFuZCBTaGlmdC1UYWIsIGxldHRpbmcgdGhlIGJyb3dzZXIncyBkZWZhdWx0XG4gICAgZm9jdXMtY2hhbmdpbmcgYmVoYXZpb3IgZ28gdGhyb3VnaCBpbnN0ZWFkLiBUaGlzIGlzIHVzZWZ1bCB0b1xuICAgIHByZXZlbnQgdHJhcHBpbmcga2V5Ym9hcmQgdXNlcnMgaW4geW91ciBlZGl0b3IuXG4gICAgXG4gICAgV2l0aG91dCBhcmd1bWVudCwgdGhpcyB0b2dnbGVzIHRoZSBtb2RlLiBXaXRoIGEgYm9vbGVhbiwgaXRcbiAgICBlbmFibGVzICh0cnVlKSBvciBkaXNhYmxlcyBpdCAoZmFsc2UpLiBHaXZlbiBhIG51bWJlciwgaXRcbiAgICB0ZW1wb3JhcmlseSBlbmFibGVzIHRoZSBtb2RlIHVudGlsIHRoYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgIGhhdmUgcGFzc2VkIG9yIGFub3RoZXIgbm9uLVRhYiBrZXkgaXMgcHJlc3NlZC5cbiAgICAqL1xuICAgIHNldFRhYkZvY3VzTW9kZSh0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlIDwgMCA/IDAgOiAtMTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRvID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IHRvID8gMCA6IC0xO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlICE9IDApXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gRGF0ZS5ub3coKSArIHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXG4gICAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICAgIGV4dGVuc2lvbiBwcmVjZWRlbmNlLCBhbmQgdGhlIGZpcnN0IGhhbmRsZXIgdG8gcmV0dXJuIHRydWUgd2lsbFxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxuICAgIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgICBvbiB0aGUgW2NvbnRlbnQgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29udGVudERPTSksIGV4Y2VwdFxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXG4gICAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZXMgaXMgc2Nyb2xsZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudEhhbmRsZXJzOiBoYW5kbGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBET00gZXZlbnQgb2JzZXJ2ZXJzLiBDb250cmFyeVxuICAgIHRvIGV2ZW50IFtoYW5kbGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZG9tRXZlbnRIYW5kbGVycyksXG4gICAgb2JzZXJ2ZXJzIGNhbid0IGJlIHByZXZlbnRlZCBmcm9tIHJ1bm5pbmcgYnkgYSBoaWdoZXItcHJlY2VkZW5jZVxuICAgIGhhbmRsZXIgcmV0dXJuaW5nIHRydWUuIFRoZXkgYWxzbyBkb24ndCBwcmV2ZW50IG90aGVyIGhhbmRsZXJzXG4gICAgYW5kIG9ic2VydmVycyBmcm9tIHJ1bm5pbmcgd2hlbiB0aGV5IHJldHVybiB0cnVlLCBhbmQgc2hvdWxkIG5vdFxuICAgIGNhbGwgYHByZXZlbnREZWZhdWx0YC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudE9ic2VydmVycyhvYnNlcnZlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRPYnNlcnZlcnM6IG9ic2VydmVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGhlbWUgZXh0ZW5zaW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgY2FuIGJlIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxuICAgIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICAgIHByZWZpeGVkIHdpdGggYSBnZW5lcmF0ZWQgY2xhc3MgZm9yIHRoZSBzdHlsZS5cbiAgICBcbiAgICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgICB0aGF0IGRpcmVjdGx5IG1hdGNoIHRoZSBlZGl0b3IncyBbd3JhcHBlclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSnigJR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxuICAgIGFkZGVk4oCUbmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgICB0aGUgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudOKAlGZvciBleGFtcGxlXG4gICAgYCYuY20tZm9jdXNlZGAuXG4gICAgXG4gICAgV2hlbiBgZGFya2AgaXMgc2V0IHRvIHRydWUsIHRoZSB0aGVtZSB3aWxsIGJlIG1hcmtlZCBhcyBkYXJrLFxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxuICAgIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gICAgYCZsaWdodGAgd2hlbiBhIGxpZ2h0IHRoZW1lIGlzIGFjdGl2ZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgdGhlbWUoc3BlYywgb3B0aW9ucykge1xuICAgICAgICBsZXQgcHJlZml4ID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhcmspXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXJrVGhlbWUub2YodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcbiAgICB3aXRoIFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSksIHVzZSBgJmAgdG8gaW5kaWNhdGUgdGhlXG4gICAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XG4gICAgdGFyZ2V0IGVkaXRvcnMgd2l0aCBhIGRhcmsgb3IgbGlnaHQgdGhlbWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFByZWMubG93ZXN0KHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhbiBlZGl0b3IgdmlldyBpbnN0YW5jZSBmcm9tIHRoZSB2aWV3J3MgRE9NXG4gICAgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb21ET00oZG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xuICAgICAgICBsZXQgdGlsZSA9IGNvbnRlbnQgJiYgVGlsZS5nZXQoY29udGVudCkgfHwgVGlsZS5nZXQoZG9tKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aWxlID09PSBudWxsIHx8IHRpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbGUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXcpIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5GYWNldCB0byBhZGQgYSBbc3R5bGVcbm1vZHVsZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pIHRvXG5hbiBlZGl0b3Igdmlldy4gVGhlIHZpZXcgd2lsbCBlbnN1cmUgdGhhdCB0aGUgbW9kdWxlIGlzXG5tb3VudGVkIGluIGl0cyBbZG9jdW1lbnRcbnJvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnN0cnVjdG9yXmNvbmZpZy5yb290KS5cbiovXG5FZGl0b3JWaWV3LnN0eWxlTW9kdWxlID0gc3R5bGVNb2R1bGU7XG4vKipcbkFuIGlucHV0IGhhbmRsZXIgY2FuIG92ZXJyaWRlIHRoZSB3YXkgY2hhbmdlcyB0byB0aGUgZWRpdGFibGVcbkRPTSBjb250ZW50IGFyZSBoYW5kbGVkLiBIYW5kbGVycyBhcmUgcGFzc2VkIHRoZSBkb2N1bWVudFxucG9zaXRpb25zIGJldHdlZW4gd2hpY2ggdGhlIGNoYW5nZSB3YXMgZm91bmQsIGFuZCB0aGUgbmV3XG5jb250ZW50LiBXaGVuIG9uZSByZXR1cm5zIHRydWUsIG5vIGZ1cnRoZXIgaW5wdXQgaGFuZGxlcnMgYXJlXG5jYWxsZWQgYW5kIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXZlbnRlZC5cblxuVGhlIGBpbnNlcnRgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgZGVmYXVsdCB0cmFuc2FjdGlvblxudGhhdCB3b3VsZCBiZSBhcHBsaWVkIGZvciB0aGlzIGlucHV0LiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlblxuZGlzcGF0Y2hpbmcgdGhlIGN1c3RvbSBiZWhhdmlvciBhcyBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uLlxuKi9cbkVkaXRvclZpZXcuaW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xuLyoqXG5GdW5jdGlvbnMgcHJvdmlkZWQgaW4gdGhpcyBmYWNldCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHRleHRcbnBhc3RlZCBvciBkcm9wcGVkIGludG8gdGhlIGVkaXRvci5cbiovXG5FZGl0b3JWaWV3LmNsaXBib2FyZElucHV0RmlsdGVyID0gY2xpcGJvYXJkSW5wdXRGaWx0ZXI7XG4vKipcblRyYW5zZm9ybSB0ZXh0IGNvcGllZCBvciBkcmFnZ2VkIGZyb20gdGhlIGVkaXRvci5cbiovXG5FZGl0b3JWaWV3LmNsaXBib2FyZE91dHB1dEZpbHRlciA9IGNsaXBib2FyZE91dHB1dEZpbHRlcjtcbi8qKlxuU2Nyb2xsIGhhbmRsZXJzIGNhbiBvdmVycmlkZSBob3cgdGhpbmdzIGFyZSBzY3JvbGxlZCBpbnRvIHZpZXcuXG5JZiB0aGV5IHJldHVybiBgdHJ1ZWAsIG5vIGZ1cnRoZXIgaGFuZGxpbmcgaGFwcGVucyBmb3IgdGhlXG5zY3JvbGxpbmcuIElmIHRoZXkgcmV0dXJuIGZhbHNlLCB0aGUgZGVmYXVsdCBzY3JvbGwgYmVoYXZpb3IgaXNcbmFwcGxpZWQuIFNjcm9sbCBoYW5kbGVycyBzaG91bGQgbmV2ZXIgaW5pdGlhdGUgZWRpdG9yIHVwZGF0ZXMuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxIYW5kbGVyID0gc2Nyb2xsSGFuZGxlcjtcbi8qKlxuVGhpcyBmYWNldCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGZ1bmN0aW9ucyB0aGF0IGNyZWF0ZSBlZmZlY3RzXG50byBiZSBkaXNwYXRjaGVkIHdoZW4gdGhlIGVkaXRvcidzIGZvY3VzIHN0YXRlIGNoYW5nZXMuXG4qL1xuRWRpdG9yVmlldy5mb2N1c0NoYW5nZUVmZmVjdCA9IGZvY3VzQ2hhbmdlRWZmZWN0O1xuLyoqXG5CeSBkZWZhdWx0LCB0aGUgZWRpdG9yIGFzc3VtZXMgYWxsIGl0cyBjb250ZW50IGhhcyB0aGUgc2FtZVxuW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0aW9uKS4gQ29uZmlndXJlIHRoaXMgd2l0aCBhIGB0cnVlYFxudmFsdWUgdG8gbWFrZSBpdCByZWFkIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiBldmVyeSAocmVuZGVyZWQpXG5saW5lIHNlcGFyYXRlbHkuXG4qL1xuRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbiA9IHBlckxpbmVUZXh0RGlyZWN0aW9uO1xuLyoqXG5BbGxvd3MgeW91IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGVcbmxpYnJhcnkgY2F0Y2hlcyBhbiBleGNlcHRpb24gZnJvbSBhbiBleHRlbnNpb24gKG1vc3RseSBmcm9tIHZpZXdcbnBsdWdpbnMsIGJ1dCBtYXkgYmUgdXNlZCBieSBvdGhlciBleHRlbnNpb25zIHRvIHJvdXRlIGV4Y2VwdGlvbnNcbmZyb20gdXNlci1jb2RlLXByb3ZpZGVkIGNhbGxiYWNrcykuIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3JcbmRlYnVnZ2luZyBhbmQgbG9nZ2luZy4gU2VlIFtgbG9nRXhjZXB0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmxvZ0V4Y2VwdGlvbikuXG4qL1xuRWRpdG9yVmlldy5leGNlcHRpb25TaW5rID0gZXhjZXB0aW9uU2luaztcbi8qKlxuQSBmYWNldCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5ldmVyeSB0aW1lIHRoZSB2aWV3IHVwZGF0ZXMuXG4qL1xuRWRpdG9yVmlldy51cGRhdGVMaXN0ZW5lciA9IHVwZGF0ZUxpc3RlbmVyO1xuLyoqXG5GYWNldCB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvciBjb250ZW50IERPTSBpcyBlZGl0YWJsZS5cbldoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpcyBgZmFsc2VgLCB0aGUgZWxlbWVudCB3aWxsXG5ub3QgaGF2ZSBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldC4gKE5vdGUgdGhhdCB0aGlzXG5kb2Vzbid0IGFmZmVjdCBBUEkgY2FsbHMgdGhhdCBjaGFuZ2UgdGhlIGVkaXRvciBjb250ZW50LCBldmVuXG53aGVuIHRob3NlIGFyZSBib3VuZCB0byBrZXlzIG9yIGJ1dHRvbnMuIFNlZSB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBmYWNldCBmb3IgdGhhdC4pXG4qL1xuRWRpdG9yVmlldy5lZGl0YWJsZSA9IGVkaXRhYmxlO1xuLyoqXG5BbGxvd3MgeW91IHRvIGluZmx1ZW5jZSB0aGUgd2F5IG1vdXNlIHNlbGVjdGlvbiBoYXBwZW5zLiBUaGVcbmZ1bmN0aW9ucyBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgY2FsbGVkIGZvciBhIGBtb3VzZWRvd25gIGV2ZW50XG5vbiB0aGUgZWRpdG9yLCBhbmQgY2FuIHJldHVybiBhbiBvYmplY3QgdGhhdCBvdmVycmlkZXMgdGhlIHdheSBhXG5zZWxlY3Rpb24gaXMgY29tcHV0ZWQgZnJvbSB0aGF0IG1vdXNlIGNsaWNrIG9yIGRyYWcuXG4qL1xuRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlID0gbW91c2VTZWxlY3Rpb25TdHlsZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGlvbiBkcmFnIGV2ZW50XG5zaG91bGQgbW92ZSBvciBjb3B5IHRoZSBzZWxlY3Rpb24uIFRoZSBnaXZlbiBwcmVkaWNhdGUgd2lsbCBiZVxuY2FsbGVkIHdpdGggdGhlIGBtb3VzZWRvd25gIGV2ZW50LCBhbmQgY2FuIHJldHVybiBgdHJ1ZWAgd2hlblxudGhlIGRyYWcgc2hvdWxkIG1vdmUgdGhlIGNvbnRlbnQuXG4qL1xuRWRpdG9yVmlldy5kcmFnTW92ZXNTZWxlY3Rpb24gPSBkcmFnTW92ZXNTZWxlY3Rpb24kMTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGluZyBjbGljayBhZGRzIGFcbm5ldyByYW5nZSB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uIG9yIHJlcGxhY2VzIGl0IGVudGlyZWx5LiBUaGVcbmRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY2hlY2sgYGV2ZW50Lm1ldGFLZXlgIG9uIG1hY09TLCBhbmRcbmBldmVudC5jdHJsS2V5YCBlbHNld2hlcmUuXG4qL1xuRWRpdG9yVmlldy5jbGlja0FkZHNTZWxlY3Rpb25SYW5nZSA9IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlO1xuLyoqXG5BIGZhY2V0IHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKVxuYXJlIHNob3duIGluIHRoZSB2aWV3LiBEZWNvcmF0aW9ucyBjYW4gYmUgcHJvdmlkZWQgaW4gdHdvXG53YXlz4oCUZGlyZWN0bHksIG9yIHZpYSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gZWRpdG9yIHZpZXcuXG5cbk9ubHkgZGVjb3JhdGlvbiBzZXRzIHByb3ZpZGVkIGRpcmVjdGx5IGFyZSBhbGxvd2VkIHRvIGluZmx1ZW5jZVxudGhlIGVkaXRvcidzIHZlcnRpY2FsIGxheW91dCBzdHJ1Y3R1cmUuIFRoZSBvbmVzIHByb3ZpZGVkIGFzXG5mdW5jdGlvbnMgYXJlIGNhbGxlZCBfYWZ0ZXJfIHRoZSBuZXcgdmlld3BvcnQgaGFzIGJlZW4gY29tcHV0ZWQsXG5hbmQgdGh1cyAqKm11c3Qgbm90KiogaW50cm9kdWNlIGJsb2NrIHdpZGdldHMgb3IgcmVwbGFjaW5nXG5kZWNvcmF0aW9ucyB0aGF0IGNvdmVyIGxpbmUgYnJlYWtzLlxuXG5JZiB5b3Ugd2FudCBkZWNvcmF0ZWQgcmFuZ2VzIHRvIGJlaGF2ZSBsaWtlIGF0b21pYyB1bml0cyBmb3JcbmN1cnNvciBtb3Rpb24gYW5kIGRlbGV0aW9uIHB1cnBvc2VzLCBhbHNvIHByb3ZpZGUgdGhlIHJhbmdlIHNldFxuY29udGFpbmluZyB0aGUgZGVjb3JhdGlvbnMgdG9cbltgRWRpdG9yVmlldy5hdG9taWNSYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15hdG9taWNSYW5nZXMpLlxuKi9cbkVkaXRvclZpZXcuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbi8qKlxuW0Jsb2NrIHdyYXBwZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuQmxvY2tXcmFwcGVyKSBwcm92aWRlIGEgd2F5IHRvIGFkZCBET01cbnN0cnVjdHVyZSBhcm91bmQgZWRpdG9yIGxpbmVzIGFuZCBibG9jayB3aWRnZXRzLiBTZXRzIG9mXG53cmFwcGVycyBhcmUgcHJvdmlkZWQgaW4gYSBzaW1pbGFyIHdheSB0byBkZWNvcmF0aW9ucywgYW5kIGFyZVxubmVzdGVkIGluIGEgc2ltaWxhciB3YXkgd2hlbiB0aGV5IG92ZXJsYXAuIEEgd3JhcHBlciBhZmZlY3RzIGFsbFxubGluZXMgYW5kIGJsb2NrIHdpZGdldHMgdGhhdCBzdGFydCBpbnNpZGUgaXRzIHJhbmdlLlxuKi9cbkVkaXRvclZpZXcuYmxvY2tXcmFwcGVycyA9IGJsb2NrV3JhcHBlcnM7XG4vKipcbkZhY2V0IHRoYXQgd29ya3MgbXVjaCBsaWtlXG5bYGRlY29yYXRpb25zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZGVjb3JhdGlvbnMpLCBidXQgcHV0cyBpdHNcbmlucHV0cyBhdCB0aGUgdmVyeSBib3R0b20gb2YgdGhlIHByZWNlZGVuY2Ugc3RhY2ssIG1lYW5pbmcgbWFya1xuZGVjb3JhdGlvbnMgcHJvdmlkZWQgaGVyZSB3aWxsIG9ubHkgYmUgc3BsaXQgYnkgb3RoZXIsIHBhcnRpYWxseVxub3ZlcmxhcHBpbmcgYG91dGVyRGVjb3JhdGlvbnNgIHJhbmdlcywgYW5kIHdyYXAgYXJvdW5kIGFsbFxucmVndWxhciBkZWNvcmF0aW9ucy4gVXNlIHRoaXMgZm9yIG1hcmsgZWxlbWVudHMgdGhhdCBzaG91bGQsIGFzXG5tdWNoIGFzIHBvc3NpYmxlLCByZW1haW4gaW4gb25lIHBpZWNlLlxuKi9cbkVkaXRvclZpZXcub3V0ZXJEZWNvcmF0aW9ucyA9IG91dGVyRGVjb3JhdGlvbnM7XG4vKipcblVzZWQgdG8gcHJvdmlkZSByYW5nZXMgdGhhdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhdG9tcyBhcyBmYXIgYXNcbmN1cnNvciBtb3Rpb24gaXMgY29uY2VybmVkLiBUaGlzIGNhdXNlcyBtZXRob2RzIGxpa2VcbltgbW92ZUJ5Q2hhcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUNoYXIpIGFuZFxuW2Btb3ZlVmVydGljYWxseWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVWZXJ0aWNhbGx5KSAoYW5kIHRoZVxuY29tbWFuZHMgYnVpbHQgb24gdG9wIG9mIHRoZW0pIHRvIHNraXAgYWNyb3NzIHN1Y2ggcmVnaW9ucyB3aGVuXG5hIHNlbGVjdGlvbiBlbmRwb2ludCB3b3VsZCBlbnRlciB0aGVtLiBUaGlzIGRvZXMgX25vdF8gcHJldmVudFxuZGlyZWN0IHByb2dyYW1tYXRpYyBbc2VsZWN0aW9uXG51cGRhdGVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGZyb20gbW92aW5nIGludG8gc3VjaFxucmVnaW9ucy5cbiovXG5FZGl0b3JWaWV3LmF0b21pY1JhbmdlcyA9IGF0b21pY1Jhbmdlcztcbi8qKlxuV2hlbiByYW5nZSBkZWNvcmF0aW9ucyBhZGQgYSBgdW5pY29kZS1iaWRpOiBpc29sYXRlYCBzdHlsZSwgdGhleVxuc2hvdWxkIGFsc28gaW5jbHVkZSBhXG5bYGJpZGlJc29sYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lk1hcmtEZWNvcmF0aW9uU3BlYy5iaWRpSXNvbGF0ZSkgcHJvcGVydHlcbmluIHRoZWlyIGRlY29yYXRpb24gc3BlYywgYW5kIGJlIGV4cG9zZWQgdGhyb3VnaCB0aGlzIGZhY2V0LCBzb1xudGhhdCB0aGUgZWRpdG9yIGNhbiBjb21wdXRlIHRoZSBwcm9wZXIgdGV4dCBvcmRlci4gKE90aGVyIHZhbHVlc1xuZm9yIGB1bmljb2RlLWJpZGlgLCBleGNlcHQgb2YgY291cnNlIGBub3JtYWxgLCBhcmUgbm90XG5zdXBwb3J0ZWQuKVxuKi9cbkVkaXRvclZpZXcuYmlkaUlzb2xhdGVkUmFuZ2VzID0gYmlkaUlzb2xhdGVkUmFuZ2VzO1xuLyoqXG5GYWNldCB0aGF0IGFsbG93cyBleHRlbnNpb25zIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBzY3JvbGxcbm1hcmdpbnMgKHNwYWNlIGFyb3VuZCB0aGUgc2lkZXMgb2YgdGhlIHNjcm9sbGluZyBlbGVtZW50IHRoYXRcbnNob3VsZCBiZSBjb25zaWRlcmVkIGludmlzaWJsZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZVxucGx1Z2luIGludHJvZHVjZXMgZWxlbWVudHMgdGhhdCBjb3ZlciBwYXJ0IG9mIHRoYXQgZWxlbWVudCAoZm9yXG5leGFtcGxlIGEgaG9yaXpvbnRhbGx5IGZpeGVkIGd1dHRlcikuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zID0gc2Nyb2xsTWFyZ2lucztcbi8qKlxuVGhpcyBmYWNldCByZWNvcmRzIHdoZXRoZXIgYSBkYXJrIHRoZW1lIGlzIGFjdGl2ZS4gVGhlIGV4dGVuc2lvblxucmV0dXJuZWQgYnkgW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSBhdXRvbWF0aWNhbGx5XG5pbmNsdWRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIHdoZW4gdGhlIGBkYXJrYCBvcHRpb24gaXMgc2V0IHRvXG50cnVlLlxuKi9cbkVkaXRvclZpZXcuZGFya1RoZW1lID0gZGFya1RoZW1lO1xuLyoqXG5Qcm92aWRlcyBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IG5vbmNlIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG50aGUgc3R5bGUgc2hlZXRzIGZvciB0aGUgZWRpdG9yLiBIb2xkcyB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gbm9cbm5vbmNlIGhhcyBiZWVuIHByb3ZpZGVkLlxuKi9cbkVkaXRvclZpZXcuY3NwTm9uY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBcIlwiIH0pO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIGFkZGl0aW9uYWwgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3Inc1xuZWRpdGFibGUgRE9NIGVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcyA9IGNvbnRlbnRBdHRyaWJ1dGVzO1xuLyoqXG5GYWNldCB0aGF0IHByb3ZpZGVzIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3Mgb3V0ZXJcbmVsZW1lbnQuXG4qL1xuRWRpdG9yVmlldy5lZGl0b3JBdHRyaWJ1dGVzID0gZWRpdG9yQXR0cmlidXRlcztcbi8qKlxuQW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBsaW5lIHdyYXBwaW5nIGluIHRoZSBlZGl0b3IgKGJ5XG5zZXR0aW5nIENTUyBgd2hpdGUtc3BhY2VgIHRvIGBwcmUtd3JhcGAgaW4gdGhlIGNvbnRlbnQpLlxuKi9cbkVkaXRvclZpZXcubGluZVdyYXBwaW5nID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YoeyBcImNsYXNzXCI6IFwiY20tbGluZVdyYXBwaW5nXCIgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB1c2VkIHRvIGluY2x1ZGUgc2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnRzIGluIGFcbnRyYW5zYWN0aW9uLiBUaGVzZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBET00gaW4gYSB2aXN1YWxseSBoaWRkZW5cbmVsZW1lbnQgd2l0aCBgYXJpYS1saXZlPVwicG9saXRlXCJgIHNldCwgYW5kIHNob3VsZCBiZSB1c2VkIHRvXG5kZXNjcmliZSBlZmZlY3RzIHRoYXQgYXJlIHZpc3VhbGx5IG9idmlvdXMgYnV0IG1heSBub3QgYmVcbm5vdGljZWQgYnkgc2NyZWVuIHJlYWRlciB1c2VycyAoc3VjaCBhcyBtb3ZpbmcgdG8gdGhlIG5leHRcbnNlYXJjaCBtYXRjaCkuXG4qL1xuRWRpdG9yVmlldy5hbm5vdW5jZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8vIE1heGltdW0gbGluZSBsZW5ndGggZm9yIHdoaWNoIHdlIGNvbXB1dGUgYWNjdXJhdGUgYmlkaSBpbmZvXG5jb25zdCBNYXhCaWRpTGluZSA9IDQwOTY7XG5jb25zdCBCYWRNZWFzdXJlID0ge307XG5jbGFzcyBDYWNoZWRPcmRlciB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpciwgaXNvbGF0ZXMsIGZyZXNoLCBvcmRlcikge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmlzb2xhdGVzID0gaXNvbGF0ZXM7XG4gICAgICAgIHRoaXMuZnJlc2ggPSBmcmVzaDtcbiAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlKGNhY2hlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmVtcHR5ICYmICFjYWNoZS5zb21lKGMgPT4gYy5mcmVzaCkpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgbGFzdERpciA9IGNhY2hlLmxlbmd0aCA/IGNhY2hlW2NhY2hlLmxlbmd0aCAtIDFdLmRpciA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjYWNoZS5sZW5ndGggLSAxMCk7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoZW50cnkuZGlyID09IGxhc3REaXIgJiYgIWNoYW5nZXMudG91Y2hlc1JhbmdlKGVudHJ5LmZyb20sIGVudHJ5LnRvKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FjaGVkT3JkZXIoY2hhbmdlcy5tYXBQb3MoZW50cnkuZnJvbSwgMSksIGNoYW5nZXMubWFwUG9zKGVudHJ5LnRvLCAtMSksIGVudHJ5LmRpciwgZW50cnkuaXNvbGF0ZXMsIGZhbHNlLCBlbnRyeS5vcmRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cnNGcm9tRmFjZXQodmlldywgZmFjZXQsIGJhc2UpIHtcbiAgICBmb3IgKGxldCBzb3VyY2VzID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCksIGkgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBzb3VyY2VzW2ldLCB2YWx1ZSA9IHR5cGVvZiBzb3VyY2UgPT0gXCJmdW5jdGlvblwiID8gc291cmNlKHZpZXcpIDogc291cmNlO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBjb21iaW5lQXR0cnModmFsdWUsIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgY3VycmVudFBsYXRmb3JtID0gYnJvd3Nlci5tYWMgPyBcIm1hY1wiIDogYnJvd3Nlci53aW5kb3dzID8gXCJ3aW5cIiA6IGJyb3dzZXIubGludXggPyBcImxpbnV4XCIgOiBcImtleVwiO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lLCBwbGF0Zm9ybSkge1xuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybSA9PSBcIm1hY1wiKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICE9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuY29uc3QgaGFuZGxlS2V5RXZlbnRzID0gLypAX19QVVJFX18qL1ByZWMuZGVmYXVsdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBrZXlkb3duKGV2ZW50LCB2aWV3KSB7XG4gICAgICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBcImVkaXRvclwiKTtcbiAgICB9XG59KSk7XG4vKipcbkZhY2V0IHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGtleW1hcHMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcHMgdG8gYW4gZWRpdG9yLiBUaGVpciBwcmlvcml0aWVzXG5kZXRlcm1pbmUgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgc3BlY2lmaWVkIGVhcmx5IG9yIHdpdGggaGlnaFxucHJpb3JpdHkgZ2V0IGNoZWNrZWQgZmlyc3QpLiBXaGVuIGEgaGFuZGxlciBoYXMgcmV0dXJuZWQgYHRydWVgXG5mb3IgYSBnaXZlbiBrZXksIG5vIGZ1cnRoZXIgaGFuZGxlcnMgYXJlIGNhbGxlZC5cbiovXG5jb25zdCBrZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgZW5hYmxlczogaGFuZGxlS2V5RXZlbnRzIH0pO1xuY29uc3QgS2V5bWFwcyA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gVGhpcyBpcyBoaWRkZW4gYmVoaW5kIGFuIGluZGlyZWN0aW9uLCByYXRoZXIgdGhhbiBkaXJlY3RseSBjb21wdXRlZFxuLy8gYnkgdGhlIGZhY2V0LCB0byBrZWVwIGludGVybmFsIHR5cGVzIG91dCBvZiB0aGUgZmFjZXQncyB0eXBlLlxuZnVuY3Rpb24gZ2V0S2V5bWFwKHN0YXRlKSB7XG4gICAgbGV0IGJpbmRpbmdzID0gc3RhdGUuZmFjZXQoa2V5bWFwKTtcbiAgICBsZXQgbWFwID0gS2V5bWFwcy5nZXQoYmluZGluZ3MpO1xuICAgIGlmICghbWFwKVxuICAgICAgICBLZXltYXBzLnNldChiaW5kaW5ncywgbWFwID0gYnVpbGRLZXltYXAoYmluZGluZ3MucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pKSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuUnVuIHRoZSBrZXkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBzY29wZS4gVGhlIGV2ZW50XG5vYmplY3Qgc2hvdWxkIGJlIGEgYFwia2V5ZG93blwiYCBldmVudC4gUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGVcbmhhbmRsZXJzIGhhbmRsZWQgaXQuXG4qL1xuZnVuY3Rpb24gcnVuU2NvcGVIYW5kbGVycyh2aWV3LCBldmVudCwgc2NvcGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgc2NvcGUpO1xufVxubGV0IHN0b3JlZFByZWZpeCA9IG51bGw7XG5jb25zdCBQcmVmaXhUaW1lb3V0ID0gNDAwMDtcbmZ1bmN0aW9uIGJ1aWxkS2V5bWFwKGJpbmRpbmdzLCBwbGF0Zm9ybSA9IGN1cnJlbnRQbGF0Zm9ybSkge1xuICAgIGxldCBib3VuZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGlzUHJlZml4ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY2hlY2tQcmVmaXggPSAobmFtZSwgaXMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBpc1ByZWZpeFtuYW1lXTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGlzUHJlZml4W25hbWVdID0gaXM7XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgIT0gaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgYmluZGluZyBcIiArIG5hbWUgKyBcIiBpcyB1c2VkIGJvdGggYXMgYSByZWd1bGFyIGJpbmRpbmcgYW5kIGFzIGEgbXVsdGktc3Ryb2tlIHByZWZpeFwiKTtcbiAgICB9O1xuICAgIGxldCBhZGQgPSAoc2NvcGUsIGtleSwgY29tbWFuZCwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICBsZXQgcGFydHMgPSBrZXkuc3BsaXQoLyAoPyEkKS8pLm1hcChrID0+IG5vcm1hbGl6ZUtleU5hbWUoaywgcGxhdGZvcm0pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IHBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgY2hlY2tQcmVmaXgocHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc2NvcGVPYmpbcHJlZml4XSlcbiAgICAgICAgICAgICAgICBzY29wZU9ialtwcmVmaXhdID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuOiBbKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3VyT2JqID0gc3RvcmVkUHJlZml4ID0geyB2aWV3LCBwcmVmaXgsIHNjb3BlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGlmIChzdG9yZWRQcmVmaXggPT0gb3VyT2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsOyB9LCBQcmVmaXhUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVsbCA9IHBhcnRzLmpvaW4oXCIgXCIpO1xuICAgICAgICBjaGVja1ByZWZpeChmdWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBiaW5kaW5nID0gc2NvcGVPYmpbZnVsbF0gfHwgKHNjb3BlT2JqW2Z1bGxdID0ge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIHJ1bjogKChfYiA9IChfYSA9IHNjb3BlT2JqLl9hbnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zbGljZSgpKSB8fCBbXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbW1hbmQpXG4gICAgICAgICAgICBiaW5kaW5nLnJ1bi5wdXNoKGNvbW1hbmQpO1xuICAgICAgICBpZiAocHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBiaW5kaW5nLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIGJpbmRpbmcuc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICB9O1xuICAgIGZvciAobGV0IGIgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgbGV0IHNjb3BlcyA9IGIuc2NvcGUgPyBiLnNjb3BlLnNwbGl0KFwiIFwiKSA6IFtcImVkaXRvclwiXTtcbiAgICAgICAgaWYgKGIuYW55KVxuICAgICAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlT2JqLl9hbnkpXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqLl9hbnkgPSB7IHByZXZlbnREZWZhdWx0OiBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uOiBmYWxzZSwgcnVuOiBbXSB9O1xuICAgICAgICAgICAgICAgIGxldCB7IGFueSB9ID0gYjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc2NvcGVPYmopXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlT2JqW2tleV0ucnVuLnB1c2godmlldyA9PiBhbnkodmlldywgY3VycmVudEtleUV2ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lID0gYltwbGF0Zm9ybV0gfHwgYi5rZXk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgIGFkZChzY29wZSwgbmFtZSwgYi5ydW4sIGIucHJldmVudERlZmF1bHQsIGIuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChiLnNoaWZ0KVxuICAgICAgICAgICAgICAgIGFkZChzY29wZSwgXCJTaGlmdC1cIiArIG5hbWUsIGIuc2hpZnQsIGIucHJldmVudERlZmF1bHQsIGIuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmQ7XG59XG5sZXQgY3VycmVudEtleUV2ZW50ID0gbnVsbDtcbmZ1bmN0aW9uIHJ1bkhhbmRsZXJzKG1hcCwgZXZlbnQsIHZpZXcsIHNjb3BlKSB7XG4gICAgY3VycmVudEtleUV2ZW50ID0gZXZlbnQ7XG4gICAgbGV0IG5hbWUgPSBrZXlOYW1lKGV2ZW50KTtcbiAgICBsZXQgY2hhckNvZGUgPSBjb2RlUG9pbnRBdChuYW1lLCAwKSwgaXNDaGFyID0gY29kZVBvaW50U2l6ZShjaGFyQ29kZSkgPT0gbmFtZS5sZW5ndGggJiYgbmFtZSAhPSBcIiBcIjtcbiAgICBsZXQgcHJlZml4ID0gXCJcIiwgaGFuZGxlZCA9IGZhbHNlLCBwcmV2ZW50ZWQgPSBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKSB7XG4gICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuID0gbmV3IFNldDtcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLnJ1bilcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xuICAgICAgICAgICAgICAgICAgICByYW4uYWRkKGNtZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQodmlldykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nLnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmluZGluZy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nLnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGxldCBzY29wZU9iaiA9IG1hcFtzY29wZV0sIGJhc2VOYW1lLCBzaGlmdE5hbWU7XG4gICAgaWYgKHNjb3BlT2JqKSB7XG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCAhaXNDaGFyKV0pKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICYmXG4gICAgICAgICAgICAvLyBDdHJsLUFsdCBtYXkgYmUgdXNlZCBmb3IgQWx0R3Igb24gV2luZG93c1xuICAgICAgICAgICAgIShicm93c2VyLndpbmRvd3MgJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC5hbHRLZXkpICYmXG4gICAgICAgICAgICAvLyBBbHQtY29tYmluYXRpb25zIG9uIG1hY09TIHRlbmQgdG8gYmUgdHlwZWQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgIShicm93c2VyLm1hYyAmJiBldmVudC5hbHRLZXkgJiYgIShldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpKSAmJlxuICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50LCB0cnVlKV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoc2hpZnROYW1lID0gc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSAmJlxuICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkICYmIHJ1bkZvcihzY29wZU9iai5fYW55KSlcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJldmVudGVkKVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoaGFuZGxlZCAmJiBzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGN1cnJlbnRLZXlFdmVudCA9IG51bGw7XG4gICAgcmV0dXJuIGhhbmRsZWQ7XG59XG5cbi8qKlxuSW1wbGVtZW50YXRpb24gb2YgW2BMYXllck1hcmtlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5MYXllck1hcmtlcikgdGhhdCBjcmVhdGVzXG5hIHJlY3RhbmdsZSBhdCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcy5cbiovXG5jbGFzcyBSZWN0YW5nbGVNYXJrZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmtlciB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhbmQgZGltZW5zaW9ucy4gSWYgYHdpZHRoYFxuICAgIGlzIG51bGwsIHRoZSBET00gZWxlbWVudCB3aWxsIGdldCBubyB3aWR0aCBzdHlsZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSwgXG4gICAgLyoqXG4gICAgVGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIG1hcmtlciAoaW4gcGl4ZWxzLCBkb2N1bWVudC1yZWxhdGl2ZSkuXG4gICAgKi9cbiAgICBsZWZ0LCBcbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIFRoZSB3aWR0aCBvZiB0aGUgbWFya2VyLCBvciBudWxsIGlmIGl0IHNob3VsZG4ndCBnZXQgYSB3aWR0aCBhc3NpZ25lZC5cbiAgICAqL1xuICAgIHdpZHRoLCBcbiAgICAvKipcbiAgICBUaGUgaGVpZ2h0IG9mIHRoZSBtYXJrZXIuXG4gICAgKi9cbiAgICBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICB1cGRhdGUoZWx0LCBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2LmNsYXNzTmFtZSAhPSB0aGlzLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFkanVzdChlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS50b3AgPSB0aGlzLnRvcCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gICAgZXEocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID09IHAubGVmdCAmJiB0aGlzLnRvcCA9PSBwLnRvcCAmJiB0aGlzLndpZHRoID09IHAud2lkdGggJiYgdGhpcy5oZWlnaHQgPT0gcC5oZWlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgcmVjdGFuZ2xlcyBmb3IgdGhlIGdpdmVuIHNlbGVjdGlvbiByYW5nZSxcbiAgICBhc3NpZ25pbmcgdGhlbSB0aGVjbGFzc2BjbGFzc05hbWVgLiBXaWxsIGNyZWF0ZSBhIHNpbmdsZVxuICAgIHJlY3RhbmdsZSBmb3IgZW1wdHkgcmFuZ2VzLCBhbmQgYSBzZXQgb2Ygc2VsZWN0aW9uLXN0eWxlXG4gICAgcmVjdGFuZ2xlcyBjb3ZlcmluZyB0aGUgcmFuZ2UncyBjb250ZW50IChpbiBhIGJpZGktYXdhcmVcbiAgICB3YXkpIGZvciBub24tZW1wdHkgb25lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHZpZXcuY29vcmRzQXRQb3MocmFuZ2UuaGVhZCwgcmFuZ2UuYXNzb2MgfHwgMSk7XG4gICAgICAgICAgICBpZiAoIXBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBwb3MubGVmdCAtIGJhc2UubGVmdCwgcG9zLnRvcCAtIGJhc2UudG9wLCBudWxsLCBwb3MuYm90dG9tIC0gcG9zLnRvcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJhc2Uodmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCAqIHZpZXcuc2NhbGVYO1xuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ICogdmlldy5zY2FsZVgsIHRvcDogcmVjdC50b3AgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB2aWV3LnNjYWxlWSB9O1xufVxuZnVuY3Rpb24gd3JhcHBlZExpbmUodmlldywgcG9zLCBzaWRlLCBpbnNpZGUpIHtcbiAgICBsZXQgY29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MsIHNpZGUgKiAyKTtcbiAgICBpZiAoIWNvb3JkcylcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB5ID0gKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDI7XG4gICAgbGV0IGxlZnQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZWRpdG9yUmVjdC5sZWZ0ICsgMSwgeSB9KTtcbiAgICBsZXQgcmlnaHQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZWRpdG9yUmVjdC5yaWdodCAtIDEsIHkgfSk7XG4gICAgaWYgKGxlZnQgPT0gbnVsbCB8fCByaWdodCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCBNYXRoLm1pbihsZWZ0LCByaWdodCkpLCB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCBNYXRoLm1heChsZWZ0LCByaWdodCkpIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00sIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgbGV0IGxpbmVFbHQgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY20tbGluZVwiKSwgbGluZVN0eWxlID0gbGluZUVsdCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsaW5lRWx0KTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICtcbiAgICAgICAgKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpIDogMCk7XG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nUmlnaHQpIDogMCk7XG4gICAgbGV0IHN0YXJ0QmxvY2sgPSBibG9ja0F0KHZpZXcsIGZyb20sIDEpLCBlbmRCbG9jayA9IGJsb2NrQXQodmlldywgdG8sIC0xKTtcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSBzdGFydEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBzdGFydEJsb2NrIDogbnVsbDtcbiAgICBsZXQgdmlzdWFsRW5kID0gZW5kQmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGVuZEJsb2NrIDogbnVsbDtcbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgKHZpZXcubGluZVdyYXBwaW5nIHx8IHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbFN0YXJ0ID0gd3JhcHBlZExpbmUodmlldywgZnJvbSwgMSwgdmlzdWFsU3RhcnQpO1xuICAgIGlmICh2aXN1YWxFbmQgJiYgKHZpZXcubGluZVdyYXBwaW5nIHx8IGVuZEJsb2NrLndpZGdldExpbmVCcmVha3MpKVxuICAgICAgICB2aXN1YWxFbmQgPSB3cmFwcGVkTGluZSh2aWV3LCB0bywgLTEsIHZpc3VhbEVuZCk7XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCAmJiB2aXN1YWxTdGFydC5mcm9tID09IHZpc3VhbEVuZC5mcm9tICYmIHZpc3VhbFN0YXJ0LnRvID09IHZpc3VhbEVuZC50bykge1xuICAgICAgICByZXR1cm4gcGllY2VzKGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIHJhbmdlLnRvLCB2aXN1YWxTdGFydCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRvcCA9IHZpc3VhbFN0YXJ0ID8gZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgbnVsbCwgdmlzdWFsU3RhcnQpIDogZHJhd0ZvcldpZGdldChzdGFydEJsb2NrLCBmYWxzZSk7XG4gICAgICAgIGxldCBib3R0b20gPSB2aXN1YWxFbmQgPyBkcmF3Rm9yTGluZShudWxsLCByYW5nZS50bywgdmlzdWFsRW5kKSA6IGRyYXdGb3JXaWRnZXQoZW5kQmxvY2ssIHRydWUpO1xuICAgICAgICBsZXQgYmV0d2VlbiA9IFtdO1xuICAgICAgICBpZiAoKHZpc3VhbFN0YXJ0IHx8IHN0YXJ0QmxvY2spLnRvIDwgKHZpc3VhbEVuZCB8fCBlbmRCbG9jaykuZnJvbSAtICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgPyAxIDogMCkgfHxcbiAgICAgICAgICAgIHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcyA+IDEgJiYgdG9wLmJvdHRvbSArIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyIDwgYm90dG9tLnRvcClcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIHZpZXcuZWxlbWVudEF0SGVpZ2h0KCh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyKS50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZXMoeyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9KSB7XG4gICAgICAgIGxldCBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3Jpem9udGFsLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcGllY2VzLnB1c2gocGllY2UoaG9yaXpvbnRhbFtpXSwgdG9wLCBob3Jpem9udGFsW2kgKyAxXSwgYm90dG9tKSk7XG4gICAgICAgIHJldHVybiBwaWVjZXM7XG4gICAgfVxuICAgIC8vIEdldHMgcGFzc2VkIGZyb20vdG8gaW4gbGluZS1sb2NhbCBwb3NpdGlvbnNcbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShmcm9tLCB0bywgbGluZSkge1xuICAgICAgICBsZXQgdG9wID0gMWU5LCBib3R0b20gPSAtMWU5LCBob3Jpem9udGFsID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZFNwYW4oZnJvbSwgZnJvbU9wZW4sIHRvLCB0b09wZW4sIGRpcikge1xuICAgICAgICAgICAgLy8gUGFzc2luZyAyLy0yIGlzIGEga2x1ZGdlIHRvIGZvcmNlIHRoZSB2aWV3IHRvIHJldHVyblxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgb24gdGhlIHByb3BlciBzaWRlIG9mIGJsb2NrIHdpZGdldHMsIHNpbmNlXG4gICAgICAgICAgICAvLyBub3JtYWxpemluZyB0aGUgc2lkZSB0aGVyZSwgdGhvdWdoIGFwcHJvcHJpYXRlIGZvciBtb3N0XG4gICAgICAgICAgICAvLyBjb29yZHNBdFBvcyBxdWVyaWVzLCB3b3VsZCBicmVhayBzZWxlY3Rpb24gZHJhd2luZy5cbiAgICAgICAgICAgIGxldCBmcm9tQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhmcm9tLCAoZnJvbSA9PSBsaW5lLnRvID8gLTIgOiAyKSk7XG4gICAgICAgICAgICBsZXQgdG9Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHRvLCAodG8gPT0gbGluZS5mcm9tID8gMiA6IC0yKSk7XG4gICAgICAgICAgICBpZiAoIWZyb21Db29yZHMgfHwgIXRvQ29vcmRzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKGZyb21Db29yZHMudG9wLCB0b0Nvb3Jkcy50b3AsIHRvcCk7XG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChmcm9tQ29vcmRzLmJvdHRvbSwgdG9Db29yZHMuYm90dG9tLCBib3R0b20pO1xuICAgICAgICAgICAgaWYgKGRpciA9PSBEaXJlY3Rpb24uTFRSKVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaChsdHIgJiYgZnJvbU9wZW4gPyBsZWZ0U2lkZSA6IGZyb21Db29yZHMubGVmdCwgbHRyICYmIHRvT3BlbiA/IHJpZ2h0U2lkZSA6IHRvQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2goIWx0ciAmJiB0b09wZW4gPyBsZWZ0U2lkZSA6IHRvQ29vcmRzLmxlZnQsICFsdHIgJiYgZnJvbU9wZW4gPyByaWdodFNpZGUgOiBmcm9tQ29vcmRzLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBsaW5lLmZyb20sIGVuZCA9IHRvICE9PSBudWxsICYmIHRvICE9PSB2b2lkIDAgPyB0byA6IGxpbmUudG87XG4gICAgICAgIC8vIFNwbGl0IHRoZSByYW5nZSBieSB2aXNpYmxlIHJhbmdlIGFuZCBkb2N1bWVudCBsaW5lXG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKVxuICAgICAgICAgICAgaWYgKHIudG8gPiBzdGFydCAmJiByLmZyb20gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChyLmZyb20sIHN0YXJ0KSwgZW5kUG9zID0gTWF0aC5taW4oci50bywgZW5kKTs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkb2NMaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNwYW4gb2Ygdmlldy5iaWRpU3BhbnMoZG9jTGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFuRnJvbSA9IHNwYW4uZnJvbSArIGRvY0xpbmUuZnJvbSwgc3BhblRvID0gc3Bhbi50byArIGRvY0xpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuRnJvbSA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhblRvID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNwYW4oTWF0aC5tYXgoc3BhbkZyb20sIHBvcyksIGZyb20gPT0gbnVsbCAmJiBzcGFuRnJvbSA8PSBzdGFydCwgTWF0aC5taW4oc3BhblRvLCBlbmRQb3MpLCB0byA9PSBudWxsICYmIHNwYW5UbyA+PSBlbmQsIHNwYW4uZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSBkb2NMaW5lLnRvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChob3Jpem9udGFsLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgYWRkU3BhbihzdGFydCwgZnJvbSA9PSBudWxsLCBlbmQsIHRvID09IG51bGwsIHZpZXcudGV4dERpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdGb3JXaWRnZXQoYmxvY2ssIHRvcCkge1xuICAgICAgICBsZXQgeSA9IGNvbnRlbnRSZWN0LnRvcCArICh0b3AgPyBibG9jay50b3AgOiBibG9jay5ib3R0b20pO1xuICAgICAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgaG9yaXpvbnRhbDogW10gfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lTWFya2VyKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jb25zdHJ1Y3RvciA9PSBiLmNvbnN0cnVjdG9yICYmIGEuZXEoYik7XG59XG5jbGFzcyBMYXllclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGxheWVyKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5kcmF3biA9IFtdO1xuICAgICAgICB0aGlzLnNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLm1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhdy5iaW5kKHRoaXMpIH07XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllclwiKTtcbiAgICAgICAgaWYgKGxheWVyLmFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxheWVyLWFib3ZlXCIpO1xuICAgICAgICBpZiAobGF5ZXIuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGxheWVyLmNsYXNzKTtcbiAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuc2V0T3JkZXIodmlldy5zdGF0ZSk7XG4gICAgICAgIHZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgaWYgKGxheWVyLm1vdW50KVxuICAgICAgICAgICAgbGF5ZXIubW91bnQodGhpcy5kb20sIHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYXllck9yZGVyKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGF5ZXJPcmRlcikpXG4gICAgICAgICAgICB0aGlzLnNldE9yZGVyKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuZG9tKSB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlKCk7XG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvY1ZpZXdVcGRhdGUodmlldykge1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGVPbkRvY1ZpZXdVcGRhdGUgIT09IGZhbHNlKVxuICAgICAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgIH1cbiAgICBzZXRPcmRlcihzdGF0ZSkge1xuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG9yZGVyLmxlbmd0aCAmJiBvcmRlcltwb3NdICE9IHRoaXMubGF5ZXIpXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xuICAgIH1cbiAgICBzY2FsZSgpIHtcbiAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgaWYgKHNjYWxlWCAhPSB0aGlzLnNjYWxlWCB8fCBzY2FsZVkgIT0gdGhpcy5zY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gc2NhbGVYfSwgJHsxIC8gc2NhbGVZfSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcobWFya2Vycykge1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggIT0gdGhpcy5kcmF3bi5sZW5ndGggfHwgbWFya2Vycy5zb21lKChwLCBpKSA9PiAhc2FtZU1hcmtlcihwLCB0aGlzLmRyYXduW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci51cGRhdGUgJiYgb2xkICYmIG1hcmtlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmRyYXduW29sZEldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9sZEkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIuZHJhdygpLCBvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBvbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgb2xkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd24gPSBtYXJrZXJzO1xuICAgICAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmIGJyb3dzZXIuc2FmYXJpX3ZlcnNpb24gPj0gMjYpIC8vIElzc3VlICMxNjAwLCAxNjI3XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZGlzcGxheSA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQgPyBcIlwiIDogXCJub25lXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMubGF5ZXIuZGVzdHJveSh0aGlzLmRvbSwgdGhpcy52aWV3KTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufVxuY29uc3QgbGF5ZXJPcmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGEgbGF5ZXIuXG4qL1xuZnVuY3Rpb24gbGF5ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodiA9PiBuZXcgTGF5ZXJWaWV3KHYsIGNvbmZpZykpLFxuICAgICAgICBsYXllck9yZGVyLm9mKGNvbmZpZylcbiAgICBdO1xufVxuXG5jb25zdCBzZWxlY3Rpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAxMjAwLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogKGEsIGIpID0+IE1hdGgubWluKGEsIGIpLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZGVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNlbGVjdGlvbiBhbmRcbmN1cnNvciwgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGJhY2tncm91bmQgYmVoaW5kIHRoZSB0ZXh0XG4od2l0aCB0aGUgYGNtLXNlbGVjdGlvbkJhY2tncm91bmRgIGNsYXNzKSwgYW5kIHRoZVxuY3Vyc29ycyB3aXRoIGVsZW1lbnRzIG92ZXJsYWlkIG92ZXIgdGhlIGNvZGUgKHVzaW5nXG5gY20tY3Vyc29yLXByaW1hcnlgIGFuZCBgY20tY3Vyc29yLXNlY29uZGFyeWApLlxuXG5UaGlzIGFsbG93cyB0aGUgZWRpdG9yIHRvIGRpc3BsYXkgc2Vjb25kYXJ5IHNlbGVjdGlvbiByYW5nZXMsIGFuZFxudGVuZHMgdG8gcHJvZHVjZSBhIHR5cGUgb2Ygc2VsZWN0aW9uIG1vcmUgaW4gbGluZSB3aXRoIHRoYXQgdXNlcnNcbmV4cGVjdCBpbiBhIHRleHQgZWRpdG9yICh0aGUgbmF0aXZlIHNlbGVjdGlvbiBzdHlsaW5nIHdpbGwgb2Z0ZW5cbmxlYXZlIGdhcHMgYmV0d2VlbiBsaW5lcyBhbmQgd29uJ3QgZmlsbCB0aGUgaG9yaXpvbnRhbCBzcGFjZSBhZnRlclxuYSBsaW5lIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250aW51ZXMgcGFzdCBpdCkuXG5cbkl0IGRvZXMgaGF2ZSBhIHBlcmZvcm1hbmNlIGNvc3QsIGluIHRoYXQgaXQgcmVxdWlyZXMgYW4gZXh0cmEgRE9NXG5sYXlvdXQgY3ljbGUgZm9yIG1hbnkgdXBkYXRlcyAodGhlIHNlbGVjdGlvbiBpcyBkcmF3biBiYXNlZCBvbiBET01cbmxheW91dCBpbmZvcm1hdGlvbiB0aGF0J3Mgb25seSBhdmFpbGFibGUgYWZ0ZXIgbGF5aW5nIG91dCB0aGVcbmNvbnRlbnQpLlxuKi9cbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZWxlY3Rpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY3Vyc29yTGF5ZXIsXG4gICAgICAgIHNlbGVjdGlvbkxheWVyLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxuICAgICAgICBuYXRpdmVTZWxlY3Rpb25IaWRkZW4ub2YodHJ1ZSlcbiAgICBdO1xufVxuLyoqXG5SZXRyaWV2ZSB0aGUgW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNvbmZpZ3VyYXRpb25cbmZvciB0aGlzIHN0YXRlLiAoTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gYSBzZXQgb2YgZGVmYXVsdHMgZXZlblxuaWYgYGRyYXdTZWxlY3Rpb25gIGlzbid0IGVuYWJsZWQuKVxuKi9cbmZ1bmN0aW9uIGdldERyYXdTZWxlY3Rpb25Db25maWcoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZWQodXBkYXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG59XG5jb25zdCBjdXJzb3JMYXllciA9IC8qQF9fUFVSRV9fKi9sYXllcih7XG4gICAgYWJvdmU6IHRydWUsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IGN1cnNvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgcHJpbSA9IHIgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBpZiAoci5lbXB0eSB8fCBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxufSk7XG5jb25zdCBoaWRlTmF0aXZlU2VsZWN0aW9uID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyovRWRpdG9yVmlldy50aGVtZSh7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvbiwgJjo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9LFxuICAgICAgICBjYXJldENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIlxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiLFxuICAgICAgICBcIiYgOmZvY3VzXCI6IHtcbiAgICAgICAgICAgIGNhcmV0Q29sb3I6IFwiaW5pdGlhbCAhaW1wb3J0YW50XCIsXG4gICAgICAgICAgICBcIiY6OnNlbGVjdGlvbiwgJiA6OnNlbGVjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIkhpZ2hsaWdodCAhaW1wb3J0YW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pKTtcblxuY29uc3Qgc2V0RHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChwb3MsIG1hcHBpbmcpIHsgcmV0dXJuIHBvcyA9PSBudWxsID8gbnVsbCA6IG1hcHBpbmcubWFwUG9zKHBvcyk7IH1cbn0pO1xuY29uc3QgZHJvcEN1cnNvclBvcyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUocG9zLCB0cikge1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICBwb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyhwb3MpO1xuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHBvcywgZSkgPT4gZS5pcyhzZXREcm9wQ3Vyc29yUG9zKSA/IGUudmFsdWUgOiBwb3MsIHBvcyk7XG4gICAgfVxufSk7XG5jb25zdCBkcmF3RHJvcEN1cnNvciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5yZWFkUG9zLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXdDdXJzb3IuYmluZCh0aGlzKSB9O1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGN1cnNvclBvcyA9IHVwZGF0ZS5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY3Vyc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy52aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5jbGFzc05hbWUgPSBcImNtLWRyb3BDdXJzb3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBjdXJzb3JQb3MgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkUG9zKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBsZXQgcG9zID0gdmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IHJlY3QgPSBwb3MgIT0gbnVsbCAmJiB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgb3V0ZXIgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG91dGVyLmxlZnQgKyB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ICogdmlldy5zY2FsZVgsXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wIC0gb3V0ZXIudG9wICsgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVksXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhd0N1cnNvcihwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3O1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmhlaWdodCA9IHBvcy5oZWlnaHQgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gXCItMTAwMDAwcHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgc2V0RHJvcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBwb3MpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXREcm9wQ3Vyc29yUG9zLm9mKHBvcykgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3ModGhpcy52aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSB0aGlzLnZpZXcuY29udGVudERPTSB8fCAhdGhpcy52aWV3LmNvbnRlbnRET00uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnZW5kKCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBkcm9wKCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcbkRyYXdzIGEgY3Vyc29yIGF0IHRoZSBjdXJyZW50IGRyb3AgcG9zaXRpb24gd2hlbiBzb21ldGhpbmcgaXNcbmRyYWdnZWQgb3ZlciB0aGUgZWRpdG9yLlxuKi9cbmZ1bmN0aW9uIGRyb3BDdXJzb3IoKSB7XG4gICAgcmV0dXJuIFtkcm9wQ3Vyc29yUG9zLCBkcmF3RHJvcEN1cnNvcl07XG59XG5cbmZ1bmN0aW9uIGl0ZXJNYXRjaGVzKGRvYywgcmUsIGZyb20sIHRvLCBmKSB7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjdXJzb3IgPSBkb2MuaXRlclJhbmdlKGZyb20sIHRvKSwgcG9zID0gZnJvbSwgbTsgIWN1cnNvci5uZXh0KCkuZG9uZTsgcG9zICs9IGN1cnNvci52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFjdXJzb3IubGluZUJyZWFrKVxuICAgICAgICAgICAgd2hpbGUgKG0gPSByZS5leGVjKGN1cnNvci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgZihwb3MgKyBtLmluZGV4LCBtKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaFJhbmdlcyh2aWV3LCBtYXhMZW5ndGgpIHtcbiAgICBsZXQgdmlzaWJsZSA9IHZpZXcudmlzaWJsZVJhbmdlcztcbiAgICBpZiAodmlzaWJsZS5sZW5ndGggPT0gMSAmJiB2aXNpYmxlWzBdLmZyb20gPT0gdmlldy52aWV3cG9ydC5mcm9tICYmXG4gICAgICAgIHZpc2libGVbMF0udG8gPT0gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aXNpYmxlKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heCh2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSkuZnJvbSwgZnJvbSAtIG1heExlbmd0aCk7XG4gICAgICAgIHRvID0gTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bywgdG8gKyBtYXhMZW5ndGgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnRvID49IGZyb20pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnRvID0gdG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkhlbHBlciBjbGFzcyB1c2VkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIG1haW50YWluIGRlY29yYXRpb25zIG9uXG52aXNpYmxlIGNvZGUgdGhhdCBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLiBUbyBiZSB1c2VkXG5pbiBhIFt2aWV3IHBsdWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pLiBJbnN0YW5jZXMgb2YgdGhpcyBvYmplY3RcbnJlcHJlc2VudCBhIG1hdGNoaW5nIGNvbmZpZ3VyYXRpb24uXG4qL1xuY2xhc3MgTWF0Y2hEZWNvcmF0b3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGRlY29yYXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBjb25zdCB7IHJlZ2V4cCwgZGVjb3JhdGlvbiwgZGVjb3JhdGUsIGJvdW5kYXJ5LCBtYXhMZW5ndGggPSAxMDAwIH0gPSBjb25maWc7XG4gICAgICAgIGlmICghcmVnZXhwLmdsb2JhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnaXZlbiB0byBNYXRjaERlY29yYXRvciBzaG91bGQgaGF2ZSBpdHMgJ2cnIGZsYWcgc2V0XCIpO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9IHJlZ2V4cDtcbiAgICAgICAgaWYgKGRlY29yYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IGRlY29yYXRlKGFkZCwgZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgbWF0Y2gsIHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWNvcmF0aW9uID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRlY28gPSBkZWNvcmF0aW9uKG1hdGNoLCB2aWV3LCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjbylcbiAgICAgICAgICAgICAgICAgICAgYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY28pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCBfdmlldywgZnJvbSwgYWRkKSA9PiBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjb3JhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVpdGhlciAnZGVjb3JhdGUnIG9yICdkZWNvcmF0aW9uJyBzaG91bGQgYmUgcHJvdmlkZWQgdG8gTWF0Y2hEZWNvcmF0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgZnVsbCBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIG1hdGNoZXMgaW4gdGhlIGdpdmVuXG4gICAgdmlldydzIHZpZXdwb3J0LiBZb3UnbGwgd2FudCB0byBjYWxsIHRoaXMgd2hlbiBpbml0aWFsaXppbmcgeW91clxuICAgIHBsdWdpbi5cbiAgICAqL1xuICAgIGNyZWF0ZURlY28odmlldykge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCksIGFkZCA9IGJ1aWxkLmFkZC5iaW5kKGJ1aWxkKTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1hdGNoUmFuZ2VzKHZpZXcsIHRoaXMubWF4TGVuZ3RoKSlcbiAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgZnJvbSwgdG8sIChmcm9tLCBtKSA9PiB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIGZyb20sIGFkZCkpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgYSB2aWV3IHVwZGF0ZS4gYGRlY29gIF9tdXN0XyBiZVxuICAgIHRoZSBzZXQgb2YgZGVjb3JhdGlvbnMgcHJvZHVjZWQgYnkgX3RoaXNfIGBNYXRjaERlY29yYXRvcmAgZm9yXG4gICAgdGhlIHZpZXcgc3RhdGUgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgKi9cbiAgICB1cGRhdGVEZWNvKHVwZGF0ZSwgZGVjbykge1xuICAgICAgICBsZXQgY2hhbmdlRnJvbSA9IDFlOSwgY2hhbmdlVG8gPSAtMTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKF9mLCBfdCwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodG8gPj0gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDw9IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZyb20gPSBNYXRoLm1pbihmcm9tLCBjaGFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0TW92ZWQgfHwgY2hhbmdlVG8gLSBjaGFuZ2VGcm9tID4gMTAwMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICBpZiAoY2hhbmdlVG8gPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVJhbmdlKHVwZGF0ZS52aWV3LCBkZWNvLm1hcCh1cGRhdGUuY2hhbmdlcyksIGNoYW5nZUZyb20sIGNoYW5nZVRvKTtcbiAgICAgICAgcmV0dXJuIGRlY287XG4gICAgfVxuICAgIHVwZGF0ZVJhbmdlKHZpZXcsIGRlY28sIHVwZGF0ZUZyb20sIHVwZGF0ZVRvKSB7XG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHIuZnJvbSwgdXBkYXRlRnJvbSksIHRvID0gTWF0aC5taW4oci50bywgdXBkYXRlVG8pO1xuICAgICAgICAgICAgaWYgKHRvID49IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdTIwNjZcXHUyMDY3XFx1MjA2OVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODI5NDogXCJsZWZ0LXRvLXJpZ2h0IGlzb2xhdGVcIixcbiAgICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcbiAgICAgICAgICAgIGFkZFNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXFx0fFwiICsgY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBoaWdobGlnaHRpbmcgb2Ygc3BlY2lhbFxuY2hhcmFjdGVycy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoXG4vKipcbkNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiovXG5jb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbc3BlY2lhbENoYXJDb25maWcub2YoY29uZmlnKSwgc3BlY2lhbENoYXJQbHVnaW4oKV07XG59XG5sZXQgX3BsdWdpbiA9IG51bGw7XG5mdW5jdGlvbiBzcGVjaWFsQ2hhclBsdWdpbigpIHtcbiAgICByZXR1cm4gX3BsdWdpbiB8fCAoX3BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcih2aWV3LnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlRGVjb3JhdG9yKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogKG0sIHZpZXcsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIC8gdGhpcy52aWV3LnNjYWxlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgLVxuICAgICAgICAgICAgdmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCAtIDAuNTtcbiAgICAgICAgaWYgKGhlaWdodCA+PSAwICYmIGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogYHBhZGRpbmctYm90dG9tOiAke2hlaWdodH1weGAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IG1ha2VzIHN1cmUgdGhlIGNvbnRlbnQgaGFzIGEgYm90dG9tXG5tYXJnaW4gZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlZGl0b3IsIG1pbnVzIG9uZSBsaW5lXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxudG9wIG9mIHRoZSBlZGl0b3IuXG5cblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXG5ub3QgYmUgZW5hYmxlZCBpbiBlZGl0b3JzIHRoYXQgdGFrZSB0aGUgc2l6ZSBvZiB0aGVpciBjb250ZW50LlxuKi9cbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XG4gICAgcmV0dXJuIFtwbHVnaW4sIGNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSB8fCBudWxsOyB9KV07XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5saW5lKHsgY2xhc3M6IFwiY20tYWN0aXZlTGluZVwiIH0pO1xuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gLTEsIGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChyLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IGxhc3RMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2gobGluZURlY28ucmFuZ2UobGluZS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuXG5jbGFzcyBQbGFjZWhvbGRlciBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB3cmFwLmNsYXNzTmFtZSA9IFwiY20tcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgd3JhcC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jb250ZW50KSA6XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5jb250ZW50ID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuY29udGVudCh2aWV3KSA6XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICByZXR1cm4gd3JhcDtcbiAgICB9XG4gICAgY29vcmRzQXQoZG9tKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGRvbS5maXJzdENoaWxkID8gY2xpZW50UmVjdHNGb3IoZG9tLmZpcnN0Q2hpbGQpIDogW107XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbS5wYXJlbnROb2RlKTtcbiAgICAgICAgbGV0IHJlY3QgPSBmbGF0dGVuUmVjdChyZWN0c1swXSwgc3R5bGUuZGlyZWN0aW9uICE9IFwicnRsXCIpO1xuICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBhcnNlSW50KHN0eWxlLmxpbmVIZWlnaHQpO1xuICAgICAgICBpZiAocmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGxpbmVIZWlnaHQgKiAxLjUpXG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbGluZUhlaWdodCB9O1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLyoqXG5FeHRlbnNpb24gdGhhdCBlbmFibGVzIGEgcGxhY2Vob2xkZXLigJRhIHBpZWNlIG9mIGV4YW1wbGUgY29udGVudFxudG8gc2hvdyB3aGVuIHRoZSBlZGl0b3IgaXMgZW1wdHkuXG4qL1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIoY29udGVudCkge1xuICAgIGxldCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gY29udGVudFxuICAgICAgICAgICAgICAgID8gRGVjb3JhdGlvbi5zZXQoW0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiBuZXcgUGxhY2Vob2xkZXIoY29udGVudCksIHNpZGU6IDEgfSkucmFuZ2UoMCldKVxuICAgICAgICAgICAgICAgIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZWNvcmF0aW9ucygpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gRGVjb3JhdGlvbi5ub25lIDogdGhpcy5wbGFjZWhvbGRlcjsgfVxuICAgIH0sIHsgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9ucyB9KTtcbiAgICByZXR1cm4gdHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IFtcbiAgICAgICAgcGx1Z2luLCBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgXCJhcmlhLXBsYWNlaG9sZGVyXCI6IGNvbnRlbnQgfSlcbiAgICBdIDogcGx1Z2luO1xufVxuXG4vLyBEb24ndCBjb21wdXRlIHByZWNpc2UgY29sdW1uIHBvc2l0aW9ucyBmb3IgbGluZSBvZmZzZXRzIGFib3ZlIHRoaXNcbi8vIChzaW5jZSBpdCBjb3VsZCBnZXQgZXhwZW5zaXZlKS4gQXNzdW1lIG9mZnNldD09Y29sdW1uIGZvciB0aGVtLlxuY29uc3QgTWF4T2ZmID0gMjAwMDtcbmZ1bmN0aW9uIHJlY3RhbmdsZUZvcihzdGF0ZSwgYSwgYikge1xuICAgIGxldCBzdGFydExpbmUgPSBNYXRoLm1pbihhLmxpbmUsIGIubGluZSksIGVuZExpbmUgPSBNYXRoLm1heChhLmxpbmUsIGIubGluZSk7XG4gICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgIGlmIChhLm9mZiA+IE1heE9mZiB8fCBiLm9mZiA+IE1heE9mZiB8fCBhLmNvbCA8IDAgfHwgYi5jb2wgPCAwKSB7XG4gICAgICAgIGxldCBzdGFydE9mZiA9IE1hdGgubWluKGEub2ZmLCBiLm9mZiksIGVuZE9mZiA9IE1hdGgubWF4KGEub2ZmLCBiLm9mZik7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IGVuZE9mZilcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnRPZmYsIGxpbmUudG8gKyBlbmRPZmYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHN0YXJ0Q29sID0gTWF0aC5taW4oYS5jb2wsIGIuY29sKSwgZW5kQ29sID0gTWF0aC5tYXgoYS5jb2wsIGIuY29sKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgc3RhcnRDb2wsIHN0YXRlLnRhYlNpemUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobGluZS50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBlbmRDb2wsIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydCwgbGluZS5mcm9tICsgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGFic29sdXRlQ29sdW1uKHZpZXcsIHgpIHtcbiAgICBsZXQgcmVmID0gdmlldy5jb29yZHNBdFBvcyh2aWV3LnZpZXdwb3J0LmZyb20pO1xuICAgIHJldHVybiByZWYgPyBNYXRoLnJvdW5kKE1hdGguYWJzKChyZWYubGVmdCAtIHgpIC8gdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpKSA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG9mZnNldCA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChvZmZzZXQpLCBvZmYgPSBvZmZzZXQgLSBsaW5lLmZyb207XG4gICAgbGV0IGNvbCA9IG9mZiA+IE1heE9mZiA/IC0xXG4gICAgICAgIDogb2ZmID09IGxpbmUubGVuZ3RoID8gYWJzb2x1dGVDb2x1bW4odmlldywgZXZlbnQuY2xpZW50WClcbiAgICAgICAgICAgIDogY291bnRDb2x1bW4obGluZS50ZXh0LCB2aWV3LnN0YXRlLnRhYlNpemUsIG9mZnNldCAtIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIHsgbGluZTogbGluZS5udW1iZXIsIGNvbCwgb2ZmIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IGdldFBvcyh2aWV3LCBldmVudCksIHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lKHN0YXJ0LmxpbmUpLmZyb20pO1xuICAgICAgICAgICAgICAgIGxldCBuZXdMaW5lID0gdXBkYXRlLnN0YXRlLmRvYy5saW5lQXQobmV3U3RhcnQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0geyBsaW5lOiBuZXdMaW5lLm51bWJlciwgY29sOiBzdGFydC5jb2wsIG9mZjogTWF0aC5taW4oc3RhcnQub2ZmLCBuZXdMaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgX2V4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBnZXRQb3ModmlldywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFjdXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHJlY3RhbmdsZUZvcih2aWV3LnN0YXRlLCBzdGFydCwgY3VyKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmNvbmNhdChzdGFydFNlbC5yYW5nZXMpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgcmVjdGFuZ3VsYXIgc2VsZWN0aW9ucy4gQnlcbmRlZmF1bHQsIGl0IHdpbGwgcmVhY3QgdG8gbGVmdCBtb3VzZSBkcmFnIHdpdGggdGhlIEFsdCBrZXkgaGVsZFxuZG93bi4gV2hlbiBzdWNoIGEgc2VsZWN0aW9uIG9jY3VycywgdGhlIHRleHQgd2l0aGluIHRoZSByZWN0YW5nbGVcbnRoYXQgd2FzIGRyYWdnZWQgb3ZlciB3aWxsIGJlIHNlbGVjdGVkLCBhcyBvbmUgc2VsZWN0aW9uXG5bcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UpIHBlciBsaW5lLlxuKi9cbmZ1bmN0aW9uIHJlY3Rhbmd1bGFyU2VsZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlsdGVyID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudEZpbHRlcikgfHwgKGUgPT4gZS5hbHRLZXkgJiYgZS5idXR0b24gPT0gMCk7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZS5vZigodmlldywgZXZlbnQpID0+IGZpbHRlcihldmVudCkgPyByZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSh2aWV3LCBldmVudCkgOiBudWxsKTtcbn1cbmNvbnN0IGtleXMgPSB7XG4gICAgQWx0OiBbMTgsIGUgPT4gISFlLmFsdEtleV0sXG4gICAgQ29udHJvbDogWzE3LCBlID0+ICEhZS5jdHJsS2V5XSxcbiAgICBTaGlmdDogWzE2LCBlID0+ICEhZS5zaGlmdEtleV0sXG4gICAgTWV0YTogWzkxLCBlID0+ICEhZS5tZXRhS2V5XVxufTtcbmNvbnN0IHNob3dDcm9zc2hhaXIgPSB7IHN0eWxlOiBcImN1cnNvcjogY3Jvc3NoYWlyXCIgfTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCB0dXJucyB0aGUgcG9pbnRlciBjdXJzb3IgaW50byBhXG5jcm9zc2hhaXIgd2hlbiBhIGdpdmVuIG1vZGlmaWVyIGtleSwgZGVmYXVsdGluZyB0byBBbHQsIGlzIGhlbGRcbmRvd24uIENhbiBzZXJ2ZSBhcyBhIHZpc3VhbCBoaW50IHRoYXQgcmVjdGFuZ3VsYXIgc2VsZWN0aW9uIGlzXG5nb2luZyB0byBoYXBwZW4gd2hlbiBwYWlyZWQgd2l0aFxuW2ByZWN0YW5ndWxhclNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5yZWN0YW5ndWxhclNlbGVjdGlvbikuXG4qL1xuZnVuY3Rpb24gY3Jvc3NoYWlyQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBbY29kZSwgZ2V0dGVyXSA9IGtleXNbb3B0aW9ucy5rZXkgfHwgXCJBbHRcIl07XG4gICAgbGV0IHBsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGlzRG93bikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb3duICE9IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEb3duID0gaXNEb3duO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICAgICAga2V5ZG93bihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZS5rZXlDb2RlID09IGNvZGUgfHwgZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXl1cChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSBjb2RlIHx8ICFnZXR0ZXIoZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZW1vdmUoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGdldHRlcihlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwbHVnaW4sXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEb3duKSA/IHNob3dDcm9zc2hhaXIgOiBudWxsOyB9KVxuICAgIF07XG59XG5cbmNvbnN0IE91dHNpZGUgPSBcIi0xMDAwMHB4XCI7XG5jbGFzcyBUb29sdGlwVmlld01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGZhY2V0LCBjcmVhdGVUb29sdGlwVmlldywgcmVtb3ZlVG9vbHRpcFZpZXcpIHtcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3ID0gY3JlYXRlVG9vbHRpcFZpZXc7XG4gICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcFZpZXcgPSByZW1vdmVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5pbnB1dCA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdGhpcy5pbnB1dC5maWx0ZXIodCA9PiB0KTtcbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKHQgPT4gcHJldiA9IGNyZWF0ZVRvb2x0aXBWaWV3KHQsIHByZXYpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgYWJvdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXSwgbmV3QWJvdmUgPSBhYm92ZSA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwLCBpID8gdG9vbHRpcFZpZXdzW2kgLSAxXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdBYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgbmV3QWJvdmVbaV0gPSAhIXRpcC5hYm92ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMudG9vbHRpcFZpZXdzW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3QWJvdmUpXG4gICAgICAgICAgICAgICAgICAgIG5ld0Fib3ZlW2ldID0gYWJvdmVba25vd25dO1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICBpZiAodG9vbHRpcFZpZXdzLmluZGV4T2YodCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUb29sdGlwVmlldyh0KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoYWJvdmUpIHtcbiAgICAgICAgICAgIG5ld0Fib3ZlLmZvckVhY2goKHZhbCwgaSkgPT4gYWJvdmVbaV0gPSB2YWwpO1xuICAgICAgICAgICAgYWJvdmUubGVuZ3RoID0gbmV3QWJvdmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRvb2x0aXBzO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRvb2x0aXBWaWV3cztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG5DcmVhdGVzIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgdG9vbHRpcCBiZWhhdmlvci5cbiovXG5mdW5jdGlvbiB0b29sdGlwcyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0b29sdGlwQ29uZmlnLm9mKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB3aW5kb3dTcGFjZSh2aWV3KSB7XG4gICAgbGV0IGRvY0VsdCA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiBkb2NFbHQuY2xpZW50SGVpZ2h0LCByaWdodDogZG9jRWx0LmNsaWVudFdpZHRoIH07XG59XG5jb25zdCB0b29sdGlwQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3Qga25vd25IZWlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRvb2x0aXBQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hYm92ZSA9IFtdO1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBjb25maWcucGFyZW50O1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5tZWFzdXJlU29vbigpKSA6IG51bGw7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd1Rvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCwgcCksIHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodC5kb20pO1xuICAgICAgICAgICAgdC5kb20ucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFib3ZlID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCh0ID0+ICEhdC5hYm92ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aGlzLmxhc3RUcmFuc2FjdGlvbiAtIDUwICYmXG4gICAgICAgICAgICAgICAgZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA8IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlU29vbigpO1xuICAgICAgICB9LCB7IHRocmVzaG9sZDogWzFdIH0pIDogbnVsbDtcbiAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIHZpZXcud2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbiA9IHRoaXMubWVhc3VyZVNvb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMudmlldy5kb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZUludGVyc2VjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuYWJvdmUpO1xuICAgICAgICBpZiAodXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICBsZXQgc2hvdWxkTWVhc3VyZSA9IHVwZGF0ZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZDtcbiAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wb3NpdGlvbiAhPSB0aGlzLnBvc2l0aW9uICYmICF0aGlzLm1hZGVBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ld0NvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLnBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBuZXdDb25maWcucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0LmRvbSk7XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnZpZXcudGhlbWVDbGFzc2VzICE9IHRoaXMuY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTWVhc3VyZSlcbiAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAodG9vbHRpcCwgcHJldikge1xuICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgYmVmb3JlID0gcHJldiA/IHByZXYuZG9tIDogbnVsbDtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwXCIpO1xuICAgICAgICBpZiAodG9vbHRpcC5hcnJvdyAmJiAhdG9vbHRpcFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcCA+IC5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgYXJyb3cuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWFycm93XCI7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20uYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZSh0b29sdGlwVmlldy5kb20sIGJlZm9yZSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudmlldy53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uKTtcbiAgICAgICAgZm9yIChsZXQgdG9vbHRpcFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9hID0gdG9vbHRpcFZpZXcuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodG9vbHRpcFZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnJlc2l6ZU9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZWFzdXJlVGltZW91dCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlKCkge1xuICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgbWFrZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiZml4ZWRcIiAmJiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgZG9tIH0gPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzWzBdO1xuICAgICAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGFsd2F5cyBzZXRzIG9mZnNldFBhcmVudCB0byBudWxsLCBldmVuIGlmIGEgZml4ZWRcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gYSB0cmFuc2Zvcm1lZCBwYXJlbnQuIFNvXG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIHRoaXMga2x1ZGdlIHRvIHRyeSBhbmQgZGV0ZWN0IHRoaXMuXG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gTWF0aC5hYnMocmVjdC50b3AgKyAxMDAwMCkgPiAxIHx8IE1hdGguYWJzKHJlY3QubGVmdCkgPiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTW9yZSBjb25mb3JtaW5nIGJyb3dzZXJzIHdpbGwgc2V0IG9mZnNldFBhcmVudCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1lZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9ICEhZG9tLm9mZnNldFBhcmVudCAmJiBkb20ub2Zmc2V0UGFyZW50ICE9IHRoaXMuY29udGFpbmVyLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFrZUFic29sdXRlIHx8IHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWCA9IHJlY3Qud2lkdGggLyB0aGlzLnBhcmVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyB0aGlzLnBhcmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldy52aWV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB2aXNpYmxlID0gdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB2aXNpYmxlLmxlZnQgKyBtYXJnaW5zLmxlZnQsIHRvcDogdmlzaWJsZS50b3AgKyBtYXJnaW5zLnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogdmlzaWJsZS5yaWdodCAtIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogdmlzaWJsZS5ib3R0b20gLSBtYXJnaW5zLmJvdHRvbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBwb3M6IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAoKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiB0di5nZXRDb29yZHMgPyB0di5nZXRDb29yZHModC5wb3MpIDogdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgICAgICAgc2NhbGVYLCBzY2FsZVksIG1ha2VBYnNvbHV0ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobWVhc3VyZWQubWFrZUFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLm1hZGVBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHZpc2libGUsIHNwYWNlLCBzY2FsZVgsIHNjYWxlWSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCB0b29sdGlwLmNsaXAgIT09IGZhbHNlICYmIChwb3MuYm90dG9tIDw9IE1hdGgubWF4KHZpc2libGUudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbih2aXNpYmxlLmJvdHRvbSwgc3BhY2UuYm90dG9tKSB8fFxuICAgICAgICAgICAgICAgIHBvcy5yaWdodCA8IE1hdGgubWF4KHZpc2libGUubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4odmlzaWJsZS5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSB0b29sdGlwLmFycm93ID8gdFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyb3dIZWlnaHQgPSBhcnJvdyA/IDcgLyogQXJyb3cuU2l6ZSAqLyA6IDA7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBzaXplLnJpZ2h0IC0gc2l6ZS5sZWZ0LCBoZWlnaHQgPSAoX2EgPSBrbm93bkhlaWdodC5nZXQodFZpZXcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzaXplLmJvdHRvbSAtIHNpemUudG9wO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRWaWV3Lm9mZnNldCB8fCBub09mZnNldCwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gc2l6ZS53aWR0aCA+IHNwYWNlLnJpZ2h0IC0gc3BhY2UubGVmdFxuICAgICAgICAgICAgICAgID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1heChzcGFjZS5sZWZ0LCBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKE1hdGgubWF4KHNwYWNlLmxlZnQsIHBvcy5sZWZ0IC0gd2lkdGggKyAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSAtIG9mZnNldC54KSwgc3BhY2UucmlnaHQgLSB3aWR0aCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSB0aGlzLmFib3ZlW2ldO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA8IHNwYWNlLnRvcFxuICAgICAgICAgICAgICAgIDogcG9zLmJvdHRvbSArIGhlaWdodCArIGFycm93SGVpZ2h0ICsgb2Zmc2V0LnkgPiBzcGFjZS5ib3R0b20pICYmXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcbiAgICAgICAgICAgICAgICBhYm92ZSA9IHRoaXMuYWJvdmVbaV0gPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgaGVpZ2h0ICYmIHRWaWV3LnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgdGhpcy52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga25vd25IZWlnaHQuc2V0KHRWaWV3LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID0gc3BhY2VWZXJ0KSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVmdCA8IHJpZ2h0ICYmIHIucmlnaHQgPiBsZWZ0ICYmIHIudG9wIDwgdG9wICsgaGVpZ2h0ICYmIHIuYm90dG9tID4gdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYWJvdmUgPyByLnRvcCAtIGhlaWdodCAtIDIgLSBhcnJvd0hlaWdodCA6IHIuYm90dG9tICsgYXJyb3dIZWlnaHQgKyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICh0b3AgLSBtZWFzdXJlZC5wYXJlbnQudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZXRMZWZ0U3R5bGUoZG9tLCAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSAvIHNjYWxlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNldExlZnRTdHlsZShkb20sIGxlZnQgLyBzY2FsZVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFycm93KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFycm93TGVmdCA9IHBvcy5sZWZ0ICsgKGx0ciA/IG9mZnNldC54IDogLW9mZnNldC54KSAtIChsZWZ0ICsgMTQgLyogQXJyb3cuT2Zmc2V0ICovIC0gNyAvKiBBcnJvdy5TaXplICovKTtcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYXJyb3dMZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hYm92ZVwiLCBhYm92ZSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIWFib3ZlKTtcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHRWaWV3LnBvc2l0aW9uZWQobWVhc3VyZWQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHYgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gc2V0TGVmdFN0eWxlKGVsdCwgdmFsdWUpIHtcbiAgICBsZXQgY3VycmVudCA9IHBhcnNlSW50KGVsdC5zdHlsZS5sZWZ0LCAxMCk7XG4gICAgaWYgKGlzTmFOKGN1cnJlbnQpIHx8IE1hdGguYWJzKHZhbHVlIC0gY3VycmVudCkgPiAxKVxuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHZhbHVlICsgXCJweFwiO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgekluZGV4OiA1MDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLXNlY3Rpb246bm90KDpmaXJzdC1jaGlsZClcIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgaGVpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICB3aWR0aDogYCR7NyAvKiBBcnJvdy5TaXplICovICogMn1weGAsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICBcIiY6YmVmb3JlLCAmOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1hYm92ZSAmXCI6IHtcbiAgICAgICAgICAgIGJvdHRvbTogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWJlbG93ICZcIjoge1xuICAgICAgICAgICAgdG9wOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCIjMzMzMzM4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IG5vT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4vKipcbkZhY2V0IHRvIHdoaWNoIGFuIGV4dGVuc2lvbiBjYW4gYWRkIGEgdmFsdWUgdG8gc2hvdyBhIHRvb2x0aXAuXG4qL1xuY29uc3Qgc2hvd1Rvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBbdG9vbHRpcFBsdWdpbiwgYmFzZVRoZW1lXVxufSk7XG5jb25zdCBzaG93SG92ZXJUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogaW5wdXRzID0+IGlucHV0cy5yZWR1Y2UoKGEsIGkpID0+IGEuY29uY2F0KGkpLCBbXSlcbn0pO1xuY2xhc3MgSG92ZXJUb29sdGlwSG9zdCB7XG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIb3ZlclRvb2x0aXBIb3N0KHZpZXcpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dIb3ZlclRvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCwgcCksIHQgPT4gdC5kb20ucmVtb3ZlKCkpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXAsIHByZXYpIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUoaG9zdGVkVmlldy5kb20sIHByZXYgPyBwcmV2LmRvbS5uZXh0U2libGluZyA6IHRoaXMuZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiBob3N0ZWRWaWV3O1xuICAgIH1cbiAgICBtb3VudCh2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3LnBvc2l0aW9uZWQoc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgfVxuICAgIHBhc3NQcm9wKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBnaXZlbiA9IHZpZXdbbmFtZV07XG4gICAgICAgICAgICBpZiAoZ2l2ZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdpdmVuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBnaXZlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib2Zmc2V0XCIpOyB9XG4gICAgZ2V0IGdldENvb3JkcygpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJnZXRDb29yZHNcIik7IH1cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJvdmVybGFwXCIpOyB9XG4gICAgZ2V0IHJlc2l6ZSgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJyZXNpemVcIik7IH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLm1hcCh0ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHQucG9zOyB9KSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBob3ZlcmVkID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1vdmUudGltZTtcbiAgICAgICAgaWYgKGhvdmVyZWQgPCB0aGlzLmhvdmVyVGltZSlcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lIC0gaG92ZXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIb3ZlcigpO1xuICAgIH1cbiAgICBzdGFydEhvdmVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgIGxldCB7IHZpZXcsIGxhc3RNb3ZlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdGlsZSA9IHZpZXcuZG9jVmlldy50aWxlLm5lYXJlc3QobGFzdE1vdmUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aWxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zLCBzaWRlID0gMTtcbiAgICAgICAgaWYgKHRpbGUuaXNXaWRnZXQoKSkge1xuICAgICAgICAgICAgcG9zID0gdGlsZS5wb3NBdFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdmlldy5wb3NBdENvb3JkcyhsYXN0TW92ZSk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgICAgIGlmICghcG9zQ29vcmRzIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgLSB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYmlkaSA9IHZpZXcuYmlkaVNwYW5zKHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICAgICAgc2lkZSA9IChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHZpZXcsIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgIShBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgIXJlc3VsdC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0IDogW3Jlc3VsdF0pIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiaG92ZXIgdG9vbHRpcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiAhKEFycmF5LmlzQXJyYXkob3BlbikgJiYgIW9wZW4ubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShvcGVuKSA/IG9wZW4gOiBbb3Blbl0pIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkge1xuICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy52aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuZmluZEluZGV4KHQgPT4gdC5jcmVhdGUgPT0gSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUpIDogLTE7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2luZGV4XSA6IG51bGw7XG4gICAgfVxuICAgIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0YXJnZXQ6IGV2ZW50LnRhcmdldCwgdGltZTogRGF0ZS5ub3coKSB9O1xuICAgICAgICBpZiAodGhpcy5ob3ZlclRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUpO1xuICAgICAgICBsZXQgeyBhY3RpdmUsIHRvb2x0aXAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoICYmIHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRvb2x0aXAuZG9tLCBldmVudCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IGFjdGl2ZVswXSB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYiA9IChfYSA9IGFjdGl2ZVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcG9zO1xuICAgICAgICAgICAgaWYgKChwb3MgPT0gZW5kID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHRoaXMubGFzdE1vdmUpICE9IHBvc1xuICAgICAgICAgICAgICAgIDogIWlzT3ZlclJhbmdlKHRoaXMudmlldywgcG9zLCBlbmQsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgeyBhY3RpdmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IGluVG9vbHRpcCA9IHRvb2x0aXAgJiYgdG9vbHRpcC5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWluVG9vbHRpcClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoVG9vbHRpcExlYXZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwKSB7XG4gICAgICAgIGxldCB3YXRjaCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3YXRjaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUubGVuZ3RoICYmICF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHdhdGNoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgfVxufVxuY29uc3QgdG9vbHRpcE1hcmdpbiA9IDQ7XG5mdW5jdGlvbiBpc0luVG9vbHRpcCh0b29sdGlwLCBldmVudCkge1xuICAgIGxldCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gdG9vbHRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYXJyb3c7XG4gICAgaWYgKGFycm93ID0gdG9vbHRpcC5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgbGV0IGFycm93UmVjdCA9IGFycm93LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0b3AgPSBNYXRoLm1pbihhcnJvd1JlY3QudG9wLCB0b3ApO1xuICAgICAgICBib3R0b20gPSBNYXRoLm1heChhcnJvd1JlY3QuYm90dG9tLCBib3R0b20pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQuY2xpZW50WCA+PSBsZWZ0IC0gdG9vbHRpcE1hcmdpbiAmJiBldmVudC5jbGllbnRYIDw9IHJpZ2h0ICsgdG9vbHRpcE1hcmdpbiAmJlxuICAgICAgICBldmVudC5jbGllbnRZID49IHRvcCAtIHRvb2x0aXBNYXJnaW4gJiYgZXZlbnQuY2xpZW50WSA8PSBib3R0b20gKyB0b29sdGlwTWFyZ2luO1xufVxuZnVuY3Rpb24gaXNPdmVyUmFuZ2UodmlldywgZnJvbSwgdG8sIHgsIHksIG1hcmdpbikge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvY0JvdHRvbSA9IHZpZXcuZG9jdW1lbnRUb3AgKyB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgKyB2aWV3LmNvbnRlbnRIZWlnaHQ7XG4gICAgaWYgKHJlY3QubGVmdCA+IHggfHwgcmVjdC5yaWdodCA8IHggfHwgcmVjdC50b3AgPiB5IHx8IE1hdGgubWluKHJlY3QuYm90dG9tLCBkb2NCb3R0b20pIDwgeSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeCwgeSB9LCBmYWxzZSk7XG4gICAgcmV0dXJuIHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bztcbn1cbi8qKlxuU2V0IHVwIGEgaG92ZXIgdG9vbHRpcCwgd2hpY2ggc2hvd3MgdXAgd2hlbiB0aGUgcG9pbnRlciBob3ZlcnNcbm92ZXIgcmFuZ2VzIG9mIHRleHQuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgaG92ZXJzXG5vdmVyIHRoZSBkb2N1bWVudCB0ZXh0LiBJdCBzaG91bGQsIGlmIHRoZXJlIGlzIGEgdG9vbHRpcFxuYXNzb2NpYXRlZCB3aXRoIHBvc2l0aW9uIGBwb3NgLCByZXR1cm4gdGhlIHRvb2x0aXAgZGVzY3JpcHRpb25cbihlaXRoZXIgZGlyZWN0bHkgb3IgaW4gYSBwcm9taXNlKS4gVGhlIGBzaWRlYCBhcmd1bWVudCBpbmRpY2F0ZXNcbm9uIHdoaWNoIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoZSBwb2ludGVyIGlz4oCUaXQgd2lsbCBiZSAtMSBpZiB0aGVcbnBvaW50ZXIgaXMgYmVmb3JlIHRoZSBwb3NpdGlvbiwgMSBpZiBhZnRlciB0aGUgcG9zaXRpb24uXG5cbk5vdGUgdGhhdCBhbGwgaG92ZXIgdG9vbHRpcHMgYXJlIGhvc3RlZCB3aXRoaW4gYSBzaW5nbGUgdG9vbHRpcFxuY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgYWxsb3dzIG11bHRpcGxlIHRvb2x0aXBzIG92ZXIgdGhlIHNhbWVcbnJhbmdlIHRvIGJlIFwibWVyZ2VkXCIgdG9nZXRoZXIgd2l0aG91dCBvdmVybGFwcGluZy5cblxuVGhlIHJldHVybiB2YWx1ZSBpcyBhIHZhbGlkIFtlZGl0b3IgZXh0ZW5zaW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbilcbmJ1dCBhbHNvIHByb3ZpZGVzIGFuIGBhY3RpdmVgIHByb3BlcnR5IGhvbGRpbmcgYSBzdGF0ZSBmaWVsZCB0aGF0XG5jYW4gYmUgdXNlZCB0byByZWFkIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRvb2x0aXBzIHByb2R1Y2VkIGJ5IHRoaXNcbmV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBob3ZlclRvb2x0aXAoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc2V0SG92ZXIgPSBTdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbiAgICBsZXQgaG92ZXJTdGF0ZSA9IFN0YXRlRmllbGQuZGVmaW5lKHtcbiAgICAgICAgY3JlYXRlKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oaWRlT25DaGFuZ2UgJiYgKHRyLmRvY0NoYW5nZWQgfHwgdHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhpZGVPbilcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5maWx0ZXIodiA9PiAhb3B0aW9ucy5oaWRlT24odHIsIHYpKTtcbiAgICAgICAgICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh0b29sdGlwLnBvcywgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1BvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHRvb2x0aXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkucG9zID0gbmV3UG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3B5LmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmVuZCA9IHRyLmNoYW5nZXMubWFwUG9zKGNvcHkuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWQucHVzaChjb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0SG92ZXIpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZTogZiA9PiBzaG93SG92ZXJUb29sdGlwLmZyb20oZilcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmU6IGhvdmVyU3RhdGUsXG4gICAgICAgIGV4dGVuc2lvbjogW1xuICAgICAgICAgICAgaG92ZXJTdGF0ZSxcbiAgICAgICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIG9wdGlvbnMuaG92ZXJUaW1lIHx8IDMwMCAvKiBIb3Zlci5UaW1lICovKSksXG4gICAgICAgICAgICBzaG93SG92ZXJUb29sdGlwSG9zdFxuICAgICAgICBdXG4gICAgfTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwKHZpZXcsIHRvb2x0aXApIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKCFwbHVnaW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XG4gICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbZm91bmRdO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgYW55IGhvdmVyIHRvb2x0aXBzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuc29tZSh4ID0+IHgpO1xufVxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGVmZmVjdCB0aGF0IGNsb3NlcyBhbGwgaG92ZXIgdG9vbHRpcHMuXG4qL1xuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBzID0gLypAX19QVVJFX18qL2Nsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4ubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfTtcbiAgICB9KVxufSk7XG5jbGFzcyBQYW5lbEdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLnN5bmNDbGFzc2VzKCk7XG4gICAgfVxuICAgIHN5bmMocGFuZWxzKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICBpZiAocC5kZXN0cm95ICYmIHBhbmVscy5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpbm5lckhlaWdodCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pIC0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB9XG4gICAgc3luY0NsYXNzZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIgfHwgdGhpcy5jbGFzc2VzID09IHRoaXMudmlldy50aGVtZUNsYXNzZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm0obm9kZSkge1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0O1xufVxuLyoqXG5PcGVuaW5nIGEgcGFuZWwgaXMgZG9uZSBieSBwcm92aWRpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3JcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXG5jb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgcHJvdmlkZWQuKSBWYWx1ZXMgb2YgYG51bGxgIGFyZSBpZ25vcmVkLlxuKi9cbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5TaG93IGEgcGFuZWwgYWJvdmUgb3IgYmVsb3cgdGhlIGVkaXRvciB0byBzaG93IHRoZSB1c2VyIGEgbWVzc2FnZVxub3IgcHJvbXB0IHRoZW0gZm9yIGlucHV0LiBSZXR1cm5zIGFuIGVmZmVjdCB0aGF0IGNhbiBiZSBkaXNwYXRjaGVkXG50byBjbG9zZSB0aGUgZGlhbG9nLCBhbmQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZGlhbG9nXG5pcyBjbG9zZWQgb3IgYSBmb3JtIGluc2lkZSBvZiBpdCBpcyBzdWJtaXR0ZWQuXG5cbllvdSBhcmUgZW5jb3VyYWdlZCwgaWYgeW91ciBoYW5kbGluZyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlXG5kaXNwYXRjaGVzIGEgdHJhbnNhY3Rpb24sIHRvIGluY2x1ZGUgdGhlIGBjbG9zZWAgZWZmZWN0IGluIGl0LiBJZlxueW91IGRvbid0LCB0aGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBkaXNwYXRjaCBhIHNlcGFyYXRlXG50cmFuc2FjdGlvbiByaWdodCBhZnRlci5cbiovXG5mdW5jdGlvbiBzaG93RGlhbG9nKHZpZXcsIGNvbmZpZykge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UociA9PiByZXNvbHZlID0gcik7XG4gICAgbGV0IHBhbmVsQ3RvciA9ICh2aWV3KSA9PiBjcmVhdGVEaWFsb2codmlldywgY29uZmlnLCByZXNvbHZlKTtcbiAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBvcGVuRGlhbG9nRWZmZWN0Lm9mKHBhbmVsQ3RvcikgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGRpYWxvZ0ZpZWxkLmluaXQoKCkgPT4gW3BhbmVsQ3Rvcl0pKSB9KTtcbiAgICB9XG4gICAgbGV0IGNsb3NlID0gY2xvc2VEaWFsb2dFZmZlY3Qub2YocGFuZWxDdG9yKTtcbiAgICByZXR1cm4geyBjbG9zZSwgcmVzdWx0OiBwcm9taXNlLnRoZW4oZm9ybSA9PiB7XG4gICAgICAgICAgICBsZXQgcXVldWUgPSB2aWV3Lndpbi5xdWV1ZU1pY3JvdGFzayB8fCAoKGYpID0+IHZpZXcud2luLnNldFRpbWVvdXQoZiwgMTApKTtcbiAgICAgICAgICAgIHF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCkuaW5kZXhPZihwYW5lbEN0b3IpID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgIH0pIH07XG59XG4vKipcbkZpbmQgdGhlIFtgUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuUGFuZWwpIGZvciBhbiBvcGVuIGRpYWxvZywgdXNpbmcgYSBjbGFzc1xubmFtZSBhcyBpZGVudGlmaWVyLlxuKi9cbmZ1bmN0aW9uIGdldERpYWxvZyh2aWV3LCBjbGFzc05hbWUpIHtcbiAgICBsZXQgZGlhbG9ncyA9IHZpZXcuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSB8fCBbXTtcbiAgICBmb3IgKGxldCBvcGVuIG9mIGRpYWxvZ3MpIHtcbiAgICAgICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgb3Blbik7XG4gICAgICAgIGlmIChwYW5lbCAmJiBwYW5lbC5kb20uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gcGFuZWw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgZGlhbG9nRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIFtdOyB9LFxuICAgIHVwZGF0ZShkaWFsb2dzLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKG9wZW5EaWFsb2dFZmZlY3QpKVxuICAgICAgICAgICAgICAgIGRpYWxvZ3MgPSBbZS52YWx1ZV0uY29uY2F0KGRpYWxvZ3MpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZS5pcyhjbG9zZURpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgZGlhbG9ncyA9IGRpYWxvZ3MuZmlsdGVyKGQgPT4gZCAhPSBlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlhbG9ncztcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmNvbXB1dGVOKFtmXSwgc3RhdGUgPT4gc3RhdGUuZmllbGQoZikpXG59KTtcbmNvbnN0IG9wZW5EaWFsb2dFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjbG9zZURpYWxvZ0VmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGNyZWF0ZURpYWxvZyh2aWV3LCBjb25maWcsIHJlc3VsdCkge1xuICAgIGxldCBjb250ZW50ID0gY29uZmlnLmNvbnRlbnQgPyBjb25maWcuY29udGVudCh2aWV3LCAoKSA9PiBkb25lKG51bGwpKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIGNvbnRlbnQgPSBlbHQoXCJmb3JtXCIpO1xuICAgICAgICBpZiAoY29uZmlnLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCBjb25maWcuaW5wdXQpO1xuICAgICAgICAgICAgaWYgKC9eKHRleHR8cGFzc3dvcmR8bnVtYmVyfGVtYWlsfHRlbHx1cmwpJC8udGVzdChpbnB1dC50eXBlKSlcbiAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwiY20tdGV4dGZpZWxkXCIpO1xuICAgICAgICAgICAgaWYgKCFpbnB1dC5uYW1lKVxuICAgICAgICAgICAgICAgIGlucHV0Lm5hbWUgPSBcImlucHV0XCI7XG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcImxhYmVsXCIsIChjb25maWcubGFiZWwgfHwgXCJcIikgKyBcIjogXCIsIGlucHV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbmZpZy5sYWJlbCB8fCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIikpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIGNvbmZpZy5zdWJtaXRMYWJlbCB8fCBcIk9LXCIpKTtcbiAgICB9XG4gICAgbGV0IGZvcm1zID0gY29udGVudC5ub2RlTmFtZSA9PSBcIkZPUk1cIiA/IFtjb250ZW50XSA6IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcImZvcm1cIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZm9ybSA9IGZvcm1zW2ldO1xuICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkb25lKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZG9uZShmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb25lKGZvcm0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHBhbmVsID0gZWx0KFwiZGl2XCIsIGNvbnRlbnQsIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgIG9uY2xpY2s6ICgpID0+IGRvbmUobnVsbCksXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB2aWV3LnN0YXRlLnBocmFzZShcImNsb3NlXCIpLFxuICAgICAgICBjbGFzczogXCJjbS1kaWFsb2ctY2xvc2VcIixcbiAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgIH0sIFtcIsOXXCJdKSk7XG4gICAgaWYgKGNvbmZpZy5jbGFzcylcbiAgICAgICAgcGFuZWwuY2xhc3NOYW1lID0gY29uZmlnLmNsYXNzO1xuICAgIHBhbmVsLmNsYXNzTGlzdC5hZGQoXCJjbS1kaWFsb2dcIik7XG4gICAgZnVuY3Rpb24gZG9uZShmb3JtKSB7XG4gICAgICAgIGlmIChwYW5lbC5jb250YWlucyhwYW5lbC5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICByZXN1bHQoZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogcGFuZWwsXG4gICAgICAgIHRvcDogY29uZmlnLnRvcCxcbiAgICAgICAgbW91bnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm9jdXM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuZm9jdXMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgZm9jdXMgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoY29uZmlnLmZvY3VzKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzID0gY29udGVudC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikgfHwgY29udGVudC5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChmb2N1cyAmJiBcInNlbGVjdFwiIGluIGZvY3VzKVxuICAgICAgICAgICAgICAgICAgICBmb2N1cy5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb2N1cyAmJiBcImZvY3VzXCIgaW4gZm9jdXMpXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbkEgZ3V0dGVyIG1hcmtlciByZXByZXNlbnRzIGEgYml0IG9mIGluZm9ybWF0aW9uIGF0dGFjaGVkIHRvIGEgbGluZVxuaW4gYSBzcGVjaWZpYyBndXR0ZXIuIFlvdXIgb3duIGN1c3RvbSBtYXJrZXJzIGhhdmUgdG8gZXh0ZW5kIHRoaXNcbmNsYXNzLlxuKi9cbmNsYXNzIEd1dHRlck1hcmtlciBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnN0cnVjdG9yID09IG90aGVyLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEob3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgbWFya2VyIHRvIGFub3RoZXIgbWFya2VyIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBDYWxsZWQgaWYgdGhlIG1hcmtlciBoYXMgYSBgdG9ET01gIG1ldGhvZCBhbmQgaXRzIHJlcHJlc2VudGF0aW9uXG4gICAgd2FzIHJlbW92ZWQgZnJvbSBhIGd1dHRlci5cbiAgICAqL1xuICAgIGRlc3Ryb3koZG9tKSB7IH1cbn1cbkd1dHRlck1hcmtlci5wcm90b3R5cGUuZWxlbWVudENsYXNzID0gXCJcIjtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUudG9ET00gPSB1bmRlZmluZWQ7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5zdGFydFNpZGUgPSBHdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVuZFNpZGUgPSAtMTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGFkZCBhIGNsYXNzIHRvIGFsbCBndXR0ZXIgZWxlbWVudHMgZm9yIGEgZ2l2ZW4gbGluZS5cbk1hcmtlcnMgZ2l2ZW4gdG8gdGhpcyBmYWNldCBzaG91bGQgX29ubHlfIGRlZmluZSBhblxuW2BlbGVtZW50Y2xhc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLmVsZW1lbnRDbGFzcyksIG5vdCBhXG5bYHRvRE9NYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci50b0RPTSkgKG9yIHRoZSBtYXJrZXIgd2lsbCBhcHBlYXJcbmluIGFsbCBndXR0ZXJzIGZvciB0aGUgbGluZSkuXG4qL1xuY29uc3QgZ3V0dGVyTGluZUNsYXNzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCB1c2VkIHRvIGFkZCBhIGNsYXNzIHRvIGFsbCBndXR0ZXIgZWxlbWVudHMgbmV4dCB0byBhIHdpZGdldC5cblNob3VsZCBub3QgcHJvdmlkZSB3aWRnZXRzIHdpdGggYSBgdG9ET01gIG1ldGhvZC5cbiovXG5jb25zdCBndXR0ZXJXaWRnZXRDbGFzcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGNsYXNzOiBcIlwiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIGVsZW1lbnRTdHlsZTogXCJcIixcbiAgICBtYXJrZXJzOiAoKSA9PiBSYW5nZVNldC5lbXB0eSxcbiAgICBsaW5lTWFya2VyOiAoKSA9PiBudWxsLFxuICAgIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiBudWxsLFxuICAgIGluaXRpYWxTcGFjZXI6IG51bGwsXG4gICAgdXBkYXRlU3BhY2VyOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9LFxuICAgIHNpZGU6IFwiYmVmb3JlXCJcbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYW4gZWRpdG9yIGd1dHRlci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBndXR0ZXJzIGFwcGVhciBpc1xuZGV0ZXJtaW5lZCBieSB0aGVpciBleHRlbnNpb24gcHJpb3JpdHkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVyKGNvbmZpZykge1xuICAgIHJldHVybiBbZ3V0dGVycygpLCBhY3RpdmVHdXR0ZXJzLm9mKHsgLi4uZGVmYXVsdHMsIC4uLmNvbmZpZyB9KV07XG59XG5jb25zdCB1bmZpeEd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG4vKipcblRoZSBndXR0ZXItZHJhd2luZyBwbHVnaW4gaXMgYXV0b21hdGljYWxseSBlbmFibGVkIHdoZW4geW91IGFkZCBhXG5ndXR0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGV4cGxpY2l0bHkgY29uZmlndXJlIGl0LlxuXG5Vbmxlc3MgYGZpeGVkYCBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLCB0aGUgZ3V0dGVycyBhcmVcbmZpeGVkLCBtZWFuaW5nIHRoZXkgZG9uJ3Qgc2Nyb2xsIGFsb25nIHdpdGggdGhlIGNvbnRlbnRcbmhvcml6b250YWxseSAoZXhjZXB0IG9uIEludGVybmV0IEV4cGxvcmVyLCB3aGljaCBkb2Vzbid0IHN1cHBvcnRcbkNTUyBbYHBvc2l0aW9uOlxuc3RpY2t5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uI3N0aWNreSkpLlxuKi9cbmZ1bmN0aW9uIGd1dHRlcnMoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtcbiAgICAgICAgZ3V0dGVyVmlldyxcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRvbUFmdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVycyBjbS1ndXR0ZXJzLWJlZm9yZVwiO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9ICh0aGlzLnZpZXcuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmd1dHRlcnMgPSB2aWV3LnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLm1hcChjb25mID0+IG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHZpZXcsIGNvbmYpKTtcbiAgICAgICAgdGhpcy5maXhlZCA9ICF2aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycyk7XG4gICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChndXR0ZXIuY29uZmlnLnNpZGUgPT0gXCJhZnRlclwiKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RE9NQWZ0ZXIoKS5hcHBlbmRDaGlsZChndXR0ZXIuZG9tKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChndXR0ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgZ2V0RE9NQWZ0ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb21BZnRlcikge1xuICAgICAgICAgICAgdGhpcy5kb21BZnRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmRvbUFmdGVyLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVycyBjbS1ndXR0ZXJzLWFmdGVyXCI7XG4gICAgICAgICAgICB0aGlzLmRvbUFmdGVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIuc3R5bGUubWluSGVpZ2h0ID0gKHRoaXMudmlldy5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmRvbUFmdGVyLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmRvbUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb21BZnRlcjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgbWluID0gKHRoaXMudmlldy5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSBtaW47XG4gICAgICAgICAgICBpZiAodGhpcy5kb21BZnRlcilcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUFmdGVyLnN0eWxlLm1pbkhlaWdodCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tQWZ0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5kb21BZnRlci5zdHlsZS5wb3NpdGlvbiA9IHRoaXMuZml4ZWQgPyBcInN0aWNreVwiIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgIH1cbiAgICBzeW5jR3V0dGVycyhkZXRhY2gpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5kb20ubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChkZXRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tQWZ0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5kb21BZnRlci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCAmJiBmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGIuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgYiwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLndpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGxpbmUsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uaW5zZXJ0QmVmb3JlKHRoaXMuZG9tLCBhZnRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5kb21BZnRlcilcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKHRoaXMuZG9tQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUd1dHRlcnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2ID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyksIGN1ciA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhY3RpdmVHdXR0ZXJzKTtcbiAgICAgICAgbGV0IGNoYW5nZSA9IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5oZWlnaHRDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICFSYW5nZVNldC5lcSh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB1cGRhdGUuc3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAocHJldiA9PSBjdXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGd1dHRlciBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlci51cGRhdGUodXBkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZ3V0dGVycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29uZiBvZiBjdXIpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSBwcmV2LmluZGV4T2YoY29uZik7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2gobmV3IFNpbmdsZUd1dHRlclZpZXcodGhpcy52aWV3LCBjb25mKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmd1dHRlcnNba25vd25dLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2godGhpcy5ndXR0ZXJzW2tub3duXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiB0aGlzLmd1dHRlcnMpIHtcbiAgICAgICAgICAgICAgICBnLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3V0dGVycy5pbmRleE9mKGcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgZy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBnIG9mIGd1dHRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZy5jb25maWcuc2lkZSA9PSBcImFmdGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RE9NQWZ0ZXIoKS5hcHBlbmRDaGlsZChnLmRvbSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChnLmRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmd1dHRlcnMgPSBndXR0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBpZiAodGhpcy5kb21BZnRlcilcbiAgICAgICAgICAgIHRoaXMuZG9tQWZ0ZXIucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCAqIHZpZXcuc2NhbGVYLCBhZnRlciA9IHZhbHVlLmRvbUFmdGVyID8gdmFsdWUuZG9tQWZ0ZXIub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCA6IDA7XG4gICAgICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUlxuICAgICAgICAgICAgPyB7IGxlZnQ6IGJlZm9yZSwgcmlnaHQ6IGFmdGVyIH1cbiAgICAgICAgICAgIDogeyByaWdodDogYmVmb3JlLCBsZWZ0OiBhZnRlciB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IHsgZ3V0dGVyIH0gPSB0aGlzLCBhYm92ZSA9IChibG9jay50b3AgLSB0aGlzLmhlaWdodCkgLyB2aWV3LnNjYWxlWSwgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0IC8gdmlldy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayksIG1hcmtlcnMgPSBtYXJrZXIgPyBbbWFya2VyXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB2aWV3LnN0YXRlLmZhY2V0KGd1dHRlcldpZGdldENsYXNzKSkge1xuICAgICAgICAgICAgbGV0IG1hcmtlciA9IGNscyh2aWV3LCBibG9jay53aWRnZXQsIGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICAgICAgKG1hcmtlcnMgfHwgKG1hcmtlcnMgPSBbXSkpLnB1c2gobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VycylcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBibG9jaywgbWFya2Vycyk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICB3aGlsZSAoZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMuaSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBndXR0ZXIuZWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcbiAgICAgICAgICAgIGxhc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlR3V0dGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNvbmZpZy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHByb3AsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQsIHk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXQucGFyZW50Tm9kZSAhPSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KHkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFSYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgIH1cbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYm92ZSAhPSBhYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLmFib3ZlID0gYWJvdmUpID8gYWJvdmUgKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICBpZiAoIXNhbWVNYXJrZXJzKHRoaXMubWFya2VycywgbWFya2VycykpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtlcnModmlldywgbWFya2Vycyk7XG4gICAgfVxuICAgIHNldE1hcmtlcnModmlldywgbWFya2Vycykge1xuICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCIsIGRvbVBvcyA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgc2tpcFRvID0gaU9sZCwgbWFya2VyID0gaU5ldyA8IG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1tpTmV3KytdIDogbnVsbCwgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiICsgYztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXS5jb21wYXJlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUbyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwVG8gPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGlPbGQgPCBza2lwVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubWFya2Vyc1tpT2xkKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGVzdHJveShkb21Qb3MpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIudG9ET00odmlldyksIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICBpT2xkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldE1hcmtlcnMobnVsbCwgW10pOyAvLyBGaXJzdCBhcmd1bWVudCBub3QgdXNlZCB1bmxlc3MgY3JlYXRpbmcgbWFya2Vyc1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXJzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5jb21wYXJlKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5GYWNldCB1c2VkIHRvIHByb3ZpZGUgbWFya2VycyB0byB0aGUgbGluZSBudW1iZXIgZ3V0dGVyLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNyZWF0ZSBtYXJrZXJzIGluIHRoZSBsaW5lIG51bWJlciBndXR0ZXIgbmV4dCB0byB3aWRnZXRzLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIHdpZGdldE1hcmtlcjogKHZpZXcsIHdpZGdldCwgYmxvY2spID0+IHtcbiAgICAgICAgZm9yIChsZXQgbSBvZiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbSh2aWV3LCB3aWRnZXQsIGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IHVwZGF0ZSA9PiB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZyksXG4gICAgaW5pdGlhbFNwYWNlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCBtYXhMaW5lTnVtYmVyKHZpZXcuc3RhdGUuZG9jLmxpbmVzKSkpO1xuICAgIH0sXG4gICAgdXBkYXRlU3BhY2VyKHNwYWNlciwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBtYXggPSBmb3JtYXROdW1iZXIodXBkYXRlLnZpZXcsIG1heExpbmVOdW1iZXIodXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVzKSk7XG4gICAgICAgIHJldHVybiBtYXggPT0gc3BhY2VyLm51bWJlciA/IHNwYWNlciA6IG5ldyBOdW1iZXJNYXJrZXIobWF4KTtcbiAgICB9LFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmRvbUV2ZW50SGFuZGxlcnMsXG4gICAgc2lkZTogXCJiZWZvcmVcIlxufSkpO1xuLyoqXG5DcmVhdGUgYSBsaW5lIG51bWJlciBndXR0ZXIgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIGxpbmVOdW1iZXJzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbGluZU51bWJlckNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBndXR0ZXJzKCksXG4gICAgICAgIGxpbmVOdW1iZXJHdXR0ZXJcbiAgICBdO1xufVxuZnVuY3Rpb24gbWF4TGluZU51bWJlcihsaW5lcykge1xuICAgIGxldCBsYXN0ID0gOTtcbiAgICB3aGlsZSAobGFzdCA8IGxpbmVzKVxuICAgICAgICBsYXN0ID0gbGFzdCAqIDEwICsgOTtcbiAgICByZXR1cm4gbGFzdDtcbn1cbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Q2xhc3MgPSBcImNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjtcbiAgICB9XG59O1xuY29uc3QgYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL2d1dHRlckxpbmVDbGFzcy5jb21wdXRlKFtcInNlbGVjdGlvblwiXSwgc3RhdGUgPT4ge1xuICAgIGxldCBtYXJrcyA9IFtdLCBsYXN0ID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgbGluZVBvcyA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICAgICAgaWYgKGxpbmVQb3MgPiBsYXN0KSB7XG4gICAgICAgICAgICBsYXN0ID0gbGluZVBvcztcbiAgICAgICAgICAgIG1hcmtzLnB1c2goYWN0aXZlTGluZUd1dHRlck1hcmtlci5yYW5nZShsaW5lUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG1hcmtzKTtcbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tYWN0aXZlTGluZUd1dHRlcmAgY2xhc3MgdG9cbmFsbCBndXR0ZXIgZWxlbWVudHMgb24gdGhlIFthY3RpdmVcbmxpbmVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5oaWdobGlnaHRBY3RpdmVMaW5lKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXI7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXIoZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gKHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRlY29yYXRvci5jcmVhdGVEZWNvKHZpZXcpLFxuICAgICAgICB1cGRhdGUodSkge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRvci51cGRhdGVEZWNvKHUsIHRoaXMuZGVjb3JhdGlvbnMpO1xuICAgICAgICB9LFxuICAgIH0pLCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KTtcbn1cbmNvbnN0IHRhYkRlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taGlnaGxpZ2h0VGFiXCIgfSk7XG5jb25zdCBzcGFjZURlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taGlnaGxpZ2h0U3BhY2VcIiB9KTtcbmNvbnN0IHdoaXRlc3BhY2VIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xcdHwgL2csXG4gICAgZGVjb3JhdGlvbjogbWF0Y2ggPT4gbWF0Y2hbMF0gPT0gXCJcXHRcIiA/IHRhYkRlY28gOiBzcGFjZURlY28sXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZ2hsaWdodHMgd2hpdGVzcGFjZSwgYWRkaW5nIGFcbmBjbS1oaWdobGlnaHRTcGFjZWAgY2xhc3MgdG8gc3RyZXRjaGVzIG9mIHNwYWNlcywgYW5kIGFcbmBjbS1oaWdobGlnaHRUYWJgIGNsYXNzIHRvIGluZGl2aWR1YWwgdGFiIGNoYXJhY3RlcnMuIEJ5IGRlZmF1bHQsXG50aGUgZm9ybWVyIGFyZSBzaG93biBhcyBmYWludCBkb3RzLCBhbmQgdGhlIGxhdHRlciBhcyBhcnJvd3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0V2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gd2hpdGVzcGFjZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgdHJhaWxpbmdIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xccyskL2csXG4gICAgZGVjb3JhdGlvbjogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXRyYWlsaW5nU3BhY2VcIiB9KVxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tdHJhaWxpbmdTcGFjZWAgY2xhc3MgdG8gYWxsXG50cmFpbGluZyB3aGl0ZXNwYWNlLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHJhaWxpbmdIaWdobGlnaHRlcjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3Rlc3QgPSB7IEhlaWdodE1hcCwgSGVpZ2h0T3JhY2xlLCBNZWFzdXJlZEhlaWdodHMsIFF1ZXJ5VHlwZSwgQ2hhbmdlZFJhbmdlLCBjb21wdXRlT3JkZXIsXG4gICAgbW92ZVZpc3VhbGx5LCBjbGVhckhlaWdodENoYW5nZUZsYWcsIGdldEhlaWdodENoYW5nZUZsYWc6ICgpID0+IGhlaWdodENoYW5nZUZsYWcgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBCbG9ja1dyYXBwZXIsIERlY29yYXRpb24sIERpcmVjdGlvbiwgRWRpdG9yVmlldywgR3V0dGVyTWFya2VyLCBNYXRjaERlY29yYXRvciwgUmVjdGFuZ2xlTWFya2VyLCBWaWV3UGx1Z2luLCBWaWV3VXBkYXRlLCBXaWRnZXRUeXBlLCBfX3Rlc3QsIGNsb3NlSG92ZXJUb29sdGlwcywgY3Jvc3NoYWlyQ3Vyc29yLCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCBnZXREaWFsb2csIGdldERyYXdTZWxlY3Rpb25Db25maWcsIGdldFBhbmVsLCBnZXRUb29sdGlwLCBndXR0ZXIsIGd1dHRlckxpbmVDbGFzcywgZ3V0dGVyV2lkZ2V0Q2xhc3MsIGd1dHRlcnMsIGhhc0hvdmVyVG9vbHRpcHMsIGhpZ2hsaWdodEFjdGl2ZUxpbmUsIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIsIGhpZ2hsaWdodFNwZWNpYWxDaGFycywgaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlLCBoaWdobGlnaHRXaGl0ZXNwYWNlLCBob3ZlclRvb2x0aXAsIGtleW1hcCwgbGF5ZXIsIGxpbmVOdW1iZXJNYXJrZXJzLCBsaW5lTnVtYmVyV2lkZ2V0TWFya2VyLCBsaW5lTnVtYmVycywgbG9nRXhjZXB0aW9uLCBwYW5lbHMsIHBsYWNlaG9sZGVyLCByZWN0YW5ndWxhclNlbGVjdGlvbiwgcmVwb3NpdGlvblRvb2x0aXBzLCBydW5TY29wZUhhbmRsZXJzLCBzY3JvbGxQYXN0RW5kLCBzaG93RGlhbG9nLCBzaG93UGFuZWwsIHNob3dUb29sdGlwLCB0b29sdGlwcyB9O1xuIl0sIm5hbWVzIjpbIlJhbmdlU2V0IiwiTWFwTW9kZSIsIlJhbmdlVmFsdWUiLCJmaW5kQ2x1c3RlckJyZWFrIiwiRWRpdG9yU2VsZWN0aW9uIiwiRmFjZXQiLCJTdGF0ZUVmZmVjdCIsIkNoYW5nZVNldCIsIlRleHQiLCJmaW5kQ29sdW1uIiwiQ2hhckNhdGVnb3J5IiwiRWRpdG9yU3RhdGUiLCJBbm5vdGF0aW9uIiwiVHJhbnNhY3Rpb24iLCJQcmVjIiwiY29kZVBvaW50QXQiLCJjb2RlUG9pbnRTaXplIiwiY29tYmluZUNvbmZpZyIsIlN0YXRlRmllbGQiLCJSYW5nZVNldEJ1aWxkZXIiLCJjb3VudENvbHVtbiIsIlN0eWxlTW9kdWxlIiwia2V5TmFtZSIsImJhc2UiLCJzaGlmdCIsImVsdCIsIm5hdiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInZlbmRvciIsInBsYXRmb3JtIiwiZG9jIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsImllX2VkZ2UiLCJleGVjIiwiaWVfdXB0bzEwIiwidGVzdCIsImllXzExdXAiLCJpZSIsImdlY2tvIiwiY2hyb21lIiwid2Via2l0Iiwic2FmYXJpIiwiaW9zIiwibWF4VG91Y2hQb2ludHMiLCJicm93c2VyIiwibWFjIiwid2luZG93cyIsImxpbnV4IiwiaWVfdmVyc2lvbiIsImRvY3VtZW50TW9kZSIsImdlY2tvX3ZlcnNpb24iLCJjaHJvbWVfdmVyc2lvbiIsImFuZHJvaWQiLCJ3ZWJraXRfdmVyc2lvbiIsInNhZmFyaV92ZXJzaW9uIiwidGFiU2l6ZSIsImNvbWJpbmVBdHRycyIsInNvdXJjZSIsInRhcmdldCIsIm5hbWUiLCJjbGFzcyIsIm5vQXR0cnMiLCJPYmplY3QiLCJjcmVhdGUiLCJhdHRyc0VxIiwiYSIsImIiLCJpZ25vcmUiLCJrZXlzQSIsImtleXMiLCJrZXlzQiIsImxlbmd0aCIsImluZGV4T2YiLCJrZXkiLCJzZXRBdHRycyIsImRvbSIsImF0dHJzIiwiaSIsImF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJ2YWx1ZSIsImNzc1RleHQiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJ1cGRhdGVBdHRycyIsInByZXYiLCJjaGFuZ2VkIiwiZ2V0QXR0cnMiLCJhdHRyIiwiV2lkZ2V0VHlwZSIsImVxIiwid2lkZ2V0IiwidXBkYXRlRE9NIiwidmlldyIsImNvbXBhcmUiLCJvdGhlciIsImNvbnN0cnVjdG9yIiwiZXN0aW1hdGVkSGVpZ2h0IiwibGluZUJyZWFrcyIsImlnbm9yZUV2ZW50IiwiZXZlbnQiLCJjb29yZHNBdCIsInBvcyIsInNpZGUiLCJpc0hpZGRlbiIsImVkaXRhYmxlIiwiZGVzdHJveSIsIkJsb2NrVHlwZSIsIkRlY29yYXRpb24iLCJzdGFydFNpZGUiLCJlbmRTaWRlIiwic3BlYyIsImhlaWdodFJlbGV2YW50IiwibWFyayIsIk1hcmtEZWNvcmF0aW9uIiwiTWF0aCIsIm1heCIsIm1pbiIsImJsb2NrIiwiaW5saW5lT3JkZXIiLCJQb2ludERlY29yYXRpb24iLCJyZXBsYWNlIiwiaXNCbG9ja0dhcCIsInN0YXJ0IiwiZW5kIiwiZ2V0SW5jbHVzaXZlIiwibGluZSIsIkxpbmVEZWNvcmF0aW9uIiwic2V0Iiwib2YiLCJzb3J0IiwiaGFzSGVpZ2h0Iiwibm9uZSIsImVtcHR5IiwidGFnTmFtZSIsInJhbmdlIiwiZnJvbSIsInRvIiwiUmFuZ2VFcnJvciIsInByb3RvdHlwZSIsInBvaW50IiwibWFwTW9kZSIsIlRyYWNrQmVmb3JlIiwiaXNSZXBsYWNlIiwiVHJhY2tEZWwiLCJUcmFja0FmdGVyIiwidHlwZSIsIldpZGdldFJhbmdlIiwiV2lkZ2V0QmVmb3JlIiwiV2lkZ2V0QWZ0ZXIiLCJ3aWRnZXRzRXEiLCJpbmNsdXNpdmVTdGFydCIsImluY2x1c2l2ZUVuZCIsImluY2x1c2l2ZSIsImFkZFJhbmdlIiwicmFuZ2VzIiwibWFyZ2luIiwibGFzdCIsInB1c2giLCJCbG9ja1dyYXBwZXIiLCJnZXRTZWxlY3Rpb24iLCJyb290Iiwibm9kZVR5cGUiLCJvd25lckRvY3VtZW50IiwiY29udGFpbnMiLCJub2RlIiwicGFyZW50Tm9kZSIsImhhc1NlbGVjdGlvbiIsInNlbGVjdGlvbiIsImFuY2hvck5vZGUiLCJfIiwiY2xpZW50UmVjdHNGb3IiLCJ0ZXh0UmFuZ2UiLCJub2RlVmFsdWUiLCJnZXRDbGllbnRSZWN0cyIsImlzRXF1aXZhbGVudFBvc2l0aW9uIiwib2ZmIiwidGFyZ2V0Tm9kZSIsInRhcmdldE9mZiIsInNjYW5Gb3IiLCJkb21JbmRleCIsImluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwiaXNCbG9ja0VsZW1lbnQiLCJub2RlTmFtZSIsImRpciIsIm1heE9mZnNldCIsInBhcmVudCIsImNoaWxkTm9kZXMiLCJjb250ZW50RWRpdGFibGUiLCJmbGF0dGVuUmVjdCIsInJlY3QiLCJsZWZ0IiwieCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwid2luZG93UmVjdCIsIndpbiIsInZwIiwidmlzdWFsVmlld3BvcnQiLCJ3aWR0aCIsImhlaWdodCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImdldFNjYWxlIiwic2NhbGVYIiwib2Zmc2V0V2lkdGgiLCJzY2FsZVkiLCJvZmZzZXRIZWlnaHQiLCJpc0Zpbml0ZSIsImFicyIsInNjcm9sbFJlY3RJbnRvVmlldyIsInkiLCJ4TWFyZ2luIiwieU1hcmdpbiIsImx0ciIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiY3VyIiwic3RvcCIsImJvdW5kaW5nIiwiYm9keSIsImdldENvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsInNjcm9sbFdpZHRoIiwiY2xpZW50V2lkdGgiLCJhc3NpZ25lZFNsb3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJtb3ZlWCIsIm1vdmVZIiwicmVjdEhlaWdodCIsImJvdW5kaW5nSGVpZ2h0IiwidGFyZ2V0VG9wIiwidGFyZ2V0TGVmdCIsInNjcm9sbEJ5IiwibW92ZWRYIiwibW92ZWRZIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImhvc3QiLCJzY3JvbGxhYmxlUGFyZW50cyIsIkRPTVNlbGVjdGlvblN0YXRlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJkb21TZWwiLCJzZXRSYW5nZSIsInByZXZlbnRTY3JvbGxTdXBwb3J0ZWQiLCJmb2N1c1ByZXZlbnRTY3JvbGwiLCJzZXRBY3RpdmUiLCJmb2N1cyIsInN0YWNrIiwicHJldmVudFNjcm9sbCIsInVuZGVmaW5lZCIsInNjcmF0Y2hSYW5nZSIsImNyZWF0ZVJhbmdlIiwic2V0RW5kIiwic2V0U3RhcnQiLCJkaXNwYXRjaEtleSIsImNvZGUiLCJtb2RzIiwib3B0aW9ucyIsImtleUNvZGUiLCJ3aGljaCIsImNhbmNlbGFibGUiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJtZXRhS2V5IiwiZG93biIsIktleWJvYXJkRXZlbnQiLCJzeW50aGV0aWMiLCJkaXNwYXRjaEV2ZW50IiwidXAiLCJkZWZhdWx0UHJldmVudGVkIiwiZ2V0Um9vdCIsImF0RWxlbWVudFN0YXJ0Iiwib2Zmc2V0IiwiaXNTY3JvbGxlZFRvQm90dG9tIiwidGV4dE5vZGVCZWZvcmUiLCJzdGFydE5vZGUiLCJzdGFydE9mZnNldCIsInRleHROb2RlQWZ0ZXIiLCJET01Qb3MiLCJwcmVjaXNlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJEaXJlY3Rpb24iLCJMVFIiLCJSVEwiLCJkZWMiLCJzdHIiLCJyZXN1bHQiLCJMb3dUeXBlcyIsIkFyYWJpY1R5cGVzIiwiQnJhY2tldHMiLCJCcmFja2V0U3RhY2siLCJwIiwibCIsImNoYXJDb2RlQXQiLCJyIiwiY2hhclR5cGUiLCJjaCIsIkJpZGlSRSIsIkJpZGlTcGFuIiwibGV2ZWwiLCJmb3J3YXJkIiwiZmluZCIsIm9yZGVyIiwiYXNzb2MiLCJtYXliZSIsInNwYW4iLCJpc29sYXRlc0VxIiwiaUEiLCJpQiIsImRpcmVjdGlvbiIsImlubmVyIiwidHlwZXMiLCJjb21wdXRlQ2hhclR5cGVzIiwickZyb20iLCJyVG8iLCJpc29sYXRlcyIsIm91dGVyVHlwZSIsImlJIiwicHJldlR5cGUiLCJwcmV2U3Ryb25nIiwiaiIsInByb2Nlc3NCcmFja2V0UGFpcnMiLCJvcHBvc2l0ZVR5cGUiLCJzSSIsImNvbnRleHQiLCJiciIsInNKIiwiZmxhZ3MiLCJlbWJlZCIsInByb2Nlc3NOZXV0cmFscyIsImJlZm9yZUwiLCJhZnRlckwiLCJqSSIsImZyb21KIiwiZW1pdFNwYW5zIiwiYmFzZUxldmVsIiwib3VyVHlwZSIsImlDaCIsInNhbWVEaXIiLCJpc051bSIsIm5leHQiLCJyZWN1cnNlIiwibG9jYWxMZXZlbCIsImlTY2FuIiwicnVuIiwiaXNvIiwidXB0byIsImRpclN3YXAiLCJjb21wdXRlU2VjdGlvbk9yZGVyIiwiY29tcHV0ZU9yZGVyIiwidHJpdmlhbE9yZGVyIiwibW92ZWRPdmVyIiwibW92ZVZpc3VhbGx5IiwiX2EiLCJzdGFydEluZGV4IiwiaGVhZCIsInNwYW5JIiwiYmlkaUxldmVsIiwic3BhbkVuZCIsIm5leHRJIiwibmV4dEluZGV4IiwidGV4dCIsInNsaWNlIiwibmV4dFNwYW4iLCJjdXJzb3IiLCJhdXRvRGlyZWN0aW9uIiwiY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UiLCJkZWZpbmUiLCJkcmFnTW92ZXNTZWxlY3Rpb24kMSIsIm1vdXNlU2VsZWN0aW9uU3R5bGUiLCJleGNlcHRpb25TaW5rIiwidXBkYXRlTGlzdGVuZXIiLCJpbnB1dEhhbmRsZXIiLCJmb2N1c0NoYW5nZUVmZmVjdCIsImNsaXBib2FyZElucHV0RmlsdGVyIiwiY2xpcGJvYXJkT3V0cHV0RmlsdGVyIiwicGVyTGluZVRleHREaXJlY3Rpb24iLCJjb21iaW5lIiwidmFsdWVzIiwic29tZSIsIm5hdGl2ZVNlbGVjdGlvbkhpZGRlbiIsInNjcm9sbEhhbmRsZXIiLCJTY3JvbGxUYXJnZXQiLCJpc1NuYXBzaG90IiwibWFwIiwiY2hhbmdlcyIsImNsaXAiLCJzdGF0ZSIsInNjcm9sbEludG9WaWV3IiwidCIsInNldEVkaXRDb250ZXh0Rm9ybWF0dGluZyIsImxvZ0V4Y2VwdGlvbiIsImV4Y2VwdGlvbiIsImhhbmRsZXIiLCJmYWNldCIsIm9uZXJyb3IiLCJTdHJpbmciLCJjb25zb2xlIiwiZXJyb3IiLCJuZXh0UGx1Z2luSUQiLCJ2aWV3UGx1Z2luIiwicGx1Z2lucyIsImZpbHRlciIsInBsdWdpbiIsIlZpZXdQbHVnaW4iLCJpZCIsImRvbUV2ZW50SGFuZGxlcnMiLCJkb21FdmVudE9ic2VydmVycyIsImJ1aWxkRXh0ZW5zaW9ucyIsImJhc2VFeHRlbnNpb25zIiwiZXh0ZW5zaW9uIiwiY29uY2F0IiwiYXJnIiwiZXZlbnRIYW5kbGVycyIsImV2ZW50T2JzZXJ2ZXJzIiwicHJvdmlkZSIsImRlY29yYXRpb25zIiwiZGVjbyIsImV4dCIsInBsdWdpbkluc3QiLCJmcm9tQ2xhc3MiLCJjbHMiLCJQbHVnaW5JbnN0YW5jZSIsIm11c3RVcGRhdGUiLCJ1cGRhdGUiLCJlIiwiZGVhY3RpdmF0ZSIsImVkaXRvckF0dHJpYnV0ZXMiLCJjb250ZW50QXR0cmlidXRlcyIsImJsb2NrV3JhcHBlcnMiLCJvdXRlckRlY29yYXRpb25zIiwiYXRvbWljUmFuZ2VzIiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiZ2V0SXNvbGF0ZWRSYW5nZXMiLCJzZXRzIiwiRnVuY3Rpb24iLCJzcGFucyIsImZyb21Eb2MiLCJ0b0RvYyIsImFjdGl2ZSIsIm9wZW4iLCJiaWRpSXNvbGF0ZSIsImFkZCIsInNjcm9sbE1hcmdpbnMiLCJnZXRTY3JvbGxNYXJnaW5zIiwibSIsInN0eWxlTW9kdWxlIiwiQ2hhbmdlZFJhbmdlIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImpvaW4iLCJhZGRUb1NldCIsIm1lIiwic3BsaWNlIiwiZXh0ZW5kV2l0aFJhbmdlcyIsImRpZmYiLCJkSSIsInJJIiwibmV4dEQiLCJuZXh0UiIsIlZpZXdVcGRhdGUiLCJ0cmFuc2FjdGlvbnMiLCJzdGFydFN0YXRlIiwidHIiLCJjb21wb3NlIiwiY2hhbmdlZFJhbmdlcyIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwidmlld3BvcnRDaGFuZ2VkIiwidmlld3BvcnRNb3ZlZCIsImhlaWdodENoYW5nZWQiLCJnZW9tZXRyeUNoYW5nZWQiLCJkb2NDaGFuZ2VkIiwiZm9jdXNDaGFuZ2VkIiwic2VsZWN0aW9uU2V0Iiwibm9DaGlsZHJlbiIsIlRpbGUiLCJjbVRpbGUiLCJicmVha0FmdGVyIiwiY2hpbGRyZW4iLCJpc1dpZGdldCIsImlzQ29tcG9zaXRlIiwiaXNMaW5lIiwiaXNUZXh0IiwiaXNCbG9jayIsImRvbUF0dHJzIiwic3luYyIsInRyYWNrIiwidG9TdHJpbmciLCJzZXRET00iLCJwb3NBdFN0YXJ0IiwicG9zQmVmb3JlIiwicG9zQXRFbmQiLCJ0aWxlIiwiY2hpbGQiLCJwb3NBZnRlciIsImNvdmVycyIsImNvb3Jkc0luIiwiZG9tUG9zRm9yIiwibWFya0RpcnR5Iiwib3ZlcnJpZGVET01UZXh0IiwiRG9jVGlsZSIsImdldCIsIkNvbXBvc2l0ZVRpbGUiLCJfY2hpbGRyZW4iLCJsYXN0Q2hpbGQiLCJhcHBlbmQiLCJ0cmFja2luZyIsIm5leHRTaWJsaW5nIiwiZmlyc3RDaGlsZCIsIndyaXR0ZW4iLCJybSQxIiwiaW5zZXJ0QmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJvd25zIiwibmVhcmVzdCIsImJsb2NrVGlsZXMiLCJmIiwicG9wIiwiQmxvY2tXcmFwcGVyVGlsZSIsInJlc29sdmVCbG9jayIsImJlZm9yZU9mZiIsImFmdGVyT2ZmIiwiRXJyb3IiLCJ3cmFwcGVyIiwiY3JlYXRlRWxlbWVudCIsIkxpbmVUaWxlIiwia2VlcEF0dHJzIiwicmVzb2x2ZUlubGluZSIsImZvckNvb3JkcyIsInNjYW4iLCJvblNhbWVMaW5lIiwiZm91bmQiLCJmYWxsYmFja1JlY3QiLCJkb21JbiIsInNhdyIsInJlY3RzIiwicG9zQSIsInBvc0IiLCJNYXJrVGlsZSIsIlRleHRUaWxlIiwiSlNPTiIsInN0cmluZ2lmeSIsImZsYXR0ZW4iLCJBcnJheSIsImNhbGwiLCJjcmVhdGVUZXh0Tm9kZSIsIldpZGdldFRpbGUiLCJjb29yZHNJbldpZGdldCIsImN1c3RvbSIsImZyb21CYWNrIiwidG9ET00iLCJXaWRnZXRCdWZmZXJUaWxlIiwiaW1nIiwiY2xhc3NOYW1lIiwiVGlsZVBvaW50ZXIiLCJiZWZvcmVCcmVhayIsInBhcmVudHMiLCJhZHZhbmNlIiwiZGlzdCIsIndhbGtlciIsInRha2UiLCJza2lwIiwiYnJlYWsiLCJsZWF2ZSIsImJyayIsImVudGVyIiwiT3BlbldyYXBwZXIiLCJyYW5rIiwiVGlsZUJ1aWxkZXIiLCJjYWNoZSIsImN1ckxpbmUiLCJsYXN0QmxvY2siLCJhZnRlcldpZGdldCIsIndyYXBwZXJzIiwid3JhcHBlclBvcyIsImFkZFRleHQiLCJtYXJrcyIsIm9wZW5TdGFydCIsImZsdXNoQnVmZmVyIiwiZW5zdXJlTWFya3MiLCJyZXVzZWQiLCJhZGRDb21wb3NpdGlvbiIsImNvbXBvc2l0aW9uIiwiaGFzIiwiZnJlZU5vZGUiLCJudyIsIm9sZFRpbGUiLCJhZGRJbmxpbmVXaWRnZXQiLCJub1NwYWNlIiwiZ2V0QnVmZmVyIiwiYWRkTWFyayIsImFkZEJsb2NrV2lkZ2V0IiwiZ2V0QmxvY2tQb3MiLCJlbmRMaW5lIiwiY29udGludWVXaWRnZXQiLCJhZGRMaW5lU3RhcnQiLCJsaW5lQmFzZUF0dHJzIiwiYWRkTGluZSIsImFkZEJyZWFrIiwiYWRkTGluZVN0YXJ0SWZOb3RDb3ZlcmVkIiwiYmxvY2tQb3NDb3ZlcmVkIiwiZW5zdXJlTGluZSIsImhhc0NvbnRlbnQiLCJmaW5kV2lkZ2V0IiwiQnJlYWtXaWRnZXQiLCJ1cGRhdGVCbG9ja1dyYXBwZXJzIiwiZ290byIsIndyYXAiLCJUZXh0U3RyZWFtIiwic2tpcENvdW50IiwidGV4dE9mZiIsIml0ZXIiLCJsZW4iLCJtYXhMZW4iLCJsaW5lQnJlYWsiLCJkb25lIiwiY2hhcnMiLCJidWNrZXRzIiwiYnVja2V0IiwiVGlsZUNhY2hlIiwiTWFwIiwid2lkZ2V0cyIsInBhc3MiLCJyZXVzZSIsIm1heWJlUmV1c2UiLCJjbGVhciIsIlRpbGVVcGRhdGUiLCJvbGQiLCJkaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciIsIm9wZW5XaWRnZXQiLCJvcGVuTWFya3MiLCJidWlsZGVyIiwiY29udGVudERPTSIsInJldXNlV2Fsa2VyIiwiY29tcG9zaXRpb25Db250ZXh0IiwiZ2V0Q29tcG9zaXRpb25Db250ZXh0Iiwic2tpcEEiLCJwcmVzZXJ2ZSIsImVtaXQiLCJpbmNTdGFydCIsImluY0VuZCIsImFjdGl2ZU1hcmtzIiwiZ2V0TWFya3MiLCJ1bnNoaWZ0IiwicGVuZGluZ0xpbmVBdHRycyIsIm1hcmtDb3VudCIsIm9wZW5FbmQiLCJsaW5lQXQiLCJOdWxsV2lkZ2V0IiwiaW5saW5lIiwid2lkZ2V0RmxhZ3MiLCJhZGRMaW5lRGVjbyIsInRvTG93ZXJDYXNlIiwicmVxdWlyZVRleHQiLCJwdHIiLCJjbG9uZU5vZGUiLCJ0YWciLCJEb2NWaWV3IiwiZHluYW1pY0RlY29yYXRpb25NYXAiLCJkb21DaGFuZ2VkIiwiaGFzQ29tcG9zaXRpb24iLCJlZGl0Q29udGV4dEZvcm1hdHRpbmciLCJsYXN0Q29tcG9zaXRpb25BZnRlckN1cnNvciIsIm1pbldpZHRoIiwibWluV2lkdGhGcm9tIiwibWluV2lkdGhUbyIsImltcHJlY2lzZUFuY2hvciIsImltcHJlY2lzZUhlYWQiLCJmb3JjZVNlbGVjdGlvbiIsImxhc3RVcGRhdGUiLCJEYXRlIiwibm93IiwidXBkYXRlRGVjbyIsInVwZGF0ZUlubmVyIiwiZXZlcnkiLCJtYXBQb3MiLCJ1cGRhdGVFZGl0Q29udGV4dEZvcm1hdHRpbmciLCJyZWFkQ29tcG9zaXRpb25BdCIsImlucHV0U3RhdGUiLCJjb21wb3NpbmciLCJvYnNlcnZlciIsImVkaXRDb250ZXh0IiwibmV3U2VsIiwidG91Y2hlc0NvbXBvc2l0aW9uIiwibWFpbiIsImZpbmRDb21wb3NpdGlvblJhbmdlIiwibGluZXMiLCJwcmV2RGVjbyIsInByZXZXcmFwcGVycyIsImRlY29EaWZmIiwiZmluZENoYW5nZWREZWNvIiwiYmxvY2tEaWZmIiwiZmluZENoYW5nZWRXcmFwcGVycyIsInZpZXdTdGF0ZSIsIm11c3RNZWFzdXJlQ29udGVudCIsImRlc3Ryb3lEcm9wcGVkIiwiY29udGVudEhlaWdodCIsImZsZXhCYXNpcyIsInNlbGVjdGlvblJhbmdlIiwiZ2FwcyIsInZpZXdwb3J0IiwiQmxvY2tHYXBXaWRnZXQiLCJ1cGRhdGVHYXBzIiwiZWZmZWN0IiwiZWZmZWN0cyIsImlzIiwidXBkYXRlU2VsZWN0aW9uIiwibXVzdFJlYWQiLCJmcm9tUG9pbnRlciIsInJlYWRTZWxlY3Rpb25SYW5nZSIsImFjdGl2ZUVsdCIsImFjdGl2ZUVsZW1lbnQiLCJmb2N1c2VkIiwic2VsZWN0aW9uTm90Rm9jdXMiLCJ0YWJJbmRleCIsImZvcmNlIiwiYW5jaG9yIiwiaW5saW5lRE9NTmVhclBvcyIsImJldHdlZW5VbmVkaXRhYmxlIiwiZHVtbXkiLCJzdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZSIsImluVW5lZGl0YWJsZSIsImJsdXIiLCJyYXdTZWwiLCJuZXh0VG8iLCJuZXh0VG9VbmVkaXRhYmxlIiwiY29sbGFwc2UiLCJjYXJldEJpZGlMZXZlbCIsImV4dGVuZCIsInJlbW92ZUFsbFJhbmdlcyIsInNldFNlbGVjdGlvblJhbmdlIiwic2VsIiwicG9zRnJvbURPTSIsImVuZm9yY2VDdXJzb3JBc3NvYyIsIm1vZGlmeSIsImxpbmVTdGFydCIsImRvbUF0UG9zIiwibmV3UmFuZ2UiLCJkb2NWaWV3IiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJiaWFzIiwiYmVmb3JlQmFkIiwiYWZ0ZXJCYWQiLCJjb29yZHNGb3JDaGFyIiwibWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyIsImNvbnRlbnRXaWR0aCIsImlzV2lkZXIiLCJzY3JvbGxET00iLCJ3aWRlc3QiLCJ0ZXh0RGlyZWN0aW9uIiwic3BhY2VBYm92ZSIsIm1lYXN1cmVCb3VuZHMiLCJjaGlsZFJlY3QiLCJ0ZXh0RGlyZWN0aW9uQXQiLCJtZWFzdXJlVGV4dFNpemUiLCJsaW5lTWVhc3VyZSIsInRvdGFsV2lkdGgiLCJ0ZXh0SGVpZ2h0IiwibGluZUhlaWdodCIsImNoYXJXaWR0aCIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmUiLCJjb21wdXRlQmxvY2tHYXBEZWNvIiwidnMiLCJ2aWV3cG9ydHMiLCJsaW5lQmxvY2tBdCIsImFsbERlY28iLCJkIiwiZHluYW1pYyIsImR5bmFtaWNPdXRlciIsIm91dGVyRGVjbyIsImxpbmVHYXBEZWNvIiwidiIsInJlZiIsIm1hcmdpbnMiLCJ0YXJnZXRSZWN0IiwibGluZUhhc1dpZGdldCIsImZpbmRDb21wb3NpdGlvbk5vZGUiLCJoZWFkUG9zIiwidGV4dEJlZm9yZSIsInRleHRBZnRlciIsInRleHROb2RlIiwidGlsZUFmdGVyIiwidGlsZUJlZm9yZSIsInNsaWNlU3RyaW5nIiwiaW52IiwiaW52ZXJ0ZWREZXNjIiwiRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSIsIkRlY29yYXRpb25Db21wYXJhdG9yIiwiY29tcGFyZVJhbmdlIiwiY29tcGFyZVBvaW50IiwiYm91bmRDaGFuZ2UiLCJjb21wIiwiV3JhcHBlckNvbXBhcmF0b3IiLCJpbnNpZGUiLCJ0b3VjaGVkIiwiZ3JvdXBBdCIsImNhdGVnb3JpemUiLCJjaGFyQ2F0ZWdvcml6ZXIiLCJsaW5lUG9zIiwiY2F0IiwicG9zQXRDb29yZHNJbXByZWNpc2UiLCJjb250ZW50UmVjdCIsImludG8iLCJyb3VuZCIsImRlZmF1bHRDaGFyYWN0ZXJXaWR0aCIsImxpbmVXcmFwcGluZyIsImRlZmF1bHRMaW5lSGVpZ2h0IiwiaGVpZ2h0T3JhY2xlIiwiZmxvb3IiLCJsaW5lTGVuZ3RoIiwiY29udGVudCIsInNsaWNlRG9jIiwiYmxvY2tBdCIsImlzQXJyYXkiLCJiZXN0IiwibW92ZVRvTGluZUJvdW5kYXJ5IiwiaW5jbHVkZVdyYXAiLCJjb29yZHMiLCJ3aWRnZXRMaW5lQnJlYWtzIiwiY29vcmRzQXRQb3MiLCJlZGl0b3JSZWN0IiwicG9zQXRDb29yZHMiLCJtb3ZlQnlDaGFyIiwiYnkiLCJiaWRpU3BhbnMiLCJjaGVjayIsImNoYXIiLCJudW1iZXIiLCJ2aXN1YWxMaW5lU2lkZSIsImJ5R3JvdXAiLCJuZXh0Q2F0IiwiU3BhY2UiLCJtb3ZlVmVydGljYWxseSIsImRpc3RhbmNlIiwic3RhcnRQb3MiLCJnb2FsIiwiZ29hbENvbHVtbiIsInN0YXJ0WSIsInN0YXJ0Q29vcmRzIiwiZG9jVG9wIiwiZG9jdW1lbnRUb3AiLCJyZXNvbHZlZEdvYWwiLCJza2lwQXRvbWljUmFuZ2VzIiwiYXRvbXMiLCJtb3ZlZCIsImJldHdlZW4iLCJza2lwQXRvbXNGb3JTZWxlY3Rpb24iLCJ1cGRhdGVkIiwibWFpbkluZGV4Iiwic2tpcEF0b21zIiwib2xkUG9zIiwibmV3UG9zIiwiUG9zQXNzb2MiLCJzY2FuWSIsInBhZGRpbmdUb3AiLCJ5T2Zmc2V0IiwiZG9jSGVpZ2h0IiwiZWxlbWVudEF0SGVpZ2h0IiwiaGFsZkxpbmUiLCJwb3NBdENvb3Jkc0lubGluZSIsImNsb3Nlc3QiLCJjbG9zZXN0UmVjdCIsImR4Q2xvc2VzdCIsImR5Q2xvc2VzdCIsInJvd1RvcCIsInJvd0JvdCIsImNoZWNrUmVjdHMiLCJkeCIsImR5IiwiZGlyQXQiLCJpbm5lck9mZiIsIkxpbmVCcmVha1BsYWNlaG9sZGVyIiwiRE9NUmVhZGVyIiwicG9pbnRzIiwibGluZVNlcGFyYXRvciIsInJlYWRSYW5nZSIsImZpbmRQb2ludEJlZm9yZSIsIm9sZExlbiIsInJlYWROb2RlIiwibmV4dFRpbGUiLCJpc0VtcHR5VG9FbmQiLCJyZWFkVGV4dE5vZGUiLCJyZSIsIm5leHRCcmVhayIsImJyZWFrU2l6ZSIsImZyb21WaWV3IiwiZmluZFBvaW50SW5zaWRlIiwiaXNBdEVuZCIsInciLCJvdmVycmlkZSIsIkRPTVBvaW50IiwiRE9NQ2hhbmdlIiwidHlwZU92ZXIiLCJib3VuZHMiLCJpSGVhZCIsImlBbmNob3IiLCJyZWFkT25seSIsImRvbUJvdW5kc0Fyb3VuZCIsInNlbFBvaW50cyIsInNlbGVjdGlvblBvaW50cyIsInJlYWRlciIsInN0YXJ0RE9NIiwiZW5kRE9NIiwic2VsZWN0aW9uRnJvbVBvaW50cyIsIm9mZkZyb20iLCJvZmZUbyIsInJlcGxhY2VSYW5nZSIsInNpbmdsZSIsImZyb21JIiwiZnJvbVN0YXJ0IiwidG9JIiwidG9FbmQiLCJwcmV2RW5kIiwiYXBwbHlET01DaGFuZ2UiLCJkb21DaGFuZ2UiLCJjaGFuZ2UiLCJsYXN0S2V5IiwibGFzdEtleVRpbWUiLCJsYXN0S2V5Q29kZSIsInByZWZlcnJlZFBvcyIsInByZWZlcnJlZFNpZGUiLCJmaW5kRGlmZiIsImluc2VydCIsInNwbGl0IiwiaGFzRm9jdXMiLCJzYW1lU2VsUG9zIiwiaW5zZXJ0aW5nVGV4dEF0IiwidG9UZXh0IiwiaW5zZXJ0aW5nVGV4dCIsImFwcGx5RE9NQ2hhbmdlSW5uZXIiLCJ1c2VyRXZlbnQiLCJsYXN0U2VsZWN0aW9uVGltZSIsImxhc3RTZWxlY3Rpb25PcmlnaW4iLCJkaXNwYXRjaCIsImZsdXNoSU9TS2V5IiwiZGVmYXVsdFRyIiwiZGVmYXVsdEluc2VydCIsImFwcGx5RGVmYXVsdEluc2VydCIsImgiLCJpbkF0b21pYyIsInJlcGxhY2VTZWxlY3Rpb24iLCJtYWluU2VsIiwibmV3TGVuZ3RoIiwiY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlIiwicmVwbGFjZWQiLCJjb21wb3NpdGlvblJhbmdlIiwiZExlbiIsImNoYW5nZUJ5UmFuZ2UiLCJyYW5nZUNoYW5nZXMiLCJzZWxPZmYiLCJjb21wb3NpdGlvbkVuZGVkQXQiLCJjb21wb3NpdGlvbkZpcnN0Q2hhbmdlIiwibWluTGVuIiwiYWRqdXN0IiwibW92ZSIsIklucHV0U3RhdGUiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJvcmlnaW4iLCJsYXN0VG91Y2hUaW1lIiwibGFzdEZvY3VzVGltZSIsImxhc3RTY3JvbGxUb3AiLCJsYXN0U2Nyb2xsTGVmdCIsInBlbmRpbmdJT1NLZXkiLCJ0YWJGb2N1c01vZGUiLCJsYXN0Q29udGV4dE1lbnUiLCJzY3JvbGxIYW5kbGVycyIsImhhbmRsZXJzIiwiY29tcG9zaXRpb25QZW5kaW5nS2V5IiwibW91c2VTZWxlY3Rpb24iLCJkcmFnZ2VkQ29udGVudCIsImhhbmRsZUV2ZW50IiwiYmluZCIsIm5vdGlmaWVkRm9jdXNlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmaXJlZm94Q29weUN1dEhhY2siLCJldmVudEJlbG9uZ3NUb0VkaXRvciIsImlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uIiwia2V5ZG93biIsInVwZGF0ZVN0YXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicnVuSGFuZGxlcnMiLCJvYnNlcnZlcnMiLCJwcmV2ZW50RGVmYXVsdCIsImVuc3VyZUhhbmRsZXJzIiwiY29tcHV0ZUhhbmRsZXJzIiwicGFzc2l2ZSIsImV4aXN0cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtb2RpZmllckNvZGVzIiwiZGVsYXlBbmRyb2lkS2V5IiwicGVuZGluZyIsIlBlbmRpbmdLZXlzIiwiRW1hY3N5UGVuZGluZ0tleXMiLCJzZXRUaW1lb3V0IiwiZm9yY2VGbHVzaCIsInN0YXJ0TW91c2VTZWxlY3Rpb24iLCJiaW5kSGFuZGxlciIsInJlY29yZCIsImlucHV0VHlwZSIsImRyYWdTY3JvbGxNYXJnaW4iLCJkcmFnU2Nyb2xsU3BlZWQiLCJjbGllbnRYIiwiY2xpZW50WSIsIk1vdXNlU2VsZWN0aW9uIiwic3RhcnRFdmVudCIsIm11c3RTZWxlY3QiLCJzY3JvbGxTcGVlZCIsInNjcm9sbGluZyIsImxhc3RFdmVudCIsInNjcm9sbFBhcmVudHMiLCJtdWx0aXBsZSIsImFsbG93TXVsdGlwbGVTZWxlY3Rpb25zIiwiYWRkc1NlbGVjdGlvblJhbmdlIiwiZHJhZ2dpbmciLCJpc0luUHJpbWFyeVNlbGVjdGlvbiIsImdldENsaWNrVHlwZSIsInNlbGVjdCIsImJ1dHRvbnMiLCJzeCIsInN5Iiwic2V0U2Nyb2xsU3BlZWQiLCJzZXRJbnRlcnZhbCIsInNjcm9sbCIsImNsZWFySW50ZXJ2YWwiLCJpc1VzZXJFdmVudCIsImRyYWdNb3Zlc1NlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiYnViYmxlcyIsImJyb2tlbkNsaXBib2FyZEFQSSIsImNhcHR1cmVQYXN0ZSIsImRvUGFzdGUiLCJ0ZXh0RmlsdGVyIiwiaW5wdXQiLCJieUxpbmUiLCJsaW5ld2lzZSIsImxhc3RMaW5ld2lzZUNvcHkiLCJsYXN0TGluZSIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJtb3VzZWRvd24iLCJmbHVzaCIsIm1ha2VTdHlsZSIsImJ1dHRvbiIsImJhc2ljTW91c2VTZWxlY3Rpb24iLCJtdXN0Rm9jdXMiLCJtb3VzZVNlbCIsInJhbmdlRm9yQ2xpY2siLCJ2aXN1YWwiLCJCYWRNb3VzZURldGFpbCIsImxhc3RNb3VzZURvd24iLCJsYXN0TW91c2VEb3duQ291bnQiLCJsYXN0TW91c2VEb3duVGltZSIsImRldGFpbCIsImxhc3RUaW1lIiwicG9zQW5kU2lkZUF0Q29vcmRzIiwic3RhcnRTZWwiLCJyZW1vdmVkIiwic3RhcnRSYW5nZSIsInJlbW92ZVJhbmdlQXJvdW5kIiwiZHJhZ3N0YXJ0IiwiZHJhZ2dhYmxlIiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsImVmZmVjdEFsbG93ZWQiLCJkcmFnZW5kIiwiZHJvcFRleHQiLCJkaXJlY3QiLCJkcm9wUG9zIiwiZGVsIiwiaW5zIiwiZHJvcCIsImZpbGVzIiwicmVhZCIsImZpbmlzaEZpbGUiLCJzIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlYWRBc1RleHQiLCJnZXREYXRhIiwicGFzdGUiLCJkYXRhIiwiY2xpcGJvYXJkRGF0YSIsImNhcHR1cmVDb3B5Iiwic2VsZWN0aW9uRW5kIiwic2VsZWN0aW9uU3RhcnQiLCJjb3BpZWRSYW5nZSIsImNvcHkiLCJjdXQiLCJjbGVhckRhdGEiLCJpc0ZvY3VzQ2hhbmdlIiwiZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbiIsImdldEVmZmVjdCIsImFubm90YXRpb25zIiwidXBkYXRlRm9yRm9jdXNDaGFuZ2UiLCJjbGVhclNlbGVjdGlvblJhbmdlIiwiY29tcG9zaXRpb25zdGFydCIsImNvbXBvc2l0aW9udXBkYXRlIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsImZsdXNoU29vbiIsImNvbnRleHRtZW51IiwiYmVmb3JlaW5wdXQiLCJfYiIsImdldFRhcmdldFJhbmdlcyIsInBvc0F0RE9NIiwic3RhcnRDb250YWluZXIiLCJlbmRDb250YWluZXIiLCJlbmRPZmZzZXQiLCJzdGFydFZpZXdIZWlnaHQiLCJhcHBsaWVkRmlyZWZveEhhY2siLCJTZXQiLCJ3cmFwcGluZ1doaXRlU3BhY2UiLCJoZWlnaHRDaGFuZ2VGbGFnIiwiY2xlYXJIZWlnaHRDaGFuZ2VGbGFnIiwiSGVpZ2h0T3JhY2xlIiwiaGVpZ2h0U2FtcGxlcyIsImhlaWdodEZvckdhcCIsImNlaWwiLCJoZWlnaHRGb3JMaW5lIiwic2V0RG9jIiwibXVzdFJlZnJlc2hGb3JXcmFwcGluZyIsIndoaXRlU3BhY2UiLCJtdXN0UmVmcmVzaEZvckhlaWdodHMiLCJsaW5lSGVpZ2h0cyIsIm5ld0hlaWdodCIsInJlZnJlc2giLCJrbm93bkhlaWdodHMiLCJNZWFzdXJlZEhlaWdodHMiLCJoZWlnaHRzIiwibW9yZSIsIkJsb2NrSW5mbyIsIl9jb250ZW50IiwiUXVlcnlUeXBlIiwiRXBzaWxvbiIsIkhlaWdodE1hcCIsIm91dGRhdGVkIiwic2V0SGVpZ2h0IiwiX2Zyb20iLCJfdG8iLCJub2RlcyIsImRlY29tcG9zZUxlZnQiLCJkZWNvbXBvc2VSaWdodCIsImFwcGx5Q2hhbmdlcyIsIm9sZERvYyIsIm9yYWNsZSIsIkJ5UG9zTm9IZWlnaHQiLCJOb2RlQnVpbGRlciIsImJ1aWxkIiwidXBkYXRlSGVpZ2h0IiwiSGVpZ2h0TWFwVGV4dCIsInNpemUiLCJIZWlnaHRNYXBCcmFuY2giLCJ2YWwiLCJTcGFjZURlY28iLCJIZWlnaHRNYXBCbG9jayIsIm1haW5CbG9jayIsIl9vcmFjbGUiLCJfdmFsdWUiLCJfdHlwZSIsImZvckVhY2hMaW5lIiwiQnlQb3MiLCJzZXRNZWFzdXJlZEhlaWdodCIsIm1lYXN1cmVkIiwiX2ZvcmNlIiwiYWJvdmUiLCJjb2xsYXBzZWQiLCJ3aWRnZXRIZWlnaHQiLCJicmVha3MiLCJIZWlnaHRNYXBHYXAiLCJoZWlnaHRNZXRyaWNzIiwiZmlyc3RMaW5lIiwicGVyTGluZSIsInBlckNoYXIiLCJ0b3RhbFBlckxpbmUiLCJndWVzcyIsImxpbmVUb3AiLCJCeUhlaWdodCIsImxpbmVzQWJvdmUiLCJmaXJzdCIsInNpbmdsZUhlaWdodCIsIm1pZCIsInJpZ2h0VG9wIiwicmlnaHRPZmZzZXQiLCJzdWJRdWVyeSIsInJpZ2h0U3RhcnQiLCJiYWxhbmNlZCIsIm1lcmdlR2FwcyIsInJlYmFsYW5jZSIsImFyb3VuZCIsInJlbGV2YW50V2lkZ2V0SGVpZ2h0IiwibGluZUVuZCIsImNvdmVyaW5nIiwid3JpdHRlblRvIiwiaXNDb3ZlcmVkIiwiYWRkQmxvY2siLCJlbnRlckxpbmUiLCJibGFua0NvbnRlbnQiLCJnYXAiLCJmaW5pc2giLCJoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzIiwidmlzaWJsZVBpeGVsUmFuZ2UiLCJvdmVyZmxvdyIsInBhcmVudFJlY3QiLCJvZmZzZXRQYXJlbnQiLCJpbldpbmRvdyIsImZ1bGxQaXhlbFJhbmdlIiwiTGluZUdhcCIsImRpc3BsYXlTaXplIiwic2FtZSIsImdBIiwiZ0IiLCJkcmF3Iiwid3JhcHBpbmciLCJMaW5lR2FwV2lkZ2V0IiwidmVydGljYWwiLCJkaXNwbGF5IiwiVmlld1N0YXRlIiwicGl4ZWxWaWV3cG9ydCIsImluVmlldyIsInBhZGRpbmdCb3R0b20iLCJjb250ZW50RE9NV2lkdGgiLCJjb250ZW50RE9NSGVpZ2h0IiwiZWRpdG9ySGVpZ2h0IiwiZWRpdG9yV2lkdGgiLCJzY3JvbGxlZFRvQm90dG9tIiwic2Nyb2xsQW5jaG9yUG9zIiwic2Nyb2xsQW5jaG9ySGVpZ2h0Iiwic2NhbGVyIiwiSWRTY2FsZXIiLCJzY3JvbGxUYXJnZXQiLCJwcmludGluZyIsImRlZmF1bHRUZXh0RGlyZWN0aW9uIiwidmlzaWJsZVJhbmdlcyIsIm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MiLCJndWVzc1dyYXBwaW5nIiwic3RhdGVEZWNvIiwic3RhdGljRGVjbyIsImhlaWdodE1hcCIsImdldFZpZXdwb3J0IiwidXBkYXRlRm9yVmlld3BvcnQiLCJ1cGRhdGVWaWV3cG9ydExpbmVzIiwibGluZUdhcHMiLCJlbnN1cmVMaW5lR2FwcyIsImNvbXB1dGVWaXNpYmxlUmFuZ2VzIiwiVmlld3BvcnQiLCJ1cGRhdGVTY2FsZXIiLCJCaWdTY2FsZXIiLCJ2aWV3cG9ydExpbmVzIiwic2NhbGVCbG9jayIsImNvbnRlbnRDaGFuZ2VzIiwiaGVpZ2h0Q2hhbmdlcyIsInByZXZIZWlnaHQiLCJzY3JvbGxBbmNob3IiLCJzY3JvbGxBbmNob3JBdCIsIm1hcFZpZXdwb3J0Iiwidmlld3BvcnRJc0FwcHJvcHJpYXRlIiwidmlld3BvcnRDaGFuZ2UiLCJ1cGRhdGVMaW5lR2FwcyIsIm1hcExpbmVHYXBzIiwibWVhc3VyZSIsImRvbVJlY3QiLCJtZWFzdXJlQ29udGVudCIsInBhcnNlSW50IiwiZFRvcCIsImRCb3R0b20iLCJ2aXNpYmxlVG9wIiwiZnJvbURPTSIsInZpc2libGVCb3R0b20iLCJtYXJnaW5Ub3AiLCJ2aWV3SGVpZ2h0IiwidG9wUG9zIiwibWFwcGVkIiwidG91Y2hlc1JhbmdlIiwiY3VycmVudCIsIm1heU1lYXN1cmUiLCJoYWxmTWFyZ2luIiwiZG91YmxlTWFyZ2luIiwiYWRkR2FwIiwic3RydWN0dXJlIiwiYXZvaWQiLCJnYXBTaXplIiwiY2hlY2tMaW5lIiwibGluZVN0cnVjdHVyZSIsInRvdGFsIiwidmlld0Zyb20iLCJ2aWV3VG8iLCJtYXJnaW5IZWlnaHQiLCJib3QiLCJ0YXJnZXRGcmFjIiwiZmluZEZyYWN0aW9uIiwic3BhY2VGcmFjIiwiZmluZFBvc2l0aW9uIiwibWFyZ2luV2lkdGgiLCJob3Jpek9mZnNldCIsInB4TGVmdCIsInB4UmlnaHQiLCJmb3JFYWNoIiwiZnJhY3Rpb24iLCJsaW5lQmxvY2tBdEhlaWdodCIsInJhdGlvIiwiY291bnRlZCIsImFycmF5IiwibiIsInNjYWxlIiwib3V0ZXIiLCJ2cEhlaWdodCIsImRvbUJhc2UiLCJkb21Ub3AiLCJkb21Cb3R0b20iLCJvYmoiLCJiVG9wIiwiYkJvdHRvbSIsInRoZW1lIiwic3RycyIsImRhcmtUaGVtZSIsImJhc2VUaGVtZUlEIiwibmV3TmFtZSIsImJhc2VMaWdodElEIiwiYmFzZURhcmtJRCIsImxpZ2h0RGFya0lEcyIsImJ1aWxkVGhlbWUiLCJzY29wZXMiLCJiYXNlVGhlbWUkMSIsImJveFNpemluZyIsIm91dGxpbmUiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImZvbnRGYW1pbHkiLCJvdmVyZmxvd1giLCJ6SW5kZXgiLCJvdmVyZmxvd0FuY2hvciIsImZsZXhHcm93IiwiZmxleFNocmluayIsIndvcmRXcmFwIiwibWluSGVpZ2h0IiwicGFkZGluZyIsIldlYmtpdFVzZXJNb2RpZnkiLCJ3aGl0ZVNwYWNlX2ZhbGxiYWNrIiwid29yZEJyZWFrIiwib3ZlcmZsb3dXcmFwIiwiY2FyZXRDb2xvciIsImNvbnRhaW4iLCJiYWNrZ3JvdW5kIiwicG9pbnRlckV2ZW50cyIsImFuaW1hdGlvbiIsIm9wYWNpdHkiLCJib3JkZXJMZWZ0IiwibWFyZ2luTGVmdCIsImJvcmRlckxlZnRDb2xvciIsInVuaWNvZGVCaWRpIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJpbnNldElubGluZVN0YXJ0IiwiaW5zZXRJbmxpbmVFbmQiLCJib3JkZXIiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwidGV4dEFsaWduIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyVG9wIiwiZm9udFNpemUiLCJmb250IiwidmVydGljYWxBbGlnbiIsInVzZXJTZWxlY3QiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRSZXBlYXQiLCJib3JkZXJSYWRpdXMiLCJvYnNlcnZlT3B0aW9ucyIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwidXNlQ2hhckRhdGEiLCJET01PYnNlcnZlciIsInNlbGVjdGlvbkNoYW5nZWQiLCJkZWxheWVkRmx1c2giLCJyZXNpemVUaW1lb3V0IiwicXVldWUiLCJkZWxheWVkQW5kcm9pZEtleSIsImZsdXNoaW5nQW5kcm9pZEtleSIsImxhc3RDaGFuZ2UiLCJzY3JvbGxUYXJnZXRzIiwiaW50ZXJzZWN0aW9uIiwicmVzaXplU2Nyb2xsIiwiaW50ZXJzZWN0aW5nIiwiZ2FwSW50ZXJzZWN0aW9uIiwicHJpbnRRdWVyeSIsInBhcmVudENoZWNrIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsIm11dCIsInJlbW92ZWROb2RlcyIsIm9sZFZhbHVlIiwiRWRpdENvbnRleHQiLCJFRElUX0NPTlRFWFQiLCJFZGl0Q29udGV4dE1hbmFnZXIiLCJvbkNoYXJEYXRhIiwicHJldlZhbHVlIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJvblJlc2l6ZSIsIm9uUHJpbnQiLCJvblNjcm9sbCIsIm1hdGNoTWVkaWEiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJhZGRXaW5kb3dMaXN0ZW5lcnMiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJsaXN0ZW5Gb3JTY3JvbGwiLCJpbnRlcnNlY3Rpb25SYXRpbyIsIm9uU2Nyb2xsQ2hhbmdlZCIsImNyZWF0ZUV2ZW50IiwidGhyZXNob2xkIiwicmVxdWVzdE1lYXN1cmUiLCJtZWFzdXJlUmVxIiwibWF0Y2hlcyIsImciLCJkaXNjb25uZWN0Iiwid2FzQ2hhbmdlZCIsInNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayIsImxvY2FsIiwicHJvY2Vzc1JlY29yZHMiLCJjbGVhckRlbGF5ZWRBbmRyb2lkS2V5IiwiZmx1c2hlZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidGFrZVJlY29yZHMiLCJyZWNvcmRzIiwicmVhZE11dGF0aW9uIiwicmVhZENoYW5nZSIsInJlYWRTZWxlY3Rpb24iLCJoYW5kbGVkIiwicmVjIiwiY2hpbGRCZWZvcmUiLCJmaW5kQ2hpbGQiLCJjaGlsZEFmdGVyIiwic2V0V2luZG93IiwicmVtb3ZlV2luZG93TGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIl9jIiwiY2xlYXJUaW1lb3V0IiwiY3VyVGlsZSIsImJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UiLCJjdXJBbmNob3IiLCJnZXRDb21wb3NlZFJhbmdlcyIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImV4ZWNDb21tYW5kIiwicGVuZGluZ0NvbnRleHRDaGFuZ2UiLCJyZXNldFJhbmdlIiwidG9Db250ZXh0UG9zIiwidGV4dHVwZGF0ZSIsInRvRWRpdG9yUG9zIiwidXBkYXRlUmFuZ2VTdGFydCIsInVwZGF0ZVJhbmdlRW5kIiwiY29udGV4dEJhc2UiLCJlZGl0b3JCYXNlIiwiZHJpZnRlZCIsImRlbGV0ZXMiLCJuZXdMZW4iLCJyZXZlcnRQZW5kaW5nIiwic2V0U2VsZWN0aW9uIiwiY2hhcmFjdGVyYm91bmRzdXBkYXRlIiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwiRE9NUmVjdCIsInVwZGF0ZUNoYXJhY3RlckJvdW5kcyIsInRleHRmb3JtYXR1cGRhdGUiLCJmb3JtYXQiLCJnZXRUZXh0Rm9ybWF0cyIsImxpbmVTdHlsZSIsInVuZGVybGluZVN0eWxlIiwidGhpY2tuZXNzIiwidW5kZXJsaW5lVGhpY2tuZXNzIiwicmVzZXQiLCJ1cGRhdGVDb250cm9sQm91bmRzIiwidXBkYXRlU2VsZWN0aW9uQm91bmRzIiwiYXBwbHlFZGl0cyIsImFib3J0IiwiaXRlckNoYW5nZXMiLCJfZnJvbUIiLCJfdG9CIiwidXBkYXRlVGV4dCIsInJldmVydGVkIiwicmFuZ2VJc1ZhbGlkIiwiY29udGV4dFBvcyIsImNsaXBMZW4iLCJjIiwiZWRpdG9yUG9zIiwiRWRpdG9yVmlldyIsImNvbXBvc2l0aW9uU3RhcnRlZCIsIl9yb290IiwiY29uZmlnIiwicGx1Z2luTWFwIiwiZWRpdG9yQXR0cnMiLCJjb250ZW50QXR0cnMiLCJiaWRpQ2FjaGUiLCJkZXN0cm95ZWQiLCJtZWFzdXJlU2NoZWR1bGVkIiwibWVhc3VyZVJlcXVlc3RzIiwiYW5ub3VuY2VET00iLCJkaXNwYXRjaFRyYW5zYWN0aW9ucyIsInRycyIsInNjcm9sbFRvIiwibW91bnRTdHlsZXMiLCJmb250cyIsInJlYWR5IiwicmVkcmF3biIsImF0dHJzQ2hhbmdlZCIsImZvY3VzRmxhZyIsImRpc3BhdGNoRm9jdXMiLCJhbm5vdGF0aW9uIiwicGVuZGluZ0tleSIsInBocmFzZXMiLCJzZXRTdGF0ZSIsIkNhY2hlZE9yZGVyIiwidXBkYXRlUGx1Z2lucyIsInN0eWxlTW9kdWxlcyIsInNob3dBbm5vdW5jZW1lbnRzIiwiZG9jVmlld1VwZGF0ZSIsImxpc3RlbmVyIiwibmV3U3RhdGUiLCJoYWRGb2N1cyIsInByZXZTcGVjcyIsInNwZWNzIiwibmV3UGx1Z2lucyIsInNET00iLCJ3YXJuIiwibWVhc3VyaW5nIiwiQmFkTWVhc3VyZSIsIndyaXRlIiwibmV3QW5jaG9ySGVpZ2h0IiwidGhlbWVDbGFzc2VzIiwiYXR0cnNGcm9tRmFjZXQiLCJzcGVsbGNoZWNrIiwiYXV0b2NvcnJlY3QiLCJhdXRvY2FwaXRhbGl6ZSIsIndyaXRpbmdzdWdnZXN0aW9ucyIsInRyYW5zbGF0ZSIsImNvbnRlbnRlZGl0YWJsZSIsInJvbGUiLCJjaGFuZ2VkQ29udGVudCIsImNoYW5nZWRFZGl0b3IiLCJhbm5vdW5jZSIsImRpdiIsIm5vbmNlIiwiY3NwTm9uY2UiLCJtb3VudCIsInJldmVyc2UiLCJyZWFkTWVhc3VyZWQiLCJyZXF1ZXN0Iiwia25vd24iLCJkb2N1bWVudFBhZGRpbmciLCJ2aWV3cG9ydExpbmVCbG9ja3MiLCJtb3ZlQnlHcm91cCIsImluaXRpYWwiLCJNYXhCaWRpTGluZSIsImVudHJ5IiwiZnJlc2giLCJzZXRSb290Iiwic2Nyb2xsU25hcHNob3QiLCJzZXRUYWJGb2N1c01vZGUiLCJwcmVmaXgiLCJkYXJrIiwiYmFzZVRoZW1lIiwibG93ZXN0IiwiZmluZEZyb21ET00iLCJxdWVyeVNlbGVjdG9yIiwibGFzdERpciIsInNvdXJjZXMiLCJjdXJyZW50UGxhdGZvcm0iLCJub3JtYWxpemVLZXlOYW1lIiwicGFydHMiLCJhbHQiLCJjdHJsIiwibWV0YSIsIm1vZCIsIm1vZGlmaWVycyIsImhhbmRsZUtleUV2ZW50cyIsImRlZmF1bHQiLCJnZXRLZXltYXAiLCJrZXltYXAiLCJlbmFibGVzIiwiS2V5bWFwcyIsIldlYWtNYXAiLCJiaW5kaW5ncyIsImJ1aWxkS2V5bWFwIiwicmVkdWNlIiwicnVuU2NvcGVIYW5kbGVycyIsInNjb3BlIiwic3RvcmVkUHJlZml4IiwiUHJlZml4VGltZW91dCIsImJvdW5kIiwiaXNQcmVmaXgiLCJjaGVja1ByZWZpeCIsImNvbW1hbmQiLCJzdG9wUHJvcGFnYXRpb24iLCJzY29wZU9iaiIsImsiLCJvdXJPYmoiLCJmdWxsIiwiYmluZGluZyIsIl9hbnkiLCJhbnkiLCJjdXJyZW50S2V5RXZlbnQiLCJjaGFyQ29kZSIsImlzQ2hhciIsInByZXZlbnRlZCIsInJhbiIsInJ1bkZvciIsImNtZCIsImJhc2VOYW1lIiwic2hpZnROYW1lIiwiUmVjdGFuZ2xlTWFya2VyIiwiZm9yUmFuZ2UiLCJnZXRCYXNlIiwicmVjdGFuZ2xlc0ZvclJhbmdlIiwid3JhcHBlZExpbmUiLCJsaW5lRWx0IiwibGVmdFNpZGUiLCJwYWRkaW5nTGVmdCIsInRleHRJbmRlbnQiLCJyaWdodFNpZGUiLCJwYWRkaW5nUmlnaHQiLCJzdGFydEJsb2NrIiwiZW5kQmxvY2siLCJ2aXN1YWxTdGFydCIsInZpc3VhbEVuZCIsInBpZWNlcyIsImRyYXdGb3JMaW5lIiwiZHJhd0ZvcldpZGdldCIsInBpZWNlIiwiaG9yaXpvbnRhbCIsImFkZFNwYW4iLCJmcm9tT3BlbiIsInRvT3BlbiIsImZyb21Db29yZHMiLCJ0b0Nvb3JkcyIsImVuZFBvcyIsImRvY0xpbmUiLCJzcGFuRnJvbSIsInNwYW5UbyIsInNhbWVNYXJrZXIiLCJMYXllclZpZXciLCJsYXllciIsImRyYXduIiwiY2xhc3NMaXN0Iiwic2V0T3JkZXIiLCJsYXllck9yZGVyIiwidXBkYXRlT25Eb2NWaWV3VXBkYXRlIiwibWFya2VycyIsInRyYW5zZm9ybSIsIm9sZEkiLCJtYXJrZXIiLCJzZWxlY3Rpb25Db25maWciLCJjb25maWdzIiwiY3Vyc29yQmxpbmtSYXRlIiwiZHJhd1JhbmdlQ3Vyc29yIiwiZHJhd1NlbGVjdGlvbiIsImN1cnNvckxheWVyIiwic2VsZWN0aW9uTGF5ZXIiLCJoaWRlTmF0aXZlU2VsZWN0aW9uIiwiZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZyIsImNvbmZpZ0NoYW5nZWQiLCJjb25mIiwiY3Vyc29ycyIsInByaW0iLCJhbmltYXRpb25OYW1lIiwiY29uZkNoYW5nZSIsInNldEJsaW5rUmF0ZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwiaGlnaGVzdCIsInNldERyb3BDdXJzb3JQb3MiLCJtYXBwaW5nIiwiZHJvcEN1cnNvclBvcyIsImRyYXdEcm9wQ3Vyc29yIiwicmVhZFBvcyIsImRyYXdDdXJzb3IiLCJjdXJzb3JQb3MiLCJmaWVsZCIsInNldERyb3BQb3MiLCJkcmFnb3ZlciIsImRyYWdsZWF2ZSIsInJlbGF0ZWRUYXJnZXQiLCJkcm9wQ3Vyc29yIiwiaXRlck1hdGNoZXMiLCJsYXN0SW5kZXgiLCJpdGVyUmFuZ2UiLCJtYXRjaFJhbmdlcyIsIm1heExlbmd0aCIsInZpc2libGUiLCJNYXRjaERlY29yYXRvciIsInJlZ2V4cCIsImRlY29yYXRpb24iLCJkZWNvcmF0ZSIsImJvdW5kYXJ5IiwiZ2xvYmFsIiwiYWRkTWF0Y2giLCJtYXRjaCIsIl92aWV3IiwiY3JlYXRlRGVjbyIsImNoYW5nZUZyb20iLCJjaGFuZ2VUbyIsIl9mIiwiX3QiLCJ1cGRhdGVSYW5nZSIsInVwZGF0ZUZyb20iLCJ1cGRhdGVUbyIsImZyb21MaW5lIiwidG9MaW5lIiwiZmlsdGVyRnJvbSIsImZpbHRlclRvIiwiVW5pY29kZVJlZ2V4cFN1cHBvcnQiLCJ1bmljb2RlIiwiU3BlY2lhbHMiLCJSZWdFeHAiLCJOYW1lcyIsIl9zdXBwb3J0c1RhYlNpemUiLCJzdXBwb3J0c1RhYlNpemUiLCJzdHlsZXMiLCJNb3pUYWJTaXplIiwic3BlY2lhbENoYXJDb25maWciLCJyZW5kZXIiLCJzcGVjaWFsQ2hhcnMiLCJhZGRTcGVjaWFsQ2hhcnMiLCJyZXBsYWNlVGFicyIsImhpZ2hsaWdodFNwZWNpYWxDaGFycyIsInNwZWNpYWxDaGFyUGx1Z2luIiwiX3BsdWdpbiIsImRlY29yYXRpb25DYWNoZSIsImRlY29yYXRvciIsIm1ha2VEZWNvcmF0b3IiLCJjb2wiLCJUYWJXaWRnZXQiLCJTcGVjaWFsQ2hhcldpZGdldCIsIkRlZmF1bHRQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyJDEiLCJmcm9tQ2hhckNvZGUiLCJwaCIsImRlc2MiLCJwaHJhc2UiLCJ0aXRsZSIsInNjcm9sbFBhc3RFbmQiLCJoaWdobGlnaHRBY3RpdmVMaW5lIiwiYWN0aXZlTGluZUhpZ2hsaWdodGVyIiwibGluZURlY28iLCJnZXREZWNvIiwibGFzdExpbmVTdGFydCIsIlBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXIiLCJNYXhPZmYiLCJyZWN0YW5nbGVGb3IiLCJzdGFydExpbmUiLCJzdGFydE9mZiIsImVuZE9mZiIsInN0YXJ0Q29sIiwiZW5kQ29sIiwiYWJzb2x1dGVDb2x1bW4iLCJnZXRQb3MiLCJyZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSIsIm5ld1N0YXJ0IiwibmV3TGluZSIsIl9leHRlbmQiLCJyZWN0YW5ndWxhclNlbGVjdGlvbiIsImV2ZW50RmlsdGVyIiwiQWx0IiwiQ29udHJvbCIsIlNoaWZ0IiwiTWV0YSIsInNob3dDcm9zc2hhaXIiLCJjcm9zc2hhaXJDdXJzb3IiLCJnZXR0ZXIiLCJpc0Rvd24iLCJrZXl1cCIsIm1vdXNlbW92ZSIsIk91dHNpZGUiLCJUb29sdGlwVmlld01hbmFnZXIiLCJjcmVhdGVUb29sdGlwVmlldyIsInJlbW92ZVRvb2x0aXBWaWV3IiwidG9vbHRpcHMiLCJ0b29sdGlwVmlld3MiLCJuZXdBYm92ZSIsInRpcCIsInRvb2x0aXBWaWV3IiwidG9vbHRpcENvbmZpZyIsIndpbmRvd1NwYWNlIiwiZG9jRWx0IiwidG9vbHRpcFNwYWNlIiwia25vd25IZWlnaHQiLCJ0b29sdGlwUGx1Z2luIiwibWFkZUFic29sdXRlIiwibGFzdFRyYW5zYWN0aW9uIiwibWVhc3VyZVRpbWVvdXQiLCJjbGFzc2VzIiwiY3JlYXRlQ29udGFpbmVyIiwicmVhZE1lYXN1cmUiLCJ3cml0ZU1lYXN1cmUiLCJyZXNpemVPYnNlcnZlciIsIm1lYXN1cmVTb29uIiwibWFuYWdlciIsInNob3dUb29sdGlwIiwiY3JlYXRlVG9vbHRpcCIsInVub2JzZXJ2ZSIsImludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZUludGVyc2VjdGlvbiIsIm1heWJlTWVhc3VyZSIsImNvbnRhaW5lciIsInRvb2x0aXAiLCJzaG91bGRNZWFzdXJlIiwibmV3Q29uZmlnIiwiYXJyb3ciLCJtYWtlQWJzb2x1dGUiLCJ0diIsImdldENvb3JkcyIsInNwYWNlIiwib3RoZXJzIiwidFZpZXciLCJhcnJvd0hlaWdodCIsIm5vT2Zmc2V0Iiwic3RyaWN0U2lkZSIsInNwYWNlVmVydCIsInJlc2l6ZSIsIm92ZXJsYXAiLCJzZXRMZWZ0U3R5bGUiLCJhcnJvd0xlZnQiLCJ0b2dnbGUiLCJwb3NpdGlvbmVkIiwiaXNOYU4iLCJib3JkZXJSaWdodCIsImJvcmRlclRvcENvbG9yIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJzaG93SG92ZXJUb29sdGlwIiwiaW5wdXRzIiwiSG92ZXJUb29sdGlwSG9zdCIsIm1vdW50ZWQiLCJjcmVhdGVIb3N0ZWRWaWV3IiwiaG9zdGVkVmlldyIsInBhc3NQcm9wIiwiZ2l2ZW4iLCJzaG93SG92ZXJUb29sdGlwSG9zdCIsImNvbXB1dGUiLCJIb3ZlclBsdWdpbiIsInNldEhvdmVyIiwiaG92ZXJUaW1lIiwiaG92ZXJUaW1lb3V0IiwicmVzdGFydFRpbWVvdXQiLCJsYXN0TW92ZSIsInRpbWUiLCJjaGVja0hvdmVyIiwibW91c2VsZWF2ZSIsInN0YXJ0SG92ZXIiLCJob3ZlcmVkIiwicG9zQ29vcmRzIiwiYmlkaSIsInJ0bCIsImZpbmRJbmRleCIsImlzSW5Ub29sdGlwIiwiaXNPdmVyUmFuZ2UiLCJpblRvb2x0aXAiLCJ3YXRjaFRvb2x0aXBMZWF2ZSIsIndhdGNoIiwidG9vbHRpcE1hcmdpbiIsImFycm93UmVjdCIsImRvY0JvdHRvbSIsImhvdmVyVG9vbHRpcCIsImhvdmVyU3RhdGUiLCJoaWRlT25DaGFuZ2UiLCJoaWRlT24iLCJhc3NpZ24iLCJjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCIsImdldFRvb2x0aXAiLCJoYXNIb3ZlclRvb2x0aXBzIiwiY2xvc2VIb3ZlclRvb2x0aXBzIiwicmVwb3NpdGlvblRvb2x0aXBzIiwicGFuZWxDb25maWciLCJ0b3BDb250YWluZXIiLCJib3R0b21Db250YWluZXIiLCJwYW5lbHMiLCJnZXRQYW5lbCIsInBhbmVsIiwicGFuZWxQbHVnaW4iLCJzaG93UGFuZWwiLCJQYW5lbEdyb3VwIiwic3luY0NsYXNzZXMiLCJzY3JvbGxNYXJnaW4iLCJzeW5jRE9NIiwiY3VyRE9NIiwicm0iLCJzaG93RGlhbG9nIiwicHJvbWlzZSIsInBhbmVsQ3RvciIsImNyZWF0ZURpYWxvZyIsImRpYWxvZ0ZpZWxkIiwib3BlbkRpYWxvZ0VmZmVjdCIsImFwcGVuZENvbmZpZyIsImluaXQiLCJjbG9zZSIsImNsb3NlRGlhbG9nRWZmZWN0IiwiZm9ybSIsInF1ZXVlTWljcm90YXNrIiwiZ2V0RGlhbG9nIiwiZGlhbG9ncyIsImNvbXB1dGVOIiwibGFiZWwiLCJzdWJtaXRMYWJlbCIsImZvcm1zIiwicXVlcnlTZWxlY3RvckFsbCIsIm9uY2xpY2siLCJHdXR0ZXJNYXJrZXIiLCJlbGVtZW50Q2xhc3MiLCJndXR0ZXJMaW5lQ2xhc3MiLCJndXR0ZXJXaWRnZXRDbGFzcyIsImRlZmF1bHRzIiwicmVuZGVyRW1wdHlFbGVtZW50cyIsImVsZW1lbnRTdHlsZSIsImxpbmVNYXJrZXIiLCJ3aWRnZXRNYXJrZXIiLCJsaW5lTWFya2VyQ2hhbmdlIiwiaW5pdGlhbFNwYWNlciIsInVwZGF0ZVNwYWNlciIsImFjdGl2ZUd1dHRlcnMiLCJndXR0ZXIiLCJndXR0ZXJzIiwidW5maXhHdXR0ZXJzIiwiZ3V0dGVyVmlldyIsImZpeGVkIiwiZG9tQWZ0ZXIiLCJwcmV2Vmlld3BvcnQiLCJTaW5nbGVHdXR0ZXJWaWV3IiwiZ2V0RE9NQWZ0ZXIiLCJzeW5jR3V0dGVycyIsInVwZGF0ZUd1dHRlcnMiLCJ2cEEiLCJ2cEIiLCJ2cE92ZXJsYXAiLCJkZXRhY2giLCJsaW5lQ2xhc3NlcyIsImNsYXNzU2V0IiwiY29udGV4dHMiLCJVcGRhdGVDb250ZXh0IiwiYWR2YW5jZUN1cnNvciIsImN4IiwiYXNBcnJheSIsImNvbGxlY3QiLCJhZGRFbGVtZW50IiwiZWxlbWVudHMiLCJuZXdFbHQiLCJHdXR0ZXJFbGVtZW50IiwiZXh0cmFNYXJrZXJzIiwibG9jYWxNYXJrZXJzIiwiZm9yTGluZSIsInNwYWNlciIsInByb3AiLCJwcmV2TWFya2VycyIsInNhbWVNYXJrZXJzIiwic2V0TWFya2VycyIsImRvbVBvcyIsImlOZXciLCJpT2xkIiwic2tpcFRvIiwibWF0Y2hlZCIsImxpbmVOdW1iZXJNYXJrZXJzIiwibGluZU51bWJlcldpZGdldE1hcmtlciIsImxpbmVOdW1iZXJDb25maWciLCJmb3JtYXROdW1iZXIiLCJOdW1iZXJNYXJrZXIiLCJsaW5lTnVtYmVyR3V0dGVyIiwibWF4TGluZU51bWJlciIsImxpbmVOdW1iZXJzIiwiYWN0aXZlTGluZUd1dHRlck1hcmtlciIsImFyZ3VtZW50cyIsImFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciIsImhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIiLCJtYXRjaGVyIiwidSIsInRhYkRlY28iLCJzcGFjZURlY28iLCJ3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIiLCJoaWdobGlnaHRXaGl0ZXNwYWNlIiwidHJhaWxpbmdIaWdobGlnaHRlciIsImhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSIsIl9fdGVzdCIsImdldEhlaWdodENoYW5nZUZsYWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@codemirror+view@6.39.11/node_modules/@codemirror/view/dist/index.js\n");

/***/ })

};
;